! Copyright (C) Dylan Jayatilaka, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: run_compare_cifs $

program run_COMPARE_CIFS

   implicit none

   command_line :: COMMAND_LINE
   refcif,cmpcif,head,label :: STR
   op,cl :: STR(len=1)
   ref_atom,cmp_atom :: ATOM*
   ref,cmp :: MOLECULE*
   n_atom,a,n_H_atoms,n_X_atoms,n :: INT
   UI1,UI2 :: MAT{REAL}(3,3)
   rADP_vector,rADP_errors :: VEC{REAL}(6)
   cADP_vector,cADP_errors :: VEC{REAL}(6)
   ADP_abs,ADP_ab2 :: VEC{REAL}(6)
   ADP_dfs,ADP_df2 :: VEC{REAL}(6)
   ADP_sig,ADP_siv :: VEC{REAL}(6)
   ADP_rat,ADP_ra2 :: VEC{REAL}(3)
   rUiso_val,cUiso_val :: REAL
   rUiso_err,cUiso_err :: REAL
   Uiso_abs          :: REAL
   Uiso_dfs,Uiso_df2 :: REAL
   Uiso_sig,Uiso_siv :: REAL
   Uiso_rat,Uiso_ra2 :: REAL
   rMani_val,cMani_val :: REAL
   rMani_err,cMani_err :: REAL
   Mani_abs          :: REAL
   Mani_dfs,Mani_df2 :: REAL
   Mani_sig,Mani_siv :: REAL
   Mani_rat,Mani_ra2 :: REAL
   RMSD :: REAL
   tmp,fac :: REAL
   S12 :: REAL

   ! Create Tonto system object
   ! Initialise MPI parallel stuff too.
   TONTO_CREATE

   ! Initialise standard I/O files.
   std_time.start_timing

   stderr.create_stderr; stderr.open_for("write")
   stdout.create_stdout

   ! Initialize miscellaneous ...
   GAUSSIAN_DATA:set_indices(GAUSSIAN_DATA_L_MAX)

   ! Get the command line
   command_line.process_options
   DIE_IF(NOT command_line.has_arguments,"Usage: run_compare_cifs -ref <reference-cif> <compared-cif>")
   DIE_IF(NOT command_line.n_args==1    ,"Usage: run_compare_cifs -ref <reference-cif> <compared-cif>")
   DIE_IF(NOT command_line.has_options  ,"Usage: run_compare_cifs -ref <reference-cif> <compared-cif>")
   DIE_IF(NOT command_line.n_options==1 ,"Usage: run_compare_cifs -ref <reference-cif> <compared-cif>")
   DIE_IF(command_line.option(1)/="ref" ,"Usage: run_compare_cifs -ref <reference-cif> <compared-cif>")

   ! Get options
   cmpcif = command_line.arg(1)
   refcif = command_line.option_value(1)
   head   = cmpcif.filename_head

   ! Create the molecules and process the CIFs
   ref.BASE:create
   cmp.BASE:create

   ref.cif.create
   cmp.cif.create

   ref.cif.set_file_name(refcif) 
   cmp.cif.set_file_name(cmpcif) 

   ref.CE:process_CIF
   cmp.CE:process_CIF

   ! NOTE: it does not check for CIF2 at this point, which can cause
   ! errors.

   ! Sanity checks
   DIE_IF(NOT ref.n_atom==cmp.n_atom,"different no. of atoms in each CIF")
   DIE_IF(NOT ref.atom(:).atomic_number.same_as(cmp.atom(:).atomic_number),"atom order is different in each CIF")

   ! Write the heavy atom data files
   n_atom = ref.n_atom

   ! Script banner
   stdout.flush
   stdout.text("# ============")
   stdout.text("# Compare CIFs")
   stdout.text("# ============")
   stdout.flush
   stdout.text("# This program compares CIF geometries and ADPs and produces")
   stdout.text("# this gnuplot command file suitable for plotting.")
   stdout.flush
   stdout.show("# CIF file to compare   = ",cmpcif)
   stdout.show("# CIF file reference    = ",refcif)

   ! Save & reset precisions
   stdout.save
   stdout.set_real_width(25)
   stdout.set_real_precision(16)

   ! Heavy atom positions
   stdout.redirect(trim(head)//".non_h_atoms.fcoords")

   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number<=1) cycle

      label = ref_atom.label

      stdout.put(trim(label)//"x")
      stdout.put(ref_atom.pADP_vector(1))
      stdout.put(ref_atom.pADP_errors(1))
      stdout.put(cmp_atom.pADP_vector(1))
      stdout.put(cmp_atom.pADP_errors(1))
      stdout.flush

      stdout.put(trim(label)//"y")
      stdout.put(ref_atom.pADP_vector(2))
      stdout.put(ref_atom.pADP_errors(2))
      stdout.put(cmp_atom.pADP_vector(2))
      stdout.put(cmp_atom.pADP_errors(2))
      stdout.flush

      stdout.put(trim(label)//"z")
      stdout.put(ref_atom.pADP_vector(3))
      stdout.put(ref_atom.pADP_errors(3))
      stdout.put(cmp_atom.pADP_vector(3))
      stdout.put(cmp_atom.pADP_errors(3))
      stdout.flush

   end

   stdout.revert

   ! H atom positions

   stdout.redirect(trim(head)//".the_h_atoms.fcoords")

   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number>1) cycle

      label = ref_atom.label

      stdout.put(trim(label)//"x")
      stdout.put(ref_atom.pADP_vector(1))
      stdout.put(ref_atom.pADP_errors(1))
      stdout.put(cmp_atom.pADP_vector(1))
      stdout.put(cmp_atom.pADP_errors(1))
      stdout.flush

      stdout.put(trim(label)//"y")
      stdout.put(ref_atom.pADP_vector(2))
      stdout.put(ref_atom.pADP_errors(2))
      stdout.put(cmp_atom.pADP_vector(2))
      stdout.put(cmp_atom.pADP_errors(2))
      stdout.flush

      stdout.put(trim(label)//"z")
      stdout.put(ref_atom.pADP_vector(3))
      stdout.put(ref_atom.pADP_errors(3))
      stdout.put(cmp_atom.pADP_vector(3))
      stdout.put(cmp_atom.pADP_errors(3))
      stdout.flush

   end

   ! Heavy atom ADPs

   stdout.redirect(trim(head)//".non_h_atoms.ADPs")

   ! Absolute, absolute-square & difference sum
   ! For each ADP
  ! ADP_dfs = ZERO; ADP_df2 = ZERO
  ! ADP_abs = ZERO; ADP_ab2 = ZERO
  ! ADP_sig = ZERO; ADP_siv = ZERO
  ! ADP_rat = ZERO; ADP_ra2 = ZERO

  ! Uiso_dfs = ZERO
  ! Uiso_df2 = ZERO
  ! Uiso_abs = ZERO
  ! Uiso_siv = ZERO
  ! Uiso_sig = ZERO
  ! Uiso_rat = ZERO
  ! Uiso_ra2 = ZERO

  ! Mani_dfs = ZERO
  ! Mani_df2 = ZERO
  ! Mani_abs = ZERO
  ! Mani_siv = ZERO
  ! Mani_sig = ZERO
  ! Mani_rat = ZERO
  ! Mani_ra2 = ZERO

   n_X_atoms = 0

   fac = ANGSTROM_PER_BOHR
   fac = fac*fac

   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number<=1) cycle

      n_X_atoms = n_X_atoms + 1

      label = ref_atom.label

      rUiso_val = ref_atom.U_iso*fac
      rUiso_err = ref_atom.U_iso_error*fac
      cUiso_val = cmp_atom.U_iso*fac
      cUiso_err = cmp_atom.U_iso_error*fac

!      RMSD = sqrt((cUiso_val-rUiso_val)**2/((cUiso_err)**2 + (rUiso_err)**2))

      stdout.put(trim(label)//":Uiso")
      stdout.put(rUiso_val)
      stdout.put(rUiso_err)
      stdout.put(cUiso_val)
      stdout.put(cUiso_err)
!      stdout.put(RMSD)
      stdout.flush
   
   end

   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number<=1) cycle

      label = ref_atom.label

      ! Note the factor squared here comes from the Mani value already
      ! including the factor, so this needs to be accounted for
      rMani_val = ref_atom.M_ani*fac
      rMani_err = ref_atom.M_ani_error*fac
      cMani_val = cmp_atom.M_ani*fac
      cMani_err = cmp_atom.M_ani_error*fac

!      RMSD = (cMani_val-rMani_val)/rMani_val*100

      stdout.put(trim(label)//":Mani")
      stdout.put(rMani_val)
      stdout.put(rMani_err)
      stdout.put(cMani_val)
      stdout.put(cMani_err)
!      stdout.put(RMSD)
      stdout.flush

   end
!      rADP_vector = ref_atom.pADP_vector(4:9)
!      rADP_errors = ref_atom.pADP_errors(4:9)
!      cADP_vector = cmp_atom.pADP_vector(4:9)
!      cADP_errors = cmp_atom.pADP_errors(4:9)
!      rADP_vector.convert_to("angstrom^2")
!      rADP_errors.convert_to("angstrom^2")
!      cADP_vector.convert_to("angstrom^2")
!      cADP_errors.convert_to("angstrom^2")
!
!    ! where (abs(rADP_errors)<TOL(7)) rADP_errors = ONE
!    ! where (abs(cADP_errors)<TOL(7)) cADP_errors = ONE
!
!      stdout.put(trim(label)//"Uxx")
!      stdout.put(rADP_vector(1))
!      stdout.put(rADP_errors(1))
!      stdout.put(cADP_vector(1))
!      stdout.put(cADP_errors(1))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uyy")
!      stdout.put(rADP_vector(2))
!      stdout.put(rADP_errors(2))
!      stdout.put(cADP_vector(2))
!      stdout.put(cADP_errors(2))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uzz")
!      stdout.put(rADP_vector(3))
!      stdout.put(rADP_errors(3))
!      stdout.put(cADP_vector(3))
!      stdout.put(cADP_errors(3))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uxy")
!      stdout.put(rADP_vector(4))
!      stdout.put(rADP_errors(4))
!      stdout.put(cADP_vector(4))
!      stdout.put(cADP_errors(4))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uxz")
!      stdout.put(rADP_vector(5))
!      stdout.put(rADP_errors(5))
!      stdout.put(cADP_vector(5))
!      stdout.put(cADP_errors(5))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uyz")
!      stdout.put(rADP_vector(6))
!      stdout.put(rADP_errors(6))
!      stdout.put(cADP_vector(6))
!      stdout.put(cADP_errors(6))
!      stdout.flush
      
   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number<=1) cycle

      label = ref_atom.label
      
      UI1.to_inverse_of(ref_atom.ADP_tensor)
      UI2.to_inverse_of(cmp_atom.ADP_tensor)

      S12 = UI1.S12_with_ADP(UI2) 
      
      stdout.put(trim(label)//"S12:")
      stdout.put(S12)
      stdout.flush
  !    Uiso_dfs = Uiso_dfs + cUiso_val-rUiso_val
  !    Uiso_df2 = Uiso_df2 + (cUiso_val-rUiso_val)**2
  !    Uiso_abs = Uiso_abs + abs(cUiso_val-rUiso_val)
  !    Uiso_siv = Uiso_siv + (cUiso_val-rUiso_val)/sqrt(rUiso_err**2+cUiso_err**2)
  !    Uiso_sig = Uiso_sig + (cUiso_val-rUiso_val)**2/(rUiso_err**2+cUiso_err**2)
  !    Uiso_rat = Uiso_rat + cUiso_val/rUiso_val
  !    Uiso_ra2 = Uiso_rat + (cUiso_val/rUiso_val)**2

  !    Mani_dfs = Mani_dfs + cMani_val-rMani_val
  !    Mani_df2 = Mani_df2 + (cMani_val-rMani_val)**2
  !    Mani_abs = Mani_abs + abs(cMani_val-rMani_val)
  !    Mani_siv = Mani_siv + (cMani_val-rMani_val)/sqrt(rMani_err**2+cMani_err**2)
  !    Mani_sig = Mani_sig + (cMani_val-rMani_val)**2/(rMani_err**2+cMani_err**2)
  !    Mani_rat = Mani_rat + cMani_val/rMani_val
  !    Mani_ra2 = Mani_rat + (cMani_val/rMani_val)**2

  !    stdout.show("a    =",a)
  !    stdout.show("n    =",n_X_atoms)
  !    stdout.show("siv  =",Mani_siv)
  !    stdout.show("siv top =",cMani_val-rMani_val)
  !    stdout.show("siv bot =",sqrt(rMani_err**2+cMani_err**2))
  !    stdout.show("sig  =",Mani_sig)
  !    stdout.show("sig top =",(cMani_val-rMani_val)**2)
  !    stdout.show("sig bot =",rMani_err**2+cMani_err**2)

   end

   n = n_X_atoms

  ! stdout.flush
  ! stdout.text("# U_iso figures of merit:")
  ! tmp = Uiso_dfs/n
  ! stdout.show("# < Del U_iso >             =",tmp)
  ! stdout.show("# error in above            =",sqrt(Uiso_df2/n-tmp*tmp))

  ! tmp = Uiso_abs/n
  ! stdout.show("# <|Del U_iso|>             =",tmp)
  ! stdout.show("# error in above            =",sqrt(Uiso_df2/n-tmp**2))

  ! tmp = Uiso_df2/n
  ! stdout.show("# <(Del U_iso)^2>^{1/2}     =",sqrt(Uiso_df2/n))
  ! stdout.show("# error in above            =",sqrt(Uiso_df2/n-tmp**2))

  ! tmp = Uiso_siv/n
  ! stdout.show("# <(Del U_iso/sig)^2>^{1/2} =",sqrt(Uiso_sig/n))
  ! stdout.show("# error in above            =",sqrt(Uiso_sig/n-tmp**2))

  ! stdout.flush
  ! stdout.text("# M_ani figures of merit:")
  ! tmp = Mani_dfs/n
  ! stdout.show("# < Del M_ani >             =",tmp)
  ! stdout.show("# error in above            =",sqrt(Mani_df2/n-tmp*tmp))

  ! tmp = Mani_abs/n
  ! stdout.show("# <|Del M_ani|>             =",tmp)
  ! stdout.show("# error in above            =",sqrt(Mani_df2/n-tmp**2))

  ! tmp = Mani_df2/n
  ! stdout.show("# <(Del M_ani)^2>^{1/2}     =",sqrt(Mani_df2/n))
  ! stdout.show("# error in above            =",sqrt(Mani_df2/n-tmp**2))

  ! tmp = Mani_siv/n
  ! stdout.show("# <(Del M_ani/sig)^2>^{1/2} =",sqrt(Mani_sig/n))
  ! stdout.show("# error in above            =",sqrt(Mani_sig/n-tmp**2))

   ! Hydrogen atom ADPs

   stdout.redirect(trim(head)//".the_h_atoms.ADPs")
!
!   ! Absolute, absolute-square & difference sum
!   ! For each ADP
!   ADP_dfs = ZERO; ADP_df2 = ZERO
!   ADP_abs = ZERO; ADP_ab2 = ZERO
!   ADP_sig = ZERO; ADP_siv = ZERO
!   ADP_rat = ZERO; ADP_ra2 = ZERO
!
!   n_H_atoms = 0
!
   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number>1) cycle

      label = ref_atom.label

      rUiso_val = ref_atom.U_iso*fac
      rUiso_err = ref_atom.U_iso_error*fac
      cUiso_val = cmp_atom.U_iso*fac
      cUiso_err = cmp_atom.U_iso_error*fac

!      RMSD = sqrt((cUiso_val-rUiso_val)**2/((cUiso_err)**2 + (rUiso_err)**2))

      stdout.put(trim(label)//":Uiso")
      stdout.put(rUiso_val)
      stdout.put(rUiso_err)
      stdout.put(cUiso_val)
      stdout.put(cUiso_err)
!      stdout.put(RMSD)
      stdout.flush
   
   end 

   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number>1) cycle

      n_H_atoms = n_H_atoms + 1

      label = ref_atom.label

      ! Note the factor squared here comes from the Mani value already
      ! including the factor, so this needs to be accounted for
      rMani_val = ref_atom.M_ani*fac
      rMani_err = ref_atom.M_ani_error*fac
      cMani_val = cmp_atom.M_ani*fac
      cMani_err = cmp_atom.M_ani_error*fac

!      RMSD = (cMani_val-rMani_val)/rMani_val*100

      stdout.put(trim(label)//":Mani")
      stdout.put(rMani_val)
      stdout.put(rMani_err)
      stdout.put(cMani_val)
      stdout.put(cMani_err)
!      stdout.put(RMSD)
      stdout.flush
    
   end 
   
   do a = 1,n_atom

      ref_atom => ref.atom(a)
      cmp_atom => cmp.atom(a)

      if (ref_atom.atomic_number>1) cycle


      label = ref_atom.label

    ! where (abs(rADP_errors)<TOL(7)) rADP_errors = ONE
    ! where (abs(cADP_errors)<TOL(7)) cADP_errors = ONE

!      stdout.put(trim(label)//"Uxx")
!      stdout.put(rADP_vector(1))
!      stdout.put(rADP_errors(1))
!      stdout.put(cADP_vector(1))
!      stdout.put(cADP_errors(1))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uyy")
!      stdout.put(rADP_vector(2))
!      stdout.put(rADP_errors(2))
!      stdout.put(cADP_vector(2))
!      stdout.put(cADP_errors(2))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uzz")
!      stdout.put(rADP_vector(3))
!      stdout.put(rADP_errors(3))
!      stdout.put(cADP_vector(3))
!      stdout.put(cADP_errors(3))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uxy")
!      stdout.put(rADP_vector(4))
!      stdout.put(rADP_errors(4))
!      stdout.put(cADP_vector(4))
!      stdout.put(cADP_errors(4))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uxz")
!      stdout.put(rADP_vector(5))
!      stdout.put(rADP_errors(5))
!      stdout.put(cADP_vector(5))
!      stdout.put(cADP_errors(5))
!      stdout.flush
!
!      stdout.put(trim(label)//"Uyz")
!      stdout.put(rADP_vector(6))
!      stdout.put(rADP_errors(6))
!      stdout.put(cADP_vector(6))
!      stdout.put(cADP_errors(6))
!      stdout.flush
      
      UI1.to_inverse_of(ref_atom.ADP_tensor)
      UI2.to_inverse_of(cmp_atom.ADP_tensor)

      S12 = UI1.S12_with_ADP(UI2) 
      
      stdout.put(trim(label)//"S12:")
      stdout.put(S12)
      stdout.flush
!
!      ADP_dfs = ADP_dfs + cADP_vector-rADP_vector
!      ADP_df2 = ADP_df2 + (cADP_vector-rADP_vector)**2
!      ADP_abs = ADP_abs + abs(rADP_vector-cADP_vector)
!      ADP_ab2 = ADP_ab2 + abs(rADP_vector-cADP_vector)**2
!      ADP_siv = ADP_siv + (rADP_vector-cADP_vector)/sqrt(rADP_errors**2+cADP_errors**2)
!      ADP_sig = ADP_sig + (rADP_vector-cADP_vector)**2/(rADP_errors**2+cADP_errors**2)
!      ADP_rat = ADP_rat + cADP_vector(1:3)/rADP_vector(1:3)
!      ADP_ra2 = ADP_ra2 + (cADP_vector(1:3)/rADP_vector(1:3))**2
!
   end
   
   ! Include S/R12 values here Below is the routing from Mat Real.
   ! Need to pass in the inverse of the two ADP matrices.:


!   n = 6*n_H_atoms
!
!   stdout.flush
!   stdout.text("# U_ij figures of merit:")
!   tmp = sum(ADP_dfs)/n
!   stdout.show("# < Del U_ij >             =",tmp)
!   stdout.show("# error in above           =",sqrt(sum(ADP_df2)/n-tmp*tmp))
!
!   tmp = sum(ADP_abs)/n
!   stdout.show("# <|Del U_ij|>             =",tmp)
!   stdout.show("# error in above           =",sqrt(sum(ADP_ab2)/n-tmp**2))
!
!   tmp = sum(ADP_abs)/n
!   stdout.show("# <(Del U_ij)^2>^{1/2}     =",sqrt(sum(ADP_ab2)/n))
!   stdout.show("# error in above           =",sqrt(sum(ADP_ab2)/n-tmp**2))
!
!   tmp = sum(ADP_siv)/n
!   stdout.show("# <(Del U_ij/sig)^2>^{1/2} =",sqrt(sum(ADP_sig)/n))
!   stdout.show("# error in above           =",sqrt(sum(ADP_sig)/n-tmp**2))
!
!   n = 3*n_H_atoms
!
!   stdout.text("# U_ii figures of merit:")
! ! stdout.show("# < Del U_ii >             =",sum(ADP_dfs(1:3))/n)
! ! stdout.show("# <|Del U_ii|>             =",sum(ADP_abs(1:3))/n)
! ! stdout.show("# <(Del U_ii)^2>^{1/2}     =",sqrt(sum(ADP_ab2(1:3))/n))
! ! stdout.show("# <(Del U_ii/sig)^2>^{1/2} =",sqrt(sum(ADP_sig(1:3))/n))
!   tmp = sum(ADP_rat)/n
!   stdout.show("# <U_ii^X/U_ii^N>          =",tmp)
!   stdout.show("# Error in above           =",sqrt(sum(ADP_ra2)/n-tmp**2))
!
!   stdout.revert
!
!   ! Now make the gnuplot command file for histogram plots
!   ! "ga12.standard.h_atoms.xyz_data"
!
!   op = achar(91) ! open square-becaket
!   cl = achar(93) ! close square-bracket
!
!   stdout.redirect("compare.gnuplot")
!
!   stdout.text('# This gnuplot script compares two sets of CIF data.')
!   stdout.text('#')
!   stdout.text('# To use type:')
!   stdout.text('#    gnuplot -e "data='//"'<data-file>'"//'; title='//"'<title>'"//'" compare.gnuplot')
!   stdout.text('#')
!   stdout.text('# <data-file> has repeated lines of format:')
!   stdout.text('#    varname x dx y dy')
!   stdout.text('#')
!   stdout.text('# varname is the string label of the variable used as the x label.')
!   stdout.text('# x (resp. dx) is the reference data (resp. its error) and likewise for y.')
!   stdout.text('#')
!   stdout.text('# A histogram of deviation (y - x) divided by the compound mean is made.')
!   stdout.text('# The relative precision dy/dx is also displayed. A separate plot of the')
!   stdout.text('# the frequency distribution is also made. Its assumed the reference data')
!   stdout.text('# x (dx) are for neutrons, and the y (dy) data is for X-rays.')
!   stdout.text('# Change this script if you need to.')
!   stdout.text('psfile = data . "_histogram.ps"')
!   stdout.text('set output psfile')
!   stdout.text('set terminal postscript eps color enhanced')
!   stdout.text('set ylabel "Deviation (compound-{/Symbol s} units)"')
!   stdout.text('set xlabel title offset 0,-2')
!   stdout.text('set nokey')
!   stdout.text('set style fill solid 0.4')
!   stdout.text('set style histogram clustered')
!   stdout.text('set style data histograms')
!   stdout.text('set xtics 1')
!   stdout.text('set ytics 1')
!   stdout.text('set yrange '//op//'-10:10'//cl)
!   stdout.text('set grid ytics lc rgb "#7f7f7f" lw 1 lt 0')
!   stdout.text('set grid xtics lc rgb "#7f7f7f" lw 1 lt 0')
!   stdout.text('set xtics rotate')
!   stdout.text('sigma(x,y) = sqrt(x**2+y**2)')
!   stdout.text('dify(x,d,y,e) = (y - x)/sigma(d,e)')
!   stdout.text('plot \')
!   stdout.text('data using (dify($2,$3,$4,$5)):xticlabel(1)')
!   stdout.text('#')
!   stdout.text('psfile = data . "_frequency.ps"')
!   stdout.text('set output psfile')
!   stdout.text('set terminal postscript eps color enhanced')
!   stdout.text('set ylabel "Frequency"')
!   stdout.text('set xlabel "Deviation (compound-{/Symbol s} units)" offset 0,0')
!   stdout.text('set nokey')
!   stdout.text('set style fill solid 0.4')
!   stdout.text('set style histogram clustered')
!   stdout.text('set style data histograms')
!   stdout.text('set xrange '//op//'-6:6'//cl)
!   stdout.text('set yrange '//op//'0:10'//cl)
!   stdout.text('set xtics 1')
!   stdout.text('set ytics 1')
!   stdout.text('set xtics norotate')
!   stdout.text('set grid xtics lc rgb "#7f7f7f" lw 1 lt 0')
!   stdout.text('set grid ytics lc rgb "#7f7f7f" lw 1 lt 0')
!   stdout.text('sigma(x,y) = sqrt(x**2+y**2)')
!   stdout.text('dify(x,d,y,e) = (y - x)/sigma(d,e)')
!   stdout.text('bin(x,s) = s*floor(x/s)')
!   stdout.text('bw = 1.0')
!   stdout.text('set boxwidth bw*0.6')
!   stdout.text('plot \')
!   stdout.text('data using (bin(dify($2,$3,$4,$5),bw)+bw/2.0):(1.0) smooth frequency with boxes')

   ! Unsave stdout settings
   stdout.unsave

   ! Clean-up
   cmp.BASE:destroy
   ref.BASE:destroy

   ! Clean-up files
   TEXTFILE:destroy(stderr)
   TEXTFILE:destroy(stdout)

   ! Clean-up tonto system
   TONTO_DESTROY

end
