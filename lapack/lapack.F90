#include "macros"
#undef STACK
#undef E

  function ddot(n,dx,incx,dy,incy) result (res)

!     forms the dot product of two vectors.
!     uses unrolled loops for increments equal to one.
!     jack dongarra, linpack, 3/11/78.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  REAL dx(*),dy(*),dtemp,res
  INT i,incx,incy,ix,iy,m,mp1,n
!
  res = ZERO
  dtemp = ZERO
  if (n <= 0) return
  if (incx == 1 AND incy == 1)go to 20
!
!    code for unequal increments or equal increments
!      not equal to 1
!
  ix = 1
  iy = 1
  if (incx < 0)ix = (-n+1)*incx + 1
  if (incy < 0)iy = (-n+1)*incy + 1
  do 10 i = 1,n
    dtemp = dtemp + dx(ix)*dy(iy)
    ix = ix + incx
    iy = iy + incy
   10 continue
  res  = dtemp
  return
!
!    code for both increments equal to 1
!
!
!    clean-up loop
!
   20 m = mod(n,5)
  if ( m  ==  0 ) go to 40
  do 30 i = 1,m
    dtemp = dtemp + dx(i)*dy(i)
   30 continue
  if ( n  <  5 ) go to 60
   40 mp1 = m + 1
  do 50 i = mp1,n,5
    dtemp = dtemp + dx(i)*dy(i) + dx(i + 1)*dy(i + 1) + &
     dx(i + 2)*dy(i + 2) + dx(i + 3)*dy(i + 3) + dx(i + 4)*dy(i + 4)
   50 continue
   60 res  = dtemp
  end function


  SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )
!
!  -- LAPACK driver routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     March 31, 1993
!
!     .. Scalar Arguments ..
  INTEGER    INFO, LDA, LDB, N, NRHS
!     ..
!     .. Array Arguments ..
  INTEGER    IPIV( * )
  REAL   A( LDA, * ), B( LDB, * )
!     ..
!
!  Purpose
!  =======
!
!  DGESV computes the solution to a real system of linear equations
!     A * X = B,
!  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
!
!  The LU decomposition with partial pivoting and row interchanges is
!  used to factor A as
!     A = P * L * U,
!  where P is a permutation matrix, L is unit lower triangular, and U is
!  upper triangular.  The factored form of A is then used to solve the
!  system of equations A * X = B.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The number of linear equations, i.e., the order of the
!      matrix A.  N >= 0.
!
!  NRHS    (input) INTEGER
!      The number of right hand sides, i.e., the number of columns
!      of the matrix B.  NRHS >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the N-by-N coefficient matrix A.
!      On exit, the factors L and U from the factorization
!      A = P*L*U; the unit diagonal elements of L are not stored.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  IPIV    (output) INTEGER array, dimension (N)
!      The pivot indices that define the permutation matrix P;
!      row i of the matrix was interchanged with row IPIV(i).
!
!  B   (input/output) REAL array, dimension (LDB,NRHS)
!      On entry, the N-by-NRHS matrix of right hand side matrix B.
!      On exit, if INFO = 0, the N-by-NRHS solution matrix X.
!
!  LDB     (input) INTEGER
!      The leading dimension of the array B.  LDB >= max(1,N).
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
!        has been completed, but the factor U is exactly
!        singular, so the solution could not be computed.
!
!  =====================================================================
!
!     .. External Subroutines ..
  EXTERNAL       DGETRF, DGETRS, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  INFO = 0
  IF( N < 0 ) THEN
     INFO = -1
  ELSE IF( NRHS < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  ELSE IF( LDB < MAX( 1, N ) ) THEN
     INFO = -7
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DGESV ', -INFO )
     RETURN
  END IF
!
!     Compute the LU factorization of A.
!
  CALL DGETRF( N, N, A, LDA, IPIV, INFO )
  IF( INFO == 0 ) THEN
!
!    Solve the system A*X = B, overwriting B with X.
!
     CALL DGETRS( 'No transpose', N, NRHS, A, LDA, IPIV, B, LDB, INFO )
  END IF
  RETURN
!
!     End of DGESV
!
  END

  SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  INTEGER    IPIV( * )
  REAL   A( LDA, * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DGETRI computes the inverse of a matrix using the LU factorization
!  computed by DGETRF.
!
!  This method inverts U and then computes inv(A) by solving the system
!  inv(A)*L = inv(U) for inv(A).
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the factors L and U from the factorization
!      A = P*L*U as computed by DGETRF.
!      On exit, if INFO = 0, the inverse of the original matrix A.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  IPIV    (input) INTEGER array, dimension (N)
!      The pivot indices from DGETRF; for 1<=i<=N, row i of the
!      matrix was interchanged with row IPIV(i).
!
!  WORK    (workspace/output) REAL array, dimension (LWORK)
!      On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK.  LWORK >= max(1,N).
!      For optimal performance LWORK >= N*NB, where NB is
!      the optimal blocksize returned by ILAENV.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
!        singular and its inverse could not be computed.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY
  INTEGER    I, IWS, J, JB, JJ, JP, LDWORK, LWKOPT, NB, NBMIN, NN
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. External Subroutines ..
  EXTERNAL       DGEMM, DGEMV, DSWAP, DTRSM, DTRTRI, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  INFO = 0
  NB = ILAENV( 1, 'DGETRI', ' ', N, -1, -1, -1 )
  LWKOPT = N*NB
  WORK( 1 ) = LWKOPT
  LQUERY = ( LWORK == -1 )
  IF( N < 0 ) THEN
     INFO = -1
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -3
  ELSE IF( LWORK < MAX( 1, N )  AND   NOT LQUERY ) THEN
     INFO = -6
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DGETRI', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
!     Form inv(U).  If INFO > 0 from DTRTRI, then U is singular,
!     and the inverse is not computed.
!
  CALL DTRTRI( 'Upper', 'Non-unit', N, A, LDA, INFO )
  IF( INFO > 0 ) RETURN
!
  NBMIN = 2
  LDWORK = N
  IF( NB > 1  AND  NB < N ) THEN
     IWS = MAX( LDWORK*NB, 1 )
     IF( LWORK < IWS ) THEN
    NB = LWORK / LDWORK
    NBMIN = MAX( 2, ILAENV( 2, 'DGETRI', ' ', N, -1, -1, -1 ) )
     END IF
  ELSE
     IWS = N
  END IF
!
!     Solve the equation inv(A)*L = inv(U) for inv(A).
!
  IF( NB < NBMIN  OR  NB.GE.N ) THEN
!
!    Use unblocked code.
!
     DO 20 J = N, 1, -1
!
!       Copy current column of L to WORK and replace with zeros.
!
    DO 10 I = J + 1, N
       WORK( I ) = A( I, J )
       A( I, J ) = ZERO
   10   CONTINUE
!
!       Compute current column of inv(A).
!
    IF( J < N ) &
       CALL DGEMV( 'No transpose', N, N-J, -ONE, A( 1, J+1 ), &
           LDA, WORK( J+1 ), 1, ONE, A( 1, J ), 1 )
   20    CONTINUE
  ELSE
!
!    Use blocked code.
!
     NN = ( ( N-1 ) / NB )*NB + 1
     DO 50 J = NN, 1, -NB
    JB = MIN( NB, N-J+1 )
!
!       Copy current block column of L to WORK and replace with
!       zeros.
!
    DO 40 JJ = J, J + JB - 1
       DO 30 I = JJ + 1, N
      WORK( I+( JJ-J )*LDWORK ) = A( I, JJ )
      A( I, JJ ) = ZERO
   30      CONTINUE
   40   CONTINUE
!
!       Compute current block column of inv(A).
!
    IF( J+JB <= N ) &
       CALL DGEMM( 'No transpose', 'No transpose', N, JB, &
           N-J-JB+1, -ONE, A( 1, J+JB ), LDA, &
           WORK( J+JB ), LDWORK, ONE, A( 1, J ), LDA )
    CALL DTRSM( 'Right', 'Lower', 'No transpose', 'Unit', N, JB, &
        ONE, WORK( J ), LDWORK, A( 1, J ), LDA )
   50    CONTINUE
  END IF
!
!     Apply column interchanges.
!
  DO 60 J = N - 1, 1, -1
     JP = IPIV( J )
     IF( JP/=J ) CALL DSWAP( N, A( 1, J ), 1, A( 1, JP ), 1 )
   60 CONTINUE
!
  WORK( 1 ) = IWS
  RETURN
!
!     End of DGETRI
!
  END

  SUBROUTINE DGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     March 31, 1993
!
!     .. Scalar Arguments ..
  CHR      TRANS
  INTEGER    INFO, LDA, LDB, N, NRHS
!     ..
!     .. Array Arguments ..
  INTEGER    IPIV( * )
  REAL   A( LDA, * ), B( LDB, * )
!     ..
!
!  Purpose
!  =======
!
!  DGETRS solves a system of linear equations
!     A * X = B  or  A' * X = B
!  with a general N-by-N matrix A using the LU factorization computed
!  by DGETRF.
!
!  Arguments
!  =========
!
!  TRANS   (input) STR(len=1)
!      Specifies the form of the system of equations:
!      = 'N':  A * X = B  (No transpose)
!      = 'T':  A'* X = B  (Transpose)
!      = 'C':  A'* X = B  (Conjugate transpose = Transpose)
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  NRHS    (input) INTEGER
!      The number of right hand sides, i.e., the number of columns
!      of the matrix B.  NRHS >= 0.
!
!  A   (input) REAL array, dimension (LDA,N)
!      The factors L and U from the factorization A = P*L*U
!      as computed by DGETRF.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  IPIV    (input) INTEGER array, dimension (N)
!      The pivot indices from DGETRF; for 1<=i<=N, row i of the
!      matrix was interchanged with row IPIV(i).
!
!  B   (input/output) REAL array, dimension (LDB,NRHS)
!      On entry, the right hand side matrix B.
!      On exit, the solution matrix X.
!
!  LDB     (input) INTEGER
!      The leading dimension of the array B.  LDB >= max(1,N).
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    NOTRAN
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLASWP, DTRSM, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  INFO = 0
  NOTRAN =  scan( TRANS, 'Nn' )>0
  IF(  NOT NOTRAN  AND   NOT  scan( TRANS, 'Tt' )>0  AND   NOT  &
       scan( TRANS, 'Cc' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( NRHS < 0 ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -5
  ELSE IF( LDB < MAX( 1, N ) ) THEN
     INFO = -8
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DGETRS', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0  OR  NRHS == 0 ) RETURN
!
  IF( NOTRAN ) THEN
!
!    Solve A * X = B.
!
!    Apply row interchanges to the right hand sides.
!
     CALL DLASWP( NRHS, B, LDB, 1, N, IPIV, 1 )
!
!    Solve L*X = B, overwriting B with X.
!
     CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', N, NRHS, &
         ONE, A, LDA, B, LDB )
!
!    Solve U*X = B, overwriting B with X.
!
     CALL DTRSM( 'Left', 'Upper', 'No transpose', 'Non-unit', N, &
         NRHS, ONE, A, LDA, B, LDB )
  ELSE
!
!    Solve A' * X = B.
!
!    Solve U'*X = B, overwriting B with X.
!
     CALL DTRSM( 'Left', 'Upper', 'Transpose', 'Non-unit', N, NRHS, &
         ONE, A, LDA, B, LDB )
!
!    Solve L'*X = B, overwriting B with X.
!
     CALL DTRSM( 'Left', 'Lower', 'Transpose', 'Unit', N, NRHS, ONE, &
         A, LDA, B, LDB )
!
!    Apply row interchanges to the solution vectors.
!
     CALL DLASWP( NRHS, B, LDB, 1, N, IPIV, -1 )
  END IF
!
  RETURN
!
!     End of DGETRS
!
  END

  SUBROUTINE DLADIV( A, B, C, D, P, Q )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  REAL   A, B, C, D, P, Q
!     ..
!
!  Purpose
!  =======
!
!  DLADIV performs complex division in  real arithmetic
!
!        a + i*b
!     p + i*q = ---------
!        c + i*d
!
!  The algorithm is due to Robert L. Smith and can be found
!  in D. Knuth, The art of Computer Programming, Vol.2, p.195
!
!  Arguments
!  =========
!
!  A   (input) REAL
!  B   (input) REAL
!  C   (input) REAL
!  D   (input) REAL
!      The scalars a, b, c, and d in the above expression.
!
!  P   (output) REAL
!  Q   (output) REAL
!      The scalars p and q in the above expression.
!
!  =====================================================================
!
!     .. Local Scalars ..
  REAL   E, F
!     ..
!     .. Executable Statements ..
!
  IF( ABS( D ) < ABS( C ) ) THEN
     E = D / C
     F = C + D*E
     P = ( A+B*E ) / F
     Q = ( B-A*E ) / F
  ELSE
     E = C / D
     F = D + C*E
     P = ( B+A*E ) / F
     Q = ( -A+B*E ) / F
  END IF
!
  RETURN
!
!     End of DLADIV
!
  END

  SUBROUTINE DLAE2( A, B, C, RT1, RT2 )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  REAL   A, B, C, RT1, RT2
!     ..
!
!  Purpose
!  =======
!
!  DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
!     [  A   B  ]
!     [  B   C  ].
!  On return, RT1 is the eigenvalue of larger absolute value, and RT2
!  is the eigenvalue of smaller absolute value.
!
!  Arguments
!  =========
!
!  A   (input) REAL
!      The (1,1) element of the 2-by-2 matrix.
!
!  B   (input) REAL
!      The (1,2) and (2,1) elements of the 2-by-2 matrix.
!
!  C   (input) REAL
!      The (2,2) element of the 2-by-2 matrix.
!
!  RT1     (output) REAL
!      The eigenvalue of larger absolute value.
!
!  RT2     (output) REAL
!      The eigenvalue of smaller absolute value.
!
!  Further Details
!  ===============
!
!  RT1 is accurate to a few ulps barring over/underflow.
!
!  RT2 may be inaccurate if there is massive cancellation in the
!  determinant A*C-B*B; higher precision or correctly rounded or
!  correctly truncated arithmetic would be needed to compute RT2
!  accurately in all cases.
!
!  Overflow is possible only if RT1 is within a factor of 5 of overflow.
!  Underflow is harmless if the input data is 0 or exceeds
!     underflow_threshold / macheps.
!
! =====================================================================
!
!     .. Local Scalars ..
  REAL   AB, ACMN, ACMX, ADF, DF, RT, SM, TB
!     ..
!     .. Executable Statements ..
!
!     Compute the eigenvalues
!
  SM = A + C
  DF = A - C
  ADF = ABS( DF )
  TB = B + B
  AB = ABS( TB )
  IF( ABS( A ) > ABS( C ) ) THEN
     ACMX = A
     ACMN = C
  ELSE
     ACMX = C
     ACMN = A
  END IF
  IF( ADF > AB ) THEN
     RT = ADF*SQRT( ONE+( AB / ADF )**2 )
  ELSE IF( ADF < AB ) THEN
     RT = AB*SQRT( ONE+( ADF / AB )**2 )
  ELSE
!
!    Includes case AB=ADF=0
!
     RT = AB*SQRT( TWO )
  END IF
  IF( SM < ZERO ) THEN
     RT1 = HALF*( SM-RT )
!
!    Order of execution important.
!    To get fully accurate smaller eigenvalue,
!    next line needs to be executed in higher precision.
!
     RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
  ELSE IF( SM > ZERO ) THEN
     RT1 = HALF*( SM+RT )
!
!    Order of execution important.
!    To get fully accurate smaller eigenvalue,
!    next line needs to be executed in higher precision.
!
     RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
  ELSE
!
!    Includes case RT1 = RT2 = 0
!
     RT1 = HALF*RT
     RT2 = -HALF*RT
  END IF
  RETURN
!
!     End of DLAE2
!
  END

  SUBROUTINE DLAEV2( A, B, C, RT1, RT2, CS1, SN1 )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  REAL   A, B, C, CS1, RT1, RT2, SN1
!     ..
!
!  Purpose
!  =======
!
!  DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
!     [  A   B  ]
!     [  B   C  ].
!  On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
!  eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
!  eigenvector for RT1, giving the decomposition
!
!     [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
!     [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
!
!  Arguments
!  =========
!
!  A   (input) REAL
!      The (1,1) element of the 2-by-2 matrix.
!
!  B   (input) REAL
!      The (1,2) element and the conjugate of the (2,1) element of
!      the 2-by-2 matrix.
!
!  C   (input) REAL
!      The (2,2) element of the 2-by-2 matrix.
!
!  RT1     (output) REAL
!      The eigenvalue of larger absolute value.
!
!  RT2     (output) REAL
!      The eigenvalue of smaller absolute value.
!
!  CS1     (output) REAL
!  SN1     (output) REAL
!      The vector (CS1, SN1) is a unit right eigenvector for RT1.
!
!  Further Details
!  ===============
!
!  RT1 is accurate to a few ulps barring over/underflow.
!
!  RT2 may be inaccurate if there is massive cancellation in the
!  determinant A*C-B*B; higher precision or correctly rounded or
!  correctly truncated arithmetic would be needed to compute RT2
!  accurately in all cases.
!
!  CS1 and SN1 are accurate to a few ulps barring over/underflow.
!
!  Overflow is possible only if RT1 is within a factor of 5 of overflow.
!  Underflow is harmless if the input data is 0 or exceeds
!     underflow_threshold / macheps.
!
! =====================================================================
!
!     .. Local Scalars ..
  INTEGER    SGN1, SGN2
  REAL   AB, ACMN, ACMX, ACS, ADF, CS, CT, DF, RT, SM, TB, TN
!     ..
!     .. Executable Statements ..
!
!     Compute the eigenvalues
!
  SM = A + C
  DF = A - C
  ADF = ABS( DF )
  TB = B + B
  AB = ABS( TB )
  IF( ABS( A ) > ABS( C ) ) THEN
     ACMX = A
     ACMN = C
  ELSE
     ACMX = C
     ACMN = A
  END IF
  IF( ADF > AB ) THEN
     RT = ADF*SQRT( ONE+( AB / ADF )**2 )
  ELSE IF( ADF < AB ) THEN
     RT = AB*SQRT( ONE+( ADF / AB )**2 )
  ELSE
!
!    Includes case AB=ADF=0
!
     RT = AB*SQRT( TWO )
  END IF
  IF( SM < ZERO ) THEN
     RT1 = HALF*( SM-RT )
     SGN1 = -1
!
!    Order of execution important.
!    To get fully accurate smaller eigenvalue,
!    next line needs to be executed in higher precision.
!
     RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
  ELSE IF( SM > ZERO ) THEN
     RT1 = HALF*( SM+RT )
     SGN1 = 1
!
!    Order of execution important.
!    To get fully accurate smaller eigenvalue,
!    next line needs to be executed in higher precision.
!
     RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
  ELSE
!
!    Includes case RT1 = RT2 = 0
!
     RT1 = HALF*RT
     RT2 = -HALF*RT
     SGN1 = 1
  END IF
!
!     Compute the eigenvector
!
  IF( DF.GE.ZERO ) THEN
     CS = DF + RT
     SGN2 = 1
  ELSE
     CS = DF - RT
     SGN2 = -1
  END IF
  ACS = ABS( CS )
  IF( ACS > AB ) THEN
     CT = -TB / CS
     SN1 = ONE / SQRT( ONE+CT*CT )
     CS1 = CT*SN1
  ELSE
     IF( AB == ZERO ) THEN
    CS1 = ONE
    SN1 = ZERO
     ELSE
    TN = -CS / TB
    CS1 = ONE / SQRT( ONE+TN*TN )
    SN1 = TN*CS1
     END IF
  END IF
  IF( SGN1 == SGN2 ) THEN
     TN = CS1
     CS1 = -SN1
     SN1 = TN
  END IF
  RETURN
!
!     End of DLAEV2
!
  END


  FUNCTION DLANST( NORM, N, D, E ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  CHR      NORM
  INTEGER    N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * )
  REAL   res
!     ..
!
!  Purpose
!  =======
!
!  DLANST  returns the value of the one norm,  or the Frobenius norm, or
!  the  infinity norm,  or the  element of  largest absolute value  of a
!  real symmetric tridiagonal matrix A.
!
!  Description
!  ===========
!
!  DLANST returns the value
!
!     DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
!      (
!      ( norm1(A),     NORM = '1', 'O' or 'o'
!      (
!      ( normI(A),     NORM = 'I' or 'i'
!      (
!      ( normF(A),     NORM = 'F', 'f', 'E' or 'e'
!
!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!  Arguments
!  =========
!
!  NORM    (input) STR(len=1)
!      Specifies the value to be returned in DLANST as described
!      above.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.  When N = 0, DLANST is
!      set to zero.
!
!  D   (input) REAL array, dimension (N)
!      The diagonal elements of A.
!
!  E   (input) REAL array, dimension (N-1)
!      The (n-1) sub-diagonal or super-diagonal elements of A.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I
  REAL   ANORM, SCALE, SUM
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLASSQ
!     ..
!     .. Executable Statements ..
!
  IF( N <= 0 ) THEN
     ANORM = ZERO
  ELSE IF(  scan( NORM, 'Mm' )>0 ) THEN
!
!    Find max(abs(A(i,j))).
!
     ANORM = ABS( D( N ) )
     DO 10 I = 1, N - 1
    ANORM = MAX( ANORM, ABS( D( I ) ) )
    ANORM = MAX( ANORM, ABS( E( I ) ) )
   10    CONTINUE
  ELSE IF(  scan( NORM, 'Oo' )>0  OR  NORM == '1'  OR  &
        scan( NORM, 'Ii' )>0 ) THEN
!
!    Find norm1(A).
!
     IF( N == 1 ) THEN
    ANORM = ABS( D( 1 ) )
     ELSE
    ANORM = MAX( ABS( D( 1 ) )+ABS( E( 1 ) ), &
        ABS( E( N-1 ) )+ABS( D( N ) ) )
    DO 20 I = 2, N - 1
       ANORM = MAX( ANORM, ABS( D( I ) )+ABS( E( I ) )+ ABS( E( I-1 ) ))
   20   CONTINUE
     END IF
  ELSE IF( scan( NORM, 'Ff' )>0  OR  scan( NORM, 'Ee' )>0 ) THEN
!
!    Find normF(A).
!
     SCALE = ZERO
     SUM = ONE
     IF( N > 1 ) THEN
    CALL DLASSQ( N-1, E, 1, SCALE, SUM )
    SUM = 2*SUM
     END IF
     CALL DLASSQ( N, D, 1, SCALE, SUM )
     ANORM = SCALE*SQRT( SUM )
  END IF
!
  res = ANORM
  RETURN
!
!     End of DLANST
!
  END function

  FUNCTION DLANSY( NORM, UPLO, N, A, LDA, WORK ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      NORM, UPLO
  INTEGER    LDA, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), WORK( * )
  REAL   res
!     ..
!
!  Purpose
!  =======
!
!  DLANSY  returns the value of the one norm,  or the Frobenius norm, or
!  the  infinity norm,  or the  element of  largest absolute value  of a
!  real symmetric matrix A.
!
!  Description
!  ===========
!
!  DLANSY returns the value
!
!     DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
!      (
!      ( norm1(A),     NORM = '1', 'O' or 'o'
!      (
!      ( normI(A),     NORM = 'I' or 'i'
!      (
!      ( normF(A),     NORM = 'F', 'f', 'E' or 'e'
!
!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!  Arguments
!  =========
!
!  NORM    (input) STR(len=1)
!      Specifies the value to be returned in DLANSY as described
!      above.
!
!  UPLO    (input) STR(len=1)
!      Specifies whether the upper or lower triangular part of the
!      symmetric matrix A is to be referenced.
!      = 'U':  Upper triangular part of A is referenced
!      = 'L':  Lower triangular part of A is referenced
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.  When N = 0, DLANSY is
!      set to zero.
!
!  A   (input) REAL array, dimension (LDA,N)
!      The symmetric matrix A.  If UPLO = 'U', the leading n by n
!      upper triangular part of A contains the upper triangular part
!      of the matrix A, and the strictly lower triangular part of A
!      is not referenced.  If UPLO = 'L', the leading n by n lower
!      triangular part of A contains the lower triangular part of
!      the matrix A, and the strictly upper triangular part of A is
!      not referenced.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(N,1).
!
!  WORK    (workspace) REAL array, dimension (LWORK),
!      where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
!      WORK is not referenced.
!
! =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J
  REAL   ABSA, SCALE, SUM, VALUE
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLASSQ
!     ..
!     .. Executable Statements ..
!
  IF( N == 0 ) THEN
     VALUE = ZERO
  ELSE IF(  scan( NORM, 'Mm' )>0 ) THEN
!
!    Find max(abs(A(i,j))).
!
     VALUE = ZERO
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 20 J = 1, N
       DO 10 I = 1, J
      VALUE = MAX( VALUE, ABS( A( I, J ) ) )
   10      CONTINUE
   20   CONTINUE
     ELSE
    DO 40 J = 1, N
       DO 30 I = J, N
      VALUE = MAX( VALUE, ABS( A( I, J ) ) )
   30      CONTINUE
   40   CONTINUE
     END IF
  ELSE IF( (  scan( NORM, 'IiOo1' )>0 ) ) THEN
!
!    Find normI(A) ( = norm1(A), since A is symmetric).
!
     VALUE = ZERO
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 60 J = 1, N
       SUM = ZERO
       DO 50 I = 1, J - 1
      ABSA = ABS( A( I, J ) )
      SUM = SUM + ABSA
      WORK( I ) = WORK( I ) + ABSA
   50      CONTINUE
       WORK( J ) = SUM + ABS( A( J, J ) )
   60   CONTINUE
    DO 70 I = 1, N
       VALUE = MAX( VALUE, WORK( I ) )
   70   CONTINUE
     ELSE
    DO 80 I = 1, N
       WORK( I ) = ZERO
   80   CONTINUE
    DO 100 J = 1, N
       SUM = WORK( J ) + ABS( A( J, J ) )
       DO 90 I = J + 1, N
      ABSA = ABS( A( I, J ) )
      SUM = SUM + ABSA
      WORK( I ) = WORK( I ) + ABSA
   90      CONTINUE
       VALUE = MAX( VALUE, SUM )
  100   CONTINUE
     END IF
  ELSE IF( scan( NORM, 'Ff' )>0  OR  scan( NORM, 'Ee' )>0 ) THEN
!
!    Find normF(A).
!
     SCALE = ZERO
     SUM = ONE
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 110 J = 2, N
       CALL DLASSQ( J-1, A( 1, J ), 1, SCALE, SUM )
  110   CONTINUE
     ELSE
    DO 120 J = 1, N - 1
       CALL DLASSQ( N-J, A( J+1, J ), 1, SCALE, SUM )
  120   CONTINUE
     END IF
     SUM = 2*SUM
     CALL DLASSQ( N, A, LDA+1, SCALE, SUM )
     VALUE = SCALE*SQRT( SUM )
  END IF
!
  res = VALUE
  RETURN
!
!     End of DLANSY
!
  END function

  FUNCTION DLAPY2( X, Y ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  REAL   X, Y, res
!     ..
!
!  Purpose
!  =======
!
!  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
!  overflow.
!
!  Arguments
!  =========
!
!  X   (input) REAL
!  Y   (input) REAL
!      X and Y specify the values x and y.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  REAL   W, XABS, YABS, Z
!     ..
!     .. Executable Statements ..
!
  XABS = ABS( X )
  YABS = ABS( Y )
  W = MAX( XABS, YABS )
  Z = MIN( XABS, YABS )
  IF( Z == ZERO ) THEN
     res    = W
  ELSE
     res    = W*SQRT( ONE+( Z / W )**2 )
  END IF
  RETURN
!
!     End of DLAPY2
!
  END function

  FUNCTION DLAPY3( X, Y, Z ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  REAL   X, Y, Z, res
!     ..
!
!  Purpose
!  =======
!
!  DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause
!  unnecessary overflow.
!
!  Arguments
!  =========
!
!  X   (input) REAL
!  Y   (input) REAL
!  Z   (input) REAL
!      X, Y and Z specify the values x, y and z.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  REAL   W, XABS, YABS, ZABS
!     ..
!     .. Executable Statements ..
!
  XABS = ABS( X )
  YABS = ABS( Y )
  ZABS = ABS( Z )
  W = MAX( XABS, YABS, ZABS )
  IF( W == ZERO ) THEN
     res = ZERO
  ELSE
     res = W*SQRT( ( XABS / W )**2+( YABS / W )**2+ ( ZABS / W )**2 )
  END IF
!
!     End of DLAPY3
!
  END function

  SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV, &
         T, LDT, C, LDC, WORK, LDWORK )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  CHR      DIRECT, SIDE, STOREV, TRANS
  INTEGER    K, LDC, LDT, LDV, LDWORK, M, N
!     ..
!     .. Array Arguments ..
  REAL   C( LDC, * ), T( LDT, * ), V( LDV, * ), WORK( LDWORK, *)
!     ..
!
!  Purpose
!  =======
!
!  DLARFB applies a real block reflector H or its transpose H' to a
!  real m by n matrix C, from either the left or the right.
!
!  Arguments
!  =========
!
!  SIDE    (input) STR(len=1)
!      = 'L': apply H or H' from the Left
!      = 'R': apply H or H' from the Right
!
!  TRANS   (input) STR(len=1)
!      = 'N': apply H (No transpose)
!      = 'T': apply H' (Transpose)
!
!  DIRECT  (input) STR(len=1)
!      Indicates how H is formed from a product of elementary
!      reflectors
!      = 'F': H = H(1) H(2) . . . H(k) (Forward)
!      = 'B': H = H(k) . . . H(2) H(1) (Backward)
!
!  STOREV  (input) STR(len=1)
!      Indicates how the vectors which define the elementary
!      reflectors are stored:
!      = 'C': Columnwise
!      = 'R': Rowwise
!
!  M   (input) INTEGER
!      The number of rows of the matrix C.
!
!  N   (input) INTEGER
!      The number of columns of the matrix C.
!
!  K   (input) INTEGER
!      The order of the matrix T (= the number of elementary
!      reflectors whose product defines the block reflector).
!
!  V   (input) REAL array, dimension
!            (LDV,K) if STOREV = 'C'
!            (LDV,M) if STOREV = 'R' and SIDE = 'L'
!            (LDV,N) if STOREV = 'R' and SIDE = 'R'
!      The matrix V. See further details.
!
!  LDV     (input) INTEGER
!      The leading dimension of the array V.
!      If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
!      if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
!      if STOREV = 'R', LDV >= K.
!
!  T   (input) REAL array, dimension (LDT,K)
!      The triangular k by k matrix T in the representation of the
!      block reflector.
!
!  LDT     (input) INTEGER
!      The leading dimension of the array T. LDT >= K.
!
!  C   (input/output) REAL array, dimension (LDC,N)
!      On entry, the m by n matrix C.
!      On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
!
!  LDC     (input) INTEGER
!      The leading dimension of the array C. LDA >= max(1,M).
!
!  WORK    (workspace) REAL array, dimension (LDWORK,K)
!
!  LDWORK  (input) INTEGER
!      The leading dimension of the array WORK.
!      If SIDE = 'L', LDWORK >= max(1,N);
!      if SIDE = 'R', LDWORK >= max(1,M).
!
!  =====================================================================
!
!     .. Local Scalars ..
  CHR      TRANST
  INTEGER    I, J
!     ..
!     .. External Subroutines ..
  EXTERNAL       DCOPY, DGEMM, DTRMM
!     ..
!     .. Executable Statements ..
!
!     Quick return if possible
!
  IF( M <= 0  OR  N <= 0 ) RETURN
!
  IF(  scan( TRANS, 'Nn' )>0 ) THEN
     TRANST = 'T'
  ELSE
     TRANST = 'N'
  END IF
!
  IF(  scan( STOREV, 'Cc' )>0 ) THEN
!
     IF(  scan( DIRECT, 'Ff' )>0 ) THEN
!
!       Let  V =  ( V1 )    (first K rows)
!         ( V2 )
!       where  V1  is unit lower triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
!
!      W := C1'
!
       DO 10 J = 1, K
      CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
   10      CONTINUE
!
!      W := W * V1
!
       CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
           K, ONE, V, LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C2'*V2
!
      CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K, &
          ONE, C( K+1, 1 ), LDC, V( K+1, 1 ), LDV, &
          ONE, WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V * W'
!
       IF( M > K ) THEN
!
!         C2 := C2 - V2 * W'
!
      CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K, &
          -ONE, V( K+1, 1 ), LDV, WORK, LDWORK, ONE, &
          C( K+1, 1 ), LDC )
       END IF
!
!      W := W * V1'
!
       CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K, &
           ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W'
!
       DO 30 J = 1, K
      DO 20 I = 1, N
         C( J, I ) = C( J, I ) - WORK( I, J )
   20     CONTINUE
   30      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
!
!      W := C1
!
       DO 40 J = 1, K
      CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
   40      CONTINUE
!
!      W := W * V1
!
       CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
           K, ONE, V, LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C2 * V2
!
      CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K, &
          ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV, &
          ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V'
!
       IF( N > K ) THEN
!
!         C2 := C2 - W * V2'
!
      CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K, &
          -ONE, WORK, LDWORK, V( K+1, 1 ), LDV, ONE, &
          C( 1, K+1 ), LDC )
       END IF
!
!      W := W * V1'
!
       CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K, &
           ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W
!
       DO 60 J = 1, K
      DO 50 I = 1, M
         C( I, J ) = C( I, J ) - WORK( I, J )
   50     CONTINUE
   60      CONTINUE
    END IF
!
     ELSE
!
!       Let  V =  ( V1 )
!         ( V2 )    (last K rows)
!       where  V2  is unit upper triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
!
!      W := C2'
!
       DO 70 J = 1, K
      CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
   70      CONTINUE
!
!      W := W * V2
!
       CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
           K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C1'*V1
!
      CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K, &
          ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V * W'
!
       IF( M > K ) THEN
!
!         C1 := C1 - V1 * W'
!
      CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K, &
          -ONE, V, LDV, WORK, LDWORK, ONE, C, LDC )
       END IF
!
!      W := W * V2'
!
       CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K, &
           ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
!
!      C2 := C2 - W'
!
       DO 90 J = 1, K
      DO 80 I = 1, N
         C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
   80     CONTINUE
   90      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
!
!      W := C2
!
       DO 100 J = 1, K
      CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  100      CONTINUE
!
!      W := W * V2
!
       CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
           K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C1 * V1
!
      CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K, &
          ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V'
!
       IF( N > K ) THEN
!
!         C1 := C1 - W * V1'
!
      CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K, &
          -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
       END IF
!
!      W := W * V2'
!
       CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K, &
           ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
!
!      C2 := C2 - W
!
       DO 120 J = 1, K
      DO 110 I = 1, M
         C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  110     CONTINUE
  120      CONTINUE
    END IF
     END IF
!
  ELSE IF(  scan( STOREV, 'Rr' )>0 ) THEN
!
     IF(  scan( DIRECT, 'Ff' )>0 ) THEN
!
!       Let  V =  ( V1  V2 )    (V1: first K columns)
!       where  V1  is unit upper triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
!
!      W := C1'
!
       DO 130 J = 1, K
      CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
  130      CONTINUE
!
!      W := W * V1'
!
       CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K, &
           ONE, V, LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C2'*V2'
!
      CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE, &
          C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE, &
          WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V' * W'
!
       IF( M > K ) THEN
!
!         C2 := C2 - V2' * W'
!
      CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE, &
          V( 1, K+1 ), LDV, WORK, LDWORK, ONE, &
          C( K+1, 1 ), LDC )
       END IF
!
!      W := W * V1
!
       CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
           K, ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W'
!
       DO 150 J = 1, K
      DO 140 I = 1, N
         C( J, I ) = C( J, I ) - WORK( I, J )
  140     CONTINUE
  150      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
!
!      W := C1
!
       DO 160 J = 1, K
      CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
  160      CONTINUE
!
!      W := W * V1'
!
       CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K, &
           ONE, V, LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C2 * V2'
!
      CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K, &
          ONE, C( 1, K+1 ), LDC, V( 1, K+1 ), LDV, &
          ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V
!
       IF( N > K ) THEN
!
!         C2 := C2 - W * V2
!
      CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K, &
          -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE, &
          C( 1, K+1 ), LDC )
       END IF
!
!      W := W * V1
!
       CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
           K, ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W
!
       DO 180 J = 1, K
      DO 170 I = 1, M
         C( I, J ) = C( I, J ) - WORK( I, J )
  170     CONTINUE
  180      CONTINUE
!
    END IF
!
     ELSE
!
!       Let  V =  ( V1  V2 )    (V2: last K columns)
!       where  V2  is unit lower triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
!
!      W := C2'
!
       DO 190 J = 1, K
      CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
  190      CONTINUE
!
!      W := W * V2'
!
       CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K, &
           ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C1'*V1'
!
      CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE, &
          C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V' * W'
!
       IF( M > K ) THEN
!
!         C1 := C1 - V1' * W'
!
      CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE, &
          V, LDV, WORK, LDWORK, ONE, C, LDC )
       END IF
!
!      W := W * V2
!
       CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
           K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
!
!      C2 := C2 - W'
!
       DO 210 J = 1, K
      DO 200 I = 1, N
         C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
  200     CONTINUE
  210      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
!
!      W := C2
!
       DO 220 J = 1, K
      CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  220      CONTINUE
!
!      W := W * V2'
!
       CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K, &
           ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C1 * V1'
!
      CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K, &
          ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V
!
       IF( N > K ) THEN
!
!         C1 := C1 - W * V1
!
      CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K, &
          -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
       END IF
!
!      W := W * V2
!
       CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
           K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
!
!      C1 := C1 - W
!
       DO 240 J = 1, K
      DO 230 I = 1, M
         C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  230     CONTINUE
  240      CONTINUE
!
    END IF
!
     END IF
  END IF
!
  RETURN
!
!     End of DLARFB
!
  END

  SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  CHR      SIDE
  INTEGER    INCV, LDC, M, N
  REAL   TAU
!     ..
!     .. Array Arguments ..
  REAL   C( LDC, * ), V( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DLARF applies a real elementary reflector H to a real m by n matrix
!  C, from either the left or the right. H is represented in the form
!
!    H = I - tau * v * v'
!
!  where tau is a real scalar and v is a real vector.
!
!  If tau = 0, then H is taken to be the unit matrix.
!
!  Arguments
!  =========
!
!  SIDE    (input) STR(len=1)
!      = 'L': form  H * C
!      = 'R': form  C * H
!
!  M   (input) INTEGER
!      The number of rows of the matrix C.
!
!  N   (input) INTEGER
!      The number of columns of the matrix C.
!
!  V   (input) REAL array, dimension
!         (1 + (M-1)*abs(INCV)) if SIDE = 'L'
!      or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
!      The vector v in the representation of H. V is not used if
!      TAU = 0.
!
!  INCV    (input) INTEGER
!      The increment between elements of v. INCV <> 0.
!
!  TAU     (input) REAL
!      The value tau in the representation of H.
!
!  C   (input/output) REAL array, dimension (LDC,N)
!      On entry, the m by n matrix C.
!      On exit, C is overwritten by the matrix H * C if SIDE = 'L',
!      or C * H if SIDE = 'R'.
!
!  LDC     (input) INTEGER
!      The leading dimension of the array C. LDC >= max(1,M).
!
!  WORK    (workspace) REAL array, dimension
!         (N) if SIDE = 'L'
!          or (M) if SIDE = 'R'
!
!  =====================================================================
!
!     ..
!     .. External Subroutines ..
  EXTERNAL       DGEMV, DGER
!     ..
!     .. Executable Statements ..
!
  IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!    Form  H * C
!
     IF( TAU/=ZERO ) THEN
!
!       w := C' * v
!
    CALL DGEMV( 'Transpose', M, N, ONE, C, LDC, V, INCV, ZERO, WORK, 1 )
!
!       C := C - v * w'
!
    CALL DGER( M, N, -TAU, V, INCV, WORK, 1, C, LDC )
     END IF
  ELSE
!
!    Form  C * H
!
     IF( TAU/=ZERO ) THEN
!
!       w := C * v
!
    CALL DGEMV( 'No transpose', M, N, ONE, C, LDC, V, INCV,ZERO,WORK,1)
!
!       C := C - w * v'
!
    CALL DGER( M, N, -TAU, WORK, 1, V, INCV, C, LDC )
     END IF
  END IF
  RETURN
!
!     End of DLARF
!
  END

  SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  INTEGER    INCX, N
  REAL   ALPHA, TAU
!     ..
!     .. Array Arguments ..
  REAL   X( * )
!     ..
!
!  Purpose
!  =======
!
!  DLARFG generates a real elementary reflector H of order n, such
!  that
!
!    H * ( alpha ) = ( beta ),   H' * H = I.
!    (   x   )   (   0  )
!
!  where alpha and beta are scalars, and x is an (n-1)-element real
!  vector. H is represented in the form
!
!    H = I - tau * ( 1 ) * ( 1 v' ) ,
!          ( v )
!
!  where tau is a real scalar and v is a real (n-1)-element
!  vector.
!
!  If the elements of x are all zero, then tau = 0 and H is taken to be
!  the unit matrix.
!
!  Otherwise  1 <= tau <= 2.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The order of the elementary reflector.
!
!  ALPHA   (input/output) REAL
!      On entry, the value alpha.
!      On exit, it is overwritten with the value beta.
!
!  X   (input/output) REAL array, dimension
!         (1+(N-2)*abs(INCX))
!      On entry, the vector x.
!      On exit, it is overwritten with the vector v.
!
!  INCX    (input) INTEGER
!      The increment between elements of X. INCX > 0.
!
!  TAU     (output) REAL
!      The value tau.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    J, KNT
  REAL   BETA, RSAFMN, SAFMIN, XNORM
!     ..
!     .. External Functions ..
  REAL   DLAPY2, DNRM2
  EXTERNAL       DLAPY2, DNRM2
!     ..
!     .. External Subroutines ..
  EXTERNAL       DSCAL
!     ..
!     .. Executable Statements ..
!
  IF( N <= 1 ) THEN
     TAU = ZERO
     RETURN
  END IF
!
  XNORM = DNRM2( N-1, X, INCX )
!
  IF( XNORM == ZERO ) THEN
!
!    H  =  I
!
     TAU = ZERO
  ELSE
!
!    general case
!
     BETA = -SIGN( DLAPY2( ALPHA, XNORM ), ALPHA )
     SAFMIN = tiny(ZERO)*radix(ZERO)/epsilon(ZERO)
     IF( ABS( BETA ) < SAFMIN ) THEN
!
!       XNORM, BETA may be inaccurate; scale X and recompute them
!
    RSAFMN = ONE / SAFMIN
    KNT = 0
   10   CONTINUE
    KNT = KNT + 1
    CALL DSCAL( N-1, RSAFMN, X, INCX )
    BETA = BETA*RSAFMN
    ALPHA = ALPHA*RSAFMN
    IF( ABS( BETA ) < SAFMIN ) GO TO 10
!
!       New BETA is at most 1, at least SAFMIN
!
    XNORM = DNRM2( N-1, X, INCX )
    BETA = -SIGN( DLAPY2( ALPHA, XNORM ), ALPHA )
    TAU = ( BETA-ALPHA ) / BETA
    CALL DSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX )
!
!       If ALPHA is subnormal, it may lose relative accuracy
!
    ALPHA = BETA
    DO 20 J = 1, KNT
       ALPHA = ALPHA*SAFMIN
   20   CONTINUE
     ELSE
    TAU = ( BETA-ALPHA ) / BETA
    CALL DSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX )
    ALPHA = BETA
     END IF
  END IF
!
  RETURN
!
!     End of DLARFG
!
  END

  SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  CHR      DIRECT, STOREV
  INTEGER    K, LDT, LDV, N
!     ..
!     .. Array Arguments ..
  REAL   T( LDT, * ), TAU( * ), V( LDV, * )
!     ..
!
!  Purpose
!  =======
!
!  DLARFT forms the triangular factor T of a real block reflector H
!  of order n, which is defined as a product of k elementary reflectors.
!
!  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
!
!  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
!
!  If STOREV = 'C', the vector which defines the elementary reflector
!  H(i) is stored in the i-th column of the array V, and
!
!     H  =  I - V * T * V'
!
!  If STOREV = 'R', the vector which defines the elementary reflector
!  H(i) is stored in the i-th row of the array V, and
!
!     H  =  I - V' * T * V
!
!  Arguments
!  =========
!
!  DIRECT  (input) STR(len=1)
!      Specifies the order in which the elementary reflectors are
!      multiplied to form the block reflector:
!      = 'F': H = H(1) H(2) . . . H(k) (Forward)
!      = 'B': H = H(k) . . . H(2) H(1) (Backward)
!
!  STOREV  (input) STR(len=1)
!      Specifies how the vectors which define the elementary
!      reflectors are stored (see also Further Details):
!      = 'C': columnwise
!      = 'R': rowwise
!
!  N   (input) INTEGER
!      The order of the block reflector H. N >= 0.
!
!  K   (input) INTEGER
!      The order of the triangular factor T (= the number of
!      elementary reflectors). K >= 1.
!
!  V   (input/output) REAL array, dimension
!           (LDV,K) if STOREV = 'C'
!           (LDV,N) if STOREV = 'R'
!      The matrix V. See further details.
!
!  LDV     (input) INTEGER
!      The leading dimension of the array V.
!      If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
!
!  TAU     (input) REAL array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i).
!
!  T   (output) REAL array, dimension (LDT,K)
!      The k by k triangular factor T of the block reflector.
!      If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
!      lower triangular. The rest of the array is not used.
!
!  LDT     (input) INTEGER
!      The leading dimension of the array T. LDT >= K.
!
!  Further Details
!  ===============
!
!  The shape of the matrix V and the storage of the vectors which define
!  the H(i) is best illustrated by the following example with n = 5 and
!  k = 3. The elements equal to 1 are not stored; the corresponding
!  array elements are modified but restored on exit. The rest of the
!  array is not used.
!
!  DIRECT = 'F' and STOREV = 'C':     DIRECT = 'F' and STOREV = 'R':
!
!       V = (  1   )         V = (  1 v1 v1 v1 v1 )
!       ( v1  1    )         (     1 v2 v2 v2 )
!       ( v1 v2  1 )         (    1 v3 v3 )
!       ( v1 v2 v3 )
!       ( v1 v2 v3 )
!
!  DIRECT = 'B' and STOREV = 'C':     DIRECT = 'B' and STOREV = 'R':
!
!       V = ( v1 v2 v3 )         V = ( v1 v1  1   )
!       ( v1 v2 v3 )         ( v2 v2 v2  1    )
!       (  1 v2 v3 )         ( v3 v3 v3 v3  1 )
!       (     1 v3 )
!       (    1 )
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J
  REAL   VII
!     ..
!     .. External Subroutines ..
  EXTERNAL       DGEMV, DTRMV
!     ..
!     .. Executable Statements ..
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
  IF(  scan( DIRECT, 'Ff' )>0 ) THEN
     DO 20 I = 1, K
    IF( TAU( I ) == ZERO ) THEN
!
!      H(i)  =  I
!
       DO 10 J = 1, I
      T( J, I ) = ZERO
   10      CONTINUE
    ELSE
!
!      general case
!
       VII = V( I, I )
       V( I, I ) = ONE
       IF(  scan( STOREV, 'Cc' )>0 ) THEN
!
!         T(1:i-1,i) := - tau(i) * V(i:n,1:i-1)' * V(i:n,i)
!
      CALL DGEMV( 'Transpose', N-I+1, I-1, -TAU( I ), &
          V( I, 1 ), LDV, V( I, I ), 1, ZERO, T( 1, I ), 1 )
       ELSE
!
!         T(1:i-1,i) := - tau(i) * V(1:i-1,i:n) * V(i,i:n)'
!
      CALL DGEMV( 'No transpose', I-1, N-I+1, -TAU( I ), &
          V( 1, I ), LDV, V( I, I ), LDV, ZERO, T(1,I), 1)
       END IF
       V( I, I ) = VII
!
!      T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
!
       CALL DTRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T, &
           LDT, T( 1, I ), 1 )
       T( I, I ) = TAU( I )
    END IF
   20    CONTINUE
  ELSE
     DO 40 I = K, 1, -1
    IF( TAU( I ) == ZERO ) THEN
!
!      H(i)  =  I
!
       DO 30 J = I, K
      T( J, I ) = ZERO
   30      CONTINUE
    ELSE
!
!      general case
!
       IF( I < K ) THEN
      IF(  scan( STOREV, 'Cc' )>0 ) THEN
         VII = V( N-K+I, I )
         V( N-K+I, I ) = ONE
!
!        T(i+1:k,i) :=
!            - tau(i) * V(1:n-k+i,i+1:k)' * V(1:n-k+i,i)
!
         CALL DGEMV( 'Transpose', N-K+I, K-I, -TAU( I ), &
             V( 1, I+1 ), LDV, V( 1, I ), 1, ZERO, &
             T( I+1, I ), 1 )
         V( N-K+I, I ) = VII
      ELSE
         VII = V( I, N-K+I )
         V( I, N-K+I ) = ONE
!
!        T(i+1:k,i) :=
!            - tau(i) * V(i+1:k,1:n-k+i) * V(i,1:n-k+i)'
!
         CALL DGEMV( 'No transpose', K-I, N-K+I, -TAU( I ), &
             V( I+1, 1 ), LDV, V( I, 1 ), LDV, ZERO, &
             T( I+1, I ), 1 )
         V( I, N-K+I ) = VII
      END IF
!
!         T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
!
      CALL DTRMV( 'Lower', 'No transpose', 'Non-unit', K-I, &
          T( I+1, I+1 ), LDT, T( I+1, I ), 1 )
       END IF
       T( I, I ) = TAU( I )
    END IF
   40    CONTINUE
  END IF
  RETURN
!
!     End of DLARFT
!
  END

  SUBROUTINE DLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  CHR      TYPE
  INTEGER    INFO, KL, KU, LDA, M, N
  REAL   CFROM, CTO
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  DLASCL multiplies the M by N real matrix A by the real scalar
!  CTO/CFROM.  This is done without over/underflow as long as the final
!  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
!  A may be full, upper triangular, lower triangular, upper Hessenberg,
!  or banded.
!
!  Arguments
!  =========
!
!  TYPE    (input) STR(len=1)
!      TYPE indices the storage type of the input matrix.
!      = 'G':  A is a full matrix.
!      = 'L':  A is a lower triangular matrix.
!      = 'U':  A is an upper triangular matrix.
!      = 'H':  A is an upper Hessenberg matrix.
!      = 'B':  A is a symmetric band matrix with lower bandwidth KL
!      and upper bandwidth KU and with the only the lower
!      half stored.
!      = 'Q':  A is a symmetric band matrix with lower bandwidth KL
!      and upper bandwidth KU and with the only the upper
!      half stored.
!      = 'Z':  A is a band matrix with lower bandwidth KL and upper
!      bandwidth KU.
!
!  KL  (input) INTEGER
!      The lower bandwidth of A.  Referenced only if TYPE = 'B',
!      'Q' or 'Z'.
!
!  KU  (input) INTEGER
!      The upper bandwidth of A.  Referenced only if TYPE = 'B',
!      'Q' or 'Z'.
!
!  CFROM   (input) REAL
!  CTO     (input) REAL
!      The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
!      without over/underflow if the final result CTO*A(I,J)/CFROM
!      can be represented without over/underflow.  CFROM must be
!      nonzero.
!
!  M   (input) INTEGER
!      The number of rows of the matrix A.  M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix A.  N >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,M)
!      The matrix to be multiplied by CTO/CFROM.  See TYPE for the
!      storage type.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,M).
!
!  INFO    (output) INTEGER
!      0  - successful exit
!      <0 - if INFO = -i, the i-th argument had an illegal value.
!
!  =====================================================================
!
!     .. Local Scalars ..
  LOGICAL    DONE
  INTEGER    I, ITYPE, J, K1, K2, K3, K4
  REAL   BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
!
  IF(  scan( TYPE, 'Gg' )>0 ) THEN
     ITYPE = 0
  ELSE IF(  scan( TYPE, 'Ll' )>0 ) THEN
     ITYPE = 1
  ELSE IF(  scan( TYPE, 'Uu' )>0 ) THEN
     ITYPE = 2
  ELSE IF(  scan( TYPE, 'Hh' )>0 ) THEN
     ITYPE = 3
  ELSE IF(  scan( TYPE, 'Bb' )>0 ) THEN
     ITYPE = 4
  ELSE IF(  scan( TYPE, 'Qq' )>0 ) THEN
     ITYPE = 5
  ELSE IF(  scan( TYPE, 'Zz' )>0 ) THEN
     ITYPE = 6
  ELSE
     ITYPE = -1
  END IF
!
  IF( ITYPE == -1 ) THEN
     INFO = -1
  ELSE IF( CFROM == ZERO ) THEN
     INFO = -4
  ELSE IF( M < 0 ) THEN
     INFO = -6
  ELSE IF( N < 0  OR  ( ITYPE == 4  AND  N/=M )  OR  &
       ( ITYPE == 5  AND  N/=M ) ) THEN
     INFO = -7
  ELSE IF( ITYPE <= 3  AND  LDA < MAX( 1, M ) ) THEN
     INFO = -9
  ELSE IF( ITYPE.GE.4 ) THEN
     IF( KL < 0  OR  KL > MAX( M-1, 0 ) ) THEN
    INFO = -2
     ELSE IF( KU < 0  OR  KU > MAX( N-1, 0 )  OR  &
      ( ( ITYPE == 4  OR  ITYPE == 5 )  AND  KL/=KU ) ) &
       THEN
    INFO = -3
     ELSE IF( ( ITYPE == 4  AND  LDA < KL+1 )  OR  &
      ( ITYPE == 5  AND  LDA < KU+1 )  OR  &
      ( ITYPE == 6  AND  LDA < 2*KL+KU+1 ) ) THEN
    INFO = -9
     END IF
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DLASCL', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0  OR  M == 0 ) RETURN
!
!     Get machine parameters
!
  SMLNUM = tiny(ZERO)
  BIGNUM = ONE / SMLNUM
!
  CFROMC = CFROM
  CTOC = CTO
!
   10 CONTINUE
  CFROM1 = CFROMC*SMLNUM
  CTO1 = CTOC / BIGNUM
  IF( ABS( CFROM1 ) > ABS( CTOC )  AND  CTOC/=ZERO ) THEN
     MUL = SMLNUM
     DONE =  FALSE
     CFROMC = CFROM1
  ELSE IF( ABS( CTO1 ) > ABS( CFROMC ) ) THEN
     MUL = BIGNUM
     DONE =  FALSE
     CTOC = CTO1
  ELSE
     MUL = CTOC / CFROMC
     DONE =  TRUE
  END IF
!
  IF( ITYPE == 0 ) THEN
!
!    Full matrix
!
     DO 30 J = 1, N
    DO 20 I = 1, M
       A( I, J ) = A( I, J )*MUL
   20   CONTINUE
   30    CONTINUE
!
  ELSE IF( ITYPE == 1 ) THEN
!
!    Lower triangular matrix
!
     DO 50 J = 1, N
    DO 40 I = J, M
       A( I, J ) = A( I, J )*MUL
   40   CONTINUE
   50    CONTINUE
!
  ELSE IF( ITYPE == 2 ) THEN
!
!    Upper triangular matrix
!
     DO 70 J = 1, N
    DO 60 I = 1, MIN( J, M )
       A( I, J ) = A( I, J )*MUL
   60   CONTINUE
   70    CONTINUE
!
  ELSE IF( ITYPE == 3 ) THEN
!
!    Upper Hessenberg matrix
!
     DO 90 J = 1, N
    DO 80 I = 1, MIN( J+1, M )
       A( I, J ) = A( I, J )*MUL
   80   CONTINUE
   90    CONTINUE
!
  ELSE IF( ITYPE == 4 ) THEN
!
!    Lower half of a symmetric band matrix
!
     K3 = KL + 1
     K4 = N + 1
     DO 110 J = 1, N
    DO 100 I = 1, MIN( K3, K4-J )
       A( I, J ) = A( I, J )*MUL
  100   CONTINUE
  110    CONTINUE
!
  ELSE IF( ITYPE == 5 ) THEN
!
!    Upper half of a symmetric band matrix
!
     K1 = KU + 2
     K3 = KU + 1
     DO 130 J = 1, N
    DO 120 I = MAX( K1-J, 1 ), K3
       A( I, J ) = A( I, J )*MUL
  120   CONTINUE
  130    CONTINUE
!
  ELSE IF( ITYPE == 6 ) THEN
!
!    Band matrix
!
     K1 = KL + KU + 2
     K2 = KL + 1
     K3 = 2*KL + KU + 1
     K4 = KL + KU + 1 + M
     DO 150 J = 1, N
    DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J )
       A( I, J ) = A( I, J )*MUL
  140   CONTINUE
  150    CONTINUE
!
  END IF
!
  IF(  NOT DONE ) GO TO 10
!
  RETURN
!
!     End of DLASCL
!
  END

  SUBROUTINE DLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    LDA, M, N
  REAL   ALPHA, BETA
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  DLASET initializes an m-by-n matrix A to BETA on the diagonal and
!  ALPHA on the offdiagonals.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      Specifies the part of the matrix A to be set.
!      = 'U':  Upper triangular part is set; the strictly lower
!          triangular part of A is not changed.
!      = 'L':  Lower triangular part is set; the strictly upper
!          triangular part of A is not changed.
!      Otherwise:  All of the matrix A is set.
!
!  M   (input) INTEGER
!      The number of rows of the matrix A.  M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix A.  N >= 0.
!
!  ALPHA   (input) REAL
!      The constant to which the offdiagonal elements are to be set.
!
!  BETA    (input) REAL
!      The constant to which the diagonal elements are to be set.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On exit, the leading m-by-n submatrix of A is set as follows:
!
!      if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
!      if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
!      otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
!
!      and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,M).
!
! =====================================================================
!
!     .. Local Scalars ..
  INTEGER    I, J
!     ..
!     .. Executable Statements ..
!
  IF(  scan( UPLO, 'Uu' )>0 ) THEN
!
!    Set the strictly upper triangular or trapezoidal part of the
!    array to ALPHA.
!
     DO 20 J = 2, N
    DO 10 I = 1, MIN( J-1, M )
       A( I, J ) = ALPHA
   10   CONTINUE
   20    CONTINUE
!
  ELSE IF(  scan( UPLO, 'Ll' )>0 ) THEN
!
!    Set the strictly lower triangular or trapezoidal part of the
!    array to ALPHA.
!
     DO 40 J = 1, MIN( M, N )
    DO 30 I = J + 1, M
       A( I, J ) = ALPHA
   30   CONTINUE
   40    CONTINUE
!
  ELSE
!
!    Set the leading m-by-n submatrix to ALPHA.
!
     DO 60 J = 1, N
    DO 50 I = 1, M
       A( I, J ) = ALPHA
   50   CONTINUE
   60    CONTINUE
  END IF
!
!     Set the first min(M,N) diagonal elements to BETA.
!
  DO 70 I = 1, MIN( M, N )
     A( I, I ) = BETA
   70 CONTINUE
!
  RETURN
!
!     End of DLASET
!
  END

  SUBROUTINE DLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      DIRECT, PIVOT, SIDE
  INTEGER    LDA, M, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), C( * ), S( * )
!     ..
!
!  Purpose
!  =======
!
!  DLASR   performs the transformation
!
!     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )
!
!     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )
!
!  where A is an m by n real matrix and P is an orthogonal matrix,
!  consisting of a sequence of plane rotations determined by the
!  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
!  and z = n when SIDE = 'R' or 'r' ):
!
!  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then
!
!     P = P( z - 1 )*...*P( 2 )*P( 1 ),
!
!  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then
!
!     P = P( 1 )*P( 2 )*...*P( z - 1 ),
!
!  where  P( k ) is a plane rotation matrix for the following planes:
!
!     when  PIVOT = 'V' or 'v'  ( Variable pivot ),
!    the plane ( k, k + 1 )
!
!     when  PIVOT = 'T' or 't'  ( Top pivot ),
!    the plane ( 1, k + 1 )
!
!     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),
!    the plane ( k, z )
!
!  c( k ) and s( k )  must contain the  cosine and sine that define the
!  matrix  P( k ).  The two by two plane rotation part of the matrix
!  P( k ), R( k ), is assumed to be of the form
!
!     R( k ) = (  c( k )  s( k ) ).
!      ( -s( k )  c( k ) )
!
!  This version vectorises across rows of the array A when SIDE = 'L'.
!
!  Arguments
!  =========
!
!  SIDE    (input) STR(len=1)
!      Specifies whether the plane rotation matrix P is applied to
!      A on the left or the right.
!      = 'L':  Left, compute A := P*A
!      = 'R':  Right, compute A:= A*P'
!
!  DIRECT  (input) STR(len=1)
!      Specifies whether P is a forward or backward sequence of
!      plane rotations.
!      = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )
!      = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )
!
!  PIVOT   (input) STR(len=1)
!      Specifies the plane for which P(k) is a plane rotation
!      matrix.
!      = 'V':  Variable pivot, the plane (k,k+1)
!      = 'T':  Top pivot, the plane (1,k+1)
!      = 'B':  Bottom pivot, the plane (k,z)
!
!  M   (input) INTEGER
!      The number of rows of the matrix A.  If m <= 1, an immediate
!      return is effected.
!
!  N   (input) INTEGER
!      The number of columns of the matrix A.  If n <= 1, an
!      immediate return is effected.
!
!  C, S    (input) REAL arrays, dimension
!      (M-1) if SIDE = 'L'
!      (N-1) if SIDE = 'R'
!      c(k) and s(k) contain the cosine and sine that define the
!      matrix P(k).  The two by two plane rotation part of the
!      matrix P(k), R(k), is assumed to be of the form
!      R( k ) = (  c( k )  s( k ) ).
!       ( -s( k )  c( k ) )
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      The m by n matrix A.  On exit, A is overwritten by P*A if
!      SIDE = 'R' or by A*P' if SIDE = 'L'.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,M).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, INFO, J
  REAL   CTEMP, STEMP, TEMP
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  IF(  NOT  scan( SIDE, 'LlRr' )>0 ) THEN
     INFO = 1
  ELSE IF(  NOT  scan( PIVOT, 'VvTtBb' )>0 ) THEN
     INFO = 2
  ELSE IF(  NOT  scan( DIRECT, 'FfBb' )>0 ) THEN
     INFO = 3
  ELSE IF( M < 0 ) THEN
     INFO = 4
  ELSE IF( N < 0 ) THEN
     INFO = 5
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = 9
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DLASR ', INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( ( M == 0 )  OR  ( N == 0 ) ) RETURN
  IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!    Form  P * A
!
     IF(  scan( PIVOT, 'Vv' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 20 J = 1, M - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 10 I = 1, N
        TEMP = A( J+1, I )
        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
   10        CONTINUE
      END IF
   20      CONTINUE
    ELSE IF( scan( DIRECT, 'Bb' )>0 ) THEN
       DO 40 J = M - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 30 I = 1, N
        TEMP = A( J+1, I )
        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
   30        CONTINUE
      END IF
   40      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Tt' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 60 J = 2, M
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 50 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
   50        CONTINUE
      END IF
   60      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 80 J = M, 2, -1
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 70 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
   70        CONTINUE
      END IF
   80      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Bb' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 100 J = 1, M - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 90 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
   90        CONTINUE
      END IF
  100      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 120 J = M - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 110 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
  110        CONTINUE
      END IF
  120      CONTINUE
    END IF
     END IF
  ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!    Form A * P'
!
     IF(  scan( PIVOT, 'Vv' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 140 J = 1, N - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 130 I = 1, M
        TEMP = A( I, J+1 )
        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  130        CONTINUE
      END IF
  140      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 160 J = N - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 150 I = 1, M
        TEMP = A( I, J+1 )
        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  150        CONTINUE
      END IF
  160      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Tt' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 180 J = 2, N
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 170 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
  170        CONTINUE
      END IF
  180      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 200 J = N, 2, -1
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 190 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
  190        CONTINUE
      END IF
  200      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Bb' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 220 J = 1, N - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 210 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
  210        CONTINUE
      END IF
  220      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 240 J = N - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 230 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
  230        CONTINUE
      END IF
  240      CONTINUE
    END IF
     END IF
  END IF
!
  RETURN
!
!     End of DLASR
!
  END

  SUBROUTINE DLASRT( ID, N, D, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      ID
  INTEGER    INFO, N
!     ..
!     .. Array Arguments ..
  REAL   D( * )
!     ..
!
!  Purpose
!  =======
!
!  Sort the numbers in D in increasing order (if ID = 'I') or
!  in decreasing order (if ID = 'D' ).
!
!  Use Quick Sort, reverting to Insertion sort on arrays of
!  size <= 20. Dimension of STACK limits N to about 2**32.
!
!  Arguments
!  =========
!
!  ID  (input) STR(len=1)
!      = 'I': sort D in increasing order;
!      = 'D': sort D in decreasing order.
!
!  N   (input) INTEGER
!      The length of the array D.
!
!  D   (input/output) REAL array, dimension (N)
!      On entry, the array to be sorted.
!      On exit, D has been sorted into increasing order
!      (D(1) <= ... <= D(N) ) or into decreasing order
!      (D(1) >= ... >= D(N) ), depending on ID.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  =====================================================================
!
!     .. Parameters ..
  INTEGER    SELECT
  PARAMETER      ( SELECT = 20 )
!     ..
!     .. Local Scalars ..
  INTEGER    DIR, ENDD, I, J, START, STKPNT
  REAL   D1, D2, D3, DMNMX, TMP
!     ..
!     .. Local Arrays ..
  INTEGER    STACK( 2, 32 )
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input paramters.
!
  INFO = 0
  DIR = -1
  IF(  scan( ID, 'Dd' )>0 ) THEN
     DIR = 0
  ELSE IF(  scan( ID, 'Ii' )>0 ) THEN
     DIR = 1
  END IF
  IF( DIR == -1 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DLASRT', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 1 ) RETURN
!
  STKPNT = 1
  STACK( 1, 1 ) = 1
  STACK( 2, 1 ) = N
   10 CONTINUE
  START = STACK( 1, STKPNT )
  ENDD = STACK( 2, STKPNT )
  STKPNT = STKPNT - 1
  IF( ENDD-START <= SELECT  AND  ENDD-START > 0 ) THEN
!
!    Do Insertion sort on D( START:ENDD )
!
     IF( DIR == 0 ) THEN
!
!       Sort into decreasing order
!
    DO 30 I = START + 1, ENDD
       DO 20 J = I, START + 1, -1
      IF( D( J ) > D( J-1 ) ) THEN
         DMNMX = D( J )
         D( J ) = D( J-1 )
         D( J-1 ) = DMNMX
      ELSE
         GO TO 30
      END IF
   20      CONTINUE
   30   CONTINUE
!
     ELSE
!
!       Sort into increasing order
!
    DO 50 I = START + 1, ENDD
       DO 40 J = I, START + 1, -1
      IF( D( J ) < D( J-1 ) ) THEN
         DMNMX = D( J )
         D( J ) = D( J-1 )
         D( J-1 ) = DMNMX
      ELSE
         GO TO 50
      END IF
   40      CONTINUE
   50   CONTINUE
!
     END IF
!
  ELSE IF( ENDD-START > SELECT ) THEN
!
!    Partition D( START:ENDD ) and stack parts, largest one first
!
!    Choose partition entry as median of 3
!
     D1 = D( START )
     D2 = D( ENDD )
     I = ( START+ENDD ) / 2
     D3 = D( I )
     IF( D1 < D2 ) THEN
    IF( D3 < D1 ) THEN
       DMNMX = D1
    ELSE IF( D3 < D2 ) THEN
       DMNMX = D3
    ELSE
       DMNMX = D2
    END IF
     ELSE
    IF( D3 < D2 ) THEN
       DMNMX = D2
    ELSE IF( D3 < D1 ) THEN
       DMNMX = D3
    ELSE
       DMNMX = D1
    END IF
     END IF
!
     IF( DIR == 0 ) THEN
!
!       Sort into decreasing order
!
    I = START - 1
    J = ENDD + 1
   60   CONTINUE
   70   CONTINUE
    J = J - 1
    IF( D( J ) < DMNMX ) GO TO 70
   80   CONTINUE
    I = I + 1
    IF( D( I ) > DMNMX ) GO TO 80
    IF( I < J ) THEN
       TMP = D( I )
       D( I ) = D( J )
       D( J ) = TMP
       GO TO 60
    END IF
    IF( J-START > ENDD-J-1 ) THEN
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = START
       STACK( 2, STKPNT ) = J
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = J + 1
       STACK( 2, STKPNT ) = ENDD
    ELSE
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = J + 1
       STACK( 2, STKPNT ) = ENDD
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = START
       STACK( 2, STKPNT ) = J
    END IF
     ELSE
!
!       Sort into increasing order
!
    I = START - 1
    J = ENDD + 1
   90   CONTINUE
  100   CONTINUE
    J = J - 1
    IF( D( J ) > DMNMX ) GO TO 100
  110   CONTINUE
    I = I + 1
    IF( D( I ) < DMNMX ) GO TO 110
    IF( I < J ) THEN
       TMP = D( I )
       D( I ) = D( J )
       D( J ) = TMP
       GO TO 90
    END IF
    IF( J-START > ENDD-J-1 ) THEN
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = START
       STACK( 2, STKPNT ) = J
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = J + 1
       STACK( 2, STKPNT ) = ENDD
    ELSE
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = J + 1
       STACK( 2, STKPNT ) = ENDD
       STKPNT = STKPNT + 1
       STACK( 1, STKPNT ) = START
       STACK( 2, STKPNT ) = J
    END IF
     END IF
  END IF
  IF( STKPNT > 0 ) GO TO 10
  RETURN
!
!     End of DLASRT
!
  END

  SUBROUTINE DLASSQ( N, X, INCX, SCALE, SUMSQ )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INCX, N
  REAL   SCALE, SUMSQ
!     ..
!     .. Array Arguments ..
  REAL   X( * )
!     ..
!
!  Purpose
!  =======
!
!  DLASSQ  returns the values  scl  and  smsq  such that
!
!     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
!
!  where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
!  assumed to be non-negative and  scl  returns the value
!
!     scl = max( scale, abs( x( i ) ) ).
!
!  scale and sumsq must be supplied in SCALE and SUMSQ and
!  scl and smsq are overwritten on SCALE and SUMSQ respectively.
!
!  The routine makes only one pass through the vector x.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The number of elements to be used from the vector X.
!
!  X   (input) REAL array, dimension (N)
!      The vector for which a scaled sum of squares is computed.
!     x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
!
!  INCX    (input) INTEGER
!      The increment between successive values of the vector X.
!      INCX > 0.
!
!  SCALE   (input/output) REAL
!      On entry, the value  scale  in the equation above.
!      On exit, SCALE is overwritten with  scl , the scaling factor
!      for the sum of squares.
!
!  SUMSQ   (input/output) REAL
!      On entry, the value  sumsq  in the equation above.
!      On exit, SUMSQ is overwritten with  smsq , the basic sum of
!      squares from which  scl  has been factored out.
!
! =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    IX
  REAL   ABSXI
!     ..
!     .. Executable Statements ..
!
  IF( N > 0 ) THEN
     DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX
    IF( X( IX )/=ZERO ) THEN
       ABSXI = ABS( X( IX ) )
       IF( SCALE < ABSXI ) THEN
      SUMSQ = 1 + SUMSQ*( SCALE / ABSXI )**2
      SCALE = ABSXI
       ELSE
      SUMSQ = SUMSQ + ( ABSXI / SCALE )**2
       END IF
    END IF
   10    CONTINUE
  END IF
  RETURN
!
!     End of DLASSQ
!
  END

  SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INCX, K1, K2, LDA, N
!     ..
!     .. Array Arguments ..
  INTEGER    IPIV( * )
  REAL   A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  DLASWP performs a series of row interchanges on the matrix A.
!  One row interchange is initiated for each of rows K1 through K2 of A.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The number of columns of the matrix A.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the matrix of column dimension N to which the row
!      interchanges will be applied.
!      On exit, the permuted matrix.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.
!
!  K1  (input) INTEGER
!      The first element of IPIV for which a row interchange will
!      be done.
!
!  K2  (input) INTEGER
!      The last element of IPIV for which a row interchange will
!      be done.
!
!  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
!      The vector of pivot indices.  Only the elements in positions
!      K1 through K2 of IPIV are accessed.
!      IPIV(K) = L implies rows K and L are to be interchanged.
!
!  INCX    (input) INTEGER
!      The increment between successive values of IPIV.  If IPIV
!      is negative, the pivots are applied in reverse order.
!
!  Further Details
!  ===============
!
!  Modified by
!   R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
!
! =====================================================================
!
!     .. Local Scalars ..
  INTEGER    I, I1, I2, INC, IP, IX, IX0, J, K, N32
  REAL   TEMP
!     ..
!     .. Executable Statements ..
!
!     Interchange row I with row IPIV(I) for each of rows K1 through K2.
!
  IF( INCX > 0 ) THEN
     IX0 = K1
     I1 = K1
     I2 = K2
     INC = 1
  ELSE IF( INCX < 0 ) THEN
     IX0 = 1 + ( 1-K2 )*INCX
     I1 = K2
     I2 = K1
     INC = -1
  ELSE
     RETURN
  END IF
!
  N32 = ( N / 32 )*32
  IF( N32/=0 ) THEN
     DO 30 J = 1, N32, 32
    IX = IX0
    DO 20 I = I1, I2, INC
       IP = IPIV( IX )
       IF( IP/=I ) THEN
      DO 10 K = J, J + 31
         TEMP = A( I, K )
         A( I, K ) = A( IP, K )
         A( IP, K ) = TEMP
   10     CONTINUE
       END IF
       IX = IX + INCX
   20   CONTINUE
   30    CONTINUE
  END IF
  IF( N32/=N ) THEN
     N32 = N32 + 1
     IX = IX0
     DO 50 I = I1, I2, INC
    IP = IPIV( IX )
    IF( IP/=I ) THEN
       DO 40 K = N32, N
      TEMP = A( I, K )
      A( I, K ) = A( IP, K )
      A( IP, K ) = TEMP
   40      CONTINUE
    END IF
    IX = IX + INCX
   50    CONTINUE
  END IF
!
  RETURN
!
!     End of DLASWP
!
  END

  SUBROUTINE DLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    LDA, LDW, N, NB
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), E( * ), TAU( * ), W( LDW, * )
!     ..
!
!  Purpose
!  =======
!
!  DLATRD reduces NB rows and columns of a real symmetric matrix A to
!  symmetric tridiagonal form by an orthogonal similarity
!  transformation Q' * A * Q, and returns the matrices V and W which are
!  needed to apply the transformation to the unreduced part of A.
!
!  If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
!  matrix, of which the upper triangle is supplied;
!  if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
!  matrix, of which the lower triangle is supplied.
!
!  This is an auxiliary routine called by DSYTRD.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR
!      Specifies whether the upper or lower triangular part of the
!      symmetric matrix A is stored:
!      = 'U': Upper triangular
!      = 'L': Lower triangular
!
!  N   (input) INTEGER
!      The order of the matrix A.
!
!  NB  (input) INTEGER
!      The number of rows and columns to be reduced.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the symmetric matrix A.  If UPLO = 'U', the leading
!      n-by-n upper triangular part of A contains the upper
!      triangular part of the matrix A, and the strictly lower
!      triangular part of A is not referenced.  If UPLO = 'L', the
!      leading n-by-n lower triangular part of A contains the lower
!      triangular part of the matrix A, and the strictly upper
!      triangular part of A is not referenced.
!      On exit:
!      if UPLO = 'U', the last NB columns have been reduced to
!    tridiagonal form, with the diagonal elements overwriting
!    the diagonal elements of A; the elements above the diagonal
!    with the array TAU, represent the orthogonal matrix Q as a
!    product of elementary reflectors;
!      if UPLO = 'L', the first NB columns have been reduced to
!    tridiagonal form, with the diagonal elements overwriting
!    the diagonal elements of A; the elements below the diagonal
!    with the array TAU, represent the  orthogonal matrix Q as a
!    product of elementary reflectors.
!      See Further Details.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= (1,N).
!
!  E   (output) REAL array, dimension (N-1)
!      If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
!      elements of the last NB columns of the reduced matrix;
!      if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
!      the first NB columns of the reduced matrix.
!
!  TAU     (output) REAL array, dimension (N-1)
!      The scalar factors of the elementary reflectors, stored in
!      TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
!      See Further Details.
!
!  W   (output) REAL array, dimension (LDW,NB)
!      The n-by-nb matrix W required to update the unreduced part
!      of A.
!
!  LDW     (input) INTEGER
!      The leading dimension of the array W. LDW >= max(1,N).
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n) H(n-1) . . . H(n-nb+1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a real scalar, and v is a real vector with
!  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
!  and tau in TAU(i-1).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(nb).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a real scalar, and v is a real vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
!  and tau in TAU(i).
!
!  The elements of the vectors v together form the n-by-nb matrix V
!  which is needed, with W, to apply the transformation to the unreduced
!  part of the matrix, using a symmetric rank-2k update of the form:
!  A := A - V*W' - W*V'.
!
!  The contents of A on exit are illustrated by the following examples
!  with n = 5 and nb = 2:
!
!  if UPLO = 'U':           if UPLO = 'L':
!
!    (  a   a   a   v4  v5 )      (  d      )
!    (  a   a   v4  v5 )      (  1   d      )
!    (      a   1   v5 )      (  v1  1   a      )
!    (      d   1  )      (  v1  v2  a   a  )
!    (      d  )      (  v1  v2  a   a   a  )
!
!  where d denotes a diagonal element of the reduced matrix, a denotes
!  an element of the original matrix that is unchanged, and vi denotes
!  an element of the vector defining H(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, IW
  REAL   ALPHA
!     ..
!     .. External Subroutines ..
  EXTERNAL       DAXPY, DGEMV, DLARFG, DSCAL, DSYMV
!     ..
!     .. External Functions ..
  REAL   DDOT
  EXTERNAL       DDOT
!     ..
!     .. Executable Statements ..
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
  IF(  scan( UPLO, 'Uu' )>0 ) THEN
!
!    Reduce last NB columns of upper triangle
!
     DO 10 I = N, N - NB + 1, -1
    IW = I - N + NB
    IF( I < N ) THEN
!
!      Update A(1:i,i)
!
       CALL DGEMV( 'No transpose', I, N-I, -ONE, A( 1, I+1 ), &
           LDA, W( I, IW+1 ), LDW, ONE, A( 1, I ), 1 )
       CALL DGEMV( 'No transpose', I, N-I, -ONE, W( 1, IW+1 ), &
           LDW, A( I, I+1 ), LDA, ONE, A( 1, I ), 1 )
    END IF
    IF( I > 1 ) THEN
!
!      Generate elementary reflector H(i) to annihilate
!      A(1:i-2,i)
!
       CALL DLARFG( I-1, A( I-1, I ), A( 1, I ), 1, TAU( I-1 ) )
       E( I-1 ) = A( I-1, I )
       A( I-1, I ) = ONE
!
!      Compute W(1:i-1,i)
!
       CALL DSYMV( 'Upper', I-1, ONE, A, LDA, A( 1, I ), 1, &
           ZERO, W( 1, IW ), 1 )
       IF( I < N ) THEN
      CALL DGEMV( 'Transpose', I-1, N-I, ONE, W( 1, IW+1 ), &
          LDW, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
      CALL DGEMV( 'No transpose', I-1, N-I, -ONE, &
          A( 1, I+1 ), LDA, W( I+1, IW ), 1, ONE, &
          W( 1, IW ), 1 )
      CALL DGEMV( 'Transpose', I-1, N-I, ONE, A( 1, I+1 ), &
          LDA, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
      CALL DGEMV( 'No transpose', I-1, N-I, -ONE, &
          W( 1, IW+1 ), LDW, W( I+1, IW ), 1, ONE, &
          W( 1, IW ), 1 )
       END IF
       CALL DSCAL( I-1, TAU( I-1 ), W( 1, IW ), 1 )
       ALPHA = -HALF*TAU( I-1 )*DDOT( I-1, W( 1, IW ), 1, A( 1, I ), 1 )
       CALL DAXPY( I-1, ALPHA, A( 1, I ), 1, W( 1, IW ), 1 )
    END IF
!
   10    CONTINUE
  ELSE
!
!    Reduce first NB columns of lower triangle
!
     DO 20 I = 1, NB
!
!       Update A(i:n,i)
!
    CALL DGEMV( 'No transpose', N-I+1, I-1, -ONE, A( I, 1 ), &
        LDA, W( I, 1 ), LDW, ONE, A( I, I ), 1 )
    CALL DGEMV( 'No transpose', N-I+1, I-1, -ONE, W( I, 1 ), &
        LDW, A( I, 1 ), LDA, ONE, A( I, I ), 1 )
    IF( I < N ) THEN
!
!      Generate elementary reflector H(i) to annihilate
!      A(i+2:n,i)
!
       CALL DLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1, TAU(I))
       E( I ) = A( I+1, I )
       A( I+1, I ) = ONE
!
!      Compute W(i+1:n,i)
!
       CALL DSYMV( 'Lower', N-I, ONE, A( I+1, I+1 ), LDA, &
           A( I+1, I ), 1, ZERO, W( I+1, I ), 1 )
       CALL DGEMV( 'Transpose', N-I, I-1, ONE, W( I+1, 1 ), LDW, &
           A( I+1, I ), 1, ZERO, W( 1, I ), 1 )
       CALL DGEMV( 'No transpose', N-I, I-1, -ONE, A( I+1, 1 ), &
           LDA, W( 1, I ), 1, ONE, W( I+1, I ), 1 )
       CALL DGEMV( 'Transpose', N-I, I-1, ONE, A( I+1, 1 ), LDA, &
           A( I+1, I ), 1, ZERO, W( 1, I ), 1 )
       CALL DGEMV( 'No transpose', N-I, I-1, -ONE, W( I+1, 1 ), &
           LDW, W( 1, I ), 1, ONE, W( I+1, I ), 1 )
       CALL DSCAL( N-I, TAU( I ), W( I+1, I ), 1 )
       ALPHA = -HALF*TAU( I )*DDOT( N-I, W( I+1, I ), 1, A( I+1, I ), 1)
       CALL DAXPY( N-I, ALPHA, A( I+1, I ), 1, W( I+1, I ), 1 )
    END IF
!
   20    CONTINUE
  END IF
!
  RETURN
!
!     End of DLATRD
!
  END

  FUNCTION DNRM2 ( N, X, INCX ) result(res)
!     .. Scalar Arguments ..
  INTEGER           INCX, N
!     .. Array Arguments ..
  REAL      X( * ), res
!     ..
!
!  DNRM2 returns the euclidean norm of a vector via the function
!  name, so that
!
!     DNRM2 := sqrt( x'*x )
!
!
!
!  -- This version written on 25-October-1982.
!     Modified on 14-October-1993 to inline the call to DLASSQ.
!     Sven Hammarling, Nag Ltd.
!
!
!     .. Local Scalars ..
  INTEGER       IX
  REAL  ABSXI, NORM, SCALE, SSQ
!     ..
!     .. Executable Statements ..
  IF( N < 1  OR  INCX < 1 )THEN
     NORM  = ZERO
  ELSE IF( N == 1 )THEN
     NORM  = ABS( X( 1 ) )
  ELSE
     SCALE = ZERO
     SSQ   = ONE
!    The following loop is equivalent to this call to the LAPACK
!    auxiliary routine:
!    CALL DLASSQ( N, X, INCX, SCALE, SSQ )
!
     DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
    IF( X( IX )/=ZERO )THEN
       ABSXI = ABS( X( IX ) )
       IF( SCALE < ABSXI )THEN
      SSQ   = ONE   + SSQ*( SCALE/ABSXI )**2
      SCALE = ABSXI
       ELSE
      SSQ   = SSQ   +     ( ABSXI/SCALE )**2
       END IF
    END IF
   10    CONTINUE
     NORM  = SCALE * SQRT( SSQ )
  END IF
 
  res = NORM
  END function

  SUBROUTINE DORG2L( M, N, K, A, LDA, TAU, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, M, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DORG2L generates an m by n real matrix Q with orthonormal columns,
!  which is defined as the last n columns of a product of k elementary
!  reflectors of order m
!
!    Q  =  H(k) . . . H(2) H(1)
!
!  as returned by DGEQLF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the (n-k+i)-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by DGEQLF in the last k columns of its array
!      argument A.
!      On exit, the m by n matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) REAL array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by DGEQLF.
!
!  WORK    (workspace) REAL array, dimension (N)
!
!  INFO    (output) INTEGER
!      = 0: successful exit
!      < 0: if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, II, J, L
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLARF, DSCAL, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DORG2L', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
!     Initialise columns 1:n-k to columns of the unit matrix
!
  DO 20 J = 1, N - K
     DO 10 L = 1, M
    A( L, J ) = ZERO
   10    CONTINUE
     A( M-N+J, J ) = ONE
   20 CONTINUE
!
  DO 40 I = 1, K
     II = N - K + I
!
!    Apply H(i) to A(1:m-k+i,1:n-k+i) from the left
!
     A( M-N+II, II ) = ONE
     CALL DLARF( 'Left', M-N+II, II-1, A( 1, II ), 1, TAU(I), A, LDA, WORK)
     CALL DSCAL( M-N+II-1, -TAU( I ), A( 1, II ), 1 )
     A( M-N+II, II ) = ONE - TAU( I )
!
!    Set A(m-k+i+1:m,n-k+i) to zero
!
     DO 30 L = M - N + II + 1, M
    A( L, II ) = ZERO
   30    CONTINUE
   40 CONTINUE
  RETURN
!
!     End of DORG2L
!
  END

  SUBROUTINE DORG2R( M, N, K, A, LDA, TAU, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, M, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DORG2R generates an m by n real matrix Q with orthonormal columns,
!  which is defined as the first n columns of a product of k elementary
!  reflectors of order m
!
!    Q  =  H(1) H(2) . . . H(k)
!
!  as returned by DGEQRF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the i-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by DGEQRF in the first k columns of its array
!      argument A.
!      On exit, the m-by-n matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) REAL array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by DGEQRF.
!
!  WORK    (workspace) REAL array, dimension (N)
!
!  INFO    (output) INTEGER
!      = 0: successful exit
!      < 0: if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J, L
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLARF, DSCAL, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DORG2R', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
!     Initialise columns k+1:n to columns of the unit matrix
!
  DO 20 J = K + 1, N
     DO 10 L = 1, M
    A( L, J ) = ZERO
   10    CONTINUE
     A( J, J ) = ONE
   20 CONTINUE
!
  DO 40 I = K, 1, -1
!
!    Apply H(i) to A(i:m,i:n) from the left
!
     IF( I < N ) THEN
    A( I, I ) = ONE
    CALL DLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAU( I ), &
        A( I, I+1 ), LDA, WORK )
     END IF
     IF( I < M ) CALL DSCAL( M-I, -TAU( I ), A( I+1, I ), 1 )
     A( I, I ) = ONE - TAU( I )
!
!    Set A(1:i-1,i) to zero
!
     DO 30 L = 1, I - 1
    A( L, I ) = ZERO
   30    CONTINUE
   40 CONTINUE
  RETURN
!
!     End of DORG2R
!
  END

  SUBROUTINE DORGQL( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, LWORK, M, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DORGQL generates an M-by-N real matrix Q with orthonormal columns,
!  which is defined as the last N columns of a product of K elementary
!  reflectors of order M
!
!    Q  =  H(k) . . . H(2) H(1)
!
!  as returned by DGEQLF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the (n-k+i)-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by DGEQLF in the last k columns of its array
!      argument A.
!      On exit, the M-by-N matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) REAL array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by DGEQLF.
!
!  WORK    (workspace/output) REAL array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK. LWORK >= max(1,N).
!      For optimum performance LWORK >= N*NB, where NB is the
!      optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY
  INTEGER    I, IB, IINFO, IWS, J, KK, L, LDWORK, LWKOPT, &
         NB, NBMIN, NX
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLARFB, DLARFT, DORG2L, XERBLA
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  NB = ILAENV( 1, 'DORGQL', ' ', M, N, K, -1 )
  LWKOPT = MAX( 1, N )*NB
  WORK( 1 ) = LWKOPT
  LQUERY = ( LWORK == -1 )
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  ELSE IF( LWORK < MAX( 1, N )  AND   NOT LQUERY ) THEN
     INFO = -8
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DORGQL', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  NBMIN = 2
  NX = 0
  IWS = N
  IF( NB > 1  AND  NB < K ) THEN
!
!    Determine when to cross over from blocked to unblocked code.
!
     NX = MAX( 0, ILAENV( 3, 'DORGQL', ' ', M, N, K, -1 ) )
     IF( NX < K ) THEN
!
!       Determine if workspace is large enough for blocked code.
!
    LDWORK = N
    IWS = LDWORK*NB
    IF( LWORK < IWS ) THEN
!
!      Not enough workspace to use optimal NB:  reduce NB and
!      determine the minimum value of NB.
!
       NB = LWORK / LDWORK
       NBMIN = MAX( 2, ILAENV( 2, 'DORGQL', ' ', M, N, K, -1 ) )
    END IF
     END IF
  END IF
!
  IF( NB.GE.NBMIN  AND  NB < K  AND  NX < K ) THEN
!
!    Use blocked code after the first block.
!    The last kk columns are handled by the block method.
!
     KK = MIN( K, ( ( K-NX+NB-1 ) / NB )*NB )
!
!    Set A(m-kk+1:m,1:n-kk) to zero.
!
     DO 20 J = 1, N - KK
    DO 10 I = M - KK + 1, M
       A( I, J ) = ZERO
   10   CONTINUE
   20    CONTINUE
  ELSE
     KK = 0
  END IF
!
!     Use unblocked code for the first or only block.
!
  CALL DORG2L( M-KK, N-KK, K-KK, A, LDA, TAU, WORK, IINFO )
!
  IF( KK > 0 ) THEN
!
!    Use blocked code
!
     DO 50 I = K - KK + 1, K, NB
    IB = MIN( NB, K-I+1 )
    IF( N-K+I > 1 ) THEN
!
!      Form the triangular factor of the block reflector
!      H = H(i+ib-1) . . . H(i+1) H(i)
!
       CALL DLARFT( 'Backward', 'Columnwise', M-K+I+IB-1, IB, &
            A( 1, N-K+I ), LDA, TAU( I ), WORK, LDWORK )
!
!      Apply H to A(1:m-k+i+ib-1,1:n-k+i-1) from the left
!
       CALL DLARFB( 'Left', 'No transpose', 'Backward', &
            'Columnwise', M-K+I+IB-1, N-K+I-1, IB, &
            A( 1, N-K+I ), LDA, WORK, LDWORK, A, LDA, &
            WORK( IB+1 ), LDWORK )
    END IF
!
!       Apply H to rows 1:m-k+i+ib-1 of current block
!
    CALL DORG2L( M-K+I+IB-1, IB, IB, A( 1, N-K+I ), LDA, &
         TAU( I ), WORK, IINFO )
!
!       Set rows m-k+i+ib:m of current block to zero
!
    DO 40 J = N - K + I, N - K + I + IB - 1
       DO 30 L = M - K + I + IB, M
      A( L, J ) = ZERO
   30      CONTINUE
   40   CONTINUE
   50    CONTINUE
  END IF
!
  WORK( 1 ) = IWS
  RETURN
!
!     End of DORGQL
!
  END

  SUBROUTINE DORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, LWORK, M, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DORGQR generates an M-by-N real matrix Q with orthonormal columns,
!  which is defined as the first N columns of a product of K elementary
!  reflectors of order M
!
!    Q  =  H(1) H(2) . . . H(k)
!
!  as returned by DGEQRF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the i-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by DGEQRF in the first k columns of its array
!      argument A.
!      On exit, the M-by-N matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) REAL array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by DGEQRF.
!
!  WORK    (workspace/output) REAL array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK. LWORK >= max(1,N).
!      For optimum performance LWORK >= N*NB, where NB is the
!      optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY
  INTEGER    I, IB, IINFO, IWS, J, KI, KK, L, LDWORK, &
         LWKOPT, NB, NBMIN, NX
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLARFB, DLARFT, DORG2R, XERBLA
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  NB = ILAENV( 1, 'DORGQR', ' ', M, N, K, -1 )
  LWKOPT = MAX( 1, N )*NB
  WORK( 1 ) = LWKOPT
  LQUERY = ( LWORK == -1 )
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  ELSE IF( LWORK < MAX( 1, N )  AND   NOT LQUERY ) THEN
     INFO = -8
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DORGQR', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  NBMIN = 2
  NX = 0
  IWS = N
  IF( NB > 1  AND  NB < K ) THEN
!
!    Determine when to cross over from blocked to unblocked code.
!
     NX = MAX( 0, ILAENV( 3, 'DORGQR', ' ', M, N, K, -1 ) )
     IF( NX < K ) THEN
!
!       Determine if workspace is large enough for blocked code.
!
    LDWORK = N
    IWS = LDWORK*NB
    IF( LWORK < IWS ) THEN
!
!      Not enough workspace to use optimal NB:  reduce NB and
!      determine the minimum value of NB.
!
       NB = LWORK / LDWORK
       NBMIN = MAX( 2, ILAENV( 2, 'DORGQR', ' ', M, N, K, -1 ) )
    END IF
     END IF
  END IF
!
  IF( NB.GE.NBMIN  AND  NB < K  AND  NX < K ) THEN
!
!    Use blocked code after the last block.
!    The first kk columns are handled by the block method.
!
     KI = ( ( K-NX-1 ) / NB )*NB
     KK = MIN( K, KI+NB )
!
!    Set A(1:kk,kk+1:n) to zero.
!
     DO 20 J = KK + 1, N
    DO 10 I = 1, KK
       A( I, J ) = ZERO
   10   CONTINUE
   20    CONTINUE
  ELSE
     KK = 0
  END IF
!
!     Use unblocked code for the last or only block.
!
  IF( KK < N ) CALL DORG2R( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA, &
          TAU( KK+1 ), WORK, IINFO )
!
  IF( KK > 0 ) THEN
!
!    Use blocked code
!
     DO 50 I = KI + 1, 1, -NB
    IB = MIN( NB, K-I+1 )
    IF( I+IB <= N ) THEN
!
!      Form the triangular factor of the block reflector
!      H = H(i) H(i+1) . . . H(i+ib-1)
!
       CALL DLARFT( 'Forward', 'Columnwise', M-I+1, IB, &
            A( I, I ), LDA, TAU( I ), WORK, LDWORK )
!
!      Apply H to A(i:m,i+ib:n) from the left
!
       CALL DLARFB( 'Left', 'No transpose', 'Forward', &
            'Columnwise', M-I+1, N-I-IB+1, IB, &
            A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ), &
            LDA, WORK( IB+1 ), LDWORK )
    END IF
!
!       Apply H to rows i:m of current block
!
    CALL DORG2R( M-I+1, IB, IB, A( I, I ), LDA, TAU( I ), WORK, IINFO )
!
!       Set rows 1:i-1 of current block to zero
!
    DO 40 J = I, I + IB - 1
       DO 30 L = 1, I - 1
      A( L, J ) = ZERO
   30      CONTINUE
   40   CONTINUE
   50    CONTINUE
  END IF
!
  WORK( 1 ) = IWS
  RETURN
!
!     End of DORGQR
!
  END

  SUBROUTINE DORGTR( UPLO, N, A, LDA, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DORGTR generates a real orthogonal matrix Q which is defined as the
!  product of n-1 elementary reflectors of order N, as returned by
!  DSYTRD:
!
!  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
!
!  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      = 'U': Upper triangle of A contains elementary reflectors
!         from DSYTRD;
!      = 'L': Lower triangle of A contains elementary reflectors
!         from DSYTRD.
!
!  N   (input) INTEGER
!      The order of the matrix Q. N >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the vectors which define the elementary reflectors,
!      as returned by DSYTRD.
!      On exit, the N-by-N orthogonal matrix Q.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A. LDA >= max(1,N).
!
!  TAU     (input) REAL array, dimension (N-1)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by DSYTRD.
!
!  WORK    (workspace/output) REAL array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK. LWORK >= max(1,N-1).
!      For optimum performance LWORK >= (N-1)*NB, where NB is
!      the optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY, UPPER
  INTEGER    I, IINFO, J, LWKOPT, NB
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. External Subroutines ..
  EXTERNAL       DORGQL, DORGQR, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  LQUERY = ( LWORK == -1 )
  UPPER =  scan( UPLO, 'Uu' )>0
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  ELSE IF( LWORK < MAX( 1, N-1 )  AND   NOT LQUERY ) THEN
     INFO = -7
  END IF
!
  IF( INFO == 0 ) THEN
     IF( UPPER ) THEN
    NB = ILAENV( 1, 'DORGQL', ' ', N-1, N-1, N-1, -1 )
     ELSE
    NB = ILAENV( 1, 'DORGQR', ' ', N-1, N-1, N-1, -1 )
     END IF
     LWKOPT = MAX( 1, N-1 )*NB
     WORK( 1 ) = LWKOPT
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DORGTR', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  IF( UPPER ) THEN
!
!    Q was determined by a call to DSYTRD with UPLO = 'U'
!
!    Shift the vectors which define the elementary reflectors one
!    column to the left, and set the last row and column of Q to
!    those of the unit matrix
!
     DO 20 J = 1, N - 1
    DO 10 I = 1, J - 1
       A( I, J ) = A( I, J+1 )
   10   CONTINUE
    A( N, J ) = ZERO
   20    CONTINUE
     DO 30 I = 1, N - 1
    A( I, N ) = ZERO
   30    CONTINUE
     A( N, N ) = ONE
!
!    Generate Q(1:n-1,1:n-1)
!
     CALL DORGQL( N-1, N-1, N-1, A, LDA, TAU, WORK, LWORK, IINFO )
!
  ELSE
!
!    Q was determined by a call to DSYTRD with UPLO = 'L'.
!
!    Shift the vectors which define the elementary reflectors one
!    column to the right, and set the first row and column of Q to
!    those of the unit matrix
!
     DO 50 J = N, 2, -1
    A( 1, J ) = ZERO
    DO 40 I = J + 1, N
       A( I, J ) = A( I, J-1 )
   40   CONTINUE
   50    CONTINUE
     A( 1, 1 ) = ONE
     DO 60 I = 2, N
    A( I, 1 ) = ZERO
   60    CONTINUE
     IF( N > 1 ) THEN
!
!       Generate Q(2:n,2:n)
!
    CALL DORGQR( N-1, N-1, N-1, A( 2, 2 ), LDA, TAU, WORK, LWORK, IINFO)
     END IF
  END IF
  WORK( 1 ) = LWKOPT
  RETURN
!
!     End of DORGTR
!
  END
  subroutine  dscal(n,da,dx,incx)
!
!     scales a vector by a constant.
!     uses unrolled loops for increment equal to one.
!     jack dongarra, linpack, 3/11/78.
!     modified 3/93 to return if incx  <=  0.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  REAL da,dx(*)
  INT i,incx,m,mp1,n,nincx
!
  if ( n <= 0 .or. incx <= 0 ) return
  if (incx == 1)go to 20
!
!    code for increment not equal to 1
!
  nincx = n*incx
  do 10 i = 1,nincx,incx
    dx(i) = da*dx(i)
   10 continue
  return
!
!    code for increment equal to 1
!
!
!    clean-up loop
!
   20 m = mod(n,5)
  if ( m  ==  0 ) go to 40
  do 30 i = 1,m
    dx(i) = da*dx(i)
   30 continue
  if ( n  <  5 ) return
   40 mp1 = m + 1
  do 50 i = mp1,n,5
    dx(i) = da*dx(i)
    dx(i + 1) = da*dx(i + 1)
    dx(i + 2) = da*dx(i + 2)
    dx(i + 3) = da*dx(i + 3)
    dx(i + 4) = da*dx(i + 4)
   50 continue
  return
  END

  SUBROUTINE DSTEQR( COMPZ, N, D, E, Z, LDZ, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      COMPZ
  INTEGER    INFO, LDZ, N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * ), WORK( * ), Z( LDZ, * )
!     ..
!
!  Purpose
!  =======
!
!  DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
!  symmetric tridiagonal matrix using the implicit QL or QR method.
!  The eigenvectors of a full or band symmetric matrix can also be found
!  if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
!  tridiagonal form.
!
!  Arguments
!  =========
!
!  COMPZ   (input) STR(len=1)
!      = 'N':  Compute eigenvalues only.
!      = 'V':  Compute eigenvalues and eigenvectors of the original
!      symmetric matrix.  On entry, Z must contain the
!      orthogonal matrix used to reduce the original matrix
!      to tridiagonal form.
!      = 'I':  Compute eigenvalues and eigenvectors of the
!      tridiagonal matrix.  Z is initialized to the identity
!      matrix.
!
!  N   (input) INTEGER
!      The order of the matrix.  N >= 0.
!
!  D   (input/output) REAL array, dimension (N)
!      On entry, the diagonal elements of the tridiagonal matrix.
!      On exit, if INFO = 0, the eigenvalues in ascending order.
!
!  E   (input/output) REAL array, dimension (N-1)
!      On entry, the (n-1) subdiagonal elements of the tridiagonal
!      matrix.
!      On exit, E has been destroyed.
!
!  Z   (input/output) REAL array, dimension (LDZ, N)
!      On entry, if  COMPZ = 'V', then Z contains the orthogonal
!      matrix used in the reduction to tridiagonal form.
!      On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
!      orthonormal eigenvectors of the original symmetric matrix,
!      and if COMPZ = 'I', Z contains the orthonormal eigenvectors
!      of the symmetric tridiagonal matrix.
!      If COMPZ = 'N', then Z is not referenced.
!
!  LDZ     (input) INTEGER
!      The leading dimension of the array Z.  LDZ >= 1, and if
!      eigenvectors are desired, then  LDZ >= max(1,N).
!
!  WORK    (workspace) REAL array, dimension (max(1,2*N-2))
!      If COMPZ = 'N', then WORK is not referenced.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  the algorithm has failed to find all the eigenvalues in
!        a total of 30*N iterations; if INFO = i, then i
!        elements of E have not converged to zero; on exit, D
!        and E contain the elements of a symmetric tridiagonal
!        matrix which is orthogonally similar to the original
!        matrix.
!
!  =====================================================================
!
!     .. Parameters ..
  INTEGER    MAXIT
  PARAMETER      ( MAXIT = 30 )
!     ..
!     .. Local Scalars ..
  INTEGER    I, ICOMPZ, II, ISCALE, J, JTOT, K, L, L1, LEND, &
         LENDM1, LENDP1, LENDSV, LM1, LSV, M, MM, MM1, &
         NM1, NMAXIT
  REAL   ANORM, B, C, EPS, EPS2, F, G, P, R, RT1, RT2, &
         S, SAFMAX, SAFMIN, SSFMAX, SSFMIN, TST
!     ..
!     .. External Functions ..
  REAL   DLANST, DLAPY2
  EXTERNAL       DLANST, DLAPY2
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLAE2, DLAEV2, DLARTG, DLASCL, DLASET, DLASR, &
         DLASRT, DSWAP, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  INFO = 0
!
  IF(  scan( COMPZ, 'Nn' )>0 ) THEN
     ICOMPZ = 0
  ELSE IF(  scan( COMPZ, 'Vv' )>0 ) THEN
     ICOMPZ = 1
  ELSE IF(  scan( COMPZ, 'Ii' )>0 ) THEN
     ICOMPZ = 2
  ELSE
     ICOMPZ = -1
  END IF
  IF( ICOMPZ < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( ( LDZ < 1 )  OR  ( ICOMPZ > 0  AND  LDZ < MAX( 1, N ) ) ) THEN
     INFO = -6
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DSTEQR', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
  IF( N == 1 ) THEN
     IF( ICOMPZ == 2 ) Z( 1, 1 ) = ONE
     RETURN
  END IF
!
!     Determine the unit roundoff and over/underflow thresholds.
!
  EPS = epsilon(ZERO)/radix(ZERO)
  EPS2 = EPS**2
  SAFMIN = tiny(ZERO)
  SAFMAX = ONE / SAFMIN
  SSFMAX = SQRT( SAFMAX ) / THREE
  SSFMIN = SQRT( SAFMIN ) / EPS2
!
!     Compute the eigenvalues and eigenvectors of the tridiagonal
!     matrix.
!
  IF( ICOMPZ == 2 ) CALL DLASET( 'Full', N, N, ZERO, ONE, Z, LDZ )
!
  NMAXIT = N*MAXIT
  JTOT = 0
!
!     Determine where the matrix splits and choose QL or QR iteration
!     for each block, according to whether top or bottom diagonal
!     element is smaller.
!
  L1 = 1
  NM1 = N - 1
!
   10 CONTINUE
  IF( L1 > N ) GO TO 160
  IF( L1 > 1 ) E( L1-1 ) = ZERO
  IF( L1 <= NM1 ) THEN
     DO 20 M = L1, NM1
    TST = ABS( E( M ) )
    IF( TST == ZERO ) GO TO 30
    IF( TST <= ( SQRT( ABS( D( M ) ) )*SQRT( ABS( D(M+1) ) ) )*EPS) THEN
       E( M ) = ZERO
       GO TO 30
    END IF
   20    CONTINUE
  END IF
  M = N
!
   30 CONTINUE
  L = L1
  LSV = L
  LEND = M
  LENDSV = LEND
  L1 = M + 1
  IF( LEND == L ) GO TO 10
!
!     Scale submatrix in rows and columns L to LEND
!
  ANORM = DLANST( 'I', LEND-L+1, D( L ), E( L ) )
  ISCALE = 0
  IF( ANORM == ZERO ) GO TO 10
  IF( ANORM > SSFMAX ) THEN
     ISCALE = 1
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N, INFO )
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N, INFO )
  ELSE IF( ANORM < SSFMIN ) THEN
     ISCALE = 2
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N, INFO )
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N, INFO )
  END IF
!
!     Choose between QL and QR iteration
!
  IF( ABS( D( LEND ) ) < ABS( D( L ) ) ) THEN
     LEND = LSV
     L = LENDSV
  END IF
!
  IF( LEND > L ) THEN
!
!    QL Iteration
!
!    Look for small subdiagonal element.
!
   40    CONTINUE
     IF( L/=LEND ) THEN
    LENDM1 = LEND - 1
    DO 50 M = L, LENDM1
       TST = ABS( E( M ) )**2
       IF( TST <= ( EPS2*ABS( D(M) ) )*ABS( D(M+1) )+ SAFMIN) GO TO 60
   50   CONTINUE
     END IF
!
     M = LEND
!
   60    CONTINUE
     IF( M < LEND ) E( M ) = ZERO
     P = D( L )
     IF( M == L ) GO TO 80
!
!    If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
!    to compute its eigensystem.
!
     IF( M == L+1 ) THEN
    IF( ICOMPZ > 0 ) THEN
       CALL DLAEV2( D( L ), E( L ), D( L+1 ), RT1, RT2, C, S )
       WORK( L ) = C
       WORK( N-1+L ) = S
       CALL DLASR( 'R', 'V', 'B', N, 2, WORK( L ), &
           WORK( N-1+L ), Z( 1, L ), LDZ )
    ELSE
       CALL DLAE2( D( L ), E( L ), D( L+1 ), RT1, RT2 )
    END IF
    D( L ) = RT1
    D( L+1 ) = RT2
    E( L ) = ZERO
    L = L + 2
    IF( L <= LEND ) GO TO 40
    GO TO 140
     END IF
!
     IF( JTOT == NMAXIT ) GO TO 140
     JTOT = JTOT + 1
!
!    Form shift.
!
     G = ( D( L+1 )-P ) / ( TWO*E( L ) )
     R = DLAPY2( G, ONE )
     G = D( M ) - P + ( E( L ) / ( G+SIGN( R, G ) ) )
!
     S = ONE
     C = ONE
     P = ZERO
!
!    Inner loop
!
     MM1 = M - 1
     DO 70 I = MM1, L, -1
    F = S*E( I )
    B = C*E( I )
    CALL DLARTG( G, F, C, S, R )
    IF( I/=M-1 ) E( I+1 ) = R
    G = D( I+1 ) - P
    R = ( D( I )-G )*S + TWO*C*B
    P = S*R
    D( I+1 ) = G + P
    G = C*R - B
!
!       If eigenvectors are desired, then save rotations.
!
    IF( ICOMPZ > 0 ) THEN
       WORK( I ) = C
       WORK( N-1+I ) = -S
    END IF
!
   70    CONTINUE
!
!    If eigenvectors are desired, then apply saved rotations.
!
     IF( ICOMPZ > 0 ) THEN
    MM = M - L + 1
    CALL DLASR( 'R', 'V', 'B', N, MM, WORK( L ), WORK( N-1+L ), &
        Z( 1, L ), LDZ )
     END IF
!
     D( L ) = D( L ) - P
     E( L ) = G
     GO TO 40
!
!    Eigenvalue found.
!
   80    CONTINUE
     D( L ) = P
!
     L = L + 1
     IF( L <= LEND ) GO TO 40
     GO TO 140
!
  ELSE
!
!    QR Iteration
!
!    Look for small superdiagonal element.
!
   90    CONTINUE
     IF( L/=LEND ) THEN
    LENDP1 = LEND + 1
    DO 100 M = L, LENDP1, -1
       TST = ABS( E( M-1 ) )**2
       IF( TST <= ( EPS2*ABS( D(M) ) )*ABS( D(M-1) )+ SAFMIN )GO TO 110
  100   CONTINUE
     END IF
!
     M = LEND
!
  110    CONTINUE
     IF( M > LEND ) E( M-1 ) = ZERO
     P = D( L )
     IF( M == L ) GO TO 130
!
!    If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
!    to compute its eigensystem.
!
     IF( M == L-1 ) THEN
    IF( ICOMPZ > 0 ) THEN
       CALL DLAEV2( D( L-1 ), E( L-1 ), D( L ), RT1, RT2, C, S )
       WORK( M ) = C
       WORK( N-1+M ) = S
       CALL DLASR( 'R', 'V', 'F', N, 2, WORK( M ), &
           WORK( N-1+M ), Z( 1, L-1 ), LDZ )
    ELSE
       CALL DLAE2( D( L-1 ), E( L-1 ), D( L ), RT1, RT2 )
    END IF
    D( L-1 ) = RT1
    D( L ) = RT2
    E( L-1 ) = ZERO
    L = L - 2
    IF( L.GE.LEND ) GO TO 90
    GO TO 140
     END IF
!
     IF( JTOT == NMAXIT ) GO TO 140
     JTOT = JTOT + 1
!
!    Form shift.
!
     G = ( D( L-1 )-P ) / ( TWO*E( L-1 ) )
     R = DLAPY2( G, ONE )
     G = D( M ) - P + ( E( L-1 ) / ( G+SIGN( R, G ) ) )
!
     S = ONE
     C = ONE
     P = ZERO
!
!    Inner loop
!
     LM1 = L - 1
     DO 120 I = M, LM1
    F = S*E( I )
    B = C*E( I )
    CALL DLARTG( G, F, C, S, R )
    IF( I/=M ) E( I-1 ) = R
    G = D( I ) - P
    R = ( D( I+1 )-G )*S + TWO*C*B
    P = S*R
    D( I ) = G + P
    G = C*R - B
!
!       If eigenvectors are desired, then save rotations.
!
    IF( ICOMPZ > 0 ) THEN
       WORK( I ) = C
       WORK( N-1+I ) = S
    END IF
!
  120    CONTINUE
!
!    If eigenvectors are desired, then apply saved rotations.
!
     IF( ICOMPZ > 0 ) THEN
    MM = L - M + 1
    CALL DLASR( 'R', 'V', 'F', N, MM, WORK( M ), WORK( N-1+M ), &
        Z( 1, M ), LDZ )
     END IF
!
     D( L ) = D( L ) - P
     E( LM1 ) = G
     GO TO 90
!
!    Eigenvalue found.
!
  130    CONTINUE
     D( L ) = P
!
     L = L - 1
     IF( L.GE.LEND ) GO TO 90
     GO TO 140
!
  END IF
!
!     Undo scaling if necessary
!
  140 CONTINUE
  IF( ISCALE == 1 ) THEN
     CALL DLASCL('G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1, D(LSV), N, INFO)
     CALL DLASCL('G', 0, 0, SSFMAX, ANORM, LENDSV-LSV, 1, E( LSV ), N, INFO)
  ELSE IF( ISCALE == 2 ) THEN
     CALL DLASCL('G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1, D(LSV), N, INFO)
     CALL DLASCL('G', 0, 0, SSFMIN, ANORM, LENDSV-LSV, 1, E(LSV), N, INFO)
  END IF
!
!     Check for no convergence to an eigenvalue after a total
!     of N*MAXIT iterations.
!
  IF( JTOT < NMAXIT ) GO TO 10
  DO 150 I = 1, N - 1
     IF( E( I )/=ZERO ) INFO = INFO + 1
  150 CONTINUE
  GO TO 190
!
!     Order eigenvalues and eigenvectors.
!
  160 CONTINUE
  IF( ICOMPZ == 0 ) THEN
!
!    Use Quick Sort
!
     CALL DLASRT( 'I', N, D, INFO )
!
  ELSE
!
!    Use Selection Sort to minimize swaps of eigenvectors
!
     DO 180 II = 2, N
    I = II - 1
    K = I
    P = D( I )
    DO 170 J = II, N
       IF( D( J ) < P ) THEN
      K = J
      P = D( J )
       END IF
  170   CONTINUE
    IF( K/=I ) THEN
       D( K ) = D( I )
       D( I ) = P
       CALL DSWAP( N, Z( 1, I ), 1, Z( 1, K ), 1 )
    END IF
  180    CONTINUE
  END IF
!
  190 CONTINUE
  RETURN
!
!     End of DSTEQR
!
  END

  SUBROUTINE DSTERF( N, D, E, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INFO, N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * )
!     ..
!
!  Purpose
!  =======
!
!  DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
!  using the Pal-Walker-Kahan variant of the QL or QR algorithm.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The order of the matrix.  N >= 0.
!
!  D   (input/output) REAL array, dimension (N)
!      On entry, the n diagonal elements of the tridiagonal matrix.
!      On exit, if INFO = 0, the eigenvalues in ascending order.
!
!  E   (input/output) REAL array, dimension (N-1)
!      On entry, the (n-1) subdiagonal elements of the tridiagonal
!      matrix.
!      On exit, E has been destroyed.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  the algorithm failed to find all of the eigenvalues in
!        a total of 30*N iterations; if INFO = i, then i
!        elements of E have not converged to zero.
!
!  =====================================================================
!
!     .. Parameters ..
  INTEGER    MAXIT
  PARAMETER      ( MAXIT = 30 )
!     ..
!     .. Local Scalars ..
  INTEGER    I, ISCALE, JTOT, L, L1, LEND, LENDSV, LSV, M, NMAXIT
  REAL   ALPHA, ANORM, BB, C, EPS, EPS2, GAMMA, OLDC, &
         OLDGAM, P, R, RT1, RT2, RTE, S, SAFMAX, SAFMIN, &
         SIGMA, SSFMAX, SSFMIN
!     ..
!     .. External Functions ..
  REAL   DLANST, DLAPY2
  EXTERNAL       DLANST, DLAPY2
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLAE2, DLASCL, DLASRT, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  INFO = 0
!
!     Quick return if possible
!
  IF( N < 0 ) THEN
     INFO = -1
     CALL XERBLA( 'DSTERF', -INFO )
     RETURN
  END IF
  IF( N <= 1 ) RETURN
!
!     Determine the unit roundoff for this environment.
!
  EPS = epsilon(ZERO)/radix(ZERO)
  EPS2 = EPS**2
  SAFMIN = tiny(ZERO)
  SAFMAX = ONE / SAFMIN
  SSFMAX = SQRT( SAFMAX ) / THREE
  SSFMIN = SQRT( SAFMIN ) / EPS2
!
!     Compute the eigenvalues of the tridiagonal matrix.
!
  NMAXIT = N*MAXIT
  SIGMA = ZERO
  JTOT = 0
!
!     Determine where the matrix splits and choose QL or QR iteration
!     for each block, according to whether top or bottom diagonal
!     element is smaller.
!
  L1 = 1
!
   10 CONTINUE
  IF( L1 > N ) GO TO 170
  IF( L1 > 1 ) E( L1-1 ) = ZERO
  DO 20 M = L1, N - 1
     IF( ABS( E( M ) ) <= ( SQRT( ABS( D( M ) ) )*SQRT( ABS( D( M+ &
     1 ) ) ) )*EPS ) THEN
    E( M ) = ZERO
    GO TO 30
     END IF
   20 CONTINUE
  M = N
!
   30 CONTINUE
  L = L1
  LSV = L
  LEND = M
  LENDSV = LEND
  L1 = M + 1
  IF( LEND == L ) GO TO 10
!
!     Scale submatrix in rows and columns L to LEND
!
  ANORM = DLANST( 'I', LEND-L+1, D( L ), E( L ) )
  ISCALE = 0
  IF( ANORM > SSFMAX ) THEN
     ISCALE = 1
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N, INFO )
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N, INFO )
  ELSE IF( ANORM < SSFMIN ) THEN
     ISCALE = 2
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N, INFO )
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N, INFO )
  END IF
!
  DO 40 I = L, LEND - 1
     E( I ) = E( I )**2
   40 CONTINUE
!
!     Choose between QL and QR iteration
!
  IF( ABS( D( LEND ) ) < ABS( D( L ) ) ) THEN
     LEND = LSV
     L = LENDSV
  END IF
!
  IF( LEND.GE.L ) THEN
!
!    QL Iteration
!
!    Look for small subdiagonal element.
!
   50    CONTINUE
     IF( L/=LEND ) THEN
    DO 60 M = L, LEND - 1
       IF( ABS( E( M ) ) <= EPS2*ABS( D( M )*D( M+1 ) ) ) GO TO 70
   60   CONTINUE
     END IF
     M = LEND
!
   70    CONTINUE
     IF( M < LEND ) E( M ) = ZERO
     P = D( L )
     IF( M == L ) GO TO 90
!
!    If remaining matrix is 2 by 2, use DLAE2 to compute its
!    eigenvalues.
!
     IF( M == L+1 ) THEN
    RTE = SQRT( E( L ) )
    CALL DLAE2( D( L ), RTE, D( L+1 ), RT1, RT2 )
    D( L ) = RT1
    D( L+1 ) = RT2
    E( L ) = ZERO
    L = L + 2
    IF( L <= LEND ) GO TO 50
    GO TO 150
     END IF
!
     IF( JTOT == NMAXIT ) GO TO 150
     JTOT = JTOT + 1
!
!    Form shift.
!
     RTE = SQRT( E( L ) )
     SIGMA = ( D( L+1 )-P ) / ( TWO*RTE )
     R = DLAPY2( SIGMA, ONE )
     SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) )
!
     C = ONE
     S = ZERO
     GAMMA = D( M ) - SIGMA
     P = GAMMA*GAMMA
!
!    Inner loop
!
     DO 80 I = M - 1, L, -1
    BB = E( I )
    R = P + BB
    IF( I/=M-1 ) E( I+1 ) = S*R
    OLDC = C
    C = P / R
    S = BB / R
    OLDGAM = GAMMA
    ALPHA = D( I )
    GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM
    D( I+1 ) = OLDGAM + ( ALPHA-GAMMA )
    IF( C/=ZERO ) THEN
       P = ( GAMMA*GAMMA ) / C
    ELSE
       P = OLDC*BB
    END IF
   80    CONTINUE
!
     E( L ) = S*P
     D( L ) = SIGMA + GAMMA
     GO TO 50
!
!    Eigenvalue found.
!
   90    CONTINUE
     D( L ) = P
!
     L = L + 1
     IF( L <= LEND ) GO TO 50
     GO TO 150
!
  ELSE
!
!    QR Iteration
!
!    Look for small superdiagonal element.
!
  100    CONTINUE
     DO 110 M = L, LEND + 1, -1
    IF( ABS( E( M-1 ) ) <= EPS2*ABS( D( M )*D( M-1 ) ) ) GO TO 120
  110    CONTINUE
     M = LEND
!
  120    CONTINUE
     IF( M > LEND ) E( M-1 ) = ZERO
     P = D( L )
     IF( M == L ) GO TO 140
!
!    If remaining matrix is 2 by 2, use DLAE2 to compute its
!    eigenvalues.
!
     IF( M == L-1 ) THEN
    RTE = SQRT( E( L-1 ) )
    CALL DLAE2( D( L ), RTE, D( L-1 ), RT1, RT2 )
    D( L ) = RT1
    D( L-1 ) = RT2
    E( L-1 ) = ZERO
    L = L - 2
    IF( L.GE.LEND ) GO TO 100
    GO TO 150
     END IF
!
     IF( JTOT == NMAXIT ) GO TO 150
     JTOT = JTOT + 1
!
!    Form shift.
!
     RTE = SQRT( E( L-1 ) )
     SIGMA = ( D( L-1 )-P ) / ( TWO*RTE )
     R = DLAPY2( SIGMA, ONE )
     SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) )
!
     C = ONE
     S = ZERO
     GAMMA = D( M ) - SIGMA
     P = GAMMA*GAMMA
!
!    Inner loop
!
     DO 130 I = M, L - 1
    BB = E( I )
    R = P + BB
    IF( I/=M ) E( I-1 ) = S*R
    OLDC = C
    C = P / R
    S = BB / R
    OLDGAM = GAMMA
    ALPHA = D( I+1 )
    GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM
    D( I ) = OLDGAM + ( ALPHA-GAMMA )
    IF( C/=ZERO ) THEN
       P = ( GAMMA*GAMMA ) / C
    ELSE
       P = OLDC*BB
    END IF
  130    CONTINUE
!
     E( L-1 ) = S*P
     D( L ) = SIGMA + GAMMA
     GO TO 100
!
!    Eigenvalue found.
!
  140    CONTINUE
     D( L ) = P
!
     L = L - 1
     IF( L.GE.LEND ) GO TO 100
     GO TO 150
!
  END IF
!
!     Undo scaling if necessary
!
  150 CONTINUE
  IF( ISCALE == 1 ) &
     CALL DLASCL('G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1, D(LSV), N, INFO)
  IF( ISCALE == 2 ) &
     CALL DLASCL('G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1, D(LSV), N, INFO)
!
!     Check for no convergence to an eigenvalue after a total
!     of N*MAXIT iterations.
!
  IF( JTOT < NMAXIT ) GO TO 10
  DO 160 I = 1, N - 1
     IF( E( I )/=ZERO ) INFO = INFO + 1
  160 CONTINUE
  GO TO 180
!
!     Sort eigenvalues in increasing order.
!
  170 CONTINUE
  CALL DLASRT( 'I', N, D, INFO )
!
  180 CONTINUE
  RETURN
!
!     End of DSTERF
!
  END
  subroutine  dswap (n,dx,incx,dy,incy)
!
!     interchanges two vectors.
!     uses unrolled loops for increments equal one.
!     jack dongarra, linpack, 3/11/78.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  REAL dx(*),dy(*),dtemp
  INT i,incx,incy,ix,iy,m,mp1,n
!
  if (n <= 0) return
  if (incx == 1 AND incy == 1)go to 20
!
!   code for unequal increments or equal increments not equal
!     to 1
!
  ix = 1
  iy = 1
  if (incx < 0)ix = (-n+1)*incx + 1
  if (incy < 0)iy = (-n+1)*incy + 1
  do 10 i = 1,n
    dtemp = dx(ix)
    dx(ix) = dy(iy)
    dy(iy) = dtemp
    ix = ix + incx
    iy = iy + incy
   10 continue
  return
!
!   code for both increments equal to 1
!
!
!   clean-up loop
!
   20 m = mod(n,3)
  if ( m  ==  0 ) go to 40
  do 30 i = 1,m
    dtemp = dx(i)
    dx(i) = dy(i)
    dy(i) = dtemp
   30 continue
  if ( n  <  3 ) return
   40 mp1 = m + 1
  do 50 i = mp1,n,3
    dtemp = dx(i)
    dx(i) = dy(i)
    dy(i) = dtemp
    dtemp = dx(i + 1)
    dx(i + 1) = dy(i + 1)
    dy(i + 1) = dtemp
    dtemp = dx(i + 2)
    dx(i + 2) = dy(i + 2)
    dy(i + 2) = dtemp
   50 continue
  return
  end

  SUBROUTINE DSYEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, INFO )
!
!  -- LAPACK driver routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  CHR      JOBZ, UPLO
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), W( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DSYEV computes all eigenvalues and, optionally, eigenvectors of a
!  real symmetric matrix A.
!
!  Arguments
!  =========
!
!  JOBZ    (input) STR(len=1)
!      = 'N':  Compute eigenvalues only;
!      = 'V':  Compute eigenvalues and eigenvectors.
!
!  UPLO    (input) STR(len=1)
!      = 'U':  Upper triangle of A is stored;
!      = 'L':  Lower triangle of A is stored.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) REAL array, dimension (LDA, N)
!      On entry, the symmetric matrix A.  If UPLO = 'U', the
!      leading N-by-N upper triangular part of A contains the
!      upper triangular part of the matrix A.  If UPLO = 'L',
!      the leading N-by-N lower triangular part of A contains
!      the lower triangular part of the matrix A.
!      On exit, if JOBZ = 'V', then if INFO = 0, A contains the
!      orthonormal eigenvectors of the matrix A.
!      If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
!      or the upper triangle (if UPLO='U') of A, including the
!      diagonal, is destroyed.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  W   (output) REAL array, dimension (N)
!      If INFO = 0, the eigenvalues in ascending order.
!
!  WORK    (workspace/output) REAL array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The length of the array WORK.  LWORK >= max(1,3*N-1).
!      For optimal efficiency, LWORK >= (NB+2)*N,
!      where NB is the blocksize for DSYTRD returned by ILAENV.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  if INFO = i, the algorithm failed to converge; i
!        off-diagonal elements of an intermediate tridiagonal
!        form did not converge to zero.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LOWER, LQUERY, WANTZ
  INTEGER    IINFO, IMAX, INDE, INDTAU, INDWRK, ISCALE, &
         LLWORK, LOPT, LWKOPT, NB
  REAL   ANRM, BIGNUM, EPS, RMAX, RMIN, SAFMIN, SIGMA, SMLNUM
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  REAL   DLANSY
  EXTERNAL       ILAENV, DLANSY
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLASCL, DORGTR, DSCAL, DSTEQR, DSTERF, DSYTRD, XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  WANTZ =  scan( JOBZ, 'Vv' )>0
  LOWER =  scan( UPLO, 'Ll' )>0
  LQUERY = ( LWORK == -1 )
!
  INFO = 0
  IF(  NOT ( WANTZ  OR   scan( JOBZ, 'Nn' )>0 ) ) THEN
     INFO = -1
  ELSE IF(  NOT ( LOWER  OR   scan( UPLO, 'Uu' )>0 ) ) THEN
     INFO = -2
  ELSE IF( N < 0 ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -5
  ELSE IF( LWORK < MAX( 1, 3*N-1 )  AND   NOT LQUERY ) THEN
     INFO = -8
  END IF
!
  IF( INFO == 0 ) THEN
     NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 )
     LWKOPT = MAX( 1, ( NB+2 )*N )
     WORK( 1 ) = LWKOPT
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DSYEV ', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  IF( N == 1 ) THEN
     W( 1 ) = A( 1, 1 )
     WORK( 1 ) = 3
     IF( WANTZ ) A( 1, 1 ) = ONE
     RETURN
  END IF
!
!     Get machine constants.
!
  SAFMIN = tiny(ZERO)
  EPS = epsilon(ZERO)
  SMLNUM = SAFMIN / EPS
  BIGNUM = ONE / SMLNUM
  RMIN = SQRT( SMLNUM )
  RMAX = SQRT( BIGNUM )
!
!     Scale matrix to allowable range, if necessary.
!
  ANRM = DLANSY( 'M', UPLO, N, A, LDA, WORK )
  ISCALE = 0
  IF( ANRM > ZERO  AND  ANRM < RMIN ) THEN
     ISCALE = 1
     SIGMA = RMIN / ANRM
  ELSE IF( ANRM > RMAX ) THEN
     ISCALE = 1
     SIGMA = RMAX / ANRM
  END IF
  IF( ISCALE == 1 ) CALL DLASCL( UPLO, 0, 0, ONE, SIGMA, N, N, A, LDA, INFO)
!
!     Call DSYTRD to reduce symmetric matrix to tridiagonal form.
!
  INDE = 1
  INDTAU = INDE + N
  INDWRK = INDTAU + N
  LLWORK = LWORK - INDWRK + 1
  CALL DSYTRD( UPLO, N, A, LDA, W, WORK( INDE ), WORK( INDTAU ), &
       WORK( INDWRK ), LLWORK, IINFO )
  LOPT = 2*N + WORK( INDWRK )
!
!     For eigenvalues only, call DSTERF.  For eigenvectors, first call
!     DORGTR to generate the orthogonal matrix, then call DSTEQR.
!
  IF(  NOT WANTZ ) THEN
     CALL DSTERF( N, W, WORK( INDE ), INFO )
  ELSE
     CALL DORGTR(UPLO, N, A, LDA, WORK(INDTAU), WORK(INDWRK), LLWORK, IINFO)
     CALL DSTEQR( JOBZ, N, W, WORK( INDE ), A, LDA, WORK( INDTAU ), INFO)
  END IF
!
!     If matrix was scaled, then rescale eigenvalues appropriately.
!
  IF( ISCALE == 1 ) THEN
     IF( INFO == 0 ) THEN
    IMAX = N
     ELSE
    IMAX = INFO - 1
     END IF
     CALL DSCAL( IMAX, ONE / SIGMA, W, 1 )
  END IF
!
!     Set WORK(1) to optimal workspace size.
!
  WORK( 1 ) = LWKOPT
!
  RETURN
!
!     End of DSYEV
!
  END

  SUBROUTINE DSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDA, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), D( * ), E( * ), TAU( * )
!     ..
!
!  Purpose
!  =======
!
!  DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
!  form T by an orthogonal similarity transformation: Q' * A * Q = T.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      Specifies whether the upper or lower triangular part of the
!      symmetric matrix A is stored:
!      = 'U':  Upper triangular
!      = 'L':  Lower triangular
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the symmetric matrix A.  If UPLO = 'U', the leading
!      n-by-n upper triangular part of A contains the upper
!      triangular part of the matrix A, and the strictly lower
!      triangular part of A is not referenced.  If UPLO = 'L', the
!      leading n-by-n lower triangular part of A contains the lower
!      triangular part of the matrix A, and the strictly upper
!      triangular part of A is not referenced.
!      On exit, if UPLO = 'U', the diagonal and first superdiagonal
!      of A are overwritten by the corresponding elements of the
!      tridiagonal matrix T, and the elements above the first
!      superdiagonal, with the array TAU, represent the orthogonal
!      matrix Q as a product of elementary reflectors; if UPLO
!      = 'L', the diagonal and first subdiagonal of A are over-
!      written by the corresponding elements of the tridiagonal
!      matrix T, and the elements below the first subdiagonal, with
!      the array TAU, represent the orthogonal matrix Q as a product
!      of elementary reflectors. See Further Details.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  D   (output) REAL array, dimension (N)
!      The diagonal elements of the tridiagonal matrix T:
!      D(i) = A(i,i).
!
!  E   (output) REAL array, dimension (N-1)
!      The off-diagonal elements of the tridiagonal matrix T:
!      E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
!
!  TAU     (output) REAL array, dimension (N-1)
!      The scalar factors of the elementary reflectors (see Further
!      Details).
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n-1) . . . H(2) H(1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a real scalar, and v is a real vector with
!  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!  A(1:i-1,i+1), and tau in TAU(i).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(n-1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a real scalar, and v is a real vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!  and tau in TAU(i).
!
!  The contents of A on exit are illustrated by the following examples
!  with n = 5:
!
!  if UPLO = 'U':           if UPLO = 'L':
!
!    (  d   e   v2  v3  v4 )      (  d      )
!    (  d   e   v3  v4 )      (  e   d      )
!    (      d   e   v4 )      (  v1  e   d      )
!    (      d   e  )      (  v1  v2  e   d  )
!    (      d  )      (  v1  v2  v3  e   d  )
!
!  where d and e denote diagonal and off-diagonal elements of T, and vi
!  denotes an element of the vector defining H(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    UPPER
  INTEGER    I
  REAL   ALPHA, TAUI
!     ..
!     .. External Subroutines ..
  EXTERNAL       DAXPY, DLARFG, DSYMV, DSYR2, XERBLA
!     ..
!     .. External Functions ..
  REAL   DDOT
  EXTERNAL       DDOT
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  UPPER =  scan( UPLO, 'Uu' )>0
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DSYTD2', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
  IF( UPPER ) THEN
!
!    Reduce the upper triangle of A
!
     DO 10 I = N - 1, 1, -1
!
!       Generate elementary reflector H(i) = I - tau * v * v'
!       to annihilate A(1:i-1,i+1)
!
    CALL DLARFG( I, A( I, I+1 ), A( 1, I+1 ), 1, TAUI )
    E( I ) = A( I, I+1 )
!
    IF( TAUI/=ZERO ) THEN
!
!      Apply H(i) from both sides to A(1:i,1:i)
!
       A( I, I+1 ) = ONE
!
!      Compute  x := tau * A * v  storing x in TAU(1:i)
!
       CALL DSYMV( UPLO, I, TAUI, A, LDA, A( 1, I+1 ), 1, ZERO, TAU, 1)
!
!      Compute  w := x - 1/2 * tau * (x'*v) * v
!
       ALPHA = -HALF*TAUI*DDOT( I, TAU, 1, A( 1, I+1 ), 1 )
       CALL DAXPY( I, ALPHA, A( 1, I+1 ), 1, TAU, 1 )
!
!      Apply the transformation as a rank-2 update:
!         A := A - v * w' - w * v'
!
       CALL DSYR2( UPLO, I, -ONE, A( 1, I+1 ), 1, TAU, 1, A, LDA )
!
       A( I, I+1 ) = E( I )
    END IF
    D( I+1 ) = A( I+1, I+1 )
    TAU( I ) = TAUI
   10    CONTINUE
     D( 1 ) = A( 1, 1 )
  ELSE
!
!    Reduce the lower triangle of A
!
     DO 20 I = 1, N - 1
!
!       Generate elementary reflector H(i) = I - tau * v * v'
!       to annihilate A(i+2:n,i)
!
    CALL DLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1, TAUI )
    E( I ) = A( I+1, I )
!
    IF( TAUI/=ZERO ) THEN
!
!      Apply H(i) from both sides to A(i+1:n,i+1:n)
!
       A( I+1, I ) = ONE
!
!      Compute  x := tau * A * v  storing y in TAU(i:n-1)
!
       CALL DSYMV( UPLO, N-I, TAUI, A( I+1, I+1 ), LDA, &
           A( I+1, I ), 1, ZERO, TAU( I ), 1 )
!
!      Compute  w := x - 1/2 * tau * (x'*v) * v
!
       ALPHA = -HALF*TAUI*DDOT( N-I, TAU( I ), 1, A( I+1, I ), 1 )
       CALL DAXPY( N-I, ALPHA, A( I+1, I ), 1, TAU( I ), 1 )
!
!      Apply the transformation as a rank-2 update:
!         A := A - v * w' - w * v'
!
       CALL DSYR2(UPLO,N-I,-ONE,A(I+1,I),1,TAU(I),1,A(I+1,I+1),LDA)
!
       A( I+1, I ) = E( I )
    END IF
    D( I ) = A( I, I )
    TAU( I ) = TAUI
   20    CONTINUE
     D( N ) = A( N, N )
  END IF
!
  RETURN
!
!     End of DSYTD2
!
  END

  SUBROUTINE DSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  REAL   A( LDA, * ), D( * ), E( * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  DSYTRD reduces a real symmetric matrix A to real symmetric
!  tridiagonal form T by an orthogonal similarity transformation:
!  Q**T * A * Q = T.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      = 'U':  Upper triangle of A is stored;
!      = 'L':  Lower triangle of A is stored.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) REAL array, dimension (LDA,N)
!      On entry, the symmetric matrix A.  If UPLO = 'U', the leading
!      N-by-N upper triangular part of A contains the upper
!      triangular part of the matrix A, and the strictly lower
!      triangular part of A is not referenced.  If UPLO = 'L', the
!      leading N-by-N lower triangular part of A contains the lower
!      triangular part of the matrix A, and the strictly upper
!      triangular part of A is not referenced.
!      On exit, if UPLO = 'U', the diagonal and first superdiagonal
!      of A are overwritten by the corresponding elements of the
!      tridiagonal matrix T, and the elements above the first
!      superdiagonal, with the array TAU, represent the orthogonal
!      matrix Q as a product of elementary reflectors; if UPLO
!      = 'L', the diagonal and first subdiagonal of A are over-
!      written by the corresponding elements of the tridiagonal
!      matrix T, and the elements below the first subdiagonal, with
!      the array TAU, represent the orthogonal matrix Q as a product
!      of elementary reflectors. See Further Details.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  D   (output) REAL array, dimension (N)
!      The diagonal elements of the tridiagonal matrix T:
!      D(i) = A(i,i).
!
!  E   (output) REAL array, dimension (N-1)
!      The off-diagonal elements of the tridiagonal matrix T:
!      E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
!
!  TAU     (output) REAL array, dimension (N-1)
!      The scalar factors of the elementary reflectors (see Further
!      Details).
!
!  WORK    (workspace/output) REAL array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK.  LWORK >= 1.
!      For optimum performance LWORK >= N*NB, where NB is the
!      optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n-1) . . . H(2) H(1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a real scalar, and v is a real vector with
!  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!  A(1:i-1,i+1), and tau in TAU(i).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(n-1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a real scalar, and v is a real vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!  and tau in TAU(i).
!
!  The contents of A on exit are illustrated by the following examples
!  with n = 5:
!
!  if UPLO = 'U':           if UPLO = 'L':
!
!    (  d   e   v2  v3  v4 )      (  d      )
!    (  d   e   v3  v4 )      (  e   d      )
!    (      d   e   v4 )      (  v1  e   d      )
!    (      d   e  )      (  v1  v2  e   d  )
!    (      d  )      (  v1  v2  v3  e   d  )
!
!  where d and e denote diagonal and off-diagonal elements of T, and vi
!  denotes an element of the vector defining H(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY, UPPER
  INTEGER    I, IINFO, IWS, J, KK, LDWORK, LWKOPT, NB, NBMIN, NX
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLATRD, DSYR2K, DSYTD2, XERBLA
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  UPPER =  scan( UPLO, 'Uu' )>0
  LQUERY = ( LWORK == -1 )
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  ELSE IF( LWORK < 1  AND   NOT LQUERY ) THEN
     INFO = -9
  END IF
!
  IF( INFO == 0 ) THEN
!
!    Determine the block size.
!
     NB = ILAENV( 1, 'DSYTRD', UPLO, N, -1, -1, -1 )
     LWKOPT = N*NB
     WORK( 1 ) = LWKOPT
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'DSYTRD', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  NX = N
  IWS = 1
  IF( NB > 1  AND  NB < N ) THEN
!
!    Determine when to cross over from blocked to unblocked code
!    (last block is always handled by unblocked code).
!
     NX = MAX( NB, ILAENV( 3, 'DSYTRD', UPLO, N, -1, -1, -1 ) )
     IF( NX < N ) THEN
!
!       Determine if workspace is large enough for blocked code.
!
    LDWORK = N
    IWS = LDWORK*NB
    IF( LWORK < IWS ) THEN
!
!      Not enough workspace to use optimal NB:  determine the
!      minimum value of NB, and reduce NB or force use of
!      unblocked code by setting NX = N.
!
       NB = MAX( LWORK / LDWORK, 1 )
       NBMIN = ILAENV( 2, 'DSYTRD', UPLO, N, -1, -1, -1 )
       IF( NB < NBMIN ) NX = N
    END IF
     ELSE
    NX = N
     END IF
  ELSE
     NB = 1
  END IF
!
  IF( UPPER ) THEN
!
!    Reduce the upper triangle of A.
!    Columns 1:kk are handled by the unblocked method.
!
     KK = N - ( ( N-NX+NB-1 ) / NB )*NB
     DO 20 I = N - NB + 1, KK + 1, -NB
!
!       Reduce columns i:i+nb-1 to tridiagonal form and form the
!       matrix W which is needed to update the unreduced part of
!       the matrix
!
    CALL DLATRD( UPLO, I+NB-1, NB, A, LDA, E, TAU, WORK, LDWORK )
!
!       Update the unreduced submatrix A(1:i-1,1:i-1), using an
!       update of the form:  A := A - V*W' - W*V'
!
    CALL DSYR2K( UPLO, 'No transpose', I-1, NB, -ONE, A( 1, I ), &
         LDA, WORK, LDWORK, ONE, A, LDA )
!
!       Copy superdiagonal elements back into A, and diagonal
!       elements into D
!
    DO 10 J = I, I + NB - 1
       A( J-1, J ) = E( J-1 )
       D( J ) = A( J, J )
   10   CONTINUE
   20    CONTINUE
!
!    Use unblocked code to reduce the last or only block
!
     CALL DSYTD2( UPLO, KK, A, LDA, D, E, TAU, IINFO )
  ELSE
!
!    Reduce the lower triangle of A
!
     DO 40 I = 1, N - NX, NB
!
!       Reduce columns i:i+nb-1 to tridiagonal form and form the
!       matrix W which is needed to update the unreduced part of
!       the matrix
!
    CALL DLATRD( UPLO, N-I+1, NB, A( I, I ), LDA, E( I ), &
         TAU( I ), WORK, LDWORK )
!
!       Update the unreduced submatrix A(i+ib:n,i+ib:n), using
!       an update of the form:  A := A - V*W' - W*V'
!
    CALL DSYR2K( UPLO, 'No transpose', N-I-NB+1, NB, -ONE, &
         A( I+NB, I ), LDA, WORK( NB+1 ), LDWORK, ONE, &
         A( I+NB, I+NB ), LDA )
!
!       Copy subdiagonal elements back into A, and diagonal
!       elements into D
!
    DO 30 J = I, I + NB - 1
       A( J+1, J ) = E( J )
       D( J ) = A( J, J )
   30   CONTINUE
   40    CONTINUE
!
!    Use unblocked code to reduce the last or only block
!
     CALL DSYTD2( UPLO, N-I+1, A(I,I), LDA, D(I), E(I), TAU(I), IINFO )
  END IF
!
  WORK( 1 ) = LWKOPT
  RETURN
!
!     End of DSYTRD
!
  END

  FUNCTION DZNRM2( N, X, INCX ) result(res)
!     .. Scalar Arguments ..
  INTEGER           INCX, N
!     .. Array Arguments ..
  CPX        X( * )
  REAL res
!     ..
!
!  DZNRM2 returns the euclidean norm of a vector via the function
!  name, so that
!
!     DZNRM2 := sqrt( conjg( x' )*x )
!
!
!
!  -- This version written on 25-October-1982.
!     Modified on 14-October-1993 to inline the call to ZLASSQ.
!     Sven Hammarling, Nag Ltd.
!
!
!     .. Local Scalars ..
  INTEGER       IX
  REAL  NORM, SCALE, SSQ, TEMP
!     ..
!     .. Executable Statements ..
  IF( N < 1  OR  INCX < 1 )THEN
     NORM  = ZERO
  ELSE
     SCALE = ZERO
     SSQ   = ONE
!    The following loop is equivalent to this call to the LAPACK
!    auxiliary routine:
!    CALL ZLASSQ( N, X, INCX, SCALE, SSQ )
!
     DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
    IF( DBLE( X( IX ) )/=ZERO )THEN
       TEMP = ABS( DBLE( X( IX ) ) )
       IF( SCALE < TEMP )THEN
      SSQ   = ONE   + SSQ*( SCALE/TEMP )**2
      SCALE = TEMP
       ELSE
      SSQ   = SSQ   +     ( TEMP/SCALE )**2
       END IF
    END IF
    IF( AIMAG( X( IX ) )/=ZERO )THEN
       TEMP = ABS( AIMAG( X( IX ) ) )
       IF( SCALE < TEMP )THEN
      SSQ   = ONE   + SSQ*( SCALE/TEMP )**2
      SCALE = TEMP
       ELSE
      SSQ   = SSQ   +     ( TEMP/SCALE )**2
       END IF
    END IF
   10    CONTINUE
     NORM  = SCALE * SQRT( SSQ )
  END IF
!
  res = NORM
  END function
  function idamax(n,dx,incx) result (res)
!
!     finds the index of element having max. absolute value.
!     jack dongarra, linpack, 3/11/78.
!     modified 3/93 to return if incx  <=  0.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  REAL dx(*),dmax
  INT i,incx,ix,n,res
!
  res = 0
  if ( n < 1 .or. incx <= 0 ) return
  res = 1
  if (n == 1) return
  if (incx == 1)go to 20
!
!    code for increment not equal to 1
!
  ix = 1
  dmax = dabs(dx(1))
  ix = ix + incx
  do i = 2,n
     if (dabs(dx(ix)) <= dmax) go to 5
     res = i
     dmax = dabs(dx(ix))
    5    ix = ix + incx
  end do
  return
!
!    code for increment equal to 1
!
   20 dmax = dabs(dx(1))
  do i = 2,n
    if (dabs(dx(i)) <= dmax) exit
    res = i
    dmax = dabs(dx(i))
  end do
  end function


  FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
!  STR*( * )    NAME, OPTS
  STR(len=*)    NAME, OPTS
  INTEGER    ISPEC, N1, N2, N3, N4, res
!     ..
!
!  Purpose
!  =======
!
!  ILAENV is called from the LAPACK routines to choose problem-dependent
!  parameters for the local environment.  See ISPEC for a description of
!  the parameters.
!
!  This version provides a set of parameters which should give good,
!  but not optimal, performance on many of the currently available
!  computers.  Users are encouraged to modify this subroutine to set
!  the tuning parameters for their particular machine using the option
!  and problem size information in the arguments.
!
!  This routine will not function correctly if it is converted to all
!  lower case.  Converting it to all upper case is allowed.
!
!  Arguments
!  =========
!
!  ISPEC   (input) INTEGER
!      Specifies the parameter to be returned as the value of
!      ILAENV.
!      = 1: the optimal blocksize; if this value is 1, an unblocked
!       algorithm will give the best performance.
!      = 2: the minimum block size for which the block routine
!       should be used; if the usable block size is less than
!       this value, an unblocked routine should be used.
!      = 3: the crossover point (in a block routine, for N less
!       than this value, an unblocked routine should be used)
!      = 4: the number of shifts, used in the nonsymmetric
!       eigenvalue routines
!      = 5: the minimum column dimension for blocking to be used;
!       rectangular blocks must have dimension at least k by m,
!       where k is given by ILAENV(2,...) and m by ILAENV(5,...)
!      = 6: the crossover point for the SVD (when reducing an m by n
!       matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
!       this value, a QR factorization is used first to reduce
!       the matrix to a triangular form.)
!      = 7: the number of processors
!
!  NAME    (input) STR*(*)
!      The name of the calling subroutine, in either upper case or
!      lower case.
!
!  OPTS    (input) STR*(*)
!      The character options to the subroutine NAME, concatenated
!      into a single character string.  For example, UPLO = 'U',
!      TRANS = 'T', and DIAG = 'N' for a triangular routine would
!      be specified as OPTS = 'UTN'.
!
!  N1  (input) INTEGER
!  N2  (input) INTEGER
!  N3  (input) INTEGER
!  N4  (input) INTEGER
!      Problem dimensions for the subroutine NAME; these may not all
!      be required.
!
! (ILAENV) (output) INTEGER
!      >= 0: the value of the parameter specified by ISPEC
!      < 0:  if ILAENV = -k, the k-th argument had an illegal value.
!
!  Further Details
!  ===============
!
!  The following conventions have been used when calling ILAENV from the
!  LAPACK routines:
!  1)  OPTS is a concatenation of all of the character options to
!  subroutine NAME, in the same order that they appear in the
!  argument list for NAME, even if they are not used in determining
!  the value of the parameter specified by ISPEC.
!  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
!  that they appear in the argument list for NAME.  N1 is used
!  first, N2 second, and so on, and unused problem dimensions are
!  passed a value of -1.
!  3)  The parameter value returned by ILAENV is checked for validity in
!  the calling subroutine.  For example, ILAENV is used to retrieve
!  the optimal blocksize for STRTRI as follows:
!
!  NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
!  IF( NB <= 1 ) NB = MAX( 1, N )
!
!  =====================================================================
!
!     .. Local Scalars ..
  LOGICAL    CNAME, SNAME
  STR(len=1)    C1
  STR(len=2)    C2, C4
  STR(len=3)    C3
  STR(len=6)    SUBNAM
  INTEGER    I, IC, IZ, NB, NBMIN, NX
!     ..
!     .. Executable Statements ..
!
!  GO TO ( 100, 100, 100, 400, 500, 600, 700 ) ISPEC
  select case (ISPEC)
  case (1,2,3)
!  100 CONTINUE
!
!     Convert NAME to upper case if the first character is lower case.
!
  res = 1
  SUBNAM = NAME
  IC = ICHAR( SUBNAM( 1:1 ) )
  IZ = ICHAR( 'Z' )
  IF( IZ == 90  OR  IZ == 122 ) THEN
!
!    ASCII character set
!
     IF( IC.GE.97  AND  IC <= 122 ) THEN
    SUBNAM( 1:1 ) = CHAR( IC-32 )
    DO 10 I = 2, 6
       IC = ICHAR( SUBNAM( I:I ) )
       IF( IC.GE.97  AND  IC <= 122 ) SUBNAM( I:I ) = CHAR( IC-32 )
   10   CONTINUE
     END IF
!
  ELSE IF( IZ == 233  OR  IZ == 169 ) THEN
!
!    EBCDIC character set
!
     IF( ( IC.GE.129  AND  IC <= 137 )  OR  &
     ( IC.GE.145  AND  IC <= 153 )  OR  &
     ( IC.GE.162  AND  IC <= 169 ) ) THEN
    SUBNAM( 1:1 ) = CHAR( IC+64 )
    DO 20 I = 2, 6
       IC = ICHAR( SUBNAM( I:I ) )
       IF( ( IC.GE.129  AND  IC <= 137 )  OR  &
       ( IC.GE.145  AND  IC <= 153 )  OR  &
       ( IC.GE.162  AND  IC <= 169 ) ) &
      SUBNAM( I:I ) = CHAR( IC+64 )
   20   CONTINUE
     END IF
!
  ELSE IF( IZ == 218  OR  IZ == 250 ) THEN
!
!    Prime machines:  ASCII+128
!
     IF( IC.GE.225  AND  IC <= 250 ) THEN
    SUBNAM( 1:1 ) = CHAR( IC-32 )
    DO 30 I = 2, 6
       IC = ICHAR( SUBNAM( I:I ) )
       IF( IC.GE.225  AND  IC <= 250 ) SUBNAM( I:I ) = CHAR( IC-32 )
   30   CONTINUE
     END IF
  END IF
!
  C1 = SUBNAM( 1:1 )
  SNAME = C1 == 'S'  OR  C1 == 'D'
  CNAME = C1 == 'C'  OR  C1 == 'Z'
  IF(  NOT ( CNAME  OR  SNAME ) ) RETURN
  C2 = SUBNAM( 2:3 )
  C3 = SUBNAM( 4:6 )
  C4 = C3( 2:3 )
!
!  GO TO ( 110, 200, 300 ) ISPEC
  select case (ISPEC)
!
!  110 CONTINUE
  case (1)
!
!     ISPEC = 1:  block size
!
!     In these examples, separate code is provided for setting NB for
!     real and complex.  We assume that NB will take the same value in
!     single or REAL.
!
  NB = 1
!
  IF( C2 == 'GE' ) THEN
     IF( C3 == 'TRF' ) THEN
    IF( SNAME ) THEN
       NB = 64
    ELSE
       NB = 64
    END IF
     ELSE IF( C3 == 'QRF'  OR  C3 == 'RQF'  OR  C3 == 'LQF'  OR  &
      C3 == 'QLF' ) THEN
    IF( SNAME ) THEN
       NB = 32
    ELSE
       NB = 32
    END IF
     ELSE IF( C3 == 'HRD' ) THEN
    IF( SNAME ) THEN
       NB = 32
    ELSE
       NB = 32
    END IF
     ELSE IF( C3 == 'BRD' ) THEN
    IF( SNAME ) THEN
       NB = 32
    ELSE
       NB = 32
    END IF
     ELSE IF( C3 == 'TRI' ) THEN
    IF( SNAME ) THEN
       NB = 64
    ELSE
       NB = 64
    END IF
     END IF
  ELSE IF( C2 == 'PO' ) THEN
     IF( C3 == 'TRF' ) THEN
    IF( SNAME ) THEN
       NB = 64
    ELSE
       NB = 64
    END IF
     END IF
  ELSE IF( C2 == 'SY' ) THEN
     IF( C3 == 'TRF' ) THEN
    IF( SNAME ) THEN
       NB = 64
    ELSE
       NB = 64
    END IF
     ELSE IF( SNAME  AND  C3 == 'TRD' ) THEN
    NB = 32
     ELSE IF( SNAME  AND  C3 == 'GST' ) THEN
    NB = 64
     END IF
  ELSE IF( CNAME  AND  C2 == 'HE' ) THEN
     IF( C3 == 'TRF' ) THEN
    NB = 64
     ELSE IF( C3 == 'TRD' ) THEN
    NB = 32
     ELSE IF( C3 == 'GST' ) THEN
    NB = 64
     END IF
  ELSE IF( SNAME  AND  C2 == 'OR' ) THEN
     IF( C3( 1:1 ) == 'G' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NB = 32
    END IF
     ELSE IF( C3( 1:1 ) == 'M' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NB = 32
    END IF
     END IF
  ELSE IF( CNAME  AND  C2 == 'UN' ) THEN
     IF( C3( 1:1 ) == 'G' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NB = 32
    END IF
     ELSE IF( C3( 1:1 ) == 'M' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NB = 32
    END IF
     END IF
  ELSE IF( C2 == 'GB' ) THEN
     IF( C3 == 'TRF' ) THEN
    IF( SNAME ) THEN
       IF( N4 <= 64 ) THEN
      NB = 1
       ELSE
      NB = 32
       END IF
    ELSE
       IF( N4 <= 64 ) THEN
      NB = 1
       ELSE
      NB = 32
       END IF
    END IF
     END IF
  ELSE IF( C2 == 'PB' ) THEN
     IF( C3 == 'TRF' ) THEN
    IF( SNAME ) THEN
       IF( N2 <= 64 ) THEN
      NB = 1
       ELSE
      NB = 32
       END IF
    ELSE
       IF( N2 <= 64 ) THEN
      NB = 1
       ELSE
      NB = 32
       END IF
    END IF
     END IF
  ELSE IF( C2 == 'TR' ) THEN
     IF( C3 == 'TRI' ) THEN
    IF( SNAME ) THEN
       NB = 64
    ELSE
       NB = 64
    END IF
     END IF
  ELSE IF( C2 == 'LA' ) THEN
     IF( C3 == 'UUM' ) THEN
    IF( SNAME ) THEN
       NB = 64
    ELSE
       NB = 64
    END IF
     END IF
  ELSE IF( SNAME  AND  C2 == 'ST' ) THEN
     IF( C3 == 'EBZ' ) THEN
    NB = 1
     END IF
  END IF
  res = NB
  RETURN
!
  case (2)
!  200 CONTINUE
!
!     ISPEC = 2:  minimum block size
!
  NBMIN = 2
  IF( C2 == 'GE' ) THEN
     IF(C3 == 'QRF'  OR  C3 == 'RQF'  OR  C3 == 'LQF'  OR  C3 == 'QLF') THEN
    IF( SNAME ) THEN
       NBMIN = 2
    ELSE
       NBMIN = 2
    END IF
     ELSE IF( C3 == 'HRD' ) THEN
    IF( SNAME ) THEN
       NBMIN = 2
    ELSE
       NBMIN = 2
    END IF
     ELSE IF( C3 == 'BRD' ) THEN
    IF( SNAME ) THEN
       NBMIN = 2
    ELSE
       NBMIN = 2
    END IF
     ELSE IF( C3 == 'TRI' ) THEN
    IF( SNAME ) THEN
       NBMIN = 2
    ELSE
       NBMIN = 2
    END IF
     END IF
  ELSE IF( C2 == 'SY' ) THEN
     IF( C3 == 'TRF' ) THEN
    IF( SNAME ) THEN
       NBMIN = 8
    ELSE
       NBMIN = 8
    END IF
     ELSE IF( SNAME  AND  C3 == 'TRD' ) THEN
    NBMIN = 2
     END IF
  ELSE IF( CNAME  AND  C2 == 'HE' ) THEN
     IF( C3 == 'TRD' ) THEN
    NBMIN = 2
     END IF
  ELSE IF( SNAME  AND  C2 == 'OR' ) THEN
     IF( C3( 1:1 ) == 'G' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NBMIN = 2
    END IF
     ELSE IF( C3( 1:1 ) == 'M' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NBMIN = 2
    END IF
     END IF
  ELSE IF( CNAME  AND  C2 == 'UN' ) THEN
     IF( C3( 1:1 ) == 'G' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NBMIN = 2
    END IF
     ELSE IF( C3( 1:1 ) == 'M' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NBMIN = 2
    END IF
     END IF
  END IF
  res = NBMIN
  RETURN
!
  case (3)
!  300 CONTINUE
!
!     ISPEC = 3:  crossover point
!
  NX = 0
  IF( C2 == 'GE' ) THEN
     IF(C3 == 'QRF'  OR  C3 == 'RQF'  OR  C3 == 'LQF'  OR  C3 == 'QLF') THEN
    IF( SNAME ) THEN
       NX = 128
    ELSE
       NX = 128
    END IF
     ELSE IF( C3 == 'HRD' ) THEN
    IF( SNAME ) THEN
       NX = 128
    ELSE
       NX = 128
    END IF
     ELSE IF( C3 == 'BRD' ) THEN
    IF( SNAME ) THEN
       NX = 128
    ELSE
       NX = 128
    END IF
     END IF
  ELSE IF( C2 == 'SY' ) THEN
     IF( SNAME  AND  C3 == 'TRD' ) THEN
    NX = 32
     END IF
  ELSE IF( CNAME  AND  C2 == 'HE' ) THEN
     IF( C3 == 'TRD' ) THEN
    NX = 32
     END IF
  ELSE IF( SNAME  AND  C2 == 'OR' ) THEN
     IF( C3( 1:1 ) == 'G' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NX = 128
    END IF
     END IF
  ELSE IF( CNAME  AND  C2 == 'UN' ) THEN
     IF( C3( 1:1 ) == 'G' ) THEN
    IF( C4 == 'QR'  OR  C4 == 'RQ'  OR  C4 == 'LQ'  OR  &
        C4 == 'QL'  OR  C4 == 'HR'  OR  C4 == 'TR'  OR  &
        C4 == 'BR' ) THEN
       NX = 128
    END IF
     END IF
  END IF
  res = NX
  RETURN
  end select
!
  case (4)
!  400 CONTINUE
!
!     ISPEC = 4:  number of shifts (used by xHSEQR)
!
  res = 6
  RETURN
!
  case (5)
!  500 CONTINUE
!
!     ISPEC = 5:  minimum column dimension (not used)
!
  res = 2
  RETURN
!
  case (6)
!  600 CONTINUE
!
!     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)
!
  res = int( real( MIN( N1, N2 ) ,kind=kind(ZERO))*1.6E0 )
  RETURN
!
  case (7)
!  700 CONTINUE
!
!     ISPEC = 7:  number of processors (not used)
!
  res = 1
  RETURN
  case default
!
!     Invalid value for ISPEC
!
  res = -1
  RETURN
!
  end select
  END function

  subroutine zaxpy(n,za,zx,incx,zy,incy)
!
!     constant times a vector plus a vector.
!     jack dongarra, 3/11/78.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  CPX zx(*),zy(*),za
  INT i,incx,incy,ix,iy,n
  if (n <= 0) return
  if (abs(za)  ==  ZERO) return
  if (incx == 1 AND incy == 1)go to 20
!
!    code for unequal increments or equal increments
!      not equal to 1
!
  ix = 1
  iy = 1
  if (incx < 0)ix = (-n+1)*incx + 1
  if (incy < 0)iy = (-n+1)*incy + 1
  do 10 i = 1,n
    zy(iy) = zy(iy) + za*zx(ix)
    ix = ix + incx
    iy = iy + incy
   10 continue
  return
!
!    code for both increments equal to 1
!
   20 do 30 i = 1,n
    zy(i) = zy(i) + za*zx(i)
   30 continue
  return
  end
  subroutine  zcopy(n,zx,incx,zy,incy)
!
!     copies a vector, x, to a vector, y.
!     jack dongarra, linpack, 4/11/78.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  CPX zx(*),zy(*)
  INT i,incx,incy,ix,iy,n
!
  if (n <= 0) return
  if (incx == 1 AND incy == 1)go to 20
!
!    code for unequal increments or equal increments
!      not equal to 1
!
  ix = 1
  iy = 1
  if (incx < 0)ix = (-n+1)*incx + 1
  if (incy < 0)iy = (-n+1)*incy + 1
  do 10 i = 1,n
    zy(iy) = zx(ix)
    ix = ix + incx
    iy = iy + incy
   10 continue
  return
!
!    code for both increments equal to 1
!
   20 do 30 i = 1,n
    zy(i) = zx(i)
   30 continue
  return
  end
  function zdotc(n,zx,incx,zy,incy) result (res)
!
!     forms the dot product of a vector.
!     jack dongarra, 3/11/78.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  CPX zx(*),zy(*),ztemp
  INT i,incx,incy,ix,iy,n
  CPX res
  ztemp = (ZERO,ZERO)
  res   = (ZERO,ZERO)
  if (n <= 0) return
  if (incx == 1 AND incy == 1)go to 20
!
!    code for unequal increments or equal increments
!      not equal to 1
!
  ix = 1
  iy = 1
  if (incx < 0)ix = (-n+1)*incx + 1
  if (incy < 0)iy = (-n+1)*incy + 1
  do 10 i = 1,n
    ztemp = ztemp + conjg(zx(ix))*zy(iy)
    ix = ix + incx
    iy = iy + incy
   10 continue
  res = ztemp
  return
!
!    code for both increments equal to 1
!
   20 do 30 i = 1,n
    ztemp = ztemp + conjg(zx(i))*zy(i)
   30 continue
  res = ztemp
  return
  end
  subroutine  zdscal(n,da,zx,incx)
!
!     scales a vector by a constant.
!     jack dongarra, 3/11/78.
!     modified 3/93 to return if incx  <=  0.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  CPX zx(*)
  REAL da
  INT i,incx,ix,n
!
  if ( n <= 0 .or. incx <= 0 ) return
  if (incx == 1)go to 20
!
!    code for increment not equal to 1
!
  ix = 1
  do 10 i = 1,n
    zx(ix) = cmplx(da,ZERO,kind=kind(ZERO))*zx(ix)
    ix = ix + incx
   10 continue
  return
!
!    code for increment equal to 1
!
   20 do 30 i = 1,n
    zx(i) = cmplx(da,ZERO,kind=kind(ZERO))*zx(i)
   30 continue
  return
  end

  SUBROUTINE ZHEEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK, INFO )
!
!  -- LAPACK driver routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  CHR      JOBZ, UPLO
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  REAL   RWORK( * ), W( * )
  CPX     A( LDA, * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZHEEV computes all eigenvalues and, optionally, eigenvectors of a
!  complex Hermitian matrix A.
!
!  Arguments
!  =========
!
!  JOBZ    (input) STR(len=1)
!      = 'N':  Compute eigenvalues only;
!      = 'V':  Compute eigenvalues and eigenvectors.
!
!  UPLO    (input) STR(len=1)
!      = 'U':  Upper triangle of A is stored;
!      = 'L':  Lower triangle of A is stored.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) CPX array, dimension (LDA, N)
!      On entry, the Hermitian matrix A.  If UPLO = 'U', the
!      leading N-by-N upper triangular part of A contains the
!      upper triangular part of the matrix A.  If UPLO = 'L',
!      the leading N-by-N lower triangular part of A contains
!      the lower triangular part of the matrix A.
!      On exit, if JOBZ = 'V', then if INFO = 0, A contains the
!      orthonormal eigenvectors of the matrix A.
!      If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
!      or the upper triangle (if UPLO='U') of A, including the
!      diagonal, is destroyed.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  W   (output) REAL array, dimension (N)
!      If INFO = 0, the eigenvalues in ascending order.
!
!  WORK    (workspace/output) CPX array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The length of the array WORK.  LWORK >= max(1,2*N-1).
!      For optimal efficiency, LWORK >= (NB+1)*N,
!      where NB is the blocksize for ZHETRD returned by ILAENV.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  if INFO = i, the algorithm failed to converge; i
!        off-diagonal elements of an intermediate tridiagonal
!        form did not converge to zero.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LOWER, LQUERY, WANTZ
  INTEGER    IINFO, IMAX, INDE, INDTAU, INDWRK, ISCALE, &
         LLWORK, LOPT, LWKOPT, NB
  REAL   ANRM, BIGNUM, EPS, RMAX, RMIN, SAFMIN, SIGMA, SMLNUM
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  REAL   ZLANHE
  EXTERNAL       ILAENV, ZLANHE
!     ..
!     .. External Subroutines ..
  EXTERNAL       DSCAL, DSTERF, XERBLA, ZHETRD, ZLASCL, ZSTEQR, ZUNGTR
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  WANTZ =  scan( JOBZ, 'Vv' )>0
  LOWER =  scan( UPLO, 'Ll' )>0
  LQUERY = ( LWORK == -1 )
!
  INFO = 0
  IF(  NOT ( WANTZ  OR   scan( JOBZ, 'Nn' )>0 ) ) THEN
     INFO = -1
  ELSE IF(  NOT ( LOWER  OR   scan( UPLO, 'Uu' )>0 ) ) THEN
     INFO = -2
  ELSE IF( N < 0 ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -5
  ELSE IF( LWORK < MAX( 1, 2*N-1 )  AND   NOT LQUERY ) THEN
     INFO = -8
  END IF
!
  IF( INFO == 0 ) THEN
     NB = ILAENV( 1, 'ZHETRD', UPLO, N, -1, -1, -1 )
     LWKOPT = MAX( 1, ( NB+1 )*N )
     WORK( 1 ) = LWKOPT
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZHEEV ', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  IF( N == 1 ) THEN
     W( 1 ) = A( 1, 1 )
     WORK( 1 ) = 3
     IF( WANTZ ) A( 1, 1 ) = ONE
     RETURN
  END IF
!
!     Get machine constants.
!
  SAFMIN = tiny(ZERO)
  EPS = epsilon(ZERO)
  SMLNUM = SAFMIN / EPS
  BIGNUM = ONE / SMLNUM
  RMIN = SQRT( SMLNUM )
  RMAX = SQRT( BIGNUM )
!
!     Scale matrix to allowable range, if necessary.
!
  ANRM = ZLANHE( 'M', UPLO, N, A, LDA, RWORK )
  ISCALE = 0
  IF( ANRM > ZERO  AND  ANRM < RMIN ) THEN
     ISCALE = 1
     SIGMA = RMIN / ANRM
  ELSE IF( ANRM > RMAX ) THEN
     ISCALE = 1
     SIGMA = RMAX / ANRM
  END IF
  IF( ISCALE == 1 ) CALL ZLASCL( UPLO, 0, 0, ONE, SIGMA, N, N, A, LDA, INFO)
!
!     Call ZHETRD to reduce Hermitian matrix to tridiagonal form.
!
  INDE = 1
  INDTAU = 1
  INDWRK = INDTAU + N
  LLWORK = LWORK - INDWRK + 1
  CALL ZHETRD( UPLO, N, A, LDA, W, RWORK( INDE ), WORK( INDTAU ), &
       WORK( INDWRK ), LLWORK, IINFO )
  LOPT = N + WORK( INDWRK )
!
!     For eigenvalues only, call DSTERF.  For eigenvectors, first call
!     ZUNGTR to generate the unitary matrix, then call ZSTEQR.
!
  IF(  NOT WANTZ ) THEN
     CALL DSTERF( N, W, RWORK( INDE ), INFO )
  ELSE
     CALL ZUNGTR( UPLO, N, A, LDA, WORK( INDTAU ), WORK( INDWRK ), &
          LLWORK, IINFO )
     INDWRK = INDE + N
     CALL ZSTEQR( JOBZ, N, W, RWORK( INDE ), A, LDA, &
          RWORK( INDWRK ), INFO )
  END IF
!
!     If matrix was scaled, then rescale eigenvalues appropriately.
!
  IF( ISCALE == 1 ) THEN
     IF( INFO == 0 ) THEN
    IMAX = N
     ELSE
    IMAX = INFO - 1
     END IF
     CALL DSCAL( IMAX, ONE / SIGMA, W, 1 )
  END IF
!
!     Set WORK(1) to optimal complex workspace size.
!
  WORK( 1 ) = LWKOPT
!
  RETURN
!
!     End of ZHEEV
!
  END

  SUBROUTINE ZHETD2( UPLO, N, A, LDA, D, E, TAU, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1999
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDA, N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * )
  CPX     A( LDA, * ), TAU( * )
!     ..
!
!  Purpose
!  =======
!
!  ZHETD2 reduces a complex Hermitian matrix A to real symmetric
!  tridiagonal form T by a unitary similarity transformation:
!  Q' * A * Q = T.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      Specifies whether the upper or lower triangular part of the
!      Hermitian matrix A is stored:
!      = 'U':  Upper triangular
!      = 'L':  Lower triangular
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
!      n-by-n upper triangular part of A contains the upper
!      triangular part of the matrix A, and the strictly lower
!      triangular part of A is not referenced.  If UPLO = 'L', the
!      leading n-by-n lower triangular part of A contains the lower
!      triangular part of the matrix A, and the strictly upper
!      triangular part of A is not referenced.
!      On exit, if UPLO = 'U', the diagonal and first superdiagonal
!      of A are overwritten by the corresponding elements of the
!      tridiagonal matrix T, and the elements above the first
!      superdiagonal, with the array TAU, represent the unitary
!      matrix Q as a product of elementary reflectors; if UPLO
!      = 'L', the diagonal and first subdiagonal of A are over-
!      written by the corresponding elements of the tridiagonal
!      matrix T, and the elements below the first subdiagonal, with
!      the array TAU, represent the unitary matrix Q as a product
!      of elementary reflectors. See Further Details.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  D   (output) REAL array, dimension (N)
!      The diagonal elements of the tridiagonal matrix T:
!      D(i) = A(i,i).
!
!  E   (output) REAL array, dimension (N-1)
!      The off-diagonal elements of the tridiagonal matrix T:
!      E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
!
!  TAU     (output) CPX array, dimension (N-1)
!      The scalar factors of the elementary reflectors (see Further
!      Details).
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n-1) . . . H(2) H(1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!  A(1:i-1,i+1), and tau in TAU(i).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(n-1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!  and tau in TAU(i).
!
!  The contents of A on exit are illustrated by the following examples
!  with n = 5:
!
!  if UPLO = 'U':           if UPLO = 'L':
!
!    (  d   e   v2  v3  v4 )      (  d      )
!    (  d   e   v3  v4 )      (  e   d      )
!    (      d   e   v4 )      (  v1  e   d      )
!    (      d   e  )      (  v1  v2  e   d  )
!    (      d  )      (  v1  v2  v3  e   d  )
!
!  where d and e denote diagonal and off-diagonal elements of T, and vi
!  denotes an element of the vector defining H(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    UPPER
  INTEGER    I
  CPX     ALPHA, TAUI
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZAXPY, ZHEMV, ZHER2, ZLARFG
!     ..
!     .. External Functions ..
  CPX     ZDOTC
  EXTERNAL       ZDOTC
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  UPPER =  scan( UPLO, 'Uu' )>0
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZHETD2', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
  IF( UPPER ) THEN
!
!    Reduce the upper triangle of A
!
     A( N, N ) = DBLE( A( N, N ) )
     DO 10 I = N - 1, 1, -1
!
!       Generate elementary reflector H(i) = I - tau * v * v'
!       to annihilate A(1:i-1,i+1)
!
    ALPHA = A( I, I+1 )
    CALL ZLARFG( I, ALPHA, A( 1, I+1 ), 1, TAUI )
    E( I ) = ALPHA
!
    IF( TAUI/=ZERO ) THEN
!
!      Apply H(i) from both sides to A(1:i,1:i)
!
       A( I, I+1 ) = ONE
!
!      Compute  x := tau * A * v  storing x in TAU(1:i)
!
       CALL ZHEMV( UPLO, I, TAUI, A, LDA, A( 1, I+1 ), 1, ZERO, TAU, 1 )
!
!      Compute  w := x - 1/2 * tau * (x'*v) * v
!
       ALPHA = -HALF*TAUI*ZDOTC( I, TAU, 1, A( 1, I+1 ), 1 )
       CALL ZAXPY( I, ALPHA, A( 1, I+1 ), 1, TAU, 1 )
!
!      Apply the transformation as a rank-2 update:
!         A := A - v * w' - w * v'
!
       CALL ZHER2( UPLO, I, -ONE, A( 1, I+1 ), 1, TAU, 1, A, LDA )
!
    ELSE
       A( I, I ) = DBLE( A( I, I ) )
    END IF
    A( I, I+1 ) = E( I )
    D( I+1 ) = A( I+1, I+1 )
    TAU( I ) = TAUI
   10    CONTINUE
     D( 1 ) = A( 1, 1 )
  ELSE
!
!    Reduce the lower triangle of A
!
     A( 1, 1 ) = DBLE( A( 1, 1 ) )
     DO 20 I = 1, N - 1
!
!       Generate elementary reflector H(i) = I - tau * v * v'
!       to annihilate A(i+2:n,i)
!
    ALPHA = A( I+1, I )
    CALL ZLARFG( N-I, ALPHA, A( MIN( I+2, N ), I ), 1, TAUI )
    E( I ) = ALPHA
!
    IF( TAUI/=ZERO ) THEN
!
!      Apply H(i) from both sides to A(i+1:n,i+1:n)
!
       A( I+1, I ) = ONE
!
!      Compute  x := tau * A * v  storing y in TAU(i:n-1)
!
       CALL ZHEMV( UPLO, N-I, TAUI, A( I+1, I+1 ), LDA, &
           A( I+1, I ), 1, ZERO, TAU( I ), 1 )
!
!      Compute  w := x - 1/2 * tau * (x'*v) * v
!
       ALPHA = -HALF*TAUI*ZDOTC( N-I, TAU( I ), 1, A( I+1, I ), 1 )
       CALL ZAXPY( N-I, ALPHA, A( I+1, I ), 1, TAU( I ), 1 )
!
!      Apply the transformation as a rank-2 update:
!         A := A - v * w' - w * v'
!
       CALL ZHER2( UPLO, N-I, -ONE, A( I+1, I ), 1, TAU( I ), 1, &
           A( I+1, I+1 ), LDA )
!
    ELSE
       A( I+1, I+1 ) = DBLE( A( I+1, I+1 ) )
    END IF
    A( I+1, I ) = E( I )
    D( I ) = A( I, I )
    TAU( I ) = TAUI
   20    CONTINUE
     D( N ) = A( N, N )
  END IF
!
  RETURN
!
!     End of ZHETD2
!
  END

  SUBROUTINE ZHETRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * )
  CPX     A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZHETRD reduces a complex Hermitian matrix A to real symmetric
!  tridiagonal form T by a unitary similarity transformation:
!  Q**H * A * Q = T.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      = 'U':  Upper triangle of A is stored;
!      = 'L':  Lower triangle of A is stored.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
!      N-by-N upper triangular part of A contains the upper
!      triangular part of the matrix A, and the strictly lower
!      triangular part of A is not referenced.  If UPLO = 'L', the
!      leading N-by-N lower triangular part of A contains the lower
!      triangular part of the matrix A, and the strictly upper
!      triangular part of A is not referenced.
!      On exit, if UPLO = 'U', the diagonal and first superdiagonal
!      of A are overwritten by the corresponding elements of the
!      tridiagonal matrix T, and the elements above the first
!      superdiagonal, with the array TAU, represent the unitary
!      matrix Q as a product of elementary reflectors; if UPLO
!      = 'L', the diagonal and first subdiagonal of A are over-
!      written by the corresponding elements of the tridiagonal
!      matrix T, and the elements below the first subdiagonal, with
!      the array TAU, represent the unitary matrix Q as a product
!      of elementary reflectors. See Further Details.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  D   (output) REAL array, dimension (N)
!      The diagonal elements of the tridiagonal matrix T:
!      D(i) = A(i,i).
!
!  E   (output) REAL array, dimension (N-1)
!      The off-diagonal elements of the tridiagonal matrix T:
!      E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
!
!  TAU     (output) CPX array, dimension (N-1)
!      The scalar factors of the elementary reflectors (see Further
!      Details).
!
!  WORK    (workspace/output) CPX array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK.  LWORK >= 1.
!      For optimum performance LWORK >= N*NB, where NB is the
!      optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n-1) . . . H(2) H(1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
!  A(1:i-1,i+1), and tau in TAU(i).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(n-1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
!  and tau in TAU(i).
!
!  The contents of A on exit are illustrated by the following examples
!  with n = 5:
!
!  if UPLO = 'U':           if UPLO = 'L':
!
!    (  d   e   v2  v3  v4 )      (  d      )
!    (  d   e   v3  v4 )      (  e   d      )
!    (      d   e   v4 )      (  v1  e   d      )
!    (      d   e  )      (  v1  v2  e   d  )
!    (      d  )      (  v1  v2  v3  e   d  )
!
!  where d and e denote diagonal and off-diagonal elements of T, and vi
!  denotes an element of the vector defining H(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY, UPPER
  INTEGER    I, IINFO, IWS, J, KK, LDWORK, LWKOPT, NB, NBMIN, NX
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZHER2K, ZHETD2, ZLATRD
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  UPPER =  scan( UPLO, 'Uu' )>0
  LQUERY = ( LWORK == -1 )
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  ELSE IF( LWORK < 1  AND   NOT LQUERY ) THEN
     INFO = -9
  END IF
!
  IF( INFO == 0 ) THEN
!
!    Determine the block size.
!
     NB = ILAENV( 1, 'ZHETRD', UPLO, N, -1, -1, -1 )
     LWKOPT = N*NB
     WORK( 1 ) = LWKOPT
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZHETRD', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  NX = N
  IWS = 1
  IF( NB > 1  AND  NB < N ) THEN
!
!    Determine when to cross over from blocked to unblocked code
!    (last block is always handled by unblocked code).
!
     NX = MAX( NB, ILAENV( 3, 'ZHETRD', UPLO, N, -1, -1, -1 ) )
     IF( NX < N ) THEN
!
!       Determine if workspace is large enough for blocked code.
!
    LDWORK = N
    IWS = LDWORK*NB
    IF( LWORK < IWS ) THEN
!
!      Not enough workspace to use optimal NB:  determine the
!      minimum value of NB, and reduce NB or force use of
!      unblocked code by setting NX = N.
!
       NB = MAX( LWORK / LDWORK, 1 )
       NBMIN = ILAENV( 2, 'ZHETRD', UPLO, N, -1, -1, -1 )
       IF( NB < NBMIN ) NX = N
    END IF
     ELSE
    NX = N
     END IF
  ELSE
     NB = 1
  END IF
!
  IF( UPPER ) THEN
!
!    Reduce the upper triangle of A.
!    Columns 1:kk are handled by the unblocked method.
!
     KK = N - ( ( N-NX+NB-1 ) / NB )*NB
     DO 20 I = N - NB + 1, KK + 1, -NB
!
!       Reduce columns i:i+nb-1 to tridiagonal form and form the
!       matrix W which is needed to update the unreduced part of
!       the matrix
!
    CALL ZLATRD( UPLO, I+NB-1, NB, A, LDA, E, TAU, WORK, LDWORK )
!
!       Update the unreduced submatrix A(1:i-1,1:i-1), using an
!       update of the form:  A := A - V*W' - W*V'
!
    CALL ZHER2K( UPLO, 'No transpose', I-1, NB, -ONE, &
         A( 1, I ), LDA, WORK, LDWORK, ONE, A, LDA )
!
!       Copy superdiagonal elements back into A, and diagonal
!       elements into D
!
    DO 10 J = I, I + NB - 1
       A( J-1, J ) = E( J-1 )
       D( J ) = A( J, J )
   10   CONTINUE
   20    CONTINUE
!
!    Use unblocked code to reduce the last or only block
!
     CALL ZHETD2( UPLO, KK, A, LDA, D, E, TAU, IINFO )
  ELSE
!
!    Reduce the lower triangle of A
!
     DO 40 I = 1, N - NX, NB
!
!       Reduce columns i:i+nb-1 to tridiagonal form and form the
!       matrix W which is needed to update the unreduced part of
!       the matrix
!
    CALL ZLATRD( UPLO, N-I+1, NB, A( I, I ), LDA, E( I ), &
         TAU( I ), WORK, LDWORK )
!
!       Update the unreduced submatrix A(i+nb:n,i+nb:n), using
!       an update of the form:  A := A - V*W' - W*V'
!
    CALL ZHER2K( UPLO, 'No transpose', N-I-NB+1, NB, -ONE, &
         A( I+NB, I ), LDA, WORK( NB+1 ), LDWORK, ONE, &
         A( I+NB, I+NB ), LDA )
!
!       Copy subdiagonal elements back into A, and diagonal
!       elements into D
!
    DO 30 J = I, I + NB - 1
       A( J+1, J ) = E( J )
       D( J ) = A( J, J )
   30   CONTINUE
   40    CONTINUE
!
!    Use unblocked code to reduce the last or only block
!
     CALL ZHETD2(UPLO, N-I+1, A(I,I), LDA, D(I), E(I), TAU(I), IINFO)
  END IF
!
  WORK( 1 ) = LWKOPT
  RETURN
!
!     End of ZHETRD
!
  END

  SUBROUTINE ZHPEV( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, RWORK, INFO )
!
!  -- LAPACK driver routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     March 31, 1993
!
!     .. Scalar Arguments ..
  CHR      JOBZ, UPLO
  INTEGER    INFO, LDZ, N
!     ..
!     .. Array Arguments ..
  REAL   RWORK( * ), W( * )
  CPX     AP( * ), WORK( * ), Z( LDZ, * )
!     ..
!
!  Purpose
!  =======
!
!  ZHPEV computes all the eigenvalues and, optionally, eigenvectors of a
!  complex Hermitian matrix in packed storage.
!
!  Arguments
!  =========
!
!  JOBZ    (input) STR(len=1)
!      = 'N':  Compute eigenvalues only;
!      = 'V':  Compute eigenvalues and eigenvectors.
!
!  UPLO    (input) STR(len=1)
!      = 'U':  Upper triangle of A is stored;
!      = 'L':  Lower triangle of A is stored.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  AP  (input/output) CPX array, dimension (N*(N+1)/2)
!      On entry, the upper or lower triangle of the Hermitian matrix
!      A, packed columnwise in a linear array.  The j-th column of A
!      is stored in the array AP as follows:
!      if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
!      if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
!
!      On exit, AP is overwritten by values generated during the
!      reduction to tridiagonal form.  If UPLO = 'U', the diagonal
!      and first superdiagonal of the tridiagonal matrix T overwrite
!      the corresponding elements of A, and if UPLO = 'L', the
!      diagonal and first subdiagonal of T overwrite the
!      corresponding elements of A.
!
!  W   (output) REAL array, dimension (N)
!      If INFO = 0, the eigenvalues in ascending order.
!
!  Z   (output) CPX array, dimension (LDZ, N)
!      If JOBZ = 'V', then if INFO = 0, Z contains the orthonormal
!      eigenvectors of the matrix A, with the i-th column of Z
!      holding the eigenvector associated with W(i).
!      If JOBZ = 'N', then Z is not referenced.
!
!  LDZ     (input) INTEGER
!      The leading dimension of the array Z.  LDZ >= 1, and if
!      JOBZ = 'V', LDZ >= max(1,N).
!
!  WORK    (workspace) CPX array, dimension (max(1, 2*N-1))
!
!  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))
!
!  INFO    (output) INTEGER
!      = 0:  successful exit.
!      < 0:  if INFO = -i, the i-th argument had an illegal value.
!      > 0:  if INFO = i, the algorithm failed to converge; i
!        off-diagonal elements of an intermediate tridiagonal
!        form did not converge to zero.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    WANTZ
  INTEGER    IINFO, IMAX, INDE, INDRWK, INDTAU, INDWRK, ISCALE
  REAL   ANRM, BIGNUM, EPS, RMAX, RMIN, SAFMIN, SIGMA, SMLNUM
!     ..
!     .. External Functions ..
  REAL   ZLANHP
  EXTERNAL       ZLANHP
!     ..
!     .. External Subroutines ..
  EXTERNAL       DSCAL, DSTERF, XERBLA, ZDSCAL, ZHPTRD, ZSTEQR, ZUPGTR
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  WANTZ =  scan( JOBZ, 'Vv' )>0
!
  INFO = 0
  IF(  NOT ( WANTZ  OR   scan( JOBZ, 'Nn' )>0 ) ) THEN
     INFO = -1
  ELSE IF(  NOT  scan( UPLO, 'LlUu' )>0  ) THEN
     INFO = -2
  ELSE IF( N < 0 ) THEN
     INFO = -3
  ELSE IF( LDZ < 1  OR  ( WANTZ  AND  LDZ < N ) ) THEN
     INFO = -7
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZHPEV ', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
  IF( N == 1 ) THEN
     W( 1 ) = AP( 1 )
     RWORK( 1 ) = 1
     IF( WANTZ ) Z( 1, 1 ) = ONE
     RETURN
  END IF
!
!     Get machine constants.
!
  SAFMIN = tiny(ZERO)
  EPS = epsilon(ZERO)
  SMLNUM = SAFMIN / EPS
  BIGNUM = ONE / SMLNUM
  RMIN = SQRT( SMLNUM )
  RMAX = SQRT( BIGNUM )
!
!     Scale matrix to allowable range, if necessary.
!
  ANRM = ZLANHP( 'M', UPLO, N, AP, RWORK )
  ISCALE = 0
  IF( ANRM > ZERO  AND  ANRM < RMIN ) THEN
     ISCALE = 1
     SIGMA = RMIN / ANRM
  ELSE IF( ANRM > RMAX ) THEN
     ISCALE = 1
     SIGMA = RMAX / ANRM
  END IF
  IF( ISCALE == 1 ) THEN
     CALL ZDSCAL( ( N*( N+1 ) ) / 2, SIGMA, AP, 1 )
  END IF
!
!     Call ZHPTRD to reduce Hermitian packed matrix to tridiagonal form.
!
  INDE = 1
  INDTAU = 1
  CALL ZHPTRD( UPLO, N, AP, W, RWORK( INDE ), WORK( INDTAU ), IINFO )
!
!     For eigenvalues only, call DSTERF.  For eigenvectors, first call
!     ZUPGTR to generate the orthogonal matrix, then call ZSTEQR.
!
  IF(  NOT WANTZ ) THEN
     CALL DSTERF( N, W, RWORK( INDE ), INFO )
  ELSE
     INDWRK = INDTAU + N
     CALL ZUPGTR( UPLO, N, AP, WORK(INDTAU), Z, LDZ, WORK(INDWRK), IINFO)
     INDRWK = INDE + N
     CALL ZSTEQR( JOBZ, N, W, RWORK( INDE ), Z, LDZ, RWORK(INDRWK), INFO)
  END IF
!
!     If matrix was scaled, then rescale eigenvalues appropriately.
!
  IF( ISCALE == 1 ) THEN
     IF( INFO == 0 ) THEN
    IMAX = N
     ELSE
    IMAX = INFO - 1
     END IF
     CALL DSCAL( IMAX, ONE / SIGMA, W, 1 )
  END IF
!
  RETURN
!
!     End of ZHPEV
!
  END

  SUBROUTINE ZHPTRD( UPLO, N, AP, D, E, TAU, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * )
  CPX     AP( * ), TAU( * )
!     ..
!
!  Purpose
!  =======
!
!  ZHPTRD reduces a complex Hermitian matrix A stored in packed form to
!  real symmetric tridiagonal form T by a unitary similarity
!  transformation: Q**H * A * Q = T.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      = 'U':  Upper triangle of A is stored;
!      = 'L':  Lower triangle of A is stored.
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.
!
!  AP  (input/output) CPX array, dimension (N*(N+1)/2)
!      On entry, the upper or lower triangle of the Hermitian matrix
!      A, packed columnwise in a linear array.  The j-th column of A
!      is stored in the array AP as follows:
!      if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
!      if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.
!      On exit, if UPLO = 'U', the diagonal and first superdiagonal
!      of A are overwritten by the corresponding elements of the
!      tridiagonal matrix T, and the elements above the first
!      superdiagonal, with the array TAU, represent the unitary
!      matrix Q as a product of elementary reflectors; if UPLO
!      = 'L', the diagonal and first subdiagonal of A are over-
!      written by the corresponding elements of the tridiagonal
!      matrix T, and the elements below the first subdiagonal, with
!      the array TAU, represent the unitary matrix Q as a product
!      of elementary reflectors. See Further Details.
!
!  D   (output) REAL array, dimension (N)
!      The diagonal elements of the tridiagonal matrix T:
!      D(i) = A(i,i).
!
!  E   (output) REAL array, dimension (N-1)
!      The off-diagonal elements of the tridiagonal matrix T:
!      E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
!
!  TAU     (output) CPX array, dimension (N-1)
!      The scalar factors of the elementary reflectors (see Further
!      Details).
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n-1) . . . H(2) H(1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP,
!  overwriting A(1:i-1,i+1), and tau is stored in TAU(i).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(n-1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP,
!  overwriting A(i+2:n,i), and tau is stored in TAU(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    UPPER
  INTEGER    I, I1, I1I1, II
  CPX     ALPHA, TAUI
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZAXPY, ZHPMV, ZHPR2, ZLARFG
!     ..
!     .. External Functions ..
  CPX     ZDOTC
  EXTERNAL       ZDOTC
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  UPPER =  scan( UPLO, 'Uu' )>0
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZHPTRD', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
  IF( UPPER ) THEN
!
!    Reduce the upper triangle of A.
!    I1 is the index in AP of A(1,I+1).
!
     I1 = N*( N-1 ) / 2 + 1
     AP( I1+N-1 ) = DBLE( AP( I1+N-1 ) )
     DO 10 I = N - 1, 1, -1
!
!       Generate elementary reflector H(i) = I - tau * v * v'
!       to annihilate A(1:i-1,i+1)
!
    ALPHA = AP( I1+I-1 )
    CALL ZLARFG( I, ALPHA, AP( I1 ), 1, TAUI )
    E( I ) = ALPHA
!
    IF( TAUI/=ZERO ) THEN
!
!      Apply H(i) from both sides to A(1:i,1:i)
!
       AP( I1+I-1 ) = ONE
!
!      Compute  y := tau * A * v  storing y in TAU(1:i)
!
       CALL ZHPMV( UPLO, I, TAUI, AP, AP( I1 ), 1, ZERO, TAU, 1 )
!
!      Compute  w := y - 1/2 * tau * (y'*v) * v
!
       ALPHA = -HALF*TAUI*ZDOTC( I, TAU, 1, AP( I1 ), 1 )
       CALL ZAXPY( I, ALPHA, AP( I1 ), 1, TAU, 1 )
!
!      Apply the transformation as a rank-2 update:
!         A := A - v * w' - w * v'
!
       CALL ZHPR2( UPLO, I, -ONE, AP( I1 ), 1, TAU, 1, AP )
!
    END IF
    AP( I1+I-1 ) = E( I )
    D( I+1 ) = AP( I1+I )
    TAU( I ) = TAUI
    I1 = I1 - I
   10    CONTINUE
     D( 1 ) = AP( 1 )
  ELSE
!
!    Reduce the lower triangle of A. II is the index in AP of
!    A(i,i) and I1I1 is the index of A(i+1,i+1).
!
     II = 1
     AP( 1 ) = DBLE( AP( 1 ) )
     DO 20 I = 1, N - 1
    I1I1 = II + N - I + 1
!
!       Generate elementary reflector H(i) = I - tau * v * v'
!       to annihilate A(i+2:n,i)
!
    ALPHA = AP( II+1 )
    CALL ZLARFG( N-I, ALPHA, AP( II+2 ), 1, TAUI )
    E( I ) = ALPHA
!
    IF( TAUI/=ZERO ) THEN
!
!      Apply H(i) from both sides to A(i+1:n,i+1:n)
!
       AP( II+1 ) = ONE
!
!      Compute  y := tau * A * v  storing y in TAU(i:n-1)
!
       CALL ZHPMV( UPLO, N-I, TAUI, AP( I1I1 ), AP( II+1 ), 1, &
           ZERO, TAU( I ), 1 )
!
!      Compute  w := y - 1/2 * tau * (y'*v) * v
!
       ALPHA = -HALF*TAUI*ZDOTC( N-I, TAU( I ), 1, AP( II+1 ), 1 )
       CALL ZAXPY( N-I, ALPHA, AP( II+1 ), 1, TAU( I ), 1 )
!
!      Apply the transformation as a rank-2 update:
!         A := A - v * w' - w * v'
!
       CALL ZHPR2( UPLO, N-I, -ONE, AP(II+1), 1, TAU(I), 1, AP( I1I1 ))
!
    END IF
    AP( II+1 ) = E( I )
    D( I ) = AP( II )
    TAU( I ) = TAUI
    II = I1I1
   20    CONTINUE
     D( N ) = AP( II )
  END IF
!
  RETURN
!
!     End of ZHPTRD
!
  END

  SUBROUTINE ZLACGV( N, X, INCX )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  INTEGER    INCX, N
!     ..
!     .. Array Arguments ..
  CPX     X( * )
!     ..
!
!  Purpose
!  =======
!
!  ZLACGV conjugates a complex vector of length N.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The length of the vector X.  N >= 0.
!
!  X   (input/output) CPX array, dimension
!         (1+(N-1)*abs(INCX))
!      On entry, the vector of length N to be conjugated.
!      On exit, X is overwritten with conjg(X).
!
!  INCX    (input) INTEGER
!      The spacing between successive elements of X.
!
! =====================================================================
!
!     .. Local Scalars ..
  INTEGER    I, IOFF
!     ..
!     .. Executable Statements ..
!
  IF( INCX == 1 ) THEN
     DO 10 I = 1, N
    X( I ) = conjg( X( I ) )
   10    CONTINUE
  ELSE
     IOFF = 1
     IF( INCX < 0 ) IOFF = 1 - ( N-1 )*INCX
     DO 20 I = 1, N
    X( IOFF ) = conjg( X( IOFF ) )
    IOFF = IOFF + INCX
   20    CONTINUE
  END IF
  RETURN
!
!     End of ZLACGV
!
  END

   FUNCTION ZLADIV( X, Y ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CPX     X, Y, res
!     ..
!
!  Purpose
!  =======
!
!  ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y
!  will not overflow on an intermediary step unless the results
!  overflows.
!
!  Arguments
!  =========
!
!  X   (input) CPX
!  Y   (input) CPX
!      The complex scalars X and Y.
!
!  =====================================================================
!
!     .. Local Scalars ..
  REAL   ZI, ZR
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLADIV
!     ..
!     .. Executable Statements ..
!
  CALL DLADIV( DBLE( X ), AIMAG( X ), DBLE( Y ), AIMAG( Y ), ZR, ZI )
  res = CMPLX( ZR, ZI , kind=kind(ZI))
  END function

  FUNCTION ZLANHE( NORM, UPLO, N, A, LDA, WORK ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      NORM, UPLO
  INTEGER    LDA, N
!     ..
!     .. Array Arguments ..
  REAL   WORK( * ), res
  CPX     A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  ZLANHE  returns the value of the one norm,  or the Frobenius norm, or
!  the  infinity norm,  or the  element of  largest absolute value  of a
!  complex hermitian matrix A.
!
!  Description
!  ===========
!
!  ZLANHE returns the value
!
!     ZLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
!      (
!      ( norm1(A),     NORM = '1', 'O' or 'o'
!      (
!      ( normI(A),     NORM = 'I' or 'i'
!      (
!      ( normF(A),     NORM = 'F', 'f', 'E' or 'e'
!
!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!  Arguments
!  =========
!
!  NORM    (input) STR(len=1)
!      Specifies the value to be returned in ZLANHE as described
!      above.
!
!  UPLO    (input) STR(len=1)
!      Specifies whether the upper or lower triangular part of the
!      hermitian matrix A is to be referenced.
!      = 'U':  Upper triangular part of A is referenced
!      = 'L':  Lower triangular part of A is referenced
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.  When N = 0, ZLANHE is
!      set to zero.
!
!  A   (input) CPX array, dimension (LDA,N)
!      The hermitian matrix A.  If UPLO = 'U', the leading n by n
!      upper triangular part of A contains the upper triangular part
!      of the matrix A, and the strictly lower triangular part of A
!      is not referenced.  If UPLO = 'L', the leading n by n lower
!      triangular part of A contains the lower triangular part of
!      the matrix A, and the strictly upper triangular part of A is
!      not referenced. Note that the imaginary parts of the diagonal
!      elements need not be set and are assumed to be zero.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(N,1).
!
!  WORK    (workspace) REAL array, dimension (LWORK),
!      where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
!      WORK is not referenced.
!
! =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J
  REAL   ABSA, SCALE, SUM, VALUE
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZLASSQ
!     ..
!     .. Executable Statements ..
!
  IF( N == 0 ) THEN
     VALUE = ZERO
  ELSE IF(  scan( NORM, 'Mm' )>0 ) THEN
!
!    Find max(abs(A(i,j))).
!
     VALUE = ZERO
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 20 J = 1, N
       DO 10 I = 1, J - 1
      VALUE = MAX( VALUE, ABS( A( I, J ) ) )
   10      CONTINUE
       VALUE = MAX( VALUE, ABS( DBLE( A( J, J ) ) ) )
   20   CONTINUE
     ELSE
    DO 40 J = 1, N
       VALUE = MAX( VALUE, ABS( DBLE( A( J, J ) ) ) )
       DO 30 I = J + 1, N
      VALUE = MAX( VALUE, ABS( A( I, J ) ) )
   30      CONTINUE
   40   CONTINUE
     END IF
  ELSE IF( scan( NORM, 'IiOo1' )>0 ) THEN
!
!    Find normI(A) ( = norm1(A), since A is hermitian).
!
     VALUE = ZERO
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 60 J = 1, N
       SUM = ZERO
       DO 50 I = 1, J - 1
      ABSA = ABS( A( I, J ) )
      SUM = SUM + ABSA
      WORK( I ) = WORK( I ) + ABSA
   50      CONTINUE
       WORK( J ) = SUM + ABS( DBLE( A( J, J ) ) )
   60   CONTINUE
    DO 70 I = 1, N
       VALUE = MAX( VALUE, WORK( I ) )
   70   CONTINUE
     ELSE
    DO 80 I = 1, N
       WORK( I ) = ZERO
   80   CONTINUE
    DO 100 J = 1, N
       SUM = WORK( J ) + ABS( DBLE( A( J, J ) ) )
       DO 90 I = J + 1, N
      ABSA = ABS( A( I, J ) )
      SUM = SUM + ABSA
      WORK( I ) = WORK( I ) + ABSA
   90      CONTINUE
       VALUE = MAX( VALUE, SUM )
  100   CONTINUE
     END IF
  ELSE IF( scan( NORM, 'FfEe' )>0 ) THEN
!
!    Find normF(A).
!
     SCALE = ZERO
     SUM = ONE
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 110 J = 2, N
       CALL ZLASSQ( J-1, A( 1, J ), 1, SCALE, SUM )
  110   CONTINUE
     ELSE
    DO 120 J = 1, N - 1
       CALL ZLASSQ( N-J, A( J+1, J ), 1, SCALE, SUM )
  120   CONTINUE
     END IF
     SUM = 2*SUM
     DO 130 I = 1, N
    IF( DBLE( A( I, I ) )/=ZERO ) THEN
       ABSA = ABS( DBLE( A( I, I ) ) )
       IF( SCALE < ABSA ) THEN
      SUM = ONE + SUM*( SCALE / ABSA )**2
      SCALE = ABSA
       ELSE
      SUM = SUM + ( ABSA / SCALE )**2
       END IF
    END IF
  130    CONTINUE
     VALUE = SCALE*SQRT( SUM )
  END IF
!
  res = VALUE
  END function

  FUNCTION ZLANHP( NORM, UPLO, N, AP, WORK ) result (res)
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  REAL res
  CHR      NORM, UPLO
  INTEGER    N
!     ..
!     .. Array Arguments ..
  REAL   WORK( * )
  CPX     AP( * )
!     ..
!
!  Purpose
!  =======
!
!  ZLANHP  returns the value of the one norm,  or the Frobenius norm, or
!  the  infinity norm,  or the  element of  largest absolute value  of a
!  complex hermitian matrix A,  supplied in packed form.
!
!  Description
!  ===========
!
!  ZLANHP returns the value
!
!     ZLANHP = ( max(abs(A(i,j))), NORM = 'M' or 'm'
!      (
!      ( norm1(A),     NORM = '1', 'O' or 'o'
!      (
!      ( normI(A),     NORM = 'I' or 'i'
!      (
!      ( normF(A),     NORM = 'F', 'f', 'E' or 'e'
!
!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
!
!  Arguments
!  =========
!
!  NORM    (input) STR(len=1)
!      Specifies the value to be returned in ZLANHP as described
!      above.
!
!  UPLO    (input) STR(len=1)
!      Specifies whether the upper or lower triangular part of the
!      hermitian matrix A is supplied.
!      = 'U':  Upper triangular part of A is supplied
!      = 'L':  Lower triangular part of A is supplied
!
!  N   (input) INTEGER
!      The order of the matrix A.  N >= 0.  When N = 0, ZLANHP is
!      set to zero.
!
!  AP  (input) CPX array, dimension (N*(N+1)/2)
!      The upper or lower triangle of the hermitian matrix A, packed
!      columnwise in a linear array.  The j-th column of A is stored
!      in the array AP as follows:
!      if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;
!      if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.
!      Note that the  imaginary parts of the diagonal elements need
!      not be set and are assumed to be zero.
!
!  WORK    (workspace) REAL array, dimension (LWORK),
!      where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
!      WORK is not referenced.
!
! =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J, K
  REAL   ABSA, SCALE, SUM, VALUE
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZLASSQ
!     ..
!     .. Executable Statements ..
!
  IF( N == 0 ) THEN
     VALUE = ZERO
  ELSE IF(  scan( NORM, 'Mm' )>0 ) THEN
!
!    Find max(abs(A(i,j))).
!
     VALUE = ZERO
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    K = 0
    DO 20 J = 1, N
       DO 10 I = K + 1, K + J - 1
      VALUE = MAX( VALUE, ABS( AP( I ) ) )
   10      CONTINUE
       K = K + J
       VALUE = MAX( VALUE, ABS( DBLE( AP( K ) ) ) )
   20   CONTINUE
     ELSE
    K = 1
    DO 40 J = 1, N
       VALUE = MAX( VALUE, ABS( DBLE( AP( K ) ) ) )
       DO 30 I = K + 1, K + N - J
      VALUE = MAX( VALUE, ABS( AP( I ) ) )
   30      CONTINUE
       K = K + N - J + 1
   40   CONTINUE
     END IF
  ELSE IF( scan( NORM, 'IiOo1' )>0 ) THEN
!
!    Find normI(A) ( = norm1(A), since A is hermitian).
!
     VALUE = ZERO
     K = 1
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 60 J = 1, N
       SUM = ZERO
       DO 50 I = 1, J - 1
      ABSA = ABS( AP( K ) )
      SUM = SUM + ABSA
      WORK( I ) = WORK( I ) + ABSA
      K = K + 1
   50      CONTINUE
       WORK( J ) = SUM + ABS( DBLE( AP( K ) ) )
       K = K + 1
   60   CONTINUE
    DO 70 I = 1, N
       VALUE = MAX( VALUE, WORK( I ) )
   70   CONTINUE
     ELSE
    DO 80 I = 1, N
       WORK( I ) = ZERO
   80   CONTINUE
    DO 100 J = 1, N
       SUM = WORK( J ) + ABS( DBLE( AP( K ) ) )
       K = K + 1
       DO 90 I = J + 1, N
      ABSA = ABS( AP( K ) )
      SUM = SUM + ABSA
      WORK( I ) = WORK( I ) + ABSA
      K = K + 1
   90      CONTINUE
       VALUE = MAX( VALUE, SUM )
  100   CONTINUE
     END IF
  ELSE IF( scan( NORM, 'FfEe' )>0 ) THEN
!
!    Find normF(A).
!
     SCALE = ZERO
     SUM = ONE
     K = 2
     IF(  scan( UPLO, 'Uu' )>0 ) THEN
    DO 110 J = 2, N
       CALL ZLASSQ( J-1, AP( K ), 1, SCALE, SUM )
       K = K + J
  110   CONTINUE
     ELSE
    DO 120 J = 1, N - 1
       CALL ZLASSQ( N-J, AP( K ), 1, SCALE, SUM )
       K = K + N - J + 1
  120   CONTINUE
     END IF
     SUM = 2*SUM
     K = 1
     DO 130 I = 1, N
    IF( DBLE( AP( K ) )/=ZERO ) THEN
       ABSA = ABS( DBLE( AP( K ) ) )
       IF( SCALE < ABSA ) THEN
      SUM = ONE + SUM*( SCALE / ABSA )**2
      SCALE = ABSA
       ELSE
      SUM = SUM + ( ABSA / SCALE )**2
       END IF
    END IF
    IF(  scan( UPLO, 'Uu' )>0 ) THEN
       K = K + I + 1
    ELSE
       K = K + N - I + 1
    END IF
  130    CONTINUE
     VALUE = SCALE*SQRT( SUM )
  END IF
!
  res = VALUE
  END function

  SUBROUTINE ZLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV, &
         T, LDT, C, LDC, WORK, LDWORK )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      DIRECT, SIDE, STOREV, TRANS
  INTEGER    K, LDC, LDT, LDV, LDWORK, M, N
!     ..
!     .. Array Arguments ..
  CPX     C( LDC, * ), T( LDT, * ), V( LDV, * ), WORK(LDWORK, *)
!     ..
!
!  Purpose
!  =======
!
!  ZLARFB applies a complex block reflector H or its transpose H' to a
!  complex M-by-N matrix C, from either the left or the right.
!
!  Arguments
!  =========
!
!  SIDE    (input) STR(len=1)
!      = 'L': apply H or H' from the Left
!      = 'R': apply H or H' from the Right
!
!  TRANS   (input) STR(len=1)
!      = 'N': apply H (No transpose)
!      = 'C': apply H' (Conjugate transpose)
!
!  DIRECT  (input) STR(len=1)
!      Indicates how H is formed from a product of elementary
!      reflectors
!      = 'F': H = H(1) H(2) . . . H(k) (Forward)
!      = 'B': H = H(k) . . . H(2) H(1) (Backward)
!
!  STOREV  (input) STR(len=1)
!      Indicates how the vectors which define the elementary
!      reflectors are stored:
!      = 'C': Columnwise
!      = 'R': Rowwise
!
!  M   (input) INTEGER
!      The number of rows of the matrix C.
!
!  N   (input) INTEGER
!      The number of columns of the matrix C.
!
!  K   (input) INTEGER
!      The order of the matrix T (= the number of elementary
!      reflectors whose product defines the block reflector).
!
!  V   (input) CPX array, dimension
!            (LDV,K) if STOREV = 'C'
!            (LDV,M) if STOREV = 'R' and SIDE = 'L'
!            (LDV,N) if STOREV = 'R' and SIDE = 'R'
!      The matrix V. See further details.
!
!  LDV     (input) INTEGER
!      The leading dimension of the array V.
!      If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
!      if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
!      if STOREV = 'R', LDV >= K.
!
!  T   (input) CPX array, dimension (LDT,K)
!      The triangular K-by-K matrix T in the representation of the
!      block reflector.
!
!  LDT     (input) INTEGER
!      The leading dimension of the array T. LDT >= K.
!
!  C   (input/output) CPX array, dimension (LDC,N)
!      On entry, the M-by-N matrix C.
!      On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
!
!  LDC     (input) INTEGER
!      The leading dimension of the array C. LDC >= max(1,M).
!
!  WORK    (workspace) CPX array, dimension (LDWORK,K)
!
!  LDWORK  (input) INTEGER
!      The leading dimension of the array WORK.
!      If SIDE = 'L', LDWORK >= max(1,N);
!      if SIDE = 'R', LDWORK >= max(1,M).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  CHR      TRANST
  INTEGER    I, J
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZCOPY, ZGEMM, ZLACGV, ZTRMM
!     ..
!     .. Executable Statements ..
!
!     Quick return if possible
!
  IF( M <= 0  OR  N <= 0 ) RETURN
!
  IF(  scan( TRANS, 'Nn' )>0 ) THEN
     TRANST = 'C'
  ELSE
     TRANST = 'N'
  END IF
!
  IF(  scan( STOREV, 'Cc' )>0 ) THEN
!
     IF(  scan( DIRECT, 'Ff' )>0 ) THEN
!
!       Let  V =  ( V1 )    (first K rows)
!         ( V2 )
!       where  V1  is unit lower triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
!
!      W := C1'
!
       DO 10 J = 1, K
      CALL ZCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
      CALL ZLACGV( N, WORK( 1, J ), 1 )
   10      CONTINUE
!
!      W := W * V1
!
       CALL ZTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
           K, ONE, V, LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C2'*V2
!
      CALL ZGEMM( 'Conjugate transpose', 'No transpose', N, &
          K, M-K, ONE, C( K+1, 1 ), LDC, &
          V( K+1, 1 ), LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL ZTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V * W'
!
       IF( M > K ) THEN
!
!         C2 := C2 - V2 * W'
!
      CALL ZGEMM( 'No transpose', 'Conjugate transpose', &
          M-K, N, K, -ONE, V( K+1, 1 ), LDV, WORK, &
          LDWORK, ONE, C( K+1, 1 ), LDC )
       END IF
!
!      W := W * V1'
!
       CALL ZTRMM( 'Right', 'Lower', 'Conjugate transpose', &
           'Unit', N, K, ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W'
!
       DO 30 J = 1, K
      DO 20 I = 1, N
         C( J, I ) = C( J, I ) - conjg( WORK( I, J ) )
   20     CONTINUE
   30      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
!
!      W := C1
!
       DO 40 J = 1, K
      CALL ZCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
   40      CONTINUE
!
!      W := W * V1
!
       CALL ZTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
           K, ONE, V, LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C2 * V2
!
      CALL ZGEMM( 'No transpose', 'No transpose', M, K, N-K, &
          ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV, &
          ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL ZTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V'
!
       IF( N > K ) THEN
!
!         C2 := C2 - W * V2'
!
      CALL ZGEMM( 'No transpose', 'Conjugate transpose', M, &
          N-K, K, -ONE, WORK, LDWORK, V( K+1, 1 ), &
          LDV, ONE, C( 1, K+1 ), LDC )
       END IF
!
!      W := W * V1'
!
       CALL ZTRMM( 'Right', 'Lower', 'Conjugate transpose', &
           'Unit', M, K, ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W
!
       DO 60 J = 1, K
      DO 50 I = 1, M
         C( I, J ) = C( I, J ) - WORK( I, J )
   50     CONTINUE
   60      CONTINUE
    END IF
!
     ELSE
!
!       Let  V =  ( V1 )
!         ( V2 )    (last K rows)
!       where  V2  is unit upper triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
!
!      W := C2'
!
       DO 70 J = 1, K
      CALL ZCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
      CALL ZLACGV( N, WORK( 1, J ), 1 )
   70      CONTINUE
!
!      W := W * V2
!
       CALL ZTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
           K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C1'*V1
!
      CALL ZGEMM( 'Conjugate transpose', 'No transpose', N, &
          K, M-K, ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL ZTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V * W'
!
       IF( M > K ) THEN
!
!         C1 := C1 - V1 * W'
!
      CALL ZGEMM( 'No transpose', 'Conjugate transpose', &
          M-K, N, K, -ONE, V, LDV, WORK, LDWORK, &
          ONE, C, LDC )
       END IF
!
!      W := W * V2'
!
       CALL ZTRMM( 'Right', 'Upper', 'Conjugate transpose', &
           'Unit', N, K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK)
!
!      C2 := C2 - W'
!
       DO 90 J = 1, K
      DO 80 I = 1, N
         C( M-K+J, I ) = C( M-K+J, I ) - conjg( WORK( I, J ) )
   80     CONTINUE
   90      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
!
!      W := C2
!
       DO 100 J = 1, K
      CALL ZCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  100      CONTINUE
!
!      W := W * V2
!
       CALL ZTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
           K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C1 * V1
!
      CALL ZGEMM( 'No transpose', 'No transpose', M, K, N-K, &
          ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL ZTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V'
!
       IF( N > K ) THEN
!
!         C1 := C1 - W * V1'
!
      CALL ZGEMM( 'No transpose', 'Conjugate transpose', M, &
          N-K, K, -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
       END IF
!
!      W := W * V2'
!
       CALL ZTRMM( 'Right', 'Upper', 'Conjugate transpose', &
           'Unit', M, K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK)
!
!      C2 := C2 - W
!
       DO 120 J = 1, K
      DO 110 I = 1, M
         C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  110     CONTINUE
  120      CONTINUE
    END IF
     END IF
!
  ELSE IF(  scan( STOREV, 'Rr' )>0 ) THEN
!
     IF(  scan( DIRECT, 'Ff' )>0 ) THEN
!
!       Let  V =  ( V1  V2 )    (V1: first K columns)
!       where  V1  is unit upper triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
!
!      W := C1'
!
       DO 130 J = 1, K
      CALL ZCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
      CALL ZLACGV( N, WORK( 1, J ), 1 )
  130      CONTINUE
!
!      W := W * V1'
!
       CALL ZTRMM( 'Right', 'Upper', 'Conjugate transpose', &
           'Unit', N, K, ONE, V, LDV, WORK, LDWORK )
       IF( M > K ) THEN
!
!         W := W + C2'*V2'
!
      CALL ZGEMM( 'Conjugate transpose', &
          'Conjugate transpose', N, K, M-K, ONE, &
          C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE, &
          WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL ZTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V' * W'
!
       IF( M > K ) THEN
!
!         C2 := C2 - V2' * W'
!
      CALL ZGEMM( 'Conjugate transpose', &
          'Conjugate transpose', M-K, N, K, -ONE, &
          V( 1, K+1 ), LDV, WORK, LDWORK, ONE, &
          C( K+1, 1 ), LDC )
       END IF
!
!      W := W * V1
!
       CALL ZTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N, &
           K, ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W'
!
       DO 150 J = 1, K
      DO 140 I = 1, N
         C( J, I ) = C( J, I ) - conjg( WORK( I, J ) )
  140     CONTINUE
  150      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
!
!      W := C1
!
       DO 160 J = 1, K
      CALL ZCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
  160      CONTINUE
!
!      W := W * V1'
!
       CALL ZTRMM( 'Right', 'Upper', 'Conjugate transpose', &
           'Unit', M, K, ONE, V, LDV, WORK, LDWORK )
       IF( N > K ) THEN
!
!         W := W + C2 * V2'
!
      CALL ZGEMM( 'No transpose', 'Conjugate transpose', M, &
          K, N-K, ONE, C( 1, K+1 ), LDC, &
          V( 1, K+1 ), LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL ZTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V
!
       IF( N > K ) THEN
!
!         C2 := C2 - W * V2
!
      CALL ZGEMM( 'No transpose', 'No transpose', M, N-K, K, &
          -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE, &
          C( 1, K+1 ), LDC )
       END IF
!
!      W := W * V1
!
       CALL ZTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M, &
           K, ONE, V, LDV, WORK, LDWORK )
!
!      C1 := C1 - W
!
       DO 180 J = 1, K
      DO 170 I = 1, M
         C( I, J ) = C( I, J ) - WORK( I, J )
  170     CONTINUE
  180      CONTINUE
!
    END IF
!
     ELSE
!
!       Let  V =  ( V1  V2 )    (V2: last K columns)
!       where  V2  is unit lower triangular.
!
    IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!      Form  H * C  or  H' * C  where  C = ( C1 )
!                  ( C2 )
!
!      W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
!
!      W := C2'
!
       DO 190 J = 1, K
      CALL ZCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
      CALL ZLACGV( N, WORK( 1, J ), 1 )
  190      CONTINUE
!
!      W := W * V2'
!
       CALL ZTRMM( 'Right', 'Lower', 'Conjugate transpose', &
           'Unit', N, K, ONE, V( 1, M-K+1 ), LDV, WORK, &
           LDWORK )
       IF( M > K ) THEN
!
!         W := W + C1'*V1'
!
      CALL ZGEMM( 'Conjugate transpose', &
          'Conjugate transpose', N, K, M-K, ONE, C, &
          LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T'  or  W * T
!
       CALL ZTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - V' * W'
!
       IF( M > K ) THEN
!
!         C1 := C1 - V1' * W'
!
      CALL ZGEMM( 'Conjugate transpose', &
          'Conjugate transpose', M-K, N, K, -ONE, V, &
          LDV, WORK, LDWORK, ONE, C, LDC )
       END IF
!
!      W := W * V2
!
       CALL ZTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N, &
           K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
!
!      C2 := C2 - W'
!
       DO 210 J = 1, K
      DO 200 I = 1, N
         C( M-K+J, I ) = C( M-K+J, I ) - conjg( WORK( I, J ) )
  200     CONTINUE
  210      CONTINUE
!
    ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!      Form  C * H  or  C * H'  where  C = ( C1  C2 )
!
!      W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
!
!      W := C2
!
       DO 220 J = 1, K
      CALL ZCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  220      CONTINUE
!
!      W := W * V2'
!
       CALL ZTRMM( 'Right', 'Lower', 'Conjugate transpose', &
           'Unit', M, K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK)
       IF( N > K ) THEN
!
!         W := W + C1 * V1'
!
      CALL ZGEMM( 'No transpose', 'Conjugate transpose', M, &
          K, N-K, ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
       END IF
!
!      W := W * T  or  W * T'
!
       CALL ZTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K, &
           ONE, T, LDT, WORK, LDWORK )
!
!      C := C - W * V
!
       IF( N > K ) THEN
!
!         C1 := C1 - W * V1
!
      CALL ZGEMM( 'No transpose', 'No transpose', M, N-K, K, &
          -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
       END IF
!
!      W := W * V2
!
       CALL ZTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M, &
           K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
!
!      C1 := C1 - W
!
       DO 240 J = 1, K
      DO 230 I = 1, M
         C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  230     CONTINUE
  240      CONTINUE
!
    END IF
!
     END IF
  END IF
!
  RETURN
!
!     End of ZLARFB
!
  END

  SUBROUTINE ZLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      SIDE
  INTEGER    INCV, LDC, M, N
  CPX     TAU
!     ..
!     .. Array Arguments ..
  CPX     C( LDC, * ), V( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZLARF applies a complex elementary reflector H to a complex M-by-N
!  matrix C, from either the left or the right. H is represented in the
!  form
!
!    H = I - tau * v * v'
!
!  where tau is a complex scalar and v is a complex vector.
!
!  If tau = 0, then H is taken to be the unit matrix.
!
!  To apply H' (the conjugate transpose of H), supply conjg(tau) instead
!  tau.
!
!  Arguments
!  =========
!
!  SIDE    (input) STR(len=1)
!      = 'L': form  H * C
!      = 'R': form  C * H
!
!  M   (input) INTEGER
!      The number of rows of the matrix C.
!
!  N   (input) INTEGER
!      The number of columns of the matrix C.
!
!  V   (input) CPX array, dimension
!         (1 + (M-1)*abs(INCV)) if SIDE = 'L'
!      or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
!      The vector v in the representation of H. V is not used if
!      TAU = 0.
!
!  INCV    (input) INTEGER
!      The increment between elements of v. INCV <> 0.
!
!  TAU     (input) CPX
!      The value tau in the representation of H.
!
!  C   (input/output) CPX array, dimension (LDC,N)
!      On entry, the M-by-N matrix C.
!      On exit, C is overwritten by the matrix H * C if SIDE = 'L',
!      or C * H if SIDE = 'R'.
!
!  LDC     (input) INTEGER
!      The leading dimension of the array C. LDC >= max(1,M).
!
!  WORK    (workspace) CPX array, dimension
!         (N) if SIDE = 'L'
!          or (M) if SIDE = 'R'
!
!  =====================================================================
!
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZGEMV, ZGERC
!     ..
!     .. Executable Statements ..
!
  IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!    Form  H * C
!
     IF( TAU/=ZERO ) THEN
!
!       w := C' * v
!
    CALL ZGEMV( 'Conjugate transpose', M, N, ONE, C, LDC, V, &
        INCV, ZERO, WORK, 1 )
!
!       C := C - v * w'
!
    CALL ZGERC( M, N, -TAU, V, INCV, WORK, 1, C, LDC )
     END IF
  ELSE
!
!    Form  C * H
!
     IF( TAU/=ZERO ) THEN
!
!       w := C * v
!
    CALL ZGEMV('No transpose', M, N, ONE, C, LDC, V, INCV, ZERO, WORK,1)
!
!       C := C - w * v'
!
    CALL ZGERC( M, N, -TAU, WORK, 1, V, INCV, C, LDC )
     END IF
  END IF
  RETURN
!
!     End of ZLARF
!
  END

  SUBROUTINE ZLARFG( N, ALPHA, X, INCX, TAU )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  INTEGER    INCX, N
  CPX     ALPHA, TAU
!     ..
!     .. Array Arguments ..
  CPX     X( * )
!     ..
!
!  Purpose
!  =======
!
!  ZLARFG generates a complex elementary reflector H of order n, such
!  that
!
!    H' * ( alpha ) = ( beta ),   H' * H = I.
!     (   x   )   (   0  )
!
!  where alpha and beta are scalars, with beta real, and x is an
!  (n-1)-element complex vector. H is represented in the form
!
!    H = I - tau * ( 1 ) * ( 1 v' ) ,
!          ( v )
!
!  where tau is a complex scalar and v is a complex (n-1)-element
!  vector. Note that H is not hermitian.
!
!  If the elements of x are all zero and alpha is real, then tau = 0
!  and H is taken to be the unit matrix.
!
!  Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 .
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The order of the elementary reflector.
!
!  ALPHA   (input/output) CPX
!      On entry, the value alpha.
!      On exit, it is overwritten with the value beta.
!
!  X   (input/output) CPX array, dimension
!         (1+(N-2)*abs(INCX))
!      On entry, the vector x.
!      On exit, it is overwritten with the vector v.
!
!  INCX    (input) INTEGER
!      The increment between elements of X. INCX > 0.
!
!  TAU     (output) CPX
!      The value tau.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    J, KNT
  REAL   ALPHI, ALPHR, BETA, RSAFMN, SAFMIN, XNORM
!     ..
!     .. External Functions ..
  REAL   DLAPY3, DZNRM2
  CPX     ZLADIV
  EXTERNAL       DLAPY3, DZNRM2, ZLADIV
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZDSCAL, ZSCAL
!     ..
!     .. Executable Statements ..
!
  IF( N <= 0 ) THEN
     TAU = ZERO
     RETURN
  END IF
!
  XNORM = DZNRM2( N-1, X, INCX )
  ALPHR = DBLE( ALPHA )
  ALPHI = AIMAG( ALPHA )
!
  IF( XNORM == ZERO  AND  ALPHI == ZERO ) THEN
!
!    H  =  I
!
     TAU = ZERO
  ELSE
!
!    general case
!
     BETA = -SIGN( DLAPY3( ALPHR, ALPHI, XNORM ), ALPHR )
     SAFMIN = tiny(ZERO)*radix(ZERO)/epsilon(ZERO)
     RSAFMN = ONE / SAFMIN
!
     IF( ABS( BETA ) < SAFMIN ) THEN
!
!       XNORM, BETA may be inaccurate; scale X and recompute them
!
    KNT = 0
   10   CONTINUE
    KNT = KNT + 1
    CALL ZDSCAL( N-1, RSAFMN, X, INCX )
    BETA = BETA*RSAFMN
    ALPHI = ALPHI*RSAFMN
    ALPHR = ALPHR*RSAFMN
    IF( ABS( BETA ) < SAFMIN ) GO TO 10
!
!       New BETA is at most 1, at least SAFMIN
!
    XNORM = DZNRM2( N-1, X, INCX )
    ALPHA = CMPLX( ALPHR, ALPHI , kind=kind(ONE))
    BETA = -SIGN( DLAPY3( ALPHR, ALPHI, XNORM ), ALPHR )
    TAU = CMPLX( ( BETA-ALPHR ) / BETA, -ALPHI / BETA , kind=kind(ONE))
    ALPHA = ZLADIV( CMPLX( ONE , kind=kind(ONE)), ALPHA-BETA )
    CALL ZSCAL( N-1, ALPHA, X, INCX )
!
!       If ALPHA is subnormal, it may lose relative accuracy
!
    ALPHA = BETA
    DO 20 J = 1, KNT
       ALPHA = ALPHA*SAFMIN
   20   CONTINUE
     ELSE
    TAU = CMPLX( ( BETA-ALPHR ) / BETA, -ALPHI / BETA , kind=kind(ONE))
    ALPHA = ZLADIV( CMPLX( ONE , kind=kind(ONE)), ALPHA-BETA )
    CALL ZSCAL( N-1, ALPHA, X, INCX )
    ALPHA = BETA
     END IF
  END IF
!
  RETURN
!
!     End of ZLARFG
!
  END

  SUBROUTINE ZLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      DIRECT, STOREV
  INTEGER    K, LDT, LDV, N
!     ..
!     .. Array Arguments ..
  CPX     T( LDT, * ), TAU( * ), V( LDV, * )
!     ..
!
!  Purpose
!  =======
!
!  ZLARFT forms the triangular factor T of a complex block reflector H
!  of order n, which is defined as a product of k elementary reflectors.
!
!  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
!
!  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
!
!  If STOREV = 'C', the vector which defines the elementary reflector
!  H(i) is stored in the i-th column of the array V, and
!
!     H  =  I - V * T * V'
!
!  If STOREV = 'R', the vector which defines the elementary reflector
!  H(i) is stored in the i-th row of the array V, and
!
!     H  =  I - V' * T * V
!
!  Arguments
!  =========
!
!  DIRECT  (input) STR(len=1)
!      Specifies the order in which the elementary reflectors are
!      multiplied to form the block reflector:
!      = 'F': H = H(1) H(2) . . . H(k) (Forward)
!      = 'B': H = H(k) . . . H(2) H(1) (Backward)
!
!  STOREV  (input) STR(len=1)
!      Specifies how the vectors which define the elementary
!      reflectors are stored (see also Further Details):
!      = 'C': columnwise
!      = 'R': rowwise
!
!  N   (input) INTEGER
!      The order of the block reflector H. N >= 0.
!
!  K   (input) INTEGER
!      The order of the triangular factor T (= the number of
!      elementary reflectors). K >= 1.
!
!  V   (input/output) CPX array, dimension
!           (LDV,K) if STOREV = 'C'
!           (LDV,N) if STOREV = 'R'
!      The matrix V. See further details.
!
!  LDV     (input) INTEGER
!      The leading dimension of the array V.
!      If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
!
!  TAU     (input) CPX array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i).
!
!  T   (output) CPX array, dimension (LDT,K)
!      The k by k triangular factor T of the block reflector.
!      If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
!      lower triangular. The rest of the array is not used.
!
!  LDT     (input) INTEGER
!      The leading dimension of the array T. LDT >= K.
!
!  Further Details
!  ===============
!
!  The shape of the matrix V and the storage of the vectors which define
!  the H(i) is best illustrated by the following example with n = 5 and
!  k = 3. The elements equal to 1 are not stored; the corresponding
!  array elements are modified but restored on exit. The rest of the
!  array is not used.
!
!  DIRECT = 'F' and STOREV = 'C':     DIRECT = 'F' and STOREV = 'R':
!
!       V = (  1   )         V = (  1 v1 v1 v1 v1 )
!       ( v1  1    )         (     1 v2 v2 v2 )
!       ( v1 v2  1 )         (    1 v3 v3 )
!       ( v1 v2 v3 )
!       ( v1 v2 v3 )
!
!  DIRECT = 'B' and STOREV = 'C':     DIRECT = 'B' and STOREV = 'R':
!
!       V = ( v1 v2 v3 )         V = ( v1 v1  1   )
!       ( v1 v2 v3 )         ( v2 v2 v2  1    )
!       (  1 v2 v3 )         ( v3 v3 v3 v3  1 )
!       (     1 v3 )
!       (    1 )
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J
  CPX     VII
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZGEMV, ZLACGV, ZTRMV
!     ..
!     .. Executable Statements ..
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
  IF(  scan( DIRECT, 'Ff' )>0 ) THEN
     DO 20 I = 1, K
    IF( TAU( I ) == ZERO ) THEN
!
!      H(i)  =  I
!
       DO 10 J = 1, I
      T( J, I ) = ZERO
   10      CONTINUE
    ELSE
!
!      general case
!
       VII = V( I, I )
       V( I, I ) = ONE
       IF(  scan( STOREV, 'Cc' )>0 ) THEN
!
!         T(1:i-1,i) := - tau(i) * V(i:n,1:i-1)' * V(i:n,i)
!
      CALL ZGEMV( 'Conjugate transpose', N-I+1, I-1, &
          -TAU( I ), V( I, 1 ), LDV, V( I, I ), 1, &
          ZERO, T( 1, I ), 1 )
       ELSE
!
!         T(1:i-1,i) := - tau(i) * V(1:i-1,i:n) * V(i,i:n)'
!
      IF( I < N ) CALL ZLACGV( N-I, V( I, I+1 ), LDV )
      CALL ZGEMV( 'No transpose', I-1, N-I+1, -TAU( I ), &
          V( 1, I ), LDV, V( I, I ), LDV, ZERO, &
          T( 1, I ), 1 )
      IF( I < N ) CALL ZLACGV( N-I, V( I, I+1 ), LDV )
       END IF
       V( I, I ) = VII
!
!      T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
!
       CALL ZTRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T, &
           LDT, T( 1, I ), 1 )
       T( I, I ) = TAU( I )
    END IF
   20    CONTINUE
  ELSE
     DO 40 I = K, 1, -1
    IF( TAU( I ) == ZERO ) THEN
!
!      H(i)  =  I
!
       DO 30 J = I, K
      T( J, I ) = ZERO
   30      CONTINUE
    ELSE
!
!      general case
!
       IF( I < K ) THEN
      IF(  scan( STOREV, 'Cc' )>0 ) THEN
         VII = V( N-K+I, I )
         V( N-K+I, I ) = ONE
!
!        T(i+1:k,i) :=
!            - tau(i) * V(1:n-k+i,i+1:k)' * V(1:n-k+i,i)
!
         CALL ZGEMV( 'Conjugate transpose', N-K+I, K-I, &
             -TAU( I ), V( 1, I+1 ), LDV, V( 1, I ), &
             1, ZERO, T( I+1, I ), 1 )
         V( N-K+I, I ) = VII
      ELSE
         VII = V( I, N-K+I )
         V( I, N-K+I ) = ONE
!
!        T(i+1:k,i) :=
!            - tau(i) * V(i+1:k,1:n-k+i) * V(i,1:n-k+i)'
!
         CALL ZLACGV( N-K+I-1, V( I, 1 ), LDV )
         CALL ZGEMV( 'No transpose', K-I, N-K+I, -TAU( I ), &
             V( I+1, 1 ), LDV, V( I, 1 ), LDV, ZERO, &
             T( I+1, I ), 1 )
         CALL ZLACGV( N-K+I-1, V( I, 1 ), LDV )
         V( I, N-K+I ) = VII
      END IF
!
!         T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
!
      CALL ZTRMV( 'Lower', 'No transpose', 'Non-unit', K-I, &
          T( I+1, I+1 ), LDT, T( I+1, I ), 1 )
       END IF
       T( I, I ) = TAU( I )
    END IF
   40    CONTINUE
  END IF
  RETURN
!
!     End of ZLARFT
!
  END

  SUBROUTINE ZLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     February 29, 1992
!
!     .. Scalar Arguments ..
  CHR      TYPE
  INTEGER    INFO, KL, KU, LDA, M, N
  REAL   CFROM, CTO
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  ZLASCL multiplies the M by N complex matrix A by the real scalar
!  CTO/CFROM.  This is done without over/underflow as long as the final
!  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
!  A may be full, upper triangular, lower triangular, upper Hessenberg,
!  or banded.
!
!  Arguments
!  =========
!
!  TYPE    (input) STR(len=1)
!      TYPE indices the storage type of the input matrix.
!      = 'G':  A is a full matrix.
!      = 'L':  A is a lower triangular matrix.
!      = 'U':  A is an upper triangular matrix.
!      = 'H':  A is an upper Hessenberg matrix.
!      = 'B':  A is a symmetric band matrix with lower bandwidth KL
!      and upper bandwidth KU and with the only the lower
!      half stored.
!      = 'Q':  A is a symmetric band matrix with lower bandwidth KL
!      and upper bandwidth KU and with the only the upper
!      half stored.
!      = 'Z':  A is a band matrix with lower bandwidth KL and upper
!      bandwidth KU.
!
!  KL  (input) INTEGER
!      The lower bandwidth of A.  Referenced only if TYPE = 'B',
!      'Q' or 'Z'.
!
!  KU  (input) INTEGER
!      The upper bandwidth of A.  Referenced only if TYPE = 'B',
!      'Q' or 'Z'.
!
!  CFROM   (input) REAL
!  CTO     (input) REAL
!      The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
!      without over/underflow if the final result CTO*A(I,J)/CFROM
!      can be represented without over/underflow.  CFROM must be
!      nonzero.
!
!  M   (input) INTEGER
!      The number of rows of the matrix A.  M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix A.  N >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,M)
!      The matrix to be multiplied by CTO/CFROM.  See TYPE for the
!      storage type.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,M).
!
!  INFO    (output) INTEGER
!      0  - successful exit
!      <0 - if INFO = -i, the i-th argument had an illegal value.
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    DONE
  INTEGER    I, ITYPE, J, K1, K2, K3, K4
  REAL   BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
!
  IF(  scan( TYPE, 'Gg' )>0 ) THEN
     ITYPE = 0
  ELSE IF(  scan( TYPE, 'Ll' )>0 ) THEN
     ITYPE = 1
  ELSE IF(  scan( TYPE, 'Uu' )>0 ) THEN
     ITYPE = 2
  ELSE IF(  scan( TYPE, 'Hh' )>0 ) THEN
     ITYPE = 3
  ELSE IF(  scan( TYPE, 'Bb' )>0 ) THEN
     ITYPE = 4
  ELSE IF(  scan( TYPE, 'Qq' )>0 ) THEN
     ITYPE = 5
  ELSE IF(  scan( TYPE, 'Zz' )>0 ) THEN
     ITYPE = 6
  ELSE
     ITYPE = -1
  END IF
!
  IF( ITYPE == -1 ) THEN
     INFO = -1
  ELSE IF( CFROM == ZERO ) THEN
     INFO = -4
  ELSE IF( M < 0 ) THEN
     INFO = -6
  ELSE IF( N < 0  OR  ( ITYPE == 4  AND  N/=M )  OR  &
       ( ITYPE == 5  AND  N/=M ) ) THEN
     INFO = -7
  ELSE IF( ITYPE <= 3  AND  LDA < MAX( 1, M ) ) THEN
     INFO = -9
  ELSE IF( ITYPE.GE.4 ) THEN
     IF( KL < 0  OR  KL > MAX( M-1, 0 ) ) THEN
    INFO = -2
     ELSE IF( KU < 0  OR  KU > MAX( N-1, 0 )  OR  &
      ( ( ITYPE == 4  OR  ITYPE == 5 )  AND  KL/=KU ) ) THEN
    INFO = -3
     ELSE IF( ( ITYPE == 4  AND  LDA < KL+1 )  OR  &
      ( ITYPE == 5  AND  LDA < KU+1 )  OR  &
      ( ITYPE == 6  AND  LDA < 2*KL+KU+1 ) ) THEN
    INFO = -9
     END IF
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZLASCL', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0  OR  M == 0 ) RETURN
!
!     Get machine parameters
!
  SMLNUM = tiny(ZERO)
  BIGNUM = ONE / SMLNUM
!
  CFROMC = CFROM
  CTOC = CTO
!
   10 CONTINUE
  CFROM1 = CFROMC*SMLNUM
  CTO1 = CTOC / BIGNUM
  IF( ABS( CFROM1 ) > ABS( CTOC )  AND  CTOC/=ZERO ) THEN
     MUL = SMLNUM
     DONE =  FALSE
     CFROMC = CFROM1
  ELSE IF( ABS( CTO1 ) > ABS( CFROMC ) ) THEN
     MUL = BIGNUM
     DONE =  FALSE
     CTOC = CTO1
  ELSE
     MUL = CTOC / CFROMC
     DONE =  TRUE
  END IF
!
  IF( ITYPE == 0 ) THEN
!
!    Full matrix
!
     DO 30 J = 1, N
    DO 20 I = 1, M
       A( I, J ) = A( I, J )*MUL
   20   CONTINUE
   30    CONTINUE
!
  ELSE IF( ITYPE == 1 ) THEN
!
!    Lower triangular matrix
!
     DO 50 J = 1, N
    DO 40 I = J, M
       A( I, J ) = A( I, J )*MUL
   40   CONTINUE
   50    CONTINUE
!
  ELSE IF( ITYPE == 2 ) THEN
!
!    Upper triangular matrix
!
     DO 70 J = 1, N
    DO 60 I = 1, MIN( J, M )
       A( I, J ) = A( I, J )*MUL
   60   CONTINUE
   70    CONTINUE
!
  ELSE IF( ITYPE == 3 ) THEN
!
!    Upper Hessenberg matrix
!
     DO 90 J = 1, N
    DO 80 I = 1, MIN( J+1, M )
       A( I, J ) = A( I, J )*MUL
   80   CONTINUE
   90    CONTINUE
!
  ELSE IF( ITYPE == 4 ) THEN
!
!    Lower half of a symmetric band matrix
!
     K3 = KL + 1
     K4 = N + 1
     DO 110 J = 1, N
    DO 100 I = 1, MIN( K3, K4-J )
       A( I, J ) = A( I, J )*MUL
  100   CONTINUE
  110    CONTINUE
!
  ELSE IF( ITYPE == 5 ) THEN
!
!    Upper half of a symmetric band matrix
!
     K1 = KU + 2
     K3 = KU + 1
     DO 130 J = 1, N
    DO 120 I = MAX( K1-J, 1 ), K3
       A( I, J ) = A( I, J )*MUL
  120   CONTINUE
  130    CONTINUE
!
  ELSE IF( ITYPE == 6 ) THEN
!
!    Band matrix
!
     K1 = KL + KU + 2
     K2 = KL + 1
     K3 = 2*KL + KU + 1
     K4 = KL + KU + 1 + M
     DO 150 J = 1, N
    DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J )
       A( I, J ) = A( I, J )*MUL
  140   CONTINUE
  150    CONTINUE
!
  END IF
!
  IF(  NOT DONE ) GO TO 10
!
  RETURN
!
!     End of ZLASCL
!
  END

  SUBROUTINE ZLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    LDA, M, N
  CPX     ALPHA, BETA
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  ZLASET initializes a 2-D array A to BETA on the diagonal and
!  ALPHA on the offdiagonals.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      Specifies the part of the matrix A to be set.
!      = 'U':  Upper triangular part is set. The lower triangle
!          is unchanged.
!      = 'L':  Lower triangular part is set. The upper triangle
!          is unchanged.
!      Otherwise:  All of the matrix A is set.
!
!  M   (input) INTEGER
!      On entry, M specifies the number of rows of A.
!
!  N   (input) INTEGER
!      On entry, N specifies the number of columns of A.
!
!  ALPHA   (input) CPX
!      All the offdiagonal array elements are set to ALPHA.
!
!  BETA    (input) CPX
!      All the diagonal array elements are set to BETA.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the m by n matrix A.
!      On exit, A(i,j) = ALPHA, 1 <= i <= m, 1 <= j <= n, i.ne.j;
!       A(i,i) = BETA , 1 <= i <= min(m,n)
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,M).
!
!  =====================================================================
!
!     .. Local Scalars ..
  INTEGER    I, J
!     ..
!     .. Executable Statements ..
!
  IF(  scan( UPLO, 'Uu' )>0 ) THEN
!
!    Set the diagonal to BETA and the strictly upper triangular
!    part of the array to ALPHA.
!
     DO 20 J = 2, N
    DO 10 I = 1, MIN( J-1, M )
       A( I, J ) = ALPHA
   10   CONTINUE
   20    CONTINUE
     DO 30 I = 1, MIN( N, M )
    A( I, I ) = BETA
   30    CONTINUE
!
  ELSE IF(  scan( UPLO, 'Ll' )>0 ) THEN
!
!    Set the diagonal to BETA and the strictly lower triangular
!    part of the array to ALPHA.
!
     DO 50 J = 1, MIN( M, N )
    DO 40 I = J + 1, M
       A( I, J ) = ALPHA
   40   CONTINUE
   50    CONTINUE
     DO 60 I = 1, MIN( N, M )
    A( I, I ) = BETA
   60    CONTINUE
!
  ELSE
!
!    Set the array to BETA on the diagonal and ALPHA on the
!    offdiagonal.
!
     DO 80 J = 1, N
    DO 70 I = 1, M
       A( I, J ) = ALPHA
   70   CONTINUE
   80    CONTINUE
     DO 90 I = 1, MIN( M, N )
    A( I, I ) = BETA
   90    CONTINUE
  END IF
!
  RETURN
!
!     End of ZLASET
!
  END

  SUBROUTINE ZLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     October 31, 1992
!
!     .. Scalar Arguments ..
  CHR      DIRECT, PIVOT, SIDE
  INTEGER    LDA, M, N
!     ..
!     .. Array Arguments ..
  REAL   C( * ), S( * )
  CPX     A( LDA, * )
!     ..
!
!  Purpose
!  =======
!
!  ZLASR   performs the transformation
!
!     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )
!
!     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )
!
!  where A is an m by n complex matrix and P is an orthogonal matrix,
!  consisting of a sequence of plane rotations determined by the
!  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
!  and z = n when SIDE = 'R' or 'r' ):
!
!  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then
!
!     P = P( z - 1 )*...*P( 2 )*P( 1 ),
!
!  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then
!
!     P = P( 1 )*P( 2 )*...*P( z - 1 ),
!
!  where  P( k ) is a plane rotation matrix for the following planes:
!
!     when  PIVOT = 'V' or 'v'  ( Variable pivot ),
!    the plane ( k, k + 1 )
!
!     when  PIVOT = 'T' or 't'  ( Top pivot ),
!    the plane ( 1, k + 1 )
!
!     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),
!    the plane ( k, z )
!
!  c( k ) and s( k )  must contain the  cosine and sine that define the
!  matrix  P( k ).  The two by two plane rotation part of the matrix
!  P( k ), R( k ), is assumed to be of the form
!
!     R( k ) = (  c( k )  s( k ) ).
!      ( -s( k )  c( k ) )
!
!  Arguments
!  =========
!
!  SIDE    (input) STR(len=1)
!      Specifies whether the plane rotation matrix P is applied to
!      A on the left or the right.
!      = 'L':  Left, compute A := P*A
!      = 'R':  Right, compute A:= A*P'
!
!  DIRECT  (input) STR(len=1)
!      Specifies whether P is a forward or backward sequence of
!      plane rotations.
!      = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )
!      = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )
!
!  PIVOT   (input) STR(len=1)
!      Specifies the plane for which P(k) is a plane rotation
!      matrix.
!      = 'V':  Variable pivot, the plane (k,k+1)
!      = 'T':  Top pivot, the plane (1,k+1)
!      = 'B':  Bottom pivot, the plane (k,z)
!
!  M   (input) INTEGER
!      The number of rows of the matrix A.  If m <= 1, an immediate
!      return is effected.
!
!  N   (input) INTEGER
!      The number of columns of the matrix A.  If n <= 1, an
!      immediate return is effected.
!
!  C, S    (input) REAL arrays, dimension
!      (M-1) if SIDE = 'L'
!      (N-1) if SIDE = 'R'
!      c(k) and s(k) contain the cosine and sine that define the
!      matrix P(k).  The two by two plane rotation part of the
!      matrix P(k), R(k), is assumed to be of the form
!      R( k ) = (  c( k )  s( k ) ).
!       ( -s( k )  c( k ) )
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      The m by n matrix A.  On exit, A is overwritten by P*A if
!      SIDE = 'R' or by A*P' if SIDE = 'L'.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,M).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, INFO, J
  REAL   CTEMP, STEMP
  CPX     TEMP
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters
!
  INFO = 0
  IF(  NOT  scan( SIDE, 'LlRr' )>0 ) THEN
     INFO = 1
  ELSE IF(  NOT  scan( PIVOT, 'VvTtBb' )>0 ) THEN
     INFO = 2
  ELSE IF(  NOT  scan( DIRECT, 'FfBb' )>0 ) THEN
     INFO = 3
  ELSE IF( M < 0 ) THEN
     INFO = 4
  ELSE IF( N < 0 ) THEN
     INFO = 5
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = 9
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZLASR ', INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( ( M == 0 )  OR  ( N == 0 ) ) RETURN
  IF(  scan( SIDE, 'Ll' )>0 ) THEN
!
!    Form  P * A
!
     IF(  scan( PIVOT, 'Vv' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 20 J = 1, M - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 10 I = 1, N
        TEMP = A( J+1, I )
        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
   10        CONTINUE
      END IF
   20      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 40 J = M - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 30 I = 1, N
        TEMP = A( J+1, I )
        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
   30        CONTINUE
      END IF
   40      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Tt' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 60 J = 2, M
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 50 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
   50        CONTINUE
      END IF
   60      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 80 J = M, 2, -1
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 70 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
   70        CONTINUE
      END IF
   80      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Bb' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 100 J = 1, M - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 90 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
   90        CONTINUE
      END IF
  100      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 120 J = M - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 110 I = 1, N
        TEMP = A( J, I )
        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
  110        CONTINUE
      END IF
  120      CONTINUE
    END IF
     END IF
  ELSE IF(  scan( SIDE, 'Rr' )>0 ) THEN
!
!    Form A * P'
!
     IF(  scan( PIVOT, 'Vv' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 140 J = 1, N - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 130 I = 1, M
        TEMP = A( I, J+1 )
        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  130        CONTINUE
      END IF
  140      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 160 J = N - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 150 I = 1, M
        TEMP = A( I, J+1 )
        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  150        CONTINUE
      END IF
  160      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Tt' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 180 J = 2, N
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 170 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
  170        CONTINUE
      END IF
  180      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 200 J = N, 2, -1
      CTEMP = C( J-1 )
      STEMP = S( J-1 )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 190 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
  190        CONTINUE
      END IF
  200      CONTINUE
    END IF
     ELSE IF(  scan( PIVOT, 'Bb' )>0 ) THEN
    IF(  scan( DIRECT, 'Ff' )>0 ) THEN
       DO 220 J = 1, N - 1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 210 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
  210        CONTINUE
      END IF
  220      CONTINUE
    ELSE IF(  scan( DIRECT, 'Bb' )>0 ) THEN
       DO 240 J = N - 1, 1, -1
      CTEMP = C( J )
      STEMP = S( J )
      IF( ( CTEMP/=ONE )  OR  ( STEMP/=ZERO ) ) THEN
         DO 230 I = 1, M
        TEMP = A( I, J )
        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
  230        CONTINUE
      END IF
  240      CONTINUE
    END IF
     END IF
  END IF
!
  RETURN
!
!     End of ZLASR
!
  END

  SUBROUTINE ZLASSQ( N, X, INCX, SCALE, SUMSQ )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INCX, N
  REAL   SCALE, SUMSQ
!     ..
!     .. Array Arguments ..
  CPX     X( * )
!     ..
!
!  Purpose
!  =======
!
!  ZLASSQ returns the values scl and ssq such that
!
!     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
!
!  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
!  assumed to be at least unity and the value of ssq will then satisfy
!
!     1.0  <=  ssq  <=  ( sumsq + 2*n ).
!
!  scale is assumed to be non-negative and scl returns the value
!
!     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
!    i
!
!  scale and sumsq must be supplied in SCALE and SUMSQ respectively.
!  SCALE and SUMSQ are overwritten by scl and ssq respectively.
!
!  The routine makes only one pass through the vector X.
!
!  Arguments
!  =========
!
!  N   (input) INTEGER
!      The number of elements to be used from the vector X.
!
!  X   (input) CPX array, dimension (N)
!      The vector x as described above.
!     x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
!
!  INCX    (input) INTEGER
!      The increment between successive values of the vector X.
!      INCX > 0.
!
!  SCALE   (input/output) REAL
!      On entry, the value  scale  in the equation above.
!      On exit, SCALE is overwritten with the value  scl .
!
!  SUMSQ   (input/output) REAL
!      On entry, the value  sumsq  in the equation above.
!      On exit, SUMSQ is overwritten with the value  ssq .
!
! =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    IX
  REAL   TEMP1
!     ..
!     .. Executable Statements ..
!
  IF( N > 0 ) THEN
     DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX
    IF( DBLE( X( IX ) )/=ZERO ) THEN
       TEMP1 = ABS( DBLE( X( IX ) ) )
       IF( SCALE < TEMP1 ) THEN
      SUMSQ = 1 + SUMSQ*( SCALE / TEMP1 )**2
      SCALE = TEMP1
       ELSE
      SUMSQ = SUMSQ + ( TEMP1 / SCALE )**2
       END IF
    END IF
    IF( AIMAG( X( IX ) )/=ZERO ) THEN
       TEMP1 = ABS( AIMAG( X( IX ) ) )
       IF( SCALE < TEMP1 ) THEN
      SUMSQ = 1 + SUMSQ*( SCALE / TEMP1 )**2
      SCALE = TEMP1
       ELSE
      SUMSQ = SUMSQ + ( TEMP1 / SCALE )**2
       END IF
    END IF
   10    CONTINUE
  END IF
!
  RETURN
!
!     End of ZLASSQ
!
  END

  SUBROUTINE ZLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )
!
!  -- LAPACK auxiliary routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    LDA, LDW, N, NB
!     ..
!     .. Array Arguments ..
  REAL   E( * )
  CPX     A( LDA, * ), TAU( * ), W( LDW, * )
!     ..
!
!  Purpose
!  =======
!
!  ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to
!  Hermitian tridiagonal form by a unitary similarity
!  transformation Q' * A * Q, and returns the matrices V and W which are
!  needed to apply the transformation to the unreduced part of A.
!
!  If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
!  matrix, of which the upper triangle is supplied;
!  if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
!  matrix, of which the lower triangle is supplied.
!
!  This is an auxiliary routine called by ZHETRD.
!
!  Arguments
!  =========
!
!  UPLO    (input) STR
!      Specifies whether the upper or lower triangular part of the
!      Hermitian matrix A is stored:
!      = 'U': Upper triangular
!      = 'L': Lower triangular
!
!  N   (input) INTEGER
!      The order of the matrix A.
!
!  NB  (input) INTEGER
!      The number of rows and columns to be reduced.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
!      n-by-n upper triangular part of A contains the upper
!      triangular part of the matrix A, and the strictly lower
!      triangular part of A is not referenced.  If UPLO = 'L', the
!      leading n-by-n lower triangular part of A contains the lower
!      triangular part of the matrix A, and the strictly upper
!      triangular part of A is not referenced.
!      On exit:
!      if UPLO = 'U', the last NB columns have been reduced to
!    tridiagonal form, with the diagonal elements overwriting
!    the diagonal elements of A; the elements above the diagonal
!    with the array TAU, represent the unitary matrix Q as a
!    product of elementary reflectors;
!      if UPLO = 'L', the first NB columns have been reduced to
!    tridiagonal form, with the diagonal elements overwriting
!    the diagonal elements of A; the elements below the diagonal
!    with the array TAU, represent the  unitary matrix Q as a
!    product of elementary reflectors.
!      See Further Details.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A.  LDA >= max(1,N).
!
!  E   (output) REAL array, dimension (N-1)
!      If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
!      elements of the last NB columns of the reduced matrix;
!      if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
!      the first NB columns of the reduced matrix.
!
!  TAU     (output) CPX array, dimension (N-1)
!      The scalar factors of the elementary reflectors, stored in
!      TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
!      See Further Details.
!
!  W   (output) CPX array, dimension (LDW,NB)
!      The n-by-nb matrix W required to update the unreduced part
!      of A.
!
!  LDW     (input) INTEGER
!      The leading dimension of the array W. LDW >= max(1,N).
!
!  Further Details
!  ===============
!
!  If UPLO = 'U', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(n) H(n-1) . . . H(n-nb+1).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
!  and tau in TAU(i-1).
!
!  If UPLO = 'L', the matrix Q is represented as a product of elementary
!  reflectors
!
!     Q = H(1) H(2) . . . H(nb).
!
!  Each H(i) has the form
!
!     H(i) = I - tau * v * v'
!
!  where tau is a complex scalar, and v is a complex vector with
!  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
!  and tau in TAU(i).
!
!  The elements of the vectors v together form the n-by-nb matrix V
!  which is needed, with W, to apply the transformation to the unreduced
!  part of the matrix, using a Hermitian rank-2k update of the form:
!  A := A - V*W' - W*V'.
!
!  The contents of A on exit are illustrated by the following examples
!  with n = 5 and nb = 2:
!
!  if UPLO = 'U':           if UPLO = 'L':
!
!    (  a   a   a   v4  v5 )      (  d      )
!    (  a   a   v4  v5 )      (  1   d      )
!    (      a   1   v5 )      (  v1  1   a      )
!    (      d   1  )      (  v1  v2  a   a  )
!    (      d  )      (  v1  v2  a   a   a  )
!
!  where d denotes a diagonal element of the reduced matrix, a denotes
!  an element of the original matrix that is unchanged, and vi denotes
!  an element of the vector defining H(i).
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, IW
  CPX     ALPHA
!     ..
!     .. External Subroutines ..
  EXTERNAL       ZAXPY, ZGEMV, ZHEMV, ZLACGV, ZLARFG, ZSCAL
!     ..
!     .. External Functions ..
  CPX     ZDOTC
  EXTERNAL       ZDOTC
!     ..
!     .. Executable Statements ..
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
  IF(  scan( UPLO, 'Uu' )>0 ) THEN
!
!    Reduce last NB columns of upper triangle
!
     DO 10 I = N, N - NB + 1, -1
    IW = I - N + NB
    IF( I < N ) THEN
!
!      Update A(1:i,i)
!
       A( I, I ) = DBLE( A( I, I ) )
       CALL ZLACGV( N-I, W( I, IW+1 ), LDW )
       CALL ZGEMV( 'No transpose', I, N-I, -ONE, A( 1, I+1 ), &
           LDA, W( I, IW+1 ), LDW, ONE, A( 1, I ), 1 )
       CALL ZLACGV( N-I, W( I, IW+1 ), LDW )
       CALL ZLACGV( N-I, A( I, I+1 ), LDA )
       CALL ZGEMV( 'No transpose', I, N-I, -ONE, W( 1, IW+1 ), &
           LDW, A( I, I+1 ), LDA, ONE, A( 1, I ), 1 )
       CALL ZLACGV( N-I, A( I, I+1 ), LDA )
       A( I, I ) = DBLE( A( I, I ) )
    END IF
    IF( I > 1 ) THEN
!
!      Generate elementary reflector H(i) to annihilate
!      A(1:i-2,i)
!
       ALPHA = A( I-1, I )
       CALL ZLARFG( I-1, ALPHA, A( 1, I ), 1, TAU( I-1 ) )
       E( I-1 ) = ALPHA
       A( I-1, I ) = ONE
!
!      Compute W(1:i-1,i)
!
       CALL ZHEMV( 'Upper', I-1, ONE, A, LDA, A( 1, I ), 1, &
           ZERO, W( 1, IW ), 1 )
       IF( I < N ) THEN
      CALL ZGEMV( 'Conjugate transpose', I-1, N-I, ONE, &
          W( 1, IW+1 ), LDW, A( 1, I ), 1, ZERO, &
          W( I+1, IW ), 1 )
      CALL ZGEMV( 'No transpose', I-1, N-I, -ONE, &
          A( 1, I+1 ), LDA, W( I+1, IW ), 1, ONE, &
          W( 1, IW ), 1 )
      CALL ZGEMV( 'Conjugate transpose', I-1, N-I, ONE, &
          A( 1, I+1 ), LDA, A( 1, I ), 1, ZERO, &
          W( I+1, IW ), 1 )
      CALL ZGEMV( 'No transpose', I-1, N-I, -ONE, &
          W( 1, IW+1 ), LDW, W( I+1, IW ), 1, ONE, &
          W( 1, IW ), 1 )
       END IF
       CALL ZSCAL( I-1, TAU( I-1 ), W( 1, IW ), 1 )
       ALPHA = -HALF*TAU( I-1 )*ZDOTC( I-1, W( 1, IW ), 1, &
           A( 1, I ), 1 )
       CALL ZAXPY( I-1, ALPHA, A( 1, I ), 1, W( 1, IW ), 1 )
    END IF
!
   10    CONTINUE
  ELSE
!
!    Reduce first NB columns of lower triangle
!
     DO 20 I = 1, NB
!
!       Update A(i:n,i)
!
    A( I, I ) = DBLE( A( I, I ) )
    CALL ZLACGV( I-1, W( I, 1 ), LDW )
    CALL ZGEMV( 'No transpose', N-I+1, I-1, -ONE, A( I, 1 ), &
        LDA, W( I, 1 ), LDW, ONE, A( I, I ), 1 )
    CALL ZLACGV( I-1, W( I, 1 ), LDW )
    CALL ZLACGV( I-1, A( I, 1 ), LDA )
    CALL ZGEMV( 'No transpose', N-I+1, I-1, -ONE, W( I, 1 ), &
        LDW, A( I, 1 ), LDA, ONE, A( I, I ), 1 )
    CALL ZLACGV( I-1, A( I, 1 ), LDA )
    A( I, I ) = DBLE( A( I, I ) )
    IF( I < N ) THEN
!
!      Generate elementary reflector H(i) to annihilate
!      A(i+2:n,i)
!
       ALPHA = A( I+1, I )
       CALL ZLARFG( N-I, ALPHA, A( MIN( I+2, N ), I ), 1, TAU( I ) )
       E( I ) = ALPHA
       A( I+1, I ) = ONE
!
!      Compute W(i+1:n,i)
!
       CALL ZHEMV( 'Lower', N-I, ONE, A( I+1, I+1 ), LDA, &
           A( I+1, I ), 1, ZERO, W( I+1, I ), 1 )
       CALL ZGEMV( 'Conjugate transpose', N-I, I-1, ONE, &
           W( I+1, 1 ), LDW, A( I+1, I ), 1, ZERO, W( 1, I ), 1)
       CALL ZGEMV( 'No transpose', N-I, I-1, -ONE, A( I+1, 1 ), &
           LDA, W( 1, I ), 1, ONE, W( I+1, I ), 1 )
       CALL ZGEMV( 'Conjugate transpose', N-I, I-1, ONE, &
           A( I+1, 1 ), LDA, A( I+1, I ), 1, ZERO, W( 1, I ), 1)
       CALL ZGEMV( 'No transpose', N-I, I-1, -ONE, W( I+1, 1 ), &
           LDW, W( 1, I ), 1, ONE, W( I+1, I ), 1 )
       CALL ZSCAL( N-I, TAU( I ), W( I+1, I ), 1 )
       ALPHA = -HALF*TAU( I )*ZDOTC( N-I, W( I+1, I ), 1, A(I+1, I), 1)
       CALL ZAXPY( N-I, ALPHA, A( I+1, I ), 1, W( I+1, I ), 1 )
    END IF
!
   20    CONTINUE
  END IF
!
  RETURN
!
!     End of ZLATRD
!
  END
  subroutine  zscal(n,za,zx,incx)
!
!     scales a vector by a constant.
!     jack dongarra, 3/11/78.
!     modified 3/93 to return if incx  <=  0.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  CPX za,zx(*)
  INT i,incx,ix,n
!
  if ( n <= 0 .or. incx <= 0 ) return
  if (incx == 1)go to 20
!
!    code for increment not equal to 1
!
  ix = 1
  do 10 i = 1,n
    zx(ix) = za*zx(ix)
    ix = ix + incx
   10 continue
  return
!
!    code for increment equal to 1
!
   20 do 30 i = 1,n
    zx(i) = za*zx(i)
   30 continue
  return
  end

  SUBROUTINE ZSTEQR( COMPZ, N, D, E, Z, LDZ, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      COMPZ
  INTEGER    INFO, LDZ, N
!     ..
!     .. Array Arguments ..
  REAL   D( * ), E( * ), WORK( * )
  CPX     Z( LDZ, * )
!     ..
!
!  Purpose
!  =======
!
!  ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
!  symmetric tridiagonal matrix using the implicit QL or QR method.
!  The eigenvectors of a full or band complex Hermitian matrix can also
!  be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
!  matrix to tridiagonal form.
!
!  Arguments
!  =========
!
!  COMPZ   (input) STR(len=1)
!      = 'N':  Compute eigenvalues only.
!      = 'V':  Compute eigenvalues and eigenvectors of the original
!      Hermitian matrix.  On entry, Z must contain the
!      unitary matrix used to reduce the original matrix
!      to tridiagonal form.
!      = 'I':  Compute eigenvalues and eigenvectors of the
!      tridiagonal matrix.  Z is initialized to the identity
!      matrix.
!
!  N   (input) INTEGER
!      The order of the matrix.  N >= 0.
!
!  D   (input/output) REAL array, dimension (N)
!      On entry, the diagonal elements of the tridiagonal matrix.
!      On exit, if INFO = 0, the eigenvalues in ascending order.
!
!  E   (input/output) REAL array, dimension (N-1)
!      On entry, the (n-1) subdiagonal elements of the tridiagonal
!      matrix.
!      On exit, E has been destroyed.
!
!  Z   (input/output) CPX array, dimension (LDZ, N)
!      On entry, if  COMPZ = 'V', then Z contains the unitary
!      matrix used in the reduction to tridiagonal form.
!      On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
!      orthonormal eigenvectors of the original Hermitian matrix,
!      and if COMPZ = 'I', Z contains the orthonormal eigenvectors
!      of the symmetric tridiagonal matrix.
!      If COMPZ = 'N', then Z is not referenced.
!
!  LDZ     (input) INTEGER
!      The leading dimension of the array Z.  LDZ >= 1, and if
!      eigenvectors are desired, then  LDZ >= max(1,N).
!
!  WORK    (workspace) REAL array, dimension (max(1,2*N-2))
!      If COMPZ = 'N', then WORK is not referenced.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!      > 0:  the algorithm has failed to find all the eigenvalues in
!        a total of 30*N iterations; if INFO = i, then i
!        elements of E have not converged to zero; on exit, D
!        and E contain the elements of a symmetric tridiagonal
!        matrix which is unitarily similar to the original
!        matrix.
!
!  =====================================================================
!
!     .. Parameters ..
  INTEGER    MAXIT
  PARAMETER      ( MAXIT = 30 )
!     ..
!     .. Local Scalars ..
  INTEGER    I, ICOMPZ, II, ISCALE, J, JTOT, K, L, L1, LEND, &
         LENDM1, LENDP1, LENDSV, LM1, LSV, M, MM, MM1, &
         NM1, NMAXIT
  REAL   ANORM, B, C, EPS, EPS2, F, G, P, R, RT1, RT2, &
         S, SAFMAX, SAFMIN, SSFMAX, SSFMIN, TST
!     ..
!     .. External Functions ..
  REAL   DLANST, DLAPY2
  EXTERNAL       DLANST, DLAPY2
!     ..
!     .. External Subroutines ..
  EXTERNAL       DLAE2, DLAEV2, DLARTG, DLASCL, DLASRT, XERBLA, &
         ZLASET, ZLASR, ZSWAP
!     ..
!     .. Executable Statements ..
!
!     Test the input parameters.
!
  INFO = 0
!
  IF(  scan( COMPZ, 'Nn' )>0 ) THEN
     ICOMPZ = 0
  ELSE IF(  scan( COMPZ, 'Vv' )>0 ) THEN
     ICOMPZ = 1
  ELSE IF(  scan( COMPZ, 'Ii' )>0 ) THEN
     ICOMPZ = 2
  ELSE
     ICOMPZ = -1
  END IF
  IF( ICOMPZ < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( ( LDZ < 1 )  OR  ( ICOMPZ > 0  AND  LDZ < MAX(1,N) ) ) THEN
     INFO = -6
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZSTEQR', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
  IF( N == 1 ) THEN
     IF( ICOMPZ == 2 ) Z( 1, 1 ) = ONE
     RETURN
  END IF
!
!     Determine the unit roundoff and over/underflow thresholds.
!
  EPS = epsilon(ZERO)/radix(ZERO)
  EPS2 = EPS**2
  SAFMIN = tiny(ZERO)
  SAFMAX = ONE / SAFMIN
  SSFMAX = SQRT( SAFMAX ) / THREE
  SSFMIN = SQRT( SAFMIN ) / EPS2
!
!     Compute the eigenvalues and eigenvectors of the tridiagonal
!     matrix.
!
  IF( ICOMPZ == 2 ) CALL ZLASET( 'Full', N, N, ZERO, ONE, Z, LDZ )
!
  NMAXIT = N*MAXIT
  JTOT = 0
!
!     Determine where the matrix splits and choose QL or QR iteration
!     for each block, according to whether top or bottom diagonal
!     element is smaller.
!
  L1 = 1
  NM1 = N - 1
!
   10 CONTINUE
  IF( L1 > N ) GO TO 160
  IF( L1 > 1 ) E( L1-1 ) = ZERO
  IF( L1 <= NM1 ) THEN
     DO 20 M = L1, NM1
    TST = ABS( E( M ) )
    IF( TST == ZERO ) GO TO 30
    IF( TST <= ( SQRT( ABS( D( M ) ) )*SQRT( ABS( D( M+ &
        1 ) ) ) )*EPS ) THEN
       E( M ) = ZERO
       GO TO 30
    END IF
   20    CONTINUE
  END IF
  M = N
!
   30 CONTINUE
  L = L1
  LSV = L
  LEND = M
  LENDSV = LEND
  L1 = M + 1
  IF( LEND == L ) GO TO 10
!
!     Scale submatrix in rows and columns L to LEND
!
  ANORM = DLANST( 'I', LEND-L+1, D( L ), E( L ) )
  ISCALE = 0
  IF( ANORM == ZERO ) GO TO 10
  IF( ANORM > SSFMAX ) THEN
     ISCALE = 1
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N, INFO )
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N, INFO )
  ELSE IF( ANORM < SSFMIN ) THEN
     ISCALE = 2
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N, INFO )
     CALL DLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N, INFO )
  END IF
!
!     Choose between QL and QR iteration
!
  IF( ABS( D( LEND ) ) < ABS( D( L ) ) ) THEN
     LEND = LSV
     L = LENDSV
  END IF
!
  IF( LEND > L ) THEN
!
!    QL Iteration
!
!    Look for small subdiagonal element.
!
   40    CONTINUE
     IF( L/=LEND ) THEN
    LENDM1 = LEND - 1
    DO 50 M = L, LENDM1
       TST = ABS( E( M ) )**2
       IF( TST <= ( EPS2*ABS( D(M) ) )*ABS( D(M+1) )+ SAFMIN )GO TO 60
   50   CONTINUE
     END IF
!
     M = LEND
!
   60    CONTINUE
     IF( M < LEND ) E( M ) = ZERO
     P = D( L )
     IF( M == L ) GO TO 80
!
!    If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
!    to compute its eigensystem.
!
     IF( M == L+1 ) THEN
    IF( ICOMPZ > 0 ) THEN
       CALL DLAEV2( D( L ), E( L ), D( L+1 ), RT1, RT2, C, S )
       WORK( L ) = C
       WORK( N-1+L ) = S
       CALL ZLASR( 'R', 'V', 'B', N, 2, WORK( L ), &
           WORK( N-1+L ), Z( 1, L ), LDZ )
    ELSE
       CALL DLAE2( D( L ), E( L ), D( L+1 ), RT1, RT2 )
    END IF
    D( L ) = RT1
    D( L+1 ) = RT2
    E( L ) = ZERO
    L = L + 2
    IF( L <= LEND ) GO TO 40
    GO TO 140
     END IF
!
     IF( JTOT == NMAXIT ) GO TO 140
     JTOT = JTOT + 1
!
!    Form shift.
!
     G = ( D( L+1 )-P ) / ( TWO*E( L ) )
     R = DLAPY2( G, ONE )
     G = D( M ) - P + ( E( L ) / ( G+SIGN( R, G ) ) )
!
     S = ONE
     C = ONE
     P = ZERO
!
!    Inner loop
!
     MM1 = M - 1
     DO 70 I = MM1, L, -1
    F = S*E( I )
    B = C*E( I )
    CALL DLARTG( G, F, C, S, R )
    IF( I/=M-1 ) E( I+1 ) = R
    G = D( I+1 ) - P
    R = ( D( I )-G )*S + TWO*C*B
    P = S*R
    D( I+1 ) = G + P
    G = C*R - B
!
!       If eigenvectors are desired, then save rotations.
!
    IF( ICOMPZ > 0 ) THEN
       WORK( I ) = C
       WORK( N-1+I ) = -S
    END IF
!
   70    CONTINUE
!
!    If eigenvectors are desired, then apply saved rotations.
!
     IF( ICOMPZ > 0 ) THEN
    MM = M - L + 1
    CALL ZLASR( 'R', 'V', 'B', N, MM, WORK( L ), WORK( N-1+L ), &
        Z( 1, L ), LDZ )
     END IF
!
     D( L ) = D( L ) - P
     E( L ) = G
     GO TO 40
!
!    Eigenvalue found.
!
   80    CONTINUE
     D( L ) = P
!
     L = L + 1
     IF( L <= LEND ) GO TO 40
     GO TO 140
!
  ELSE
!
!    QR Iteration
!
!    Look for small superdiagonal element.
!
   90    CONTINUE
     IF( L/=LEND ) THEN
    LENDP1 = LEND + 1
    DO 100 M = L, LENDP1, -1
       TST = ABS( E( M-1 ) )**2
       IF( TST <= ( EPS2*ABS( D(M) ) )*ABS( D(M-1) )+ SAFMIN )GO TO 110
  100   CONTINUE
     END IF
!
     M = LEND
!
  110    CONTINUE
     IF( M > LEND ) E( M-1 ) = ZERO
     P = D( L )
     IF( M == L ) GO TO 130
!
!    If remaining matrix is 2-by-2, use DLAE2 or SLAEV2
!    to compute its eigensystem.
!
     IF( M == L-1 ) THEN
    IF( ICOMPZ > 0 ) THEN
       CALL DLAEV2( D( L-1 ), E( L-1 ), D( L ), RT1, RT2, C, S )
       WORK( M ) = C
       WORK( N-1+M ) = S
       CALL ZLASR( 'R', 'V', 'F', N, 2, WORK( M ), &
           WORK( N-1+M ), Z( 1, L-1 ), LDZ )
    ELSE
       CALL DLAE2( D( L-1 ), E( L-1 ), D( L ), RT1, RT2 )
    END IF
    D( L-1 ) = RT1
    D( L ) = RT2
    E( L-1 ) = ZERO
    L = L - 2
    IF( L.GE.LEND ) GO TO 90
    GO TO 140
     END IF
!
     IF( JTOT == NMAXIT ) GO TO 140
     JTOT = JTOT + 1
!
!    Form shift.
!
     G = ( D( L-1 )-P ) / ( TWO*E( L-1 ) )
     R = DLAPY2( G, ONE )
     G = D( M ) - P + ( E( L-1 ) / ( G+SIGN( R, G ) ) )
!
     S = ONE
     C = ONE
     P = ZERO
!
!    Inner loop
!
     LM1 = L - 1
     DO 120 I = M, LM1
    F = S*E( I )
    B = C*E( I )
    CALL DLARTG( G, F, C, S, R )
    IF( I/=M ) E( I-1 ) = R
    G = D( I ) - P
    R = ( D( I+1 )-G )*S + TWO*C*B
    P = S*R
    D( I ) = G + P
    G = C*R - B
!
!       If eigenvectors are desired, then save rotations.
!
    IF( ICOMPZ > 0 ) THEN
       WORK( I ) = C
       WORK( N-1+I ) = S
    END IF
!
  120    CONTINUE
!
!    If eigenvectors are desired, then apply saved rotations.
!
     IF( ICOMPZ > 0 ) THEN
    MM = L - M + 1
    CALL ZLASR('R', 'V', 'F', N, MM, WORK(M), WORK(N-1+M), Z(1,M), LDZ)
     END IF
!
     D( L ) = D( L ) - P
     E( LM1 ) = G
     GO TO 90
!
!    Eigenvalue found.
!
  130    CONTINUE
     D( L ) = P
!
     L = L - 1
     IF( L.GE.LEND ) GO TO 90
     GO TO 140
!
  END IF
!
!     Undo scaling if necessary
!
  140 CONTINUE
  IF( ISCALE == 1 ) THEN
     CALL DLASCL('G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1, D(LSV), N, INFO)
     CALL DLASCL('G', 0, 0, SSFMAX, ANORM, LENDSV-LSV, 1, E( LSV ), N, INFO)
  ELSE IF( ISCALE == 2 ) THEN
     CALL DLASCL('G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1, D(LSV), N, INFO)
     CALL DLASCL('G', 0, 0, SSFMIN, ANORM, LENDSV-LSV, 1, E(LSV), N, INFO)
  END IF
!
!     Check for no convergence to an eigenvalue after a total
!     of N*MAXIT iterations.
!
  IF( JTOT == NMAXIT ) THEN
     DO 150 I = 1, N - 1
    IF( E( I )/=ZERO ) INFO = INFO + 1
  150    CONTINUE
     RETURN
  END IF
  GO TO 10
!
!     Order eigenvalues and eigenvectors.
!
  160 CONTINUE
  IF( ICOMPZ == 0 ) THEN
!
!    Use Quick Sort
!
     CALL DLASRT( 'I', N, D, INFO )
!
  ELSE
!
!    Use Selection Sort to minimize swaps of eigenvectors
!
     DO 180 II = 2, N
    I = II - 1
    K = I
    P = D( I )
    DO 170 J = II, N
       IF( D( J ) < P ) THEN
      K = J
      P = D( J )
       END IF
  170   CONTINUE
    IF( K/=I ) THEN
       D( K ) = D( I )
       D( I ) = P
       CALL ZSWAP( N, Z( 1, I ), 1, Z( 1, K ), 1 )
    END IF
  180    CONTINUE
  END IF
  RETURN
!
!     End of ZSTEQR
!
  END
  subroutine  zswap (n,zx,incx,zy,incy)
!
!     interchanges two vectors.
!     jack dongarra, 3/11/78.
!     modified 12/3/93, array(1) declarations changed to array(*)
!
  CPX zx(*),zy(*),ztemp
  INT i,incx,incy,ix,iy,n
!
  if (n <= 0) return
  if (incx == 1 AND incy == 1)go to 20
!
!   code for unequal increments or equal increments not equal
!     to 1
!
  ix = 1
  iy = 1
  if (incx < 0)ix = (-n+1)*incx + 1
  if (incy < 0)iy = (-n+1)*incy + 1
  do 10 i = 1,n
    ztemp = zx(ix)
    zx(ix) = zy(iy)
    zy(iy) = ztemp
    ix = ix + incx
    iy = iy + incy
   10 continue
  return
!
!   code for both increments equal to 1
   20 do 30 i = 1,n
    ztemp = zx(i)
    zx(i) = zy(i)
    zy(i) = ztemp
   30 continue
  return
  end

  SUBROUTINE ZUNG2L( M, N, K, A, LDA, TAU, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, M, N
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZUNG2L generates an m by n complex matrix Q with orthonormal columns,
!  which is defined as the last n columns of a product of k elementary
!  reflectors of order m
!
!    Q  =  H(k) . . . H(2) H(1)
!
!  as returned by ZGEQLF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the (n-k+i)-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by ZGEQLF in the last k columns of its array
!      argument A.
!      On exit, the m-by-n matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) CPX array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by ZGEQLF.
!
!  WORK    (workspace) CPX array, dimension (N)
!
!  INFO    (output) INTEGER
!      = 0: successful exit
!      < 0: if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, II, J, L
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZLARF, ZSCAL
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZUNG2L', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
!     Initialise columns 1:n-k to columns of the unit matrix
!
  DO 20 J = 1, N - K
     DO 10 L = 1, M
    A( L, J ) = ZERO
   10    CONTINUE
     A( M-N+J, J ) = ONE
   20 CONTINUE
!
  DO 40 I = 1, K
     II = N - K + I
!
!    Apply H(i) to A(1:m-k+i,1:n-k+i) from the left
!
     A( M-N+II, II ) = ONE
     CALL ZLARF( 'Left', M-N+II, II-1, A( 1, II ), 1, TAU(I), A, LDA, WORK)
     CALL ZSCAL( M-N+II-1, -TAU( I ), A( 1, II ), 1 )
     A( M-N+II, II ) = ONE - TAU( I )
!
!    Set A(m-k+i+1:m,n-k+i) to zero
!
     DO 30 L = M - N + II + 1, M
    A( L, II ) = ZERO
   30    CONTINUE
   40 CONTINUE
  RETURN
!
!     End of ZUNG2L
!
  END

  SUBROUTINE ZUNG2R( M, N, K, A, LDA, TAU, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, M, N
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZUNG2R generates an m by n complex matrix Q with orthonormal columns,
!  which is defined as the first n columns of a product of k elementary
!  reflectors of order m
!
!    Q  =  H(1) H(2) . . . H(k)
!
!  as returned by ZGEQRF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the i-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by ZGEQRF in the first k columns of its array
!      argument A.
!      On exit, the m by n matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) CPX array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by ZGEQRF.
!
!  WORK    (workspace) CPX array, dimension (N)
!
!  INFO    (output) INTEGER
!      = 0: successful exit
!      < 0: if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  INTEGER    I, J, L
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZLARF, ZSCAL
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZUNG2R', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) RETURN
!
!     Initialise columns k+1:n to columns of the unit matrix
!
  DO 20 J = K + 1, N
     DO 10 L = 1, M
    A( L, J ) = ZERO
   10    CONTINUE
     A( J, J ) = ONE
   20 CONTINUE
!
  DO 40 I = K, 1, -1
!
!    Apply H(i) to A(i:m,i:n) from the left
!
     IF( I < N ) THEN
    A( I, I ) = ONE
    CALL ZLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAU( I ), &
        A( I, I+1 ), LDA, WORK )
     END IF
     IF( I < M ) CALL ZSCAL( M-I, -TAU( I ), A( I+1, I ), 1 )
     A( I, I ) = ONE - TAU( I )
!
!    Set A(1:i-1,i) to zero
!
     DO 30 L = 1, I - 1
    A( L, I ) = ZERO
   30    CONTINUE
   40 CONTINUE
  RETURN
!
!     End of ZUNG2R
!
  END

  SUBROUTINE ZUNGQL( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, LWORK, M, N
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
!  which is defined as the last N columns of a product of K elementary
!  reflectors of order M
!
!    Q  =  H(k) . . . H(2) H(1)
!
!  as returned by ZGEQLF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the (n-k+i)-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by ZGEQLF in the last k columns of its array
!      argument A.
!      On exit, the M-by-N matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) CPX array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by ZGEQLF.
!
!  WORK    (workspace/output) CPX array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK. LWORK >= max(1,N).
!      For optimum performance LWORK >= N*NB, where NB is the
!      optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY
  INTEGER    I, IB, IINFO, IWS, J, KK, L, LDWORK, LWKOPT, &
         NB, NBMIN, NX
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZLARFB, ZLARFT, ZUNG2L
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  NB = ILAENV( 1, 'ZUNGQL', ' ', M, N, K, -1 )
  LWKOPT = MAX( 1, N )*NB
  WORK( 1 ) = LWKOPT
  LQUERY = ( LWORK == -1 )
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  ELSE IF( LWORK < MAX( 1, N )  AND   NOT LQUERY ) THEN
     INFO = -8
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZUNGQL', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  NBMIN = 2
  NX = 0
  IWS = N
  IF( NB > 1  AND  NB < K ) THEN
!
!    Determine when to cross over from blocked to unblocked code.
!
     NX = MAX( 0, ILAENV( 3, 'ZUNGQL', ' ', M, N, K, -1 ) )
     IF( NX < K ) THEN
!
!       Determine if workspace is large enough for blocked code.
!
    LDWORK = N
    IWS = LDWORK*NB
    IF( LWORK < IWS ) THEN
!
!      Not enough workspace to use optimal NB:  reduce NB and
!      determine the minimum value of NB.
!
       NB = LWORK / LDWORK
       NBMIN = MAX( 2, ILAENV( 2, 'ZUNGQL', ' ', M, N, K, -1 ) )
    END IF
     END IF
  END IF
!
  IF( NB.GE.NBMIN  AND  NB < K  AND  NX < K ) THEN
!
!    Use blocked code after the first block.
!    The last kk columns are handled by the block method.
!
     KK = MIN( K, ( ( K-NX+NB-1 ) / NB )*NB )
!
!    Set A(m-kk+1:m,1:n-kk) to zero.
!
     DO 20 J = 1, N - KK
    DO 10 I = M - KK + 1, M
       A( I, J ) = ZERO
   10   CONTINUE
   20    CONTINUE
  ELSE
     KK = 0
  END IF
!
!     Use unblocked code for the first or only block.
!
  CALL ZUNG2L( M-KK, N-KK, K-KK, A, LDA, TAU, WORK, IINFO )
!
  IF( KK > 0 ) THEN
!
!    Use blocked code
!
     DO 50 I = K - KK + 1, K, NB
    IB = MIN( NB, K-I+1 )
    IF( N-K+I > 1 ) THEN
!
!      Form the triangular factor of the block reflector
!      H = H(i+ib-1) . . . H(i+1) H(i)
!
       CALL ZLARFT( 'Backward', 'Columnwise', M-K+I+IB-1, IB, &
            A( 1, N-K+I ), LDA, TAU( I ), WORK, LDWORK )
!
!      Apply H to A(1:m-k+i+ib-1,1:n-k+i-1) from the left
!
       CALL ZLARFB( 'Left', 'No transpose', 'Backward', &
            'Columnwise', M-K+I+IB-1, N-K+I-1, IB, &
            A( 1, N-K+I ), LDA, WORK, LDWORK, A, LDA, &
            WORK( IB+1 ), LDWORK )
    END IF
!
!       Apply H to rows 1:m-k+i+ib-1 of current block
!
    CALL ZUNG2L( M-K+I+IB-1, IB, IB, A( 1, N-K+I ), LDA, &
         TAU( I ), WORK, IINFO )
!
!       Set rows m-k+i+ib:m of current block to zero
!
    DO 40 J = N - K + I, N - K + I + IB - 1
       DO 30 L = M - K + I + IB, M
      A( L, J ) = ZERO
   30      CONTINUE
   40   CONTINUE
   50    CONTINUE
  END IF
!
  WORK( 1 ) = IWS
  RETURN
!
!     End of ZUNGQL
!
  END

  SUBROUTINE ZUNGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  INTEGER    INFO, K, LDA, LWORK, M, N
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
!  which is defined as the first N columns of a product of K elementary
!  reflectors of order M
!
!    Q  =  H(1) H(2) . . . H(k)
!
!  as returned by ZGEQRF.
!
!  Arguments
!  =========
!
!  M   (input) INTEGER
!      The number of rows of the matrix Q. M >= 0.
!
!  N   (input) INTEGER
!      The number of columns of the matrix Q. M >= N >= 0.
!
!  K   (input) INTEGER
!      The number of elementary reflectors whose product defines the
!      matrix Q. N >= K >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the i-th column must contain the vector which
!      defines the elementary reflector H(i), for i = 1,2,...,k, as
!      returned by ZGEQRF in the first k columns of its array
!      argument A.
!      On exit, the M-by-N matrix Q.
!
!  LDA     (input) INTEGER
!      The first dimension of the array A. LDA >= max(1,M).
!
!  TAU     (input) CPX array, dimension (K)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by ZGEQRF.
!
!  WORK    (workspace/output) CPX array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK. LWORK >= max(1,N).
!      For optimum performance LWORK >= N*NB, where NB is the
!      optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument has an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY
  INTEGER    I, IB, IINFO, IWS, J, KI, KK, L, LDWORK, &
         LWKOPT, NB, NBMIN, NX
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZLARFB, ZLARFT, ZUNG2R
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  NB = ILAENV( 1, 'ZUNGQR', ' ', M, N, K, -1 )
  LWKOPT = MAX( 1, N )*NB
  WORK( 1 ) = LWKOPT
  LQUERY = ( LWORK == -1 )
  IF( M < 0 ) THEN
     INFO = -1
  ELSE IF( N < 0  OR  N > M ) THEN
     INFO = -2
  ELSE IF( K < 0  OR  K > N ) THEN
     INFO = -3
  ELSE IF( LDA < MAX( 1, M ) ) THEN
     INFO = -5
  ELSE IF( LWORK < MAX( 1, N )  AND   NOT LQUERY ) THEN
     INFO = -8
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZUNGQR', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N <= 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  NBMIN = 2
  NX = 0
  IWS = N
  IF( NB > 1  AND  NB < K ) THEN
!
!    Determine when to cross over from blocked to unblocked code.
!
     NX = MAX( 0, ILAENV( 3, 'ZUNGQR', ' ', M, N, K, -1 ) )
     IF( NX < K ) THEN
!
!       Determine if workspace is large enough for blocked code.
!
    LDWORK = N
    IWS = LDWORK*NB
    IF( LWORK < IWS ) THEN
!
!      Not enough workspace to use optimal NB:  reduce NB and
!      determine the minimum value of NB.
!
       NB = LWORK / LDWORK
       NBMIN = MAX( 2, ILAENV( 2, 'ZUNGQR', ' ', M, N, K, -1 ) )
    END IF
     END IF
  END IF
!
  IF( NB.GE.NBMIN  AND  NB < K  AND  NX < K ) THEN
!
!    Use blocked code after the last block.
!    The first kk columns are handled by the block method.
!
     KI = ( ( K-NX-1 ) / NB )*NB
     KK = MIN( K, KI+NB )
!
!    Set A(1:kk,kk+1:n) to zero.
!
     DO 20 J = KK + 1, N
    DO 10 I = 1, KK
       A( I, J ) = ZERO
   10   CONTINUE
   20    CONTINUE
  ELSE
     KK = 0
  END IF
!
!     Use unblocked code for the last or only block.
!
  IF( KK < N ) CALL ZUNG2R( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA, &
          TAU( KK+1 ), WORK, IINFO )
!
  IF( KK > 0 ) THEN
!
!    Use blocked code
!
     DO 50 I = KI + 1, 1, -NB
    IB = MIN( NB, K-I+1 )
    IF( I+IB <= N ) THEN
!
!      Form the triangular factor of the block reflector
!      H = H(i) H(i+1) . . . H(i+ib-1)
!
       CALL ZLARFT( 'Forward', 'Columnwise', M-I+1, IB, &
            A( I, I ), LDA, TAU( I ), WORK, LDWORK )
!
!      Apply H to A(i:m,i+ib:n) from the left
!
       CALL ZLARFB( 'Left', 'No transpose', 'Forward', &
            'Columnwise', M-I+1, N-I-IB+1, IB, &
            A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ), &
            LDA, WORK( IB+1 ), LDWORK )
    END IF
!
!       Apply H to rows i:m of current block
!
    CALL ZUNG2R( M-I+1, IB, IB, A( I, I ), LDA, TAU( I ), WORK, IINFO )
!
!       Set rows 1:i-1 of current block to zero
!
    DO 40 J = I, I + IB - 1
       DO 30 L = 1, I - 1
      A( L, J ) = ZERO
   30      CONTINUE
   40   CONTINUE
   50    CONTINUE
  END IF
!
  WORK( 1 ) = IWS
  RETURN
!
!     End of ZUNGQR
!
  END

  SUBROUTINE ZUNGTR( UPLO, N, A, LDA, TAU, WORK, LWORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     June 30, 1999
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDA, LWORK, N
!     ..
!     .. Array Arguments ..
  CPX     A( LDA, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZUNGTR generates a complex unitary matrix Q which is defined as the
!  product of n-1 elementary reflectors of order N, as returned by
!  ZHETRD:
!
!  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
!
!  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      = 'U': Upper triangle of A contains elementary reflectors
!         from ZHETRD;
!      = 'L': Lower triangle of A contains elementary reflectors
!         from ZHETRD.
!
!  N   (input) INTEGER
!      The order of the matrix Q. N >= 0.
!
!  A   (input/output) CPX array, dimension (LDA,N)
!      On entry, the vectors which define the elementary reflectors,
!      as returned by ZHETRD.
!      On exit, the N-by-N unitary matrix Q.
!
!  LDA     (input) INTEGER
!      The leading dimension of the array A. LDA >= N.
!
!  TAU     (input) CPX array, dimension (N-1)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by ZHETRD.
!
!  WORK    (workspace/output) CPX array, dimension (LWORK)
!      On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
!
!  LWORK   (input) INTEGER
!      The dimension of the array WORK. LWORK >= N-1.
!      For optimum performance LWORK >= (N-1)*NB, where NB is
!      the optimal blocksize.
!
!      If LWORK = -1, then a workspace query is assumed; the routine
!      only calculates the optimal size of the WORK array, returns
!      this value as the first entry of the WORK array, and no error
!      message related to LWORK is issued by XERBLA.
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    LQUERY, UPPER
  INTEGER    I, IINFO, J, LWKOPT, NB
!     ..
!     .. External Functions ..
  INTEGER    ILAENV
  EXTERNAL       ILAENV
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZUNGQL, ZUNGQR
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  LQUERY = ( LWORK == -1 )
  UPPER =  scan( UPLO, 'Uu' )>0
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDA < MAX( 1, N ) ) THEN
     INFO = -4
  ELSE IF( LWORK < MAX( 1, N-1 )  AND   NOT LQUERY ) THEN
     INFO = -7
  END IF
!
  IF( INFO == 0 ) THEN
     IF( UPPER ) THEN
    NB = ILAENV( 1, 'ZUNGQL', ' ', N-1, N-1, N-1, -1 )
     ELSE
    NB = ILAENV( 1, 'ZUNGQR', ' ', N-1, N-1, N-1, -1 )
     END IF
     LWKOPT = MAX( 1, N-1 )*NB
     WORK( 1 ) = LWKOPT
  END IF
!
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZUNGTR', -INFO )
     RETURN
  ELSE IF( LQUERY ) THEN
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) THEN
     WORK( 1 ) = 1
     RETURN
  END IF
!
  IF( UPPER ) THEN
!
!    Q was determined by a call to ZHETRD with UPLO = 'U'
!
!    Shift the vectors which define the elementary reflectors one
!    column to the left, and set the last row and column of Q to
!    those of the unit matrix
!
     DO 20 J = 1, N - 1
    DO 10 I = 1, J - 1
       A( I, J ) = A( I, J+1 )
   10   CONTINUE
    A( N, J ) = ZERO
   20    CONTINUE
     DO 30 I = 1, N - 1
    A( I, N ) = ZERO
   30    CONTINUE
     A( N, N ) = ONE
!
!    Generate Q(1:n-1,1:n-1)
!
     CALL ZUNGQL( N-1, N-1, N-1, A, LDA, TAU, WORK, LWORK, IINFO )
!
  ELSE
!
!    Q was determined by a call to ZHETRD with UPLO = 'L'.
!
!    Shift the vectors which define the elementary reflectors one
!    column to the right, and set the first row and column of Q to
!    those of the unit matrix
!
     DO 50 J = N, 2, -1
    A( 1, J ) = ZERO
    DO 40 I = J + 1, N
       A( I, J ) = A( I, J-1 )
   40   CONTINUE
   50    CONTINUE
     A( 1, 1 ) = ONE
     DO 60 I = 2, N
    A( I, 1 ) = ZERO
   60    CONTINUE
     IF( N > 1 ) THEN
!
!       Generate Q(2:n,2:n)
!
    CALL ZUNGQR( N-1, N-1, N-1, A( 2, 2 ), LDA, TAU, WORK, LWORK, IINFO)
     END IF
  END IF
  WORK( 1 ) = LWKOPT
  RETURN
!
!     End of ZUNGTR
!
  END

  SUBROUTINE ZUPGTR( UPLO, N, AP, TAU, Q, LDQ, WORK, INFO )
!
!  -- LAPACK routine (version 3.0) --
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
!     Courant Institute, Argonne National Lab, and Rice University
!     September 30, 1994
!
!     .. Scalar Arguments ..
  CHR      UPLO
  INTEGER    INFO, LDQ, N
!     ..
!     .. Array Arguments ..
  CPX     AP( * ), Q( LDQ, * ), TAU( * ), WORK( * )
!     ..
!
!  Purpose
!  =======
!
!  ZUPGTR generates a complex unitary matrix Q which is defined as the
!  product of n-1 elementary reflectors H(i) of order n, as returned by
!  ZHPTRD using packed storage:
!
!  if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
!
!  if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
!
!  Arguments
!  =========
!
!  UPLO    (input) STR(len=1)
!      = 'U': Upper triangular packed storage used in previous
!         call to ZHPTRD;
!      = 'L': Lower triangular packed storage used in previous
!         call to ZHPTRD.
!
!  N   (input) INTEGER
!      The order of the matrix Q. N >= 0.
!
!  AP  (input) CPX array, dimension (N*(N+1)/2)
!      The vectors which define the elementary reflectors, as
!      returned by ZHPTRD.
!
!  TAU     (input) CPX array, dimension (N-1)
!      TAU(i) must contain the scalar factor of the elementary
!      reflector H(i), as returned by ZHPTRD.
!
!  Q   (output) CPX array, dimension (LDQ,N)
!      The N-by-N unitary matrix Q.
!
!  LDQ     (input) INTEGER
!      The leading dimension of the array Q. LDQ >= max(1,N).
!
!  WORK    (workspace) CPX array, dimension (N-1)
!
!  INFO    (output) INTEGER
!      = 0:  successful exit
!      < 0:  if INFO = -i, the i-th argument had an illegal value
!
!  =====================================================================
!
!     ..
!     .. Local Scalars ..
  LOGICAL    UPPER
  INTEGER    I, IINFO, IJ, J
!     ..
!     .. External Subroutines ..
  EXTERNAL       XERBLA, ZUNG2L, ZUNG2R
!     ..
!     .. Executable Statements ..
!
!     Test the input arguments
!
  INFO = 0
  UPPER =  scan( UPLO, 'Uu' )>0
  IF(  NOT UPPER  AND   NOT  scan( UPLO, 'Ll' )>0 ) THEN
     INFO = -1
  ELSE IF( N < 0 ) THEN
     INFO = -2
  ELSE IF( LDQ < MAX( 1, N ) ) THEN
     INFO = -6
  END IF
  IF( INFO/=0 ) THEN
     CALL XERBLA( 'ZUPGTR', -INFO )
     RETURN
  END IF
!
!     Quick return if possible
!
  IF( N == 0 ) RETURN
!
  IF( UPPER ) THEN
!
!    Q was determined by a call to ZHPTRD with UPLO = 'U'
!
!    Unpack the vectors which define the elementary reflectors and
!    set the last row and column of Q equal to those of the unit
!    matrix
!
     IJ = 2
     DO 20 J = 1, N - 1
    DO 10 I = 1, J - 1
       Q( I, J ) = AP( IJ )
       IJ = IJ + 1
   10   CONTINUE
    IJ = IJ + 2
    Q( N, J ) = ZERO
   20    CONTINUE
     DO 30 I = 1, N - 1
    Q( I, N ) = ZERO
   30    CONTINUE
     Q( N, N ) = ONE
!
!    Generate Q(1:n-1,1:n-1)
!
     CALL ZUNG2L( N-1, N-1, N-1, Q, LDQ, TAU, WORK, IINFO )
!
  ELSE
!
!    Q was determined by a call to ZHPTRD with UPLO = 'L'.
!
!    Unpack the vectors which define the elementary reflectors and
!    set the first row and column of Q equal to those of the unit
!    matrix
!
     Q( 1, 1 ) = ONE
     DO 40 I = 2, N
    Q( I, 1 ) = ZERO
   40    CONTINUE
     IJ = 3
     DO 60 J = 2, N
    Q( 1, J ) = ZERO
    DO 50 I = J + 1, N
       Q( I, J ) = AP( IJ )
       IJ = IJ + 1
   50   CONTINUE
    IJ = IJ + 2
   60    CONTINUE
     IF( N > 1 ) THEN
!
!       Generate Q(2:n,2:n)
!
    CALL ZUNG2R( N-1, N-1, N-1, Q( 2, 2 ), LDQ, TAU, WORK, IINFO )
     END IF
  END IF
  RETURN
!
!     End of ZUPGTR
!
  END
