%  __________________________________________________________________
% |                                                                  |
% |                                                                  |
% |                           chemfig v1.2d                          |
% |                                                                  |
% |                          1 december 2015                         |
% |                                                                  |
% |__________________________________________________________________|
%
% This is chemfig.tex, the code of the "chemfig" package.
%
% Maintainer : Christian Tellechea
% E-mail     : unbonpetit@openmailbox.org
%              Comments, bug reports and suggestions are welcome.
% Licence    : Released under the LaTeX Project Public License v1.3c
%              or later, see http://www.latex-project.org/lppl.txt
% Package URL: http://ctan.org/pkg/chemfig
% Copyright  : Christian Tellechea 2010-2015
%
% The "chemfig" package consists of the 8 following files:
%    - chemfig.tex (this file)
%    - chemfig.sty (the package file for LaTeX)
%    - t-chemfig.tex (the package file for conTeXt)
%    - README
%    - chemfig_doc_en.tex, chemfig_doc_en.pdf (english manual)
%    - chemfig_doc_fr.tex, chemfig_doc_fr.pdf (manual in french)
%
% --------------------------------------------------------------------
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%
% %     http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% --------------------------------------------------------------------
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Christian Tellechea
% --------------------------------------------------------------------

\def\usechemfigcatcode{%
	\begingroup
		\def\X##1{\catcode\number`##1=\number\catcode`##1\relax}
		\xdef\chemfigrestorecatcode{%
			\X\[\X\]\X\:\X\(\X\)\X\,\X\-\X\=\X\~\X\!\X\?\X\<\X\>\X\;\X\*\X\|\X\@\X\
			\let\noexpand\chemfigrestorecatcode\relax
		}%
	\endgroup
	\catcode`\[12 \catcode`\]12 \catcode`\:12 \catcode`\(12
	\catcode`\)12 \catcode`\,12 \catcode`\-12 \catcode`\=12
	\catcode`\~12 \catcode`\!12 \catcode`\?12 \catcode`\<12
	\catcode`\>12 \catcode`\;12 \catcode`\*12 \catcode`\|12
	\catcode`\@11 \catcode`\#6  \catcode`\ 10
}

\usechemfigcatcode

\def\CF@def#1{%
	\ifdefined#1%
		\errmessage{Package \CF@package@name\space Error: the macro \string#1\space is already defined. Please, email the author.}%
	\fi
	\def#1%
}

\CF@def\CF@ver         {1.2d}
\CF@def\CF@date        {2015/12/01}
\CF@def\CF@fr@date     {1 d\'ecembre 2015}
\CF@def\CF@en@date     {1 december 2015}
\CF@def\CF@package@name{chemfig}

\CF@def\CF@error#1{\errmessage{Package \CF@package@name\space Error: #1.}}
\CF@def\CF@warning#1{\immediate\write\CF@unused{Package \CF@package@name\space Warning: #1^^J}}

% V\'erifie que eTeX est le moteur utilis\'e
\begingroup
	\edef\CF@ver{\meaning\eTeXversion}
	\edef\CF@date{\string\eTeXversion}
	\ifx\CF@ver\CF@date
		\endgroup
	\else
		\endgroup
		\errmessage{Package \CF@package@name\space Error: you are not using an eTeX engine, chemfig cannot work.}%
		\expandafter\endinput
	\fi

\expandafter\ifx\csname @latexerr\endcsname\relax% on n'utilise pas LaTeX ?
	\ifdefined\tikzpicture\else
		\def\CF@next@action{\input tikz.tex}%
		\expandafter\CF@next@action
	\fi
	\immediate\write\m@ne{Package: \CF@package@name\space\CF@date\space\space v\CF@ver\space\space Draw molecule with an easy syntax}%
	\long\def\@firstoftwo#1#2{#1}
	\long\def\@secondoftwo#1#2{#2}
	\long\def\@firstofone#1{#1}
	\long\def\@gobble#1{}
	\long\def\@gobbletwo#1#2{}
	\def\@car#1#2\@nil{#1}
	\def\@makeother#1{\catcode`#1=12\relax}
	\long\def\@ifnextchar#1#2#3{%
		\let\reserved@d=#1%
		\def\reserved@a{#2}%
		\def\reserved@b{#3}%
		\futurelet\@let@arg\@ifnch}
	\def\@ifnch{%
		\ifx\@let@arg\@sptoken
			\let\reserved@c\@xifnch
		\else
			\ifx\@let@arg\reserved@d
				\let\reserved@c\reserved@a
			\else
				\let\reserved@c\reserved@b
			\fi
		\fi
		\reserved@c}
	\def\:{\let\@sptoken= } \:
	\def\:{\@xifnch} \expandafter\def\: {\futurelet\@let@arg\@ifnch}
	\def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
	\long\def\@testopt#1#2{\@ifnextchar[{#1}{#1[{#2}]}}
	\def\@empty{}
	\def\space{ }
	\CF@def\printatom#1{\ifmmode\rm#1\else$\rm#1$\fi}% \printatom pour TeX et ConTeXt
	\def\CF@begin@tikzpicture{\tikzpicture}%
	\def\CF@end@tikzpicture{\endtikzpicture}%
\else% fin des d\'efinitions LaTeX
	\CF@def\printatom#1{\ensuremath{\mathrm{#1}}}% \printatom pour LaTeX.
	\def\CF@begin@tikzpicture{\begin{tikzpicture}}%
	\def\CF@end@tikzpicture{\end{tikzpicture}}%
\fi

\usetikzlibrary{arrows.meta}

\newcount\CF@cnt@atomingroup
\newcount\CF@cnt@groupnumber
\newcount\CF@cnt@atomnumber
\newcount\CF@cnt@cycle

\newif\ifCF@incycle
\newif\ifCF@cyclearc
\newif\ifCF@definesubmol
\newif\ifCF@name@dp@adjust
\newif\ifCF@macrofixedbondlength
\newif\ifCF@globalfixedbondlength

\newdimen\CF@dim

\newbox\CF@lewis@box
\newbox\CF@box@boxa
\newbox\CF@box@boxb
\newbox\CF@stuff@box

\def\enablefixedbondlength{\global\CF@globalfixedbondlengthtrue}
\def\disablefixedbondlength{\global\CF@globalfixedbondlengthfalse}
\disablefixedbondlength

\newwrite\CF@unused

\CF@def\CF@sanitize@catcode{%
	\@makeother\[\@makeother\]\@makeother\:\@makeother\(\@makeother\)%
	\@makeother\,\@makeother\-\@makeother\=\@makeother\~\@makeother\!%
	\@makeother\?\@makeother\<\@makeother\>\@makeother\;\@makeother\*%
	\@makeother\|\@makeother\#\@makeother\@%
}

\CF@def\CF@if@integer#1{%
	\begingroup
		\afterassignment\CF@after@integer
		\CF@cnt@cycle0#1\relax
}

\CF@def\CF@after@integer#1\relax{%
	\endgroup
	\CF@ifempty{#1}%
}

\CF@def\CF@ifx#1#2{\ifx#1#2\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi}

\CF@def\CF@ifempty#1{\ifx\@empty#1\@empty\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi}

\CF@def\CF@doifempty#1{\ifx\@empty#1\@empty\expandafter\@firstofone\else\expandafter\@gobble\fi}

\CF@def\CF@doifnotempty#1{\ifx\@empty#1\@empty\expandafter\@gobble\else\expandafter\@firstofone\fi}

\CF@def\CF@gobtonil#1\@nil{}

\edef\CF@hash{\string#}

\edef\CF@arobas{\string @}

\CF@def\CF@three@ea{\expandafter\expandafter\expandafter}

\CF@def\CF@exp@macroarg#1#2{\expandafter#1\expandafter{#2}}

\CF@def\CF@twoexp@macroarg#1#2{\expandafter\expandafter\expandafter#1\expandafter\expandafter\expandafter{#2}}

\CF@def\CF@exp@twomacroargs#1#2#3{\CF@exp@second{\CF@exp@macroarg#1{#2}}{#3}}

\CF@def\CF@exp@threemacroargs#1#2#3#4{\CF@exp@second{\CF@exp@twomacroargs#1{#2}{#3}}{#4}}

\CF@def\CF@swap@arg#1#2{#2{#1}}

\CF@def\CF@exp@second#1#2{\CF@exp@macroarg\CF@swap@arg{#2}{#1}}% \CF@exp@second<{arg1>}{<arg2>} donne "<arg1>{*<arg2>}"

\CF@def\CF@twoexp@second#1#2{\CF@twoexp@macroarg\CF@swap@arg{#2}{#1}}% \CF@twoexp@second{<arg1>}{<arg2>} donne "<arg1>{**<arg2>}"

\CF@def\CF@swap@unarg#1#2{#2#1}

\CF@def\CF@exp@after#1#2{\CF@exp@macroarg\CF@swap@unarg{#2}{#1}}% \CF@exp@after{<arg1>}{<arg2>} donne "<arg1>*<arg2>"

\CF@def\CF@twoexp@after#1#2{\CF@twoexp@macroarg\CF@swap@unarg{#2}{#1}}% \CF@twoexp@after{<arg1>}{<arg2>} donne "<arg1>**<arg2>"

\CF@def\CF@edef@second#1#2{%
	\edef\CF@tmp@str{#2}%
	\CF@exp@macroarg\CF@swap@unarg{\CF@tmp@str}{#1}%
}

\CF@def\CF@add@tocs#1#2{\CF@exp@second{\def#1}{#1#2}}

\CF@def\CF@expadd@tocs#1#2{\CF@exp@second{\CF@add@tocs#1}{#2}}

\CF@def\CF@edefadd@tocs#1#2{%
	\edef\CF@tmp@str{#2}%
	\CF@exp@second{\CF@add@tocs#1}{\CF@tmp@str}%
}

\CF@def\CF@if@firsttokmatch#1#2{% est ce que #1 et #2 commencent par les m\^emes tokens ?
	\futurelet\CF@toks@a\CF@gobtonil#1\relax\@nil
	\futurelet\CF@toks@b\CF@gobtonil#2\relax\@nil
	\CF@ifx\CF@toks@a\CF@toks@b
}

\CF@def\CF@if@firsttokin#1{% teste si le token qui commence #1 appartient aux tokens mis dans #2
	\futurelet\CF@toks@a\CF@gobtonil#1\relax\@nil
	\CF@if@firsttokin@a
}

\CF@def\CF@if@firsttokin@a#1{%
	\CF@ifempty{#1}
		\@secondoftwo
		{\futurelet\CF@toks@b\CF@gobtonil#1\relax\@nil
		\CF@ifx\CF@toks@a\CF@toks@b
			\@firstoftwo
			{\CF@exp@macroarg\CF@if@firsttokin@a{\@gobble#1}}%
		}%
}

\CF@def\CF@if@instr#1#2{%
	\def\CF@if@instr@a##1#2##2\@nil{\ifx\@empty##2\@empty\expandafter\@secondoftwo\else\expandafter\@firstoftwo\fi}%
	\CF@if@instr@a#1\@@nil#2\@nil
}

\CF@def\CF@after@space#1 #2\@nil{#2}

\CF@def\CF@node@content{\expandafter\printatom\expandafter{\csname atom@\number\CF@cnt@atomnumber\endcsname\CF@node@strut}}

\CF@def\chemskipalign{%
	\CF@doifempty\CF@bond@outcontentsaved% sauf si un \chemskipalign a \'et\'e fait \`a l'atome pr\'ec\'edent
		{\global\let\CF@bond@outcontentsaved\CF@bond@outcontent}% sauvegarder l'atome d'o\`u vient la liaison
	\let\CF@node@strut\@empty
}

\CF@def\CF@empty@node{{}}

\CF@def\CF@cycle@inraduiscoeff{0.75}% coeff multiplicateur du rayon des arcs dans les cycles

\CF@def\CF@donoclip#1;{}
\CF@def\setcrambond{%
	\@ifstar
		{\let\CF@clipcramornot\CF@donoclip\CF@setcrambond}
		{\def\CF@clipcramornot{\clip}\CF@setcrambond}%
}
\CF@def\CF@setcrambond#1#2#3{%
	\CF@ifempty{#1}{\def\CF@cram@basewidth{1.5ex}}{\def\CF@cram@basewidth{#1}}%
	\CF@ifempty{#2}{\def\CF@cram@dashlength{1pt}}{\def\CF@cram@dashlength{#2}}%
	\CF@ifempty{#3}{\def\CF@cram@dashsep{2pt}}{\def\CF@cram@dashsep{#3}}%
}
\setcrambond{}{}{}

\CF@def\setatomsep{\def\CF@atom@sep}% espacement des atomes li\'es
\setatomsep{}

\CF@def\setbondoffset{\def\CF@bond@offset}% offset des liaisons
\setbondoffset{2pt}

\CF@def\setdoublesep{\def\CF@double@sep}
\setdoublesep{2pt}

\CF@def\setangleincrement{\def\CF@angle@increment}
\setangleincrement{45}% valeur par d\'efaut

\CF@def\definesubmol{\CF@definesubmoltrue\CF@def@submol}
\CF@def\redefinesubmol{\CF@definesubmolfalse\CF@def@submol}

\CF@def\CF@def@submol#1{%
	\begingroup
		\def\CF@tmp@str{#1}%
		\catcode`[\@ne\catcode`]\tw@
		\futurelet\CF@toks@a\CF@test@nxttok
}

\CF@def\CF@test@nxttok{%
	\if[\noexpand\CF@toks@a\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
		{\CF@exp@macroarg\CF@grab@optalias{\CF@tmp@str}}%
		{\CF@exp@second{%
			\endgroup
			\begingroup
			\CF@sanitize@catcode
			\CF@def@submol@a
			}\CF@tmp@str{}%
		}%
}

\CF@def\CF@grab@optalias#1#2{%
	\endgroup
	\begingroup
	\everyeof{\@nil}\endlinechar\m@ne
	\CF@sanitize@catcode
	\expandafter\assign@tonil\expandafter\CF@tmp@str\scantokens{#2}%
	\CF@exp@second{%
		\CF@sanitize@catcode
		\CF@def@submol@a{#1}%
		}\CF@tmp@str
}

\CF@def\CF@def@submol@a#1#2#3{% #1 nom, #2 = code si liaison arrive de droite , #3 = code si liaison arrive de gauche
	\endgroup
	\ifcat\relax\expandafter\noexpand\@car#1\@nil% si #1 est une s\'equence de contr\^ole
		\expandafter\ifdefined\@car#1\@nil
			\ifCF@definesubmol
				\immediate\write\CF@unused{Package \CF@package@name\space Warning: the macro \expandafter\string\@car#1\@nil\space is already defined, the previous definition is lost on input line \the\inputlineno.}%
			\fi
		\fi
		\CF@ifempty{#2}%
			{\CF@exp@second{\expandafter\def\@car#1\@nil}{\expandafter\@empty\romannumeral-`\.\noexpand#3}}
			{\expandafter\def\@car#1\@nil{%
				\romannumeral-`\.%
				\ifdim\CF@current@angle pt>90pt
					\ifdim\CF@current@angle pt<270pt
						\expandafter\expandafter\expandafter\@firstoftwo
					\else
						\expandafter\expandafter\expandafter\@secondoftwo
					\fi
				\else
					\expandafter\@secondoftwo
				\fi
				{\noexpand#2}{\noexpand#3}}%
			}%
	\else
		\ifcsname CF@@#1\endcsname
			\ifCF@definesubmol
				\immediate\write\CF@unused{Package \CF@package@name\space Warning:the submol "#1" is already defined, the previous definition is lost on input line \the\inputlineno.}%
			\fi
		\fi
		\CF@ifempty{#2}%
			{\CF@exp@second{\expandafter\def\csname CF@@#1\endcsname}{\expandafter\@empty\romannumeral-`\.\noexpand#3}}
			{\expandafter\def\csname CF@@#1\endcsname{%
				\romannumeral-`\.%
				\ifdim\CF@current@angle pt>90pt
					\ifdim\CF@current@angle pt<270pt
						\expandafter\expandafter\expandafter\@firstoftwo
					\else
						\expandafter\expandafter\expandafter\@secondoftwo
					\fi
				\else
					\expandafter\@secondoftwo
				\fi
				{\noexpand#2}{\noexpand#3}}%
			}%
	\fi
}

\CF@def\CF@seek@node#1#2#3{% cherche un noeud au d\'ebut de #1 l'assigne dans la sc #2 et met le reste dans #3
	\let#2\@empty
	\def#3{#1}%
	\CF@if@firsttokmatch{#1}{ }%
		{\CF@exp@macroarg\CF@seek@node@a{\romannumeral-`\.\noexpand#1}#2#3}% ignore les espaces au d\'ebut du groupe d'atome
		{\CF@seek@node@a{#1}#2#3}%
}

\CF@def\CF@seek@node@a#1#2#3{%
	\CF@ifempty{#1}%
		{\let#3\@empty}
		{\futurelet\CF@toks@a\CF@gobtonil#1\relax\@nil
		\CF@ifx\CF@toks@a\@sptoken
			{\CF@add@tocs#2{ }%
			\CF@exp@macroarg\CF@seek@node@a{\CF@after@space#1\@nil}#2#3%
			}%
			{\CF@ifx\CF@toks@a\bgroup
				{\CF@expadd@tocs#2{\expandafter{\@car#1\@nil}}%
				\CF@exp@macroarg\CF@seek@node@a{\@gobble#1}#2#3%
				}%
				{\CF@if@firsttokin@a{-=(*<>!~}%
					{\def#3{#1}}%
					{\CF@expadd@tocs#2{\@car#1\@nil}%
					\CF@exp@macroarg\CF@seek@node@a{\@gobble#1}#2#3%
					}%
				}%
			}%
		}%
}

% on sait que #1 commence par -,=,~,<,>. On analyse cette liaison
% #2 reçoit le type de liaisons (1 pour -, 2 pour =, 3 pour ~)
\CF@def\CF@bond@findcode#1#2{%
	\futurelet\CF@toks@a\CF@gobtonil#1\@nil
	\edef#2{%
		\ifx-\CF@toks@a1\else
		\ifx=\CF@toks@a2\else
		\ifx~\CF@toks@a3\else
		\ifx>\CF@toks@a4\else
		\ifx<\CF@toks@a5\else0% si 0 --> il y a une erreur non due \`a l'utilisateur
		\fi\fi\fi\fi\fi}%
	\ifnum#2>\thr@@% si c'est une liaison de Cram
		\CF@exp@after{\futurelet\CF@toks@a\CF@gobtonil}{\@gobble#1\@nil}% chope le caract\`ere suivant
		\CF@ifx:\CF@toks@a
			{\edef#2{\number\numexpr#2+2}}% si c 'est un ":", signe du pointill\'e, ajoute 2
			{\ifx|\CF@toks@a
				\edef#2{\number\numexpr#2+4}% si c 'est un "|", signe du triangle \'evid\'e, ajouter 4
			\fi
			}%
	\fi
}

\CF@def\CF@analyse@bondoffset#1,#2\@nil{%
	\def\CF@start@offset{#1}\def\CF@end@offset{#2}%
}

\CF@def\CF@grab@bondoffset#1(#2)#3\@nil{%
	\CF@doifnotempty{#2}%
		{\CF@if@instr{#2},%
			{\CF@analyse@bondoffset#2\@nil}%
			{\def\CF@start@offset{#2}}%
		}%
	\def\CF@remain@afterbond{#3}%
}

\CF@def\CF@analyse@bond#1#2{%
	\CF@bond@findcode{#1}#2%
	\CF@exp@second{\def\CF@remain@afterbond}{\@gobble#1}%mange le premier signe de la liaison
	\let\CF@doublebond@type\z@
	\ifnum#2=\tw@% si c'est une double liaison, regarde s'il y a un + ou - derri\`ere
		\CF@exp@after{\futurelet\CF@toks@a\CF@gobtonil}{\@gobble#1\@nil}%
		\CF@ifx^\CF@toks@a
			{\let\CF@doublebond@type\@ne
			\CF@exp@second{\def\CF@remain@afterbond}{\@gobbletwo#1}% mange le "^"
			}
			{\ifx_\CF@toks@a
				\let\CF@doublebond@type\tw@
				\CF@exp@second{\def\CF@remain@afterbond}{\@gobbletwo#1}% mange le "_"
			\fi
			}%
	\else
		\ifnum#2>5 % si c'est une laision de Cram pointill\'ee ou triangle \'evid\'e
			\CF@exp@second{\def\CF@remain@afterbond}{\@gobbletwo#1}% mange un caract\`ere de plus
		\fi
	\fi
	\CF@exp@twomacroargs\CF@if@firsttokmatch\CF@remain@afterbond\CF@hash%
		{\expandafter\CF@grab@bondoffset\CF@remain@afterbond\@nil}%
		{}%
	\CF@exp@twomacroargs\CF@if@firsttokmatch\CF@remain@afterbond\CF@arobas
		{\expandafter\CF@grab@movearg\CF@remain@afterbond\@nil}%
		{}%
	\CF@exp@macroarg\CF@if@firsttokmatch{\CF@remain@afterbond}[%
		{\expandafter\CF@analyse@optarg\CF@remain@afterbond\@nil\CF@remain@afterbond}%
		{\let\CF@current@stringangle\CF@default@stringangle
		\let\CF@current@length\CF@default@length
		\let\CF@current@fromatom\CF@default@fromatom
		\let\CF@current@toatom\CF@default@toatom
		\let\CF@current@tikz\CF@default@tikz
		\let\CF@movebond@name\@empty
		}%
	\ifCF@incycle
		\pgfmathsetmacro\CF@cycle@increment@angle{360/\CF@cycle@num+\CF@initcycle@angle}%
		\edef\CF@current@stringangle{::+\CF@cycle@increment@angle}%
		\def\CF@initcycle@angle{0}%
		\let\CF@current@length\CF@default@length% et on ignore la longueur de liaison sp\'ecifi\'ee
	\fi
	\CF@exp@macroarg\CF@set@bondangle{\CF@current@stringangle}\CF@current@angle
}

\CF@def\CF@set@bondangle#1#2{% le code de la direction est contenu dans #1, en sortie, #2 contient l'angle
	\CF@ifempty{#1}%
		{\let#2\CF@default@angle}
		{\if:\expandafter\noexpand\@car#1\@nil
			\if:\CF@three@ea\noexpand\expandafter\@car\@gobble#1\@nil
				\pgfmathsetmacro#2{\CF@previous@angle+\expandafter\@gobble\@gobble#1}%
			\else
				\pgfmathsetmacro#2{\@gobble#1}%
			\fi
		\else
			\pgfmathsetmacro#2{#1*\CF@angle@increment}%
		\fi% puis normalise l'angle entre 0 et 360
		\ifdim\ifdim#2pt<\z@-\fi#2pt>360pt \pgfmathsetmacro#2{#2-360*floor(#2/360)}\fi% si |#2|>360
		\ifdim#2pt<\z@\pgfmathsetmacro#2{#2+360}\fi
		}%
}

\CF@def\CF@int@part#1.#2\@nil{#1 }

\CF@def\CF@analyse@movearg#1,#2\@nil#3{%
	\def#3{#1}\def\CF@movebond@coeff{#2}%
}

% Argument limit\'es l\'egitimes ici car #2 (qui est ce qui suit "@{<nom>}" dans l'argument optionnel) ne DOIT
% pas commencer par une accolade.
\expandafter\CF@def\expandafter\CF@grab@movearg\CF@arobas#1#2\@nil{%
	\CF@if@instr{#1},%
		{\CF@analyse@movearg#1\@nil\CF@movebond@name}%
		{\def\CF@movebond@name{#1}\def\CF@movebond@coeff{0.5}}%
	\def\CF@remain@optarg{#2}%
}

\CF@def\CF@testempty@andassign#1#2#3{\CF@ifempty{#2}{\let#1#3}{\def#1{#2}}}

\CF@def\CF@sanitize@lastitem#1,\@empty#2\@nil{#1}

\CF@def\CF@parse@optlist#1,#2,#3,#4,#5\@nil{%
	\CF@testempty@andassign\CF@current@stringangle{#1}\CF@default@stringangle
	\CF@testempty@andassign\CF@current@length{#2}\CF@default@length
	\CF@testempty@andassign\CF@current@fromatom{#3}\CF@default@fromatom
	\CF@testempty@andassign\CF@current@toatom{#4}\CF@default@toatom
	\expandafter\CF@testempty@andassign\expandafter\CF@current@tikz\expandafter{\CF@sanitize@lastitem#5,\@empty\@nil}\CF@default@tikz
}%

\CF@def\CF@analyse@optarg[#1]#2\@nil#3{%
	\CF@doifnotempty{#1}%
		{\CF@exp@after{\CF@if@firsttokmatch{#1}}{\CF@arobas}%
			{\CF@grab@movearg#1\@nil}%
			{\let\CF@movebond@name\@empty
			\def\CF@remain@optarg{#1}%
			}%
		\expandafter\CF@parse@optlist\CF@remain@optarg,\@empty,\@empty,\@empty,\@empty\@nil
		\def#3{#2}%
		}%
}

\CF@def\CF@seek@submol{%
	\CF@exp@second{\def\CF@remain@molecule}{\romannumeral-`\.\expandafter\noexpand\CF@remain@molecule}%
	\CF@exp@macroarg\CF@if@firsttokmatch{\CF@remain@molecule}!%
		{\CF@twoexp@second{\def\CF@remain@molecule}{\expandafter\@gobble\CF@remain@molecule}% enl\`eve le "!"
		\ifx\empty\CF@remain@molecule\errmessage{Package \CF@package@name\space Error: no submol name found after "!"}\fi
		\ifcat\relax\CF@three@ea\noexpand\expandafter\@car\CF@remain@molecule*\@nil
			\CF@twoexp@second{\CF@twoexp@second{\def\CF@insert@submol}}{\expandafter\@car\CF@remain@molecule\@nil}%
		\else
			\CF@exp@second{\CF@twoexp@second{\def\CF@insert@submol}}{\csname CF@@\expandafter\@car\CF@remain@molecule\@nil\endcsname}%
		\fi
		\CF@twoexp@second{\def\CF@remain@molecule}{\csname CF@insert@submol\CF@three@ea\endcsname\csname @gobble\expandafter\endcsname\CF@remain@molecule}%
		\CF@seek@submol
		}%
		{}%
}

\CF@def\CF@insert@emptygroup#1{% ins\`ere {} au d\'ebut de la sc #1
	\CF@exp@second{\def#1}{\expandafter{\expandafter}#1}%
}

\CF@def\chemfig{\@ifstar{\CF@macrofixedbondlengthtrue\CF@chemfig@a}{\CF@macrofixedbondlengthfalse\CF@chemfig@a}}

\CF@def\CF@chemfig@a{\ifCF@globalfixedbondlength\CF@macrofixedbondlengthtrue\fi\@testopt\CF@chemfig@b{}}

\CF@def\CF@chemfig@b[#1]{\@testopt{\CF@chemfig@c[#1]}{}}

\CF@def\CF@chemfig@c[#1][#2]{%
	\edef\CF@tmp@str{[remember picture,every node/.style={anchor=base,inner sep=\z@,outer sep=\z@,minimum size=\z@\ifx\@empty#2\@empty\else,#2\fi},baseline\ifx\@empty#1\@empty\else,#1\fi]}%
	\CF@exp@threemacroargs\CF@chemfig@d\CF@begin@tikzpicture\CF@tmp@str\CF@end@tikzpicture
}

\CF@def\CF@chemfig@d#1#2#3#4{%
	#1#2%
	\begingroup
		\let\CF@hook@list\@empty
		\CF@doifempty\CF@atom@sep{\def\CF@atom@sep{3em}}%
		\CF@doifempty\CF@cram@basewidth{\def\CF@cram@basewidth{1.5ex}}%
		\CF@incyclefalse
		\CF@cnt@groupnumber\z@
		\let\CF@last@action\z@% 0=d\'ebut du dessin 1=trac\'e d'un noeud 2=trac\'e d'une liaison
		\let\CF@start@offset\@empty
		\let\CF@end@offset\@empty
		\let\CF@bond@outcontentsaved\@empty
		\def\CF@cycle@anglecorrection{180/\CF@cycle@num}%
		\def\CF@default@angle{0}%
		\def\CF@default@stringangle{:0}% angle pris par d\'efaut si le champ est vide
		\def\CF@default@length{1}%
		\let\CF@default@fromatom\@empty% numero de l'atome d'o\`u partent les liaisons par d\'efaut
		\let\CF@default@toatom\@empty% num\'ero de l'atome o\`u arrivent les laisons par d\'efaut
		\let\CF@default@tikz\@empty
		\let\CF@previous@bondangle\empty
		\let\CF@joinbond\z@
		\let\CF@previous@tikz\empty
		\everyeof{\@nil}\endlinechar\m@ne
		\CF@sanitize@catcode
		\expandafter\assign@tonil\expandafter\CF@remain@molecule\scantokens{#4}%
		\CF@exp@macroarg\CF@chemfig@e{\CF@remain@molecule}%
	#3%
	\let\CF@split@state\z@
}

\CF@def\CF@chemfig@e#1{% #1 est le code de la mol\'ecule
	\ifnum\CF@last@action=\thr@@
		\ifCF@incycle
			\def\CF@default@angle{0}%
		\else
			\ifnum\CF@cnt@cycle=\z@% si c'est le d\'ebut d'un cycle
				\pgfmathsetmacro\CF@default@angle{\CF@previous@angle+180+\CF@cycle@anglecorrection}% on met la liaison \`a +180° + correction
			\else
				\pgfmathsetmacro\CF@default@angle{\CF@previous@angle-90+180/\CF@cycle@num}% sinon \`a la bissectrice du sommet du cycle
			\fi
		\fi
		\let\CF@default@stringangle\@empty
	\fi
	\let\CF@current@angle\CF@default@angle
	\def\CF@remain@molecule{#1}%
	\CF@seek@submol% alias en premier ?
	\if[\CF@three@ea\noexpand\expandafter\@car\CF@remain@molecule\@nil
		\expandafter\CF@analyse@optarg\CF@remain@molecule\@nil\CF@remain@molecule
		\CF@exp@macroarg\CF@set@bondangle{\CF@current@stringangle}\CF@current@angle
		\let\CF@default@angle\CF@current@angle
		\let\CF@previous@angle\CF@current@angle
		\CF@doifnotempty\CF@current@stringangle{\let\CF@default@angle\CF@current@angle}%
		\CF@doifnotempty\CF@current@length{\let\CF@default@length\CF@current@length}%
		\CF@doifnotempty\CF@current@fromatom{\let\CF@default@fromatom\CF@current@fromatom}%
		\CF@doifnotempty\CF@current@toatom{\let\CF@default@toatom\CF@current@toatom}%
		\CF@doifnotempty\CF@current@tikz{\let\CF@default@tikz\CF@current@tikz}%
		\CF@seek@submol
	\fi
	\edef\CF@default@stringangle{:\CF@default@angle}%
	\let\CF@current@length\CF@default@length
	\let\CF@current@fromatom\CF@default@fromatom
	\let\CF@current@toatom\CF@default@toatom
	\let\CF@current@tikz\CF@default@tikz
	\ifCF@incycle% si on commence un cycle
		\let\CF@current@angle\CF@previous@angle
		\ifCF@cyclearc% on doit tracer l'arc de cercle dans le cycle ?
			\pgfmathsetmacro\CF@cyclearc@radius{\CF@cycle@inraduiscoeff*\CF@current@length*\CF@atom@sep/(2*tan(180/\CF@cycle@num))}%
			\pgfmathsetmacro\CF@cyclearc@initangle{\CF@current@angle+\CF@initcycle@angle+180/\CF@cycle@num+90}
			\pgfmathparse{\CF@current@length*\CF@atom@sep/(2*sin(180/\CF@cycle@num))}%
			\node[at=(\CF@bond@outnode),shift=(\CF@cyclearc@initangle:\pgfmathresult pt)](arccenter){};% le centre de l'arc
			\node[at=(arccenter),shift=(\CF@cyclearc@startangle:\CF@cyclearc@radius pt)](initarc){};% le d\'ebut de l'arc
			\expandafter\draw\expandafter[\CF@cyclearc@directtikz](initarc) arc (\CF@cyclearc@startangle:\CF@cyclearc@endangle:\CF@cyclearc@radius pt);
		\fi
	\else
		\let\CF@current@angle\CF@default@angle
	\fi
	\ifnum\CF@last@action=\z@
		\let\CF@previous@angle\CF@default@angle
		\node(CF@node){};
		\CF@exp@macroarg\CF@if@firsttokin{\CF@remain@molecule}{-=(*~?<>}%
			{\CF@insert@emptygroup\CF@remain@molecule}%
			{}%
	\fi
	\CF@chemfig@f
}

\CF@def\CF@chemfig@f{%
	\let\CF@next@action\CF@chemfig@f% \`a priori, on reboucle
	\CF@ifx\CF@remain@molecule\@empty
		{\let\CF@next@action\endgroup}
		{\CF@seek@submol
		\CF@exp@macroarg\CF@seek@node{\CF@remain@molecule}\CF@current@atomgroup\CF@remain@molecule
		\CF@ifx\@empty\CF@current@atomgroup% pas de noeud pour commencer ?
			{\def\CF@bond@outnode{%
				n\CF@last@groupnumber-%
				\ifx\CF@current@fromatom\@empty
					 \ifdim\CF@current@angle pt<90pt \number\CF@cnt@atomingroup
					 \else\ifdim\CF@current@angle pt>270pt \number\CF@cnt@atomingroup\else1\fi
					 \fi
				 \else
					\CF@current@fromatom
				 \fi}%
			\CF@exp@after{\futurelet\CF@toks@a\CF@gobtonil}{\CF@remain@molecule\relax\@nil}%
			\CF@if@firsttokin@a{-=<>~}% la suite est une liaison
				{\ifnum\CF@last@action=\tw@% c'est la deuxi\`eme liaison cons\'ecutive ?
					\CF@insert@emptygroup\CF@remain@molecule% ins\`ere un groupe vide
					\edef\CF@bond@outnode{\CF@bond@outnode}%
				\else
					\ifCF@incycle\advance\CF@cnt@cycle\@ne\fi
					\CF@exp@macroarg\CF@analyse@bond{\CF@remain@molecule}\CF@bond@type
					\edef\CF@bond@outnode{\CF@bond@outnode}%
					\let\CF@remain@molecule\CF@remain@afterbond
					\ifCF@incycle
						\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
							\CF@three@ea\@firstoftwo
						\else
							\ifnum\CF@cnt@cycle=\@ne
								\let\CF@cycle@firsttikz\CF@current@tikz
								\CF@doifnotempty\CF@start@offset{\let\CF@cycle@joinlast\z@}%
							\fi
							\CF@three@ea\@secondoftwo
						\fi
					\else
						\expandafter\@secondoftwo
					\fi
						{\let\CF@next@action\endgroup
						\CF@draw@bond\CF@bond@type{\CF@bond@outnode}{\CF@hook@cycle}\CF@previous@atomgroup\CF@hook@atomgroup
						}%
						{\node[at=(\CF@bond@outnode\ifCF@incycle\else\ifCF@macrofixedbondlength.\CF@current@angle\fi\fi),shift=(\ifcase\CF@split@state\or180-\or-\fi\CF@current@angle:\CF@current@length*\CF@atom@sep)](CF@node){};
						\let\CF@previous@angle\CF@current@angle
						\let\CF@last@action\tw@
						}%
				\fi
				\ifcat\relax\detokenize\expandafter{\romannumeral-`\.\expandafter\noexpand\CF@remain@molecule}\relax
				% s'il ne reste plus rien apr\`es la liaison (sans tenir compte de l'espace devant)-> ins\`ere un groupe vide
					\CF@insert@emptygroup\CF@remain@molecule
				\fi
				}%
				{\edef\CF@bond@outnode{\CF@bond@outnode}% \'evalue le l'atome de d\'epart de liaison
				\CF@ifx(\CF@toks@a% une parenth\`ese pour commencer ?
					{\ifnum\CF@last@action=\tw@% il y avait une liaison juste avant ?
						\CF@insert@emptygroup\CF@remain@molecule
					\else
						\CF@exp@macroarg\CF@grab@submol{\CF@remain@molecule}%
						\begingroup
							\ifCF@incycle\let\CF@last@action\thr@@\fi% on \'etait dans un cycle
							\CF@incyclefalse
							\aftergroup\CF@chemfig@f
							\def\CF@next@action{\CF@exp@macroarg\CF@chemfig@e{\CF@sub@mol}}%
					\fi
					}%
					{\CF@ifx\CF@remain@molecule\@empty
						{\let\CF@next@action\endgroup}
						{% ce qui reste apr\`es le noeud courant n'est pas vide, ne commence pas par "-=~", ni par une parenth\`ese
						\CF@ifx*\CF@toks@a% un cycle ?
							{\ifnum\CF@last@action=\tw@
								\CF@insert@emptygroup\CF@remain@molecule% ins\`ere un groupe vide
							\else
								\ifCF@incycle\let\CF@last@action\thr@@\fi% on \'etait dans un cycle
								\ifnum\CF@last@action=\thr@@\let\CF@lastcycle@num\CF@cycle@num\fi
								\CF@twoexp@macroarg\CF@if@firsttokmatch{\expandafter\@gobble\CF@remain@molecule}*%
									{\CF@twoexp@second{\def\CF@remain@molecule}{\expandafter\@gobble\CF@remain@molecule}% enl\`eve la 1er \'etoile
									\CF@twoexp@macroarg\CF@if@firsttokmatch{\expandafter\@gobble\CF@remain@molecule}[% un crochet ensuite ?
										{\expandafter\CF@cycle@parsepreamblewithoptarg\CF@remain@molecule\@nil% \begingroup inclus
										}%
										{\def\CF@cyclearc@startangle{0}\def\CF@cyclearc@endangle{360}%
										\let\CF@cyclearc@directtikz\@empty
										\expandafter\CF@cycle@parsepreamble\CF@remain@molecule\@nil% \begingroup inclus
										}%
									\CF@cyclearctrue
									}%
									{\expandafter\CF@cycle@parsepreamble\CF@remain@molecule\@nil% \begingroup inclus
									\CF@cyclearcfalse
									}%
								\CF@cnt@cycle\z@
								\edef\CF@hook@cycle{\CF@bond@outnode}%
								\let\CF@hook@atomgroup\CF@previous@atomgroup
								\CF@ifx\CF@hook@atomgroup\CF@empty@node
									{\let\CF@cycle@joinlast\@ne}% joindre le dernier
									{\let\CF@cycle@joinlast\z@}
								\CF@incycletrue
								\ifnum\CF@last@action=\thr@@
									\pgfmathsetmacro\CF@initcycle@angle{360/\CF@lastcycle@num-180}% c'est un cycle dans un cycle
								\else
									\pgfmathsetmacro\CF@initcycle@angle{-180/\CF@cycle@num-90+\CF@cycle@anglecorrection}%
								\fi
								\aftergroup\CF@chemfig@f
								\def\CF@next@action{\CF@exp@macroarg\CF@chemfig@e{\CF@sub@mol}}%
							\fi
							}%
							{\errmessage{Package \CF@package@name\space Error: something went wrong here: \detokenize\expandafter{\CF@remain@molecule}^^JIf you think it's a bug, please, send a Minimal Example to the author.}%
							}%
						}%
					}%
				}%
			}%
			{\CF@exp@threemacroargs\CF@draw@atomgroup\CF@current@angle\CF@current@toatom\CF@current@atomgroup
			}%
		}%
	\CF@next@action
}

\CF@def\CF@cycle@parsepreamble*#1#2\@nil{%
	\ifnum#1<\thr@@
		\errmessage{Package \CF@package@name\space Error: A cycle must be at least a triangle.^^JThe number following "*" must be 3 or more}%
	\fi
	\def\CF@remain@molecule{#2}%
	\CF@exp@macroarg\CF@grab@submol{\CF@remain@molecule}%
	\begingroup
	\def\CF@cycle@num{#1}%
}

\CF@def\CF@cycle@parsepreamblewithoptarg*[#1]#2#3\@nil{%
	\CF@cycle@parseoptarg#1,\@empty,\@empty,\@empty\@nil
	\CF@cycle@parsepreamble*#2#3\@nil
}

\CF@def\CF@cycle@parseoptarg#1,#2,#3\@nil{%
	\CF@ifempty{#1}{\def\CF@cyclearc@startangle{0}}{\def\CF@cyclearc@startangle{#1}}%
	\CF@ifempty{#2}{\def\CF@cyclearc@endangle{360}}{\def\CF@cyclearc@endangle{#2}}%
	\CF@exp@second{\def\CF@cyclearc@directtikz}{\CF@sanitize@lastitem#3,\@empty\@nil}%
}

\CF@def\CF@grab@submol#1{%
	\begingroup
		\catcode`(\@ne\catcode`)\tw@
		\CF@three@ea
	\endgroup
	\expandafter\CF@grab@submol@a\scantokens{\relax#1}%
}

\CF@def\CF@grab@submol@a#1\@nil{%
	\expandafter\assign@tonil\expandafter\CF@remain@molecule\scantokens\CF@three@ea{\expandafter\@gobble\@gobble#1}%
	\expandafter\assign@tonil\expandafter\CF@sub@mol\scantokens\CF@three@ea{\expandafter\@car\@gobble#1\@nil}%
}

\CF@def\assign@tonil#1#2\@nil{\def#1{#2}}

\CF@def\CF@ifcar@isupperletter#1{%
	\ifcat\relax\noexpand#1%
		\let\CF@next\@secondoftwo% faux si c'est une sc
	\else
		\ifnum`#1<`A
			\let\CF@next\@secondoftwo
		\else
			\ifnum`#1>`Z
				\let\CF@next\@secondoftwo
			\else
				\let\CF@next\@firstoftwo
			\fi
		\fi
	\fi
	\CF@next
}

% Cr\'e\'e 4 noeuds au dessus et au dessous des noeuds #1 et #2
% \`a une distance de #3 du noeud #1 et #4 du noeud #2
\CF@def\CF@create@normnodes#1#2#3#4{%
	\CF@doifnotempty{#3}
		{\node[shape=coordinate,at=(#1),xshift=#3*\CF@norm@x,yshift=#3*\CF@norm@y](#11){};
		\node[shape=coordinate,at=(#1),xshift=-#3*\CF@norm@x,yshift=-#3*\CF@norm@y](#12){};
		}%
	\CF@doifnotempty{#4}
		{\node[shape=coordinate,at=(#2),xshift=#4*\CF@norm@x,yshift=#4*\CF@norm@y](#21){};
		\node[shape=coordinate,at=(#2),xshift=-#4*\CF@norm@x,yshift=-#4*\CF@norm@y](#22){};
		}%
}

\CF@def\CF@compute@nodevect#1#2{%
	\pgfextractx\CF@dim{\pgfpointanchor{#1}{center}}\edef\CF@dimax{\the\CF@dim}%
	\pgfextracty\CF@dim{\pgfpointanchor{#1}{center}}\edef\CF@dimay{\the\CF@dim}%
	\pgfextractx\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@dimbx{\the\CF@dim}%
	\pgfextracty\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@dimby{\the\CF@dim}%
	\pgfmathsetmacro\CF@len@vector{veclen(\CF@dimbx-\CF@dimax,\CF@dimby-\CF@dimay)}%
	\pgfmathsetmacro\CF@norm@x{(\CF@dimay-\CF@dimby)/\CF@len@vector}%
	\pgfmathsetmacro\CF@norm@y{(\CF@dimbx-\CF@dimax)/\CF@len@vector}%
}

\CF@def\CF@set@offset#1#2{%
	\CF@doifempty#1%
		{\edef#1{\ifx#2\CF@empty@node0pt\else\ifx#2\@empty0pt\else\CF@bond@offset\fi\fi}}%
}

\CF@def\CF@draw@bond#1#2#3#4#5{% #1=type de liaison #2 et #3:nom de noeuds de d\'ebut et fin #4 et #5: contenu des atomes de d\'ebut et fin
	\CF@set@offset\CF@start@offset#4%
	\CF@set@offset\CF@end@offset#5%
	\let\CF@current@bondstyle\CF@bond@style
	\CF@doifnotempty\CF@current@tikz{\CF@expadd@tocs\CF@current@bondstyle{\expandafter,\CF@current@tikz}}%
	\path(#2)--(#3)coordinate[pos=0](#2@)coordinate[pos=1](#3@);%
	\CF@compute@nodevect{#2@}{#3@}%
	\pgfmathsetmacro\CF@start@coeff{\CF@start@offset/\CF@len@vector}%
	\pgfmathsetmacro\CF@end@coeff{1-\CF@end@offset/\CF@len@vector}%
	\path(#2@)--(#3@)coordinate[pos=\CF@start@coeff](#2@@)coordinate[pos=\CF@end@coeff](#3@@);%
	\CF@doifnotempty\CF@movebond@name% on doit poser un noeud sur la liaison
		{\path(#2@@)--(#3@@)coordinate[overlay,pos=\CF@movebond@coeff](\CF@movebond@name);
		\let\CF@movebond@name\@empty
		}%
	\ifcase#1\relax
		\errmessage{Package \CF@package@name\space Error: unknown bond type, this error should not occur^^JIf you think it's a bug, send a Minimal Example to the author}%
	\or% 1 = liaison simple
		\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe
	\or% 2 = liaison double
		\ifCF@incycle
			\ifnum\CF@doublebond@type=\z@
				\let\CF@doublebond@type\@ne
			\fi
			\ifnum\CF@split@state>\z@
				\let\CF@doublebond@type\tw@
			\fi
			\pgfmathsetmacro\CF@doublebond@lengthcorrection{\CF@double@sep*tan(180/\CF@cycle@num)}%
		\fi
		\ifcase\CF@doublebond@type
			\CF@create@normnodes{#2@@}{#3@@}{\CF@double@sep/2}{\CF@double@sep/2}%
			\CF@draw@bond@a(#2@@1)--(#3@@1);
			\CF@draw@bond@a(#2@@2)--(#3@@2);
			\let\CF@joinbond\z@
		\or
			\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
			\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe\CF@draw@bond@a(#2@@)--(#3@@);
			\begingroup% ajuste \'eventuellement les longueurs des liaisons doubles
				\ifCF@incycle
					\ifdim\CF@start@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten <=\CF@doublebond@lengthcorrection pt}%
					\fi
					\ifdim\CF@end@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten >=\CF@doublebond@lengthcorrection pt}%
					\fi
				\fi
				\CF@draw@bond@a(#2@@1)--(#3@@1);
			\endgroup
		\or
			\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
			\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe\CF@draw@bond@a(#2@@)--(#3@@);
			\begingroup% ajuste \'eventuellement les longueurs des liaisons doubles
				\ifCF@incycle
					\ifdim\CF@start@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten \ifnum\CF@split@state=\z@<=-\else>=\fi\CF@doublebond@lengthcorrection pt}%
					\fi
					\ifdim\CF@end@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten \ifnum\CF@split@state=\z@>=-\else<=\fi\CF@doublebond@lengthcorrection pt}%
					\fi
				\fi
				\CF@draw@bond@a(#2@@2)--(#3@@2);
			\endgroup
		\fi
	\or% 3 = liaison triple
		\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
		\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe\CF@draw@bond@a(#2@@)--(#3@@);
		\CF@draw@bond@a(#2@@1)--(#3@@1);
		\CF@draw@bond@a(#2@@2)--(#3@@2);
	\or% 4 = liaison Cram pleine de #2 vers #3
		\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
		\expandafter\filldraw\expandafter[\CF@current@bondstyle,line join=bevel](#2@@1)--(#2@@2)--(#3@@)--cycle;
		\let\CF@joinbond\z@
	\or% 5 = liaison Cram creuse de #3 vers #2
		\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
		\expandafter\filldraw\expandafter[\CF@current@bondstyle,line join=bevel](#3@@1)--(#3@@2)--(#2@@)--cycle;
		\let\CF@joinbond\z@
	\or% 6 = liaison Cram pointill\'ee de #2 vers #3
		\scope
			\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
			\CF@clipcramornot(#2@@1)--(#2@@2)--(#3@@)--(#2@@1);
			\expandafter\draw\expandafter[\CF@current@bondstyle,dash pattern=on \CF@cram@dashlength off \CF@cram@dashsep,line width=\CF@cram@basewidth](#2@@)--(#3@@);
		\endscope
		\let\CF@joinbond\z@
	\or% 7 = liaison Cram pointill\'ee de #3 vers #2
		\scope
			\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
			\CF@clipcramornot(#3@@1)--(#3@@2)--(#2@@)--(#3@@1);
			\expandafter\draw\expandafter[\CF@current@bondstyle,dash pattern=on \CF@cram@dashlength off \CF@cram@dashsep,line width=\CF@cram@basewidth](#3@@)--(#2@@);
		\endscope
		\let\CF@joinbond\z@
	\or% 8 = liaison Cram triangle \'evid\'e de #2 vers #3
		\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
		\expandafter\draw\expandafter[\CF@current@bondstyle,line join=bevel](#2@@1)--(#2@@2)--(#3@@)--cycle;
		\let\CF@joinbond\z@
	\or% 9 = liaison Cram triangle \'evid\'e de #3 vers #1
		\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
		\expandafter\draw\expandafter[\CF@current@bondstyle,line join=bevel](#3@@1)--(#3@@2)--(#2@@)--cycle;
		\let\CF@joinbond\z@
	\else
		\errmessage{Package \CF@package@name\space Error: unknown bond type, this error should not occur^^JIf you think it's a bug, send a Minimal Example to the author}%
	\fi
	\let\CF@start@offset\@empty
	\let\CF@end@offset\@empty
 	\let\CF@previous@tikz\CF@current@tikz
	\let\CF@previous@bondangle\CF@previous@angle
	\def\CF@previous@bond{#1}%
}

\CF@def\CF@draw@axisbond@nojoin#1#2{\CF@draw@bond@a(#1@@)--(#2@@);}

\CF@def\CF@draw@axisbond@join#1#2{% dessine une liaison simple dans l'axe avec raccord r\'etrograde
	\ifCF@incycle\ifnum\CF@cnt@cycle=\CF@cycle@num\relax\let\CF@next@tikz\CF@cycle@firsttikz\fi\fi
	\ifnum\CF@joinbond=\z@
		\ifCF@incycle
			\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
				\ifnum\CF@cycle@joinlast=\@ne
					\CF@draw@bond@a(#1@@)--(#2@@)--%
						([shift=(\CF@previous@bondangle+2*\CF@cycle@increment@angle:.5\pgflinewidth)]#2@@);
				\else
					\CF@draw@bond@a(#1@@)--(#2@@);
				\fi
			\else
				\CF@draw@bond@a(#1@@)--(#2@@);
			\fi
		\else
			\CF@draw@bond@a(#1@@)--(#2@@);
		\fi
		\let\CF@joinbond\@ne
	\else
		\CF@ifx\CF@previous@tikz\CF@current@tikz
			{\let\CF@joinbond\@ne
			\CF@ifx\CF@previous@atomgroup\CF@empty@node
				{\CF@ifx\CF@previous@bondangle\empty% si d\'ebut mol\'ecule
					{\CF@draw@bond@a(#1@@)--(#2@@);
					}
					{\ifdim\CF@start@offset=\z@
						\ifCF@incycle
							\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
								\ifnum\CF@cycle@joinlast=\@ne
									\CF@ifx\CF@cycle@firsttikz\CF@current@tikz
										{\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@)--%
										([shift=(\CF@previous@bondangle+2*\CF@cycle@increment@angle:.5\pgflinewidth)]#2@@);
										}
										{\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
										}%
								\else
									\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
								\fi
							\else
								\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
							\fi
						\else
							\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
						\fi
					\else
						\CF@draw@bond@a(#1@@)--(#2@@);
					\fi
					}%
				}
				{\CF@draw@bond@a(#1@@)--(#2@@);}%
			}
			{\ifCF@incycle
				\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
					\ifnum\CF@cycle@joinlast=\@ne
						\CF@ifx\CF@next@tikz\CF@current@tikz
							{\CF@draw@bond@a(#1@@)--(#2@@)--%
								([shift=(\CF@previous@bondangle+2*\CF@cycle@increment@angle:.5\pgflinewidth)]#2@@);
							}%
							{\CF@draw@bond@a(#1@@)--(#2@@);
							}%
					\else
						\CF@draw@bond@a(#1@@)--(#2@@);
					\fi
				\else
					\CF@draw@bond@a(#1@@)--(#2@@);
				\fi
			\else
				\CF@draw@bond@a(#1@@)--(#2@@);
			\fi
			}%
 	\fi
 	\ifdim\CF@end@offset=\z@\else\let\CF@joinbond\z@\fi
}

\CF@def\enablebondjoin {\global\let\CF@draw@axisbond\CF@draw@axisbond@join}
\CF@def\disablebondjoin{\global\let\CF@draw@axisbond\CF@draw@axisbond@nojoin}
\disablebondjoin% par d\'efaut, d\'esactiver la jointure entre liaisons

\CF@def\CF@draw@bond@a{\expandafter\draw\expandafter[\CF@current@bondstyle]}

\CF@def\CF@hook@drawall{% dessine tous les crochets contenus dans la sc \CF@hook@draw
	\CF@doifnotempty\CF@hook@drawlist
		{\expandafter\CF@hook@drawfirst\CF@hook@drawlist\@nil% trace un lien de crochet \`a crochet
		\CF@hook@drawall
		}%
}

\CF@def\CF@hook@drawfirst[#1,#2,#3]#4#5#6#7#8\@nil{%
	\def\CF@hook@drawlist{#8}%
	\begingroup
		\let\CF@joinbond\z@
		\def\CF@current@tikz{#3}%
		\def\CF@hook@startcontent{#6}\def\CF@hook@endcontent{#7}%
		\CF@if@integer{#2}%
			{\CF@draw@bond{#2}{#4}{#5}\CF@hook@startcontent\CF@hook@endcontent}%
			{\CF@bond@findcode{#2}\CF@bond@currentnum
			\CF@draw@bond\CF@bond@currentnum{#4}{#5}\CF@hook@startcontent\CF@hook@endcontent
			}%
	\endgroup
}

\CF@def\CF@extract@atom#1-#2\@nil{#2}% transforme le bound@outnode en n° de l'atome

\CF@def\setnodestyle{\def\CF@node@style}
\setnodestyle{}

\CF@def\setbondstyle{\def\CF@bond@style}
\setbondstyle{}

\expandafter\CF@def\expandafter\CF@gobble@movearg\CF@arobas#1#2\@nil#3{%
	\expandafter\def\csname atom@\number\CF@cnt@atomnumber\endcsname{#2}%
	\CF@if@instr{#1},%
		{\CF@analyse@movearg#1\@nil#3\let\CF@movebond@coeff\@empty}%
		{\def#3{#1}}%
	\CF@doifempty{#2}{\let\CF@node@strut\@empty}%
}%

\CF@def\hflipnext{\let\CF@split@state\@ne}

\CF@def\vflipnext{\let\CF@split@state\tw@}
\let\CF@split@state\z@

\CF@def\CF@draw@atomgroup#1#2#3{% #1=angle d'arriv\'ee de la liaison #2=numero atome sur lequel arrive la liaison #3=groupe d'atomes
	\expandafter\let\expandafter\CF@bond@outcontent% assigne le contenu de l'atome d'o\`u part la liaison
		\csname
			\ifdefined\CF@bond@outnode
				atom@\expandafter\CF@extract@atom\CF@bond@outnode\@nil
			\else
				@empty%
			\fi
		\endcsname
	\global\advance\CF@cnt@groupnumber\@ne
	\let\CF@current@atom\@empty
	\global\let\CF@hook@drawlist\@empty
	\CF@cnt@atomingroup\z@
	\CF@if@firsttokmatch{#3}?{\CF@draw@atomgroup@a{{}#3}}{\CF@draw@atomgroup@a{#3}}%
	\def\CF@current@atomgroup{#3}%
	\CF@remove@movearg\CF@current@atomgroup% enl\`eve les "@{<nom>}"
	\CF@if@instr{#3}?%
		{\CF@remove@hook\CF@current@atomgroup
		\ifcat\relax\detokenize\expandafter{\romannumeral-`\.\expandafter\noexpand\CF@current@atomgroup}\relax
			\let\CF@current@atomgroup\CF@empty@node
		\fi
		}%
		{}%
	\CF@doifnotempty{#2}
		{\ifnum#2<\@ne
			\immediate\write\CF@unused{Package \CF@package@name\space Warning: no atom found at position #2, pershaps you mispelled the optional argument of the bond.}%
		\else
			\ifnum#2>\CF@cnt@atomingroup
				\errmessage{Package \CF@package@name\space Error: no atom found at position #2, pershaps you mispelled the optional argument of the bond.}%
			\fi
		\fi
		}%
	\edef\CF@hook@atomnumber{%
		\CF@ifempty{#2}
			{\ifdim#1pt>90pt
				\ifdim#1pt<270pt \number\CF@cnt@atomingroup\else1\fi
			\else1%
			\fi
			}
			{#2}%
	}%
	\CF@cnt@atomnumber\CF@hook@atomnumber
	\CF@ifx\CF@current@atomgroup\CF@empty@node
		{\let\CF@node@strut\@empty}
		{\CF@ifx\@empty\CF@bond@outcontentsaved
			{\def\CF@node@strut{\vphantom\CF@bond@outcontent}}%
			{\def\CF@node@strut{\vphantom\CF@bond@outcontentsaved}}%
		}%
	\edef\CF@opt@string{anchor=\ifnum\CF@last@action=\z@ base\else\ifCF@incycle center\else\ifCF@macrofixedbondlength 180+#1\else center\fi\fi\fi,at=(CF@node),\CF@node@style}% premier atome de la mol\'ecule affich\'e
	\loop
		\unless\ifnum\CF@cnt@atomnumber>\CF@cnt@atomingroup
		\CF@twoexp@after
			{\futurelet\CF@toks@a}
			{\expandafter\expandafter\expandafter\CF@gobtonil\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil}%
		\expandafter\CF@ifx\CF@arobas\CF@toks@a% l'atome courant commence par un "@"
			{\CF@three@ea\CF@gobble@movearg\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil\CF@moveatom@name
			\expandafter\node\expandafter[\CF@opt@string,overlay](\CF@moveatom@name){\phantom{\CF@node@content}};%
			\let\CF@moveatom@name\@empty
			}
			{}%
		\expandafter\node\expandafter[\CF@opt@string](n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber){\CF@node@content};%
		\let\CF@node@strut\@empty
		\advance\CF@cnt@atomnumber\@ne
		\edef\CF@opt@string{anchor=base \ifnum\CF@split@state=\@ne east\else west\fi,at=(n\number\CF@cnt@groupnumber-\number\numexpr\CF@cnt@atomnumber-1.base \ifnum\CF@split@state=\@ne west\else east\fi),\CF@node@style}%
	\repeat
	\CF@cnt@atomnumber\CF@hook@atomnumber
	\ifnum\CF@last@action=\tw@% s'il faut tracer une liaison
		\gdef\CF@cycle@anglecorrection{0}% alors c'est qu'un cycle ne peut pas commencer la mol\'ecule : annulation de la correction d'angle
		\CF@draw@bond\CF@bond@type{\CF@bond@outnode}{n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber}\CF@previous@atomgroup\CF@current@atomgroup
	\fi
	\let\CF@last@action\@ne% met la derni\`ere action \`a 1 : affichage d'un noeud
	\loop
		\ifnum\CF@cnt@atomnumber>\@ne
		\advance\CF@cnt@atomnumber\m@ne
		\edef\CF@opt@string{anchor=base \ifnum\CF@split@state=\@ne west\else east\fi,at=(n\number\CF@cnt@groupnumber-\number\numexpr\CF@cnt@atomnumber+1.base \ifnum\CF@split@state=\@ne east\else west\fi),\CF@node@style}%
		\CF@twoexp@after
			{\futurelet\CF@toks@a}
			{\expandafter\expandafter\expandafter\CF@gobtonil\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil}%
		\expandafter\CF@ifx\CF@arobas\CF@toks@a% l'atome courant commence par un "@"
			{\CF@three@ea\CF@gobble@movearg\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil\CF@moveatom@name
			\expandafter\node\expandafter[\CF@opt@string,overlay](\CF@moveatom@name){\phantom{\CF@node@content}};%
			\let\CF@moveatom@name\@empty
			}
			{}%
		\expandafter\node\expandafter[\CF@opt@string](n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber){\CF@node@content};%
	\repeat
	\CF@hook@drawall
	\edef\CF@last@groupnumber{\number\CF@cnt@groupnumber}%
	\let\CF@previous@atomgroup\CF@current@atomgroup
}

\expandafter\CF@def\expandafter\CF@keep@movearg\CF@arobas#1#2\@nil{\CF@exp@second{\def\CF@current@atom}{\CF@arobas{#1}}}

\CF@def\CF@draw@atomgroup@a#1{% transforme #1 en un groupe d'atomes
	\CF@ifempty{#1}
		{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom}
		{\advance\CF@cnt@atomingroup\@ne
		\futurelet\CF@toks@a\CF@gobtonil#1\@nil
		\expandafter\CF@ifx\CF@arobas\CF@toks@a
			{\CF@keep@movearg#1\@nil
			\CF@remove@movearg@a#1\@nil\CF@after@movearg
			\CF@exp@macroarg\CF@draw@atomgroup@b{\CF@after@movearg}%
			}%
			{\let\CF@current@atom\@empty
			\CF@draw@atomgroup@b{#1}%
			}%
		}%
}

\CF@def\CF@draw@atomgroup@b#1{%
	\CF@ifempty{#1}
		{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom}
		{\futurelet\CF@toks@a\CF@gobtonil#1\@nil
		\CF@ifx\bgroup\CF@toks@a
			{\CF@expadd@tocs\CF@current@atom{\expandafter{\@car#1\@nil}}%
			\CF@exp@macroarg\CF@draw@atomgroup@bi{\@gobble#1}%
			}%
			{\CF@ifx\@sptoken\CF@toks@a
				{\CF@add@tocs\CF@current@atom{ }%
				\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@after@space#1\@nil}%
				}%
				{\CF@expadd@tocs\CF@current@atom{\@car#1\@nil}%
				\CF@exp@macroarg\CF@draw@atomgroup@bi{\@gobble#1}%
				}%
			}%
		}%
}

% enl\`eve tous les "@{nom}" de la sc #1
\CF@def\CF@remove@movearg#1{%
	\CF@exp@after{\expandafter\CF@if@instr\expandafter{#1}}{\CF@arobas}%
		{\expandafter\CF@remove@movearg@a#1\@nil#1%
		\CF@remove@movearg#1%
		}%
		{}%
}

% enl\`eve le premier "@{<nom>}" de l'argument et l'assigne \`a #2
\CF@def\CF@remove@movearg@a#1\@nil#2{%
	\expandafter\def\expandafter\CF@remove@movearg@b\expandafter##\expandafter1\CF@arobas{%
		\CF@exp@second{\def#2}{\@gobble##1}% mange le \relax
		\CF@remove@movearg@c\relax
	}%
	\def\CF@remove@movearg@c##1\@nil{\CF@expadd@tocs#2{\@gobbletwo##1}}% mange le \relax et le <nom>
	\CF@remove@movearg@b\relax#1\@nil
}

\CF@def\CF@draw@atomgroup@bi#1{% transforme #1 en un groupe d'atomes
	\CF@ifempty{#1}
		{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
		\let\CF@current@atom\@empty
		}
		{\futurelet\CF@toks@a\CF@gobtonil#1\@nil
		\expandafter\CF@ifx\CF@arobas\CF@toks@a
			{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
			\let\CF@current@atom\@empty
			\CF@draw@atomgroup@a{#1}%
			}%
			{\CF@ifx|\CF@toks@a
				{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
				\let\CF@current@atom\@empty
				\CF@exp@macroarg\CF@draw@atomgroup@a{\@gobble#1}%
				}%
				{\CF@ifx\@sptoken\CF@toks@a
					{\CF@add@tocs\CF@current@atom{ }%
					\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@after@space#1\@nil}%
					 }%
					{\CF@ifx\bgroup\CF@toks@a
						{\CF@expadd@tocs\CF@current@atom{\expandafter{\@car#1\@nil}}%
						\CF@exp@macroarg\CF@draw@atomgroup@bi{\@gobble#1}%
						}%
						{\CF@exp@macroarg\CF@ifcar@isupperletter{\@car#1\@nil}%
							{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
							\let\CF@current@atom\@empty
							\CF@draw@atomgroup@a{#1}%
							}%
							{\CF@ifx?\CF@toks@a
								{\CF@exp@macroarg\CF@if@firsttokmatch{\@gobble#1}[% un crochet apr\`es le "?"
									{\expandafter\CF@grab@optarg\@gobble#1\@nil\CF@after@hook}%
									{\expandafter\CF@grab@optarg\expandafter[\expandafter]\@gobble#1\@nil\CF@after@hook}%
								\CF@exp@twomacroargs\CF@if@instr{\CF@hook@list}{\expandafter(\CF@hook@currentname)}% crochet d\'ej\`a d\'efini ?
									{\CF@exp@macroarg\CF@hook@parselist{\CF@hook@currentname}% chercher les caract\'eristiques du crochet sauvegard\'e
									\CF@edefadd@tocs\CF@hook@drawlist{%
										[\CF@hook@currentname,\CF@hook@currentlink,\CF@hook@currenttikz]{\CF@hook@savedcoord}{n\number\CF@cnt@groupnumber-\number\CF@cnt@atomingroup}}%
									\CF@expadd@tocs\CF@hook@drawlist{\expandafter{\CF@hook@savedcontent}}%
									\CF@expadd@tocs\CF@hook@drawlist{\expandafter{\CF@current@atom}}% ajoute les 4 arguments \`a la liste des crochets \`a tracer
									\global\let\CF@hook@drawlist\CF@hook@drawlist
									}%
									{\CF@edefadd@tocs\CF@hook@list{(\CF@hook@currentname)|n\number\CF@cnt@groupnumber-\number\CF@cnt@atomingroup|}%
									\CF@expadd@tocs\CF@hook@list{\CF@current@atom|}%
									\global\let\CF@hook@list\CF@hook@list
									}%
								\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@after@hook}%
								}%
								{\CF@expadd@tocs\CF@current@atom{\@car#1\@nil}%
								\CF@exp@macroarg\CF@draw@atomgroup@bi{\@gobble#1}%
								}%
							}%
						}%
					}%
				}%
			}%
		}%
}

\CF@def\CF@kook@defaultname{a}
\CF@def\CF@hook@defaultlink{-}
\CF@def\CF@hook@defaulttikz{}

\CF@def\CF@hook@parseoptarg#1,#2,#3\@nil{%
	\CF@testempty@andassign\CF@hook@currentname{#1}\CF@kook@defaultname
	\CF@testempty@andassign\CF@hook@currentlink{#2}\CF@hook@defaultlink
	\CF@testempty@andassign\CF@hook@currenttikz{#3}\CF@hook@defaulttikz
}

\CF@def\CF@grab@optarg[#1]#2\@nil#3{%
	\CF@hook@parseoptarg#1,,\@nil
	\def#3{#2}%
}

\CF@def\CF@hook@parselist#1{% #1 est le nom du noeud \`a retrouver
	\def\CF@hook@parselist@a##1(#1)|##2|##3|##4\@nil{\def\CF@hook@savedcoord{##2}\def\CF@hook@savedcontent{##3}}%
	\expandafter\CF@hook@parselist@a\CF@hook@list\@nil
}

\CF@def\CF@remove@hook#1{%
	\CF@exp@macroarg\CF@if@instr{#1}?%
		{\expandafter\CF@remove@hook@a\expandafter\relax#1\@nil#1%
		\CF@remove@hook#1%
		}
		{}%
}

\CF@def\CF@remove@hook@a#1?#2\@nil#3{%
	\CF@if@firsttokmatch{#2}[%
		{\CF@remove@hook@b#1?#2\@nil#3}
		{\CF@exp@second{\def#3}{\@gobble#1#2}}%
}

\CF@def\CF@remove@hook@b#1?[#2]#3\@nil#4{\CF@exp@second{\def#4}{\@gobble#1#3}}

\CF@def\setlewis{\@testopt\CF@setlewis{0.3ex}}

\CF@def\CF@setlewis[#1]#2#3#4{%
	\def\CF@lewis@widthdouble{#1}%
	\CF@ifempty{#2}{\def\CF@lewis@offset{0.4ex}}{\def\CF@lewis@offset{#2}}%
	\CF@ifempty{#3}{\def\CF@lewis@length{1.5ex}}{\def\CF@lewis@length{#3}}%
	\CF@ifempty{#4}{\def\CF@lewis@style{}}{\def\CF@lewis@style{#4}}%
}
\setlewis{}{}{}

\CF@def\setlewisdist#1{%
	\CF@ifempty{#1}{\def\CF@lewis@dist{0.2em}}{\def\CF@lewis@dist{#1}}%
}
\setlewisdist{0.3em}

\CF@def\Lewis{\@testopt{\CF@lewis@a{}}{1}}

\CF@def\lewis{\@testopt{\CF@lewis@a{,overlay}}{1}}

\CF@def\CF@lewis@a#1[#2]{%
	\CF@ifempty{#2}{\def\CF@lewis@diagcoeff{1}}{\def\CF@lewis@diagcoeff{#2}}%
	\CF@lewis@b{#1}%
}

\CF@def\CF@lewis@b#1#2{\CF@lewis@c#2\@nil{#1}}

\CF@def\CF@lewis@c#1,#2\@nil#3{%
	\setbox\CF@lewis@box\hbox{\printatom{#2}}% mettre en dehors de tikzpicture (si \printatom ne passe pas en mode math)
	\tikzpicture[every node/.style={anchor=base,inner sep=\z@,outer sep=\z@,minimum size=\z@},baseline]%
		\@makeother;\@makeother:%
		\node(CF@lewis@anchor){};
		\def\CF@lewis@remainpos{#1}%
		\let\CF@lewis@previouspos\@empty
		\loop
			\unless\ifx\CF@lewis@remainpos\@empty
				\edef\CF@lewis@currentpos{\expandafter\@car\CF@lewis@remainpos\@nil}%
				\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
				\pgfmathsetmacro\CF@lewis@x{\wd\CF@lewis@box/2+\ifcase\CF@lewis@currentpos\space1\or1\or0\or-1\or-1\or-1\or0\or1\fi*(\wd\CF@lewis@box/2)}%
				\pgfmathsetmacro\CF@lewis@y{\ht\CF@lewis@box/2+\ifcase\CF@lewis@currentpos\space0\or1\or1\or1\or0\or-1\or-1\or-1\fi*(\ht\CF@lewis@box/2\ifnum\CF@lewis@currentpos>4 +\dp\CF@lewis@box\fi)}%
				\edef\CF@lewis@xoffset{\ifcase\CF@lewis@currentpos\space1\or0.70711\or0\or-0.70711\or-1\or-0.70711\or0\or0.70711\fi}%
				\edef\CF@lewis@yoffset{\ifcase\CF@lewis@currentpos\space0\or0.70711\or1\or0.70711\or0\or-0.70711\or-1\or-0.70711\fi}%
				\ifodd\CF@lewis@currentpos\relax
					\pgfmathsetmacro\CF@lewis@current@offset{\CF@lewis@offset*\CF@lewis@diagcoeff}%%
				\else
					\let\CF@lewis@current@offset\CF@lewis@offset
				\fi
				\if.\expandafter\@car\CF@lewis@remainpos\relax\@nil
					\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
					\CF@exp@after{\draw[fill,black,}{\CF@lewis@style#3]}%
						(\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset,\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset)circle(0.15ex);%
				\else
					\if|\expandafter\@car\CF@lewis@remainpos\relax\@nil
						\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
						\pgfmathsetmacro\CF@lewis@x{\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset}%
						\pgfmathsetmacro\CF@lewis@y{\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset}%
						\expandafter\draw\expandafter[\CF@lewis@style#3]%
							(\CF@lewis@x pt+\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y-\CF@lewis@length*\CF@lewis@xoffset/2 pt)--
							(\CF@lewis@x pt+\CF@lewis@length*\CF@lewis@yoffset/2 pt+\CF@lewis@xoffset*\CF@lewis@widthdouble,\CF@lewis@y-\CF@lewis@length*\CF@lewis@xoffset/2 pt+\CF@lewis@yoffset*\CF@lewis@widthdouble)--
							(\CF@lewis@x pt-\CF@lewis@length*\CF@lewis@yoffset/2 pt+\CF@lewis@xoffset*\CF@lewis@widthdouble,\CF@lewis@y+\CF@lewis@length*\CF@lewis@xoffset/2 pt+\CF@lewis@yoffset*\CF@lewis@widthdouble)--
							(\CF@lewis@x pt-\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@xoffset/2 pt)--cycle;%
					\else
						\if:\expandafter\@car\CF@lewis@remainpos\relax\@nil
							\edef\CF@lewis@remainpos{\expandafter\@gobble\CF@lewis@remainpos}%
							\pgfmathsetmacro\CF@lewis@x{\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset}%
							\pgfmathsetmacro\CF@lewis@y{\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset}%
							\CF@exp@after{\draw[fill,black,}{\CF@lewis@style#3]}%
								(\CF@lewis@x pt+\CF@lewis@dist*\CF@lewis@yoffset/2 pt,\CF@lewis@y-\CF@lewis@dist*\CF@lewis@xoffset/2 pt)circle(0.15ex)%
								(\CF@lewis@x pt-\CF@lewis@dist*\CF@lewis@yoffset/2 pt,\CF@lewis@y+\CF@lewis@dist*\CF@lewis@xoffset/2 pt)circle(0.15ex);%
						\else
							\pgfmathsetmacro\CF@lewis@x{\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset}%
							\pgfmathsetmacro\CF@lewis@y{\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset}%
							\expandafter\draw\expandafter[\CF@lewis@style#3]%
								(\CF@lewis@x pt+\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y-\CF@lewis@length*\CF@lewis@xoffset/2 pt)--%
								(\CF@lewis@x pt-\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@xoffset/2 pt);%
						\fi
					\fi
			\fi
		\repeat
		\node[anchor=base west]at(CF@lewis@anchor){\box\CF@lewis@box};%
	\endtikzpicture
}

\CF@def\setstacksep#1{\edef\CF@stacksep{\CF@ifempty{#1}{1.5pt}{\the\dimexpr#1\relax}}}
\setstacksep{1.5pt}

\CF@def\Chembelow{\begingroup\let\CF@tmp@str\@gobble\CF@chembelow@a}

\CF@def\chembelow{\begingroup\let\CF@tmp@str\@firstofone\CF@chembelow@a}

\CF@def\CF@chembelow@a{\@testopt\CF@chembelow@b\CF@stacksep}

\CF@def\CF@chembelow@b[#1]#2#3{%
	\setbox\CF@box@boxa\hbox{\printatom{#2}}%
	\expandafter\vtop\CF@tmp@str{to\ht\CF@box@boxa}{%
		\offinterlineskip
		\hbox{\printatom{#2}}%
		\kern#1\relax
		\hbox to\wd\CF@box@boxa{\hss\printatom{#3}\hss}%
		\CF@tmp@str\vss
		}%
	\endgroup
}

\CF@def\Chemabove{\begingroup\let\CF@tmp@str\@gobble\CF@chemabove@a}

\CF@def\chemabove{\begingroup\let\CF@tmp@str\@firstofone\CF@chemabove@a}

\CF@def\CF@chemabove@a{\@testopt\CF@chemabove@b\CF@stacksep}

\CF@def\CF@chemabove@b[#1]#2#3{%
	\setbox\CF@box@boxa\hbox{\printatom{#2}}%
	\expandafter\vbox\CF@tmp@str{to\ht\CF@box@boxa}{%
		\offinterlineskip
		\CF@tmp@str\vss
		\hbox to\wd\CF@box@boxa{\hss\printatom{#3}\hss}%
		\kern#1\relax
		\hbox{\printatom{#2}}%
	}%
	\endgroup
}

\CF@def\chemmove{\@testopt\CF@chemmove{}}

\CF@def\CF@chemmove[#1]#2{%
	\CF@doifnotempty{#2}%
		{\expandafter\tikzpicture\romannumeral\CF@ifempty{#1}%
			{\z@[overlay,remember picture,-CF]}
			{\z@[overlay,remember picture,-CF,#1]}%
			#2
		\endtikzpicture
		}%
}

\CF@def\chemnameinit#1{%
	\setbox\CF@stuff@box\hbox{#1}%
	\xdef\CF@dp@max{\the\dp\CF@stuff@box}%
}
\let\CF@dp@max\z@

\CF@def\CF@parse@molname#1\\#2\@nil{%
	\hbox to\CF@wd@stuffbox{\hss#1\hss}%
	\CF@doifnotempty{#2}{\CF@parse@molname#2\@nil}%
}

\CF@def\chemname{%
	\@ifstar
		{\CF@name@dp@adjustfalse\CF@chemname@a}
		{\CF@name@dp@adjusttrue \CF@chemname@a}%
}

\CF@def\CF@chemname@a{\@testopt\CF@chemname@b{1.5ex}}

\CF@def\CF@chemname@b[#1]#2#3{%
	\setbox\CF@stuff@box\hbox{#2}%
	\edef\CF@wd@stuffbox{\the\wd\CF@stuff@box}\edef\CF@dp@stuffbox{\the\dp\CF@stuff@box}%
	\leavevmode
	\ifdim\CF@dp@max<\CF@dp@stuffbox\global\let\CF@dp@max\CF@dp@stuffbox\fi
	\vtop{%
		\box\CF@stuff@box
		\nointerlineskip
		\kern\dimexpr#1\ifCF@name@dp@adjust+\CF@dp@max-\CF@dp@stuffbox\fi\relax
		\CF@parse@molname#3\\\@nil
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%    S C H E M A S      R E A C T I O N N E L S    %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcount\CF@compound@cnt

\newdimen\CF@arrow@size

\newif\ifCF@name@start
\newif\ifCF@name@end
\newif\ifCF@reac@debug

\let\CF@scheme@nest\z@% ne PAS modifier cette ligne !

\CF@def\CF@subscheme{\@testopt\CF@subscheme@a{}}
\CF@def\CF@subscheme@a[#1]{\@testopt{\CF@subscheme@b[#1]}{text}}
\CF@def\CF@subscheme@b[#1][#2]#3{\schemestart[#1][#2]#3\schemestop}

\CF@def\schemedebug#1{\ifcsname CF@reac@debug#1\endcsname\csname CF@reac@debug#1\endcsname\else\CF@reac@debugfalse\fi}
\schemedebug{false}

\CF@def\setcompoundstyle{\def\CF@default@compound@style}
\setcompoundstyle{}

\CF@def\CF@set@style#1,#2,#3\@nil#4#5#6{%
	\def#4{#1}%
	\CF@exp@second{\def#5}{#2}%
	\CF@expadd@tocs#6{#3}
	\CF@twoexp@second{\def#6}{\expandafter\CF@sanitize@lastitem#6,\@empty\@nil}%
}

\CF@def\setarrowdefault#1{%
	\def\CF@default@arrow@style{-CF,}% style minimal par d\'efaut
	\CF@set@style#1,\@empty,\@empty\@nil\CF@default@arrow@angle\CF@default@arrow@length\CF@default@arrow@style
	\CF@doifempty\CF@default@arrow@angle{\def\CF@default@arrow@angle{0}}%
	\CF@doifempty\CF@default@arrow@length{\def\CF@default@arrow@length{1}}%
}
\setarrowdefault{}% style de fl\`eche

\CF@def\setarrowoffset#1{%
	\CF@ifempty{#1}{\def\CF@arrow@offset{1em}}{\def\CF@arrow@offset{#1}}%
}%
\setarrowoffset{}

\CF@def\setcompoundsep#1{%
	\CF@ifempty{#1}{\def\CF@compound@sep{5em}}{\def\CF@compound@sep{#1}}%
}
\setcompoundsep{}

\CF@def\setarrowlabelsep#1{%
	\CF@ifempty{#1}{\def\CF@arrow@labelsep{3pt}}{\def\CF@arrow@labelsep{#1}}%
}
\setarrowlabelsep{}

\CF@def\chemleft#1#2\chemright#3{%
	\leavevmode
	\begingroup
		\setbox\z@\hbox{$\vcenter{\hbox{}}$}\edef\CF@delim@math@ht{\the\ht\z@}%
		\setbox\z@\hbox{#2}\edef\CF@delim@dim{\the\dimexpr(\ht\z@+\dp\z@)/\tw@}%
		\edef\CF@delim@shift{\the\dimexpr(\ht\z@-\dp\z@)/\tw@-\CF@delim@math@ht}%
		\raise\CF@delim@shift\hbox{$\left#1\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right.$}\box\z@
		\raise\CF@delim@shift\hbox{$\left.\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right#3$}%
	\endgroup
}

\CF@def\chemright#1{%
	\immediate\write\CF@unused{Package \CF@package@name\space Warning: "\string\chemright\string#1"ignored! No \string\chemleft\space previously found.^^J}%
}

\CF@def\chemup#1#2\chemdown#3{%
	\begingroup
		\setbox\z@\hbox{\printatom{#2}}\edef\CF@delim@dim{\the\dimexpr\wd\z@/\tw@}%
		\tikzpicture[every node/.style={inner sep=\z@,outer sep=\z@,minimum size=\z@},baseline]%
			\node[anchor=base west](chem@stuff){\box\z@};%
			\node[at=(chem@stuff.north),anchor=east,rotate=-90]{$\left#1\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right.$};%
			\node[at=(chem@stuff.south),anchor=west,rotate=-90]{$\left.\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right#3$};%
		\endtikzpicture
	\endgroup
}

\CF@def\chemdown#1{%
	\immediate\write\CF@unused{Package \CF@package@name\space Warning: "\string\chemdown\string#1" ignored! No \string\chemup\space previously found.^^J}%
}

\CF@def\CF@and{\futurelet\CF@toks@a\CF@and@a}

\CF@def\CF@and@a{%
	\CF@ifx\CF@toks@a\bgroup
		\CF@and@b
		{\CF@and@b{}}%
}

\CF@def\CF@and@b#1{%
	\let\CF@sign@vshift\@empty
	\CF@set@style#1,\@empty,\@empty\@nil\CF@signspace@ante\CF@signspace@post\CF@sign@vshift
	\CF@doifempty\CF@signspace@ante{\let\CF@signspace@ante\CF@signspace@ante@default}%
	\CF@doifempty\CF@signspace@post{\let\CF@signspace@post\CF@signspace@post@default}%
	\CF@doifempty\CF@sign@vshift{\let\CF@sign@vshift\CF@sign@vshift@default}%
	\raise\CF@sign@vshift\hbox{\kern\CF@signspace@ante$+$\kern\CF@signspace@post}%
}

\CF@def\setandsign#1{%
	\let\CF@sign@vshift@default\@empty
	\CF@set@style#1,\@empty,\@empty\@nil\CF@signspace@ante@default\CF@signspace@post@default\CF@sign@vshift@default
	\CF@doifempty\CF@signspace@ante@default{\def\CF@signspace@ante@default{.5em}}%
	\CF@doifempty\CF@signspace@post@default{\def\CF@signspace@post@default{.5em}}%
	\CF@doifempty\CF@sign@vshift@default{\let\CF@sign@vshift@default\z@}%
}
\setandsign{}

\CF@def\schemestart{%
	\xdef\CF@scheme@nest{\number\numexpr\CF@scheme@nest+\@ne}%
	\@testopt\CF@schemestart@a{}%
}

\CF@def\CF@schemestart@a[#1]{%
	\let\CF@arrow@style\@empty
	\CF@set@style#1,\@empty,\@empty\@nil\CF@arrow@angle\CF@arrow@length\CF@arrow@style
	\CF@doifempty\CF@arrow@angle{\let\CF@arrow@angle\CF@default@arrow@angle}%
	\CF@doifempty\CF@arrow@length{\let\CF@arrow@length\CF@default@arrow@length}%
	\CF@ifx\@empty\CF@arrow@style
		{\let\CF@arrow@style\CF@default@arrow@style}
		{\CF@twoexp@second{\def\CF@arrow@style}{\expandafter\CF@default@arrow@style\expandafter,\CF@arrow@style}}% se rajoute apr\`es le style par d\'efaut
	\ifCF@reac@debug
		\tikzpicture[every node/.style={draw,anchor=base,inner sep=\z@,outer sep=\z@,minimum size=1.5pt},baseline,remember picture]%
	\else
		\tikzpicture[every node/.style={anchor=base,inner sep=\z@,outer sep=\z@,minimum size=\z@},baseline,remember picture]%
	\fi
	\let\merge\CF@merge
	\expandafter\let\csname+\endcsname\CF@and
	\let\arrow\CF@arrow
	\let\schemestop\CF@schemestop
	\let\subscheme\CF@subscheme
	\@testopt{\CF@schemestart@b[#1]}{text}%
}

\CF@def\CF@schemestart@b[#1][#2]{%
	\ifnum\CF@scheme@nest=\@ne% la commande n'est pas imbriqu\'ee ?
		\CF@compound@cnt\z@
	\fi
	\edef\CF@current@nodename{c\number\CF@compound@cnt}%
	\let\CF@next@nodename\@empty
	\let\CF@next@nodestyle\@empty
	\let\CF@direct@arrow@list\@empty
	\ifCF@reac@debug
		\node[fill,green](\CF@current@nodename){};%
	\else
		\node(\CF@current@nodename){};%
	\fi
	\def\CF@next@nodeanchor{#2}%
	\CF@doifempty\CF@next@nodeanchor{\def\CF@next@nodeanchor{text}}%
	\let\CF@compound\@empty
	\CF@schemestart@c
}

\CF@def\CF@schemestart@c{%
	\futurelet\CF@toks@a\CF@schemestart@e
}

\expandafter\CF@def\expandafter\CF@schemestart@d\space{\futurelet\CF@toks@a\CF@schemestart@e}

\CF@def\CF@schemestart@e{% ... et l'examine :
	\CF@if@firsttokin@a{\arrow\schemestop\merge}%
		{}
		{\CF@ifx\CF@toks@a\bgroup
			{\CF@add@nextarg}
			{\CF@ifx\CF@toks@a\@sptoken
				{\CF@add@tocs\CF@compound{ }%
				\CF@schemestart@d
				}
				{\afterassignment\CF@schemestart@c
				\CF@add@tocs\CF@compound
				}%
			}%
		}%
}

\CF@def\CF@add@nextarg#1{\CF@add@tocs\CF@compound{{#1}}\CF@schemestart@c}

\CF@def\CF@display@compound#1#2{% #1 = nom et #2 = style
	\CF@doifnotempty\CF@compound
		{\global\advance\CF@compound@cnt\@ne
		\CF@ifx\CF@default@compound@style\@empty
			{\let\CF@current@nodestyle\@empty}
			{\CF@exp@second{\def\CF@current@nodestyle}{\CF@default@compound@style,}}%
		\CF@add@tocs\CF@current@nodestyle{anchor=\CF@next@nodeanchor,at=(\CF@current@nodename)}%
		\CF@ifempty{#2}%
			{\CF@doifnotempty\CF@next@nodestyle
				{\CF@expadd@tocs\CF@current@nodestyle{\expandafter,\CF@next@nodestyle}}%
			}
			{\CF@doifnotempty\CF@next@nodestyle
				{\immediate\write\CF@unused{Package \CF@package@name\space Warning: two styles for the same node, first style "\CF@next@nodestyle" ignored^^J}%
				}%
			\CF@add@tocs\CF@current@nodestyle{,#2}%
			}%
		\CF@ifempty{#1}
			{\edef\CF@tmp@str{\CF@ifempty\CF@next@nodename{c\number\CF@compound@cnt}{\CF@next@nodename}}%
			}
			{\CF@doifnotempty\CF@next@nodename
				{\immediate\write\CF@unused{Package \CF@package@name\space Warning: two names for the same node, first name "\CF@next@nodename" ignored^^J}%
				}%
			\edef\CF@tmp@str{#1}%
			}%
		\expandafter\node\expandafter[\CF@current@nodestyle](\CF@tmp@str){\CF@compound};%
		\ifCF@reac@debug
			\node[draw=none,anchor=270,at=(\CF@tmp@str.90),fill=green!60,overlay,opacity=0.5]{\scriptsize\bfseries\CF@tmp@str};%
		\fi
		\let\CF@current@nodename\CF@tmp@str
		}%
}

\CF@def\CF@schemestop{%
	\CF@display@compound{}{}%
	\CF@direct@arrow@list
	\endtikzpicture
	\xdef\CF@scheme@nest{\number\numexpr\CF@scheme@nest-\@ne}%
}

\CF@def\CF@analyse@arrowarg#1{\CF@analyse@arrowarg@i#1[]\@nil}

\CF@def\CF@analyse@arrowarg@i#1[#2]#3\@nil{%
	\CF@if@instr{#1}.{\CF@add@tocs\CF@tmp@str{#1[#2]}}{\CF@add@tocs\CF@tmp@str{#1.[#2]}}%
}

\CF@def\CF@arrow{%
	\@ifnextchar(%
		\CF@arrow@a
		{\@ifnextchar\bgroup{\CF@arrow@b(.[]--.[])}{\CF@arrow@b(.[]--.[]){}}}%
}

\CF@def\CF@arrow@a(#1--#2){%
	\def\CF@tmp@str{(}%
	\CF@analyse@arrowarg{#1}%
	\CF@add@tocs\CF@tmp@str{--}%
	\CF@analyse@arrowarg{#2}%
	\CF@add@tocs\CF@tmp@str)%
	\@ifnextchar\bgroup{\expandafter\CF@arrow@b\CF@tmp@str}{\expandafter\CF@arrow@b\CF@tmp@str{}}%
}

\CF@def\CF@arrow@b(#1.#2[#3]--#4.#5[#6])#7{%
	\def\CF@current@arrowtype{#7}%
	\CF@doifempty\CF@current@arrowtype{\def\CF@current@arrowtype{->}}%
	\@testopt{\CF@arrow@c(#1.#2[#3]--#4.#5[#6])}{}%
}

\CF@def\CF@arrow@c(#1.#2[#3]--#4.#5[#6])[#7]{%
	\def\CF@tmp@str{\CF@arrow@e(#1.#2[#3]--#4.#5[#6])}%
	\CF@arrow@d#7,\@empty,\@empty\@nil
}

\CF@def\CF@arrow@d#1,#2,#3\@nil{%
	\CF@add@tocs\CF@tmp@str{{#1}}%
	\CF@expadd@tocs\CF@tmp@str{\expandafter{#2}}%
	\expandafter\CF@expadd@tocs\expandafter\CF@tmp@str\expandafter{\expandafter\expandafter\expandafter{\expandafter\CF@sanitize@lastitem#3,\@empty\@nil}}%
	\CF@tmp@str
}

% #1, #4 : nom des nodes    #2, #5 : ancres des nodes    #3, #6 : styles des nodes
% #7 : angle fl\`eche    #8 : longueur fl\`eche    #9 : style tikz de la fl\`eche
\CF@def\CF@arrow@e(#1.#2[#3]--#4.#5[#6])#7#8#9{%
	\let\CF@arrow@current@style\CF@arrow@style
	\if\CF@arobas\expandafter\@car\detokenize{#1.}\@nil% si #1 commence par @
		\if\CF@arobas\expandafter\@car\detokenize{#4.}\@nil
			\CF@expadd@tocs\CF@direct@arrow@list{\expandafter\CF@direct@arrow\expandafter{\CF@current@arrowtype}{#1}{#2}{#4}{#5}{#9}}%
			\let\CF@next@action\CF@schemestart@c
		\else
			\CF@doifnotempty\CF@arrow@current@style{\CF@add@tocs\CF@arrow@current@style,}%
			\CF@doifnotempty{#9}{\CF@add@tocs\CF@arrow@current@style{#9,}}%
			\CF@display@compound{}{#3}%
			\def\CF@next@nodename{#4}%
			\CF@exp@second{\def\CF@current@nodename}{\@gobble#1}%
			\let\CF@arrow@start@name\CF@current@nodename
			\let\CF@arrow@end@name\CF@next@nodename
			\CF@arrow@f{#7}{#8}{#2}{#5}%
			\def\CF@next@nodestyle{#6}%
		\fi
	\else
		\CF@doifnotempty\CF@arrow@current@style{\CF@add@tocs\CF@arrow@current@style,}%
		\CF@doifnotempty{#9}{\CF@add@tocs\CF@arrow@current@style{#9,}}%
		\if\CF@arobas\expandafter\@car\detokenize{#2.}\@nil
			\errmessage{Package \CF@package@name\space Error: syntax "(<name>--@<name>)" is not allowed}%
		\else
			\CF@display@compound{#1}{#3}%
			\edef\CF@arrow@start@name{\CF@ifempty{#1}\CF@current@nodename{#1}\CF@doifnotempty{#2}{.#2}}%
			\CF@arrow@f{#7}{#8}{#2}{#5}%
			\def\CF@next@nodename{#4}%
			\def\CF@next@nodestyle{#6}%
		\fi
	\fi
	\CF@arrow@gobspaces% mange les espaces puis ex\'ecute \CF@next@action
}

\CF@def\CF@arrow@gobspaces{\futurelet\CF@toks@a\CF@arrow@gobspaces@a}

\CF@def\CF@arrow@gobspaces@a{%
	\CF@ifx\@sptoken\CF@toks@a
		\CF@arrow@gobspaces@b
		\CF@next@action
}

\expandafter\def\expandafter\CF@arrow@gobspaces@b\space{\futurelet\CF@toks@a\CF@arrow@gobspaces@a}

\CF@def\CF@arrow@f#1#2#3#4{% #1=angle   #2=longueur    #3=ancre d\'epart   #4=ancre arriv\'ee
	\def\CF@next@action{\let\CF@compound\@empty\CF@schemestart@c}%
	\def\CF@arrow@current@angle{#1}\CF@doifempty\CF@arrow@current@angle{\let\CF@arrow@current@angle\CF@arrow@angle}%
	\def\CF@current@arrow@length{#2}\CF@doifempty\CF@current@arrow@length{\let\CF@current@arrow@length\CF@arrow@length}%
	\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@current@arrow@length*\CF@compound@sep),cyan,fill](end@arrow@i@\number\CF@scheme@nest){};%
	\edef\CF@arrow@end@name{end@arrow@i@\number\CF@scheme@nest\CF@doifnotempty{#4}{.#4}}%
	\ifCF@reac@debug
		\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@arrow@offset),red,fill](start@arrow){};%
		\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@current@arrow@length*\CF@compound@sep-\CF@arrow@offset),red,fill](end@arrow){};%
	\else
		\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@arrow@offset)](start@arrow){};%
		\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@current@arrow@length*\CF@compound@sep-\CF@arrow@offset)](end@arrow){};%
	\fi
	\def\CF@arrow@start@node{start@arrow}\def\CF@arrow@end@node{end@arrow}%
	\csname\expandafter\CF@grab@arrow@name\CF@current@arrowtype[\@nil\CF@three@ea\endcsname
		\expandafter\CF@grab@arrow@args\CF@current@arrowtype[]\@nil[][][][][][][][]\@nil
	\def\CF@current@nodename{end@arrow@i@\number\CF@scheme@nest}%
	\edef\CF@next@nodeanchor{\CF@ifempty{#4}{180+\CF@arrow@current@angle}{#4}}%
}

% trace un fl\`eche initi\'ee par (@nom--@nom)
% #1=type de fl\`eche   #2=nom depart   #3=ancre d\'epart    #4=nom arriv\'ee    #5=ancre arriv\'ee    #6=style fl\`eche
\CF@def\CF@direct@arrow#1#2#3#4#5#6{%
	\CF@exp@second{\def\CF@arrow@start@name}{\@gobble#2}%
	\CF@exp@second{\def\CF@arrow@end@name}{\@gobble#4}%
	\path[sloped,allow upside down](\@gobble#2\ifx\@empty#3\@empty\else.#3\fi)--(\@gobble#4\ifx\@empty#5\@empty\else.#5\fi)%
		coordinate[pos=0,xshift=\CF@arrow@offset](start@direct@arrow)%
		coordinate[pos=1,xshift=-\CF@arrow@offset](end@direct@arrow);%
	\def\CF@arrow@start@node{start@direct@arrow}%
	\def\CF@arrow@end@node{end@direct@arrow}%
	\pgfmathanglebetweenpoints
		{\pgfpointanchor{\@gobble#2}{\ifx\@empty#3\@empty center\else#3\fi}}% Ne pas utiliser \CF@ifempty ici !!!
		{\pgfpointanchor{\@gobble#4}{\ifx\@empty#5\@empty center\else#5\fi}}%
	\let\CF@arrow@current@angle\pgfmathresult
	\CF@doifnotempty{#6}{\CF@add@tocs\CF@arrow@current@style{#6,}}%
	\csname\CF@grab@arrow@name#1[]\@nil\expandafter\endcsname\CF@grab@arrow@args#1[]\@nil[][][][][][][][]\@nil
}

\CF@def\CF@merge@grab@chardir#1[#2][#3]#4\@nil{%
	\expandafter\futurelet\expandafter\CF@toks@a\expandafter\CF@gobtonil\@car#1>\@nil\@nil
	\ifx>\CF@toks@a\def\CF@merge@angle{0}\def\CF@merge@extreme{xmax}\def\CF@merge@sign{+}\else
	\ifx<\CF@toks@a\def\CF@merge@angle{180}\def\CF@merge@extreme{xmin}\def\CF@merge@sign{-}\else
	\ifx^\CF@toks@a\def\CF@merge@angle{90}\def\CF@merge@extreme{ymax}\def\CF@merge@sign{+}\else
	\ifx v\CF@toks@a\def\CF@merge@angle{-90}\def\CF@merge@extreme{ymin}\def\CF@merge@sign{-}%
	\fi\fi\fi\fi
	\def\CF@merge@labelup{#2}\def\CF@merge@labeldo{#3}%
}

\CF@def\CF@merge#1({%
	\CF@merge@grab@chardir#1[][]\@nil
	\CF@merge@a(%
}

\CF@def\CF@merge@a#1--(#2){\@testopt{\CF@merge@b#1--(#2)}{}}

\CF@def\CF@merge@b#1--(#2)[#3]{%
	\CF@display@compound{}{}%
	\CF@parse@mergeopt#3,\@empty,\@empty,\@empty\@nil
	\def\CF@merge@xmax{-16383.99999pt}\let\CF@merge@ymax\CF@merge@xmax
	\def\CF@merge@xmin{16383.99999pt}\let\CF@merge@ymin\CF@merge@xmin
	\CF@merge@parse@nodelist#1(\relax)% calcule les maxi des positions
	\pgfmathsetmacro\CF@merge@extreme@result{\csname CF@merge@\CF@merge@extreme\endcsname\CF@merge@sign\CF@merge@fromcoeff*\CF@compound@sep}%
	\CF@merge@c#1(\relax)% trace les lignes entre les noeuds pr\'ec\'edents et la ligne de jonction
	\CF@exp@second{\def\CF@tmp@str}{\expandafter[\CF@merge@style,shorten <=0,shorten >=0,-]}%
	\if x\expandafter\@car\CF@merge@extreme\@nil
		\CF@add@tocs\CF@tmp@str{(\CF@merge@extreme@result pt,\CF@merge@ymax)--(\CF@merge@extreme@result pt,\CF@merge@ymin)}%
	\else
		\CF@add@tocs\CF@tmp@str{(\CF@merge@xmin,\CF@merge@extreme@result pt)--(\CF@merge@xmax,\CF@merge@extreme@result pt)}%
	\fi
	\expandafter\draw\CF@tmp@str node[pos=\CF@merge@splitcoeff](merge@point){}% trace la ligne de jonction
		node[at=(merge@point),shift=(\CF@merge@angle:\CF@compound@sep*\CF@merge@tocoeff-\CF@arrow@offset)](end@merge){}%
		node[at=(merge@point),shift=(\CF@merge@angle:\CF@compound@sep*\CF@merge@tocoeff)](end@merge@i){};%
	\let\CF@arrow@current@angle\CF@merge@angle
	\expandafter\draw\expandafter[\CF@merge@style,shorten <=0](merge@point)--(end@merge)%
		\expandafter\CF@arrow@display@label@a\expandafter{\CF@merge@labelup}{.5}+\expandafter\CF@arrow@display@label@a\expandafter{\CF@merge@labeldo}{.5}-;%
	\def\CF@current@nodename{end@merge@i}%
	\let\CF@tmp@str\@empty
	\CF@analyse@arrowarg{#2}%
	\expandafter\CF@merge@d\CF@tmp@str\@nil
}

\CF@def\CF@merge@c(#1){%
	\if\relax\expandafter\noexpand\@car#1\@nil
	\else
		\CF@if@stop{#1}%
			{\edef\merge@current@nodename{\CF@before@stop#1\@nil}\edef\merge@current@anchor{\CF@after@stop#1\@nil}}%
			{\def\merge@current@nodename{#1}\let\merge@current@anchor\CF@merge@angle}%
		\if x\expandafter\@car\CF@merge@extreme\@nil
			\pgfextracty\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
			\expandafter\draw\expandafter[\CF@merge@style,shorten >=0,-]([shift=(\CF@merge@angle:\CF@arrow@offset)]\merge@current@nodename.\merge@current@anchor)--(\CF@merge@extreme@result pt,\CF@dim);%
		\else
			\pgfextractx\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
			\expandafter\draw\expandafter[\CF@merge@style,shorten >=0,-]([shift=(\CF@merge@angle:\CF@arrow@offset)]\merge@current@nodename.\merge@current@anchor)--(\CF@dim,\CF@merge@extreme@result pt);%
		\fi
		\expandafter\CF@merge@c
	\fi
}

\CF@def\CF@merge@d#1.#2[#3]\@nil{%
	\def\CF@next@nodename{#1}%
	\edef\CF@next@nodeanchor{\CF@ifempty{#2}{180+\CF@merge@angle}{#2}}%
	\def\CF@next@nodestyle{#3}%
	\let\CF@compound\@empty
	\CF@schemestart@c
}

\CF@def\CF@parse@mergeopt#1,#2,#3,#4\@nil{%
	\CF@ifempty{#1}{\def\CF@merge@fromcoeff{0.5}}{\def\CF@merge@fromcoeff{#1}}%
	\CF@exp@second{\def\CF@merge@tocoeff}{#2}\CF@doifempty\CF@merge@tocoeff{\def\CF@merge@tocoeff{0.5}}%
	\CF@exp@second{\def\CF@merge@splitcoeff}{#3}\CF@doifempty\CF@merge@splitcoeff{\def\CF@merge@splitcoeff{0.5}}%
	\def\CF@merge@style{-CF}\CF@doifnotempty{#4}{\CF@expadd@tocs\CF@merge@style{\expandafter,#4}}%
	\CF@twoexp@second{\def\CF@merge@style}{\expandafter\CF@sanitize@lastitem\CF@merge@style,\@empty\@nil}%
}

\CF@def\CF@merge@parse@nodelist(#1){%
	\if\relax\expandafter\noexpand\@car#1\@nil
	\else
		\CF@if@stop{#1}%
			{\edef\merge@current@nodename{\CF@before@stop#1\@nil}\edef\merge@current@anchor{\CF@after@stop#1\@nil}}%
			{\def\merge@current@nodename{#1}\let\merge@current@anchor\CF@merge@angle}%
		\pgfextractx\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
		\ifdim\CF@dim>\CF@merge@xmax\edef\CF@merge@xmax{\the\CF@dim}\fi
		\ifdim\CF@dim<\CF@merge@xmin\edef\CF@merge@xmin{\the\CF@dim}\fi
		\pgfextracty\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
		\ifdim\CF@dim>\CF@merge@ymax\edef\CF@merge@ymax{\the\CF@dim}\fi
		\ifdim\CF@dim<\CF@merge@ymin\edef\CF@merge@ymin{\the\CF@dim}\fi
		\expandafter\CF@merge@parse@nodelist
	\fi
}

\CF@def\CF@grab@arrow@name#1[#2\@nil{#1}
\CF@def\CF@grab@arrow@args#1[#2\@nil{[#2}

\CF@def\CF@make@parameter@text#1{%
	\toks\z@{}%
	\CF@cnt@groupnumber#1\relax
	\CF@make@parameter@text@a1%
}

\CF@def\CF@make@parameter@text@a#1{%
	\unless\ifnum#1>\CF@cnt@groupnumber
		\toks\z@\expandafter{\the\toks\z@[###1]}%
		\expandafter\CF@make@parameter@text@a\expandafter{\number\numexpr#1+1\expandafter}%
	\fi
}

% #1 est le nombre d'arguments optionnels, #2 est le nom et #3 le code
\CF@def\definearrow#1#2#3{%
	\begingroup
		\CF@make@parameter@text{#1}%
	\expandafter\endgroup
	\expandafter\def\csname\detokenize{#2}\expandafter\endcsname\the\toks\z@{#3\CF@gobtonil}%
}

\CF@def\CF@if@stop#1{\CF@if@stop@a#1.\@nil}
\CF@def\CF@if@stop@a#1.#2\@nil{\ifx\@empty#2\@empty\expandafter\@secondoftwo\else\expandafter\@firstoftwo\fi}
\CF@def\CF@before@stop#1.#2\@nil{#1}
\CF@def\CF@after@stop#1.#2\@nil{#2}

\CF@def\CF@rotate@node*#1#2\@nil{\CF@if@stop{#1}{\CF@before@stop#1\@nil}{#1}}
\CF@def\CF@anchor@node*#1#2\@nil#3{\CF@if@stop{#1}{\CF@after@stop#1\@nil}{\CF@arrow@current@angle-#390-#1}}

% #1 = label  #2 = position  #3 = + ou - (au dessus ou au dessous)  #4 : nom du noeud de d\'epart
% #5 = label  #6 = position  #7 = + ou - (au dessus ou au dessous)  #8 : nom du noeud de fin
\CF@def\CF@arrow@display@label#1#2#3#4#5#6#7#8{%
	\CF@doifnotempty{#1#5}
		{\path(#4)--(#8)\CF@arrow@display@label@a{#1}{#2}{#3}\CF@arrow@display@label@a{#5}{#6}{#7};}%
}

\CF@def\CF@arrow@display@label@a#1#2#3{%
	\CF@doifnotempty{#1}
		{\if*\expandafter\@car\detokenize{#1}\@nil
			\ifCF@reac@debug
				node[pos=#2,sloped,yshift=#3\CF@arrow@labelsep,draw,fill,cyan](shifted@node){}%
				node[draw,rotate=\CF@rotate@node#1\@nil,anchor=\CF@anchor@node#1\@nil#3,at=(shifted@node)]{\expandafter\@gobble\@gobble#1}%
			\else
				node[pos=#2,sloped,yshift=#3\CF@arrow@labelsep](shifted@node){}%
				node[rotate=\CF@rotate@node#1\@nil,anchor=\CF@anchor@node#1\@nil#3,at=(shifted@node)]{\expandafter\@gobble\@gobble#1}%
			\fi
		\else
			\ifCF@reac@debug
				node[pos=#2,sloped,yshift=#3\CF@arrow@labelsep,draw,fill,cyan](shifted@node){}%
				node[draw,pos=#2,anchor=-#390,sloped,yshift=#3\CF@arrow@labelsep]{#1}%
			\else
				node[pos=#2,anchor=-#390,sloped,yshift=#3\CF@arrow@labelsep]{#1}%
			\fi
		\fi
		}%
}

% pose des noeuds d\'ecal\'es de la dimension #1 \`a (\CF@arrow@start@node) et (\CF@arrow@end@node)
\CF@def\CF@arrow@shift@nodes#1{%
	\unless\ifdim\CF@ifempty{#1}\z@{#1}=\z@
		\edef\CF@tmp@str{%
			\noexpand\path(\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0,sloped,yshift=#1](\CF@arrow@start@node1){}node[pos=1,sloped,yshift=#1](\CF@arrow@end@node1){};}%
		\CF@tmp@str
		\edef\CF@arrow@start@node{\CF@arrow@start@node1}\edef\CF@arrow@end@node{\CF@arrow@end@node1}%
	\fi
}

\definearrow3{->}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node)--(\CF@arrow@end@node);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow3{<-}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@end@node)--(\CF@arrow@start@node);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow5{-/>}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node)--(\CF@arrow@end@node)%
		coordinate[midway,shift=(\CF@arrow@current@angle:-1pt)](midway@i)%
		coordinate[midway,shift=(\CF@arrow@current@angle:1pt)](midway@ii)%
		coordinate[at=(midway@i),shift=(\CF@ifempty{#4}{225}{#4+180}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@start)%
		coordinate[at=(midway@i),shift=(\CF@ifempty{#4}{45}{#4}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@end)%
		coordinate[at=(midway@ii),shift=(\CF@ifempty{#4}{225}{#4+180}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@start@i)%
		coordinate[at=(midway@ii),shift=(\CF@ifempty{#4}{45}{#4}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@end@i);
	\draw(line@start)--(line@end);%
	\draw(line@start@i)--(line@end@i);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow3{<->}{%
	\CF@arrow@shift@nodes{#3}%
	\path(\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0.5,sloped,xshift=-1pt](\CF@arrow@start@node1){}node[pos=0.5,sloped,xshift=1pt](\CF@arrow@end@node1){};%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node1)--(\CF@arrow@end@node);%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@end@node1)--(\CF@arrow@start@node);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow3{<=>}{%
	\CF@arrow@shift@nodes{#3}%
	\path[allow upside down](\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0,sloped,yshift=1pt](\CF@arrow@start@node @u0){}%
			node[pos=0,sloped,yshift=-1pt](\CF@arrow@start@node @d0){}%
			node[pos=1,sloped,yshift=1pt](\CF@arrow@start@node @u1){}%
			node[pos=1,sloped,yshift=-1pt](\CF@arrow@start@node @d1){};%
	\begingroup
		\pgfarrowharpoontrue
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @u0)--(\CF@arrow@start@node @u1);%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @d1)--(\CF@arrow@start@node @d0);%
	\endgroup
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node%
}

\definearrow3{<->>}{%
	\CF@arrow@shift@nodes{#3}%
	\path[allow upside down](\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0,sloped,yshift=1pt](\CF@arrow@start@node @u0){}%
			node[pos=0.2,sloped,yshift=-1pt](\CF@arrow@start@node @d0){}%
			node[pos=1,sloped,yshift=1pt](\CF@arrow@start@node @u1){}%
			node[pos=0.8,sloped,yshift=-1pt](\CF@arrow@start@node @d1){};%
	\begingroup
		\pgfarrowharpoontrue
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @u0)--(\CF@arrow@start@node @u1);%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @d1)--(\CF@arrow@start@node @d0);%
	\endgroup
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node%
}

\definearrow3{<<->}{%
	\path[allow upside down](\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0.2,sloped,yshift=1pt](\CF@arrow@start@node @u0){}%
			node[pos=0,sloped,yshift=-1pt](\CF@arrow@start@node @d0){}%
			node[pos=0.8,sloped,yshift=1pt](\CF@arrow@start@node @u1){}%
			node[pos=1,sloped,yshift=-1pt](\CF@arrow@start@node @d1){};%
	\begingroup
		\pgfarrowharpoontrue
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @u0)--(\CF@arrow@start@node @u1);%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @d1)--(\CF@arrow@start@node @d0);%
	\endgroup
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow30{%
	\CF@arrow@shift@nodes{#3}%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow5{-U>}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node)--(\CF@arrow@end@node)node[midway](Uarrow@arctangent){};%
	\CF@ifempty{#4}
		{\def\CF@Uarrow@radius{0.333}}
		{\def\CF@Uarrow@radius{#4}}%
	\CF@ifempty{#5}%
		{\def\CF@Uarrow@absangle{60}}
		{\pgfmathsetmacro\CF@Uarrow@absangle{abs(#5)}}% ne prendre en compte que la valeur absolue de l'angle
	\edef\CF@tmp@str{[\CF@ifempty{#1}{draw=none}{\unexpanded\expandafter{\CF@arrow@current@style}},-]}%
	\expandafter\draw\CF@tmp@str (Uarrow@arctangent)%
		arc[radius=\CF@compound@sep*\CF@current@arrow@length*\CF@Uarrow@radius,start angle=\CF@arrow@current@angle-90,delta angle=-\CF@Uarrow@absangle]node(Uarrow@start){};
	\edef\CF@tmp@str{[\CF@ifempty{#2}{draw=none}{\unexpanded\expandafter{\CF@arrow@current@style}}]}%
	\expandafter\draw\CF@tmp@str (Uarrow@arctangent)%
		arc[radius=\CF@compound@sep*\CF@current@arrow@length*\CF@Uarrow@radius,start angle=\CF@arrow@current@angle-90,delta angle=\CF@Uarrow@absangle]node(Uarrow@end){};
	\pgfmathsetmacro\CF@tmp@str{\CF@Uarrow@radius*cos(\CF@arrow@current@angle)<0?"-":"+"}%
	\ifdim\CF@Uarrow@radius pt>\z@
		\CF@arrow@display@label{#1}{0}\CF@tmp@str{Uarrow@start}{#2}{1}\CF@tmp@str{Uarrow@end}%
	\else
		\CF@arrow@display@label{#2}{0}\CF@tmp@str{Uarrow@start}{#1}{1}\CF@tmp@str{Uarrow@end}%
	\fi
}

\pgfdeclarearrow{%
	name = CF,%
	defaults = {%
		length  = 3pt 5 1,%
		width'  = 0pt .8,%
		inset'  = 0pt .5,%
		line width = 0pt 1 1,%
		round%
	},%
	setup code = {%
		% Cap the line width at 1/4th distance from inset to tip
		\pgf@x\pgfarrowlength
		\advance\pgf@x by-\pgfarrowinset
		\pgf@x.25\pgf@x
		\ifdim\pgf@x<\pgfarrowlinewidth\pgfarrowlinewidth\pgf@x\fi
		% Compute front miter length:
		\pgfmathdivide@{\pgf@sys@tonumber\pgfarrowlength}{\pgf@sys@tonumber\pgfarrowwidth}%
		\let\pgf@temp@quot\pgfmathresult%
		\pgf@x\pgfmathresult pt%
		\pgf@x\pgfmathresult\pgf@x%
		\pgf@x4\pgf@x%
		\advance\pgf@x by1pt%
		\pgfmathsqrt@{\pgf@sys@tonumber\pgf@x}%
		\pgf@xc\pgfmathresult\pgfarrowlinewidth% xc is front miter
		\pgf@xc.5\pgf@xc
		\pgf@xa\pgf@temp@quot\pgfarrowlinewidth% xa is extra harpoon miter
		% Compute back miter length:
		\pgf@ya.5\pgfarrowwidth%
		\csname pgfmathatan2@\endcsname{\pgfmath@tonumber\pgfarrowlength}{\pgfmath@tonumber\pgf@ya}%
		\pgf@yb\pgfmathresult pt%
		\csname pgfmathatan2@\endcsname{\pgfmath@tonumber\pgfarrowinset}{\pgfmath@tonumber\pgf@ya}%
		\pgf@ya\pgfmathresult pt%
		\advance\pgf@yb by-\pgf@ya%
		\pgf@yb.5\pgf@yb% half angle in yb
		\pgfmathtan@{\pgf@sys@tonumber\pgf@yb}%
		\pgfmathreciprocal@{\pgfmathresult}%
		\pgf@yc\pgfmathresult\pgfarrowlinewidth%
		\pgf@yc.5\pgf@yc%
		\advance\pgf@ya by\pgf@yb%
		\pgfmathsincos@{\pgf@sys@tonumber\pgf@ya}%
		\pgf@ya\pgfmathresulty\pgf@yc% ya is the back miter
		\pgf@yb\pgfmathresultx\pgf@yc% yb is the top miter
		\ifdim\pgfarrowinset=\z@
			\pgf@ya.5\pgfarrowlinewidth% easy: back miter is half linewidth
		\fi
		% Compute inset miter length:
		\pgfmathdivide@{\pgf@sys@tonumber\pgfarrowinset}{\pgf@sys@tonumber\pgfarrowwidth}%
		\let\pgf@temp@quot\pgfmathresult%
		\pgf@x\pgfmathresult pt%
		\pgf@x\pgfmathresult\pgf@x%
		\pgf@x4\pgf@x%\pgf@ya
		\advance\pgf@x by1pt%
		\pgfmathsqrt@{\pgf@sys@tonumber\pgf@x}%
		\pgf@yc\pgfmathresult\pgfarrowlinewidth% yc is inset miter
		\pgf@yc.5\pgf@yc% 
		% Inner length (pgfutil@tempdima) is now arrowlength - front miter - back miter
		\pgfutil@tempdima\pgfarrowlength%
		\advance\pgfutil@tempdima by-\pgf@xc%
		\advance\pgfutil@tempdima by-\pgf@ya%
		\pgfutil@tempdimb.5\pgfarrowwidth%
		\advance\pgfutil@tempdimb by-\pgf@yb%
		% harpoon miter correction
		\ifpgfarrowroundjoin
			\pgfarrowssetbackend{\pgf@ya\advance\pgf@x by-.5\pgfarrowlinewidth}%
		\else
			\pgfarrowssetbackend{0pt}
		\fi
		\ifpgfarrowharpoon
			\pgfarrowssetlineend{\pgfarrowinset\advance\pgf@x by\pgf@yc\advance\pgf@x by.5\pgfarrowlinewidth}%
		\else
			\pgfarrowssetlineend{\pgfarrowinset\advance\pgf@x by\pgf@yc\advance\pgf@x by-.25\pgfarrowlinewidth}%
			\ifpgfarrowreversed
				\ifdim\pgfinnerlinewidth>0pt
					\pgfarrowssetlineend{\pgfarrowinset}%
				\else
					\pgfarrowssetlineend{\pgfutil@tempdima\advance\pgf@x by\pgf@ya\advance\pgf@x by-.25\pgfarrowlinewidth}%
				\fi
			\fi
		\fi
		\ifpgfarrowroundjoin
			\pgfarrowssettipend{\pgfutil@tempdima\advance\pgf@x by\pgf@ya\advance\pgf@x by.5\pgfarrowlinewidth}%
		\else
			\pgfarrowssettipend{\pgfarrowlength\ifpgfarrowharpoon\advance\pgf@x by\pgf@xa\fi}%
		\fi
		% The hull:
		\pgfarrowshullpoint{\pgfarrowlength\ifpgfarrowroundjoin\else\ifpgfarrowharpoon\advance\pgf@x by\pgf@xa\fi\fi}{\ifpgfarrowharpoon-.5\pgfarrowlinewidth\else0pt\fi}%
		\pgfarrowsupperhullpoint{0pt}{.5\pgfarrowwidth}%
		\pgfarrowshullpoint{\pgfarrowinset}{\ifpgfarrowharpoon-.5\pgfarrowlinewidth\else 0pt\fi}%
		% Adjust inset
		\pgfarrowssetvisualbackend{\pgfarrowinset}%
		\advance\pgfarrowinset by\pgf@yc%
		% The following are needed in the code:
		\pgfarrowssavethe\pgfutil@tempdima
		\pgfarrowssavethe\pgfutil@tempdimb
		\pgfarrowssavethe\pgfarrowlinewidth
		\pgfarrowssavethe\pgf@ya
		\pgfarrowssavethe\pgfarrowinset
	},%
	drawing code = {%
		\pgfsetdash{}{0pt}%
		\ifpgfarrowroundjoin\pgfsetroundjoin\else\pgfsetmiterjoin\fi
		\ifdim\pgfarrowlinewidth=\pgflinewidth\else\pgfsetlinewidth{\pgfarrowlinewidth}\fi
		\pgfpathmoveto{\pgfqpoint{\pgfutil@tempdima\advance\pgf@x by\pgf@ya}{0pt}}%
		\pgfpathlineto{\pgfqpoint{\pgf@ya}{\pgfutil@tempdimb}}%
		\pgfpathlineto{\pgfqpoint{\pgfarrowinset}{0pt}}%
		\ifpgfarrowharpoon \else
			\pgfpathlineto{\pgfqpoint{\pgf@ya}{-\pgfutil@tempdimb}}%
		\fi
		\pgfpathclose
		\ifpgfarrowopen\pgfusepathqstroke\else\ifdim\pgfarrowlinewidth>0pt \pgfusepathqfillstroke\else\pgfusepathqfill\fi\fi
	},%
	parameters = {%
		\the\pgfarrowlinewidth,%
		\the\pgfarrowlength,%
		\the\pgfarrowwidth,%
		\the\pgfarrowinset,%
		\ifpgfarrowharpoon h\fi%
		\ifpgfarrowopen o\fi%
		\ifpgfarrowroundjoin j\fi%
	}%
}

\chemfigrestorecatcode

\endinput

######################################################################
#                             Historique                             #
######################################################################

v0.1        2010/06/23
    - Premi\`ere version publique sur le CTAN
----------------------------------------------------------------------
v0.2        2010/08/31
    - Ajout de la documentation en anglais.
    - Correction de bugs.
    - \printatom est d\'esormais une macro publique.
    - Les espaces sont permis dans les mol\'ecules. Ils seront
      ignor\'es par d\'efaut puisque les atomes sont compos\'es en
      mode math par \printatom
    - Une paire de Lewis peut \^etre repr\'esent\'ee ":".
    - Dans les cycles, une correction de la longueur du trait
      d\'eport\'e des liaisons doubles est fait de telle sorte que si
      l'on \'ecrit \chemfig{*5(=====)}, on obtient deux polygones
      r\'eguliers concentriques.
    - La s\'equence de contr\^ole \setnodestyle permet de sp\'ecifier
      le style des noeuds dessin\'es par tikz.
----------------------------------------------------------------------
v0.3        2010/11/21
    - Am\'elioration de \definesubmol qui accepte les s\'equences de
      contr\^ole. On peut aussi choisir un alias dont la substitution
      est diff\'erente selon l'orientation de la liaison qui lui
      arrive dessus.
    - Le caract\`ere "|" force la fin d'un atome. Si on \'ecrit
      "D|ef" alors, chemfig verra deux atomes "D" et "ef".
    - Le caract\`ere "#" est reconnu lorsqu'il suit un caract\`ere de
      liaison. Il doit \^etre suivi d'un argument entre parenth\`eses
      qui contient l'offset de d\'ebut et de fin qui s'appliqueront
      \`a cette liaison.
    - La macro \chemfig admet un argument optionnel qui sera pass\'e
      \`a l'environnement tikzpicture dans lequel elle est dessin\'ee
    - Mise en place de la repr\'esentation des m\'ecanismes
      r\'eactionnels avec la synatxe "@{<nom>}" devant un atome o\`u
      "@{<nom>,<coeff>}" au tout d\'ebut de l'argument d'une liaison.
      Cette syntaxe permet de placer un noeud (au sens de tikz) qui
      deviendra l'extr\'emit\'e des fl\`eches des m\'ecanismes.
      Le trac\'e des fl\`eches est faite par la macro \chemmove dont
      l'argument optionnel devient celui de l'environnement
      tikspicture dans lequel sont faites les fl\`eches.
    - Pour le m\'ecanisme d'alignement vertical via le \vphantom, la
      commande \chemskipalign permet d'ignorer le groupe d'atomes
      dans lequel elle est \'ecrite.
    - La commande \chemname permet d'afficher un nom sous une
      mol\'ecule. la commande \chemnameinit initialise la plus grande
      profondeur rencontr\'ee.
    - La commande \lewis a \'et\'e modifi\'ee de telle sorte que les
      dessins des d\'ecorations soient proportionnels \`a la taille
      de la police.
----------------------------------------------------------------------
v0.3a       2011/01/08
    - Correction d'un bug dans l'argument optionnel de \definesubmol
      lorsque celui-ci comporte des crochets.
    - Mise \`a jour du manuel en anglais.
    - Ajout de \vflipnext et \hflipnext pour retourner
      horizontalement ou verticalement la prochaine mol\'ecule.
----------------------------------------------------------------------
v0.4        2011/03/07
    - chemfig est d\'esormais \'ecrit en plain-etex et donc
      utilisable par d'autres formats que LaTeX.
    - Un peu plus de rigueur avec les catcodes des caract\`eres
      sp\'eciaux, notamment lorsque la commande \chemfig se trouve
      dans l'argument de \chemmove, \chemabove, \chembelow, \chemrel.
      TODO : faut-il \scantoker l'argument de \chemfig pour \^etre
      d\'efinitivement d\'ebarass\'e de ces histoires de catcode ???
    - Correction d'un bug dans le calcul de l'angle des liaisons
----------------------------------------------------------------------
v0.4a       2011/04/10
    - Correction d'un bug concernant l'argument optionnel en d\'ebut
      de mol\'ecule.
----------------------------------------------------------------------
v0.4b       2011/04/24
    - l'argument de \chemfig est tok\'enis\'e avec \scantokens ce qui
      rend caduc tout souci de code de cat\'egorie, \`a part #.
    - la commande \setbondstyle permet de d\'efinir le style des
      liaisons.
    - correction de l'affichage incorrect des doubles liaisons dans
      les cycles apr\`es les commandes \hflipnext et \vflipnext
    - correction d'un bug lorsqu'un alias commence une mol\'ecule
----------------------------------------------------------------------
v1.0       2011/06/15
    - les sch\'emas r\'eactionnels sont d\'esormais disponibles.
    - \Chemabove et \Chembelow modifient la boite englobante.
    - \Lewis modifie la boite englobante
    - les macros \chemleft, \chemright, \chemup et \chemdown
      affichent des d\'elimiteurs extensibles \`a gauche, \`a droite,
      au dessus et au dessous d'un mat\'eriel.
----------------------------------------------------------------------
v1.0a      2011/09/18
    - les macros \Lewis et \lewis admettent un argument optionnel
    - la macro \setlewisdist r\`egle la distance entre les 2
      \'electrons
----------------------------------------------------------------------
v1.0b      2011/11/29
    - la commande \merge est d\'esormais prot\'eg\'ee entre
      \schemestart et \schemestop contre des d\'efinitions par d'autres
      packages.
    - \box\z@ est utilis\'e au lieu du maladroit \unhbox\z@
----------------------------------------------------------------------
v1.0c      2011/11/30
    - la macro \+ n'est plus explicitement \'ecrite
    - v\'erifie que eTeX est le moteur utilis\'e
----------------------------------------------------------------------
v1.0d      2011/12/19
    - les cercles des cycles \'etaient trac\'es au mauvais moment. La
      longueur de la liaison qui les pr\'ec\'edait influait sur le
      rayon du cercle : \chemfig{-[,0.5]**6(------)} donnait un bug
      \`a l'affichage.
----------------------------------------------------------------------
v1.0e      2012/01/13
    - la gestion des espaces dans les groupes d'atomes est
      d\'esormais plus rigoureuse. Plusieurs bugs ont \'et\'e
      corrig\'e
----------------------------------------------------------------------
v1.0f      2012/02/24
    - correction d'un bug avec \definesubmol, les catcodes n'\'etaient
      pas correctement g\'er\'es.
----------------------------------------------------------------------
v1.0g      2012/11/16
    - correction d'un bug dans \CF@direct@arrow pour faire prendre en
      compte le style des fl\`eche par d\'efaut
    - correction d'un bug dans \CF@lewis@c : la boite *doit* \^etre
      compos\'ee en dehors de l'environnement tikzpicture pour
      \'eviter nullfont si jamais \printatom ne passe pas en mode
      math.
    - correction d'un bug dans \CF@chemfig@e : si une longueur par
      d\'efaut est modifi\'ee par [,<l>] au d\'ebut d'une mol\'ecule
      et si des cycles \'etaient emboit\'es, cette longueur n'\'etait
      pas appliqu\'ee aux sous-cycles.
    - r\'e-\'ecriture des macros \chemabove et \chembemow pour
      prendre en compte le bug (d\'esormais corrig\'e) dans luatex.
    - nouvelle macro \setstacksep qui d\'efinit l'espacement par
      d\'efaut dans les macros \chemabove et \chembelow.
----------------------------------------------------------------------
v1.0h      2013/11/28
    - \chemname admet maintenant une version \'etoil\'e qui ne tient
      pas compte des profondeurs pr\'ec\'edentes.
    - \CF@dp@max est g\'er\'e globalement.
    - correction d'un bug dans "-U>" : le style de la fl\`eche
      n'\'etait pris en compte pour l'arc.
    - correction d'un bug dans \CF@direct@arrow : l'angle de la
      fl\`eche n'\'etait pas calcul\'e
----------------------------------------------------------------------
v1.1       2015/02/13
    - correction d'un bug dans \CF@seek@submol : la macro
      \CF@remain@molecule est d\'epouill\'e de son \'eventuel espace
      en premi\`ere position.
    - correction d'un bug dans \CF@arrow@f : le nom du prochain
      noeud courant "end@arrow@i" \'etait erron\'e dans le cas o\`u une
      fl\`eche contenait un sous sch\'ema. Ce nom doit d\'ependre de
      \CF@scheme@nest.
    - la jonction entre deux liaisons cons\'ecutives dans l'axe peut
      \^etre activ\'e avec \enablebondjoin et d\'esactiv\'e avec
      \disablebondjoin (pr\'ef\'erable, \'etat par d\'efaut).
    - \chemfig suivi d'une "*" demande \`a ce que les liaisons aient
      une longueur invariable : la distance inter-atome devient donc
      variable. Cette fonctionnalit\'e est d\'esavctiv\'e dans les
      cycles afin que les polygones soient r\'eguliers.
      \enablefixedbondlength permet cette fonctionnalit\'e pour
      toutes les macros \chemfig (m\^eme non \'etoil\'ee) tandis que
      \disablefixedbondlength le d\'esactive.
----------------------------------------------------------------------
v1.1a      2015/02/23
    - correction d'un bug dans \CF@grab@bondoffset. Si \chemfig est
      dans l'argument d'une macro, les # sont doubl\'es par l'action
      de \scantokens de la macro \CF@chemfig@d et il faut un
      argument d\'elimit\'e avant "(" pour absorber tous les #.
----------------------------------------------------------------------
v1.2       2015/10/08
    - correction d'un bug dans le trac\'e des liaisons de Cram.
    - cr\'eation de \setangleincrement.
    - chargement de "arrows.meta" et d\'efinition de la fl\`eche "CF"
      bas\'ee sur "Stealth" et d\'efinie avec \pgfdeclarearrow.
      Les anciennes fl\`eches "CF@full" et "CF@half" sont
      abandonn\'ees puisque d\'efinies avec \pgfarrowsdeclare.
    - fl\`eche "-U>" corrige\'e : le placement des labels est
      maintenant correct dans tous les cas. Ainsi :
                         -U>[<a>][<b>][<d>][r][a]
      place le label <a> pr\`es du d\'ebut de la fl\`eche, quels que
      soient les signes du rayon r et de l'angle a.
    - \chemrel, \setchemrel et \chemsign sont supprim\'ees.
    - compatibilit\'e, avec les limitations d'usage, avec la
      librairie "externalize" : le \begin{tikzpicture} voit
      d\'esormais le \end correspondant dans la macro \CF@chemfig@d.
----------------------------------------------------------------------
v1.2a      2015/10/21
    - erreur de copier-coller dans le code: une adresse url \'etait
      malencontreusement pr\'esente en plein milieu d'une ligne de
      code
----------------------------------------------------------------------
v1.2b      2015/11/15
    - bug dans \CF@seek@submol qui laissait "*" dans le flux de
      lecture de TeX. Un message d'erreur est \'egalement ajout\'e
      en cas de "!" en fin de traitement.
    - correction d'un bug dans \CF@set@bondangle o\`u l'angle [<:a>]
      n'\'etait pas \'evalu\'e par \pgfmathsetmacro.
----------------------------------------------------------------------
v1.2c      2015/11/20
    - Correction d'un bug dans \CF@set@bondangle : l'angle renvoy\'e
      pouvait \^etre n\'egatif
    - Correction d'un bug dans \CF@direct@arrow : la macro \CF@ifempty
      n'est pas correctement d\'evelopp\'ee dans l'argument de
      \pgfpointanchor
----------------------------------------------------------------------
v1.2d      2015/12/01
    - correction d'un bug dans la fl\`eche "-U"
    - la version \'etoil\'ee de \setcrambond dessine les liaisons de
      Cram en pointill\'es sous forme de trait large et non pas sous
      forme de triangle.