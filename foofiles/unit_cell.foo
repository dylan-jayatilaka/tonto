!-------------------------------------------------------------------------------
!
! UNIT_CELL: Data structure for a crystal unit cell
!
! $Id: unit_cell.foo 4312 2014-03-22 08:31:20Z dylan_ $
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module UNIT_CELL

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object. This version does not nullify point parts.
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object. This version does not destroy pointer parts.
   end

!  ====
!  Copy
!  ====

   create_copy(unit_cell) ::: leaky
   ! Create a copy of "unit_cell"
      self :: PTR
      unit_cell :: UNIT_CELL, IN
      .create
      .copy(unit_cell)
   end

   copy(unit_cell)
   ! Set self to be "unit_cell"
      unit_cell :: UNIT_CELL, IN
      self = unit_cell
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: pure
   ! Set up a default crystal object
   ! NOTE: all in bohr/radian units
      self :: INOUT

      .angle        = HALF_PI
      .angle_error  = ZERO

      .length       = ONE
      .length_error = ZERO

      .volume       = -ONE
      .volume_error = ZERO

      .info_made    = FALSE

      .make_info

   end

   set_units_to(kind) ::: PURE
   ! Set the units of all parameters to the "kind" system
      self :: INOUT
      kind :: STR, IN

   ENSURE(kind.is_one_of(["cif","au "]),"unknown kind, "//trim(kind))

      fd,fa,f1,f3 :: REAL

      fd = STR:conversion_factor("degree")
      fa = STR:conversion_factor("angstrom")
      f3 = STR:conversion_factor("angstrom^3")
      f1 = STR:conversion_factor("angstrom^-1")

      select case (kind)

         case ("cif")

            .angle             = .angle*fd
            .angle_error       = .angle_error*fd

            .length            = .length*fa
            .length_error      = .length_error*fa

            .volume            = .volume*f3
            .volume_error      = .volume_error*f3

            .direct_matrix     = .direct_matrix*fa
            .inverse_matrix    = .inverse_matrix*f1
            .reciprocal_matrix = .reciprocal_matrix*f1

         case ("au")

            .angle             = .angle/fd
            .angle_error       = .angle_error/fd

            .length            = .length/fa
            .length_error      = .length_error/fa

            .volume            = .volume/f3
            .volume_error      = .volume_error/f3

            .direct_matrix     = .direct_matrix/fa
            .inverse_matrix    = .inverse_matrix/f1
            .reciprocal_matrix = .reciprocal_matrix/f1

      end

   end

!  ===============
!  Basic cell info
!  ===============

   alpha_angle result (res) ::: pure
   ! Return the alpha angle, in radians.
      self :: IN
      res :: REAL

      res = .angle(1)

   end

   beta_angle result (res) ::: pure
   ! Return the beta angle, in radians.
      self :: IN
      res :: REAL
      
      res = .angle(2)

   end

   gamma_angle result (res) ::: pure
   ! Return the gamma angle, in radians.
      self :: IN
      res :: REAL

      res = .angle(3)

   end

   alpha_star_angle result (res) ::: pure
   ! Return the alpha reciprocal lattice angle, in radians.
      self :: IN
      res :: REAL

      tmp,alpha,beta,gamma :: REAL

      alpha = .angle(1)
      beta  = .angle(2)
      gamma = .angle(3)

      tmp = (cos(beta)*cos(gamma)-cos(alpha))/(sin(beta)*sin(gamma))

      res = tmp.arccos

   end

   beta_star_angle result (res) ::: pure
   ! Return the beta reciprocal lattice angle, in radians.
      self :: IN
      res :: REAL

      tmp,alpha,beta,gamma :: REAL

      alpha = .angle(1)
      beta  = .angle(2)
      gamma = .angle(3)

      tmp = (cos(gamma)*cos(alpha)-cos(beta))/(sin(gamma)*sin(alpha))

      res = tmp.arccos

   end

   gamma_star_angle result (res) ::: pure
   ! Return the gamma reciprocal lattice angle, in radians.
      self :: IN
      res :: REAL

      tmp,alpha,beta,gamma :: REAL

      alpha = .angle(1)
      beta  = .angle(2)
      gamma = .angle(3)

      tmp = (cos(alpha)*cos(beta)-cos(gamma))/(sin(alpha)*sin(beta))

      res = tmp.arccos

   end

   a result (res) ::: pure
   ! Return the a cell length, in bohr.
      self :: IN
      res :: REAL

      res = .length(1) 

   end

   b result (res) ::: pure
   ! Return the b cell length, in bohr.
      self :: IN
      res :: REAL

      res = .length(2) 

   end

   c result (res) ::: pure
   ! Return the c cell length, in bohr.
      self :: IN
      res :: REAL

      res = .length(3) 

   end

   a_star result (res) ::: pure
   ! Return the a reciprocal lattice length, in bohr.
      self :: IN
      res :: REAL

      res = .length(2) * .length(3) * sin(.angle(1)) / .volume

   end

   b_star result (res) ::: pure
   ! Return the b reciprocal lattice length, in bohr.
      self :: IN
      res :: REAL

      res = .length(3) * .length(1) * sin(.angle(2)) / .volume

   end

   c_star result (res) ::: pure
   ! Return the c reciprocal lattice length, in bohr.
      self :: IN
      res :: REAL

      res = .length(1) * .length(2) * sin(.angle(3)) / .volume

   end

!  ==========================
!  Make cell axis/volume info
!  ==========================

   make_info ::: pure
   ! Calculate the various unit cell axis matrices.
      self :: INOUT

      .make_volume
      .make_direct_matrix
      .make_reciprocal_matrix
      .make_direct_U_matrix
      .make_reciprocal_U_matrix

      .info_made = TRUE

   end

   make_volume ::: pure, private
   ! Calculate the cell volume
      self :: INOUT

      a,b,c,ca,cb,cg :: REAL

      a = .length(1)
      b = .length(2)
      c = .length(3)

      ca = cos(.angle(1))
      cb = cos(.angle(2))
      cg = cos(.angle(3))

      .volume = a*b*c * sqrt(ONE - ca**2 - cb**2 - cg**2 + TWO*ca*cb*cg)

   end

   make_direct_matrix ::: pure, private
   ! Calculate the direct cell matrices (i.e. cell axes) in units of BOHRS.
      self :: INOUT

      v,a,b,c,ca,cb,cg,sg :: REAL

      a = .length(1)
      b = .length(2)
      c = .length(3)

      ca = cos(.angle(1))
      cb = cos(.angle(2))
      cg = cos(.angle(3))
      sg = sin(.angle(3))

      v = .volume

      ! Direct cell matrix
      ! From Giacovazzo, C., Fundamentals of Crystallography, p.68
      .direct_matrix(1,1) = a
      .direct_matrix(1,2) = b*cg
      .direct_matrix(1,3) = c*cb

      .direct_matrix(2,1) = ZERO
      .direct_matrix(2,2) = b*sg
      .direct_matrix(2,3) = c*(ca-cb*cg)/sg

      .direct_matrix(3,1) = ZERO
      .direct_matrix(3,2) = ZERO
      .direct_matrix(3,3) = v/(a*b*sg)

   end

   make_reciprocal_matrix ::: pure, private
   ! Calculate the reciprocal cell matrices (i.e. reciprocal cell axes) in units
   ! of 1/BOHRS. Also calculate the inverse direct cell matrix.
      self :: INOUT

      v,a,b,c,ca,cb,cg,sg :: REAL

      a = .length(1)
      b = .length(2)
      c = .length(3)

      ca = cos(.angle(1))
      cb = cos(.angle(2))
      cg = cos(.angle(3))
      sg = sin(.angle(3))

      v = .volume
      ! Reciprocal cell matrix
      ! From Giacovazzo, C., Fundamentals of Crystallography, p.68
      .reciprocal_matrix(1,1) = ONE/a
      .reciprocal_matrix(1,2) = ZERO
      .reciprocal_matrix(1,3) = ZERO

      .reciprocal_matrix(2,1) = -cg/(a*sg)
      .reciprocal_matrix(2,2) = 1/(b*sg)
      .reciprocal_matrix(2,3) = ZERO

      .reciprocal_matrix(3,1) = b*c*(ca*cg-cb)/v/sg
      .reciprocal_matrix(3,2) = a*c*(cb*cg-ca)/v/sg
      .reciprocal_matrix(3,3) = a*b*sg/v

      ! Inverse direct cell matrix
      .inverse_matrix = transpose(.reciprocal_matrix)

   end

   make_direct_U_matrix ::: pure, private
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system (the usual U reported in the cif
   ! file) into the cartesian axis system:  
   !   U_cart = (D L)^T U_cif (D L)
   ! where D is the direct cell matrix and L is the diagonal of
   ! reciprocal matrix lengths.
   ! See also comments for reciprocal_U_tensor_matrix below.
   ! See also Grosse-Kuntsleve and Adams, J. Appl. Cryst 35 p.477-480
      self :: INOUT

      len :: REAL
      i :: INT

      do i = 1,3
         len = .reciprocal_matrix(:,i).norm
         .direct_U_matrix(i,:) = .direct_matrix(:,i)*len
      end

   end

   make_reciprocal_U_matrix ::: pure, private
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   !   U_cif = (D* L^-1)^T U_cart (D* L^-1)
   ! where D*=(D^-1)^T is the reciprocal cell matrix and L is the
   ! diagonal of reciprocal matrix lengths.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal cell matrix.
   ! See also Grosse-Kuntsleve and Adams, J. Appl. Cryst 35 p.477-480
      self :: INOUT

      len :: REAL
      i :: INT

      do i = 1,3
         len = ONE/.reciprocal_matrix(:,i).norm
         .reciprocal_U_matrix(:,i) = .reciprocal_matrix(:,i)*len
      end

   end

!  ==========================
!  Geometry altering routines
!  ==========================

   change_from_fractional(g) ::: PURE
   ! Change the columns of geometry array "g" *from* crystal fractional
   ! coordinates into standard cartesian coordiantes
      self :: IN
      g :: MAT{REAL}, INOUT

   ENSURE(g.dim1==3,"dim1 is not 3")

      W :: MAT{REAL}*

      W.create_copy(g)

      g.to_product_of(.direct_matrix,W)

      W.destroy

   end

   change_into_fractional(g) ::: PURE
   ! Change the columns of geometry array "g" from standard cartesian
   ! coordinates *into* crystal fractional coordinates
      self :: IN
      g :: MAT{REAL}, INOUT

   ENSURE(g.dim1==3,"dim1 is not 3")

      W :: MAT{REAL}*

      W.create_copy(g)

      g.to_product_of(.inverse_matrix,W)

      W.destroy

   end

   change_from_fractional(p) ::: PURE
   ! Change the position "p" *from* crystal fractional coordinates into standard
   ! cartesian coordiantes
      self :: IN
      p :: VEC{REAL}(3), INOUT

      v :: VEC{REAL}(3)

      v = p
      p.to_product_of(.direct_matrix,v)

   end

   change_into_fractional(p) ::: PURE
   ! Change the position "p" from standard cartesian coordinates *into* crystal
   ! fractional coordinates
      self :: IN
      p :: VEC{REAL}(3), INOUT

      v :: VEC{REAL}(3)

      v = p
      p.to_product_of(.inverse_matrix,v)

   end


   change_ADP_from_fractional(ADP_vector) ::: PURE
   ! Change thermal parameters in the cartesian axis system to the
   ! crystal axis system
      self :: IN
      ADP_vector :: VEC{REAL}(6), INOUT

      U :: MAT{REAL}(3,3)

      U(1,1) = ADP_vector(1)
      U(2,2) = ADP_vector(2)
      U(3,3) = ADP_vector(3)
      U(1,2) = ADP_vector(4)
      U(1,3) = ADP_vector(5)
      U(2,3) = ADP_vector(6)
      U(2,1) = ADP_vector(4)
      U(3,1) = ADP_vector(5)
      U(3,2) = ADP_vector(6)

      U.change_basis_using(.direct_U_matrix)
      
      ADP_vector(1) = U(1,1)
      ADP_vector(2) = U(2,2)
      ADP_vector(3) = U(3,3)
      ADP_vector(4) = U(1,2)
      ADP_vector(5) = U(1,3)
      ADP_vector(6) = U(2,3)
      ADP_vector(4) = U(2,1)
      ADP_vector(5) = U(3,1)
      ADP_vector(6) = U(3,2)

   end

   change_ADP_into_fractional(ADP_vector) ::: PURE
   ! Change thermal parameters in the cartesian axis system to the
   ! crystal axis system
      self :: IN
      ADP_vector :: VEC{REAL}(6), INOUT

      U :: MAT{REAL}(3,3)

      U(1,1) = ADP_vector(1)
      U(2,2) = ADP_vector(2)
      U(3,3) = ADP_vector(3)
      U(1,2) = ADP_vector(4)
      U(1,3) = ADP_vector(5)
      U(2,3) = ADP_vector(6)
      U(2,1) = ADP_vector(4)
      U(3,1) = ADP_vector(5)
      U(3,2) = ADP_vector(6)

      U.change_basis_using(.reciprocal_U_matrix)
      
      ADP_vector(1) = U(1,1)
      ADP_vector(2) = U(2,2)
      ADP_vector(3) = U(3,3)
      ADP_vector(4) = U(1,2)
      ADP_vector(5) = U(1,3)
      ADP_vector(6) = U(2,3)
      ADP_vector(4) = U(2,1)
      ADP_vector(5) = U(3,1)
      ADP_vector(6) = U(3,2)

   end


!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword)
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                ")  ! exit read_loop
         case ("a=               "); .read_a
         case ("alpha=           "); .read_alpha
         case ("angles=          "); .read_angles
         case ("b=               "); .read_b
         case ("beta=            "); .read_beta
         case ("c=               "); .read_c
         case ("debug_on         "); .read_debug_on
         case ("debug_off        "); .read_debug_off
         case ("dimensions=      "); .read_lengths
         case ("gamma=           "); .read_gamma
         case ("junk=            "); .read_junk
         case ("lengths=         "); .read_lengths
         case ("put              "); .put
         case ("units=           "); .read_units
         case default;               UNKNOWN(word)
      end

      .update

   end


   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   update ::: pure
   ! Update the cell information
      self :: INOUT

      .make_info

   end

   read_lengths ::: private
   ! Read the unit cell axis lengths
      stdin.read_quantity(.length,.length_error)
   end

   read_a ::: private
   ! Read the a length
      self :: INOUT

      stdin.read_quantity(.length(1))

   end

   read_b ::: private
   ! Read the b length
      self :: INOUT

      stdin.read_quantity(.length(2))

   end

   read_c ::: private
   ! Read the c length
      self :: INOUT

      stdin.read_quantity(.length(3))

   end

   read_angles ::: private
   ! Read the unit cell angles
      self :: INOUT

      stdin.read_quantity(.angle,.angle_error)

   end

   read_alpha ::: private
   ! Read the alpha angle
      self :: INOUT

      stdin.read_quantity(.angle(1))

   end

   read_beta ::: private
   ! Read the beta angle
      self :: INOUT

      stdin.read_quantity(.angle(2))

   end

   read_gamma ::: private
   ! Read the gamma angle
      self :: INOUT

      stdin.read_quantity(.angle(3))

   end


   read_CIF(cif) 
   ! Read cell information from a CIF file "cif"
      self :: INOUT
      cif :: CIF, INOUT

      if (NOT cif.is_mmCIF) then
         .read_smCIF(cif)
      else
         .read_mmCIF(cif)
      end

   end

   read_smCIF(cif) 
   ! Read cell information from a small-molecule CIF file "cif"
      self :: INOUT
      cif :: CIF, INOUT

      found :: BIN

      ! Set defaults
      .set_defaults
      .set_units_to("cif")

      ! Read it in
      cif.read_item("_cell_angle_alpha",.angle(1),.angle_error(1),found)
      cif.read_item("_cell_angle_beta" ,.angle(2),.angle_error(2),found)
      cif.read_item("_cell_angle_gamma",.angle(3),.angle_error(3),found)

      cif.read_item("_cell_length_a",.length(1),.length_error(1),found)
      cif.read_item("_cell_length_b",.length(2),.length_error(2),found)
      cif.read_item("_cell_length_c",.length(3),.length_error(3),found)

      cif.read_item("_cell_volume",.volume,.volume_error,found)

      ! Convert to standard units
      .set_units_to("au")

      ! Calculate associated information
      .update

   end

   read_mmCIF(cif) 
   ! Read cell information from a macromolecular CIF file "cif"
      self :: INOUT
      cif :: CIF, INOUT

      found :: BIN

      ! Set defaults
      .set_defaults
      .set_units_to("cif")

      ! Read it in
      cif.read_item("_cell.angle_alpha",.angle(1),.angle_error(1),found)
      cif.read_item("_cell.angle_beta" ,.angle(2),.angle_error(2),found)
      cif.read_item("_cell.angle_gamma",.angle(3),.angle_error(3),found)

      cif.read_item("_cell.length_a",.length(1),.length_error(1),found)
      cif.read_item("_cell.length_b",.length(2),.length_error(2),found)
      cif.read_item("_cell.length_c",.length(3),.length_error(3),found)

      ! Seems for protein guiys, they can't be bothered
    ! cif.read_item("_cell.volume",.volume,.volume_error,found)

      ! Convert to standard units
      .set_units_to("au")

      ! Calculate associated information
      .update

   end

!  ==========================
!  Local field factor tensors
!  ==========================

   make_LFF_tensors(L2,pos)
   ! Make the local field factor tensor "L2" at a series of unit cell
   ! positions "pos" (in cartesian coordinates). These tell what the
   ! electric field is at a certain position k1 when there is a dipole
   ! at position k2 in the unit cell and all translationally
   ! equivalent cells, F = L2(:,:,k1k2) mu(:). The last index of "L2"
   ! is a triangle index. This uses formula in ref:
   ! Cummins et al (1976), Acta Cryst A32, p. 847
      L2 :: MAT3{REAL}, OUT
      pos :: MAT{REAL}, IN

   ENSURE(L2.dim1==3 AND L2.dim2==3,"L2 must be 3x3")
   ENSURE(pos.dim1==3,"pos must have first dimension 3")

      L,L0,G,H :: MAT{REAL}(3,3)
    ! t1,t2 :: MAT{REAL}(3,3)
      r,r0,q,hv :: VEC{REAL}(3)
      k,k1,k2,m,h1,h2,h3 :: INT
      v13,vr,vq,dot :: REAL

      v13 = .volume**(THIRD)
      vr  = SQRT_PI/v13
      vq  = SQRT_PI*v13

      k = 0
      do k1 = 1,pos.dim2
      do k2 = 1,k1

         k = k + 1
         r0 = vr*(pos(:,k2) - pos(:,k1))

         if (k1==k2) then
            L0.to_unit_matrix
            L0 = THIRD*L0
         else
            UNIT_CELL::make_LFF_h_tensor(r0,H)
            L0 = H
         end


         m = 0

         do ! until converged

            m = m + 1

            L = ZERO

            do h1 = -m,m,2*m
            do h2 = -m,m
            do h3 = -m,m
               hv = [h1,h2,h3]
               r.to_scaled_product_of(.direct_matrix,hv,vr)
               r = r + r0
               q.to_scaled_product_of(.reciprocal_matrix,hv,vq)
               UNIT_CELL::make_LFF_h_tensor(r,H)
               UNIT_CELL::make_LFF_g_tensor(q,G)
               dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
               L = L + H - G*cos(TWO*dot)
            end
            end
            end

            do h1 = -m+1,m-1
            do h2 = -m,m,2*m
            do h3 = -m,m
               hv = [h1,h2,h3]
               r.to_scaled_product_of(.direct_matrix,hv,vr)
               r = r + r0
               q.to_scaled_product_of(.reciprocal_matrix,hv,vq)
               UNIT_CELL::make_LFF_h_tensor(r,H)
               UNIT_CELL::make_LFF_g_tensor(q,G)
               dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
               L = L + H - G*cos(TWO*dot)
            end
            end
            end

            do h1 = -m+1,m-1
            do h2 = -m+1,m-1
            do h3 = -m,m,2*m
               hv = [h1,h2,h3]
               r.to_scaled_product_of(.direct_matrix,hv,vr)
               r = r + r0
               q.to_scaled_product_of(.reciprocal_matrix,hv,vq)
               UNIT_CELL::make_LFF_h_tensor(r,H)
               UNIT_CELL::make_LFF_g_tensor(q,G)
               dot = q(1)*r0(1) + q(2)*r0(2) + q(3)*r0(3)
               L = L + H - G*cos(TWO*dot)
            end
            end
            end

            L0 = L0 + L
            if (maxval(abs(L))<TOL(10)) exit

         end

         L2(:,:,k) = L0

      end
      end

   end

   make_LFF_h_tensor(r,h2) ::: selfless, private
   ! Make the local field factor H tensors. See appendix of:
   ! Cummins et al (1976), Acta Cryst A32, p. 847
      r :: VEC{REAL}(3), IN
      h2 :: MAT{REAL}(3,3), OUT

      a,b :: INT
      r1,r2,rm1,rm2,rm5,faa,fab,f1,f2 :: REAL
      exmr2,erfcr,sqpi2,ra,rb,rab :: REAL

      ! Temporary variables related to R
      r2  = r(1)*r(1) + r(2)*r(2) + r(3)*r(3)
      r1  = sqrt(r2)
      rm1 = ONE/r1
      rm2 = rm1*rm1
      rm5 = rm2*rm2*rm1

      ! Inverse R sums, including exponential term
      f1 =  rm2
      f2 =  rm2*(3*f1 + 2)
      exmr2 = HALF*exp(-r2)
      f1 = f1*exmr2
      f2 = f2*exmr2

      ! Complementary erf term
      erfcr = r1.erfc
      sqpi2 = SQRT_PI*QUARTER*erfcr*rm5

      ! These are for h2
      faa = -f1 - r2*sqpi2
      fab =  f2 +  3*sqpi2

      ! Now make the h tensors ...
      h2 = ZERO

      do a = 1,3
         ra = r(a)
         do b = 1,3
            rb = r(b)
            rab = ra*rb
            h2(a,b) = h2(a,b) + fab*rab
         end
         h2(a,a) = h2(a,a) + faa
      end
      
   end

   make_LFF_g_tensor(q,g2) ::: selfless, private
   ! Make the local field factor tensor. See appendix of:
   ! Cummins et al (1976), Acta Cryst A32, p. 847
      q :: VEC{REAL}(3), IN
      g2 :: MAT{REAL}(3,3), OUT

      a,b :: INT
      q2,qm2,exmq2,qa,qb,fab :: REAL

      q2  = q(1)*q(1) + q(2)*q(2) + q(3)*q(3)
      qm2 = ONE/q2

      exmq2 = exp(-q2)

      fab = qm2*exmq2

      do a = 1,3
         qa = q(a)
         do b = 1,3
            qb = q(b)
            g2(a,b) = qa*qb*fab
         end
      end
      
   end

!   make_LFF_h_tensors(r,h2,h3,h4)
!   ! Make the local field factor tensors. 
!      r :: VEC{REAL}(3), IN
!      h2 :: MAT{REAL}(3,3), OUT
!      h3 :: MAT3{REAL}(3,3,3), OUT
!      h4 :: MAT4{REAL}(3,3,3,3), OUT
!
!      a,b,c,d :: INT
!      r1,r2,rm1,rm2,rm5,v13,v23,r13,r23 :: REAL
!      faa,fab,fabb,fabc,fabab,fabcc,fabcd :: REAL
!      f1,f2,f3,f4,exmr2,erfcr,sqpi2,val,tmp :: REAL
!      ra,rb,rc,rd,rab,rabc,rabcd :: REAL
!
!      ! Temporary variables related to R
!      r2  = r(1)*r(1) + r(2)*r(2) + r(3)*r(3)
!      r1  = sqrt(r2)
!      rm1 = ONE/r1
!      rm2 = rm1*rm1
!      rm5 = rm2*rm2*rm1
!
!      ! Temporary variables relatd to V
!      v13 = SQRT_PI*.volume**(-THIRD)
!      v23 = v13*v13
!      r13 = v13*rm2
!      r23 = r13*r13
!
!      ! Inverse R sums, including exponential term
!      f1 =  rm2
!      f2 =  rm2*(3*f1 + 2)
!      f3 =  rm2*(5*f2 + 4)
!      f4 =  rm2*(7*f3 + 8)
!      exmr2 = HALF*exp(-r2)
!      f1 = f1*exmr2
!      f2 = f2*exmr2
!      f3 = f3*exmr2
!      f4 = f4*exmr2
!
!      ! Complementary erf term
!      erfcr = r1.erfc
!      sqpi2 = SQRT_PI*QUARTER*erfcr*rm5
!
!      ! These are for h2
!      faa = -f1
!      fab =  f2
!      val = sqpi2
!      faa = faa - r2*val
!      fab = fab +  3*val
!
!      ! These are for h3
!      fabb =  f2*v13
!      fabc = -f3*v13
!      val = r13*sqpi2
!      fabb = fabb +  3*r2*val
!      fabc = fabc - 15*val
!
!      ! These are for h4
!      fabab =  f2*v23
!      fabcc = -f3*v23
!      fabcd =  f4*v23
!      val = r23*sqpi2
!      fabab = fabab +   3*r2*r2*val
!      fabcc = fabcc -  15*r2*val
!      fabcd = fabcd + 105*val
!
!      ! Now make the h tensors ...
!      h2 = ZERO
!      h3 = ZERO
!      h4 = ZERO
!
!      do a = 1,3
!         ra = r(a)
!         do b = 1,3
!            rb = r(b)
!            rab = ra*rb
!            h2(a,b) = h2(a,b) + fab*rab
!            do c = 1,3
!               rc = r(c)
!               rabc = rab*rc
!               h3(a,b,c) = h3(a,b,c) + fabc*rabc
!               do d = 1,3
!                  rd = r(d)
!                  rabcd = rabc*rd
!                  h4(a,b,c,d) = h4(a,b,c,d) + fabcd*rabcd
!               end
!               tmp = fabcc*rab
!               h4(a,b,c,c) = h4(a,b,c,c) + tmp
!               h4(a,c,b,c) = h4(a,c,b,c) + tmp
!               h4(a,c,c,b) = h4(a,c,c,b) + tmp
!               h4(c,a,b,c) = h4(c,a,b,c) + tmp
!               h4(c,a,c,b) = h4(c,a,c,b) + tmp
!               h4(c,c,a,b) = h4(c,c,a,b) + tmp
!            end
!            tmp = fabb*ra
!            h3(a,b,b) = h3(a,b,b) + tmp
!            h3(b,b,a) = h3(b,b,a) + tmp
!            h3(b,a,b) = h3(b,a,b) + tmp
!            h4(a,b,a,b) = h4(a,b,a,b) + fabab
!            h4(a,a,b,b) = h4(a,a,b,b) + fabab
!            h4(a,b,b,a) = h4(a,b,b,a) + fabab
!         end
!         h2(a,a) = h2(a,a) + faa
!      end
!      
!   end

!   make_LFF_g_tensors(q,g2,g3,g4)
!   ! Make the local field factor tensor.
!      q :: VEC{REAL}(3), IN
!      g2 :: MAT{REAL}(3,3), OUT
!      g3 :: MAT3{REAL}(3,3,3), OUT
!      g4 :: MAT4{REAL}(3,3,3,3), OUT
!
!      a,b,c,d :: INT
!      q2,qm2,exmq2,qa,qb,qc,qd,v13,fab,gab,gabc,gabcd :: REAL
!
!      q2  = q(1)*q(1) + q(2)*q(2) + q(3)*q(3)
!      qm2 = ONE/q2
!
!      v13 = TWO*SQRT_PI*.volume**(-THIRD)
!
!      exmq2 = exp(-q2)
!
!      fab = qm2*exmq2
!
!      do a = 1,3
!         qa = q(a)
!         do b = 1,3
!            qb = q(b)
!            gab = qa*qb*fab
!            g2(a,b) = gab
!            do c = 1,3
!               qc = q(c)
!               gabc = v13*qc*gab
!               g3(a,b,c) = gabc
!               do d = 1,3
!                  qd = q(d)
!                  gabcd = v13*qd*gabc
!                  g4(a,b,c,d) = gabc
!               end
!            end
!         end
!      end
!      
!   end

!   make_LFF_h1_tensor(h2,x,n)
!   ! Make the local field factor tensors from the formula in 
!   ! Reis (2000), JCP 112 p. 6161, Appendix B.
!      h2 :: MAT{REAL}(3,3), OUT
!      x :: VEC{REAL}(3), IN
!      n :: INT, IN
!
!      i,j :: INT
!      x1,x2,xm1,xm2,xm3,erfx,expx,fij,fii :: REAL
!
!      ! Temporary variables related to R
!      x2  = x(1)*x(1) + x(2)*x(2) + x(3)*x(3)
!      x1  = sqrt(x2)
!      xm1 = ONE/x1
!      xm3 = xm1*xm1*xm1
!
!      ! Complementary erf term
!      if (n==0) then; erfx = -x1.erf
!      else;           erfx =  x1.erfc
!      end
!
!      erfx  = xm3*erfx
!      expx  = xm2*TWO*exp(-x2)/SQRT_PI
!      fii   = -erfx - expx
!      fij   = THREE*xm2*erfx + (THREE*xm2+TWO)*expx
!
!      ! Now make the h tensors ...
!      h2 = ZERO
!      do i = 1,3
!         xi = x(i)
!         do j = 1,3
!            xj = x(j)
!            h2(i,j) = h2(i,j) + fij*xi*xj
!         end
!         h2(i,i) = h2(i,i) + fii
!      end
!      
!   end

   make_LFF_tensors(L0,L1,pos,mol_for,sphere_sum)
   ! Make the charge local field factor (LFF) tensor "L0" and the
   ! dipole LFF tensor "L1" at a series of cartesian cell positions
   ! "pos" (usually the atom positions).  "mol_for" gives the molecule
   ! that the position is attached to. These tensors give the electric
   ! field at position p1, due to a charge and dipole at another
   ! position p2 in the unit cell *and* at all translationally
   ! equivalent points. Thus:
   !           F(:) = L0(:,:) q(:) + L1(:,:) mu(:).  
   ! where F(:) are the fields at all the positions as a flattened
   ! vector, and q(:) and mu(:) are charges and dipoles also as
   ! flattened vectors.
   ! >>>> See: Reis (2000) JCP 112 p. 6161 Appendix B.
      L0,L1 :: MAT{REAL}, target, OUT
      pos :: MAT{REAL}, IN
      mol_for  :: VEC{INT}, IN
      sphere_sum :: BIN, optional

   ENSURE(L0.dim1==3*pos.dim2 AND L0.dim2==pos.dim2,"L0 wrong size")
   ENSURE(L1.dim1==3*pos.dim2 AND L1.is_square,"L1 wrong size")
   ENSURE(pos.dim1==3,"pos must have first dimension 3")
   ENSURE(pos.dim2==mol_for.dim,"pos and mol_for, incompatible")
   ENSURE(mol_for.dim1==pos.dim2,"mol_for wrong size")

      LL1 :: MAT{REAL}*
      LL0 :: VEC{REAL}*
      W1, H1,G1 :: MAT{REAL}(3,3)
      W0, r0,rt,yt, H0,G0, t :: VEC{REAL}(3)
      p1,p2,k1,k2,i,j,m,t1,t2,t3 :: INT
      v,v13,R,R2,iso,fd0,fd1,fy0,fy1,dot :: REAL
      same_mol,same_site,add_iso,add_H0,add_H1,sphere :: BIN

      ! See: Reis (2000) JCP 112 p. 6161 Appendix B.
      sphere = FALSE
      if (present(sphere_sum)) sphere = sphere_sum

      ! Cell volume constants
      v   = .volume                    
      v13 = v**(THIRD)

      ! Arbitrary convergence factor
      R   = SQRT_PI/v13                
      R2  = R*R                        

      ! Constants
      iso = v*R2*R/(THREE*PI*SQRT_PI)  
      fd0 = v*R2/(FOUR*PI)
      fd1 = R*fd0
      fy0 = HALF/R
      fy1 = PI/R

      i = -3
      do p1 = 1,pos.dim2

         ! Supermatrix first index
         i = i + 3

         ! Molecule point p1 belongs to
         k1 = mol_for(p1)              

         j = -3
         do p2 = 1,pos.dim2

            ! Supermatrix second index (L1 only)
            j = j + 3

            ! Molecule point p2 belongs to
            k2 = mol_for(p2)

            ! Delta functions 
            same_mol  = k1==k2
            same_site = p1==p2
            add_iso = (same_mol AND same_site) AND NOT sphere
            add_H0  = same_mol AND NOT same_site
            add_H1  = NOT same_mol

            ! Unit cell position difference
            r0 = R*(pos(:,p2) - pos(:,p1))

            ! The 3x1 and 3x3 submatrices
            LL0 => L0(i+1:i+3,p2);       LL0 = ZERO
            LL1 => L1(i+1:i+3,j+1:j+3);  LL1 = ZERO


            ! The isotropic part, only for L1
            if (add_iso) then
               LL1.to_unit_matrix
               LL1 = iso*LL1
            end

            ! The n=0 part
            if (add_H0) then
               UNIT_CELL::make_LFF_h_tensors(H0,H1,r0,n=0)
               LL0 = LL0 - fd0*H0
               LL1 = LL1 + fd1*H1
            end

            ! The l=0, n=1 part
            if (add_H1) then
               UNIT_CELL::make_LFF_h_tensors(H0,H1,r0,n=1)
               LL0 = LL0 - fd0*H0
               LL1 = LL1 + fd1*H1
            end

            ! The extent of the cubic lattice
            m = 0
   
            do ! until converged
   
               m = m + 1

               W0 = ZERO
               W1 = ZERO
   
               do t1 = -m,m,2*m
               do t2 = -m,m
               do t3 = -m,m
                  t  = [t1,t2,t3]

                  rt.to_scaled_product_of(.direct_matrix,t,R) 
                  rt = rt + r0
                  UNIT_CELL::make_LFF_h_tensors(H0,H1,rt,n=1)

                  yt.to_scaled_product_of(.reciprocal_matrix,t,fy1)
                  UNIT_CELL::make_LFF_g_tensors(G0,G1,yt)

                  dot = yt(1)*r0(1) + yt(2)*r0(2) + yt(3)*r0(3)

                  W0 = W0 - fd0*H0 - fy0*G0*sin(TWO*dot)
                  W1 = W1 + fd1*H1 -     G1*cos(TWO*dot)
               end
               end
               end

               do t1 = -m+1,m-1
               do t2 = -m,m,2*m
               do t3 = -m,m
                  t  = [t1,t2,t3]

                  rt.to_scaled_product_of(.direct_matrix,t,R) 
                  rt = rt + r0
                  UNIT_CELL::make_LFF_h_tensors(H0,H1,rt,n=1)

                  yt.to_scaled_product_of(.reciprocal_matrix,t,fy1)
                  UNIT_CELL::make_LFF_g_tensors(G0,G1,yt)

                  dot = yt(1)*r0(1) + yt(2)*r0(2) + yt(3)*r0(3)

                  W0 = W0 - fd0*H0 - fy0*G0*sin(TWO*dot)
                  W1 = W1 + fd1*H1 -     G1*cos(TWO*dot)
               end
               end
               end

               do t1 = -m+1,m-1
               do t2 = -m+1,m-1
               do t3 = -m,m,2*m
                  t  = [t1,t2,t3]

                  rt.to_scaled_product_of(.direct_matrix,t,R) 
                  rt = rt + r0
                  UNIT_CELL::make_LFF_h_tensors(H0,H1,rt,n=1)

                  yt.to_scaled_product_of(.reciprocal_matrix,t,fy1)
                  UNIT_CELL::make_LFF_g_tensors(G0,G1,yt)

                  dot = yt(1)*r0(1) + yt(2)*r0(2) + yt(3)*r0(3)

                  W0 = W0 - fd0*H0 - fy0*G0*sin(TWO*dot)
                  W1 = W1 + fd1*H1 -     G1*cos(TWO*dot)
               end
               end
               end

               LL0 = LL0 + W0
               LL1 = LL1 + W1
               if (m>=5 AND maxval(abs(W0))<TOL(10) AND maxval(abs(W1))<TOL(10)) exit
   
            end

         end
      end

      .put_debug(L0,"make_LFF_tensors: L0")
      .put_debug(L1,"make_LFF_tensors: L1")

   end

   make_LFF_h_tensors(H0,H1,x,n) ::: selfless, private
   ! Make the local field factor h tensors from the formula in 
   ! Reis (2000), JCP 112 p. 6161, Appendix B.
      H0 :: VEC{REAL}(3), OUT
      H1 :: MAT{REAL}(3,3), OUT
      x :: VEC{REAL}(3), IN
      n :: INT, IN

      i,j :: INT
      x1,x2,xm1,xm2,xm3,erfx,expx,fij,fii,fi,xi,xj :: REAL

      ! Temporary variables related to R
      x2  = x(1)*x(1) + x(2)*x(2) + x(3)*x(3)
      x1  = sqrt(x2)
      xm1 = ONE/x1
      xm2 = xm1*xm1
      xm3 = xm2*xm1

      ! Complementary erf term
      if (n==0) then; erfx = -x1.erf
      else;           erfx =  x1.erfc
      end

      erfx  = xm3*erfx
      expx  = xm2*TWO*exp(-x2)/SQRT_PI

      fii   = -erfx - expx
      fij   = THREE*xm2*erfx + (THREE*xm2+TWO)*expx
      fi    = erfx + expx

      ! Now make the h tensors ...
      H0 = ZERO
      H1 = ZERO
      do i = 1,3
         xi = x(i)
         do j = 1,3
            xj = x(j)
            H1(i,j) = H1(i,j) + fij*xi*xj
         end
         H1(i,i) = H1(i,i) + fii
         H0(i)   = H0(i)   + fi*xi
      end
      
   end

   make_LFF_g_tensors(G0,G1,x) ::: selfless, private
   ! G(x) function from
   ! Reis (2000), JCP 112 p. 6161, Appendix B.
      G0 :: VEC{REAL}(3), OUT
      G1 :: MAT{REAL}(3,3), OUT
      x  :: VEC{REAL}(3), IN

      i,j :: INT
      x2,xi,xj,g :: REAL

      ! Temporary variables related to R
      x2  = x(1)*x(1) + x(2)*x(2) + x(3)*x(3)
      g   = exp(-x2)/x2

      do i = 1,3
         xi = x(i)
         do j = 1,3
            xj = x(j)
            G1(i,j) = xi*xj*g
         end
         G0(i) = xi*g  ! need to be multiplied by 1/2R
      end
   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("angle",.angle)
      stdout.dump("length",.length)
      stdout.dump("volume",.volume)
      stdout.dump("direct_matrix",.direct_matrix)
      stdout.dump("inverse_matrix",.inverse_matrix)
      stdout.dump("reciprocal_matrix",.reciprocal_matrix)
      stdout.dump("direct_U_matrix",.direct_U_matrix)
      stdout.dump("reciprocal_U_matrix",.reciprocal_U_matrix)
      stdout.dump("info_made",.info_made)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE?=>UNIT_CELL)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE?=>UNIT_CELL)
   ! Dump pointer object data as text
   end

!  ===========
!  Put methods
!  ===========

   put
   ! Put unit cell information 
      self :: INOUT

      fac :: REAL

      ! Convert to CIF units
      .set_units_to("cif")

      ! Change defaults
      stdout.save
      stdout.set_real_width(14)
      stdout.set_real_precision(6)

      ! Print
      stdout.flush
      stdout.flush
      stdout.text("=====================")
      stdout.text("Unit cell information")
      stdout.text("=====================")
      stdout.flush
      stdout.text(". Lengths are in Angstrom")
      stdout.text(". Angles  are in degrees")

      stdout.flush
      stdout.show("a cell parameter         =",.length(1),.length_error(1))
      stdout.show("b cell parameter         =",.length(2),.length_error(2))
      stdout.show("c cell parameter         =",.length(3),.length_error(3))
      stdout.show("Cell volume              =",.volume,.volume_error)
      stdout.flush
      stdout.show("alpha angle              =",.angle(1),.angle_error(1))
      stdout.show("beta  angle              =",.angle(2),.angle_error(2))
      stdout.show("gamma angle              =",.angle(3),.angle_error(3))

      ! Need to go back to au here
      .set_units_to("au")
      fac = STR:conversion_factor("angstrom^-1")
      stdout.flush
      stdout.show("a* cell parameter (A^-1) =",.a_star*fac)
      stdout.show("b* cell parameter (A^-1) =",.b_star*fac)
      stdout.show("c* cell parameter (A^-1) =",.c_star*fac)
      fac = STR:conversion_factor("degree")
      stdout.flush
      stdout.show("alpha* angle (degree)    =",.alpha_star_angle*fac)
      stdout.show("beta*  angle (degree)    =",.beta_star_angle*fac)
      stdout.show("gamma* angle (degree)    =",.gamma_star_angle*fac)

      ! Back to cif units
      .set_units_to("cif")
      stdout.flush
      stdout.text("Direct cell matrix")
      stdout.flush
      stdout.put(.direct_matrix,auto_width=TRUE)

      stdout.flush
      stdout.text("Reciprocal cell matrix")
      stdout.flush
      stdout.put(.reciprocal_matrix,auto_width=TRUE)

      ! Put back defaults
      stdout.unsave

      ! Convert back
      .set_units_to("au")

   end

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
      self :: INOUT
      label,formula,spacegroup :: STR, IN

      ! Convert to CIF units
      .set_units_to("cif")

      ! Output
      stdout.flush
      stdout.text("begin crystalcell " // label.trim)
      stdout.text("   formula = "//'"'//trim(formula)//'"')
      stdout.text("   spacegroup = "//'"'//trim(spacegroup)//'"')
      stdout.show("   a =",.length(1),dots=FALSE)
      stdout.show("   b =",.length(2),dots=FALSE)
      stdout.show("   c =",.length(3),dots=FALSE)
      stdout.show("   alpha =",.angle(1),dots=FALSE)
      stdout.show("   beta  =",.angle(2),dots=FALSE)
      stdout.show("   gamma =",.angle(3),dots=FALSE)
      stdout.text("end crystalcell")

      ! Convert back
      .set_units_to("au")

   end

   put_CIF(Z,cart,har)
   ! Put unit cell information in CIF format
      self :: INOUT
      Z    :: REAL, IN
      cart :: BIN, optional, IN
      har  :: BIN, optional, IN

      a,b,c,da,db,dc, v,dv :: REAL
      dohar :: BIN

      ! Convert to CIF units
      .set_units_to("cif")

      ! Change defaults
      stdout.save
      stdout.set_real_width(14)
      stdout.set_real_precision(6)

      ! Output
      stdout.flush
      stdout.text("# =========")
      stdout.text("# Unit cell")
      stdout.text("# =========")

      stdout.flush
      stdout.show("_cell_measurement_temperature ","?",dots=FALSE)
      stdout.show("_cell_measurement_reflns_used ","?",dots=FALSE)
      stdout.show("_cell_measurement_theta_min   ","?",dots=FALSE)
      stdout.show("_cell_measurement_theta_max   ","?",dots=FALSE)

      a  = .length(1)
      b  = .length(2)
      c  = .length(3)
      da = .length_error(1)
      db = .length_error(2)
      dc = .length_error(3)

      stdout.flush
      stdout.show("_cell_length_a                ",a,da,dots=FALSE)
      stdout.show("_cell_length_b                ",b,db,dots=FALSE)
      stdout.show("_cell_length_c                ",c,dc,dots=FALSE)

      a  = .angle(1)
      b  = .angle(2)
      c  = .angle(3)
      da = .angle_error(1)
      db = .angle_error(2)
      dc = .angle_error(3)

      stdout.show("_cell_angle_alpha             ",a,da,dots=FALSE)
      stdout.show("_cell_angle_beta              ",b,db,dots=FALSE)
      stdout.show("_cell_angle_gamma             ",c,dc,dots=FALSE)

      v  = .volume
      dv = .volume_error

      stdout.show("_cell_volume                  ",v,dv,dots=FALSE)

      stdout.flush
      stdout.show("_cell_formula_units_Z              ",Z.to_str("f11.6"),dots=FALSE)

      if (cart) then
      stdout.flush
      stdout.show("_atom_sites_Cartn_tran_matrix_11   ",.direct_matrix(1,1),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_21   ",.direct_matrix(2,1),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_31   ",.direct_matrix(3,1),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_12   ",.direct_matrix(1,2),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_22   ",.direct_matrix(2,2),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_32   ",.direct_matrix(3,2),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_13   ",.direct_matrix(1,3),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_23   ",.direct_matrix(2,3),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_matrix_33   ",.direct_matrix(3,3),dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_vector_1    ",ZERO               ,dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_vector_2    ",ZERO               ,dots=FALSE)
      stdout.show("_atom_sites_Cartn_tran_vector_3    ",ZERO               ,dots=FALSE)
      end

      dohar = FALSE
      if (present(har)) dohar = har

      if (dohar) then
      stdout.flush
      stdout.show("_atom_sites_solution_hydrogens     ","HAR"              ,dots=FALSE)
      end

      ! Put back defaults
      stdout.unsave

      ! Convert back
      .set_units_to("au")

   end

end
