!===============================================================================
!
! MOLECULE.PUT
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below.
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further.
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! Updated 2014-12-01
!
! .BASE
!     3 .REL
!    16---24 .GRID
!    14---12---- 1 .XTAL
!     2--- |---- |---- 4 .CE =
!     7--- |---- 1---- |-- | .INTS
!    14--- |---- 5---- |-- |---- 2 .FOCK
!    30--- 5---- 4---- 5-- |----10---- 5 .SCF
!     2--- |---- |---- |-- |---- 1---- 5--- 1 .GEM =     =     =
!    11--- |---- |---- 1-- |----15---- 5---13--- | .PROP =     =
!     4--- |---- 6---- |-- |---- 3---- |--- 2--- |---- | .PLOT =
!     4--- |---- 5---- |-- |---- 4---- 2--- 1--- |---- |---- | .CP
!    12--- |---- 7---- |-- |---- |---- |--- 1--- |---- |---- 1-- | .TAD
!    15--- |---- 5---- 1-- |---- 5---- 6--- 5--- |---- |---- |-- |--- 2 .MISC
!    76--- 3---- 3----13-- 7---- 1---- |---13--- 3----19---- 6-- 9---11----24 .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===============================================================================

module MOLECULE.PUT

   implicit none

contains

!  ======================
!  Gaussian chk interface
!  ======================

   put_tonto_FChk_MO ::: leaky
   ! Write the MO's in a way which can replace g09 fchk file section
      self :: IN

   ENSURE(NOT .use_spherical_basis,   "spherical basis not implemented")
   ENSURE(.MOs.allocated,"no MO's")

      arch :: ARCHIVE 

      arch.set(.name,"gaussian_MO",genre=.MOs.genre,format="ascii")
      arch.write(.MOs,by_column=TRUE,ascii=TRUE)

   end

   put_tonto_FChk_DM ::: leaky
   ! Write the MO's in a way which can replace g09 fchk file section
      self :: IN

   ENSURE(NOT .use_spherical_basis,   "spherical basis not implemented")
   ENSURE(.density_mx.allocated,"no MO's")

      arch :: ARCHIVE 

      arch.set(.name,"gaussian_DM",genre=.density_mx.genre,format="ascii")
      arch.write(.density_mx,by_column=TRUE,ascii=TRUE)

   end

!  ==============
!  Write XYZ File 
!  ==============

   put_xyz_file ::: leaky
   ! Prints out an asymmetric-unit xyz file.
   ! cartesian axes.
      self :: IN

      name :: STR
      xyzfile :: TEXTFILE@
      i :: INT

      atomnumber :: STR, parameter = "(I3)"
      comment :: STR, parameter = "(' written by tonto')"
      atom_format :: STR, parameter = "(A5, 3F12.6)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      xyzfile.create(trim(name)//".xyz")
      xyzfile.open_for("write")
      
      xyzfile.put(.n_atom)
      xyzfile.flush
      xyzfile.put(trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION)
      xyzfile.flush
      do i=1,.n_atom
          xyzfile.put(.atom(i).label)
          xyzfile.put(.atom(i).position(1)*ANGSTROM_PER_BOHR)
          xyzfile.put(.atom(i).position(2)*ANGSTROM_PER_BOHR)
          xyzfile.put(.atom(i).position(3)*ANGSTROM_PER_BOHR)
          xyzfile.flush
      end do
      
      ! Cleanup
      xyzfile.close
      xyzfile.destroy

   end

   put_xtal23_xyz_file ::: leaky
   ! Prints out an asymmetric-unit xyz file.
   ! cartesian axes.
      self :: IN

      name :: STR
      xyzfile :: TEXTFILE@
      i :: INT
      n_atom :: INT

      atomnumber :: STR, parameter = "(I3)"
      comment :: STR, parameter = "(' written by tonto')"
      atom_format :: STR, parameter = "(A5, 3F12.6)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      xyzfile.create(trim(name)//".xyz")
      xyzfile.open_for("write")
     
      n_atom = .crystal.n_asymmetric_unit_atoms

      xyzfile.put(n_atom)
      xyzfile.flush
      xyzfile.put(trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION)
      xyzfile.flush
      do i=1,n_atom
!         xyzfile.put(.atom(i).atomic_number)
          xyzfile.put(.crystal.asymmetric_unit_atom(i).atomic_number)
          xyzfile.put(.crystal.asymmetric_unit_geometry(1,i))
          xyzfile.put(.crystal.asymmetric_unit_geometry(2,i))
          xyzfile.put(.crystal.asymmetric_unit_geometry(3,i))
          xyzfile.flush
      end do
      
      ! Cleanup
      xyzfile.close
      xyzfile.destroy

   end

!  ======
!  Output
!  ======

   put
   ! Put all the available molecule information on file
      self :: INOUT

   DIE_IF(tonto.deallocated,"no tonto variable")

      .PUT:put_basics

      ! Stop here for low verbosity
      if (tonto.low_verbosity) then
      if (.atom.allocated) then
         if (.atom.dim>100) return
      end
      end

      ! Atoms coordinates, basis sets
      if (.atom.allocated) .PUT:put_atoms ! INOUT

      ! Atom groups
      if (.atom_group.allocated) .PUT:put_atom_groups

      ! Stop here for proteins
      if (.crystal.use_Ryde_capping) then
      if (.atom.allocated) then
         if (.atom.dim>100) return
      end
      end

      if (.pointgroup.allocated)  .PUT:put_pointgroup
      if (.crystal.allocated)     .PUT:put_crystal
      if (.cluster.allocated)     .PUT:put_cluster
      if (.becke_grid.allocated)  .PUT:put_becke_grid

      if (.overlapping_atoms.allocated AND .atom.allocated) then
         .PUT:put_overlapping_atoms
         .PUT:put_overlapping_atoms_4_atom
      end

   end

   put_basics
   ! Put basic molecule information
      self :: IN

      stdout.flush
      stdout.flush
      stdout.text("====================")
      stdout.text("Molecule information")
      stdout.text("====================")

      stdout.flush
      stdout.show("Name                   =",.name)

      stdout.flush
      stdout.show("Chemical Formula       =",trim(.atom.chemical_formula(with_spaces=TRUE)))
      stdout.show("Molecular weight       =",.atom.molecular_weight)

      stdout.flush
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.spin_multiplicity)

      stdout.flush
      stdout.show("No. of atoms           =",.n_atom)
      stdout.show("No. of electrons       =",.n_e)
      stdout.show("No. of alpha electrons =",.n_a)
      stdout.show("No. of beta  electrons =",.n_b)

      if (.atom.has_all_bases) stdout.flush
      if (.basis_name/=" ") then
      stdout.show("Gaussian basis name    =",.basis_name)
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      end
      if (.slaterbasis_name/=" ") &
      stdout.show("Slater basis name      =",.slaterbasis_name)
      if (.coppensbasis_name/=" ") &
      stdout.show("Coppens basis name     =",.coppensbasis_name)

      if (NOT .E_field.is_zero) &
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      if (NOT .B_field.is_zero) &
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      if (NOT .gauge_origin.is_zero) &
      stdout.show("B field Gauge origin   =",.gauge_origin)

   end

   put_atoms
   ! Output the atom coordinate and basis set information
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")

      .atom.put_coordinate_info

      if (.basis.allocated)        .PUT:put_bases ! INOUT
    ! if (.coppensbasis.allocated) .put_coppensbases
    ! if (.slaterbasis.allocated)  .put_slaterbases

    ! .atom.put_ADPs

   end

   put_basics_and_atoms
   ! Output minimal atom info without crystal info.
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")

      .PUT:put_basics
      .PUT:put_atoms ! INOUT
      .PUT:put_bases

   end

   put_ADPs
   ! Output the ADPs in cartesian axes
     self :: IN

   ENSURE(.atom.allocated,"no atom list")

      .atom.put_ADPs

   end


   put_bond_length_with_error ::: leaky
   ! Read two atoms, and output the bond length with associated error
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no diffraction data")
   ENSURE(.crystal.xray_data.covariance_mx.allocated,"no cov matrix created")

      cm :: MAT{REAL}@
      a1,a2,n_f :: INT

      ! Read the two atoms
      stdin.read(a1)
      stdin.read(a2)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.xray_data.fragment_covariance_mx.destroy
      .crystal.xray_data.fragment_covariance_mx.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx ! INOUT

      ! Extract positional-covariances
      .crystal.make_pos_covariance_mx(cm)

      ! Put the bond length
      .atom.put_bond_length_with_error(a1,a2,cm)

      ! Clean
      cm.destroy

   end

   put_bond_angle_with_error ::: leaky
   ! Output the atom coordinate and basis set information
   ! Read three atoms, and output the bond angle with associated error
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no diffraction data")
   ENSURE(.crystal.xray_data.covariance_mx.allocated,"no cov matrix created")

      cm :: MAT{REAL}@
      a1,a2,a3,n_f :: INT

      ! Read the three atoms defining the angle
      stdin.read(a1)
      stdin.read(a2)
      stdin.read(a3)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.xray_data.fragment_covariance_mx.destroy
      .crystal.xray_data.fragment_covariance_mx.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx ! INOUT

      ! Extract positional-covariances
      .crystal.make_pos_covariance_mx(cm)

      ! Put the bond angle
      .atom.put_bond_angle_with_error(a1,a2,a3,cm)

      cm.destroy

   end

   put_torsion_angle_with_error ::: leaky
   ! Output the atom coordinate and basis set information
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no diffraction data")
   ENSURE(.crystal.xray_data.covariance_mx.allocated,"no cov matrix created")

      cm :: MAT{REAL}@
      a1,a2,a3,a4,n_f :: INT

      ! Read the three atoms defining the angle
      stdin.read(a1)
      stdin.read(a2)
      stdin.read(a3)
      stdin.read(a4)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.xray_data.fragment_covariance_mx.destroy
      .crystal.xray_data.fragment_covariance_mx.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx ! INOUT

      ! Extract positional-covariances
      .crystal.make_pos_covariance_mx(cm)

      ! Put the torsion angle
      .atom.put_torsion_angle_with_error(a1,a2,a3,a4,cm)

      ! Clean
      cm.destroy

   end


   put_principal_axes
   ! Output the atom principal axes
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")

      .atom.put_principal_axes

   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
      self :: INOUT

      if (NOT .basis.allocated) return

      ! Put atom basis tags
      .atom.put_bases

      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian basis sets")
      stdout.text("===================")
      stdout.flush
      stdout.show("Basis name             =",.basis_name)
      stdout.flush
      if (.use_spherical_basis) &
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      stdout.flush

      .basis.renormalize ! INOUT
      .basis.put
      .basis.unnormalize

   end

   put_slaterbases
   ! Output the molecule slaterbasis set information, if the bases are
   ! all resolved.
      self :: IN

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.slaterbasis.allocated,"no basis set list")

      if (NOT .atom.slaterbases_are_resolved) return

      stdout.flush
      stdout.text("Molecule atom slaterbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.slaterbasis.dim)

      .slaterbasis.put

   end

   put_coppensbases
   ! Output the molecule coppensbasis set information, if the bases are all
   ! resolved.
      self :: IN

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.coppensbasis.allocated,"no basis set list")

      if (NOT .atom.coppensbases_are_resolved) return

      stdout.flush
      stdout.text("Molecule atom coppensbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.coppensbasis.dim)
      stdout.show("Maximum N value   =",.coppensbasis.maximum_basis_n_value)
      stdout.show("No. of orbitals   =",.coppensbasis.no_of_orbitals)
      stdout.show("No. of primitives =",.coppensbasis.no_of_primitives)

      .coppensbasis.put

   end

   put_atom_groups
   ! Output the .atom_group info array
      self :: INOUT

   ENSURE(.atom_group.allocated,"no atom group information")

      .atom_group.put
      .PUT:put_atom_group_mols
      
   end

   put_atom_group_mols
   ! Output each .atom_group.mol info
      self :: INOUT

   ENSURE(.atom_group.allocated,"no .atom_group information")
   ENSURE(.mol.allocated,"no .mol information")

      name :: STR
      g :: INT

      ! Output fragment info
      do g = 1,.atom_group.dim
      
         ! Minimal stdout for fragment
         name = trim(.atom_group(g).name)
         stdout.redirect(name)
       ! .mol(g).PUT:put_basics_and_atoms
         .mol(g).PUT:put ! INOUT
         stdout.revert
        
         ! Even more minimal xyz for plotting
         .mol(g).atom.put_xyz_file(name)
      
      end

   end

   put_overlapping_atoms
   ! Out out the .overlapping_atom info array
      self :: IN

   ENSURE(.overlapping_atoms.allocated,"no overlapping_atoms")
   ENSURE(.atom.allocated,"no atoms")

      i,j,k :: INT

      stdout.save_style

      stdout.set_int_width(4)
      stdout.set_n_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms:")
      stdout.text(" ")

      do i = 1,.atom.dim
         k = 1
         stdout.put(i)
         do j = 1,.atom.dim
            if (NOT .INQ:is_overlapping_atom(i,j)) cycle
            k = k + 1
            stdout.put(j)
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave_style

   end

   put_overlapping_atoms_4_atom
   ! Out out the .overlapping_atoms_for_atom info array
      self :: IN

   ENSURE(.overlapping_atoms.allocated,"no overlapping_atoms")
   ENSURE(.atom.allocated,"no atoms")

      i,j,k :: INT

      stdout.save_style
      stdout.set_int_width(4)
      stdout.set_n_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms for atom:")
      stdout.text(" ")

      do i = 1,.atom.dim
         stdout.put(i)
         k = 1
         do j = 1,.overlapping_atoms_for_atom(i).element.dim
            k = k + 1
            stdout.put(.overlapping_atoms_for_atom(i)[j])
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave_style

   end

   put_pointgroup
   ! Output the current pointgroup
      self :: IN

      .pointgroup.put

   end

   put_plot_grid
   ! Output the current grid.
   ENSURE(.plot_grid.allocated,"no plot grid to output")
      .plot_grid.put
   end

   put_becke_grid
   ! Output the current DFT grid.
      self :: IN

   ENSURE(.becke_grid.allocated,"no Becke integration grid to output")

      .becke_grid.put

   end

   put_crystal
   ! Output the current crystal
      self :: INOUT

      .crystal.put

   end

   put_cluster
   ! Put out the cluster information
      self :: IN

   ENSURE(.cluster.allocated,"no cluster data")

      .cluster.put

   end

   put_MOs
   ! Output the current associated molecular orbitals
      self :: IN

      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.MOs)

   end

   put_MOs_and_energies
   ! Output the current associated molecular orbitals and their energies
      self :: IN

      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.MO_energies)
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.MOs)

   end

   put_MO_energies
   ! Output the molecular orbital energies
      self :: IN

      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.MO_energies)

   end

   put_NOs
   ! Output the current associated molecular orbitals
      self :: IN

      stdout.flush
      stdout.text("NO occupation numbers:")
      stdout.put(.NO_occ_nos)

      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.NOs)

   end

   put_NBO_file_47
   ! Output the current associated density matrix
      self :: IN

   ENSURE(.density_mx.allocated,"no density matrix")

      i,j, Z :: INT
      pos :: VEC{REAL}(3)
      ind, fbf,lbf,ang :: VEC{INT}@
      mx  :: OPMATRIX@

      stdout.redirect(trim(.name)//".NBO,file_47")

      write(stdout.unit,"(1x,'$COORD')")
      write(stdout.unit,"(1x,a)") trim(.name)
      do i = 1,.n_atom
         Z   = .atom(i).atomic_number
         pos = .atom(i).atomic_number * ANGSTROM_PER_BOHR
         write(stdout.unit,"(1x,2i5,3f15.6)") Z,Z,pos
      end
      write(stdout.unit,"(1x,'$END')")

      write(stdout.unit,"(1x,'$BASIS')")
      .atom.make_atom_for_basis_fn_in(ind)
      write(stdout.unit,"(1x,' CENTER =',11i6,/,(10x,11i6))") (ind(i), i=1,ind.dim)
      write(stdout.unit,"(1x,'$END')")

      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      mx = .density_mx
      mx.renormalize(fbf,lbf,ang)
      write(stdout.unit,"(1x,'$DENSITY')")
      write(stdout.unit,"((1x,5e20.12))") ((mx.r(i,j), i=j,.n_bf), j=1,.n_bf)
      write(stdout.unit,"(1x,'$END')")

      mx = .fock_mx
      mx.renormalize(fbf,lbf,ang)
      write(stdout.unit,"(1x,'$FOCK')")
      write(stdout.unit,"((1x,5e20.12))") ((mx.r(i,j), i=j,.n_bf), j=1,.n_bf)
      write(stdout.unit,"(1x,'$END')")

      mx.destroy

      stdout.revert

   end

   put_density_mx
   ! Output the current associated density matrix
      self :: IN

   ENSURE(.density_mx.allocated,"no density matrix")

      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_mx)

   end

   put_Fock_mx
   ! Output the current associated fock matrix
      self :: IN

   ENSURE(.fock_mx.allocated,"no fock matrix")

      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_mx)

   end


   put_vrml
   ! Output a VRML file for the coordinate geometry
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list!")

      out :: TEXTFILE@

      out.create(trim(.name)//achar(46)//"wrl")
      out.open_for("write")
      stdout.text("Generating VRML molecule")
      out.text("#VRML V2.0 utf8")
      out.text("NavigationInfo { type " // achar(34) // "EXAMINE" // achar(34) // " }")
      out.text("Viewpoint { ")
      out.text("position 0 0 10")
      out.text("fieldOfView 1")
      out.text("orientation 0 0 1 0")
      out.text('description "camera z"')
      out.text("}")
      out.text("DirectionalLight {")
      out.text("  color 1 1 1")
      out.text("  direction 1 0 0")
      out.text("  intensity 0.4")
      out.text("}")
      .atom.put_vrml(out)
      if (.isosurface.allocated) .isosurface.put_vrml(out) ! INOUT
      stdout.text("done VRML molecule")

   end

!  =====
!  ANO's
!  =====

   put_ANOs ::: leaky
   ! Put the ANO data out for all atoms in the molecule.
      self :: IN

   ENSURE(.atom.allocated,"no atoms")

      k,a,b :: INT
      list :: STR

      if (NOT .INQ:has_all_ANO_matrices) return

      if (.n_atom_kind<=0) return

      stdout.flush
      stdout.text("========")
      stdout.text("ANO data")
      stdout.text("========")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle
         k = .atom(a).kind

         list = trim(a.to_str)
         do b = a+1,.n_atom
            if (.atom(b).kind/=k) cycle
            list = trim(list)//" "//trim(b.to_str)
         end
         list = "ANO's for atoms ... "//trim(list)

         stdout.flush
         stdout.text(repeat("=",len_trim(list)))
         stdout.text(list)
         stdout.text(repeat("=",len_trim(list)))
         .atom(a).put_ANOs
         stdout.flush

      end

   end

!  =======
!  Put CIF
!  =======

   put_grown_CIF(with_ESDs)
   ! Prints out fragment cif file.
   ! Does only cartesian axes.
   ! NOTE: IF "with_esds" is present and TRUE, it is assumed
   ! that the covariances from a refinement are present, and
   ! these are used to make the ESDs; otherwise ESDs are still
   ! made by transforming in a straightforward way.
      self :: INOUT
      with_ESDs :: BIN, optional, IN

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean,change_ESDs,H_U_iso :: BIN

      ! Make sure CIF is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".cif")
      end

      ! Cartesian fragment/CIF2
      .cif.set_use_CIF2(TRUE)
      stdout.redirect(trim(.name)//".cartesian.cif2")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .PUT:put_CIF_basics
      .PUT:put_CIF_wavefunction
      .crystal.put_fragment_CIF(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.xray_data.allocated) H_U_iso = .crystal.xray_data.refine_H_U_iso

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_CIFs(with_ESDs)
   ! Prints out an asymmetric and fragment cif file.
   ! Does both cartesian and crystal axes.
   ! NOTE: IF "with_esds" is present and TRUE, it is assumed
   ! that the covariances from a refinement are present, and
   ! these are used to make the ESDs; otherwise ESDs are still
   ! made by transforming in a straightforward way.
      self :: INOUT
      with_ESDs :: BIN, optional, IN

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean,change_ESDs,H_U_iso :: BIN
      title :: STR

      ! Make sure CIF is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".cif")
      end

      ! Cartesian fragment/CIF2
      .cif.set_use_CIF2(TRUE)

      ! Set title
      title = .name
      if (.scfdata.allocated) then
      if (.scfdata.is_constrained_wavefunction) then
         title = trim(title)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))
      end
      end
      if (.plot_grid.allocated) then
      if (.plot_grid.plot_label/=" ") then
         title = trim(title)//","//trim(.plot_grid.plot_label)
      end
      end

      ! Redirect
      stdout.redirect(trim(title)//".cartesian.cif2")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .PUT:put_CIF_basics
      .PUT:put_CIF_wavefunction
      .crystal.put_fragment_CIF(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.xray_data.allocated) H_U_iso = .crystal.xray_data.refine_H_U_iso

      ! Put refection files
      .PUT:put_tonto_fcf 
      .PUT:put_xd_fco

      ! Crystal asymmetric-unit/CIF1
      .cif.set_use_CIF2(FALSE)

      ! Redirect
      stdout.redirect(trim(title)//".HBB.cif2")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .PUT:put_CIF_basics
      .PUT:put_CIF_wavefunction
      .crystal.put_fragment_CIF_HBB(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.xray_data.allocated) H_U_iso = .crystal.xray_data.refine_H_U_iso

      ! Put refection files
      .PUT:put_tonto_fcf 
      .PUT:put_xd_fco

      ! Crystal asymmetric-unit/CIF1
      .cif.set_use_CIF2(FALSE)

      ! Redirect
      stdout.redirect(trim(title)//".archive.cif")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .PUT:put_CIF_basics
      .PUT:put_CIF_wavefunction
    ! .crystal.asymmetric_unit_atom.change_axis_system_to("crystal",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.asymmetric_unit_atom.change_axis_system_to("crystal",.crystal.unit_cell,change_ESDs)
      .crystal.put_asymm_unit_CIF(.cif)
    ! .crystal.asymmetric_unit_atom.change_axis_system_to("cartesian",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.asymmetric_unit_atom.change_axis_system_to("cartesian",.crystal.unit_cell,change_ESDs)
      .crystal.put_asymm_unit_CIF_bond_info ! Must be cartesian
      stdout.revert

      ! Put other files
!     if (.crystal.xray_data.allocated) then
!     if (.crystal.xray_data.reflections.allocated) then

      ! .PUT:put_shelx_hkl3
      ! .PUT:put_shelx_hkl4
      ! .PUT:put_shelx_fcf5
      ! .PUT:put_shelx_fcf6

      ! Crystal fragment/CIF1
      .cif.set_use_CIF2(FALSE)

      ! Redirect
      stdout.redirect(trim(title)//".fractional.cif1")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .PUT:put_CIF_basics
      .PUT:put_CIF_wavefunction
    ! .crystal.fragment_atom.change_axis_system_to("crystal",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.fragment_atom.change_axis_system_to("crystal",.crystal.unit_cell,change_ESDs)
      .crystal.put_fragment_CIF(.cif)
    ! .crystal.fragment_atom.change_axis_system_to("cartesian",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.fragment_atom.change_axis_system_to("cartesian",.crystal.unit_cell,change_ESDs)
      .crystal.put_fragment_CIF_bond_info   ! Must be cartesian
      stdout.revert

 !     end
 !     end

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_CIF_banner(CIF2) ::: private
   ! Prints out the CIF banner, with "CIF2" format if needed.
      self :: IN
      CIF2 :: BIN, IN

      date :: STR

      if (CIF2) then
      stdout.text("#\#CIF_2.0")
      stdout.flush
      end

      stdout.text("# ========================")
      stdout.text("# Tonto generated CIF file")
      stdout.text("# ========================")
      stdout.flush
      stdout.text("# NOTE: This is an incomplete CIF file")
      stdout.text("# Manually edit it to pass checkCIF")
      stdout.flush
      stdout.text("data_"//trim(.name))
      stdout.flush
      date = TIME:current_date_YMD_str()
      stdout.text("_audit_creation_date                "//trim(date))
      stdout.text("_audit_creation_method              'Tonto "//TONTO_VERSION//" github v. "//GIT_VERSION//"'")

      stdout.flush
      stdout.text("# ============")
      stdout.text("# QCr software")
      stdout.text("# ============")

      stdout.flush
      stdout.text("_QCr_software                       'Tonto'")
      stdout.text("_QCr_software_version               '"//TONTO_VERSION//" v. "//GIT_VERSION//"'")
      stdout.text("_QCr_software_platform              '"//TONTO_PLATFORM//"'")
      stdout.text("_QCr_software_build_date            '"//TONTO_BUILD_DATE//"'")
      stdout.text("_QCr_software_website               'https://github.com/dylan-jayatilaka/tonto'")

   end

   put_CIF_basics ::: private
   ! Put basic molecule information
      self :: IN

      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Publication")
      stdout.text("# ===========")

      stdout.flush
      stdout.text("_publ_contact_author")
      stdout.text(";")
      stdout.text("    Prof. Dr. Sir Tonto Magnifico")
      stdout.text(";")
      stdout.text("_publ_contact_author_email          'tonto.magnifico@gmail.com'")
      stdout.text("_publ_contact_author_phone          '+61 8 6488 3138'")
      stdout.text("_publ_requested_journal             'IUCrJ'")
      stdout.text("_publ_section_title")
      stdout.text(";")
      stdout.text("   'Hirshfeld atom-refinement (HAR) for "//trim(.name)//"'")
      stdout.text("   'X-ray wavefunction refinement (XWR) for "//trim(.name)//"'")
      stdout.text("   Tonto Magnifico, IUCrJ (XXXX)")
      stdout.text(";")

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _publ_author_name")
      stdout.text("    'Tonto Magnifico'")

      stdout.flush
      stdout.text("_publ_author_address")
      stdout.text(";")
      stdout.text("    Prof. Dr. Sir Tonto Magnifico")
      stdout.text("    1 El Camino Ciberespacio")
      stdout.text("    Tierra Austral del Espiritu Santo")
      stdout.text(";")

      stdout.flush
      stdout.text("# ========")
      stdout.text("# Chemical")
      stdout.text("# ========")

      stdout.flush
      stdout.text("_chemical_name_common               "//trim(.name))
      stdout.text("_chemical_formula_sum               '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_moiety            '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_weight            "//trim(REAL:to_str(.atom.molecular_weight,"f10.4")))
      stdout.text("_chemical_compound_source           'see text'")
      stdout.text("_chemical_absolute_configuration    unk")


   end

   put_CIF_wavefunction ::: private
   ! Put the wavefunction information out
      self :: IN

      psi :: VEC{STR}(19)

      if (.scfdata.deallocated) return
      if (.basis.deallocated) return

      ! Get wavefunction details
      psi = .INQ:wavefunction_descriptor

      stdout.flush
      stdout.text("# ==========")
      stdout.text("# QCr method")
      stdout.text("# ==========")

      stdout.flush
      stdout.text("_QCr_calc_method                    '"//trim(psi(1))//"'")
      stdout.text("_QCr_calc_spinorbital_genre          '"//trim(psi(2))//"'")
      stdout.text("_QCr_calc_gaussian_basis_set        '"//trim(psi(3))//"'")
      stdout.text("_QCr_calc_gaussian_basis_set_kind   '"//trim(psi(4))//"'")
      stdout.text("_QCr_calc_basis_max_l               '"//trim(psi(5))//"'")

      stdout.flush
      stdout.text("_QCr_calc_unit                      'See _atom_site_* in tonto.cif2'")
      stdout.text("_QCr_calc_unit_spin_multiplicity    "//trim(INT:to_str(.spin_multiplicity)))
      stdout.text("_QCr_calc_unit_n_electrons          "//trim(INT:to_str(.n_e)))
      stdout.text("_QCr_calc_unit_n_alpha_electrons    "//trim(INT:to_str(.n_a)))
      stdout.text("_QCr_calc_unit_n_beta_electrons     "//trim(INT:to_str(.n_b)))
                                                    
      if (psi(6)/="?") then
      stdout.flush
      stdout.text("_QCr_Becke_grid_kind                "//trim(psi( 6)))
      stdout.text("_QCr_Becke_grid_accuracy            "//trim(psi( 7)))
      stdout.text("_QCr_Becke_grid_L_angular_grid      "//trim(psi(17)))
      stdout.text("_QCr_Becke_grid_L_H_angular_grid    "//trim(psi(18)))
      stdout.text("_QCr_Becke_grid_reduce_L_H_ang_grid "//trim(psi(19)))
      stdout.text("_QCr_Becke_grid_core_pruning_scheme "//trim(psi( 8)))
      stdout.text("_QCr_Becke_grid_scale_H-He_grid     "//trim(psi(11)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_1     "//trim(psi(12)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_2     "//trim(psi(13)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_3     "//trim(psi(14)))
      stdout.text("_QCr_Becke_grid_n_radial_H_pts      "//trim(psi(15)))
      stdout.text("_QCr_Becke_grid_H_pts_per_n_shell   "//trim(psi(16)))
      stdout.text("_QCr_Becke_grid_basis_fn_cutoff     "//trim(psi( 9)))
      stdout.text("_QCr_Becke_grid_rho_cutoff          "//trim(psi(10)))
      end

   end

   put_shelx_hkl3
   ! Prints out reflections in shelx hkl3 format
      self :: INOUT

   ENSURE(.atom.allocated, "No atom")
   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.crystal.xray_data.allocated, "No crystal diffraction data")
   ENSURE(.crystal.xray_data.reflections.allocated, "No crystal reflections")

      ! Fragment
      stdout.redirect(trim(.name)//".hkl3")
      .crystal.xray_data.reflections.put_shelx_hkl3
      stdout.revert

   end

   put_shelx_hkl4
   ! Prints out reflections in shelx hkl4 format
      self :: INOUT

   ENSURE(.atom.allocated, "No atom")
   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.crystal.xray_data.allocated, "No crystal diffraction data")
   ENSURE(.crystal.xray_data.reflections.allocated, "No crystal reflections")

      ! Fragment
      stdout.redirect(trim(.name)//".hkl4")
      .crystal.xray_data.reflections.put_shelx_hkl4
      stdout.revert

   end

   put_shelx_fcf5
   ! Prints out just the reflection information plus minimal
   ! extra stuff as in the shelx fcf LIST=5 file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".fcf5")
      end

      ! Fragment
      stdout.redirect(trim(.name)//".fcf5")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_shelx_fcf5
      stdout.revert

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_shelx_fcf6
   ! Prints out just the reflection information plus minimal
   ! extra stuff as in the shelx fcf LIST=6 file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".fcf6")
      end

      ! Fragment
      stdout.redirect(trim(.name)//".fcf6")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_shelx_fcf6
      stdout.revert

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_tonto_fcf
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".archive.fcf")
      end

      ! Fragment
      stdout.save_style
      stdout.redirect(trim(.name)//".archive.fcf")
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_tonto_fcf
      stdout.revert
      stdout.unsave_style

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_tonto_fcf_XCW
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         if (.scfdata.do_outputs) then
            if (NOT .scfdata.exceeded_lambda_max) then
               .cif.create(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fcf")
            else
               .cif.create(trim(.name)//".archive.fcf")
            end
         else
            .cif.create(trim(.name)//".archive.fcf")
         end
      end

      ! Fragment
      stdout.save_style
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
            stdout.redirect(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fcf")
         else
            stdout.redirect(trim(.name)//".archive.fcf")
         end
      else
         stdout.redirect(trim(.name)//".archive.fcf")
      end
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_tonto_fcf
      stdout.revert
      stdout.unsave_style

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_olex_fcf_XCW
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         if (.scfdata.do_outputs) then
            if (NOT .scfdata.exceeded_lambda_max) then
               .cif.create(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".olex.fcf")
            else
               .cif.create(trim(.name)//".archive.fcf")
            end
         else
            .cif.create(trim(.name)//".archive.fcf")
         end
      end

      ! Fragment
      stdout.save_style
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
            stdout.redirect(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".olex.fcf")
         else
            stdout.redirect(trim(.name)//".archive.fcf")
         end
      else
         stdout.redirect(trim(.name)//".archive.fcf")
      end
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_Olex2_fcf("'all reflections are used'")
      stdout.revert
      stdout.unsave_style

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_xd_fco
   ! Prints out just the F2 reflection information plus minimal
   ! extra stuff as in the XD fco file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".archive.fco")
      end

      ! Fragment
      stdout.save_style
      stdout.redirect(trim(.name)//".archive.fco")
      stdout.set_int_width(5)
      stdout.set_real_precision(4)
      stdout.set_real_width(13)
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_xd_fco
      stdout.revert
      stdout.unsave_style

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_xd_fco_XCW
   ! Prints out just the F2 reflection information plus minimal
   ! extra stuff as in the XD fco file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         if (.scfdata.do_outputs) then
            if (NOT .scfdata.exceeded_lambda_max) then
               .cif.create(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fco")
            else
               .cif.create(trim(.name)//".archive.fco")
            end
         else
            .cif.create(trim(.name)//".archive.fco")
         end
      end

      ! Fragment
      stdout.save_style
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
            stdout.redirect(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fco")
         else
            stdout.redirect(trim(.name)//".archive.fco")
         end
      else
         stdout.redirect(trim(.name)//".archive.fco")
      end
      stdout.set_int_width(5)
      stdout.set_real_precision(4)
      stdout.set_real_width(13)
      .PUT:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_xd_fco
      stdout.revert
      stdout.unsave_style

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

!  ===================
!  Atomic form factors
!  ===================

   put_atomic_form_factors
   ! Put the spherically averaged restricted atomic form factors
   ! for the unique atoms.

   ENSURE(.atom.allocated,"no atom")
   ENSURE(.crystal.allocated,"no crystal - specify H form factor type")

      length,spacing :: REAL
      IAM,val :: BIN
      a :: INT

      ! Type of IAM SF's
      IAM = .crystal.xray_data.use_IAM_ITC_FFs

      ! Table length
      length  = 2.00d0 * FOUR*PI * ANGSTROM_PER_BOHR
      spacing = 0.05d0 * FOUR*PI * ANGSTROM_PER_BOHR

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Structure factors
         stdout.flush
         stdout.text("========================")
         stdout.text("Real form factors for "//trim(.atom(a).chemical_symbol))
         stdout.text("========================")
         stdout.flush

         val = .atom(a).use_IAM_ITC_FFs
         .atom(a).set_use_IAM_ITC_FFs(IAM)
         .atom(a).put_FT_along_z_r(length,spacing)
         .atom(a).set_use_IAM_ITC_FFs(val)  ! Put back

       ! ! Structure factors
       ! stdout.flush
       ! stdout.text("=============================")
       ! stdout.text("Imaginary form factors for "//trim(.atom(a).chemical_symbol))
       ! stdout.text("=============================")
       ! stdout.flush
       ! .atom(a).put_FT_along_z_i(length,spacing)

      end

   end

!  ==================
!  Archiving routines
!  ==================

   put_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.
      self :: INOUT

      fbf,lbf,ang :: VEC{INT}@
      name,normalize :: STR
      do_norm :: BIN
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set archive "name"
      arch.set(.name,name)

      ! Second word on line is normalize?
      normalize = " "
      if (stdin.buffer.n_items==2) stdin.read(normalize)
      do_norm = normalize(1:9)=="normalize" OR normalize(1:9)=="normalize"

      ! Tell them
      if (do_norm) then
         stdout.flush
         stdout.text("Writing normalized "//trim(name))
         stdout.flush
      end

      fbf = .first_basis_fn_for_shell
      lbf =  .last_basis_fn_for_shell
      ang = .angular_moment_for_shell

      ! Write the archive, "genre" from object
      select case (name)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
         DIE_IF(.MOs.deallocated,"no MOs")
         if (do_norm) then
            .MOs.renormalize("1",fbf,lbf,ang)
            arch.write(.MOs)
            .MOs.unnormalize("1",fbf,lbf,ang)
         else
            arch.write(.MOs)
         end

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         DIE_IF(.MO_energies.deallocated,"no MO_energies")
         arch.write(.MO_energies)

      case ("natural_orbitals  ","NOs               ")
         DIE_IF(.NOs.deallocated,"no NOs")
         if (do_norm) then
            .NOs.renormalize("1",fbf,lbf,ang)
            arch.write(.NOs)
            .NOs.unnormalize("1",fbf,lbf,ang)
         else
            arch.write(.NOs)
         end

      case ("no_occupation_nos ","NO_occ_nos        ")
         DIE_IF(.NO_occ_nos.deallocated,"no NO_occ_nos")
         arch.write(.NO_occ_nos)


      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
         DIE_IF(.density_mx.deallocated,"no density_mx")
         if (do_norm) then
            .density_mx.renormalize(fbf,lbf,ang)
            arch.write(.density_mx)
            .density_mx.unnormalize(fbf,lbf,ang)
         else
            arch.write(.density_mx)
         end

      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
         DIE_IF(.fock_mx.deallocated,"no fock_mx")
         if (do_norm) then
            .fock_mx.renormalize(fbf,lbf,ang)
            arch.write(.fock_mx)
            .fock_mx.unnormalize(fbf,lbf,ang)
         else
            arch.write(.fock_mx)
         end

      case default
         UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   put_ascii_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.
      self :: INOUT

      name :: STR
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set the archive "name" and ascii format
      arch.set(.name,name,format="ascii")

      ! Write the archive, "genre" from object
      select case (name)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
       ! .MOs.renormalize("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.MOs,by_column=TRUE)
       ! .MOs.unnormalize("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         arch.write(.MO_energies,  by_column=TRUE)

      case ("natural_orbitals  ","NOs               ")
       ! .NOs.renormalize("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.NOs,  by_column=TRUE)
       ! .NOs.unnormalize("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("occupation_nos    ","NO_occ_nos        ")
         arch.write(.NO_occ_nos,by_column=TRUE)

      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
       ! .density_mx.renormalize(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.density_mx,    by_column=TRUE)
       ! .density_mx.unnormalize(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
      
      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
       ! .fock_mx.renormalize(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.fock_mx,       by_column=TRUE)
       ! .fock_mx.unnormalize(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case default
         UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   put_archive(opmatrix,archive_name,genre,with_lambda)
   ! Save "opmatrix" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      self :: IN
      opmatrix :: OPMATRIX, IN
      archive_name :: STR, IN
      genre        :: STR, optional, IN
      with_lambda  :: BIN, optional, IN

      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set(.name,archive_name)
      archive.write(opmatrix,genre)

      if (avec_lambda) then
         if (.scfdata.allocated) then
         if (.scfdata.SCF_kind.includes("xray_") OR .scfdata.SCF_kind.includes("pnd_")) then
       ! archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
         archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6")))
         archive.write(opmatrix,genre)
         end
         end
      end

   end

   put_archive(opvector,archive_name,genre,with_lambda)
   ! Save "opvector" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      self :: IN
      opvector :: OPVECTOR, IN
      archive_name :: STR, IN
      genre        :: STR, optional, IN
      with_lambda  :: BIN, optional, IN

      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set(.name,archive_name)
      archive.write(opvector,genre)
      if (avec_lambda) then
         if (.scfdata.allocated) then
         if (.scfdata.SCF_kind.includes("xray_") OR .scfdata.SCF_kind.includes("pnd_")) then
     !   archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
         archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6")))
         archive.write(opvector,genre)
         end
         end
      end

   end

   put_archive(item,archive_name,genre,with_lambda)
   ! Save "item" to an archive on disk with name "archive_name".
      self :: IN
      item :: REAL, IN
      archive_name :: STR, IN
      genre :: STR, optional, IN
      with_lambda :: BIN, optional, IN

      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set(.name,archive_name)
      archive.write(item,genre)

      if (avec_lambda) then
         if (.scfdata.allocated) then
         if (.scfdata.SCF_kind.includes("xray_") OR .scfdata.SCF_kind.includes("pnd_")) then
     !   archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
         archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6")))
         archive.write(item,genre)
         end
         end
      end

   end

!  ====
!  Dump
!  ====

   serialize(filename)
   ! Write out data from sbf file
      self :: IN 
      filename :: STR, IN
      datafile :: DATAFILE
      labels   :: STR(len=1), dimension(:,:), allocatable
      i, label_length :: INT

      label_length = 1

      if (tonto.is_master_processor) then

         ! how long is the longest label
         do i = 1, .atom.size
            if (len(trim(.atom(i).label)) > label_length) label_length = len(trim(.atom(i).label))
         end do
        
         ! need to convert the labels to an MxN character array
         allocate(labels(.atom.size, label_length))
         do i = 1, .atom.size
            labels(i, :) = .atom(i).label.character_array(label_length)
         end do
        
         datafile.open(filename)
         call datafile%sbf%add_dataset(sbf_Dataset("name", trim(.name)))
         call datafile%sbf%add_dataset(sbf_Dataset("basis_name", trim(.basis_name)))
         call datafile%sbf%add_dataset(sbf_Dataset("atomic_labels", labels))
         call datafile%sbf%add_dataset(sbf_Dataset("atomic_numbers", .atom(:).atomic_number))
         call datafile%sbf%add_dataset(sbf_Dataset("atomic_coordinates", .atom.coordinate_vector))
         call datafile%sbf%add_dataset(sbf_Dataset("charge_multiplicity", [.charge, .spin_multiplicity]))
        
        
         ! SCF data
         ! TODO should really check if it's created and DONE not just if it's unrestricted
         if (.scfdata.allocated) then
        
            select case (.scfdata.spinorbital_genre)
        
            case ("r ")
               call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("r ")))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx,r", .density_mx.r))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs,r", .MOs.r))
        
            case ("u ")
               call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("u ")))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx,a", .density_mx.a))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx,b", .density_mx.b))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs,a", .MOs.a))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs,b", .MOs.a))
        
            case default
               call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("r ")))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx", .density_mx.r))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs", .MOs.r))
               !DIE("Serializing these orbitals is not implemented")
        
            end
        
         end if
        
         call datafile%sbf%serialize
         datafile.close
       
      end if 

   end 

!  ==========================
!  Plot printing and deletion
!  ==========================

   dump_plot_grid(grid,name,form)
   ! Dump (write) out the plot "grid" to an appropriate file with
   ! "name", in various formats "form", otherwise (like most things)
   ! taken from the .plot_grid settings.
      self :: IN
      grid :: VEC{REAL}, INOUT
      name :: STR, IN
      form :: STR, optional, IN

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.atom.allocated, "no atoms")

      pos :: MAT{REAL}@
      valid :: VEC{INT}@
      bonds :: VEC{EVEC{INT}}@
      arch :: ARCHIVE
      title,fmt :: STR
      fac,z_range :: REAL

      if (.plot_grid.plot_units/=" ") then
         fac = .plot_grid.plot_units.conversion_factor
         grid = fac*grid
      end

      if (.plot_grid.use_plot_max) then
         where (grid>.plot_grid.plot_max) grid = .plot_grid.plot_max
      end

      if (.plot_grid.use_plot_min) then
         where (grid<.plot_grid.plot_min) grid = .plot_grid.plot_min
      end

      ! Set title
      title = .name
      if (.scfdata.allocated) then
      if (.scfdata.is_constrained_wavefunction) then
         title = trim(title)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))
      end
      end
      if (.plot_grid.allocated) then
      if (.plot_grid.plot_label/=" ") then
         title = trim(title)//","//trim(.plot_grid.plot_label)
      end
      end

      ! Get plot format
      fmt = .plot_grid.plot_format
      if (present(form)) fmt = form

      ! Dump all formats if none specified
      if (fmt=="all") then

         arch.set(title,name,format="contour")
         arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)
         arch.set(title,name,format="drishti.raw")
         arch.write_drishti(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="gnuplot")
         arch.write_gnuplot(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="gaussian.cube")
         arch.write_gaussian_cube(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="mathematica")
         arch.write_mathematica(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="spackman")
         arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)
         arch.set(title,name,format="vapor.raw")
         arch.write_vapor(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="vtk")
         arch.write_vtk(grid,.plot_grid,name)
         arch.set(title,name,format="xdgraph")
         arch.write_a_la_xdgraph(grid,.plot_grid,.atom)
         arch.set(title,name,format="xcrysden.xsf")
         arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="cell.cube")
         arch.write_gaussian_cell(grid,.plot_grid,.crystal.unit_cell_atom,name)

         if (.plot_grid.n_z==1) then
            arch.set(title,name,format="mathematica")
            z_range = ONE
            .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
            .atom(valid).make_connection_table(bonds)
            arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
            bonds.destroy
            pos.destroy
            valid.destroy
         end

      ! Dump specified format
      else

         select case (fmt)

         case ("contour")

            arch.set(title,name,format="contour")
            arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)

         case ("cube")

            arch.set(title,name,format="gaussian.cube")
            arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

         case ("drishti")

            arch.set(title,name,format="drishti.raw")
            arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("gaussian","gaussian.cube")

            arch.set(title,name,format="gaussian.cube")
            arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

         case ("cell.cube")

            arch.set(title,name,format="cell.cube")
            arch.write_gaussian_cell(grid,.plot_grid,.crystal.unit_cell_atom,name)

         case ("gnuplot")

            arch.set(title,name,format="gnuplot")
            arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("gnuplot.contour")

            ! Get rotated positions and data
            .atom.make_connection_table(bonds)
            .plot_grid.get_rotated_atom_positions(pos)

            ! Make the gnuplot plot archive
            ! Use all commas so that .eps can be handled by latex
            arch.set(title,name,format="gnuplot.contour")
            arch.set_use_all_commas(TRUE)
            arch.write_gnuplot_contour(grid,.plot_grid,pos,bonds)

            ! Clean
            pos.destroy
            bonds.destroy

         case ("spackman")

            arch.set(title,name,format="spackman")
            arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)

         case ("mathematica")

            arch.set(title,name,format="mathematica")
            arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            if (.plot_grid.n_z==1) then
               arch.set(title,name,format="mathematica")
               z_range = ONE
               .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
               .atom(valid).make_connection_table(bonds)
               arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
               bonds.destroy
               pos.destroy
               valid.destroy
            end

         case ("vapor")

            arch.set(title,name,format="vapor.raw")
            arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("vtk")

            arch.set(title,name,format="vtk")
            arch.write_vtk(grid,.plot_grid,name)

         case ("xcrysden")

            arch.set(title,name,format="xcrysden.xsf")
            arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)

         case ("xdgraph")

            arch.set(title,name,format="xdgraph")
            arch.write_a_la_xdgraph(grid,.plot_grid,.atom)

         case default

            UNKNOWN(fmt)

         end

      end

   end

end
