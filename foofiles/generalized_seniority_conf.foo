!-------------------------------------------------------------------------------
!
! GENERALIZED_SENIORITY_CONF
!
! Copyright (C) Patrick Cassam-Chenai, Thomas Perez 2017
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!
!-------------------------------------------------------------------------------

module GENERALIZED_SENIORITY_CONF

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create ::: leaky
   ! Create a GSN based configuration list 
      self :: PTR
      nullify(self)
      allocate(self)
      .nullify_ptr_part
   end

   create(n_shells,shell_dims) ::: leaky
   ! Create a GSN based configuration list for a partition into n_shells
      self :: PTR
      n_shells :: INT
      shell_dims :: VEC{INT}*
      nullify(self)
      allocate(self)
      .nullify_ptr_part
      .set_defaults(n_shells,shell_dims)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self  
    nullify(.GSN_set)
    nullify(.shells)
    nullify(.shell_dims)
    nullify(.shell_occupation_nb)
  !  nullify(.configuration_list)
    nullify(.configuration_vec)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
    .GSN_set.destroy
    .shells.destroy
    .shell_dims.destroy
    .shell_occupation_nb.destroy
   ! .configuration_list.destroy
    .configuration_vec.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     self :: PTR
     b :: GENERALIZED_SENIORITY_CONF, IN

     .create(b.n_shells,b.shell_dims)
     .copy(b)

   end

   copy(b) ::: leaky
   ! Copy a GSN "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
     b :: GENERALIZED_SENIORITY_CONF, IN
     self = b
      if (b.GSN_set.created)             .GSN_set.create_copy(b.GSN_set)
      if (b.shells.created)              .shells.create_copy(b.shells)
      if (b.shell_dims.created)          .shell_dims.create_copy(b.shell_dims)
      if (b.shell_occupation_nb.created) .shell_occupation_nb.create_copy(b.shell_occupation_nb)
!      if (b.configuration_list.created)  .configuration_list.create_copy(b.configuration_list)
      if (b.configuration_vec.created)   .configuration_vec.create_copy(b.configuration_vec)
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  ===========
!  Set methods
!  ===========

   set_defaults(n_shells,shell_dims) ::: leaky
   ! Create a default object.
     n_shells :: INT
     shell_dims :: VEC{INT}*
     .n_shells=n_shells
     .shell_dims.create(n_shells)
     .shell_dims=shell_dims
   end

!  ============
!  I/O Routines
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
    ! self :: PTR
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("put                     "); .put
       case ("junk=                   "); .read_junk
       case ("units=                  "); .read_units
       case ("n_shells=               "); .read_n_shells
       case ("shell_dims=               "); .read_shell_dims
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

     read_n_shells
     ! Read nb of shells
     !  self :: PTR
       n_shells :: INT
       stdin.read(n_shells)
       .n_shells=n_shells
     end

     read_shell_dims ::: leaky
     ! Read shell dimensions
     !  self :: PTR
       .shell_dims.create(.n_shells)
       stdin.read(.shell_dims)
     end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!  ===============
!  Inquiry methods
!  ===============

!   same_as(b) result(res) 
!   ! Return TRUE if the basis set "self" is the same as "b". Only the
!   ! shell vector is compared to see if they are "really" the same.
!      self :: IN
!      b :: GEMINAL_MF_SCHEME, IN
!      res :: BIN
!      res = FALSE
!   end

!  ==============
!  Output methods
!  ==============

   put
   ! Print out the object

      stdout.text(" ")
      stdout.text(" ")
      stdout.text("GSN info:")
      stdout.text(" ")
      stdout.show("number of shells in the partition =",.n_shells)
      stdout.text(" ")
      stdout.show("shell dimensions =",.shell_dims)
   end

!  ===============
!  GSN methods
!  ===============

   make_conf
   ! 
     n_shells :: INT
     shell_dims :: VEC{INT}*
     n_shells=.n_shells
     shell_dims.create(n_shells)
     shell_dims=.shell_dims

   end

   make_orbitals(ham)
     ham :: MAT{REAL}*
     n_bas :: INT
     eigenvec :: MAT{REAL}*
     eigenval :: VEC{REAL}*
     n_bas=60
!   ham.create(n_bas,n_bas)
!   ham=ZERO
!   ham(1,9)=-ONE
!   do j=1,n_bas-1
!     ham(j,j+1)=-ONE
!     ham(j+1,j)=-ONE
!   end
     stdout.text(" ")
     stdout.text("The Hamiltonian is ")
     stdout.text(" ")
     stdout.put(ham)
     stdout.text(" ")
     eigenvec.create(n_bas,n_bas)
     eigenval.create(n_bas)
     ham.solve_symmetric_eigenproblem(eigenval,eigenvec) 
     ham.destroy 
     stdout.text(" ")
     stdout.text("The eigenvalues are ")
     stdout.text(" ")
     stdout.put(eigenval)
     stdout.text(" ")
   end

end
