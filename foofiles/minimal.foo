   put_CIF_ADPn_cartn_minimal(cif,esd) ::: private
   ! Output cartesian anharmonic ADPs in CIF format to "stdout".
   ! This version produces errors, stored in "esd".
      self :: IN
      cif :: CIF, IN
      esd :: VEC{REAL}, IN

   ENSURE(esd.dim==.no_of_pADPS,"wrong sizem esd")

      ADP :: VEC{REAL}(15)
      err :: VEC{REAL}(15)
      lab,ADPn_label :: STR
      i,k :: INT
      fac1,fac2 :: REAL
      fac3,fac4 :: REAL

      ! Unit conversion for ADP's
      fac1 = ANGSTROM_PER_BOHR
      fac2 = fac1*fac1
      fac3 = fac2*fac1
      fac4 = fac2*fac2

      ! ==========
      ! Put ADP3's 
      ! ==========
      if (.has_any_ADP3s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP3_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP3s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^3 but may be scaled")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC3_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,10
         lab = ATOM:ADP3_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP3s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors
            self(i).put_ADP3_vector_to(ADP(1:10))
            err(1:10) = esd(k+10:k+19)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:10) = ADP(1:10)*fac3
            err(1:10) = err(1:10)*fac3

            ! Scale by scale factor
            ADP(1:10) = ADP(1:10)*cif.GC3_scale_factor
            err(1:10) = err(1:10)*cif.GC3_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(err( 1))
            stdout.flush
            stdout.put(ADP( 2))
            stdout.put(err( 2))
            stdout.flush
            stdout.put(ADP( 3))
            stdout.put(err( 3))
            stdout.flush
            stdout.put(ADP( 4))
            stdout.put(err( 4))
            stdout.flush
            stdout.put(ADP( 5))
            stdout.put(err( 5))
            stdout.flush
            stdout.put(ADP( 6))
            stdout.put(err( 6))
            stdout.flush
            stdout.put(ADP( 7))
            stdout.put(err( 7))
            stdout.flush
            stdout.put(ADP( 8))
            stdout.put(err( 8))
            stdout.flush
            stdout.put(ADP( 9))
            stdout.put(err( 9))
            stdout.flush
            stdout.put(ADP(10))
            stdout.put(err(10))
            stdout.flush

            k = k + self(i).no_of_pADPs
        
         end

      end

      ! ==========
      ! Put ADP4's
      ! ==========
      if (.has_any_ADP4s_and_errors) then

         ADPn_label = "_atom_site_Cartn_ADP4_U_"

         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Cartesian ADP4s")
         stdout.text("# ===============")
         stdout.flush
         stdout.text("# . These precise data use non-standard CIF tags")
         stdout.text("# . Please keep for a better refinement restart")
         stdout.text("# . Units are in Angstrom^4")
        
         stdout.flush
         stdout.text(trim(ADPn_label)//"scale_factor "//trim(cif.GC4_scale_factor.to_str))
         stdout.flush
         stdout.text("loop_")
         stdout.text(trim(ADPn_label)//"label")

         do i = 1,15
         lab = ATOM:ADP4_index_label(i,form="123-repeated")
         stdout.text(trim(ADPn_label)//trim(lab))
         stdout.text(trim(ADPn_label)//trim(lab)//"_esu")
         end

         k = 0
         do i = 1,.dim
        
            if (NOT self(i).has_ADP4s_and_errors) cycle
        
            stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
            stdout.flush
        
            ! Get values and errors (dimensionless)
            self(i).put_ADP4_vector_to(ADP(1:15))
            err(1:15) = esd(k+20:k+34)

            ! Units !!!!!!!!!!!!!!!!!!
            ADP(1:15) = ADP(1:15)*fac4
            err(1:15) = err(1:15)*fac4

            ! Scale by scale factor
            ADP(1:15) = ADP(1:15)*cif.GC4_scale_factor
            err(1:15) = err(1:15)*cif.GC4_scale_factor
        
            ! Put quantity q with full error.
            stdout.put(ADP( 1))
            stdout.put(err( 1))
            stdout.flush
            stdout.put(ADP( 2))
            stdout.put(err( 2))
            stdout.flush
            stdout.put(ADP( 3))
            stdout.put(err( 3))
            stdout.flush
            stdout.put(ADP( 4))
            stdout.put(err( 4))
            stdout.flush
            stdout.put(ADP( 5))
            stdout.put(err( 5))
            stdout.flush
            stdout.put(ADP( 6))
            stdout.put(err( 6))
            stdout.flush
            stdout.put(ADP( 7))
            stdout.put(err( 7))
            stdout.flush
            stdout.put(ADP( 8))
            stdout.put(err( 8))
            stdout.flush
            stdout.put(ADP( 9))
            stdout.put(err( 9))
            stdout.flush
            stdout.put(ADP(10))
            stdout.put(err(10))
            stdout.flush
            stdout.put(ADP(11))
            stdout.put(err(11))
            stdout.flush
            stdout.put(ADP(12))
            stdout.put(err(12))
            stdout.flush
            stdout.put(ADP(13))
            stdout.put(err(13))
            stdout.flush
            stdout.put(ADP(14))
            stdout.put(err(14))
            stdout.flush
            stdout.put(ADP(15))
            stdout.put(err(15))
            stdout.flush
        
            k = k + self(i).no_of_pADPs
        
         end

      end ! =========

   end
