!---------------------------------------------------------------------------
!
!  VEC{REFLECTION}: a vector of crystal reflection data
!
! Copyright (C) Daniel Grimwood, 2000
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module VEC{REFLECTION}

   implicit none

 ! saved_self :: VEC{REFLECTION}*, private  DEFAULT_NULL

contains

!  ==========
!  Allocation
!  ==========

   create(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Create space for object. This version does not nullify ptr parts.
   end

   destroy ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Destroy space for object. This version does not destroy ptr parts
   end

!  ====
!  Copy
!  ====

   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Create a replica copy of "vec".
   end

   copy(vec) ::: get_from(VEC{OBJECT}), PURE
   ! Copy "vec".
   end

!  =======================
!  Shrinking and expansion
!  =======================

   shrink(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Shrink self to dimension dim.  Contents are retained.
   end

   expand(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Expand the vector "self" to "dim". New slots are left undefined.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Expands self and appends the contents of vector "v".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Expands self by 1, and appends the single scalar "value" onto the end.
   end

!  ============
!  Set routines
!  ============

   set_defaults ::: get_from(VEC{OBJECT}, leaky, pure
   ! Set default values
   end

   reset_F_exp_F_sigma ::: pure
   ! Finalize the reflections
      self :: INOUT

      n :: INT

      do n = 1,.dim
         self(n).reset_F_exp_F_sigma
      end

   end

   reset_I_exp_I_sigma ::: pure
   ! Finalize the reflections
      self :: INOUT

      n :: INT

      do n = 1,.dim
         self(n).reset_I_exp_I_sigma
      end

   end


   set_h(h) ::: pure
   ! Set the h indices
      self :: INOUT
      h :: VEC{INT}, IN

      i :: INT

      do i = 1,.dim
         self(i).h = h(i)
      end

   end

   set_k(k) ::: pure
   ! Set the k indices
      self :: INOUT
      k :: VEC{INT}, IN

      i :: INT

      do i = 1,.dim
         self(i).k = k(i)
      end

   end

   set_l(l) ::: pure
   ! Set the l indices
      self :: INOUT
      l :: VEC{INT}, IN

      i :: INT

      do i = 1,.dim
         self(i).l = l(i)
      end

   end


   set_F_calc(F_calc) ::: pure
   ! Set the calculated structure factors
   ! Also set calculated intensities.
      self :: INOUT
      F_calc :: VEC{CPX}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_F_calc(F_calc(n))
      end

   end

   set_I_calc(I_calc) ::: pure
   ! Set the calculated intensities
      self :: INOUT
      I_calc :: VEC{REAL}, IN

   ENSURE(I_calc.dim==.dim,"I_calc: wrong size")

      n :: INT

      do n = 1,.dim
         self(n).set_I_calc(I_calc(n))
      end

   end

   set_F_pred(F_pred) ::: pure
   ! Set the predicted structure factors
   ! Also set predicted intensities.
      self :: INOUT
      F_pred :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_F_pred(F_pred(n))
      end

   end

   set_I_pred(I_pred) ::: pure
   ! Set the predicted predicted intensities.
      self :: INOUT
      I_pred :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_I_pred(I_pred(n))
      end

   end

   set_F_exp(F_exp) ::: pure
   ! Set the experimental structure factors
      self :: INOUT
      F_exp :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_F_exp(F_exp(n))
      end

   end

   set_I_exp(I_exp) ::: pure
   ! Set the experimental F2 structure factors
      self :: INOUT
      I_exp :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_I_exp(I_exp(n))
      end

   end

   set_F_sigma(F_sigma)
   ! Set the experimental structure factor errors
   ! NOTE: must call after set_F_exp
      self :: INOUT
      F_sigma :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_F_sigma(F_sigma(n))
      end

   end

   set_I_sigma(I_sigma)
   ! Set the experimental F2 structure factor errors
      self :: INOUT
      I_sigma :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_I_sigma(I_sigma(n))
      end

   end


   set_F_disp(F_disp) ::: pure
   ! Set the anomalous dispersion continuation.
      self :: INOUT
      F_disp :: VEC{CPX}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_F_disp(F_disp(n))
      end

   end

   set_F_corr(values) ::: pure
   ! Set .F_corr values to "values".
      self :: INOUT
      values :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).set_F_corr(values(n))
      end

   end

   reset_F_corr_to_F_exp ::: pure
   ! Reset F_corr values to the original F_exp values.
   ! Leastt do any sanity checks.
      self :: INOUT

      n :: INT

      do n = 1,.dim
         self(n).reset_F_corr_to_F_exp
      end

   end


   remove_anom_from_F_exp(scale_factor)
   ! Remove anomalous dispersion from F_exp to make F_corr
   ! Only used when using the "XD" method.
      self :: INOUT
      scale_factor :: REAL, IN

      n :: INT

      do n = 1,.dim
         self(n).remove_anom_from_F_exp(scale_factor)
      end

   end

   remove_anom_from_F_calc ::: PURE
   ! Remove anomalous dispersion from F_calc.
   ! Only used when using the "XD" method.
      self :: INOUT

      n :: INT

      do n = 1,.dim
         self(n).remove_anom_from_F_calc
      end

   end


   set_equivalence_factors(spacegroup) ::: PURE
   ! Set the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      self :: INOUT
      spacegroup :: SPACEGROUP, IN

      hkl,new :: VEC{INT}(3)
      n,s,u :: INT

      do n = 1,.dim

         hkl = .indices(n)

         u = 1
         do s = 2,spacegroup.n_seitz
            new = int(matmul(REALIFY(hkl),spacegroup.seitz(1:3,1:3,s)))
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end

         self(n).equivalence_factor = u

      end

   end

   set_d_and_theta(cell) ::: PURE
   ! Called after the reflections are read in, in order to set all the
   ! .d and .theta values, which are used later all over the place ...
   ! NOTE: Make sure the wavelength is correct, else angles are wrong.
   ! NOTE: see Dunitz "X-ray Analysis" (1995) p. 35
      self :: INOUT
      cell :: UNIT_CELL, IN

      h :: VEC{INT}(3)
      hv :: VEC{REAL}(3)
      lambda,stl,d :: REAL
      n :: INT

      lambda = REFLECTION:wavelength()

      do n = 1,.dim

         h   = .indices(n)

         hv  = matmul(cell.reciprocal_matrix,h)
         d   = ONE/hv.norm ! with HBB 6/2/16
         stl = HALF/d

         self(n).stl   = stl
         self(n).theta = asin(stl*lambda)
         self(n).d     = d

      end

   end

!   set_theta_angles(reciprocal_matrix) ::: pure
!   ! This routine is called after the reflections are read in, in
!   ! order to set all the .theta values, which are used later all over
!   ! the place ...
!   ! NOTE: Make sjure the wavelength is correct!
!      self :: INOUT
!      reciprocal_matrix :: MAT{REAL}(3,3), IN
!
!      hkl :: VEC{INT}(3)
!      kx,ky,kz,sin_theta,lambda,fac :: REAL
!      n :: INT
!
!      fac = ONE/(FOUR*PI)
!
!      lambda = REFLECTION:wavelength()
!
!      do n = 1,.dim
!
!         hkl = .indices(n)
!
!         kx = dot_product(reciprocal_matrix(1,:),hkl(:))
!         ky = dot_product(reciprocal_matrix(2,:),hkl(:))
!         kz = dot_product(reciprocal_matrix(3,:),hkl(:))
!
!         sin_theta     = fac*sqrt(kx*kx+ky*ky+kz*kz)*lambda
!         self(n).theta = asin(sin_theta)
!
!      end
!
!   end


!  ================
!  Scaling routines
!  ================

   scale_F_exp(fac) ::: pure
   ! Scale the experimental structure factors
      self :: INOUT
      fac :: REAL, IN

      n :: INT

      do n = 1,.dim
         self(n).F_exp = self(n).F_exp * fac
      end

   end

   scale_F_exp(fac) ::: pure
   ! Scale the experimental structure factors
      self :: INOUT
      fac :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).F_exp = self(n).F_exp * fac(n)
      end

   end

   scale_F_corr(fac) ::: pure
   ! Scale the "corrected" experimental structure factors
      self :: INOUT
      fac :: REAL, IN

      n :: INT

      do n = 1,.dim
         self(n).F_corr = self(n).F_corr * fac
      end

   end

   scale_F_corr(fac) ::: pure
   ! Scale the "corrected" experimental structure factors
      self :: INOUT
      fac :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).F_corr = self(n).F_corr * fac(n)
      end

   end

   scale_F_sigma(fac) ::: pure
   ! Scale the experimental structure factor errors
      self :: INOUT
      fac :: REAL, IN

      n :: INT

      do n = 1,.dim
         self(n).F_sigma = self(n).F_sigma * fac
      end

   end

   scale_F_sigma(fac) ::: pure
   ! Scale the experimental structure factor errors
      self :: INOUT
      fac :: VEC{REAL}, IN

      n :: INT

      do n = 1,.dim
         self(n).F_sigma = self(n).F_sigma * fac(n)
      end

   end

   scale_I_exp(fac) ::: pure
   ! Scale the experimental intensities
      self :: INOUT
      fac :: REAL, IN

      n :: INT

      do n = 1,.dim
         self(n).I_exp = self(n).I_exp * fac
      end

   end

   scale_I_sigma(fac) ::: pure
   ! Scale the experimental intensity errors
      self :: INOUT
      fac :: REAL, IN

      n :: INT

      do n = 1,size(self)
         self(n).I_sigma = self(n).I_sigma * fac
      end

   end


!  ================
!  Inquiry Routines
!  ================

   n_refl result (res) ::: pure
   ! The number of reflections
      self :: IN
      res :: INT

      res = size(self)

   end


   have_F_calc result (res) ::: pure
   ! Whether we have any calculated structure factors
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).F_calc) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end

   have_F_pred result (res) ::: pure
   ! Whether we have any predicted structure factors
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).F_pred) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end

   have_F_exp result (res) ::: pure
   ! Whether we have any experimental structure factors.
   ! NOTE: If we have F_exp then we have F_corr also.
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).F_exp) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end

   have_F_sigma result (res) ::: pure
   ! Whether we have any errors in the structure factors
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).F_sigma) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end


   have_I_calc result (res) ::: pure
   ! Whether we have any F2
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).I_calc) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end

   have_I_pred result (res) ::: pure
   ! Whether we have any predicted intensities
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).I_pred) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end

   have_I_exp result (res) ::: pure
   ! Whether we have any experimental intensities
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).I_exp) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end

   have_I_sigma result (res) ::: pure
   ! Whether we have any errors in the intensities
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (abs(self(n).I_sigma) > TOL(10)) then
            res = TRUE
            exit
         end
      end

   end


   have_indices result (res) ::: pure
   ! Whether we have the Miller indices
      self :: IN
      res :: BIN

      n :: INT

      res = FALSE
      do n = 1,.dim
         if (self(n).h /= 0 OR self(n).k /= 0 OR self(n).l /= 0) then
            res = TRUE
            exit
         end
      end

   end

   indices(n) result (res) ::: pure
   ! Return the miller indices of reflection n.
      self :: IN
      n :: INT, IN
      res :: VEC{INT}(3)

      res = [ self(n).h, self(n).k, self(n).l ]

   end

   use_multiple_scale_factors result (res) ::: pure
   ! Return TRUE if we are supposed to use multiple scale factors.
      self :: IN
      res :: BIN

      res = any(self.group>0)

   end


   d_max result (res) ::: pure
   ! The maximum d spacing/resolution in au
      self :: IN
      res :: REAL

      res = maxval(self(:).d)

   end

   d_min result (res) ::: pure
   ! The minimum d spacing/resolution in au
      self :: IN
      res :: REAL

      res = minval(self(:).d)

   end


   h_max result (res) ::: pure
   ! Return the maximum Miller indices
      self :: IN
      res  :: VEC{INT}(3) 

      res(1) = maxval(self(:).h)
      res(2) = maxval(self(:).k)
      res(3) = maxval(self(:).l)

   end

   h_min result (res) ::: pure
   ! Return the minimum Miller indices
      self :: IN
      res  :: VEC{INT}(3) 

      res(1) = minval(self(:).h)
      res(2) = minval(self(:).k)
      res(3) = minval(self(:).l)

   end


   get_all_Friedel_pairs(mult) ::: PURE
   ! Returns TRUE if the list of reflections is Friedel unmerged.
   ! *Every* reflection must have matching Friedel pair.
   ! "mult" is set to 1 if there is a matching Friedel, 2 otherwise.
   ! It can be used as a scaling factor when calculating residual
   ! or other electron densities.
      self :: IN
      mult :: VEC{INT}, OUT

   ENSURE(mult.dim==.dim,"wrong size, match array")

      p,q :: VEC{INT}(3)
      i,j, n_refl :: INT
      same :: BIN

      ! No. of reflections
      n_refl = self.dim

      ! Loop reflections
      mult = 2
      same  = FALSE
      do i = 1,n_refl

         ! Skip those already matched
         if (mult(i)==1) cycle

         p = self(i).indices

         ! Find the matching pair
         same = FALSE
         do j = i+1,n_refl

            ! Skip those already matched
            if (mult(j)==1) cycle

            q = -self(j).indices

            same = p.same_as(q)
            if (same) then
               mult(i) = 1
               mult(j) = 1
            end

         end

      end
        
   end

   has_all_Friedel_pairs result (res) ::: PURE
   ! Returns TRUE if the list of reflections is Friedel unmerged.
   ! *Every* reflection must have matching Friedel pair.
      self :: IN
      res :: BIN

      p, q  :: VEC{INT}(3)
      match :: VEC{INT}@
      i,j, n_refl :: INT
      same :: BIN

      ! No. of reflections
      n_refl = self.dim

      ! Can't be unmerged if it is not even
      res = n_refl.is_even
      if (NOT res) return

      ! Matches
      match.create(n_refl)
      match = 0

      ! Loop reflections
      same = FALSE
      do i = 1,n_refl

         ! Skip those already matched
         if (match(i)>0) cycle

         p = self(i).indices

         ! Find the matching pair
         same = FALSE
         do j = i+1,n_refl

            ! Skip those already matched
            if (match(j)>0) cycle

            q = -self(j).indices

            same = p.same_as(q)
            if (same) then
               match(i) = j
               match(j) = i
            end

         end

      end

      res = all(match>0)

      match.destroy
        
   end

   has_Friedel_pairs result (res) ::: PURE
   ! Returns TRUE if there is at least *one* Friedel pair.
      self :: IN
      res :: BIN

      p,q :: VEC{INT}(3)
      i,j, n_refl :: INT
      same :: BIN

      ! No. of reflections
      n_refl = self.dim

      ! Loop reflections
      same = FALSE
      refl: do i = 1,n_refl
         p = self(i).indices
         same = FALSE
         do j = i+1,n_refl
            q = -self(j).indices
            same = p.same_as(q)
            ! Is Friedel?
            if (same) exit refl
         end
      end do refl

      res = same
        
   end

   n_unmatched_Friedel_pairs result (res) ::: PURE
   ! This is also one way to test if the reflections are
   ! Friedel-merged ....
      self :: IN
      res  :: INT

      mult :: VEC{INT}@

      mult.create(.dim)
      .get_all_Friedel_pairs(mult)
      res = count(mult==2)
      mult.destroy

   end

!  ==================
!  Enquiry statistics
!  ==================

   add_noise(dsigma)
   ! Reset experimental data to reflect addition of noise "dsigma" in
   ! units of sigma. The noise is assumed normally distributed.
   ! NOTE: F_sig is also reset! So chi2(F) should be fit to the same level
   ! NOTE: Noise is added 
   !       after  small F_sig's are removed, but
   !       before small F_exp/F_sig
      self :: INOUT
      dsigma :: REAL, IN

      n :: INT
      dF :: REAL

      do n = 1,.dim

         ! dF has mean zero, standard deviation one
         dF.to_random_normal 
         dF = dF*dsigma

         ! Reset
         self(n).F_corr  = self(n).F_corr  + dF         *self(n).F_sigma
         self(n).F_sigma = self(n).F_sigma + abs(dsigma)*self(n).F_sigma

      end

   end


   F_chi2 result (res) ::: PURE
   ! chi2 for the structure factors
      self :: IN
      res :: REAL

   ENSURE(.have_F_pred,"no predicted structure factors")
   ENSURE(.have_F_exp,"no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")

      z :: REAL
      n :: INT

      res = ZERO

      do n = 1,.dim
         z = self(n).F_z
         res = res + z*z
      end

      res = res / max(.dim - 1,1)

   end

   I_chi2 result (res) ::: PURE
   ! chi2 for the intensities
      self :: IN
      res :: REAL

   ENSURE(.have_I_pred, "no predicted intensities")
   ENSURE(.have_I_exp,  "no experimental intensities")
   ENSURE(.have_I_sigma,"no experimental intensity errors")

      z :: REAL
      n :: INT

      res = ZERO
      do n = 1,.dim
         z   = self(n).I_z
         res = res + z*z
      end

      res = res / max(.dim - 1,1)

   end


   F_goodness_of_fit result (res) ::: PURE
   ! goodness_of_fit for the structure factors
      self :: IN
      res :: REAL

      res = sqrt(.F_chi2)

   end

   I_goodness_of_fit result (res) ::: PURE
   ! goodness_of_fit for the intensities
      self :: IN
      res :: REAL

      res = sqrt(.I_chi2)

   end


   F_r_factor result (res) ::: PURE
   ! r factor for the structure factors
      self :: IN
      res :: REAL

   ENSURE(.have_F_pred,"no predicted structure factors")
   ENSURE(.have_F_exp,"no experimental structure factors")
      top,bot :: REAL

      n :: INT

      top = ZERO
      bot = ZERO

      do n=1,size(self)
         top = top + abs(self(n).F_pred - self(n).F_corr)
         bot = bot + abs(self(n).F_corr)
      end

      res = top / bot

   end

   F2_r_factor result (res) ::: PURE
   ! r factor for the structure factors *squared*
      self :: IN
      res :: REAL

   ENSURE(.have_F_pred,"no predicted structure factors")
   ENSURE(.have_F_exp,"no experimental structure factors")

      top,bot,Fp2,Fe2 :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n = 1,.dim

         Fp2 = self(n).F_pred; Fp2 = Fp2*Fp2
         Fe2 = self(n).F_corr;  Fe2 = Fe2*Fe2

         top = top + abs(Fp2 - Fe2)
         bot = bot + abs(Fe2)

      end

      res = top / bot

   end

   I_r_factor result (res) ::: PURE
   ! R factor for the intensities
      self :: IN
      res :: REAL

   ENSURE(.have_I_pred,"no predicted structure factors")
   ENSURE(.have_I_exp,"no experimental structure factors")

      top,bot :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n = 1,.dim
       top = top + abs(self(n).I_pred - self(n).I_exp)
       bot = bot + abs(self(n).I_exp)
      end

      res = top / bot

   end


   F_r_sigma result (res) ::: PURE
   ! The R_sigma(F) for the structure factors
      self :: IN
      res :: REAL

   ENSURE(.have_F_exp,  "no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")

      top,bot :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n = 1,.dim
         top = top + abs(self(n).F_sigma)
         bot = bot + abs(self(n).F_corr)
      end

      res = top / bot

   end

   F2_r_sigma result (res) ::: PURE
   ! The R_sigma(F2) for the structure factors
      self :: IN
      res :: REAL

   ENSURE(.have_F_exp,  "no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")

      top,bot :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n = 1,.dim
         top = top + abs(self(n).F_sigma)**2
         bot = bot + abs(self(n).F_corr)**2
      end

      res = top / bot

   end

   I_r_sigma result (res) ::: PURE
   ! The R_sigma(I) for the structure factors
      self :: IN
      res :: REAL

   ENSURE(.have_I_exp,  "no experimental intensities")
   ENSURE(.have_I_sigma,"no experimental intensity errors")

      top,bot :: REAL
      n :: INT

      top = ZERO
      bot = ZERO
      do n = 1,.dim
         top = top + abs(self(n).I_sigma)
         bot = bot + abs(self(n).I_exp)
      end

      res = top / bot

   end


   F_weighted_r_factor result (res) ::: PURE
   ! weighted r factor for the structure factors
      self :: IN
      res :: REAL

   ENSURE(.have_F_exp,  "no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")
   ENSURE(.have_F_pred, "no predicted structure factors")

      top,bot,z,b :: REAL
      n :: INT

      top = ZERO
      bot = ZERO
      do n = 1,.dim
         z = self(n).F_z
         b = self(n).F_corr / self(n).F_sigma
         top = top + z*z
         bot = bot + b*b
      end

      res = sqrt(top / bot)

   end

   F2_weighted_r_factor result (res) ::: PURE
   ! Weighted r factor for the structure factors *squared*
   ! NOTE: sigma is equal to (2 F_exp * F_sigma) 
   !       *not* F_sigma or F2_sigma and this is only
   !       appropriate for F refinement.
      self :: IN
      res :: REAL

   ENSURE(.have_F_exp,  "no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")
   ENSURE(.have_F_pred, "no predicted structure factors")

      top,bot,Fe,Fp,sg,z,b,Fe2,Fp2 :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n = 1,.dim

         Fp = self(n).F_pred; Fp2 = Fp*Fp
         Fe = self(n).F_corr; Fe2 = Fe*Fe

         sg = TWO * self(n).F_corr * self(n).F_sigma

         z  = (Fe2 - Fp2)/sg
         b  = Fe2/sg

         top = top + z*z
         bot = bot + b*b

      end

      res = sqrt(top / bot)

   end

   I_weighted_r_factor result (res) ::: PURE
   ! weighted r factor for the intensities
      self :: IN
      res :: REAL

   ENSURE(.have_I_exp,  "no experimental intensities")
   ENSURE(.have_I_sigma,"no experimental intensity errors")
   ENSURE(.have_I_pred, "no predicted intensities")

      top,bot,z,b :: REAL
      n :: INT

      top = ZERO
      bot = ZERO
      do n = 1,.dim
         z = self(n).I_z
         b = self(n).I_exp / self(n).I_sigma
         top = top + z*z
         bot = bot + b*b
      end

      res = sqrt(top / bot)

   end


   F2_calc_abs result (res) ::: pure
   ! Return the square of the magnitude of the calculated structure
   ! factors, F_calc
      self :: IN
      res :: VEC{REAL}(.dim)

      res = abs(self(:).F_calc)
      res = res*res

   end

   F_calc_abs result (res) ::: pure
   ! Return the magnitude of the calculated structure factors
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = abs(self(:).F_calc)

   end

   F_calc result (res) ::: pure
   ! return the calculated structure factors
      self :: IN
      res :: VEC{CPX}(size(self))

      res(:) = self(:).F_calc

   end


   F_pred result (res) ::: PURE
   ! return the predicted structure factors
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_pred

   end


   F_exp result (res) ::: PURE
   ! Return the experimental structure factors
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_exp

   end

   F2_exp result (res) ::: PURE
   ! Return the experimental structure factors *squared*
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_exp* self(:).F_exp


   end

   F_corr result (res) ::: PURE
   ! Return the "corrected" experimental structure factors
   ! The correction may be because of e.g. removal of dispersion.
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_corr

   end

   F2_corr result (res) ::: PURE
   ! Return the "corrected" experimental structure factors *squared*
   ! The correction may be because of e.g. removal of dispersion.
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_corr* self(:).F_corr


   end

   I_pred result (res) ::: PURE
   ! return the predicted intensities
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).I_pred

   end

   F_sigma result (res) ::: PURE
   ! return the errors in the experimental structure factors
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_sigma

   end

   F2_sigma result (res) ::: PURE
   ! Return the errors in the experimental structure factors *squared*
      self :: IN
      res :: VEC{REAL}(size(self))

      res(:) = self(:).F_sigma*self(:).F_sigma

   end

   sigma2_eff result (res) ::: PURE
   ! Return the effective (mean) value of chi2 maybe useful
   ! for starting and ending constrained fit.
      self :: IN
      res :: REAL

   ENSURE(.have_F_pred,"no predicted structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")
   ENSURE(.have_F_exp,"no experimental structure factors")

      top,bot,del,sig :: REAL
      r :: INT

      res = ZERO

      if (NOT .have_F_exp) return

      top = ZERO
      bot = ZERO

      do r = 1,.dim

         sig = self(r).F_sigma
         sig = sig*sig
         del = self(r).F_corr - self(r).F_pred
         del = del*del

         top = top + del
         bot = bot + del/sig

      end

      res = top/bot

   end

!  =============
!  Make k points
!  =============

   make_k_pts(k_pt,unit_cell) ::: pure
   ! Make the reciprocal lattice vectors
   ! Dimension of "k_pt" is [.n_refl,3]
      self :: IN
      k_pt :: MAT{REAL}, OUT
      unit_cell :: UNIT_CELL, IN

      n :: INT
      hkl :: VEC{INT}(3)
      rcm :: MAT{REAL}(3,3)

      rcm = TWO*PI*unit_cell.reciprocal_matrix

      do n = 1,.dim

         hkl = self(n).indices

         k_pt(n,1) = dot_product(rcm(1,:),hkl(:))
         k_pt(n,2) = dot_product(rcm(2,:),hkl(:))
         k_pt(n,3) = dot_product(rcm(3,:),hkl(:))

      end

   end

   n_unique_SF_k_pts(spacegroup) result (res) ::: pure
   ! The number of unique k-points for an SF calculation
      self :: IN
      spacegroup :: SPACEGROUP, IN
      res :: INT

      res = spacegroup.n_unique_SF_symops * .dim

   end

   make_unique_SF_k_pts(k,spacegroup,unit_cell) ::: PURE
   ! Make the non-translational non-inverted symmetry generated
   ! reciprocal lattice vectors "k" required for structure factor
   ! calculations.
      self :: IN
      k :: MAT{REAL}, OUT
      spacegroup :: SPACEGROUP, IN
      unit_cell :: UNIT_CELL, IN

   ENSURE(k.dim1==spacegroup.n_unique_SF_symops*.dim,"k: wrong dim1")
   ENSURE(k.dim2==3,"k: wrong dim2")

      .make_unique_SF_k_pts(k(:,1),k(:,2),k(:,3),spacegroup,unit_cell)

   end

   make_unique_SF_k_pts(k1,k2,k3,spacegroup,unit_cell) ::: PURE
   ! Make the non-translational non-inverted symmetry generated
   ! reciprocal lattice vectors "k" required for structure factor
   ! calculations.
      self :: IN
      k1,k2,k3 :: VEC{REAL}, OUT
      spacegroup :: SPACEGROUP, IN
      unit_cell :: UNIT_CELL, IN

   ENSURE(k1.dim==spacegroup.n_unique_SF_symops*.dim,"k1: wrong dim")
   ENSURE(k2.dim==spacegroup.n_unique_SF_symops*.dim,"k2: wrong dim")
   ENSURE(k3.dim==spacegroup.n_unique_SF_symops*.dim,"k3: wrong dim")

      B,rcm,symop :: MAT{REAL}(3,3)
      h1,h2,h3, n,p,u :: INT

      ! Reciprocal cell matrix
      rcm = TWO*PI*unit_cell.reciprocal_matrix

      ! Make the
      do u = 1,spacegroup.n_unique_SF_symops

         symop = spacegroup.unique_SF_symop_mat(u)

         B.to_product_of(rcm,symop,transpose_b=TRUE)

         p = (u-1)*.dim

         do n = 1,.dim

            p = p + 1

            h1 = self(n).h
            h2 = self(n).k
            h3 = self(n).l

            k1(p) = B(1,1)*h1 + B(1,2)*h2 + B(1,3)*h3
            k2(p) = B(2,1)*h1 + B(2,2)*h2 + B(2,3)*h3
            k3(p) = B(3,1)*h1 + B(3,2)*h2 + B(3,3)*h3

         end

      end

   end

   make_symop_generated_SF_k_pts(k,spacegroup,unit_cell) ::: PURE
   ! Make the full set of symmetry generated reciprocal lattice
   ! vectors "k" required for structure factor calculations.
      self :: IN
      k :: MAT{REAL}, OUT
      spacegroup :: SPACEGROUP, IN
      unit_cell :: UNIT_CELL, IN

   ENSURE(k.dim1==spacegroup.n_seitz*.dim,"k: wrong dim1")
   ENSURE(k.dim2==3,"k: wrong dim2")

      B,rcm,symop :: MAT{REAL}(3,3)
      h1,h2,h3, n,p,s :: INT

      ! Reciprocal cell matrix
      rcm = TWO*PI*unit_cell.reciprocal_matrix

      ! Make the symmetry-generated k points
      do s = 1,spacegroup.n_seitz

         symop = spacegroup.seitz(1:3,1:3,s)

         B.to_product_of(rcm,symop,transpose_b=TRUE)

         p = (s-1)*.dim

         do n = 1,.dim

            p = p + 1

            h1 = self(n).h
            h2 = self(n).k
            h3 = self(n).l

            k(p,1) = B(1,1)*h1 + B(1,2)*h2 + B(1,3)*h3
            k(p,2) = B(2,1)*h1 + B(2,2)*h2 + B(2,3)*h3
            k(p,3) = B(3,1)*h1 + B(3,2)*h2 + B(3,3)*h3

         end

      end

   end

!  =========
!  Set hkl's
!  =========

   set_hkl_up_to_stl_limit(limit,cell) ::: leaky, PURE
   ! Set (h k l) reflections as a half-sphere up to an STL "limit".
   ! NOTE: See Dunitz "Crystal Analysis" (1995) p. 35
      self :: PTR
      limit :: REAL, IN
      cell :: UNIT_CELL, IN

      h :: VEC{INT}(3)
      hv :: VEC{REAL}(3)
      d,stl :: REAL
      new :: VEC{REFLECTION}*
      ref :: REFLECTION
      h1,h2,h3, h_max,h1_max,h2_max,h3_max :: INT

      ! Get h_max
      h1_max = ceiling(cell.length(1)*2.5*limit)
      h2_max = ceiling(cell.length(2)*2.5*limit)
      h3_max = ceiling(cell.length(3)*2.5*limit)
      h_max  = max(h1_max,h2_max,h3_max)


      ! Add the list of reflections
      new.create(0)
      ref.set_defaults

      do h1 = -h_max,h_max
      do h2 = -h_max,h_max
      do h3 = 0     ,h_max

         if (h1==0 AND h2==0 AND h3==0) cycle

         h = [h1,h2,h3]

         hv  = matmul(cell.reciprocal_matrix,h)
         d   = ONE/hv.norm ! with HBB 6/2/16
         stl = HALF/d
         
         if (stl>limit) cycle

         ! Append
         ref.set_hkl(h)
         new.append(ref)

      end
      end
      end

      ! Reassign
      self.destroy
      self => new

   end

   set_hkl_range(hkl_range) ::: leaky, PURE
   ! Set a h,k,l range ... useful for structure factor calculations
   ! without having to set every reflection individually.
      self :: PTR
      hkl_range :: VEC{EVEC{INT}}, IN

   ENSURE(hkl_range.dim==3,"hkl range must have three ranges")
   ENSURE(hkl_range(1).element.dim==2,"hkl range 1 must have two limits")
   ENSURE(hkl_range(2).element.dim==2,"hkl range 2 must have two limits")
   ENSURE(hkl_range(3).element.dim==2,"hkl range 3 must have two limits")

      f1,f2,f3, l1,l2,l3, h,k,l, dim, i :: INT

      ! Get limits
      f1 = hkl_range(1).element(1)
      f2 = hkl_range(2).element(1)
      f3 = hkl_range(3).element(1)
      l1 = hkl_range(1).element(2)
      l2 = hkl_range(2).element(2)
      l3 = hkl_range(3).element(2)

      dim = (l1-f1+1) * (l2-f2+1) * (l3-f3+1)

      ! Remove (0 0 0)
    ! if (f1<=0 AND l1>=0) then
    ! if (f2<=0 AND l2>=0) then
    ! if (f3<=0 AND l3>=0) then
    !    dim = dim - 1
    ! end
    ! end
    ! end

      ! Create the array
      .destroy
      .create(dim)

      ! Report
      i = 0
      do h = f1,l1
      do k = f2,l2
      do l = f3,l3

       ! if (h==0 AND k==0 AND l==0) cycle

         i = i + 1
         self(i).h = h
         self(i).k = k
         self(i).l = l

      end
      end
      end

   end

!  =======================
!  List-based I/O Routines
!  =======================

   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process list-based keywords from "stdin". List-based keywords
   ! are those that are intended to apply to each individual element of the list
   ! through a list of "keys" stored in the associated list-element type module.
   ! NOTE: this routine will create the list, if required.
   end

   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky
   ! Process a list-type "keyword", common to all list-type objects.
   end

   read_data ::: get_from(VEC{OBJECT}), leaky
   ! Repeatedly process the "keys" to read in the data list.
   ! Opening and closing braces are needed.
   end

   read_data_sans_braces ::: get_from(VEC{OBJECT}), leaky
   ! Repeatedly process the "keys" to read in the data list.
   ! Opening and closing braces are not needed.
   end

   data_length result (length) ::: get_from(VEC{OBJECT})
   ! Read ahead in stdin to get the "length" of the data list, i.e. the number
   ! of data items in the list. The data must begin with the first data item,
   ! *not* a "{" symbol.  The order of data items comprising the list is given
   ! by keys defined in the associated list-element type module. The data list
   ! must be terminated by a "}" symbol.
   end

   read_altered_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a sublist of the complete list, and alter the data for that
   ! sublist.  The order of the data items in the sublist is given by the "keys"
   ! defined in the associated list-element type module.
   end

   read_append_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a set of data to append to an existing set.
   end

   process_keys ::: get_from(VEC{OBJECT}), leaky
   ! Process the "keys" on each element of the list.
   end

   process_keys_once ::: get_from(VEC{OBJECT})
   ! Process the "keys" just once on an anonymous object. This is useful if the
   ! "keys" set global variables in the list module (e.g. the default order of
   ! lists *within* the list data) as opposed to being keys pertaining to each
   ! element of the list.
   end

   keys_created result (res) ::: get_from(VEC{OBJECT})
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(VEC{OBJECT})
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(VEC{OBJECT}), leaky
   ! This is for destroying the "keys" externally.
   end

   read_keys ::: get_from(VEC{OBJECT}), leaky
   ! Read a new set of keys
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

!  ===========================
!  Non-list based I/O routines
!  ===========================

   read_keywords ::: get_from(VEC{OBJECT}), leaky
   ! Read in and process normal (non list-type) keywords from "stdin".
   end

   process_keyword(keyword) ::: leaky
   ! Process a normal (non list-type) "keyword".
      self :: PTR
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case("}") ! do nothing.
      case("put                      "); .put
      case("put_f_exp_data           "); .put_F_exp_data
      case("put_f_pred_data          "); .put_F_pred_data
      case("put_f_statistics         "); .put_F_statistics
      case("put_i_exp_data           "); .put_I_exp_data
      case("put_i_statistics         "); .put_I_statistics
      case("put_intensity_data       "); .put_intensity_data
      case("put_structure_factor_data"); .put_structure_factor_data
      case("redirect                 "); .redirect
      case("revert                   "); .revert
      case default;     UNKNOWN(word)
      end

   end

!  ========
!  Read CIF
!  ========

   read_CIF(cif) ::: leaky
   ! Read reflections from a "cif" file.
      self :: PTR
      cif :: CIF, INOUT

      if (NOT cif.is_mmCIF) then
         .read_smCIF(cif)
      else
         .read_mmCIF(cif)
      end

   end

! smCIF

   read_smCIF(cif) ::: leaky
   ! Read reflections from a small-molecule "cif" file.
      self :: PTR
      cif :: CIF, INOUT

           if (::has_smCIF_F_meas_F_calc(cif))  then; .read_smCIF_F_meas_F_calc(cif)
      else if (::has_smCIF_F_meas_only(cif))    then; .read_smCIF_F_meas_only(cif)
      else if (::has_smCIF_F2_reflections(cif)) then; .read_smCIF_F2_reflections(cif)
      end

   end

   has_smCIF_F_meas_F_calc(cif) result (res) ::: selfless
   ! Does small-molecule "cif" have F_meas, F_sigma and F_calc
   ! reflections?
      cif :: CIF, INOUT
      res :: BIN

      there :: VEC{BIN}(6)

      ! Find reflections
      cif.find_looped_item("_refln_index_h",there(1))
      cif.find_looped_item("_refln_index_k",there(2))
      cif.find_looped_item("_refln_index_l",there(3))
      cif.find_looped_item("_refln_F_calc" ,there(4))
      cif.find_looped_item("_refln_F_meas" ,there(5))
      cif.find_looped_item("_refln_F_sigma",there(6))

      res = all(there)

   end

   read_smCIF_F_meas_F_calc(cif) ::: leaky
   ! Read F reflections from small-molecule "cif".
      self :: PTR
      cif :: CIF, INOUT

      h,k,l :: VEC{INT}*
      Fp,Fm,Sg :: VEC{REAL}*

      ! Read
      cif.read_looped_item("_refln_index_h",h)
      cif.read_looped_item("_refln_index_k",k)
      cif.read_looped_item("_refln_index_l",l)
      cif.read_looped_item("_refln_F_calc" ,Fp)
      cif.read_looped_item("_refln_F_meas" ,Fm)
      cif.read_looped_item("_refln_F_sigma",Sg)

      ! Create and assign
      .destroy
      .create(h.dim)
      .set_h(h)
      .set_k(k)
      .set_l(l)
      .set_F_pred(Fp)
      .set_F_exp(Fm)
      .set_F_sigma(Sg)

      ! Clean
      Sg.destroy
      Fm.destroy
      Fp.destroy
      l.destroy
      k.destroy
      h.destroy

   end

   has_smCIF_F_meas_only(cif) result (res) ::: selfless
   ! Does small-molecule "cif" have F_meas & F_sigma reflections?
      cif :: CIF, INOUT
      res :: BIN

      there :: VEC{BIN}(5)

      ! Find reflections
      cif.find_looped_item("_refln_index_h",there(1))
      cif.find_looped_item("_refln_index_k",there(2))
      cif.find_looped_item("_refln_index_l",there(3))
      cif.find_looped_item("_refln_F_meas" ,there(4))
      cif.find_looped_item("_refln_F_sigma",there(5))

      res = all(there)

   end

   read_smCIF_F_meas_only(cif) ::: leaky
   ! Read F_meas and F_sigma from small-molecule "cif".
      self :: PTR
      cif :: CIF, INOUT

      h,k,l :: VEC{INT}*
      Fm,Sg :: VEC{REAL}*

      ! Read
      cif.read_looped_item("_refln_index_h",h)
      cif.read_looped_item("_refln_index_k",k)
      cif.read_looped_item("_refln_index_l",l)
      cif.read_looped_item("_refln_F_meas" ,Fm)
      cif.read_looped_item("_refln_F_sigma",Sg)

      ! Create and assign
      .destroy
      .create(h.dim)
      .set_h(h)
      .set_k(k)
      .set_l(l)
      .set_F_exp(Fm)
      .set_F_sigma(Sg)

      ! Clean
      Sg.destroy
      Fm.destroy
      l.destroy
      k.destroy
      h.destroy

   end

   has_smCIF_F2_reflections(cif) result (res) ::: selfless
   ! Does small-molecule "cif" have F2 reflections?
      cif :: CIF, INOUT
      res :: BIN

      there :: VEC{BIN}(5)

      ! Find reflections
      cif.find_looped_item("_refln_index_h",there(1))
      cif.find_looped_item("_refln_index_k",there(2))
      cif.find_looped_item("_refln_index_l",there(3))
      cif.find_looped_item("_refln_F_squared_meas" ,there(4))
      cif.find_looped_item("_refln_F_squared_sigma",there(5))

      res = all(there)

   end

   read_smCIF_F2_reflections(cif) ::: leaky
   ! Read F2 reflections from small-molecule "cif".
      self :: PTR
      cif :: CIF, INOUT

      h,k,l :: VEC{INT}*
      Fm,Sg :: VEC{REAL}*

      ! Read
      cif.read_looped_item("_refln_index_h",h)
      cif.read_looped_item("_refln_index_k",k)
      cif.read_looped_item("_refln_index_l",l)
      cif.read_looped_item("_refln_F_squared_meas" ,Fm)
      cif.read_looped_item("_refln_F_squared_sigma",Sg)

      ! Create and assign
      .destroy
      .create(h.dim)
      .set_h(h)
      .set_k(k)
      .set_l(l)
      .set_I_exp(Fm)
      .set_I_sigma(Sg)

      ! Clean
      Sg.destroy
      Fm.destroy
      l.destroy
      k.destroy
      h.destroy

   end

! mmCIF

   read_mmCIF(cif) ::: leaky
   ! Read reflections from a macromolecular "cif" file.
      self :: PTR
      cif :: CIF, INOUT

           if (::has_mmCIF_F_meas_F_calc(cif))  then; .read_mmCIF_F_meas_F_calc(cif)
      else if (::has_mmCIF_F_meas_only(cif))    then; .read_mmCIF_F_meas_only(cif)
      else if (::has_mmCIF_F2_reflections(cif)) then; .read_mmCIF_F2_reflections(cif)
      end

   end

   has_mmCIF_F_meas_F_calc(cif) result (res) ::: selfless
   ! Does macromolecular "cif" have F_meas, F_sigma and F_calc
   ! reflections?
      cif :: CIF, INOUT
      res :: BIN

      there :: VEC{BIN}(6)

      ! Find reflections
      cif.find_looped_item("_refln.index_h",there(1))
      cif.find_looped_item("_refln.index_k",there(2))
      cif.find_looped_item("_refln.index_l",there(3))
      cif.find_looped_item("_refln.F_calc" ,there(4))
      cif.find_looped_item("_refln.F_meas" ,there(5))
      cif.find_looped_item("_refln.F_sigma",there(6))

      res = all(there)

   end

   read_mmCIF_F_meas_F_calc(cif) ::: leaky
   ! Read F reflections from macromolecular "cif".
      self :: PTR
      cif :: CIF, INOUT

      h,k,l :: VEC{INT}*
      Fp,Fm,Sg :: VEC{REAL}*

      ! Read
      cif.read_looped_item("_refln.index_h",h)
      cif.read_looped_item("_refln.index_k",k)
      cif.read_looped_item("_refln.index_l",l)
      cif.read_looped_item("_refln.F_calc" ,Fp)
      cif.read_looped_item("_refln.F_meas" ,Fm)
      cif.read_looped_item("_refln.F_sigma",Sg)

      ! Create and assign
      .destroy
      .create(h.dim)
      .set_h(h)
      .set_k(k)
      .set_l(l)
      .set_F_pred(Fp)
      .set_F_exp(Fm)
      .set_F_sigma(Sg)

      ! Clean
      Sg.destroy
      Fm.destroy
      Fp.destroy
      l.destroy
      k.destroy
      h.destroy

   end

   has_mmCIF_F_meas_only(cif) result (res) ::: selfless
   ! Does macromolecular "cif" have F_meas & F_sigma reflections?
      cif :: CIF, INOUT
      res :: BIN

      there :: VEC{BIN}(5)

      ! Find reflections
      cif.find_looped_item("_refln.index_h",there(1))
      cif.find_looped_item("_refln.index_k",there(2))
      cif.find_looped_item("_refln.index_l",there(3))
      cif.find_looped_item("_refln.F_meas" ,there(4))
      cif.find_looped_item("_refln.F_sigma",there(5))

      res = all(there)

   end

   read_mmCIF_F_meas_only(cif) ::: leaky
   ! Read F_meas and F_sigma from macromolecular "cif".
      self :: PTR
      cif :: CIF, INOUT

      h,k,l :: VEC{INT}*
      Fm,Sg :: VEC{REAL}*

      ! Read
      cif.read_looped_item("_refln.index_h",h)
      cif.read_looped_item("_refln.index_k",k)
      cif.read_looped_item("_refln.index_l",l)
      cif.read_looped_item("_refln.F_meas" ,Fm)
      cif.read_looped_item("_refln.F_sigma",Sg)

      ! Create and assign
      .destroy
      .create(h.dim)
      .set_h(h)
      .set_k(k)
      .set_l(l)
      .set_F_exp(Fm)
      .set_F_sigma(Sg)

      ! Clean
      Sg.destroy
      Fm.destroy
      l.destroy
      k.destroy
      h.destroy

   end

   has_mmCIF_F2_reflections(cif) result (res) ::: selfless
   ! Does macromolecular "cif" have F2 reflections?
      cif :: CIF, INOUT
      res :: BIN

      there :: VEC{BIN}(6)

      ! Find reflections
      cif.find_looped_item("_refln.index_h",there(1))
      cif.find_looped_item("_refln.index_k",there(2))
      cif.find_looped_item("_refln.index_l",there(3))
      cif.find_looped_item("_refln.F_squared_meas" ,there(5))
      cif.find_looped_item("_refln.F_squared_sigma",there(6))

      res = all(there)

   end

   read_mmCIF_F2_reflections(cif) ::: leaky
   ! Read F2 reflections from macromolecular "cif".
      self :: PTR
      cif :: CIF, INOUT

      h,k,l :: VEC{INT}*
      Fm,Sg :: VEC{REAL}*

      ! Read
      cif.read_looped_item("_refln.index_h",h)
      cif.read_looped_item("_refln.index_k",k)
      cif.read_looped_item("_refln.index_l",l)
      cif.read_looped_item("_refln.F_squared_meas" ,Fm)
      cif.read_looped_item("_refln.F_squared_sigma",Sg)

      ! Create and assign
      .destroy
      .create(h.dim)
      .set_h(h)
      .set_k(k)
      .set_l(l)
      .set_I_exp(Fm)
      .set_I_sigma(Sg)

      ! Clean
      Sg.destroy
      Fm.destroy
      l.destroy
      k.destroy
      h.destroy

   end

!  ==================
!  Read shelx/std hkl
!  ==================

   read_shelx_hkl_file(file) ::: template
   ! Read Sheldrick's hkl F/F2 reflections from "file".
      self :: PTR
      file :: TEXTFILE, INOUT

      i,n_refl, h,k,l,n :: INT
      value,sigma :: REAL

      n_refl = ::no_of_shelx_hkl_reflections(file)

      ! Create reflections
      .destroy
      .create(n_refl)

      ! Read them
      n = 0
      do i = 1,file.no_of_lines

         file.move_to_line(i)

         if (NOT file.buffer_exhausted) then

            ! Fixed format
            h = file.buffer.string( 1: 4).to_int
            k = file.buffer.string( 5: 8).to_int
            l = file.buffer.string( 9:12).to_int
           
            if (h==0 AND k==0 AND l==0) cycle

            ! Fixed format
            value = file.buffer.string(13:20).to_real
            sigma = file.buffer.string(21:28).to_real
           
            n = n + 1
            self(n).set_hkl( [h,k,l] )
            self(n).SET_EXP?(value)
            self(n).SET_SIG?(sigma)

         end

      end

   end

   read_shelx_F_hkl_file(file) ::: get_from(read_shelx_hkl_file, SET_EXP?=>set_F_exp, SET_SIG?=>set_F_sigma), leaky
   ! Read Sheldrick's hkl F/F2 reflections from "file".
   end

   read_shelx_F2_hkl_file(file) ::: get_from(read_shelx_hkl_file, SET_EXP?=>set_I_exp, SET_SIG?=>set_I_sigma), leaky
   ! Read Sheldrick's hkl F/F2 reflections from "file".
   end

   no_of_shelx_hkl_reflections(file) result (res) ::: selfless, private
   ! Return the no. of (h k l) reflections in SHELX "file".
   ! - Blank lines are ignored
   ! - (0 0 0) reflection ignored too ...
      file :: TEXTFILE, INOUT
      res :: INT

      i, h,k,l :: INT

      res = 0

      do i = 1,file.no_of_lines

         file.move_to_line(i)

         if (NOT file.buffer_exhausted) then

            ! Fixed format
            h = file.buffer.string( 1: 4).to_int
            k = file.buffer.string( 5: 8).to_int
            l = file.buffer.string( 9:12).to_int
           
            if (h==0 AND k==0 AND l==0) cycle
           
            res = res + 1

         end

      end

   end

   read_std_hkl_file(file) ::: template
   ! Read normal free-form hkl F/F2 reflections from "file".
      self :: PTR
      file :: TEXTFILE, INOUT

      i,n_refl, h,k,l,n :: INT
      value,sigma :: REAL

      n_refl = ::no_of_hkl_reflections(file)

      ! Create reflections
      .destroy
      .create(n_refl)

      ! Read them
      n = 0
      do i = 1,file.no_of_lines

         file.move_to_line(i)

         if (NOT file.buffer_exhausted) then

            file.read(h)
            file.read(k)
            file.read(l)
           
            if (h==0 AND k==0 AND l==0) cycle
           
            file.read(value)
            file.read(sigma)
           
            n = n + 1
            self(n).set_hkl( [h,k,l] )
            self(n).SET_EXP?(value)
            self(n).SET_SIG?(sigma)

         end

      end

   end

   read_std_F_hkl_file(file) ::: get_from(read_std_hkl_file, SET_EXP?=>set_F_exp, SET_SIG?=>set_F_sigma), leaky
   ! Read normal free-form hkl F/F2 reflections from "file".
   end

   read_std_F2_hkl_file(file) ::: get_from(read_std_hkl_file, SET_EXP?=>set_I_exp, SET_SIG?=>set_I_sigma), leaky
   ! Read normal free-form hkl F/F2 reflections from "file".
   end

   no_of_hkl_reflections(file) result (res) ::: selfless, private
   ! Return the no. of (h k l) reflections in "file".
   ! - Blank lines are ignored
   ! - (0 0 0) reflection ignored too ...
      file :: TEXTFILE, INOUT
      res :: INT

      i, h,k,l :: INT

      res = 0

      do i = 1,file.no_of_lines

         file.move_to_line(i)

         if (NOT file.buffer_exhausted) then

            ! Fixed format
            file.read(h)
            file.read(k)
            file.read(l)
           
            if (h==0 AND k==0 AND l==0) cycle
           
            res = res + 1

         end

      end

   end

!  ===============
!  Output routines
!  ===============

   put
   ! Output the reflection data.
      self :: IN

      stdout.flush
      stdout.show("Number of reflections =",.dim)

      ! Structure factors
      stdout.flush
      stdout.text("Structure factors:")

      if (.have_F_pred) then

         if (.have_F_exp) then; .put_structure_factor_data
         else;                  .put_F_pred_data
         end

      else

         if      (.have_F_exp)  then; .put_F_exp_data
         else if (.have_F_calc) then; .put_F_calc_data
         else; stdout.text("There are no structure factors yet")
         end

      end

   end

   put_intensities
   ! Output the reflection data.
      self :: IN

      stdout.flush
      stdout.show("Number of reflections =",.dim)

      ! Structure factors
      stdout.flush
      stdout.text("Structure factors:")

      stdout.flush
      stdout.text("Intensities:")
      if (.have_I_pred) then
         if (.have_I_exp) then; .put_intensity_data
         else;                  .put_I_pred_data
         end
      else
         if (.have_I_exp) then; .put_I_exp_data
         else; stdout.text("There are no intensities yet")
         end
      end

   end

   put_intensities_XD
   ! Output only the experimental intensity data in XD format
      self :: IN

   ENSURE(.have_I_exp,"no experimental intensities")

      table :: VEC{TABLE_COLUMN}@
      group :: VEC{INT}@

      ! Precision
      stdout.save
      stdout.set_int_width(4)
      stdout.set_real_precision(3)

      ! Get data
      group.create(.dim)
      group   = 1

      ! Make table
      table.create(6)

      table(1).set_values(self(:).h)
      table(2).set_values(self(:).k)
      table(3).set_values(self(:).l)
      table(4).set_values(group)
      table(5).set_values(self(:).I_exp)
      table(6).set_values(self(:).I_sigma)

      table(1).set_heading("h")
      table(1).force_width(4)
      table(2).set_heading("k")
      table(2).force_width(4)
      table(3).set_heading("l")
      table(3).force_width(4)
      table(4).set_heading("g")
      table(4).force_width(3)
      table(5).set_heading("I")
      table(5).force_width(13)
      table(6).set_heading("sigma")
      table(6).force_width(13)

      ! Put
      table.put_body

      ! Clean
      table.destroy
      group.destroy

      ! Restore
      stdout.unsave

   end


   put_Miller_indices(Fc)
   ! Output the Miller indices for the complex structure factors "Fc".
      self :: IN
      Fc :: VEC{CPX}, IN

   ENSURE(Fc.dim==.dim,"Fc does not have the right dimension")

      table :: VEC{TABLE_COLUMN}@
      Fr,Fi :: VEC{REAL}@

      ! Get data
      Fr.create(.dim); Fr = RE(Fc)
      Fi.create(.dim); Fi = IM(Fc)

      ! Make table
      table.create(5)
      table( 1).set_heading("h"); table(1).set_values(self(:).h)
      table( 2).set_heading("k"); table(2).set_values(self(:).k)
      table( 3).set_heading("l"); table(3).set_values(self(:).l)
      table( 4).set_heading("F"); table(4).set_values(Fr)
      table( 5).set_heading("F"); table(5).set_values(Fi)

      ! Subheadings
      table(4).set_subhead("Re")
      table(5).set_subhead("Im")

      table.put

      ! Clean
      table.destroy
      Fi.destroy
      Fr.destroy

   end


   put_structure_factor_data
   ! Output the structure factor data
      self :: IN

      .put_F_statistics

      if (.use_multiple_scale_factors) then; .put_SF_group_data
      else;                                  .put_SF_nogrp_data
      end

   end

   put_F_statistics(show_chi2)
   ! Output the structure factor statistics
      self :: IN
      show_chi2 :: BIN, optional, IN

   ENSURE(.have_F_exp, "No F_exp data!")
   ENSURE(.have_F_pred,"No F_pred data!")

      chi2 :: REAL
      show :: BIN

      stdout.flush

      stdout.text("Model statistics based on structure factors:")
      stdout.flush

      stdout.show("R_sigma(F)                     =", .F_r_sigma)
      stdout.show("R_sigma(F2)                    =", .F2_r_sigma)
      stdout.show("R(F)                           =", .F_r_factor)
      stdout.show("R(F2)                          =", .F2_r_factor)
      stdout.show("Rw(F)                          =", .F_weighted_r_factor)
      stdout.show("Rw(F2)                         =", .F2_weighted_r_factor)

      show = TRUE
      if (present(show_chi2)) show = show_chi2

      if (show) then
      chi2 = .F_chi2
      stdout.show("chi^2(N_p=1)(F)                =", chi2)
      stdout.show("Goodness of fit(N_p=1)(F)      =", sqrt(chi2))
      end

   end

   put_F_free_stats(show_chi2)
   ! Output the structure factor statistics
      self :: IN
      show_chi2 :: BIN, optional, IN

   ENSURE(.have_F_exp, "No F_exp data!")
   ENSURE(.have_F_pred,"No F_pred data!")

      chi2 :: REAL
      show :: BIN

      stdout.flush

      stdout.text("Statistics based on free structure factors:")
      stdout.flush

      stdout.show("Free R_sigma(F)              =", .F_r_sigma)
      stdout.show("Free R(F)                    =", .F_r_factor)
      stdout.show("Free Rw(F)                   =", .F_weighted_r_factor)

      show = TRUE
      if (present(show_chi2)) show = show_chi2

      if (show) then
      chi2 = .F_chi2
      stdout.show("Free chi^2(N_p=1)(F)         =", chi2)
      stdout.show("Free GOF(N_p=1)(F)           =", sqrt(chi2))
      end

   end

   put_SF_group_data ::: private
   ! Output the structure factor data, with multiple scale factor
   ! groups
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      F_cr,F_ci,F_z,stl,d :: VEC{REAL}@

      ! Get data
      stl.create(.dim);     stl     = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim)  ;     d       = self(:).d  *ANGSTROM_PER_BOHR
      F_cr.create(.dim);    F_cr    = RE(.F_calc)
      F_ci.create(.dim);    F_ci    = IM(.F_calc)
      F_z.create(.dim);     F_z     = REFLECTION:F_z(self)

      ! Make table
      table.create(12)
       table(1).set_heading("h");        table(1).set_values(self(:).h)
       table(2).set_heading("k");        table(2).set_values(self(:).k)
       table(3).set_heading("l");        table(3).set_values(self(:).l)
       table(4).set_heading("Scale");    table(4).set_values(self(:).group)
       table(5).set_heading("stl");      table(5).set_values(stl)
       table(6).set_heading("d");        table(6).set_values(d)
       table(7).set_heading("F_calc");   table(7).set_values(F_cr)
       table(8).set_heading("F_calc");   table(8).set_values(F_ci)
       table(9).set_heading("F_pred");   table(9).set_values(self(:).F_pred)
      table(10).set_heading("F_exp");   table(10).set_values(self(:).F_exp)
      table(11).set_heading("F_sigma"); table(11).set_values(self(:).F_sigma)
      table(12).set_heading("F_z");     table(12).set_values(F_z)

      ! Subheadings
      table(4).set_subhead("group")
      table(5).set_subhead("/A^-1")
      table(6).set_subhead("/A")
      table(7).set_subhead("Re")
      table(8).set_subhead("Im")

      table.put

      ! Clean
      table.destroy
      F_z.destroy
      F_ci.destroy
      F_cr.destroy
      d.destroy
      stl.destroy

   end

   put_SF_nogrp_data ::: private
   ! Output the structure factor data, single scale factor group
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      F_cr,F_ci,F_z,stl,d :: VEC{REAL}@

      ! Get data
      stl.create(.dim);     stl     = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim);       d       = self(:).d  *ANGSTROM_PER_BOHR
      F_cr.create(.dim);    F_cr    = RE(.F_calc)
      F_ci.create(.dim);    F_ci    = IM(.F_calc)
      F_z.create(.dim);     F_z     = REFLECTION:F_z(self)

      ! Make table
      table.create(11)
      table( 1).set_heading("h");         table(1).set_values(self(:).h)
      table( 2).set_heading("k");         table(2).set_values(self(:).k)
      table( 3).set_heading("l");         table(3).set_values(self(:).l)
      table( 4).set_heading("stl");       table(4).set_values(stl)
      table( 5).set_heading("d");         table(5).set_values(d)
      table( 6).set_heading("F_calc");    table(6).set_values(F_cr)
      table( 7).set_heading("F_calc");    table(7).set_values(F_ci)
      table( 8).set_heading("F_pred");    table(8).set_values(self(:).F_pred)
      table( 9).set_heading("F_exp");     table(9).set_values(self(:).F_exp)
      table(10).set_heading("F_sigma");  table(10).set_values(self(:).F_sigma)
      table(11).set_heading("F_z");      table(11).set_values(F_z)

      ! Subheadings
      table(4).set_subhead("/A^-1")
      table(5).set_subhead("/A")
      table(6).set_subhead("Re")
      table(7).set_subhead("Im")

      table.put

      ! Clean
      table.destroy
      F_z.destroy
      F_ci.destroy
      F_cr.destroy
      d.destroy
      stl.destroy

   end

   put_F_calc_data
   ! Output only the calculated structure factor data.
   ! Predicted structure factors are the magnitude of F_calc.
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      F_cr,F_ci,F_dr,F_di,F_pred,stl,d :: VEC{REAL}@

      ! Get data
      stl.create(.dim);    stl    = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim)  ;    d      = self(:).d  *ANGSTROM_PER_BOHR
      F_cr.create(.dim);   F_cr   = RE(.F_calc)
      F_ci.create(.dim);   F_ci   = IM(.F_calc)
      F_dr.create(.dim);   F_dr   = RE(.F_disp)
      F_di.create(.dim);   F_di   = IM(.F_disp)
      F_pred.create(.dim); F_pred = abs(.F_calc)

      ! Make table
      table.create(10)
      table( 1).set_heading("h");      table( 1).set_values(self(:).h)
      table( 2).set_heading("k");      table( 2).set_values(self(:).k)
      table( 3).set_heading("l");      table( 3).set_values(self(:).l)
      table( 4).set_heading("stl");    table( 4).set_values(stl)
      table( 5).set_heading("d");      table( 5).set_values(d)
      table( 6).set_heading("F_calc"); table( 6).set_values(F_cr)
      table( 7).set_heading("F_calc"); table( 7).set_values(F_ci)
      table( 8).set_heading("F_disp"); table( 8).set_values(F_dr)
      table( 9).set_heading("F_disp"); table( 9).set_values(F_di)
      table(10).set_heading("F_pred"); table(10).set_values(F_pred)

      ! Subheadings
      table(4).set_subhead("/A^-1")
      table(5).set_subhead("/A")
      table(6).set_subhead("Re")
      table(7).set_subhead("Im")
      table(8).set_subhead("Re")
      table(9).set_subhead("Im")

      table.put

      ! Clean
      table.destroy
      F_pred.destroy
      F_di.destroy
      F_dr.destroy
      F_ci.destroy
      F_cr.destroy
      d.destroy
      stl.destroy

   end

   put_F_pred_data
   ! Output only the predicted structure factor data
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      F_cr,F_ci,stl,d :: VEC{REAL}@

      ! Get data
      stl.create(.dim);    stl    = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim)  ;    d      = self(:).d  *ANGSTROM_PER_BOHR
      F_cr.create(.dim);   F_cr   = RE(.F_calc)
      F_ci.create(.dim);   F_ci   = IM(.F_calc)

      ! Make table
      table.create(8)
      table(1).set_heading("h");      table(1).set_values(self(:).h)
      table(2).set_heading("k");      table(2).set_values(self(:).k)
      table(3).set_heading("l");      table(3).set_values(self(:).l)
      table(4).set_heading("stl");    table(4).set_values(stl)
      table(5).set_heading("d");      table(5).set_values(d)
      table(6).set_heading("F_calc"); table(6).set_values(F_cr)
      table(7).set_heading("F_calc"); table(7).set_values(F_ci)
      table(8).set_heading("F_pred"); table(8).set_values(self(:).F_pred)

      ! Subheadings
      table(4).set_subhead("/A^-1")
      table(5).set_subhead("/A")
      table(6).set_subhead("Re")
      table(7).set_subhead("Im")

      table.put

      ! Clean
      table.destroy
      F_ci.destroy
      F_cr.destroy
      d.destroy
      stl.destroy

   end

   put_F_exp_data
   ! Output only the experimental structure factor data
      self :: IN

      if (.use_multiple_scale_factors) then; .put_F_exp_group_data
      else;                                  .put_F_exp_nogrp_data
      end

   end

   put_F_exp_nogrp_data ::: private
   ! Output only the experimental structure factor data, where only
   ! one scale factor (scale group) is used.
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      stl,d :: VEC{REAL}@

      ! Get data
      stl.create(.dim); stl = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim);   d   = self(:).d  *ANGSTROM_PER_BOHR

      ! Make table
      table.create(7)
      table(1).set_heading("h");       table(1).set_values(self(:).h)
      table(2).set_heading("k");       table(2).set_values(self(:).k)
      table(3).set_heading("l");       table(3).set_values(self(:).l)
      table(4).set_heading("stl");     table(4).set_values(stl)
      table(5).set_heading("d");       table(5).set_values(d)
      table(6).set_heading("F_exp");   table(6).set_values(self(:).F_exp)
      table(7).set_heading("F_sigma"); table(7).set_values(self(:).F_sigma)

      ! Subheadings
      table(4).set_subhead("/A^-1")
      table(5).set_subhead("/A")

      ! Body
      table.put

      ! Clean
      table.destroy
      d.destroy
      stl.destroy

   end

   put_F_exp_group_data ::: private
   ! Output only the experimental structure factor data where multiple
   ! scale factors (scale groups) are used.
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      g :: VEC{INT}@
      stl,d :: VEC{REAL}*

      ! Get data
      g.create(.dim);       g       = .group
      stl.create(.dim);     stl     = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim)  ;     d       = self(:).d  *ANGSTROM_PER_BOHR

      ! Make table
      table.create(8)
      table(1).set_heading("h");       table(1).set_values(self(:).h)
      table(2).set_heading("k");       table(2).set_values(self(:).k)
      table(3).set_heading("l");       table(3).set_values(self(:).l)
      table(4).set_heading("Scale");   table(4).set_values(g)
      table(5).set_heading("stl");     table(5).set_values(stl)
      table(6).set_heading("d");       table(6).set_values(d)
      table(7).set_heading("F_exp");   table(7).set_values(self(:).F_exp)
      table(8).set_heading("F_sigma"); table(8).set_values(self(:).F_sigma)

      ! Subheadings
      table(4).set_subhead("group")
      table(5).set_subhead("/A^-1")
      table(6).set_subhead("/A")

      table.put

      ! Clean
      table.destroy
      d.destroy
      stl.destroy
      g.destroy

   end

   put_F_all_data
   ! Output all the structure factor date.
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      F_cr,F_ci,F_ph,F_dr,F_di,stl,d :: VEC{REAL}@

      ! Get data
      stl.create(.dim);     stl     = self(:).stl*BOHR_PER_ANGSTROM
      d.create(.dim)  ;     d       = self(:).d  *ANGSTROM_PER_BOHR
      F_cr.create(.dim);    F_cr    = RE(.F_calc)
      F_ci.create(.dim);    F_ci    = IM(.F_calc)
      F_ph.create(.dim);    F_ph    = REFLECTION:F_phase_angle_in_degrees(self)
      F_dr.create(.dim);    F_dr    = RE(.F_disp)
      F_di.create(.dim);    F_di    = IM(.F_disp)

      ! Make table
      table.create(14)
      table( 1).set_heading("h");       table( 1).set_values(self(:).h)
      table( 2).set_heading("k");       table( 2).set_values(self(:).k)
      table( 3).set_heading("l");       table( 3).set_values(self(:).l)
      table( 4).set_heading("stl");     table( 4).set_values(stl)
      table( 5).set_heading("d");       table( 5).set_values(d)
      table( 6).set_heading("F_calc");  table( 6).set_values(F_cr)
      table( 7).set_heading("F_calc");  table( 7).set_values(F_ci)
      table( 8).set_heading("Phase");   table( 8).set_values(F_ph)
      table( 9).set_heading("F_disp");  table( 9).set_values(F_dr)
      table(10).set_heading("F_disp");  table(10).set_values(F_di)
      table(11).set_heading("F_pred");  table(11).set_values(self(:).F_pred)
      table(12).set_heading("F_corr");  table(12).set_values(self(:).F_corr)
      table(13).set_heading("F_exp");   table(13).set_values(self(:).F_exp)
      table(14).set_heading("F_sigma"); table(14).set_values(self(:).F_sigma)

      ! Subheadings
      table( 4).set_subhead("/A^-1")
      table( 5).set_subhead("/A")
      table( 6).set_subhead("Re")
      table( 7).set_subhead("Im")
      table( 8).set_subhead("/deg")
      table( 9).set_subhead("Re")
      table(10).set_subhead("Im")
      table(11).set_subhead("(scaled)")
      table(12).set_subhead("(exp)")

      table.put

      ! Clean
      table.destroy
      F_di.destroy
      F_dr.destroy
      F_ph.destroy
      F_ci.destroy
      F_cr.destroy
      d.destroy
      stl.destroy

   end


   put_intensity_data
   ! Output the intensity data

      .put_I_statistics

      if (.use_multiple_scale_factors) then; .put_I_group_data
      else;                                  .put_I_nogrp_data
      end

   end

   put_I_statistics(show_chi2)
   ! Output the intensity goodness of fit statistics
      show_chi2 :: BIN, optional

   ENSURE(.have_I_exp, "No I_exp data!")
   ENSURE(.have_I_pred,"No I_pred data!")

      chi2 :: REAL
      show :: BIN

      stdout.flush
      stdout.text("Model statistics based on intensities:")
      stdout.flush
      stdout.text("Note: be careful when using these chi^2 values")
      stdout.text("after a Hirshfeld-atom refinement, the number of")
      stdout.text("parameters N_p will not be correct.")
      stdout.flush

      stdout.show("R_sigma(I)                   =", .I_r_sigma)
      stdout.show("R(I)                         =", .I_r_factor)
      stdout.show("Rw(I)                        =", .I_weighted_r_factor)

      show = TRUE
      if (present(show_chi2)) show = show_chi2

      if (show) then
      chi2 = .I_chi2
      stdout.show("chi^2(N_p=1)(I)              =", chi2)
      stdout.show("Goodness of fit(N_p=1)(I)    =", sqrt(chi2))
      end

   end

   put_I_free_stats(show_chi2)
   ! Output the intensity goodness of fit statistics
      show_chi2 :: BIN, optional

   ENSURE(.have_I_exp, "No I_exp data!")
   ENSURE(.have_I_pred,"No I_pred data!")

      chi2 :: REAL
      show :: BIN

      stdout.flush
      stdout.text("Model statistics based on free intensities:")
      stdout.flush
      stdout.text("Note: be careful when using these chi^2 values")
      stdout.text("after a Hirshfeld-atom refinement, the number of")
      stdout.text("parameters N_p will not be correct.")
      stdout.flush

      stdout.show("Free R_sigma(I)              =", .I_r_sigma)
      stdout.show("Free R(I)                    =", .I_r_factor)
      stdout.show("Free Rw(I)                   =", .I_weighted_r_factor)

      show = TRUE
      if (present(show_chi2)) show = show_chi2

      if (show) then
      chi2 = .I_chi2
      stdout.show("Free chi^2(N_p=1)(I)         =", chi2)
      stdout.show("Free GOF(N_p=1)(I)           =", sqrt(chi2))
      end

   end

   put_I_nogrp_data ::: private
   ! Output the intensity data, with only one scale factor groups
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      I_z :: VEC{REAL}@

      ! Get data
      I_z.create(.dim); I_z = REFLECTION:I_z(self)

      ! Make table
      table.create(8)
      table(1).set_heading("h");       table(1).set_values(self(:).h)
      table(2).set_heading("k");       table(2).set_values(self(:).k)
      table(3).set_heading("l");       table(3).set_values(self(:).l)
      table(4).set_heading("I_calc");  table(4).set_values(self(:).I_calc)
      table(5).set_heading("I_pred");  table(5).set_values(self(:).I_pred)
      table(6).set_heading("I_exp");   table(6).set_values(self(:).I_exp)
      table(7).set_heading("I_sigma"); table(7).set_values(self(:).I_sigma)
      table(8).set_heading("I_z");     table(8).set_values(I_z)
      table.put

      ! Clean
      table.destroy
      I_z.destroy

   end

   put_I_group_data ::: private
   ! Output the intensity data, with multiple scale factor groups
      self :: IN

      table :: VEC{TABLE_COLUMN}@
      I_z :: VEC{REAL}@

      ! Get data
      I_z.create(.dim); I_z = REFLECTION:I_z(self)

      ! Make table
      table.create(9)
      table(1).set_heading("h");       table(1).set_values(self(:).h)
      table(2).set_heading("k");       table(2).set_values(self(:).k)
      table(3).set_heading("l");       table(3).set_values(self(:).l)
      table(4).set_heading("Scale");   table(4).set_values(self(:).group)
      table(5).set_heading("I_calc");  table(5).set_values(self(:).I_calc)
      table(6).set_heading("I_pred");  table(6).set_values(self(:).I_pred)
      table(7).set_heading("I_exp");   table(7).set_values(self(:).I_exp)
      table(8).set_heading("I_sigma"); table(8).set_values(self(:).I_sigma)
      table(9).set_heading("I_z");     table(9).set_values(I_z)
      table.put

      ! Subheadings
      table(4).set_subhead("group")

      ! Clean
      table.destroy
      I_z.destroy

   end

   put_I_pred_data
   ! Output only the predicted intensity data
      self :: IN

      table :: VEC{TABLE_COLUMN}@

      ! Make table
      table.create(5)
      table(1).set_heading("h");      table(1).set_values(self(:).h)
      table(2).set_heading("k");      table(2).set_values(self(:).k)
      table(3).set_heading("l");      table(3).set_values(self(:).l)
      table(4).set_heading("I_calc"); table(4).set_values(self(:).I_calc)
      table(5).set_heading("I_pred"); table(5).set_values(self(:).I_pred)
      table.put

      ! Subheadings
      table(4).set_subhead("Re")
      table(5).set_subhead("Im")

      ! Clean
      table.destroy

   end

   put_I_exp_data
   ! Output only the experimental intensity data
      if (.use_multiple_scale_factors) then; .put_I_exp_group_data
      else;                                  .put_I_exp_nogrp_data
      end
   end

   put_I_exp_nogrp_data ::: private
   ! Output only the experimental intensity data, where only
   ! one scale factor (scale group) is used.
      self :: IN

      table :: VEC{TABLE_COLUMN}@

      ! Make table
      table.create(5)
      table(1).set_heading("h");       table(1).set_values(self(:).h)
      table(2).set_heading("k");       table(2).set_values(self(:).k)
      table(3).set_heading("l");       table(3).set_values(self(:).l)
      table(4).set_heading("I_exp");   table(4).set_values(self(:).I_exp)
      table(5).set_heading("I_sigma"); table(5).set_values(self(:).I_sigma)
      table.put

      ! Clean
      table.destroy

   end

   put_I_exp_group_data ::: private
   ! Output only the experimental intensity data where multiple scale
   ! factors (scale groups) are used.
      self :: IN

      table :: VEC{TABLE_COLUMN}@

      ! Make table
      table.create(6)
      table(1).set_heading("h");       table(1).set_values(self(:).h)
      table(2).set_heading("k");       table(2).set_values(self(:).k)
      table(3).set_heading("l");       table(3).set_values(self(:).l)
      table(4).set_heading("Scale");   table(4).set_values(self(:).group)
      table(5).set_heading("I_exp");   table(5).set_values(self(:).I_exp)
      table(6).set_heading("I_sigma"); table(6).set_values(self(:).I_sigma)
      table.put

      ! Subheadings
      table(4).set_subhead("group")

      ! Clean
      table.destroy

   end

!  =======
!  Put CIF
!  =======

   put_CIF(threshold)
   ! Put reflection information in CIF format
      self :: IN
      threshold :: STR, IN

      table :: VEC{TABLE_COLUMN}@
      F_cr,F_ci,F_ph,F_z,stl,d :: VEC{REAL}@


      ! Put wavelength and other refln data
      .put_CIF_refln_data(threshold)

      ! Actual hkl's ...
      stdout.flush
      stdout.text("loop_")
      stdout.text("    _refln_index_h")
      stdout.text("    _refln_index_k")
      stdout.text("    _refln_index_l")
      stdout.text("    _refln_index_group")
      stdout.text("    _refln_stl")
      stdout.text("    _refln_d_spacing")
      stdout.text("    _refln_A_calc")
      stdout.text("    _refln_B_calc")
      stdout.text("    _refln_phase_calc")
      stdout.text("    _refln_F_calc")
      stdout.text("    _refln_F_meas")
      stdout.text("    _refln_F_sigma")
      stdout.text("    _refln_delta_F_on_sigma")

      ! Get data
      stl     = self(:).stl*BOHR_PER_ANGSTROM
      d       = self(:).d  *ANGSTROM_PER_BOHR
      F_cr    = RE(.F_calc)
      F_ci    = IM(.F_calc)
      F_ph    = REFLECTION:F_phase_angle_in_degrees(self)
      F_z     = REFLECTION:F_z(self)

      ! Make table
      table.create(13)
      table( 1).set_values(self(:).h)
      table( 2).set_values(self(:).k)
      table( 3).set_values(self(:).l)
      table( 4).set_values(self(:).group)
      table( 5).set_values(stl)
      table( 6).set_values(d)
      table( 7).set_values(F_cr)
      table( 8).set_values(F_ci)
      table( 9).set_values(F_ph)
      table(10).set_values(self(:).F_pred)
      table(11).set_values(self(:).F_exp)
      table(12).set_values(self(:).F_sigma)
      table(13).set_values(F_z)

      ! Body
      table.put_body

      ! Clean
      table.destroy

   end

   put_CIF_refln_data(threshold)
   ! Put reflection information in CIF format
      self :: IN
      threshold :: STR, IN

      lambda :: REAL
      fcmax :: REAL

      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Reflections")
      stdout.text("# ===========")

      lambda = REFLECTION:wavelength()
      lambda.convert_to("angstrom")

      stdout.flush
      stdout.show("_diffrn_radiation_wavelength       ",lambda                  ,dots=FALSE)

      fcmax = maxval(abs(self(:).F_calc))
      stdout.flush
      stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)

      stdout.flush
      stdout.show("_reflns_d_resolution_high          ",.d_max*ANGSTROM_PER_BOHR,dots=FALSE)
      stdout.show("_reflns_d_resolution_low           ",.d_min*ANGSTROM_PER_BOHR,dots=FALSE)
      stdout.show("_reflns_limit_h_max                ",maxval(self(:).h)       ,dots=FALSE)
      stdout.show("_reflns_limit_h_min                ",minval(self(:).h)       ,dots=FALSE)
      stdout.show("_reflns_limit_k_max                ",maxval(self(:).k)       ,dots=FALSE)
      stdout.show("_reflns_limit_k_min                ",minval(self(:).k)       ,dots=FALSE)
      stdout.show("_reflns_limit_l_max                ",maxval(self(:).l)       ,dots=FALSE)
      stdout.show("_reflns_limit_l_min                ",minval(self(:).l)       ,dots=FALSE)
      stdout.show("_reflns_number_gt                  ",.dim                    ,dots=FALSE)
      stdout.show("_reflns_number_total               ",.dim                    ,dots=FALSE)
      stdout.show("_reflns_threshold_expression       ",threshold               ,dots=FALSE)

      stdout.flush
      stdout.text("_reflns_special_details            ")
      stdout.text(";")
      stdout.text("* Specify symmetry and Friedel pair averaging *")

      stdout.flush
      stdout.text(". Only reflections which satisfy the threshold expression")
      stdout.text("  are listed below, and only they are considered observed,")
      stdout.text("  thus the *_gt, *_all, & *_total data are always the same")
      stdout.text(";")

   end

   put_shelx_hkl3
   ! Put reflection information in shelx hkl3 format
      self :: IN

      i :: INT

      do i = 1,.dim
         stdout.put(self(i).h,width=4)
         stdout.put(self(i).k,width=4)
         stdout.put(self(i).l,width=4)
         stdout.put(self(i).F_exp)
         stdout.put(self(i).F_sigma)
         stdout.flush
      end

   end

   put_shelx_hkl4
   ! Put reflection information in shelx hkl4 format
      self :: IN

      i :: INT

      do i = 1,.dim
         stdout.put(self(i).h,width=4)
         stdout.put(self(i).k,width=4)
         stdout.put(self(i).l,width=4)
         stdout.put(self(i).F2_exp)
         stdout.put(self(i).F2_sigma)
         stdout.flush
      end

   end

!  ========
!  QQ plots
!  ========

   put_labelled_F_qq_plot(tag)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
      self :: IN
      tag :: STR, optional, IN

      grid :: MAT{REAL}*
      hkl :: MAT{INT}*
      name :: STR
      n :: INT

      name = " "
      if (present(tag)) name = tag

      hkl.create(.dim,3)
      do n = 1,.dim
         hkl(n,:) = .indices(n)
      end

      grid.create(.dim,2)

      .make_F_qq_plot_grid(grid,hkl)

      stdout.redirect("stdout.QQ_plot_with_hkl")

      stdout.text("# Labelled QQ plot:")
      stdout.text("# ")
      stdout.text("# 1st column: F_z(normal)")
      stdout.text("# 2nd column: F_z(exp)")
      stdout.text("# 3rd column: h")
      stdout.text("# 4th column: k")
      stdout.text("# 5th column: l")
      stdout.text("# F_z = (F_exp - F_pred)/F_sigma")
      stdout.text("# Note: Fexp & F_pred may have dispersion removed")
      stdout.text("# ")
      stdout.text("# Abrahams & Keve (1971) Acta Cryst A 27 p. 157 ")
      stdout.text("# ")

      do n = 1,.dim
         stdout.put(grid(n,1))
         stdout.put(grid(n,2))
         stdout.put(hkl(n,1))
         stdout.put(hkl(n,2))
         stdout.put(hkl(n,3))
         stdout.flush
      end

      stdout.revert

      grid.destroy
      hkl.destroy

   end

   make_F_qq_plot_grid(grid,hkl)
   ! Make the grid for the Q-Q plot, which is a plot of the expected
   ! deviation in standard deviation units versus the actual
   ! deviations, assuming that the expected devaitions are normally
   ! distributed. grid(1,:) contains the expected deviation d0j,
   ! grid(2,:) contains actual deviation dj.
      self :: IN
      grid :: MAT{REAL}, INOUT
      hkl  :: MAT{INT}, optional, OUT

   ENSURE(grid.dim1==.dim, "grid: wrong dim1")
   ENSURE(grid.dim2==2,    "grid: wrong dim2")

      p :: REAL
      i,j :: INT

      ! grid(:,1) ! theoretical z's
      ! grid(:,2) ! calculated z's

      do i = 1,.dim
         grid(i,2) = self(i).F_z
      end

      ! Sort array from lowest z to highest
      if (present(hkl)) then

         ENSURE(size(hkl,1)==.dim, "size of index array incorrect")
         ENSURE(size(hkl,2)==3,    "size of index array incorrect")

         do i = 1,.dim-1
         do j = i+1,.dim
            if (grid(j,2) < grid(i,2)) then
               grid(:,2).swap_elements(i,j)
               hkl.swap_rows(i,j)
            end
         end
         end

      else

         grid(:,2).sort

      end

      do j = 1,.dim                        ! expected quantile, d0j
         p = (TWO*(.dim-j)+ONE)/(TWO*.dim) ! cumulative probability
         grid(.dim-j+1,1) = REAL:z_from_cumulative_p(p)
      end

   end

end
