!-------------------------------------------------------------------------------
!
! MAT4{RMS2_INDICES}
!
! This object is used to store precalculated information pertaining to the
! reduced multiplication scheme (RMS) used in electron repulsion integral 
! evaluation.
!
! Copyright (C) Dylan Jayatilaka, 2000
! Copyright (C) Dylan Jayatilaka, 2021
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module MAT4{RMS2_INDICES}

   implicit none

contains

! ==========
! Allocation
! ==========

   create(dim1,dim2,dim3,dim4) ::: get_from(MAT4{OBJECT}), leaky, PURE
   ! Allocate the object
   end

   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: get_from(MAT4{OBJECT}), leaky, PURE
   ! Allocate the object with the given bounds
   end

   destroy ::: get_from(MAT4{OBJECT}), leaky, PURE
   ! Deallocate the object
   end

   destroy_ptr_part ::: get_from(MAT4{OBJECT}), leaky, PURE
   ! Destroy the pointer parts of self
   end

! ===========
! Set indices
! ===========

   set_indices(l_max,rms_indices,nx,ny,nz) ::: leaky, PURE
   ! Set the rms indices. 
      self :: allocatable, INOUT
      l_max :: INT, IN
      rms_indices :: MAT{RMS_INDICES}@
      nx,ny,nz :: VEC{INT}, IN

   ENSURE(.allocated,"no self object")
   ENSURE(lbound(self,1)==0,"lower bound 1 wrong")
   ENSURE(lbound(self,2)==0,"lower bound 2 wrong")
   ENSURE(lbound(self,3)==0,"lower bound 3 wrong")
   ENSURE(lbound(self,4)==0,"lower bound 4 wrong")
   ENSURE(ubound(self,1)==l_max,"upper bound 1 wrong")
   ENSURE(ubound(self,2)==l_max,"upper bound 2 wrong")
   ENSURE(ubound(self,3)==l_max,"upper bound 3 wrong")
   ENSURE(ubound(self,4)==l_max,"upper bound 4 wrong")
   ENSURE(lbound(rms_indices,1)==0,"rms_indices, lower bound 1 wrong")
   ENSURE(lbound(rms_indices,2)==0,"rms_indices, lower bound 2 wrong")
   ENSURE(ubound(rms_indices,1)==l_max,"rms_indices, upper bound 1 wrong")
   ENSURE(ubound(rms_indices,2)==l_max,"rms_indices, upper bound 2 wrong")
   ENSURE(nx.dim==MAT4{RMS2_INDICES}::n_comp_up_to(2*l_max),"wrong size, nx")
   ENSURE(ny.dim==nx.dim,"wrong size, ny")
   ENSURE(nz.dim==nx.dim,"wrong size, nz")

      ab_lmax,ab_lmin,fe,le :: INT
      cd_lmax,cd_lmin,ff,lf :: INT
      
      do ab_lmax = 0,l_max   ! Maximum l for a shell
      do ab_lmin = 0,ab_lmax ! l for the b shell
      
         fe = MAT4{RMS2_INDICES}::n_comp_up_to(ab_lmax-1)+1
         le = MAT4{RMS2_INDICES}::n_comp_up_to(ab_lmin+ab_lmax)
      
         do cd_lmax = 0,l_max   ! Maximum l for c shell
         do cd_lmin = 0,cd_lmax ! l for the d shell
      
            ff = MAT4{RMS2_INDICES}::n_comp_up_to(cd_lmax-1)+1
            lf = MAT4{RMS2_INDICES}::n_comp_up_to(cd_lmin+cd_lmax)
      
            self(ab_lmax,ab_lmin,cd_lmax,cd_lmin).set_indices( &
               rms_indices(ab_lmax,ab_lmin),  & 
               rms_indices(cd_lmax,cd_lmin),  &
               nx(fe:le),ny(fe:le),nz(fe:le), &
               nx(ff:lf),ny(ff:lf),nz(ff:lf), &
               ab_lmax+ab_lmin )
            !  ab_lmax+ab_lmin,cd_lmax+cd_lmin )
            !  ab_lmax,ab_lmin,cd_lmax,cd_lmin )
      
         end
         end
      
      end
      end

   end

   n_comp_up_to(l) result (res) ::: selfless, private, pure
   ! No. of gaussian cartesian component functions up to and including
   ! the shell with momentum "l".
      l :: INT, IN
      res :: INT
      res = (l+1)*(l+2)*(l+3)/6
   end

end
