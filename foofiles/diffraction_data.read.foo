!====================================================================
!
! DIFFRACTION_DATA.READ: 
!
! Diffraction data structure for crystals: read & documentation
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
! Copyright (C) Dylan Jayatilaka 2023
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!====================================================================

module DIFFRACTION_DATA.READ

   implicit none

contains

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the
   ! "keyword" is inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR
      die  :: BIN

      word = keyword
      word.to_lower_case

      select case (word)

      case ("}                             ")  ! exit read_loop

      case ("add_dispersion_to_f_calc=     "); .READ:read_add_dispersion_to_F_calc
      case ("correct_dispersion=           "); .READ:read_add_dispersion_to_F_calc
      case ("d_low_cutoff=                 "); .READ:read_d_low_cutoff
      case ("destroy_reflection_data       "); .SET:destroy_reflection_data
      case ("display_correlation_matrix=   "); .READ:read_show_corrrelation_mx
      case ("display_near_0_eigenvectors=  "); .READ:read_show_near_0_evecs
      case ("do_residual_cube=             "); .READ:read_do_residual_cube
      case ("exp_scale_factor=             "); .READ:read_exp_scale_factor
      case ("f_calc_cutoff=                "); .READ:read_F_calc_cutoff
      case ("f_pred_cutoff=                "); .READ:read_F_pred_cutoff
      case ("f_sigma_cutoff=               "); .READ:read_F_sigma_cutoff
      case ("f_sigma_noise=                "); .READ:read_F_sigma_noise
      case ("f_z_cutoff=                   "); .READ:read_F_z_cutoff
      case ("hkl_range=                    "); .READ:read_hkl_range
      case ("i_pred_cutoff=                "); .READ:read_I_pred_cutoff
      case ("i_sigma_cutoff=               "); .READ:read_I_sigma_cutoff
      case ("i_z_cutoff=                   "); .READ:read_I_z_cutoff
    ! case ("invariom_database_directory=  "); .READ:read_invariom_directory
    ! case ("invariom_refinement=          "); .READ:read_invariom_refinement
    ! case ("junk=                         "); .READ:read_junk
      case ("kind=                         "); .READ:read_data_kind
      case ("make_f_predicted              "); .SET:make_F_predicted
      case ("max_allowed_param_shift=      "); .READ:read_max_allowed_param_shift
      case ("max_iterations=               "); .READ:read_max_iterations
      case ("max_prune_iterations=         "); .READ:read_max_prune_iterations
      case ("min_correlation=              "); .READ:read_min_correlation
      case ("min_iterations=               "); .READ:read_min_iterations
    ! case ("nka_t_sequence_no=            "); .READ:read_NKA_T_seq_no
      case ("n_data_sets=                  "); .READ:read_n_data_sets
      case ("n_param=                      "); .READ:read_n_param
      case ("n_worst_reflections=          "); .READ:read_n_worst_reflections
      case ("near_0_tol=                   "); .READ:read_near_0_tol
      case ("optimise_extinction=          "); .READ:read_refine_extinction
      case ("optimize_extinction=          "); .READ:read_refine_extinction
      case ("optimise_scale_factor=        "); .READ:read_refine_scale
      case ("optimize_scale_factor=        "); .READ:read_refine_scale
      case ("optimise_scale_factors=       "); .READ:read_refine_scale
      case ("optimize_scale_factors=       "); .READ:read_refine_scale
      case ("partition_model=              "); .READ:read_partition_model
    ! case ("prune_reflections             "); .prune_reflections ! Apply automatically?

      !  Put            

      case ("put                           "); .PUT:put
      case ("put_worst_reflections         "); .PUT:put_worst_reflections
      case ("put_sin_theta_on_lambda       "); .PUT:put_sin_theta_on_lambda
      case ("put_wavelength                "); .PUT:put_wavelength

      case ("read_cif                      "); .READ:read_CIF
      case ("read_fcf_file                 "); .READ:read_fcf_file
      case ("redirect                      "); .READ:redirect
      case ("refine_3rd_order_for_atoms=   "); .READ:read_refine_3rd_order
      case ("refine_4th_order_for_atoms=   "); .READ:read_refine_4th_order
      case ("refine_4th_order_only=        "); .READ:read_refine_4th_order_only
      case ("refine_adps_only=             "); .READ:read_refine_ADPs_only
      case ("refine_anharmonicity=         "); .READ:read_refine_anharmonicity
      case ("refine_extinction=            "); .READ:read_refine_extinction
      case ("refine_f=                     "); .READ:read_refine_F
      case ("refine_h_adps=                "); .READ:read_refine_H_ADPs
      case ("refine_h_adps_only=           "); .READ:read_refine_H_ADPs
      case ("refine_h_positions=           "); .READ:read_refine_H_positions
      case ("refine_h_positions_only=      "); .READ:read_refine_H_positions
      case ("refine_h_u_iso=               "); .READ:read_refine_H_U_iso
      case ("refine_nothing_for_atoms=     "); .READ:read_refine_nothing_for_atoms
      case ("refine_positions_only=        "); .READ:read_refine_positions_only
      case ("refine_scale_factor=          "); .READ:read_refine_scale
      case ("refine_scale_factors=         "); .READ:read_refine_scale
      case ("refine_u_iso_for_atoms=       "); .READ:read_refine_U_iso_for_atoms
      case ("reflection_data=              "); .READ:read_reflection_data
      case ("remove_dispersion_from_f_exp= "); .READ:read_remove_disp_from_F_exp
      case ("restart_har_with_promolecule= "); .READ:read_restart_with_promolecule
      case ("revert                        "); .READ:revert
      case ("sf_mixing_parameter=          "); .READ:read_SF_mixing_parameter
      case ("show_correlation_matrix=      "); .READ:read_show_corrrelation_mx
      case ("show_fit_output=              "); .READ:read_show_fit_output
      case ("show_fit_results=             "); .READ:read_show_fit_results
      case ("show_near_0_eigenvectors=     "); .READ:read_show_near_0_evecs
      case ("show_refinement_output=       "); .READ:read_show_ref_output
      case ("show_refinement_results=      "); .READ:read_show_ref_results
      case ("show_rejects=                 "); .READ:read_show_rejects
      case ("stl_high_cutoff=              "); .READ:read_stl_high_cutoff
      case ("stl_limit=                    "); .READ:read_stl_limit
      case ("stl_low_cutoff=               "); .READ:read_stl_low_cutoff
      case ("stop_after_dispersion=        "); .READ:read_stop_after_dispersion
      case ("synthesize_sigma_i=           "); .READ:read_synthesize_sigma_I
      case ("thermal_smearing_model=       "); .READ:read_temperature_factor_model
      case ("temperature=                  "); .READ:read_temperature
      case ("temperature_factor_model=     "); .READ:read_temperature_factor_model
      case ("tol_for_shift_on_esd=         "); .READ:read_tol_for_shift_on_esd
      case ("tol_near_0=                   "); .READ:read_near_0_tol
      case ("use_disk_sfs=                 "); .READ:read_use_disk_SFs
      case ("use_equivalents=              "); .READ:read_use_equivalents
!     case ("use_IAM_density=              "); .READ:read_use_IAM_density
!     case ("use_IAM_ITC_FFs=              "); .READ:read_use_IAM_ITC_FFs
      case ("use_ryde_capping=             "); .READ:read_use_Ryde_capping
      case ("use_text_sfs=                 "); .READ:read_use_text_SFs
      case ("wavelength=                   "); .READ:read_wavelength

      !  Documentation

      case ("add_dispersion_to_f_calc=?    "); DIFFRACTION_DATA.READ:docu_add_dispersion_to_F_calc(die)
      case ("correct_dispersion=?          "); DIFFRACTION_DATA.READ:docu_add_dispersion_to_F_calc(die)
      case ("d_low_cutoff=?                "); DIFFRACTION_DATA.READ:docu_d_low_cutoff(die)
      case ("destroy_reflection_data?      "); DIFFRACTION_DATA.READ:docu_destroy_reflection_data(die)
      case ("display_correlation_mx=?      "); DIFFRACTION_DATA.READ:docu_show_corr_matrix(die)
      case ("display_near_0_eigenvectors=? "); DIFFRACTION_DATA.READ:docu_show_near_0_evecs(die)
      case ("do_residual_cube=?            "); DIFFRACTION_DATA.READ:docu_do_residual_cube(die)
      case ("exp_scale_factor=?            "); DIFFRACTION_DATA.READ:docu_exp_scale_factor(die)
      case ("f_calc_cutoff=?               "); DIFFRACTION_DATA.READ:docu_F_calc_cutoff(die)
      case ("f_pred_cutoff=?               "); DIFFRACTION_DATA.READ:docu_F_pred_cutoff(die)
      case ("f_sigma_cutoff=?              "); DIFFRACTION_DATA.READ:docu_F_sigma_cutoff(die)
      case ("f_sigma_noise=?               "); DIFFRACTION_DATA.READ:docu_F_sigma_noise(die)
      case ("f_z_cutoff=?                  "); DIFFRACTION_DATA.READ:docu_F_z_cutoff(die)
      case ("fcf_file=?                    "); DIFFRACTION_DATA.READ:docu_fcf_file(die)
      case ("hkl_range=?                   "); DIFFRACTION_DATA.READ:docu_hkl_range(die)
      case ("i_pred_cutoff=?               "); DIFFRACTION_DATA.READ:docu_I_pred_cutoff(die)
      case ("i_sigma_cutoff=?              "); DIFFRACTION_DATA.READ:docu_I_sigma_cutoff(die)
      case ("i_z_cutoff=?                  "); DIFFRACTION_DATA.READ:docu_I_z_cutoff(die)
    ! case ("invariom_database_directory=? "); DIFFRACTION_DATA.READ:docu_invariom_directory(die)
    ! case ("invariom_refinement=?         "); DIFFRACTION_DATA.READ:docu_invariom_refinement(die)
    ! case ("junk=?                        "); DIFFRACTION_DATA.READ:docu_junk(die)
      case ("kind=?                        "); DIFFRACTION_DATA.READ:docu_data_kind(die)
      case ("make_f_predicted?             "); DIFFRACTION_DATA.READ:docu_make_F_predicted(die)
      case ("max_allowed_param_shift=?     "); DIFFRACTION_DATA.READ:docu_max_allowed_param_shift(die)
      case ("max_iterations=?              "); DIFFRACTION_DATA.READ:docu_max_iterations(die)
      case ("max_prune_iterations=?        "); DIFFRACTION_DATA.READ:docu_max_prune_iterations(die)
      case ("min_correlation=?             "); DIFFRACTION_DATA.READ:docu_min_correlation(die)
      case ("min_iterations=?              "); DIFFRACTION_DATA.READ:docu_min_iterations(die)
    ! case ("nka_t_sequence_no=?           "); DIFFRACTION_DATA.READ:docu_NKA_T_seq_no(die)
      case ("n_data_sets=?                 "); DIFFRACTION_DATA.READ:docu_n_data_sets(die)
      case ("n_param=?                     "); DIFFRACTION_DATA.READ:docu_n_param(die)
      case ("n_worst_reflections=?         "); DIFFRACTION_DATA.READ:docu_n_worst_reflections(die)
      case ("near_0_tol=?                  "); DIFFRACTION_DATA.READ:docu_near_0_tol(die)
      case ("optimize_scale_factors=?      "); DIFFRACTION_DATA.READ:docu_refine_scale(die)
      case ("optimise_extinction=?         "); DIFFRACTION_DATA.READ:docu_refine_extinction(die)
      case ("optimize_extinction=?         "); DIFFRACTION_DATA.READ:docu_refine_extinction(die)
      case ("optimise_scale_factor=?       "); DIFFRACTION_DATA.READ:docu_refine_scale(die)
      case ("optimize_scale_factor=?       "); DIFFRACTION_DATA.READ:docu_refine_scale(die)
      case ("optimise_scale_factors=?      "); DIFFRACTION_DATA.READ:docu_refine_scale(die)
      case ("refine_extinction=?           "); DIFFRACTION_DATA.READ:docu_refine_extinction(die)
      case ("refine_scale_factor=?         "); DIFFRACTION_DATA.READ:docu_refine_scale(die)
      case ("refine_scale_factors=?        "); DIFFRACTION_DATA.READ:docu_refine_scale(die)
      case ("partition_model=?             "); DIFFRACTION_DATA.READ:docu_partition_model(die)
    ! case ("prune_reflections             "); .prune_reflections ! Apply automatically?(die)
      case ("put?                          "); DIFFRACTION_DATA.READ:docu_put(die)
      case ("put_worst_reflections?        "); DIFFRACTION_DATA.READ:docu_put_worst_reflections(die)
      case ("put_sin_theta_on_lambda?      "); DIFFRACTION_DATA.READ:docu_put_sin_theta_on_lambda(die)
      case ("put_wavelength?               "); DIFFRACTION_DATA.READ:docu_put_wavelength(die)
      case ("read_cif?                     "); DIFFRACTION_DATA.READ:docu_CIF(die)
      case ("redirect?                     "); DIFFRACTION_DATA.READ:docu_redirect(die)
      case ("refine_3rd_order_for_atoms=?  "); DIFFRACTION_DATA.READ:docu_refine_3rd_order(die)
      case ("refine_4th_order_for_atoms=?  "); DIFFRACTION_DATA.READ:docu_refine_4th_order(die)
      case ("refine_4th_order_only=?       "); DIFFRACTION_DATA.READ:docu_refine_4th_order_only(die)
      case ("refine_adps_only=?            "); DIFFRACTION_DATA.READ:docu_refine_ADPs_only(die)
      case ("refine_anharmonicity=?        "); DIFFRACTION_DATA.READ:docu_refine_anharmonicity(die)
      case ("refine_f=?                    "); DIFFRACTION_DATA.READ:docu_refine_F(die)
      case ("refine_h_adps=?               "); DIFFRACTION_DATA.READ:docu_refine_H_ADPs_only(die)
      case ("refine_h_adps_only=?          "); DIFFRACTION_DATA.READ:docu_refine_H_ADPs_only(die)
      case ("refine_h_positions=?          "); DIFFRACTION_DATA.READ:docu_refine_H_positions_only(die)
      case ("refine_h_positions_only=?     "); DIFFRACTION_DATA.READ:docu_refine_H_positions_only(die)
      case ("refine_h_u_iso=?              "); DIFFRACTION_DATA.READ:docu_refine_H_U_iso(die)
      case ("refine_nothing_for_atoms=?    "); DIFFRACTION_DATA.READ:docu_refine_nothing_for_atoms(die)
      case ("refine_positions_only=?       "); DIFFRACTION_DATA.READ:docu_refine_positions_only(die)
      case ("refine_u_iso_for_atoms=?      "); DIFFRACTION_DATA.READ:docu_refine_U_iso_for_atoms(die)
      case ("reflection_data=?             "); DIFFRACTION_DATA.READ:docu_reflection_data(die)
      case ("remove_dispersion_from_f_exp=?"); DIFFRACTION_DATA.READ:docu_remove_disp_from_F_exp(die)
      case ("restart_har_with_promolecule=?"); DIFFRACTION_DATA.READ:docu_restart_with_promolecule(die)
      case ("revert?                       "); DIFFRACTION_DATA.READ:docu_revert(die)
      case ("sf_mixing_parameter=?         "); DIFFRACTION_DATA.READ:docu_SF_mixing_parameter(die)
      case ("show_fit_output=?             "); DIFFRACTION_DATA.READ:docu_show_fit_output(die)
      case ("show_fit_results=?            "); DIFFRACTION_DATA.READ:docu_show_fit_results(die)
      case ("show_refinement_output=?      "); DIFFRACTION_DATA.READ:docu_show_ref_output(die)
      case ("show_refinement_results=?     "); DIFFRACTION_DATA.READ:docu_show_ref_results(die)
      case ("show_rejects=?                "); DIFFRACTION_DATA.READ:docu_show_rejects(die)
      case ("stl_high_cutoff=?             "); DIFFRACTION_DATA.READ:docu_stl_high_cutoff(die)
      case ("stl_low_cutoff=?              "); DIFFRACTION_DATA.READ:docu_stl_low_cutoff(die)
      case ("stl_limit=?                   "); DIFFRACTION_DATA.READ:docu_stl_limit(die)
    ! case ("stop_after_dispersion=?       "); DIFFRACTION_DATA.READ:docu_stop_after_dispersion(die)
    ! case ("synthesize_sigma_i=?          "); DIFFRACTION_DATA.READ:docu_synthesize_sigma_I(die)
      case ("thermal_smearing_model=?      "); DIFFRACTION_DATA.READ:docu_temperature_factor_model(die)
    ! case ("temperature=?                 "); DIFFRACTION_DATA.READ:docu_temperature(die)
      case ("temperature_factor_model=?    "); DIFFRACTION_DATA.READ:docu_temperature_factor_model(die)
      case ("tol_for_shift_on_esd=?        "); DIFFRACTION_DATA.READ:docu_tol_for_shift_on_esd(die)
      case ("tol_near_0=?                  "); DIFFRACTION_DATA.READ:docu_near_0_tol(die)
      case ("use_disk_sfs=?                "); DIFFRACTION_DATA.READ:docu_use_disk_SFs(die)
      case ("use_equivalents=?             "); DIFFRACTION_DATA.READ:docu_use_equivalents(die)
      case ("use_ryde_capping=?            "); DIFFRACTION_DATA.READ:docu_use_Ryde_capping(die)
      case ("use_text_sfs=?                "); DIFFRACTION_DATA.READ:docu_use_text_SFs(die)
      case ("wavelength=?                  "); DIFFRACTION_DATA.READ:docu_wavelength(die)
      case ("help?                         "); DIFFRACTION_DATA.READ:docu_help

      case default;                       UNKNOWN(word)

      end

   end

! Reading

   docu_help ::: selfless, private
   ! Documentation.

      stdout.flush
      stdout.flush
      stdout.text("=========================")
      stdout.text("Help for DIFFRACTION_DATA")
      stdout.text("=========================")

      DIFFRACTION_DATA.READ:docu_add_dispersion_to_F_calc
      DIFFRACTION_DATA.READ:docu_d_low_cutoff
      DIFFRACTION_DATA.READ:docu_destroy_reflection_data
      DIFFRACTION_DATA.READ:docu_show_corr_matrix
      DIFFRACTION_DATA.READ:docu_show_near_0_evecs
      DIFFRACTION_DATA.READ:docu_do_residual_cube
      DIFFRACTION_DATA.READ:docu_exp_scale_factor
      DIFFRACTION_DATA.READ:docu_F_calc_cutoff
      DIFFRACTION_DATA.READ:docu_F_pred_cutoff
      DIFFRACTION_DATA.READ:docu_F_sigma_cutoff
      DIFFRACTION_DATA.READ:docu_F_sigma_noise
      DIFFRACTION_DATA.READ:docu_F_z_cutoff
      DIFFRACTION_DATA.READ:docu_hkl_range
      DIFFRACTION_DATA.READ:docu_I_pred_cutoff
      DIFFRACTION_DATA.READ:docu_I_sigma_cutoff
      DIFFRACTION_DATA.READ:docu_I_z_cutoff
    ! DIFFRACTION_DATA.READ:docu_invariom_directory
    ! DIFFRACTION_DATA.READ:docu_invariom_refinement
    ! DIFFRACTION_DATA.READ:docu_junk
      DIFFRACTION_DATA.READ:docu_data_kind
      DIFFRACTION_DATA.READ:docu_make_F_predicted
      DIFFRACTION_DATA.READ:docu_max_allowed_param_shift
      DIFFRACTION_DATA.READ:docu_max_iterations
      DIFFRACTION_DATA.READ:docu_max_prune_iterations
      DIFFRACTION_DATA.READ:docu_min_correlation
      DIFFRACTION_DATA.READ:docu_min_iterations
    ! DIFFRACTION_DATA.READ:docu_NKA_T_seq_no
      DIFFRACTION_DATA.READ:docu_n_data_sets
      DIFFRACTION_DATA.READ:docu_n_param
      DIFFRACTION_DATA.READ:docu_n_worst_reflections
      DIFFRACTION_DATA.READ:docu_near_0_tol
      DIFFRACTION_DATA.READ:docu_refine_extinction
      DIFFRACTION_DATA.READ:docu_refine_scale
      DIFFRACTION_DATA.READ:docu_partition_model
!   ! .prune_reflections ! Apply automatically?
      DIFFRACTION_DATA.READ:docu_put
      DIFFRACTION_DATA.READ:docu_put_worst_reflections
      DIFFRACTION_DATA.READ:docu_put_sin_theta_on_lambda
      DIFFRACTION_DATA.READ:docu_put_wavelength
      DIFFRACTION_DATA.READ:docu_CIF
      DIFFRACTION_DATA.READ:docu_redirect
      DIFFRACTION_DATA.READ:docu_refine_3rd_order
      DIFFRACTION_DATA.READ:docu_refine_4th_order
      DIFFRACTION_DATA.READ:docu_refine_4th_order_only
      DIFFRACTION_DATA.READ:docu_refine_ADPs_only
      DIFFRACTION_DATA.READ:docu_refine_anharmonicity
      DIFFRACTION_DATA.READ:docu_refine_F
      DIFFRACTION_DATA.READ:docu_refine_H_ADPs_only
      DIFFRACTION_DATA.READ:docu_refine_H_positions_only
      DIFFRACTION_DATA.READ:docu_refine_H_U_iso
      DIFFRACTION_DATA.READ:docu_refine_nothing_for_atoms
      DIFFRACTION_DATA.READ:docu_refine_positions_only
      DIFFRACTION_DATA.READ:docu_refine_U_iso_for_atoms
      DIFFRACTION_DATA.READ:docu_reflection_data
      DIFFRACTION_DATA.READ:docu_remove_disp_from_F_exp
      DIFFRACTION_DATA.READ:docu_restart_with_promolecule
      DIFFRACTION_DATA.READ:docu_revert
      DIFFRACTION_DATA.READ:docu_SF_mixing_parameter
      DIFFRACTION_DATA.READ:docu_show_fit_output
      DIFFRACTION_DATA.READ:docu_show_fit_results
      DIFFRACTION_DATA.READ:docu_show_ref_output
      DIFFRACTION_DATA.READ:docu_show_ref_results
      DIFFRACTION_DATA.READ:docu_show_rejects
      DIFFRACTION_DATA.READ:docu_stl_high_cutoff
      DIFFRACTION_DATA.READ:docu_stl_low_cutoff
      DIFFRACTION_DATA.READ:docu_stl_limit
    ! DIFFRACTION_DATA.READ:docu_stop_after_dispersion
    ! DIFFRACTION_DATA.READ:docu_synthesize_sigma_I
      DIFFRACTION_DATA.READ:docu_temperature_factor_model
    ! DIFFRACTION_DATA.READ:docu_temperature
      DIFFRACTION_DATA.READ:docu_tol_for_shift_on_esd
      DIFFRACTION_DATA.READ:docu_use_disk_SFs
      DIFFRACTION_DATA.READ:docu_use_Ryde_capping
      DIFFRACTION_DATA.READ:docu_use_text_SFs
      DIFFRACTION_DATA.READ:docu_wavelength

      DIE("end of help documentation")

   end


! A

   docu_add_dispersion_to_F_calc(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("correct_dispersion=")
      stdout.text("add_dispersion_to_F_calc= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set whether to add atom-based anomalous dispersion")
      stdout.text("  corrections to the calculated structure factors, F_calc")
      if (present(die)) stop
   end

   read_add_dispersion_to_F_calc
   ! Read whether to add dispersion to F_calc.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_add_dispersion_to_F_calc(val)

   DIE_IF(.remove_dispersion_from_F_exp,"you already asked to remove dispersion from F_exp!")

   end

! D

   docu_d_low_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("d_low_cutoff= REAL")
      stdout.flush
      stdout.text(". Set the interplanar d spacing distance below which")
      stdout.text("  reflections are removed from the data set")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.text("  Initial negative value denotes feature is unused")
      if (present(die)) stop
   end

   read_d_low_cutoff ::: private
   ! Read the d_low_cutoff (spacings below this are pruned) which is
   ! converted to a stl_high_cutoff for prune_high_angle_reflections
      self :: INOUT

      d :: REAL

      stdin.read_quantity(d)
      .stl_high_cutoff = HALF/d

   ENSURE(.stl_high_cutoff>=ZERO,"must be positive")

   end

   docu_destroy_reflection_data(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("destroy_reflection_data")
      stdout.flush
      stdout.text(". Delete all reflection data, including the original")
      stdout.text("  reflection before any pruning, and reset all scale")
      stdout.text("  factors, extinction factors applied to correct |F_calc|")
      stdout.text("  or modify F_exp| to default values.")
      stdout.flush
      stdout.text(". Also, delete the measurement-group scale_factors.")
      stdout.flush
      stdout.text(". Also, delete any hkl_range= data")
      if (present(die)) stop
   end

   docu_show_corr_matrix(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_correlation_mx=    BIN [FALSE]")
      stdout.text("display_correlation_mx= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set whether to display the correlation matrix between")
      stdout.text("  the least-squares refined crystal structure parameters")
      stdout.flush
      stdout.text(". See also min_correlation=")
      stdout.flush
      stdout.text(". Correlations with scale factors, extinction parameters")
      stdout.text("  are not reported as they are refined outside of the LSQ")
      stdout.text("  procedure in order to permit wavefunction fitting")
      stdout.flush
      stdout.text(". See Davidson et al (2023) Acta Cryst B 72 p. 312-32")
      if (present(die)) stop
   end

   read_show_corrrelation_mx ::: private
   ! Read whether to display the correlation matrix.
      self :: INOUT

      stdin.read(.show_correlation_mx)
   
   end

   docu_show_near_0_evecs(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_near_0_eigenvector=    BIN [FALSE]")
      stdout.text("display_near_0_eigenvector= BIN [FALSE]")
      stdout.flush
      stdout.text(". Read whether to display the eigenvectors of the")
      stdout.text("  least-squares matrix corresponding to eigenvalues")
      stdout.text("  which are nearly equal to zero")
      stdout.flush
      stdout.text(". See also near_0_tol= ")
      if (present(die)) stop
   end

   read_show_near_0_evecs ::: private
   ! Read whether to display the near 0 eigenvectros of the correlation matrix.
      self :: INOUT

      stdin.read(.show_near_0_eigenvectors)

   end

   docu_do_residual_cube(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("do_residual_cube= BIN [TRUE]")
      stdout.flush
      stdout.text(". Set whether to calculate the residual density in the")
      stdout.text("  unit cell, to obtain the maximum, minimu and root-mean-")
      stdout.text("  -square values for the electron density fit")
      stdout.flush
      stdout.text(". This calculation can take some time, so for exploratory")
      stdout.text("  work it is best to set this option FALSE")
      if (present(die)) stop
   end

   read_do_residual_cube
   ! Read whether to write the residual density gaussian cube file.
   ! Can be used to speed up writing.
      self :: INOUT

      stdin.read(.do_residual_cube)

   end

! E

   docu_exp_scale_factor(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("exp_scale_factor= REAL")
      stdout.flush
      stdout.text(". A fixed scale factor which is applied to the")
      stdout.text("  experimental structure factors, F_exp")
      stdout.flush
      stdout.text(". Once applied, the F_exp values are changed forever")
      stdout.flush
      stdout.text(". Negative initial value indicates this scaling is")
      stdout.text("  not performed")
      if (present(die)) stop
   end

   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      self :: INOUT
      stdin.read(.exp_scale_factor)
   end

! F

   docu_F_calc_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("F_calc_cutoff= REAL [TOL(3)] ")
      stdout.flush
      stdout.text(". Set autoff for |F_calc| values, used to prune out small")
      stdout.text("  calculated structure factors.")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.text(". Initial negative value denotes feature is unused")
      stdout.flush
      stdout.text(". Useful for removing systematic absences from the data;")
      stdout.text("  essential for least-squares structure refinement to avoid")
      stdout.text("  potential divide-by-zero errors.")
      if (present(die)) stop
   end

   read_F_calc_cutoff ::: private
   ! Read the F_calc_cutoff for prune_F_calcs
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_F_calc_cutoff(val)

   end

   docu_F_pred_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("F_pred_cutoff= REAL")
      stdout.flush
      stdout.text(". Set cutoff for |F_pred| values, used to prune out small")
      stdout.text("  calculated structure factors.")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.flush
      stdout.text(". Useful for removing systematic absences from the data;")
      stdout.text("  essential for least-squares structure refinement to avoid")
      stdout.text("  potential divide-by-zero errors.")
      if (present(die)) stop
   end

   read_F_pred_cutoff ::: private
   ! Read the F_pred_cutoff for prune_F_preds
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_F_pred_cutoff(val)

   end

   docu_F_sigma_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("F_sigma_cutoff= REAL")
      stdout.flush
      stdout.text(". Set cutoff for |F_exp/F_sigma| values, used to prune out")
      stdout.text(". reflections where this quantity is too *small*")
      stdout.flush
      stdout.text(". Must be a positive value")
      if (present(die)) stop
   end

   read_F_sigma_cutoff ::: private
   ! Read the maximum acceptable value for F_cutoff
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_F_sigma_cutoff(val)

   end

   docu_F_sigma_noise(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("F_sigma_noise= REAL [ZERO] ")
      stdout.flush
      stdout.text(". If set, gaussian random noise is added to every experimental")
      stdout.text("  structure factor F_exp with standard deviation F_sigma.")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.flush
      stdout.text(". Once set, the F_exp values are changed forever")
      if (present(die)) stop
   end

   read_F_sigma_noise ::: private
   ! Read noise to add to F_exp and F_sigma, in units of F_sigma.
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_F_sigma_noise(val)

   end

   docu_F_z_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("F_z_cutoff= REAL ")
      stdout.flush
      stdout.text(". Set cutoff for |F_exp/F_sigma| values, used to prune out")
      stdout.text("  reflections where this quantity, the z value, is too *large*")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.flush
      stdout.text(". Used for pruning *bad* or *outlier* F_pred values")
      if (present(die)) stop
   end

   read_F_z_cutoff ::: private
   ! Read the F_z cutoff for prune_bad_reflections
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_F_z_cutoff(val)

   end

   docu_fcf_file(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("fcf_file= STR ")
      stdout.flush
      stdout.text(". If set, specifies the fcf file in the IUCr format from")
      stdout.text("  which reflections will be read.")
      stdout.flush
      stdout.text(". The file must end in .fcf")
      if (present(die)) stop
   end

   read_fcf_file
   ! Read the name of the fcf file from which to read in a unique set
   ! of reflections *and immediately read it in*.
      self :: INOUT

      val :: STR

      stdin.read(val)
      .SET:set_fcf_file_name(val)
      .SET:process_fcf_file

   end

! H

   docu_hkl_range(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("hkl_range= VEC{EVEC{INT}}@ ")
      stdout.flush
      stdout.text(". If set, specifies a range of Miller indices (h k l)")
      stdout.flush
      stdout.text("     { { hmin hmax } { kmin kmax } { lmin lmax } } ")
      stdout.flush
      stdout.text("  for which reflections are generated.")
      stdout.flush
      stdout.text(". Useful for obtaining calculated structure factors, F_calc")
      if (present(die)) stop
   end

   read_hkl_range ::: leaky, private
   ! Read the F_pred_cutoff for prune_F_preds
      self :: INOUT

      .hkl_range.destroy
      stdin.read_all(.hkl_range)

   end

! I

   docu_I_pred_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("I_pred_cutoff= REAL")
      stdout.flush
      stdout.text(". Set cutoff for |I_pred| values, also known as F2 values,")
      stdout.text(". used to prune out small-valued reflection intensities.")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.flush
      stdout.text(". Useful for removing systematic absences from the data;")
      stdout.text("  essential for least-squares structure refinement to avoid")
      stdout.text("  potential divide-by-zero errors.")
      if (present(die)) stop
   end

   read_I_pred_cutoff ::: private
   ! Read the I_pred_cutoff for prune_I_preds
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_I_pred_cutoff(val)

   end

   docu_I_sigma_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("I_sigma_cutoff= REAL [-FOUR] ")
      stdout.flush
      stdout.text(". Set cutoff for |I_exp/I_sigma| values, used to prune out")
      stdout.text(". reflections where this quantity is too *small*")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.text("  Initial negative value denotes this feature is unused")
      if (present(die)) stop
   end

   read_I_sigma_cutoff ::: private
   ! Read the maximum acceptable value for I_cutoff
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_I_sigma_cutoff(val)

   end

   docu_I_z_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("I_z_cutoff= REAL")
      stdout.flush
      stdout.text(". Set cutoff for |I_exp/I_sigma| values, used to prune out")
      stdout.text("  reflections where this quantity, the z value, is too *large*")
      stdout.flush
      stdout.text(". Must be a positive value")
      stdout.flush
      stdout.text(". Used for pruning *bad* or *outlier* F_pred values")
      if (present(die)) stop
   end

   read_I_z_cutoff ::: private
   ! Read the I_z cutoff for prune_bad_reflections
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .SET:set_I_z_cutoff(val)

   end

!   read_invariom_directory ::: private
!   ! Read in the directory for the invariom database.
!      self :: INOUT
!
!      stdin.read(.invariom_database_directory)
!
!   end

!   read_invariom_refinement ::: private
!   ! Read in the logical switch for the invariom refinement.
!      self :: INOUT
!
!      stdin.read(.invariom_refinement)
!
!   end

! K

   docu_data_kind(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("kind= STR")
      stdout.flush
      stdout.text(". Read the kind of diffractioin reflections which are")
      stdout.text("  to be input.")
      stdout.flush
      stdout.text(". Allowed values: xray, pnd")
      if (present(die)) stop
   end

   read_data_kind ::: private
   ! Read the data kind of crystal experiment
      self :: INOUT

      val :: STR

      stdin.read(val)
      .SET:set_data_kind(val)

   end

! N

   docu_make_F_predicted(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("make_f_predicted")
      stdout.flush
      stdout.text(". Make the predicted structure factors F_pred, including")
      stdout.text("  any scale factros, extinction, and anomaloud dispersion")
      stdout.text("  corrections, if they were requested.")
      stdout.flush
      stdout.text(". A set of experimental structure factors must be present")
      if (present(die)) stop
   end

   docu_max_allowed_param_shift(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("max_allowed_param_shift= REAL [25.0]")
      stdout.flush
      stdout.text(". Set maximum allowed change in a least-squares refined")
      stdout.text("  crystal structure refinement.")
      stdout.flush
      stdout.text(". If any one of the parameters shifts obtained from solving")
      stdout.text("  the least-squares equations is greater than this value, it")
      stdout.text("  is rescaled so that it becomes this value.")
      stdout.flush
      stdout.text(". Must be a positive value.")
      stdout.flush
      stdout.text(". Note: this cutoff is applied equally to all parameter")
      stdout.text("  types, so it is governed by the average magnitude of the")
      stdout.text("  smallest quantities, in atomic units.")
      if (present(die)) stop
   end

   read_max_allowed_param_shift ::: private
   ! Read the maximum allowed shift in a structure refinement
   ! parameter
      self :: INOUT

      stdin.read(.max_allowed_param_shift)

   ENSURE(.max_allowed_param_shift>ZERO,"not positive")

   end

   docu_max_iterations(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("max_iteration= INT [100]")
      stdout.flush
      stdout.text(". Set maximum number of iterations allowed to solve the")
      stdout.text("  least-squares equations for the crystal structure parameters.")
      stdout.flush
      stdout.text(". Must be a non-negative value.")
      stdout.flush
      stdout.text(". Must be greater than value set for min_interations=")
      if (present(die)) stop
   end

   read_max_iterations ::: private
   ! Read the maximum number of iterations
      self :: INOUT

      stdin.read(.max_iterations)

   ENSURE(.max_iterations>-1,             "max_iterations < 0 !")
   ENSURE(.max_iterations>.min_iterations,"max_iterations <= min_iterations !")

   end

   docu_max_prune_iterations(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("max_prune_iterations= INT ")
      stdout.flush
      stdout.text(". Set maximum number of iterations allowed for pruning")
      stdout.text("  *bad* reflections via the f_z_cutoff= option. An iterative")
      stdout.text("  process must be used since the scaling and extinction")
      stdout.text("  corrections must be recalculated every time some")
      stdout.text("  reflections are pruned from the data.")
      stdout.flush
      stdout.text(". Must be a positive value.")
      if (present(die)) stop
   end

   read_max_prune_iterations ::: private
   ! Read the maximum number of pruning iterations
      self :: INOUT

      stdin.read(.max_prune_iterations)

   ENSURE(.max_prune_iterations>0,"max_prune_iterations must be +ve")

   end

   docu_min_iterations(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("min_iterations= INT [2]")
      stdout.flush
      stdout.text(". Set minimum number of iterations allowed to solve the")
      stdout.text("  least-squares equations for the crystal structure parameters.")
      stdout.flush
      stdout.text(". Must be a non-negative value.")
      stdout.flush
      stdout.text(". Must be strictly less than value set for max_interations=")
      if (present(die)) stop
   end

   read_min_iterations ::: private
   ! Read the minimum number of iterations
      self :: INOUT

      stdin.read(.min_iterations)

   ENSURE(.min_iterations>-1,             "min_iterations < 0 !")
   ENSURE(.max_iterations>.min_iterations,"min_iterations >= max_iterations !")

   end

   docu_min_correlation(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("min_correlation= REAL [0.6] ")
      stdout.flush
      stdout.text(". The minimum value for the absolute value of the")
      stdout.text("  correlation matrix elements, below which they are")
      stdout.text("  not printed out in the output.")
      stdout.flush
      stdout.text(". Must be in the range (-ONE,ONE)")
      if (present(die)) stop
   end

   read_min_correlation ::: private
   ! Read the minimum number of iterations
      self :: INOUT

      stdin.read(.min_correlation)

   ENSURE(.min_correlation>=-ONE,"min_iterations < -1 !")
   ENSURE(.min_correlation<= ONE,"min_iterations > +1 !")

   end

! N

   docu_n_data_sets(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("n_data_sets= INT [1] ")
      stdout.flush
      stdout.text(". Set the number of data sets used in a multiple-")
      stdout.text("  -data-set least-squares crystal structure refinement")
      stdout.flush
      stdout.text(". The different dara sets must be assigned different")
      stdout.text("  scale group indices.")
      stdout.flush
      stdout.text(". Value must by greater than 0.")
      stdout.flush
      stdout.text(". Used to scale the residual density plots correctly")
      if (present(die)) stop
   end

   read_n_data_sets ::: private
   ! Read the no of data sets used in a multiple-data-set refinement.
      self :: INOUT

      val :: INT

      stdin.read(val)
      .SET:set_n_data_sets(val)

   end

   docu_n_param(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("n_param= INT [1] ")
      stdout.flush
      stdout.text(". Set the number of independent parameters in the least-")
      stdout.text("  squares crystal structure refinement.")
      stdout.flush
      stdout.text(". Must be a a non-negative value")
      stdout.flush
      stdout.text(". Useful in XWR calculations which do not immediately")
      stdout.text("  a Hirshfeld atom refinement, so that the GoF2 values")
      stdout.text("  at lambda=ZERO are consistent.")
      if (present(die)) stop
   end

   read_n_param ::: private
   ! Read the no of parameters for refinement explicitly.
   ! DO this if you are doing an XCW after an HAR
      self :: INOUT

      val :: INT

      stdin.read(val)
      .SET:set_n_param(val)

   end

   docu_n_worst_reflections(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("n_worst reflections= INT [40] ")
      stdout.flush
      stdout.text(". Set the number of *worst* agreeing predicted structure")
      stdout.text("  factors, F_pred, when compared to F_exp, based on the")
      stdout.text("  value of |F_pred - F_exp|/F_sigma, the Delta F_z value")
      stdout.flush
      stdout.text(". Default is 40, but may be smaller if there are very")
      stdout.text(". few reflections")
      stdout.flush
      stdout.text(". Must be a a non-negative value")
      if (present(die)) stop
   end

   read_n_worst_reflections ::: private
   ! Read the no of worst reflections to show.
      self :: INOUT

      val :: INT

      stdin.read(val)
      .SET:set_n_worst_reflections(val)

   end

! O

   docu_refine_extinction(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("optimise_extinction=")
      stdout.text("refine_extinction= BIN [FALSE] ")
      stdout.flush
      stdout.text(". Set whether to use an extinction correctgion according")
      stdout.text("  to the old Zachariasen model")
      stdout.flush
      stdout.text(". See Zachariasen  (1967) Acta Cryst. 23 p. 558; also")
      stdout.text("  Becker & Coppens (1974) Acta Cryst. A 30, p.  148")
      stdout.flush
      stdout.text(". Consider whether you really need ths option for small")
      stdout.text("  crystals, or those that do not have strongly absorbing")
      stdout.text("  atoms. It is not clear to Dylan whether such a correctiom")
      stdout.text("  interferes with path-length, or other corrections, which")
      stdout.text("  may have already been applied.")
      if (present(die)) stop
   end

   read_refine_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_refine_extinction(val)

   end

   docu_refine_scale(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("optimize_scale=")
      stdout.text("optimize_scale_factor=")
      stdout.text("optimize_scale_factors=")
      stdout.text("refine_scale=")
      stdout.text("refine_scale_factor=")
      stdout.text("refine_scale_factors= BIN [TRUE]")
      stdout.flush
      stdout.text(". Set whether to use a scale factor (or scale factors,")
      stdout.text("  associated with each reflection group index) to fit")
      stdout.text("  the calculated structure factor magnitudes |F_calc|")
      stdout.text("  to the experimentally measured structure factors, F_exp")
      if (present(die)) stop
   end

   read_refine_scale ::: private
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      self :: INOUT

      stdin.read(.refine_scale)

   end

! P

   docu_partition_model(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("partition_model= STR ")
      stdout.flush
      stdout.text(". Set the model used to partition the electron density")
      stdout.text("  into atomic or diatomic fragments in order to perform")
      stdout.text("  thermal smearing")
      stdout.flush
      stdout.text(". Allowed values are:")
      stdout.text("     - oc-hirshfeld, for one-center Hirshfeld atom partitioning")
      stdout.text("     - oc-tanaka,    for one-center Tanaka atom partitioning")
      stdout.text("     - tc-tanaka,    for two-center Tanaka atom partitioning")
      stdout.flush
      stdout.text(". See Davidson et al (2023) Acta Cryst B 72 p. 312-32")
      if (present(die)) stop
   end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      self :: INOUT

      val :: STR

      stdin.read(val)
      .SET:set_partition_model(val)

   end

   docu_put(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("put")
      stdout.flush
      stdout.text(". Output information concerning the data object to")
      stdout.text("  the output file, usually stdout")
      if (present(die)) stop
   end

   docu_put_worst_reflections(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("put_worst_reflections")
      stdout.flush
      stdout.text(". Output information concerning the *worst* or")
      stdout.text("  *most disagreeable* reflections, based on the")
      stdout.text("  magnitude of Delta F_z = |F_pred-F_exp|/F_sigma.")
      if (present(die)) stop
   end

   docu_put_sin_theta_on_lambda(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("put_sin_theta_on_lambda")
      stdout.flush
      stdout.text(". Output a table of sin(theta)/lambda for every reflection")
      stdout.flush
      stdout.text(". Ensure that wavelength= has been specified correctly")
      if (present(die)) stop
   end

   docu_put_wavelength(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("put_wavelength")
      stdout.flush
      stdout.text(". Output the wavelength of the particles used for diffraction") 
      stdout.text("  in *Angstrom* units")
      if (present(die)) stop
   end

! R

   docu_CIF(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("read_CIF STR ")
      stdout.flush
      stdout.text(". Read the name of a Crystallographic Inforemation File (CIF)")
      stdout.text("  and then oprn it and read the reflections from it.")
      stdout.flush
      stdout.text(". Note: this command has non-standard form since it expects")
      stdout.text("  additional data on the input line")
      if (present(die)) stop
   end

   docu_redirect(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("redirect STR ")
      stdout.flush
      stdout.text(". Read the name of a new input file, and start reading")
      stdout.text("  commands from it.")
      stdout.flush
      stdout.text(". Note: this command has non-standard form since it expects")
      stdout.text("  additional data on the input line; however this command")
      stdout.text("  also appears in almost every module")
      stdout.flush
      stdout.text(". See also the revert command keyword.")
      if (present(die)) stop
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   docu_refine_3rd_order(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_3rd_order= VEC{STR}@ ")
      stdout.flush
      stdout.text(". Specify the list of unique atom tags for which")
      stdout.text("  anharmonic 3rd order Gram-Charlier coefficients")
      stdout.text("  are refined.")
      stdout.flush
      stdout.text(". Anharmonic 4th order Gram-Charlier coefficients")
      stdout.text("  are *not* refined in this case.")
      stdout.flush
      stdout.text(". See also refine_4th_order=")
      if (present(die)) stop
   end

   read_refine_3rd_order ::: leaky, private
   ! Read the list of atoms for which third-order anharmonicty
   ! parameters are to be refined.
      self :: INOUT

      stdin.read_all(.refine_3rd_order_for_atom)
      .SET:set_refine_anharmonicity(TRUE)

   end

   docu_refine_4th_order(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_4th_order= VEC{STR}@ ")
      stdout.flush
      stdout.text(". Specify the list of unique atom tags for which")
      stdout.text("  anharmonic 4th order Gram-Charlier coefficients")
      stdout.text("  are refined.")
      stdout.flush
      stdout.text(". Unless otherwise cencelled, this implies that")
      stdout.text("  anharmonic 3rd order Gram-Charlier coefficients")
      stdout.text("  are also refined.")
      stdout.flush
      stdout.text(". See also refine_3rd_order=")
      if (present(die)) stop
   end

   read_refine_4th_order ::: leaky
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      self :: INOUT

      stdin.read_all(.refine_4th_order_for_atom)
      .SET:set_refine_anharmonicity(TRUE)

   end

   docu_refine_4th_order_only(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_4th_order_only= BIN [FALSE] ")
      stdout.flush
      stdout.text(". If set, and an anharmonic refinement is being performed,")
      stdout.text("  only 3rd order Gram-Charlier coefficients are refined")
      stdout.text("  for the specified atoms.")
      stdout.flush
      stdout.text(". See also refine_3rd_order=")
      if (present(die)) stop
   end

   read_refine_4th_order_only
   ! Read whether to refine 4th order coefficients only,
   ! ignoring changes to 3rd order coefficients.
   ! NOTE: it is up to you to set the ADP3s to zero.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_refine_4th_order_only(val)

   end

   docu_refine_ADPs_only(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_ADPs_only= BIN [FALSE] ")
      stdout.flush
      stdout.text(". Controls whether to refine the ADPs only in a least-")
      stdout.text("  squares  crystal structure refinement. Positions are")
      stdout.text("  not refined.")
      if (present(die)) stop
   end

   read_refine_ADPs_only
   ! Read whether to refine only the ADP's
      self :: INOUT

      stdin.read(.refine_ADPs_only)

   end

   docu_refine_anharmonicity(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_anharmonicity= BIN [FALSE] ")
      stdout.flush
      stdout.text(". Controls whether an anharmonic refinement is performed.")
      stdout.flush
      stdout.text("  This option is best used to cancel an anharmonic refinement.")
      stdout.flush
      stdout.text(". See also:")
      stdout.text("     refine_3rd_order=")
      stdout.text("     refine_4th_order=")
      stdout.text("  which also activates this switch.")
      if (present(die)) stop
   end

   read_refine_anharmonicity
   ! Read whether to refine anharmonicity
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_refine_anharmonicity(val)

   end

   docu_refine_F(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_F= BIN [TRUE] ")
      stdout.flush
      stdout.text(". Set whether to refine on structure factors magnitudes")
      stdout.text("  F_exp rather than squared structure factors, I_exp.")
      stdout.flush
      stdout.text(". WARNING: currently, setting this option FALSE does")
      stdout.text(". not work.")
      if (present(die)) stop
   end

   read_refine_F
   ! Read in whether to refine F's instead of I's
      self :: INOUT

      stdin.read(.refine_F)

   end

   docu_refine_H_ADPs_only(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_h_adps=")
      stdout.text("refine_h_adps_only= BIN [FALSE] ")
      stdout.flush
      stdout.text(". If set, only the H atom ADPs are refined in a")
      stdout.text("  crystal structure refinement, nothing else.")
      if (present(die)) stop
   end

   read_refine_H_ADPs
   ! Read whether to refine only the H atom ADP's
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_refine_H_ADPs(val)

   end

   docu_refine_H_positions_only(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_h_positions=")
      stdout.text("refine_h_positions_only= BIN [FALSE] ")
      stdout.flush
      stdout.text(". If set, only the H atom positions are refined in a")
      stdout.text("  crystal structure refinement, nothing else.")
      if (present(die)) stop
   end

   read_refine_H_positions
   ! Read whether to refine only the H atom positions
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_refine_H_positions(val)

   end

   docu_refine_nothing_for_atoms(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_nothing_for_atoms= VEC{STR}@")
      stdout.flush
      stdout.text(". Specify the list of unique atom tags for which *no*")
      stdout.text("  crystal structure parameter is refined.")
      stdout.flush
      stdout.text(". This option is best used to *modify* previous options.")
      if (present(die)) stop
   end

   read_refine_nothing_for_atoms ::: leaky
   ! Read the list of atoms for which no parameter is refined.
      self :: INOUT
      stdin.read_all(.refine_nothing_for_atom)
   end

   docu_refine_positions_only(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_positions_only= BIN [FALSE] ")
      stdout.flush
      stdout.text(". If set, only atom positions are refined in a")
      stdout.text("  crystal structure refinement, nothing else.")
      if (present(die)) stop
   end

   read_refine_positions_only
   ! Read whether to refine only the atom positions
      self :: INOUT

      stdin.read(.refine_positions_only)

   end

   docu_refine_H_U_iso(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_h_u_iso= BIN [FALSE] ")
      stdout.flush
      stdout.text(". If set, refine hydrogen atoms using isotropic ADPs.")
      if (present(die)) stop
   end

   read_refine_H_U_iso
   ! Read whether to refine only the H atom U_iso's
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_refine_H_U_iso(val)

   end

   docu_refine_U_iso_for_atoms(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("refine_u_iso_for_atoms= VEC{STR}@ [FALSE] ")
      stdout.flush
      stdout.text(". Specify the list of unique atom tags for which")
      stdout.text("  to refine isotropic ADPs.")
      stdout.flush
      stdout.text(". This option is best used to *modify* previous options.")
      if (present(die)) stop
   end

   read_refine_U_iso_for_atoms ::: leaky
   ! Read the list of atoms refined isotropically
      self :: INOUT
      stdin.read_all(.refine_U_iso_for_atom)
   end

   docu_revert(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("revert")
      stdout.flush
      stdout.text(". Stop reading the input file, return to the previous")
      stdout.text("  input file, and continue reading from immediately")
      stdout.text("  after the redirect keyword")
      stdout.flush
      stdout.text(". It is an error if there was not a previous input file")
      stdout.text("  in which a redirect command keyword appeared.")
      if (present(die)) stop
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   docu_reflection_data(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("reflection_data= VEC{REFLECTION}@  ")
      stdout.flush
      stdout.text(". The diffraction data")
      if (present(die)) stop
   end

   read_reflection_data ::: leaky, private
   ! Read in reflection data in the standard order from "stdin".
      self :: INOUT

   DIE_IF(.wavelength<ZERO,"specify wavelength for radiation before reflection_data!")

      if (.reflections.allocated) .reflections.destroy
      .reflections.read_list_keywords

   end

   docu_remove_disp_from_F_exp(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("remove_disp_from_f_exp= BIN")
      stdout.flush
      stdout.text(". Set if you want to remove atom-based anomalous dispersion")
      stdout.text("  from the experimental structure factors, F_exp")
      stdout.flush
      stdout.text(". WARNING: this option is not working. Does anyone want")
      stdout.text("  to fix it? Dylan does not, particularly")
      if (present(die)) stop
   end

   read_remove_disp_from_F_exp ::: private
   ! Read whether to add dispersion to F_calc.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_remove_disp_from_F_exp(val)

   DIE_IF(.add_dispersion_to_F_calc,"you already asked to add dispersion to F_calc!")

   end

   docu_restart_with_promolecule(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("restart_with_promolecule= BIN")
      stdout.flush
      stdout.text(". If set this will restart the SCF procedure in a")
      stdout.text("  a HAR, or fragHAR refinement with a promolecule")
      stdout.text("  guess, either with MOs or density_matrix, as was")
      stdout.text("  set by you. If you do not use this option, the")
      stdout.text("  the density matrix from a previous iteration is used.")
      stdout.flush
      stdout.text(". This option may aid convergence when cluster")
      stdout.text("  charges are used; but in this case, there may be")
      stdout.text("  other issues causing the convergene problems.")
      if (present(die)) stop
   end

   read_restart_with_promolecule ::: leaky
   ! Read whether to restart with promolecule initial guess.
      self :: INOUT

      stdin.read(.restart_HAR_with_promolecule)

   end

! S

   docu_SF_mixing_parameter(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("sf_mixing_parameter= REAL")
      stdout.flush
      stdout.text(". Read the SF mixing parameter, which resets the")
      stdout.text("  predicted structure factors F_pred to include")
      stdout.text("  the specified fraction of the experimental")
      stdout.text("  structure factors")
      stdout.flush
      stdout.text(". It was thought at some point that this might help")
      stdout.text(". convergence of X-ray constrained wavefunction calculations.")
      if (present(die)) stop
   end

   read_SF_mixing_parameter ::: privateo
   ! Read the SF mixining parameter which inlcudes some percentage of
   ! the experimental structure factors into the predicted structure
   ! factors. This may help convergence in constrained HF problems.
      self :: INOUT

      stdin.read(.SF_mixing_parameter)

   end

   docu_show_fit_output(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_fit_output= BIN")
      stdout.flush
      stdout.text(". Set TRUE if the fit statistics from *every* cycle of")
      stdout.text("  a rigid Hirshfeld atom least-squares structure")
      stdout.text("  refinement should be displayed.")
      stdout.flush
      stdout.text(". See also show_fit_results=")
      stdout.flush
      stdout.text(". Note: the output may look very corrupted if this option")
      stdout.text("  is set during a HAR or similar refinement. It is intended")
      stdout.text("  to hide IAM or other LSQ fit cycles, for testing, or in")
      stdout.text("  HAR, for debugging purposes only.")
      if (present(die)) stop
   end

   read_show_fit_output ::: private
   ! Read whether to show the fit output (including fit results)
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_show_fit_output(val)

   end

   docu_show_fit_results(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_fit_results= BIN [TRUE]")
      stdout.flush
      stdout.text(". Set TRUE if *only* the fit statistics from a rigid Hirshfeld")
      stdout.text("  atom least-squares structure refinement should be displayed.")
      stdout.flush
      stdout.text(". See also show_fit_output=")
      stdout.flush
      stdout.text(". Note: the output may look very corrupted if this option")
      stdout.text("  is set during a HAR or similar refinement. It is intended")
      stdout.text("  to hide IAM or other LSQ fit cycles, for testing, or in")
      stdout.text("  HAR, for debugging purposes only.")
      if (present(die)) stop
   end

   read_show_fit_results ::: private
   ! Read whether to show the fit results, without parameters
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_show_fit_results(val)

   end

   docu_show_ref_output(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_refinement_output= BIN")
      stdout.flush
      stdout.text(". Set TRUE if the refinement statistics from *every* cycle of")
      stdout.text("  of a Hirshfeld atom refinement (HAR) should be displayed.")
      stdout.flush
      stdout.text(". See also show_refinement_results=")
      stdout.text(". See also show_refinement_output=")
      if (present(die)) stop
   end

   read_show_ref_output ::: private
   ! Read whether to show any refinement output
   ! (including refinement results)
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_show_refinement_output(val)

   end

   docu_show_ref_results(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_refinement_results= BIN [TRUE]")
      stdout.flush
      stdout.text(". Set TRUE if *only* a the refinement statistics from a")
      stdout.text("  Hirshfeld atom refinement (HAR) should be displayed.")
      stdout.flush
      stdout.text(". See also show_refinement_output=")
      if (present(die)) stop
   end

   read_show_ref_results::: private
   ! Read whether to show the refinement results, without parameters
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_show_refinement_results(val)

   end

   docu_show_rejects(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("show_rejects= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set TRUE if you want to see a list of the rejected")
      stdout.text("  reflections when pruning reflections from a data set.")
      stdout.text("  Normally only the *number* of rejects is reported.")
      stdout.flush
      stdout.text(". Note: Once reflections are rejected, they are no longer")
      stdout.text("  available within the program. Keep your input files.")
      if (present(die)) stop
   end

   read_show_rejects ::: private
   ! Read whether to show the rejected reflections
      self :: INOUT

      stdin.read(.show_rejects)

   end

   docu_stl_high_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("stl_high_cutoff= REAL")
      stdout.flush
      stdout.text(". Reflections with sin(theta)/lambda *larger* than the")
      stdout.text("  value set for this cutoff are pruned from the data.")
      stdout.flush
      stdout.text(". Note: atomic units are used unless specified otherwise")
      stdout.text("  on the input line.")
      stdout.flush
      stdout.text(". Must be a non-negatve value.")
      stdout.flush
      stdout.text(". Must have set the wavelength= for the reflection data.")
      if (present(die)) stop
   end

   read_stl_high_cutoff ::: private
   ! Read the stl_cutoff for prune_high_angle_reflections
      self :: INOUT

      stdin.read_quantity(.stl_high_cutoff)

      ENSURE(.stl_high_cutoff>=ZERO,"must be positive")

   end

   docu_stl_low_cutoff(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("stl_low_cutoff= REAL")
      stdout.flush
      stdout.text(". Reflections with sin(theta)/lambda *smaller* than the")
      stdout.text("  value set for this cutoff are pruned from the data.")
      stdout.flush
      stdout.text(". Note: atomic units are used unless specified otherwise")
      stdout.text("  on the input line.")
      stdout.flush
      stdout.text(". Must be a non-negatve value.")
      stdout.flush
      stdout.text(". Must have set the wavelength= for the reflection data.")
      if (present(die)) stop
   end

   read_stl_low_cutoff ::: private
   ! Read the stl_cutoff for prune_low_angle_reflections
      self :: INOUT

      stdin.read_quantity(.stl_low_cutoff)

      ENSURE(.stl_low_cutoff>=ZERO,"must be positive")

   end

   docu_stl_limit(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("stl_limit= REAL")
      stdout.flush
      stdout.text(". All reflections with a value of sin(theta)/lambda")
      stdout.text("  less than this value are generated, for the purposes")
      stdout.text("  of obtaining calculated structure fac tors, |F_calc|")
      stdout.flush
      stdout.text(". Note: atomic units are used unless specified otherwise")
      stdout.text("  on the input line.")
      stdout.flush
      stdout.text(". Must be a pisitive value.")
      stdout.flush
      stdout.text(". Must have set the wavelength= for the reflection data.")
      if (present(die)) stop
   end

   read_stl_limit
   ! Read in the stl limit for generating (h k l)
      self :: INOUT

      stdin.read_quantity(.stl_limit)

      ENSURE(.stl_limit>ZERO,"must be +ve!")

   end

! T

   docu_temperature_factor_model(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN

      stdout.flush
      stdout.flush
      stdout.text("thermal_smearing_model= ")
      stdout.text("temperature_factor_model= STR")
      stdout.flush
      stdout.text(". Specify the ADP model to be used to calculate the")
      stdout.text("  anisotropic Debye-Waller factors for producing dynamic")
      stdout.text("  or thermally smeared structure factors")
      stdout.flush
      stdout.text(". Allowed values are:")
      stdout.text("     - none")
      stdout.text("       ... for static structure factors;")
      stdout.text("     - one-center")
      stdout.text("       atom-based")
      stdout.text("       ... for one-center models;")
      stdout.text("     - tc-coppens")
      stdout.text("       tc-stewart")
      stdout.text("       tc-tanaka")
      stdout.text("       ... for two-center based models")
      stdout.flush
      stdout.text(". See Davidson et al (2023) Acta Cryst B 72 p. 312-32")

      if (present(die)) stop

   end

   read_temperature_factor_model ::: private
   ! Read the temperature factor model to use to correct for thermal
   ! vibration in the calculated structure factors
      self :: INOUT

      val :: STR

      stdin.read(val)
      .SET:set_temperature_factor_model(val)

   end

   docu_tol_for_shift_on_esd(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("tol_for_shift_on_esd= REAL [0.01]")
      stdout.flush
      stdout.text(". Tolerance for the largest change in any least-squares")
      stdout.text("  -refined structural parameter, divided by its estimated")
      stdout.text("  standard uncertainly (ESU), such that convergence of the")
      stdout.text("  iterative LSQ procedure is regarded to have occured.")
      if (present(die)) stop
   end

   read_tol_for_shift_on_esd
   ! Read the tolerance for the shift on esd to decide on convergence.
      self :: INOUT

      stdin.read(.tol_for_shift_on_esd)

   ENSURE(.tol_for_shift_on_esd>ZERO,"must be positive")

   end

   docu_near_0_tol(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("near_0_tol= REAL [0.001]")
      stdout.text("tol_near_0= REAL [0.001]")
      stdout.flush
      stdout.text(". Specifies the absolute value for eigenvalues of the")
      stdout.text("  least-squares matrix *below* which the corresponding")
      stdout.text("  eigenvectors are regarded to describe linear dependencies.")
      stdout.text("  These linear dependencies are removed when solving")
      stdout.text("  the least-squares equations for crystal structure parameters.")
      stdout.flush
      stdout.text(". Must be a positive quantity.")
      if (present(die)) stop
   end

   read_near_0_tol
   ! Read the tolerance for deciding on *near* zero eigenvalues in
   ! solving the normal equations.
      self :: INOUT

      stdin.read(.near_0_tol)

   ENSURE(.near_0_tol>ZERO,"near_0_tol must be positive")

   end

! U

   docu_use_disk_SFs(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("use_disk_SFs= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set if you want the atomic form factors to be written")
      stdout.text("  out onto the disk, instead of being stored in memory.")
      stdout.text("  This drastically reduced memory usage for a HAR")
      stdout.text("  but at (possible) cost of slowing the calculation.")
      stdout.flush
      stdout.text(". This option is set by default for fragHAR refinements")
      stdout.flush
      stdout.text(". See Bergman et al (2020) IUCrJ 7 p. 1-8.")
      if (present(die)) stop
   end

   read_use_disk_SFs ::: leaky, private
   ! Read whether to use disk structure factors.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_use_disk_SFs(val)

   end

   docu_use_equivalents(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("use_disk_SFs= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set if you want to *keep* equivalent reflections.")
      stdout.text("  If you do *not* set this TRUE, equivalent reflections")
      stdout.text("  will be deleted.")
      stdout.flush
      stdout.text(". IMPORTANT: Tonto requires a  symmetry independent set")
      stdout.text("  of reflections.")
      stdout.flush
      stdout.text(". Friedel pairs may or may not be present; if you are")
      stdout.text("  using dispersion corrections, you had better have")
      stdout.text("  Friedel pairs in you set of reflections!")
      if (present(die)) stop
   end

   read_use_equivalents ::: leaky, private
   ! Read whether to keep equivalent reflections in the data set. 
   ! Normally symmetry-equivalent reflections will be pruned out.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_use_equivalents(val)

   end

   docu_use_Ryde_capping(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("use_Ryde_capping= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set TRUE if you want to use the Ulf Ryde method")
      stdout.text("  for breaking up proteins into H-atom-capped")
      stdout.text("  fragments, for the purpose of efficiently obtaining")
      stdout.text("  aspherical atomic form factors, the fragHAR procedure.")
      stdout.flush
      stdout.text(". This option is set by default for fragHAR_refinement")
      stdout.flush
      stdout.text(". See Bergman et al (2020) IUCrJ 7 p. 1-8.")
      if (present(die)) stop
   end

   read_use_Ryde_capping ::: leaky, private
   ! Read whether to use Ulf Ryde's capping method to split and cap
   ! polypeptides to make wavefunction and atomic structure factor
   ! calculations for proteins quicker.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_use_Ryde_capping(val)

   end

   docu_use_text_SFs(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("use_text_SFs= BIN [FALSE]")
      stdout.flush
      stdout.text(". Set if you want the atomic form factors to be written")
      stdout.text("  out onto the disk in *text* or ASCII format, instead of")
      stdout.text("  being stored in memory.")
      stdout.flush
      stdout.text(". This option sets use_disk_SFs=")
      stdout.flush
      stdout.text(". This option is set by default for fragHAR refinements")
      stdout.flush
      stdout.text(". See Bergman et al (2020) IUCrJ 7 p. 1-8.")
      if (present(die)) stop
   end

   read_use_text_SFs ::: leaky, private
   ! Read whether to use disk structure factors in ASCII format.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_use_text_SFs(val)

   end

   docu_wavelength(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("wavelength= REAL ")
      stdout.flush
      stdout.text(". Set the wavelength of the particles used for diffraction.")
      stdout.text("  Do not forget to specify the units.")
      stdout.flush
      stdout.text(". You must specify this quantity for sensible plane spacings")
      stdout.text("  or for sensible pruning.")
      if (present(die)) stop
   end

! U

   read_wavelength ::: private
   ! Read the experimental wavelength
      self :: INOUT

      val :: REAL

      stdin.read_quantity(val)
      .SET:set_wavelength(val)

   end

! Undocumented so far ...

   read_synthesize_sigma_I ::: private
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      self :: INOUT

      stdin.read(.synthesize_sigma_I)

   end

   read_stop_after_dispersion ::: private
   ! Stop after applying dispersion correction in the zeroth iteration
   ! of a refinement.
      self :: INOUT

      stdin.read(.stop_after_dispersion)

   end

   read_temperature
   ! Read the temperature
      self :: INOUT

      stdin.read(.temperature)

   ENSURE(.temperature>=0,"temperature is not positive!")

   end

!   read_NKA_T_seq_no
!   ! Read the temperature sequence no for NKA output file
!      self :: INOUT
!
!      stdin.read(.NKA_T_sequence_no)
!
!   ENSURE(.NKA_T_sequence_no>0,"sequence no is not positive!")
!
!   end

   read_use_Voronoi_atoms
   ! Read whether to use Voronoi atoms in refinement
      self :: INOUT
      stdin.read(.use_Voronoi_atoms)
   end

   read_use_KM_atoms
   ! Read whether to use KM atom density in refinement
      self :: INOUT
      stdin.read(.use_KM_atoms)
   end

   read_use_IAM_density
   ! Read whether to IAM density, either tabulated or
   ! from the existing atomic density matrix.
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .SET:set_use_IAM_density(val) ! NOTE: use IAM form factors by default

   end

   read_use_IAM_ITC_FFs
   ! Read whether to use International Tables C form factors.
   ! If set FALSE, then the existing atomic density is used.
      self :: INOUT

      val :: BIN

      stdin.read(.use_IAM_ITC_FFs)
      .SET:set_use_IAM_ITC_FFs(val)

   end

   read_use_zero_overlap
   ! Read whether to use KM density in refinement
      self :: INOUT
      stdin.read(.use_zero_overlap)
   end

! ========
! Read CIF
! ========

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File
   ! with the "name" taken from stdin.
      self :: INOUT

      name :: STR
      found :: BIN
      cif :: CIF@

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .READ:read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      self :: INOUT
      cif :: CIF, INOUT
       
      if (NOT cif.is_mmCIF) then
         .READ:read_smCIF(cif)
      else
         .READ:read_mmCIF(cif)
      end

   end

   read_smCIF(cif) ::: leaky
   ! Read information from a small-molecule Crystallographic
   ! Information File "cif".
      self :: INOUT
      cif :: CIF, INOUT

      there :: BIN
      sval :: STR
      ival :: INT
      rval :: REAL

      ! Read reflections
      .reflections.read_CIF(cif)

      ! First prune I's and define F's
      if (.INQ:have_I_exp) then
         DIE_IF(NOT .INQ:have_nonzero_I_sigma,"I_exp present but no I_sigma?")
         .SET:prune_small_I_sigmas
         .reflections.reset_I_exp_I_sigma
      end

      ! Next prune F's
      if (.INQ:have_F_exp) then
         DIE_IF(NOT .INQ:have_nonzero_F_sigma,"F_exp present but no F_sigma?")
         .SET:prune_small_F_sigmas
         .reflections.reset_F_exp_F_sigma
      end

      ! Is there a wavelength in the CIF?
      cif.find_item("_diffrn_radiation_wavelength",there)

      ! If there, read wavelength and override existing
      if (there) then
      cif.read_item("_diffrn_radiation_wavelength",rval)
      rval = rval*BOHR_PER_ANGSTROM
      .SET:set_wavelength(rval)
      end

      ! Read no of parameters
      cif.find_item("_refine_ls_number_parameters",there)
      if (there) then
      cif.read_item("_refine_ls_number_parameters",ival)
      .SET:set_n_param(ival)
      end

      ! Read extinction
      cif.find_item("_refine_ls_extinction_method",there)
      if (there) then
      cif.read_item("_refine_ls_number_parameters",sval)
      if (sval=="none") .SET:set_refine_extinction(FALSE)
      end

      ! Read XCW
      cif.find_item("_refine_QCr_Psi_constraint",there)
      if (there) then
      cif.read_item("_refine_QCr_Psi_constraint",sval)
      if (sval=="lambda*chi2") .SET:set_XCW(TRUE)
      end


   end

   read_mmCIF(cif) ::: leaky
   ! Read information from a macromolecular Crystallographic
   ! Information File "cif".
      self :: INOUT
      cif :: CIF, INOUT

      there :: BIN
      rval :: REAL


      ! Read reflections
      .reflections.read_CIF(cif)

      ! First prune I's and define F's
      if (.INQ:have_I_exp) then
         DIE_IF(NOT .INQ:have_nonzero_I_sigma,"I_exp present but no I_sigma?")
         .SET:prune_small_I_sigmas
         .reflections.reset_I_exp_I_sigma
      end

      ! Next prune F's
      if (.INQ:have_F_exp) then
         DIE_IF(NOT .INQ:have_nonzero_F_sigma,"F_exp present but no F_sigma?")
         .SET:prune_small_F_sigmas
         .reflections.reset_F_exp_F_sigma
      end

      ! Is there a wavelength in the CIF?
      cif.find_item("_diffrn.radiation_wavelength",there)

      ! If there, read wavelength and override existing
      if (there) then
      cif.read_item("_diffrn.radiation_wavelength",rval)
      rval = rval*BOHR_PER_ANGSTROM
      .SET:set_wavelength(rval)
      end

   end

end
