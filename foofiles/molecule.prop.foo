!===============================================================================
!
! MOLECULE.PROP: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.prop.foo $
!===============================================================================

module MOLECULE.PROP

   implicit none

contains

!  ===========
!  Frequencies
!  ===========

   read_force_constants ::: leaky
   ! Read the force constants as a flat vector in atomic units.
   ! SInce it is a symmetric matrix the order does not matter.

      fc :: VEC{REAL}*

      ! Read
      stdin.read_ptr(fc)

      ! Set ... leaky
      .BASE:set_force_constants(fc)

      ! Clean
      fc.destroy

   end

   normal_mode_analysis ::: leaky
   ! Make the normal modes
   ENSURE(.force_constants.associated,"no force constants")
   ENSURE(.atom.associated,"no atoms")

      n3n,i,j :: INT
      fc :: MAT{REAL}*
      rm :: VEC{REAL}*
      rmi,rmj :: REAL

      n3n = 3*.atom.dim

      ! Clean
      .normal_mode_eigenvectors.destroy
      .normal_mode_eigenvalues.destroy

      ! Allocate
      .normal_mode_eigenvalues.create(n3n)
      .normal_mode_eigenvectors.create(n3n,n3n)

      fc.create(n3n,n3n)
      rm.create(n3n)

      ! Masses in au ... *not* AMU
      rm = .atom.displacement_mass_vector * MASS_OF_ELECTRON_PER_AMU
      rm = ONE/sqrt(rm)

      ! Mass weight
      do i = 1,n3n
         rmi = rm(i)
         do j = 1,n3n
            rmj = rm(j)
            fc(i,j) = rmi * .force_constants(i,j) * rmj
         end
      end

      ! Get modes
      fc.solve_symmetric_eigenproblem(.normal_mode_eigenvalues,.normal_mode_eigenvectors)

      ! Clean
      rm.destroy
      fc.destroy

   end

   put_normal_modes
   ! Put the force constants and normal modes
   ENSURE(.normal_mode_eigenvectors.associated,"no normal mode eigenvectors")
   ENSURE(.normal_mode_eigenvalues.associated, "no normal mode eigenvalues")

      table :: VEC{TABLE_COLUMN}*
      eval :: VEC{REAL}*
      ewav :: VEC{STR}*
      n3n,i :: INT


      stdout.flush
      stdout.text("=========================")
      stdout.text("Cartesian force constants")
      stdout.text("=========================")
      stdout.flush

      n3n = 3*.atom.dim
      stdout.show("No. of atoms        =",n3n/3)
      stdout.show("No. of displacement =",n3n)
      stdout.flush
      stdout.put(.force_constants)

      stdout.flush
      stdout.text("Mass vector:")
      stdout.flush
      stdout.put(.atom(:).mass)

      stdout.flush
      stdout.text("========================")
      stdout.text("Normal mode eigenvectors")
      stdout.text("========================")
      stdout.flush
      stdout.text(". Eigenvalues are in cm^-1")
      stdout.text(". Eigenvectors in mass-weighted atomic units (not AMUs)")
      stdout.flush
      stdout.show("cm^-1 per Hartree     =",WAVENUMBER_PER_HARTREE)
      stdout.show("Electron mass per AMU =",MASS_OF_ELECTRON_PER_AMU)
      stdout.flush

      ! Table headings
      ewav.create(n3n)
      eval.create(n3n)
      eval = .normal_mode_eigenvalues
      eval = sqrt(abs(eval)) * WAVENUMBER_PER_HARTREE
      ewav = eval.to_str(stdout.real_style,stdout.real_width,stdout.real_precision)
      eval.destroy

      ! Set table data
      table.create(n3n)
      do i = 1,n3n
         table(i).set_heading(trim(ewav(i)))
         table(i).set_values(.normal_mode_eigenvectors(:,i))
      end

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      ewav.destroy

   end

   put_dnc_displaced_geometries
   ! Put the dimensionless normal coordinate displced geometries
   ! used for evaluating the phi constants force constants.
   ! See Schneider and Thiel (1989) CPL 157 p. 367.
   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.dim==1, "must have more than one atom")

      qtox :: MAT{REAL}*
      m12,g12,geom0,delta :: VEC{REAL}*
      n_modes,n3n,f,l,i,s :: INT
      step :: REAL

      ! Ensure modes are there
      if (.normal_mode_eigenvectors.disassociated) .:normal_mode_analysis

      ! Step size
      step = .phi_step_size

      ! Starting mode & no of modes
      n3n = 3*.atom.dim
      l = n3n
      f = 7
      if (.atom.is_linear) f = 6
      n_modes = l - f + 1

      ! Make the dimensionless normal coordinates
      qtox.create(n3n,n_modes)
      m12.create(n3n)
      g12.create(n_modes)
      g12 = ONE/sqrt(sqrt(.normal_mode_eigenvalues(f:l)))
      m12 = .atom.displacement_mass_vector * MASS_OF_ELECTRON_PER_AMU
      m12 = ONE/sqrt(m12)
      .normal_mode_eigenvectors.change_basis_to(qtox,m12,g12)
      m12.destroy
      g12.destroy

      stdout.flush
      stdout.text("================================")
      stdout.text("Dimensionless normal coordinates")
      stdout.text("================================")
      stdout.flush
      stdout.text("The columns correspoind to the non-zero modes")
      stdout.text("assuming that the geometry is a minimum")
      stdout.flush
      stdout.show("No. of atoms        =",n3n/3)
      stdout.show("No. of displacement =",n3n)
      stdout.show("No. of modes        =",n_modes)
      stdout.flush
      stdout.put(qtox)

      stdout.flush
      stdout.text("========================================================")
      stdout.text("Displaced normal coordinate geometries for Phi constants")
      stdout.text("========================================================")

      geom0.create(n3n)
      delta.create(n3n)

      stdout.flush
      stdout.text("Undisplaced (reference) geometry")

      .atom.put_coordinate_vector_to(geom0)
      .atom.put_coordinates

      do i = f,l
      do s = -1,1,2

         stdout.flush
         stdout.show("Displacement mode      = ",i)
         stdout.show("Displacement mode sign = ",s)
         delta = geom0 + s*step*qtox(:,i)

         .atom.set_positions_from_vector(delta)
         .atom.put_coordinates

      end
      end

      ! Clean
      delta.destroy
      geom0.destroy

   end


!  =======================
!  One electron properties
!  =======================

   put_1e_properties ::: leaky
   ! Put all the available one elctron properties
      self :: INOUT

   ENSURE(.density_matrix.allocated,"no density")
   ENSURE(.atom.associated,"no atoms")
   ENSURE(.basis.associated,"no basis sets specified")

      ! Make the density matrix (leaky)
      .BASE:make_ao_density_matrix

      ! Mulliken analysis (leaky)
      .:put_mulliken_populations
      .:put_Mayer_bond_indices

      ! Moments
      .:put_dipole
      .:put_quadrupole
      .:put_octupole

      ! Atomic charges & moments
      .:put_Hirshfeld_atom_info

      ! Fields and field gradients
      .:put_E_field_at_nuclei
      .:put_EFG_at_nuclei

      ! Standard plots

      ! Clean up leak here
      .BASE:delete_atom_scf_archives

   end

   put_1e_properties_with_KM ::: leaky
   ! Put all the available one elctron properties
      self :: INOUT

   ENSURE(.density_matrix.allocated,"no density")
   ENSURE(.atom.associated,"no atoms")
   ENSURE(.basis.associated,"no basis sets specified")

      ! Make the density matrix (leaky)
      .BASE:make_ao_density_matrix

      ! Mulliken analysis (leaky)
      .:put_mulliken_populations

      ! Moments
      .:put_dipole
      .:put_quadrupole
      .:put_octupole

      ! New charges
      .:put_KM_atom_multipoles

      ! Atomic charges & moments
      .:put_Hirshfeld_atom_info

      ! Fields and field gradients
      .:put_E_field_at_nuclei
      .:put_EFG_at_nuclei

      ! Standard plots

      ! Clean up leak here
      .BASE:delete_atom_scf_archives

   end

   put_1e_properties_for_groups ::: leaky
   ! Put all the one electron properties for each group
      self :: INOUT

   ENSURE(.density_matrix.allocated,"no density")
   ENSURE(.atom.associated,"no atoms")
   ENSURE(.basis.associated,"no basis sets specified")
   ENSURE(.atom_group.associated,"no atom_groups")

      g :: INT

      .SCF:make_ANO_data

      .BASE:finalize_atom_groups

      do g = 1,.atom_group.dim

         stdout.flush
         stdout.text("======================")
         stdout.text("Properties for group "//trim(g.to_str))
         stdout.text("======================")
         stdout.flush

         .atom_group(g).mol.:put_1e_properties

      end

   end

!  Mayer bond indices

   put_Mayer_bond_indices ::: leaky
   ! Write out the Mayer bond indices
      self :: INOUT

   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.restricted.allocated,"only for restricted densities")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      a,b,fa,la,fb,lb :: INT
      PD, Q,Z,V,F :: VEC{REAL}*
      PS,BO :: MAT{REAL}*
      pair :: MAT{INT}*
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,bAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(ROBY_BOND_RANGE_FACTOR)
      if (no_of_bonds<1) return

      if (.scfdata.created) then
      if (.scfdata.spinorbital_kind/="restricted") then
         return ! Do not do for anything but restricted for now
      end
      end

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Overlap matrix (leaky)
      .INTS:make_overlap_matrix

      ! Restricted Mulliken matrix
      PS.create(.n_bf,.n_bf)
      PS.to_product_of(.density_matrix.restricted,.overlap_matrix)

      ! Mulliken diagonal populations
      PD.create(.n_bf)
      PS.put_diagonal_to(PD)
      
      ! Bond orders etc.
      BO.create(.n_atom,.n_atom)
      Q.create(.n_atom)
      Z.create(.n_atom)
      V.create(.n_atom)
      F.create(.n_atom)

      do a = 1,.n_atom

         fa = .first_basis_fn_for_atom(a)
         la =  .last_basis_fn_for_atom(a)

         ! Mullken population & charge
         Q(a) = sum(PD(fa:la))
         Z(a) = -Q(a) + .atom(a).nuclear_charge

         ! Bond orders
         do b = 1,.n_atom

            fb = .first_basis_fn_for_atom(b)
            lb =  .last_basis_fn_for_atom(b)

            BO(a,b) = PS(fa:la,fb:lb).trace_product_with(PS(fb:lb,fa:la))

         end

         ! Valences
         V(a) = TWO*Q(a) - BO(a,a)

         ! Make free valences
         F(a) = V(a)
         do b = 1,.n_atom
            if (b/=a) then
               F(a) = F(a) - BO(a,b)
            end
         end

      end

      ! Title
      stdout.flush
      stdout.text("=========================================")
      stdout.text("Mayer populations, valences & bond orders")
      stdout.text("=========================================")

      stdout.flush
      stdout.text(". These bond indices and valences are defined in:")
      stdout.text("  Mayer (1986) Int. J. QUantum Chem. 29 p 477-83.")
      stdout.flush
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD).")

      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)

      stdout.flush

      ! Create table
      table.create(5)
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      table(2).set_heading("Mulliken")
      table(2).set_subhead("Pop")
      table(3).set_heading("Charge")
      table(4).set_heading("  Mayer")
      table(4).set_subhead("Valence")
      table(5).set_heading("   Free")
      table(5).set_subhead("Valence")

      ! Set data
      labels.create(.n_atom,1)
      labels(:,1) = .atom(:).tag
      table(1).set_values(labels(:,1))
      table(2).set_values(Q)
      table(3).set_values(Z)
      table(4).set_values(V)
      table(5).set_values(F)

      ! Put
      table.put(label_rows=FALSE)

      ! Clean
      labels.destroy
      table.clear_columns
      table.destroy



      ! Put bond indices
      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.atom.chemical_symbols)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(.atom(:).tag)

      table(5).set_column_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/Angs.")
      table(7).set_width_from(ONE)

      table(8).set_heading(" Bond")
      table(8).set_subhead("order")
      table(8).set_width_from(TEN)

      ! Put out the headings
      stdout.flush
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,ROBY_BOND_RANGE_FACTOR)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         bAB.create(n_bonds)
         do i = 1,n_bonds
         bAB(i) = BO(pair(i,1),pair(i,2))
         end

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         table(7).set_values(dist)
         table(8).set_values(bAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         bAB.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

      F.destroy
      V.destroy
      Q.destroy
      BO.destroy
      PD.destroy
      PS.destroy

   end

!  Mulliken populations

   put_mulliken_populations ::: leaky
   ! sets the mulliken population matrix and the outputs it.
      mulliken_matrix, density :: MAT{REAL}*
      diagonals :: VEC{REAL}*
      S2 :: MAT{REAL}*
      mulliken_matrix2 :: MAT{CPX}*
      diagonals2 :: VEC{CPX}*

      ! Create space
      mulliken_matrix.create(.n_bf, .n_bf)
      diagonals.create(.n_bf)

      ! Overlap matrix (leaky)
      .INTS:make_overlap_matrix

      ! general complex case (LBxxx)
      if (.density_matrix.is_allocated_with_genre("general_complex")) then

         ! these objects are twice as large as usually
         S2.create(2*.n_bf,2*.n_bf)
         mulliken_matrix2.create(2*.n_bf,2*.n_bf)
         diagonals2.create(2*.n_bf)

         mulliken_matrix2 = (ZERO,ZERO)
         diagonals2 = (ZERO,ZERO)
         S2 = ZERO
         S2.alpha_alpha_set_to(.overlap_matrix)
         S2.beta_beta_set_to(.overlap_matrix)

         stdout.flush
         stdout.text(" These are the GCHF Mulliken populations! ")

         ! fill the general_complex mulliken matrix and diagonals
         mulliken_matrix2.to_product_of(.density_matrix.general_complex,S2)
         mulliken_matrix2.put_diagonal_to(diagonals2)

         ! Make use of the restricted mulliken matrix
         diagonals = REALIFY(diagonals2(1:.n_bf)) + REALIFY(diagonals2(.n_bf+1:2*.n_bf))
         mulliken_matrix = REALIFY(mulliken_matrix2(1:.n_bf,1:.n_bf)) +  &
                           REALIFY(mulliken_matrix2(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf))

         ! Put the atomic populations
         .:put_mulliken_populations(mulliken_matrix, diagonals)

         mulliken_matrix2.destroy
         diagonals2.destroy
         S2.destroy

         stdout.flush
         stdout.text(" These are the GCHF Mulliken spin populations! ")
         stdout.text(" Using the ao sz density and/or the collinear spin populations")
         stdout.flush

         density.create(.n_bf,.n_bf)
         density = ZERO
         .BASE:make_ao_sz_density_matrix(density)
         mulliken_matrix=ZERO; diagonals=ZERO
         ! fill the general_complex mulliken matrix and diagonals
         mulliken_matrix.to_product_of(density,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)
         ! Put the atomic ao sz spin populations
         .:put_mulliken_spins(mulliken_matrix, diagonals)
         density.destroy

      ! Unrestricted case
      else if (.density_matrix.is_allocated_with_genre("unrestricted")) then

         ! Temporary
         density.create(.n_bf,.n_bf)

         ! Restricted density matrix
         density = .density_matrix.alpha + .density_matrix.beta

         ! Normal mulliken population
         mulliken_matrix.to_product_of(density,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)

         ! Put the populations
         .:put_mulliken_populations(mulliken_matrix, diagonals)

         ! Unpaired density matrix
         density = .density_matrix.alpha - .density_matrix.beta
         mulliken_matrix.to_product_of(density,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)

         ! Put the spin populations
         .:put_mulliken_spins(mulliken_matrix, diagonals)

         ! Clean up
         density.destroy

      ! Restricted case
      else if (.density_matrix.is_allocated_with_genre("restricted")) then

         ! Make the restricted mulliken matrix
         mulliken_matrix.to_product_of(.density_matrix.restricted,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)

         ! Put the atomic populations
         .:put_mulliken_populations(mulliken_matrix, diagonals)

      else

        DIE("Mulliken populations not yet implemented for this case")

      end

      ! Clean up
      mulliken_matrix.destroy
      diagonals.destroy

   end

   put_mulliken_populations(mulliken_matrix,diagonals)
   ! Output the Mulliken populations
      self :: IN
      mulliken_matrix :: MAT{REAL}, IN
      diagonals :: VEC{REAL}, IN

      table :: VEC{TABLE_COLUMN}*
      tags,lmom :: VEC{STR}*
      pops,chrg :: VEC{REAL}*
      off, a,b,c, fa,la,n_bf :: INT

      ! Atomic data
      pops.create(.n_atom)
      chrg.create(.n_atom)

      ! Basis-fn data
      tags.create(.n_bf)
      lmom.create(.n_bf)

      off = 0 

      do a = 1,.n_atom

         ! Mulliken population & charge
         fa = .first_basis_fn_for_atom(a)
         la =  .last_basis_fn_for_atom(a)
         pops(a) = sum(diagonals(fa:la))
         chrg(a) = .atom(a).nuclear_charge - pops(a)

         ! Symbols for each basis fn.
         do b = 1,.atom(a).basis.n_shell

            n_bf = .atom(a).basis.shell(b).n_bf
            do c = 1,n_bf
               tags(off+c) = .atom(a).tag
               lmom(off+c) = .atom(a).basis.shell(b).l_chr
            end

            off = off + n_bf

         end

      end


      ! Title
      stdout.flush
      stdout.text("===================================")
      stdout.text("Mulliken basis-function populations")
      stdout.text("===================================")
      stdout.flush
      stdout.show("Trace of the Mulliken matrix =",mulliken_matrix.trace)
      stdout.flush

      ! Create table
      table.create(3)
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      table(2).set_heading("Basis")
      table(2).set_subhead("func.")
      table(3).set_heading("Mulliken")
      table(3).set_subhead("    Pop.")

      ! Set data
      table(1).set_values(tags)
      table(2).set_values(lmom)
      table(3).set_values(diagonals)

      ! Put
      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      lmom.destroy
      tags.destroy


      stdout.flush
      stdout.text("===========================")
      stdout.text("Mulliken atomic populations")
      stdout.text("===========================")
      stdout.flush
      stdout.show("Sum of the Mulliken populations =",sum(pops))
      stdout.show("Sum of the Mulliken charges     =",sum(chrg))
      stdout.flush

      ! Create table
      table.create(3)
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      table(2).set_heading("Mulliken")
      table(2).set_subhead("    Pop.")
      table(3).set_heading("Mulliken")
      table(3).set_subhead("  charge")

      ! Set data
      tags.create(.n_atom)
      tags = .atom(:).tag
      table(1).set_values(tags)
      table(2).set_values(pops)
      table(3).set_values(chrg)

      ! Put
      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      tags.destroy
      chrg.destroy
      pops.destroy

   end

   put_mulliken_spins(mulliken_matrix,diagonals)
   ! Outputs the mulliken populations to the output file
      mulliken_matrix :: MAT{REAL}
      diagonals :: VEC{REAL}

   ! ENSURE(NOT .use_spherical_basis,"not implemented")

      atom_pop :: VEC{REAL}*
      pop :: REAL
      o_count, a, b, c, n_comp :: INT

      ! Print out the spins for every basis function
      stdout.flush
      stdout.text("Mulliken spin population analysis: ")
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Type", int_width = TRUE)
      stdout.put("Spin pop")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)

      o_count = 1
      atom_pop.create(.n_atom)
      atom_pop = ZERO

      do a = 1, .n_atom
      do b = 1, .atom(a).basis.n_shell

         if (.use_spherical_basis) then
            n_comp = .atom(a).basis.shell(b).n_sph
         else
            n_comp = .atom(a).basis.shell(b).n_comp
         end if

         do c = 1, n_comp
            stdout.put(.atom(a).label, int_width = TRUE)
            stdout.put(.atom(a).basis.shell(b).l_chr, int_width = TRUE)
            pop = diagonals(c + o_count - 1)
            stdout.put(pop)
            atom_pop(a) = atom_pop(a) + pop
            stdout.flush
         end

         o_count = o_count + n_comp

      end

      end
      stdout.dash(int_fields=2,real_fields=1)

      stdout.flush
      stdout.show("Trace of the Mulliken spin matrix =",mulliken_matrix.trace)

      ! Print out the spins
      stdout.flush
      stdout.text("Atomic spin populations: ")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Spin")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=1)
      do a = 1, .n_atom
         stdout.put(.atom(a).label, int_width = TRUE)
         stdout.put(atom_pop(a))
         stdout.flush
      end
      stdout.dash(int_fields=1, real_fields=1)

      ! Clean up
      atom_pop.destroy
      stdout.flush

   end

   get_gchf_na_nb ::: leaky
   ! alpha and beta populations of occupied GCHF spinorbitals

      S :: MAT{REAL}*
      i,k,l :: INT
      na,nb,atot,btot,II :: CPX

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
      II=(ZERO,ONE)

      stdout.flush
      stdout.flush
      stdout.text(" GCHF na nb orbital populations ")
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("i", int_width = TRUE)
      stdout.put("na")
      stdout.put("  ")
      stdout.put("nb")
      stdout.put("  ")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      atot=(ZERO,ZERO)
      btot=(ZERO,ZERO)
         do i=1,.n_e
           na=(ZERO,ZERO)
           nb=(ZERO,ZERO)
             do k=1,.n_bf
                do l=1,.n_bf
                ! sigma z overlap
                  na = na + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l,i))
                  nb = nb + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,i))
                end
             end
           stdout.put(i)  
           stdout.put(na) 
           stdout.put(nb)
           stdout.flush
           atot = atot + na
           btot = btot + nb
         end
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("total:",int_width=TRUE)  
      stdout.put(atot) 
      stdout.put(btot)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)


   end

!  Spin expectation values

   get_uhf_sx_sy_sz ::: leaky
   ! evaluation of expectation values of sigma_x, sigma_y and sigma_z
   ! n_x=0, n_y= and n_z= number of open shell electrons

      S,orbs :: MAT{REAL}*
      CMOi :: VEC{REAL}*
      i,k,l :: INT
      z,x,y :: REAL

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

      orbs.create(2*.n_bf,.n_e)
      orbs=ZERO
      do i=1,.n_a
        orbs(1:.n_bf,i) = .molecular_orbitals.alpha(:,i)
      end  
      do i=1,.n_b
        orbs(.n_bf+1:2*.n_bf,.n_a+i) = .molecular_orbitals.beta(:,i)
      end  

      x=ZERO;y=ZERO;z=ZERO
      do i=1,.n_e
        CMOi => orbs(:,i)
          do k=1,.n_bf
             do l=1,.n_bf
             ! sigma x overlap
               x = x + (CMOi(k+.n_bf))*S(k,l)*(CMOi(l))
               x = x + (CMOi(k))*S(k,l)*(CMOi(l+.n_bf))
             ! sigma y overlap
               y = y + (CMOi(k+.n_bf))*S(k,l)*CMOi(l)
               y = y - (CMOi(k))*S(k,l)*CMOi(l+.n_bf)
             ! sigma z overlap
               z = z + (CMOi(k))*S(k,l)*(CMOi(l))
               z = z - (CMOi(k+.n_bf))*S(k,l)*(CMOi(l+.n_bf))
             end
          end
      end

      stdout.flush
      stdout.flush
      stdout.text("UHF expectation values of Pauli spin matrices,")
      stdout.text("n_x=0, n_y=0 and n_z= number of open shell electrons:")
      stdout.show("n_x = <sigma_x> ",x)  
      stdout.show("n_y = <sigma_y> ",y)  
      stdout.show("n_z = <sigma_z> ",z)  
      stdout.flush

      orbs.destroy

   end

   get_gchf_sx_sy_sz ::: leaky
   ! evaluation of expectation values of sigma_x, sigma_y and sigma_z
   ! n_x=0, n_y= and n_z= number of open shell electrons
   S :: MAT{REAL}*
   i,k,l :: INT
   z,x,y,II :: CPX

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
      II=(ZERO,ONE)

         x=(ZERO,ZERO)
         y=(ZERO,ZERO)
         z=(ZERO,ZERO)
         do i=1,.n_e
             do k=1,.n_bf
                do l=1,.n_bf
                ! sigma x overlap
                  x = x + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l,i))
                  x = x + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,i))
                ! sigma y overlap
                  y = y + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*.molecular_orbitals.general_complex(l,i)
                  y = y - conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*.molecular_orbitals.general_complex(l+.n_bf,i)
                ! sigma z overlap
                  z = z + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l,i))
                  z = z - conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,i))
                end
             end
         end

         stdout.flush
         stdout.text("GCHF expectation values of Pauli spin matrices:")
         stdout.show("n_x = <sigma_x> ",x)  
         stdout.show("n_y = <sigma_y> ",y)  
         stdout.show("n_z = <sigma_z> ",z)  
         stdout.flush

   end

   get_uhf_s2 ::: leaky
   ! s2 uhf expectation values 
   ! evaluated directly for the x, y and z components
   S :: MAT{REAL}*
   CMOi,CMOj :: VEC{REAL}*
   sx,sy,sz,orbs :: MAT{REAL}*
   i,j,k,l :: INT
   x,y,z :: REAL

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

   sx.create(.n_e,.n_e); sy.create(.n_e,.n_e); sz.create(.n_e,.n_e)
         orbs.create(2*.n_bf,.n_e)
         orbs=ZERO
         do i=1,.n_a
           orbs(1:.n_bf,i) = .molecular_orbitals.alpha(:,i)
         end  
         do i=1,.n_b
           orbs(.n_bf+1:2*.n_bf,.n_a+i) = .molecular_orbitals.beta(:,i)
         end  
         sx=ZERO
         sy=ZERO
         sz=ZERO

         do i=1,.n_e
         do j=1,.n_e
           CMOi => orbs(:,i)
           CMOj => orbs(:,j)
             do k=1,.n_bf
                do l=1,.n_bf
                ! sigma x density 
                  sx(i,j) = sx(i,j) + (CMOi(k+.n_bf))*S(k,l)*(CMOj(l))
                  sx(i,j) = sx(i,j) + (CMOi(k))*S(k,l)*(CMOj(l+.n_bf))
                ! sigma y density
                  sy(i,j) = sy(i,j) + (CMOi(k+.n_bf))*S(k,l)*CMOj(l)
                  sy(i,j) = sy(i,j) - (CMOi(k))*S(k,l)*CMOj(l+.n_bf)
                ! sigma z density
                  sz(i,j) = sz(i,j) + (CMOi(k))*S(k,l)*(CMOj(l))
                  sz(i,j) = sz(i,j) - (CMOi(k+.n_bf))*S(k,l)*(CMOj(l+.n_bf))
                end
             end

         end
         end

         x=ZERO
         y=ZERO
         z=ZERO
         do i=1,.n_e
         do j=i+1,.n_e
           x = x - sx(i,j)*sx(j,i)*TWO + sx(i,i)*sx(j,j)*TWO
           y = y + sy(i,j)*sy(j,i)*TWO - sy(i,i)*sy(j,j)*TWO  ! i*i=-1
           z = z - sz(i,j)*sz(j,i)*TWO + sz(i,i)*sz(j,j)*TWO
         end
         end

         stdout.flush
         stdout.text("S^2 = Sx^2 + Sy^2 + Sz^2")  
         stdout.show("Sx^2 ",(.n_e + x)/FOUR)  
         stdout.show("Sy^2 ",(.n_e + y)/FOUR)
         stdout.show("Sz^2 ",(.n_e + z)/FOUR)  
         stdout.show("S^2  ",(THREE*.n_e+x+y+z)/FOUR)  
         stdout.flush
   sx.destroy;sy.destroy;sz.destroy

   end

   get_gchf_s2 ::: leaky
   ! S2 gchf expectation value evaluated via Sx^2 + Sy^2 + Sz^2 contributions
   S :: MAT{REAL}*
   sx,sy,sz :: MAT{CPX}*
   i,j,k,l :: INT
   x,y,z :: CPX

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

   sx.create(.n_e,.n_e); sy.create(.n_e,.n_e); sz.create(.n_e,.n_e)

         stdout.flush
         sx=(ZERO,ZERO)
         sy=(ZERO,ZERO)
         sz=(ZERO,ZERO)

         do i=1,.n_e
         do j=1,.n_e
             do k=1,.n_bf
                do l=1,.n_bf
                ! sigma x squared density
                  sx(i,j) = sx(i,j) + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l,j))
                  sx(i,j) = sx(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,j))
                ! sigma y density
                  sy(i,j) = sy(i,j) + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*.molecular_orbitals.general_complex(l,j)
                  sy(i,j) = sy(i,j) - conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*.molecular_orbitals.general_complex(l+.n_bf,j)
                ! sigma z density
                  sz(i,j) = sz(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l,j))
                  sz(i,j) = sz(i,j) - conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,j))
                end
             end

         end
         end

         x=(ZERO,ZERO)
         y=(ZERO,ZERO)
         z=(ZERO,ZERO)
         do i=1,.n_e
         do j=i+1,.n_e
           x = x - sx(i,j)*sx(j,i)*TWO + sx(i,i)*sx(j,j)*TWO
           y = y + sy(i,j)*sy(j,i)*TWO - sy(i,i)*sy(j,j)*TWO  ! i*i=-1
           z = z - sz(i,j)*sz(j,i)*TWO + sz(i,i)*sz(j,j)*TWO
         end
         end

         stdout.flush
         stdout.text("S^2 = Sx^2 + Sy^2 + Sz^2")  
         stdout.show("Sx^2 ",(.n_e + x)/FOUR)  
         stdout.show("Sy^2 ",(.n_e + y)/FOUR)
         stdout.show("Sz^2 ",(.n_e + z)/FOUR)  
         stdout.show("S^2  ",(THREE*.n_e+x+y+z)/FOUR)  
         stdout.flush
   sx.destroy;sy.destroy;sz.destroy

   end

   get_uhf_s2_orig ::: leaky
   ! s2 uhf expectation value via the overlap of alpha and beta orbs.
   S :: MAT{REAL}*
   CMOi,CMOj :: VEC{REAL}*
   aa,bb,ab,ba,orbs :: MAT{REAL}*
   i,j,k,l :: INT
   x,y,z,na,nb :: REAL

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

   aa.create(.n_e,.n_e); bb.create(.n_e,.n_e)
   ba.create(.n_e,.n_e); ab.create(.n_e,.n_e)

         stdout.flush
         stdout.text("S^2 = (S+S- + S-S+)/2 + Sz^2")  
         aa=ZERO
         ab=ZERO
         ba=ZERO
         bb=ZERO
         orbs.create(2*.n_bf,.n_e)
         orbs=ZERO
         do i=1,.n_a
           orbs(1:.n_bf,i) = .molecular_orbitals.alpha(:,i)
         end  
         do i=1,.n_b
           orbs(.n_bf+1:2*.n_bf,.n_a+i) = .molecular_orbitals.beta(:,i)
         end  

         do i=1,.n_e
         do j=1,.n_e
           CMOi => orbs(:,i)
           CMOj => orbs(:,j)
             do k=1,.n_bf
                do l=1,.n_bf
                  ba(i,j) = ba(i,j) + (CMOi(k+.n_bf))*S(k,l)*(CMOj(l))
                  ab(i,j) = ab(i,j) + (CMOi(k))*S(k,l)*(CMOj(l+.n_bf))
                  aa(i,j) = aa(i,j) + (CMOi(k))*S(k,l)*(CMOj(l))
                  bb(i,j) = bb(i,j) + (CMOi(k+.n_bf))*S(k,l)*(CMOj(l+.n_bf))
                end
             end

         end
         end
          
         na=ZERO
         nb=ZERO
         do i=1,.n_e
           CMOi => orbs(:,i)
             do k=1,.n_bf
                do l=1,.n_bf
                  na = na + (CMOi(k))*S(k,l)*(CMOi(l))
                  nb = nb + (CMOi(k+.n_bf))*S(k,l)*(CMOi(l+.n_bf))
                end
             end
         end
         stdout.text("alpha (na) and beta (nb) populations:")  
         stdout.show("na ",na)  
         stdout.show("nb ",nb)  

         x=ZERO
         y=ZERO
         z=ZERO
         do i=1,.n_e
         do j=1,.n_e
           x = x +  ab(i,i)*ba(j,j) - ab(i,j)*ba(j,i)
           y = y +  ba(i,i)*ab(j,j) - ba(i,j)*ab(j,i)
           z = z + (aa(i,j)-bb(i,j))*(aa(j,i)-bb(j,i)) 
         end
         end

         stdout.show("S2 exact",(na -nb)*(na-nb+TWO)/FOUR)
         stdout.show("S+S-/2 ",(na + x)/TWO)  
         stdout.show("S-S+/2 ",(nb + y)/TWO)  
         stdout.show("Sz^2  ",((na-nb)**2 +.n_e - z)/FOUR)  
         stdout.show("S2   ",((na-nb)**2 + .n_e - z)/FOUR + (na + x + nb + y)/TWO)  
         stdout.show("spin_contamination",nb + ( x + y)/TWO +(.n_e-z)/FOUR)  
   aa.destroy;bb.destroy;ab.destroy;ba.destroy;orbs.destroy

   end

   get_gchf_s2_orig ::: leaky
   ! S2 gchf expectation value evaluated via S+-,  S-+ and Sz^2 contributions
   S :: MAT{REAL}*
   aa,bb,ab,ba :: MAT{CPX}*
   i,j,k,l :: INT
   x,y,z,na,nb :: CPX
   S2,S2e :: REAL

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

   aa.create(.n_e,.n_e); bb.create(.n_e,.n_e)
   ba.create(.n_e,.n_e); ab.create(.n_e,.n_e)

         stdout.flush
         stdout.flush
         stdout.text("S^2 = (S+S- + S-S+)/2 + Sz^2")  
         aa=(ZERO,ZERO)
         ab=(ZERO,ZERO)
         ba=(ZERO,ZERO)
         bb=(ZERO,ZERO)

         do i=1,.n_e
         do j=1,.n_e
             do k=1,.n_bf
                do l=1,.n_bf
                  ba(i,j) = ba(i,j) + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l,j))
                  ab(i,j) = ab(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,j))
                  aa(i,j) = aa(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l,j))
                  bb(i,j) = bb(i,j) + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,j))
                end
             end

         end
         end
          
         na=(ZERO,ZERO)
         nb=(ZERO,ZERO)
         do i=1,.n_e
             do k=1,.n_bf
                do l=1,.n_bf
                  na = na + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l,i))
                  nb = nb + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,i))
                end
             end
         end
         stdout.text("alpha (na) and beta (nb) populations:")  
         stdout.show("na   ",na)  
         stdout.show("nb   ",nb)  

         x=(ZERO,ZERO)
         y=(ZERO,ZERO)
         z=(ZERO,ZERO)
         do i=1,.n_e
         do j=1,.n_e
           x = x +  ab(i,i)*ba(j,j) - ab(i,j)*ba(j,i)
           y = y +  ba(i,i)*ab(j,j) - ba(i,j)*ab(j,i)
           z = z + (aa(i,j)-bb(i,j))*(aa(j,i)-bb(j,i)) 
         end
         end

         S2e=(.n_a -.n_b)*(.n_a-.n_b+TWO)/FOUR
         S2=REALIFY( ((na-nb)**2 + .n_e - z)/FOUR + (na + x + nb + y)/TWO )

         stdout.show("S2 exact          ",(.n_a -.n_b)*(.n_a-.n_b+TWO)/FOUR)
         stdout.show("S+S-/2            ",(na + x)/TWO)  
         stdout.show("S-S+/2            ",(nb + y)/TWO)  
         stdout.show("Sz^2              ",((na-nb)**2 +.n_e - z)/FOUR)  
         stdout.show("S2                ",((na-nb)**2 + .n_e - z)/FOUR + (na + x + nb + y)/TWO)  
         stdout.show("spin_contamination",S2-S2e)
   aa.destroy;bb.destroy;ab.destroy;ba.destroy

   end

   get_gchf_s2_contributions ::: leaky
   ! S2 gchf expectation value decomposition into various contribution 
   ! and matrix whose eigenvectors give directions of optimal collinearity 
   ! see P. Cassam-Chena\"{\i}, Theor Chem Acc (2015) 134:125
   S :: MAT{REAL}*
   aa,bb,ab,ba :: MAT{CPX}*
   sxmat,symat,szmat :: MAT{CPX}*
   amat :: MAT{CPX}*
   i,j,k,l :: INT
   x,y,z,na,nb :: CPX
   ii,sx,sy,sz,sxsx,sxsy,sxsz,sysx,sysy,sysz,szsx,szsy,szsz :: CPX
   S2,S2e :: REAL

     .INTS:make_overlap_matrix ! leaky
     S => .overlap_matrix
     ii=(ZERO,ONE)

     amat.create(3,3)
     aa.create(.n_e,.n_e); bb.create(.n_e,.n_e)
     ba.create(.n_e,.n_e); ab.create(.n_e,.n_e)
     sxmat.create(.n_e,.n_e); symat.create(.n_e,.n_e); szmat.create(.n_e,.n_e)

     aa=(ZERO,ZERO)
     ab=(ZERO,ZERO)
     ba=(ZERO,ZERO)
     bb=(ZERO,ZERO)
     sxmat=(ZERO,ZERO)
     symat=(ZERO,ZERO)
     szmat=(ZERO,ZERO)

     do i=1,.n_e
       do j=1,.n_e
         do k=1,.n_bf
            do l=1,.n_bf
              ba(i,j) = ba(i,j) + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l,j))
              ab(i,j) = ab(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,j))
              aa(i,j) = aa(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*(.molecular_orbitals.general_complex(l,j))
              bb(i,j) = bb(i,j) + conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*(.molecular_orbitals.general_complex(l+.n_bf,j))
            end
         end
         sxmat(i,j) = sxmat(i,j) + ab(i,j)+ba(i,j)
         symat(i,j) = symat(i,j) + ab(i,j)-ba(i,j)
         szmat(i,j) = szmat(i,j) + aa(i,j)-bb(i,j)
       end
     end
     sxmat = sxmat/TWO
     symat = symat/TWO/ii
     szmat = szmat/TWO
      
     na=(ZERO,ZERO)
     nb=(ZERO,ZERO)
     do i=1,.n_e
       na=na+aa(i,i)
       nb=nb+bb(i,i)
     end

     stdout.flush
     stdout.flush
     stdout.text("alpha (na) and beta (nb) populations:")  
     stdout.show("na   ",na)  
     stdout.show("nb   ",nb)  
     amat=ZERO
     amat(1,1)=.n_e/FOUR
     amat(2,2)=.n_e/FOUR
     amat(3,3)=.n_e/FOUR
     x=(ZERO,ZERO)
     y=(ZERO,ZERO)
     z=(ZERO,ZERO)
     sx=(ZERO,ZERO)
     sy=(ZERO,ZERO)
     sz=(ZERO,ZERO)
     sxsx=(ZERO,ZERO)
     sxsy=(ZERO,ZERO)
     sxsz=(ZERO,ZERO)
     sysx=(ZERO,ZERO)
     sysy=(ZERO,ZERO)
     sysz=(ZERO,ZERO)
     szsx=(ZERO,ZERO)
     szsy=(ZERO,ZERO)
     szsz=(ZERO,ZERO)
     do i=1,.n_e
       do j=1,.n_e
         x = x +  ab(i,i)*ba(j,j) 
         y = y - ba(i,j)*ab(j,i)
         z = z + (aa(i,j)-bb(i,j))*(aa(j,i)-bb(j,i)) 
         amat(1,1) = amat(1,1)  - conjg(sxmat(i,j)) * sxmat(i,j)
         amat(2,2) = amat(2,2)  - conjg(symat(i,j)) * symat(i,j) 
         amat(3,3) = amat(3,3)  - conjg(szmat(i,j)) * szmat(i,j) 
         amat(1,2) = amat(1,2)  - conjg(sxmat(i,j)) * symat(i,j)
         amat(2,1) = amat(2,1)  - conjg(symat(i,j)) * sxmat(i,j) 
         amat(1,3) = amat(1,3)  - conjg(sxmat(i,j)) * szmat(i,j) 
         amat(3,1) = amat(3,1)  - conjg(szmat(i,j)) * sxmat(i,j) 
         amat(2,3) = amat(2,3)  - conjg(symat(i,j)) * szmat(i,j) 
         amat(3,2) = amat(3,2)  - conjg(szmat(i,j)) * symat(i,j) 
         sxsy=sxsy + sxmat(i,i)*symat(j,j)- conjg(sxmat(i,j)) * symat(i,j) 
         sysx=sysx + symat(i,i)*sxmat(j,j)- conjg(symat(i,j)) * sxmat(i,j)  
         sxsz=sxsz + sxmat(i,i)*szmat(j,j)- conjg(sxmat(i,j)) * szmat(i,j)  
         szsx=szsx + szmat(i,i)*sxmat(j,j)- conjg(szmat(i,j)) * sxmat(i,j)  
         sysz=sysz + symat(i,i)*szmat(j,j)- conjg(symat(i,j)) * szmat(i,j)  
         szsy=szsy + szmat(i,i)*symat(j,j)- conjg(szmat(i,j)) * symat(i,j)  
       end
       sxsy=sxsy + ii/TWO*szmat(i,i)
       sysx=sysx - ii/TWO*szmat(i,i) 
       sxsz=sxsz - ii/TWO*symat(i,i) 
       szsx=szsx + ii/TWO*symat(i,i) 
       sysz=sysz + ii/TWO*sxmat(i,i) 
       szsy=szsy - ii/TWO*sxmat(i,i) 
     end

     do i=1,.n_e
       sx=sx + sxmat(i,i)
       sy=sy + symat(i,i) 
       sz=sz + szmat(i,i) 
       do j=i+1,.n_e
         sxsx=sxsx + sxmat(i,i)*sxmat(j,j) - sxmat(i,j)*sxmat(j,i)
         sysy=sysy + symat(i,i)*symat(j,j) - symat(i,j)*symat(j,i)
         szsz=szsz + szmat(i,i)*szmat(j,j) - szmat(i,j)*szmat(j,i)
       end
     end
     sxsx=sxsx*TWO+.n_e/FOUR
     sysy=sysy*TWO+.n_e/FOUR
     szsz=szsz*TWO+.n_e/FOUR
     S2e=(.n_a -.n_b)*(.n_a-.n_b+TWO)/FOUR
     S2=REALIFY( ((na-nb)**2 + .n_e - z)/FOUR + (na + TWO*x + nb + TWO*y)/TWO )

     stdout.flush
     stdout.flush
     stdout.text("Expectation values of spin operator components and their products:")  
  !   stdout.show(" x                ",x)
  !   stdout.show(" y                ",y)
  !   stdout.show(" z                ",z)
     stdout.show("Sx                ",sx)
     stdout.show("Sy                ",sy)
     stdout.show("Sz                ",sz)
     stdout.show("SxSx              ",sxsx)
     stdout.show("SxSy              ",sxsy)
     stdout.show("SxSz              ",sxsz)
     stdout.show("SySx              ",sysx)
     stdout.show("SySy              ",sysy)
     stdout.show("SySz              ",sysz)
     stdout.show("SzSx              ",szsx)
     stdout.show("SzSy              ",szsy)
     stdout.show("SzSz              ",szsz)
     stdout.show("S+S-/2            ",(na + x + y)/TWO)  
     stdout.show("S-S+/2            ",(nb + x + y)/TWO)  
  !  stdout.show("(na/2-nb/2)^2     ",((na-nb)**2)/FOUR)  
  !  stdout.show("Sz^2              ",((na-nb)**2 +.n_e - z)/FOUR)  
  !   stdout.show("S2 exact          ",(.n_a -.n_b)*(.n_a-.n_b+TWO)/FOUR)
  !   stdout.show("S2                ",((na-nb)**2 + .n_e - z)/FOUR + (na + TWO*x + nb + TWO*y)/TWO)  
     stdout.flush
     stdout.flush
     stdout.text("S^2 expectation value contributions:")  
     stdout.show("(na-nb)(na-nb+2)/4     ",(na-nb)*(na-nb+2)/FOUR)  
  !   stdout.show("(.n_e - z)/4      ",(.n_e - z)/FOUR)  
     stdout.show("z-noncollinearity      ",(.n_e - z)/FOUR)  
  !   stdout.show(" x                ",x)  
     stdout.show("x,y-nonperpendicularity",x)  
  !   stdout.show("spin_contamination",S2-S2e)
  !   stdout.show("(nb+y)            ",(nb+y))  
     stdout.show("spin-contamination     ",(nb+y))  
     stdout.show("<S^2>                  ",sxsx+sysy+szsz)
     stdout.flush
     stdout.flush
     stdout.text("A-matrix (for reorientation in an optimal collinearity direction")
     stdout.put(amat)
     aa.destroy;bb.destroy;ab.destroy;ba.destroy
     amat.destroy
     sxmat.destroy; symat.destroy; szmat.destroy

   end

   get_uhf_kramers ::: leaky
   !  analyse uhf kramers pairs 
   S :: MAT{REAL}*
   kramersA,kramersB :: MAT{REAL}*
   i,j,k,l :: INT
   X1,X2,X3,X4 :: REAL

   kramersA.create(.n_b,.n_a)
   kramersB.create(.n_a,.n_b)

   kramersA=ZERO; kramersB=ZERO
   X1=ZERO;X2=ZERO;X3=ZERO;X4=ZERO

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
      
      stdout.flush
      stdout.flush
      stdout.text("Kramers pairs analysis - UHF case:")
      stdout.flush
      stdout.text("Overlaps of individual MOs:")

      ! table head
      stdout.dash(int_fields=2,real_fields=2)
      stdout.put("i", int_width = TRUE)
      stdout.put("j", int_width = TRUE)
      stdout.put("|<bj|ai>|")
      stdout.put("|<ai|bj>|")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)

         do i=1,.n_a
           do j=1,.n_b
             do k=1,.n_bf
                do l=1,.n_bf
                  kramersA(j,i) = kramersA(j,i) + .molecular_orbitals.beta(k,j)*S(k,l)*.molecular_orbitals.alpha(l,i)
                  kramersB(i,j) = kramersB(i,j) - .molecular_orbitals.alpha(k,i)*S(k,l)*.molecular_orbitals.beta(l,j)
                end
             end
            if (abs(kramersB(i,j)) > 0.0001 OR abs(kramersA(j,i)) > 0.0001) then   
               stdout.put(i)
               stdout.put(j)
               stdout.put(abs(kramersA(j,i)))
               stdout.put(abs(kramersB(i,j)))
               stdout.flush 
            end if   
           end
         end
      
      ! end table
      stdout.dash(int_fields=2,real_fields=2)

      stdout.flush
      stdout.text("Overlaps of one alpha MO with all the other beta MOs:")

      ! table head
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("i", int_width = TRUE)
      stdout.put("sumj <ai|bj>^2")
!     stdout.put("<sum(ai)|bj>")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)

         do i = 1,.n_a
           X1=ZERO; X2=ZERO
           do j = 1,.n_b
               X1 = X1 + kramersA(j,i)*kramersA(j,i)
               X2 = X2 + kramersB(i,j)*kramersB(i,j)
               X3 = X3 + kramersA(j,i)*kramersA(j,i)
               X4 = X4 + kramersB(i,j)*kramersB(i,j)
           end do
        stdout.put(i)
        stdout.put(X1)
!       stdout.put(X2)
        stdout.flush 
         end do

      stdout.dash(int_fields=1,real_fields=1)
        stdout.put("sum",int_width=TRUE)
        stdout.put(X3)
     !   stdout.put(X4)
        stdout.flush 
      ! end table
      stdout.dash(int_fields=1,real_fields=1)

   kramersA.destroy
   kramersB.destroy

   end

   get_gchf_kramers ::: leaky
   !  analyse kramers pairs 
   S :: MAT{REAL}*
   kramers :: MAT{CPX}*
   i,j,k,l :: INT
   X1,X2,X3,X4,II :: CPX

   kramers.create(.n_e,.n_e)

   kramers=(ZERO,ZERO)
   II=(ZERO,ONE)
   X1=(ZERO,ZERO);X2=(ZERO,ZERO);X3=(ZERO,ZERO);X4=(ZERO,ZERO)

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

      stdout.flush
      stdout.flush
      stdout.text("Kramers pairs analysis - GCHF case:")
      stdout.flush
      ! the phase is random - hence bad for testing purposes
      stdout.text("Overlaps of individual MOs:")

      ! table head
      stdout.dash(int_fields=2,real_fields=2)
      stdout.put("i", int_width = TRUE)
      stdout.put("j", int_width = TRUE)
      stdout.put("|<i|Kj>|")
      stdout.put("|<j|Ki>|")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)

         do i=1,.n_e
            do j=i,.n_e
              do k=1,.n_bf
                do l=1,.n_bf
                   kramers(i,j) = kramers(i,j) - conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*conjg(.molecular_orbitals.general_complex(l,j))
                   kramers(i,j) = kramers(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*conjg(.molecular_orbitals.general_complex(l+.n_bf,j))
                   kramers(j,i) = kramers(j,i) - conjg(.molecular_orbitals.general_complex(k+.n_bf,j))*S(k,l)*conjg(.molecular_orbitals.general_complex(l,i))
                   kramers(j,i) = kramers(j,i) + conjg(.molecular_orbitals.general_complex(k,j))*S(k,l)*conjg(.molecular_orbitals.general_complex(l+.n_bf,i))
                end
              end
              if (abs(kramers(i,j)) > 0.0001 OR abs(kramers(j,i)) > 0.0001) then   
                stdout.put(i)
                stdout.put(j)
                stdout.put(abs(kramers(i,j)))
                stdout.put(abs(kramers(j,i)))
                stdout.flush 
              end if   
            end
         end
      ! end table
      stdout.dash(int_fields=2,real_fields=2)

      stdout.flush
      stdout.text("Overlaps of MOi with all the other Kramres MOj:")

      ! table head
      stdout.dash(int_fields=1,real_fields=2)
      stdout.put("i", int_width = TRUE)
      stdout.put("sumj |<i|Kj>|^2")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=2)

         do i = 1,.n_e
         X1=(ZERO,ZERO)
           do j = 1,.n_e
               X1 = X1 + kramers(i,j)*conjg(kramers(i,j))
           end do
           stdout.put(i)
           stdout.put(abs(X1))
           stdout.flush
           X3 = X3 + X1
         end do
      stdout.dash(int_fields=1,real_fields=2)
        stdout.put("sum",int_width=TRUE)
        stdout.put(X3)
        stdout.flush 
      ! end table
      stdout.dash(int_fields=1,real_fields=2)

      stdout.show(" Number of Kramers pairs                            ", X3/TWO)
      stdout.show(" Spin contamination <up|down> ~ analog of UHF <i,j> ", .n_b-X3/TWO)

   kramers.destroy
         
   end

   get_uhf_kramers_2 ::: leaky
   !  analyse uhf kramers pairs 
   S :: MAT{REAL}*
   kramersA,kramersB :: MAT{REAL}*
   ea,eb :: VEC{REAL}*
   i,j,k,l,lb,la :: INT
   X1,X2,X3,X4 :: REAL

!   ENSURE(.orbital_energies.alpha.associated,"no alpha energies")
!   ENSURE(.orbital_energies.beta.associated,"no beta energies")
      stdout.flush
      stdout.flush
      stdout.text("Kramers pairs analysis - UHF case:")
      stdout.text("This routine is using more beta orbitals, to identify your Kramers pairs (open shells):")
      stdout.text("Note: You need the orbital energies !!!!")

    ea => .orbital_energies.alpha
    eb => .orbital_energies.beta

   lb=.n_a+(.n_a-.n_b)*2 ! instead of .n_b
   la=.n_a     ! .n_a

   kramersA.create(lb,la)
   kramersB.create(la,lb)

   kramersA=ZERO; kramersB=ZERO
   X1=ZERO;X2=ZERO;X3=ZERO;X4=ZERO

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix

      stdout.flush
      stdout.text("Overlaps of individual MOs:")

      ! table head
      stdout.dash(int_fields=2,real_fields=4)
      stdout.put("j", int_width = TRUE)
      stdout.put("i", int_width = TRUE)
      stdout.put("|<bj|ai>|")
      stdout.put("|<ai|bj>|")
      stdout.put("eai")
      stdout.put("ebj")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)

         do j=1,lb  ! instead of .n_b
           do i=1,la
             do k=1,.n_bf
                do l=1,.n_bf
                  kramersA(j,i) = kramersA(j,i) + .molecular_orbitals.beta(k,j)*S(k,l)*.molecular_orbitals.alpha(l,i)
                  kramersB(i,j) = kramersB(i,j) - .molecular_orbitals.alpha(k,i)*S(k,l)*.molecular_orbitals.beta(l,j)
                end
             end
            if (abs(kramersB(i,j)) > 0.005 OR abs(kramersA(j,i)) > 0.005) then   
               stdout.put(j)
               stdout.put(i)
               stdout.put(abs(kramersA(j,i)))
               stdout.put(abs(kramersB(i,j)))
               stdout.put(ea(i))
               stdout.put(eb(j))
               stdout.flush 
            end if   
           end
         end
    ! table end      
    stdout.dash(int_fields=2,real_fields=4)

      stdout.flush
      stdout.text("Overalps of one MOb with all the other MOa:")

      ! table head
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("j", int_width = TRUE)
      stdout.put("sumi <bj|ai>^2")
!     stdout.put("<sum(ai)|bj>")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
!        stdout.text("j_b / Sab.Sba_j / Sba.Sab_j")
         do j = 1,lb ! instead of .n_b
           X1=ZERO; X2=ZERO
           do i = 1,.n_a
             X1 = X1 + kramersA(j,i)*kramersA(j,i)
             X2 = X2 + kramersB(i,j)*kramersB(i,j)
             X3 = X3 + kramersA(j,i)*kramersA(j,i)
           end do
           stdout.put(j)
           stdout.put(X1)
!          stdout.put(X2)
           stdout.flush 
         end do
      ! table end   
      stdout.dash(int_fields=1,real_fields=1)

      !stdout.show("sum",X3)
      stdout.put("sum",int_width=TRUE)
      stdout.put(X3)
      stdout.flush 
      stdout.dash(int_fields=1,real_fields=1)

        X3=ZERO

!       stdout.text("j_b / Sab.Sba_j / Sba.Sab_j")
         do j = 1,.n_b! instead of .n_b
           X1=ZERO; X2=ZERO
           do i = 1,la
             X3 = X3 + kramersA(j,i)*kramersA(j,i)
           end do
         end do

      !stdout.show("sum*",X3)
      stdout.put("sum*",int_width=TRUE)
      stdout.put(X3)
      stdout.flush 
      stdout.dash(int_fields=1,real_fields=1)
      stdout.text("*sum of only the first nb lines in the table")

   kramersA.destroy
   kramersB.destroy

   end

   get_gchf_kramers_2 ::: leaky
   !  analyse kramers pairs 
   S :: MAT{REAL}*
   kramers :: MAT{CPX}*
   i,j,k,l,li,lj :: INT
   X1,X2,X3,X4,II :: CPX

   li=.n_e
   lj=.n_e+(.n_a - .n_b)*2

   kramers.create(lj,lj)
   kramers=(ZERO,ZERO)
   II=(ZERO,ONE)
   X1=(ZERO,ZERO);X2=(ZERO,ZERO);X3=(ZERO,ZERO);X4=(ZERO,ZERO)

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
   
      stdout.flush
      stdout.flush
      stdout.text("Kramers pairs analysis - GCHF case:")
      stdout.text("This routine is using more kramers orbitals, to identify your Kramers pairs (open shells):")

      ! the phase is random - hence bad for testing purposes
      ! table head
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("j", int_width = TRUE)
      stdout.put("i", int_width = TRUE)
      stdout.put("|<i|Kj>|")
!      stdout.put("  ")
!      stdout.put("<Kj|i>")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)

         do j=1,lj
            do i=1,li
              do k=1,.n_bf
                do l=1,.n_bf
                   kramers(i,j) = kramers(i,j) - conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*conjg(.molecular_orbitals.general_complex(l,j))
                   kramers(i,j) = kramers(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*conjg(.molecular_orbitals.general_complex(l+.n_bf,j))
                !  kramers(j,i) = kramers(j,i) - !  conjg(.molecular_orbitals.general_complex(k+.n_bf,j))*S(k,l)*conjg(.molecular_orbitals.general_complex(l,i))
                !  kramers(j,i) = kramers(j,i) + !  conjg(.molecular_orbitals.general_complex(k,j))*S(k,l)*conjg(.molecular_orbitals.general_complex(l+.n_bf,i))
                end
              end
              if (abs(kramers(i,j)) > 0.0001 OR abs(kramers(j,i)) > 0.0001) then   
                 stdout.put(j)
                 stdout.put(i)
                 stdout.put(abs(kramers(i,j)))
                 stdout.flush 
              end if   
            end
         end
      ! end table   
      stdout.dash(int_fields=2,real_fields=1)

      stdout.flush
      stdout.text("Overlaps of Kramers MOj with all the other MOi:")

      ! table head
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("j", int_width = TRUE)
      stdout.put("sumj |<i|Kj>|^2")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)


         do j = 1,lj
         X1=(ZERO,ZERO) !;X2=(ZERO,ZERO)
           do i = 1,li
               X1 = X1 + kramers(i,j)*conjg(kramers(i,j))
           end do
           stdout.put(j)
           stdout.put(abs(X1))
           stdout.flush
           X3 = X3 + X1
         end do
      stdout.dash(int_fields=1,real_fields=1)

      stdout.put("sum",int_width=TRUE)
      stdout.put(X3)
      stdout.flush 
      stdout.dash(int_fields=1,real_fields=1)

        X3=(ZERO,ZERO)

         do i = 1,.n_e 
         X1=(ZERO,ZERO) !;X2=(ZERO,ZERO)
           do j = 1,.n_e
               X1 = X1 + kramers(i,j)*conjg(kramers(i,j))
           end do
           X3 = X3 + X1
       !   X4 = X4 + X2
         end do

      stdout.put("sum*",int_width=TRUE)
      stdout.put(X3)
      stdout.flush 
      stdout.dash(int_fields=1,real_fields=1)
      stdout.text("*sum for n_e electrons only")

   kramers.destroy
         
   end

   get_gchf_jz ::: leaky
   ! s, l and j eigenvalues not finished  at all
   S :: MAT{REAL}*
   S2,Lz2 :: MAT{CPX}*
   Lx,Ly,Lz :: MAT{REAL}*
   II,jzi :: CPX
   i,k,l :: INT

   Lx.create(.n_bf,.n_bf);Ly.create(.n_bf,.n_bf);Lz.create(.n_bf,.n_bf)
   ENSURE(.molecular_orbitals.is_allocated_with_genre("general_complex"),"no gchf mos'")
   .density_matrix.general_complex.to_product_of(.molecular_orbitals.general_complex(:,1:.n_e),.molecular_orbitals.general_complex(:,1:.n_e),dagger_b=TRUE)
        
   II=(ZERO,ONE)
   Lx=ZERO; Ly=ZERO; Lz=ZERO
   .INTS:make_L_matrices(Lx,Ly,Lz)
   Lx.destroy; Ly.destroy

   .INTS:make_overlap_matrix ! leaky
   S => .overlap_matrix

   S2.create(2*.n_bf,2*.n_bf)
   Lz2.create(2*.n_bf,2*.n_bf)
   Lz2=(ZERO,ZERO);S2=(ZERO,ZERO)
   S2.alpha_alpha_set_to(S,HALF)
   S2.beta_beta_set_to(S,-HALF)
   Lz2.alpha_alpha_set_to(Lz,-II)
   Lz2.beta_beta_set_to(Lz,-II)
   Lz.destroy
   Lz2=Lz2+S2 
   S2.destroy
     
      stdout.flush
      stdout.flush
      stdout.text("Numerical Jz evaluation for each orbital")
      ! table head
      stdout.dash(int_fields=1,real_fields=2)
      stdout.put("i", int_width = TRUE)
      stdout.put("jzi")
      stdout.put(" ")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=2)

    do i=1,.n_e
      jzi=(ZERO,ZERO)
        do k=1,2*.n_bf
           do l=1,2*.n_bf
             jzi = jzi + conjg(.molecular_orbitals.general_complex(k,i))*Lz2(k,l)*.molecular_orbitals.general_complex(l,i)
           end
        end

       stdout.put(i)
       stdout.put(jzi)
       stdout.flush

    end
      ! table end
      stdout.dash(int_fields=1,real_fields=2)
   
   Lz2.destroy

   end

   get_kramers_pairs(kramers) ::: leaky
   !  get overlap of kramers pairs,
   !  i.e. the spatial overlap between alpha and beta spinors
   kramers :: MAT{REAL}

   S :: MAT{REAL}*
   i,j,k,l :: INT

   kramers=ZERO

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
         do i=1,.n_a
            do j=1,.n_b
              do k=1,.n_bf
                do l=1,.n_bf
                  kramers(i,j) = kramers(i,j) - .molecular_orbitals.alpha(k,i)*S(k,l)*.molecular_orbitals.beta(l,j)
                end
              end
            end
         end

   end

   get_kramers_pairs(kramers) ::: leaky
   !  get the overlap of kramers pairs
   kramers :: MAT{CPX}

   S :: MAT{REAL}*
   i,j,k,l :: INT

   kramers=(ZERO,ZERO)

      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
         do i=1,.n_e
            do j=i,.n_e
              do k=1,.n_bf
                do l=1,.n_bf
                   kramers(i,j) = kramers(i,j) - conjg(.molecular_orbitals.general_complex(k+.n_bf,i))*S(k,l)*conjg(.molecular_orbitals.general_complex(l,j))
                   kramers(i,j) = kramers(i,j) + conjg(.molecular_orbitals.general_complex(k,i))*S(k,l)*conjg(.molecular_orbitals.general_complex(l+.n_bf,j))
                   kramers(j,i) = kramers(j,i) - conjg(.molecular_orbitals.general_complex(k+.n_bf,j))*S(k,l)*conjg(.molecular_orbitals.general_complex(l,i))
                   kramers(j,i) = kramers(j,i) + conjg(.molecular_orbitals.general_complex(k,j))*S(k,l)*conjg(.molecular_orbitals.general_complex(l+.n_bf,i))
                end
              end
            end
         end

   end

   put_mulliken_ku_populations ::: leaky
   ! sets the kramers unrestricted mulliken spin population matrix
   ! we use the unpaired electron density concept, which accounts for
   ! the total spin
      mulliken_matrix, density :: MAT{REAL}*
      diagonals :: VEC{REAL}*
      S2,PSPS,S :: MAT{REAL}*
      mulliken_matrix2,DS2,PSPS2 :: MAT{CPX}*
      mulliken_ku_matrix2 :: MAT{CPX}*
      CMO_ku :: MAT{CPX}*
      CMO :: MAT{CPX}@
      diagonals2 :: VEC{CPX}*
!      i,j,k,l,m,n :: INT
      Oij :: CPX

      ! Create space
      mulliken_matrix.create(.n_bf, .n_bf)
      PSPS.create(.n_bf, .n_bf)
      diagonals.create(.n_bf)

      ! Overlap matrix
      .INTS:make_overlap_matrix ! leaky
      S => .overlap_matrix
      ! Unrestricted case
      if (.density_matrix.is_allocated_with_genre("unrestricted")) then

         ! Temporary
         density.create(.n_bf,.n_bf)

         ! Restricted density matrix
         density = .density_matrix.alpha + .density_matrix.beta

         ! KU mulliken population D= 2PS - PSPS from Staroverov&Davidson CPL 330 (2000) 161-168
         mulliken_matrix = matmul(density,.overlap_matrix)
         PSPS = matmul(mulliken_matrix,mulliken_matrix)
         mulliken_matrix = TWO*mulliken_matrix - PSPS
         mulliken_matrix.put_diagonal_to(diagonals)
         
         stdout.flush
         stdout.flush
         stdout.text(" Kramers unrestricted spin case!")
         stdout.text("      KU = 2PS - PS*PS ")
         ! Put the populations
         .:put_mulliken_spins(mulliken_matrix, diagonals)

         ! Clean up
         density.destroy

       elseif (.density_matrix.is_allocated_with_genre("general_complex")) then

        DIE("Mulliken ku populations not yet implemented for this case")
 
         S2.create(2*.n_bf,2*.n_bf)
         DS2.create(2*.n_bf,2*.n_bf)
         CMO_ku.create(2*.n_bf,.n_e)
         CMO = .molecular_orbitals.general_complex(:,1:.n_e)
         Oij=(ZERO,ZERO)
         PSPS2.create(2*.n_bf,2*.n_bf)
         mulliken_matrix2.create(2*.n_bf,2*.n_bf)
         mulliken_ku_matrix2.create(2*.n_bf,2*.n_bf)
         diagonals2.create(2*.n_bf)
         diagonals2.destroy
         mulliken_matrix2.destroy
         mulliken_ku_matrix2.destroy
         S2.destroy
         CMO_ku.destroy
         DS2.destroy
         PSPS2.destroy
      else
        
        DIE("Mulliken ku populations not yet implemented for this case")

      end

      ! Clean up
      mulliken_matrix.destroy
      PSPS.destroy
      diagonals.destroy

   end

!  Charge multipoles

   put_dipole
   ! Put out the dipole to stdout

      electronic,nuclear,total :: VEC{REAL}(3)
      dmag :: REAL
      axis :: VEC{STR}(3)
      i :: INT

      axis = [ "x", "y", "z" ]

      electronic = .INTS:electronic_dipole_moment
      nuclear    = .BASE:nuclear_dipole_moment
      total      = electronic + nuclear

      stdout.flush
      stdout.text("==============")
      stdout.text("Dipole moments")
      stdout.text("==============")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,3
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye"))
         stdout.put(nuclear(i).to_units("debye"))
         stdout.put(total(i).to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
      stdout.flush

      dmag = sqrt(dot_product(total,total))

      stdout.show("Dipole magnitude/au    =",dmag)
      stdout.show("Dipole magnitude/Debye =",dmag.to_units("debye"))

   end

   make_dipole result(dipole)
   ! make the dipole for self
      self :: INOUT
      dipole :: VEC{REAL}(3)
      electronic,nuclear :: VEC{REAL}(3)
      electronic = .INTS:electronic_dipole_moment
      nuclear    = .BASE:nuclear_dipole_moment
      dipole = electronic + nuclear
   end

   make_quadrupole result (quadrupole)
   ! make the dipole for self
      self :: INOUT
      quadrupole :: MAT{REAL}(3,3)

      electronic,nuclear,total :: VEC{REAL}(6)

      electronic = .INTS:electronic_quadrupole_moment
      nuclear    = .INTS:nuclear_quadrupole_moment

      total = electronic + nuclear

      quadrupole = MAT{REAL}:expand_quadrupole(total)

   end

   put_quadrupole
   ! Put out the quadrupole to stdout

      electronic,nuclear,total :: VEC{REAL}(6)
      axis :: VEC{STR}(6)
      i :: INT

      axis = [ "xx","yy","zz","xy","xz","yz" ]

      electronic = .INTS:electronic_quadrupole_moment
      nuclear    = .INTS:nuclear_quadrupole_moment
      total      = electronic + nuclear

      stdout.flush
      stdout.text("==================")
      stdout.text("Quadrupole moments")
      stdout.text("==================")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye-A")
      stdout.put("/Debye-A")
      stdout.put("/Debye-A")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,6
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye-angstrom"))
         stdout.put(nuclear(i).to_units("debye-angstrom"))
         stdout.put(total(i).to_units("debye-angstrom"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)

   end

   make_octupole result (octupole)
   ! make the octapole for self
      self :: INOUT
      octupole :: MAT3{REAL}(3,3,3)

      electronic,nuclear,total :: VEC{REAL}(10)

      electronic = .INTS:electronic_octupole_moment
      nuclear    = .INTS:nuclear_octupole_moment

      total = electronic + nuclear

      octupole = MAT3{REAL}:expand_octupole(total)

   end

   put_octupole
   ! Put out the octupole to stdout

      electronic,nuclear,total :: VEC{REAL}(10)
      axis :: VEC{STR}(10)
      i :: INT

      axis = [ "xxx","yyy","zzz","xxy","xxz","yyx","yyz","zzx","zzy","xyz" ]

      electronic = .INTS:electronic_octupole_moment
      nuclear    = .INTS:nuclear_octupole_moment
      total      = electronic + nuclear

      stdout.flush
      stdout.text("================")
      stdout.text("Octupole moments")
      stdout.text("================")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye-A2")
      stdout.put("/Debye-A2")
      stdout.put("/Debye-A2")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,10
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye-angstrom^2"))
         stdout.put(nuclear(i).to_units("debye-angstrom^2"))
         stdout.put(total(i).to_units("debye-angstrom^2"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
   end

! Field gradient

   put_E_field_at_nuclei
   ! Put out the electric field at every nuclear position

      cluster :: CLUSTER*
      electronic,nuclear,molecule,LF,xyz, xtal, pos :: MAT{REAL}*
      charge :: VEC{REAL}*
      r,d,F :: VEC{REAL}(3)
      axis :: VEC{STR}(3)
      symbol :: VEC{STR}*
      mol_rms,LF_rms,xtal_rms, d3 :: REAL
      a,i, n_charges :: INT

      axis = [ "x", "y", "z" ]
      symbol => .atom.unique_tags

      electronic.create(3,.n_atom)
      nuclear.create(3,.n_atom)
      molecule.create(3,.n_atom)

      electronic = .INTS:electronic_E_field_at_nuclei
      nuclear    = .INTS:nuclear_E_field_at_nuclei
      molecule   = electronic + nuclear

      ! Table
      stdout.flush
      stdout.text("Electric fields at nuclei:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.tab(real_fields=1,int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Atom")
      stdout.put("E_i",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_atom
      do i = 1,3
         if (i==1) then; stdout.put(symbol(a))
         else;           stdout.tab(real_fields=1)
         end
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i,a))
         stdout.put(nuclear(i,a))
         stdout.put(molecule(i,a))
         stdout.flush
      end
      end
      stdout.dash(int_fields=1,real_fields=4)

      ! Add crystal field?
      if (.crystal.associated) then

         ! Make atomic charges and dipoles
         if  (NOT .Hirshfeld_atom_info_made) then
            .SCF:make_Hirshfeld_inputs
            .SCF:make_Hirshfeld_atom_info
         end

         ! Set up the cluster ... leaky
         LF.create(3,.n_atom)
         cluster.create(.crystal)
         xyz => .atom.coordinates_ptr
         cluster.set_fragment_geometry(xyz,cartesian=TRUE)
         xyz.destroy
         cluster.set_generation_method("within_radius")
         cluster.defragment= TRUE
         cluster.radius = 10.0d0
         if (.scfdata.associated) cluster.radius = .scfdata.cluster_radius
         cluster.make_info ! leaky

         ! Make Lorentz field ... does not need full cluster
         cluster.make_Lorentz_fields(LF)

         ! Make Xtal electric field
         xtal => electronic
         xtal = LF + molecule

         ! RMS values
         mol_rms  = ZERO
         LF_rms   = ZERO
         xtal_rms = ZERO

         ! Table
         stdout.flush
         stdout.text("Electric fields at nuclei--including crystal environment:")
         stdout.text("Calculated using charge and dipole Lorentz field tensors,")
         stdout.text("and Hirshfeld charges and dipoles at every u/c atom site")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         stdout.tab(real_fields=1,int_fields=1)
         stdout.put("Molecule")
         stdout.put("Environment")
         stdout.put("Crystal")
         stdout.flush
         stdout.put("Atom")
         stdout.put("E_i",int_width=TRUE)
         stdout.put("/au")
         stdout.put("/au")
         stdout.put("/au")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         do a = 1,.n_atom
         do i = 1,3
            if (i==1) then; stdout.put(symbol(a))
            else;           stdout.tab(real_fields=1)
            end
            stdout.put(axis(i),int_width=TRUE)
            stdout.put(molecule(i,a))
            stdout.put(LF(i,a))
            stdout.put(xtal(i,a))
            stdout.flush
            mol_rms  = mol_rms   + dot_product(molecule(:,a),molecule(:,a))
            LF_rms   = LF_rms    + dot_product(LF(:,a),LF(:,a))
            xtal_rms = xtal_rms  + dot_product(xtal(:,a),xtal(:,a))
         end
         end
         stdout.dash(int_fields=1,real_fields=4)

         mol_rms  = sqrt(mol_rms/.n_atom)
         LF_rms   = sqrt(LF_rms/.n_atom)
         xtal_rms = sqrt(xtal_rms/.n_atom)

         stdout.flush
         stdout.show("RMS value for molecular    E field =",mol_rms)
         stdout.show("RMS value for environment  E field =",LF_rms)
         stdout.show("RMS value for Xtal (total) E field =",xtal_rms)

         ! Make the cluster charges
         n_charges = cluster.n_atoms - cluster.n_fragment_atoms
         n_charges = 3*n_charges
       ! n_charges = 2*n_charges
       ! n_charges = n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         cluster.make_non_fragment_mu_charges(pos,charge)
       ! cluster.make_non_fragment_positions2(pos,charge)
       ! cluster.make_non_fragment_positions3(pos,charge)

         ! Get the point charge electric fields
         LF = ZERO
         do a = 1,.n_atom
            r = .atom(a).position
            F = ZERO
            do i = 1,n_charges
               d  = r - pos(:,i)
               d3 = sqrt(dot_product(d,d))
               d3 = d3*d3*d3
               F = F + charge(i)*d/d3
            end
            LF(:,a) = F
         end

         ! Make Xtal electric field
         xtal => electronic
         xtal = LF + molecule

         ! RMS values
         mol_rms  = ZERO
         LF_rms   = ZERO
         xtal_rms = ZERO

         ! Table
         stdout.flush
         stdout.text("Electric fields at nuclei--including crystal environment:")
         stdout.text("Calculated using Hirshfeld point charges and dipoles")
         stdout.show("Cluster radius in au =",cluster.radius)
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         stdout.tab(real_fields=1,int_fields=1)
         stdout.put("Molecule")
         stdout.put("Environment")
         stdout.put("Crystal")
         stdout.flush
         stdout.put("Atom")
         stdout.put("E_i",int_width=TRUE)
         stdout.put("/au")
         stdout.put("/au")
         stdout.put("/au")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         do a = 1,.n_atom
         do i = 1,3
            if (i==1) then; stdout.put(symbol(a))
            else;           stdout.tab(real_fields=1)
            end
            stdout.put(axis(i),int_width=TRUE)
            stdout.put(molecule(i,a))
            stdout.put(LF(i,a))
            stdout.put(xtal(i,a))
            stdout.flush
            mol_rms  = mol_rms   + dot_product(molecule(:,a),molecule(:,a))
            LF_rms   = LF_rms    + dot_product(LF(:,a),LF(:,a))
            xtal_rms = xtal_rms  + dot_product(xtal(:,a),xtal(:,a))
         end
         end
         stdout.dash(int_fields=1,real_fields=4)

         mol_rms  = sqrt(mol_rms/.n_atom)
         LF_rms   = sqrt(LF_rms/.n_atom)
         xtal_rms = sqrt(xtal_rms/.n_atom)

         stdout.flush
         stdout.show("RMS value for molecular    E field =",mol_rms)
         stdout.show("RMS value for environment  E field =",LF_rms)
         stdout.show("RMS value for Xtal (total) E field =",xtal_rms)

         ! Clean up
         pos.destroy; charge.destroy
         cluster.destroy
         LF.destroy

      end

      molecule.destroy
      nuclear.destroy
      electronic.destroy
      symbol.destroy

   end

   put_EFG_at_nuclei
   ! Put out the electric field gradient at every nuclear position

      electronic,nuclear,total :: MAT{REAL}*
      axis :: VEC{STR}(6)
      symbol :: VEC{STR}*
      a,i :: INT

      axis = [ "xx","yy","zz","xy","xz","yz" ]

      symbol => .atom.unique_tags

      electronic.create(6,.n_atom)
      nuclear.create(6,.n_atom)
      total.create(6,.n_atom)

      electronic = .INTS:electronic_EFG_at_nuclei
      nuclear    = .INTS:nuclear_EFG_at_nuclei
      total      = electronic + nuclear

      stdout.flush
      stdout.text("Electric field gradient at nuclei:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.tab(real_fields=1,int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Atom")
      stdout.put("E_ij",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_atom
      do i = 1,6
         if (i==1) then; stdout.put(symbol(a))
         else;           stdout.tab(real_fields=1)
         end
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i,a))
         stdout.put(nuclear(i,a))
         stdout.put(total(i,a))
         stdout.flush
      end
      end
      stdout.dash(int_fields=1,real_fields=4)

      total.destroy
      nuclear.destroy
      electronic.destroy
      symbol.destroy

   end

   spin_contamination ::: leaky
   ! spin contamination for the UHF calculations
   ! and ones also perhaps for the gchf one
      ENSURE(.molecular_orbitals.alpha.allocated, "no alpha orbitals")
      ENSURE(.molecular_orbitals.beta.allocated, "no beta orbitals")
      MSC,S :: MAT{REAL}*
      SC,S2 :: REAL
      na,nb,i,j,k,l :: INT

      .INTS:make_overlap_matrix
      S => .overlap_matrix
      na = .BASE:no_of_alpha_electrons
      nb = .BASE:no_of_beta_electrons
      MSC.create(na,nb)
      MSC=ZERO
      SC=ZERO

      do i =1,na
        do j=1,nb
          do k=1,.n_bf
            do l=1,.n_bf
               MSC(i,j)=  MSC(i,j)+ .molecular_orbitals.beta(k,j)*S(k,l)*.molecular_orbitals.alpha(l,i)
            end do
          end do
        SC= SC + MSC(i,j)**2
        end do
      end do

      MSC.destroy

      S2 = (na-nb)*ONE/TWO * ( (na-nb)*ONE/TWO + ONE )

      stdout.flush
      stdout.show("    THEORETICAL S**2 ",S2)
      stdout.show("    UHF S**2 ",S2+nb-SC)
      stdout.show("    SPIN CONTAMINATION ",nb-SC)
      stdout.flush

   end

!  Structure factor populations
!  What is this? --dylan
!  These are the atomic contributions to structure factors --lukas

   put_mulliken_sf_populations 
   ! makes the mulliken population analysis of structure factors,
   ! you need to have the structure factors real valued, else this is CRAP!
      density,k_pts :: MAT{REAL}*
      mulliken_matrix :: MAT{CPX}*
      diagonals :: VEC{CPX}*
      S2 :: MAT{CPX}*
      mulliken_matrix2 :: MAT{CPX}*
      diagonals2 :: VEC{CPX}*
      MM :: MAT{REAL}*
      GG,ft_hkl,buco :: MAT{CPX}*
      n,m,k_max,n_ref :: INT
      sf :: CPX
      sfn :: MAT{CPX}*
      Fc :: MAT{CPX}*

      .crystal.assign_xray

      Fc.create(.crystal.n_refl,.n_atom); Fc=(ZERO,ZERO)
      sfn.create(.crystal.n_unique_SF_k_pts,.n_atom); sfn=(ZERO,ZERO)
      k_pts.create(.crystal.n_unique_SF_k_pts,3); k_pts=ZERO
      .crystal.data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)

       stdout.flush
       stdout.text("NOTE: We are in put_mulliken_sf_populations!")
       stdout.text("NOTE: You need to have the structure factors real valued!")
       stdout.text("NOTE: So as, the cmpx atomic contributions cancel out!")
       stdout.flush

      .BASE:make_ao_density_matrix

     ! Create space
      mulliken_matrix.create(.n_bf, .n_bf)
      diagonals.create(.n_bf)

      MM.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(MM)

      ft_hkl.create(.n_bf,.n_bf)
      GG.create(.n_prim,.n_prim)
      buco.create(.n_bf,.n_prim)
      
      k_max = size(k_pts,1)
      n_ref = size(Fc,1)
      sfn=ZERO

      parallel do n = 1,k_max

         ! here it comes. point by point the structure factors will be on
         ! and on calculated, the code is slow if many sfs are present
         .XTAL:make_primitive_ft_matrix(GG,k_pts(n,1),k_pts(n,2),k_pts(n,3))
         buco.to_product_of(MM,GG,transpose_a=TRUE)
         ft_hkl.to_product_of(buco,MM)
         .XTAL:make_part_and_therm_smear(ft_hkl,k_pts(n,:))

      ! general complex case (LBxxx)
      if (.density_matrix.is_allocated_with_genre("general_complex")) then

         ! these objects are twice as large as usually
         S2.create(2*.n_bf,2*.n_bf)
         mulliken_matrix2.create(2*.n_bf,2*.n_bf)
         diagonals2.create(2*.n_bf)

         mulliken_matrix2 = (ZERO,ZERO)
         diagonals2 = (ZERO,ZERO)
         S2 = (ZERO,ZERO)
         S2.alpha_alpha_set_to(ft_hkl)
         S2.beta_beta_set_to(ft_hkl)

         ! fill the general_complex mulliken matrix and diagonals
         mulliken_matrix2.to_product_of(.density_matrix.general_complex,S2)
         mulliken_matrix2.put_diagonal_to(diagonals2)

         ! Make use of the restricted mulliken matrix
         diagonals = REALIFY(diagonals2(1:.n_bf)) + REALIFY(diagonals2(.n_bf+1:2*.n_bf))
         mulliken_matrix = REALIFY(mulliken_matrix2(1:.n_bf,1:.n_bf)) +  &
                           REALIFY(mulliken_matrix2(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf))

         ! Put the atomic populations
         .:put_mulliken_sf_populations(sfn(n,:),diagonals)

         mulliken_matrix2.destroy
         diagonals2.destroy
         S2.destroy

         density.destroy

      ! Unrestricted case
      else if (.density_matrix.is_allocated_with_genre("unrestricted")) then

         ! Temporary
         density.create(.n_bf,.n_bf)

         ! Restricted density matrix
         density = .density_matrix.alpha + .density_matrix.beta

         ! Normal mulliken population
         mulliken_matrix.to_product_of(density,ft_hkl)
         mulliken_matrix.put_diagonal_to(diagonals)
         
         ! get the raw sf
         .XTAL:make_ft_test_1(sf,density,k_pts(n,:))
         ! Put the populations
         .:put_mulliken_sf_populations(sfn(n,:),diagonals)

         ! Clean up
         density.destroy

      ! Restricted case
      else if (.density_matrix.is_allocated_with_genre("restricted")) then
         
         ! Temporary
         density.create(.n_bf,.n_bf)

         ! Make the restricted mulliken matrix
         mulliken_matrix.to_product_of(.density_matrix.restricted,ft_hkl)
         mulliken_matrix.put_diagonal_to(diagonals)
         
         density=.density_matrix.restricted
         ! get the raw sf
         .XTAL:make_ft_test_1(sf,density,k_pts(n,:))

         ! Put the atomic populations
         .:put_mulliken_sf_populations(sfn(n,:),diagonals)

         ! Clean up
         density.destroy
         
      else

        DIE("Mulliken populations not yet implemented for this case")

      end if

     end

     if (DO_IN_PARALLEL) then
        PARALLEL_SUM(sfn)
     end if

      ! lets build the sf out of the unique data for all atoms 
      do n=1,.n_atom
         .crystal.spacegroup.sum_unique_sf(Fc(:,n),sfn(:,n),.crystal.data.reflections)
      end do

      stdout.flush
      stdout.flush
      stdout.put("Mulliken populations in structure factors:")
      stdout.flush
      stdout.put("(One line for one structure factor, real and imaginary part shown for each atom)")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=2*.n_atom)
      stdout.put("#", int_width = TRUE)
      do n=1,.n_atom
         stdout.put(.atom(n).label)
         stdout.put(" ")
      end do
      stdout.flush 
      stdout.dash(int_fields=1, real_fields=2*.n_atom)

      ! output
      do n=1,n_ref
         stdout.put(n)
         do m=1,.n_atom
            stdout.put(Fc(n,m))
         end do
         stdout.flush
      end do
      stdout.dash(int_fields=1, real_fields=2*.n_atom)

      ! Clean up
      mulliken_matrix.destroy
      diagonals.destroy
      ft_hkl.destroy
      k_pts.destroy
      MM.destroy
      GG.destroy
      buco.destroy
      sfn.destroy
      Fc.destroy

   end

   put_mulliken_sf_populations(sfn,diagonals)
   ! makes the mulliken sf populations 
      sfn :: VEC{CPX} !(3)
      diagonals :: VEC{CPX}

      atom_pop :: VEC{CPX}*
      pop :: CPX
      o_count, a, b, c, n_comp :: INT

      o_count = 1
      atom_pop.create(.n_atom)
      atom_pop = ZERO

      do a = 1, .n_atom
      do b = 1, .atom(a).basis.n_shell

         if (.use_spherical_basis) then
            n_comp = .atom(a).basis.shell(b).n_sph
         else
            n_comp = .atom(a).basis.shell(b).n_comp
         end if

         do c = 1, n_comp
            pop = diagonals(c + o_count - 1)
            atom_pop(a) = atom_pop(a) + pop
         end

         o_count = o_count + n_comp

      end
      end

      do a = 1, .n_atom
         sfn(a)=atom_pop(a)
      end

      atom_pop.destroy

   end

!  ====================
!  Hirshfeld properties
!  ====================

   put_Hirshfeld_atom_info ::: leaky
   ! Put the Hirshfeld charges
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")

      genre :: STR

      ! Get the genre
      genre = " "
      if (.scfdata.associated) then
         genre = .scfdata.spinorbital_kind
      else if (.density_matrix.allocated) then
         genre = .density_matrix.spinorbital_kind
      end

      ! Restricted properties
      .SCF:make_Hirshfeld_inputs
      .SCF:make_Hirshfeld_atom_info(output=TRUE)
      .:put_Hirshfeld_atom_moments

      ! Urestricted properties?
      if (genre/="restricted") then
         .SCF:make_uHirshfeld_atom_info(output=TRUE)
         .:put_uHirshfeld_atom_moments
      end

   end

   put_Hirshfeld_atom_moments ::: private
   ! Put the Hirshfeld charges

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")
   DIE_IF(NOT .Hirshfeld_atom_info_made,"no Hirshfeld atom info made!")

      e_dipole,n_dipole,t_dipole :: VEC{REAL}(3)
      ed,nd,td,dp :: REAL
      a :: INT

      ! Calculate dipole contributions
      e_dipole = ZERO
      n_dipole = ZERO
      do a = 1,.n_atom
         e_dipole = e_dipole + .atom(a).dipole
         n_dipole = n_dipole + .atom(a).charge*.atom(a).position
      end
      t_dipole = e_dipole + n_dipole
      ed = e_dipole.norm
      nd = n_dipole.norm
      td = t_dipole.norm

      ! Write results in au
      stdout.flush
      stdout.text("=========================================")
      stdout.text("Hirshfeld atom charges and dipole moments")
      stdout.text("=========================================")
      stdout.flush
      stdout.text("The data below are in atomic units")
      stdout.flush

      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("q")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).charge)
         stdout.put(.atom(a).dipole(1))
         stdout.put(.atom(a).dipole(2))
         stdout.put(.atom(a).dipole(3))
         dp = .atom(a).dipole.norm
         stdout.put(dp)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush
      stdout.text("Distributed dipole moments:")
      stdout.flush
      stdout.show("Total electronic dipole magnitude/au    =",ed)
      stdout.show("Total nuclear dipole magnitude/au       =",nd)
      stdout.show("Total dipole magnitude/au               =",td)

      ! Write results in Debye
      stdout.flush
      stdout.text("=========================================")
      stdout.text("Hirshfeld atom charges and dipole moments")
      stdout.text("=========================================")
      stdout.flush
      stdout.text("The data below are in Debye units")
      stdout.flush

      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("q")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).charge)
         stdout.put(.atom(a).dipole(1).to_units("debye"))
         stdout.put(.atom(a).dipole(2).to_units("debye"))
         stdout.put(.atom(a).dipole(3).to_units("debye"))
         dp = .atom(a).dipole.norm
         stdout.put(dp.to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush
      stdout.show("Total electronic dipole magnitude/Debye =",ed.to_units("debye"))
      stdout.show("Total nuclear dipole magnitude/Debye    =",nd.to_units("debye"))
      stdout.show("Total dipole magnitude/Debye            =",td.to_units("debye"))

      ! Write results in au
      stdout.flush
      stdout.text("=================================")
      stdout.text("Hirshfeld atom quadrupole moments")
      stdout.text("=================================")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Qxx")
      stdout.put("Qyy")
      stdout.put("Qzz")
      stdout.put("Qxy")
      stdout.put("Qxz")
      stdout.put("Qyz")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).quadrupole(1,1))
         stdout.put(.atom(a).quadrupole(2,2))
         stdout.put(.atom(a).quadrupole(3,3))
         stdout.put(.atom(a).quadrupole(1,2))
         stdout.put(.atom(a).quadrupole(1,3))
         stdout.put(.atom(a).quadrupole(2,3))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)

   end

   put_uHirshfeld_atom_moments ::: private
   ! Make the unrestricted Hirshfeld atom properties

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")
   DIE_IF(NOT .uHirshfeld_atom_info_made,"no Hirshfeld atom info made!")

      dp :: REAL
      a :: INT

      ! Write results in au
      stdout.flush
      stdout.text("Hirshfeld unpaired spin and unpaired spin dipole moments (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("spin")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).spin)
         stdout.put(.atom(a).spin_dipole(1))
         stdout.put(.atom(a).spin_dipole(2))
         stdout.put(.atom(a).spin_dipole(3))
         dp = .atom(a).spin_dipole.norm
         stdout.put(dp)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush

      ! Write results in Debye
      stdout.flush
      stdout.text("Hirshfeld unpaired charges and dipole moments (Debye):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("spin")        !<=== ?
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).spin)
         stdout.put(.atom(a).spin_dipole(1).to_units("debye"))
         stdout.put(.atom(a).spin_dipole(2).to_units("debye"))
         stdout.put(.atom(a).spin_dipole(3).to_units("debye"))
         dp = .atom(a).spin_dipole.norm
         stdout.put(dp.to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)

   end

!  =================
!  Structure factors
!  =================

   put_X_SF_statistics ::: leaky
   ! Put the X-ray structure factors, with summary statistics if
   ! possible
      self :: INOUT

   DIE_IF(NOT .atom.associated,"no atom list")
   DIE_IF(NOT .basis_info_made,"no basis info")
   DIE_IF(NOT .crystal.associated,"no crystal")
   DIE_IF(NOT .crystal.data.associated,"no crystal data")

      if (.crystal.data.have_F_exp) then

         ! Remake F_pred
         .crystal.data.make_F_predicted

         ! Show stats & data analysis
         stdout.flush
         stdout.text("============================")
         stdout.text("X-ray diffraction statistics")
         stdout.text("============================")
         .crystal.put_F_statistics

      end

   end

   put_X_SFs ::: leaky
   ! Put the X-ray structure factors, with summary statistics if
   ! possible
      self :: INOUT

   DIE_IF(NOT .atom.associated,"no atom list")
   DIE_IF(NOT .basis_info_made,"no basis info")
   DIE_IF(NOT .crystal.associated,"no crystal")
   DIE_IF(NOT .crystal.data.associated,"no crystal data")

      if (.crystal.data.have_F_exp) then

         ! Show stats & data analysis
         stdout.flush
         stdout.text("============================")
         stdout.text("X-ray diffraction statistics")
         stdout.text("============================")
         .crystal.put_F_statistics
         .crystal.put_data_analysis

      end

      .crystal.put_X_reflection_data

   end

   put_N_SFs ::: leaky
   ! Put the PND (Sz) structure factors, with summary statistics
   ! if possible
      self :: INOUT

   DIE_IF(NOT .atom.associated,"no atom list")
   DIE_IF(NOT .basis_info_made,"no basis info")
   DIE_IF(NOT .crystal.associated,"no crystal")
   DIE_IF(NOT .crystal.data.associated,"no crystal data")
   DIE_IF(NOT .crystal.data.have_F_exp, "no crystal F_exp data")
   DIE_IF(NOT .crystal.data.have_F_pred,"no crystal F_pred data")

      if (.crystal.data.have_F_exp) then

         ! Remake F_pred
         .crystal.data.make_F_predicted

         ! Show stats & data analysis
         stdout.flush
         stdout.text("==============")
         stdout.text("PND statistics")
         stdout.text("==============")
         .crystal.put_F_statistics
         .crystal.put_data_analysis

      else

         .crystal.put_N_reflection_data

      end

   end

!  ==============
!  Coulomb energy
!  ==============

   put_Coulomb_energy
   ! Print out the Coulomb energy for the current density matrix
   ! NOTE: ths turns off any adiabatic constant and Fermi-Amaldi

   ENSURE(.density_matrix.allocated,"no density matrix")

      J,K :: MAT{REAL}*
      E_J,E_K :: REAL

      ! Make restricted density matrix
      .BASE:make_ao_density_matrix

      ! Make the J matrix
      .scfdata.set_ee_adiabatic_constant(ONE)
      .scfdata.set_Fermi_Amaldi(FALSE)
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      .FOCK:make_r_JK_engine(J,K,.density_matrix.restricted)

      ! Energy
      E_J =     HALF*J.trace_product_with(self.density_matrix.restricted)
      E_K = -QUARTER*K.trace_product_with(self.density_matrix.restricted)

      ! Output
      stdout.flush
      stdout.show("Coulomb  energy = ",E_J)
      stdout.show("Exchange energy = ",E_K)

      K.destroy
      J.destroy

   end

!  ===================
!  Pairwise SCF energy
!  ===================

   put_scf_energy_in_mo_pairs
   ! Analyze the SCF energy into MO pairs
      Di :: OPMATRIX@
      core_energy :: VEC{REAL}*
      pair_energy :: MAT{REAL}*
      i,j :: INT
      energy :: REAL
      direct :: BIN

      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)

      core_energy = ZERO
      pair_energy = ZERO

      Di.create(.n_bf)

      direct = .scfdata.using_direct_scf
      .scfdata.set_using_direct_scf(TRUE)

      do i = 1,.n_a

         .BASE:make_scf_density_matrix(i)
         .FOCK:make_fock_matrix(.density_matrix,.fock_matrix,core=TRUE,r12=FALSE)

         Di.set_to(.density_matrix)

         core_energy(i) = .SCF:scf_electronic_energy(Di,core=TRUE)

         do j = 1,i

            .BASE:make_scf_density_matrix(j)
            .FOCK:make_fock_matrix(.density_matrix,.fock_matrix,core=FALSE,r12=TRUE)

            energy = .SCF:scf_electronic_energy(Di,core=FALSE)

            if (i==j) then; pair_energy(i,j) =     energy
            else;           pair_energy(i,j) = TWO*energy
            end

         end

      end
      Di.destroy

      .scfdata.set_using_direct_scf(direct)

      stdout.flush
      stdout.text("SCF MO pair energy decomposition:")
      energy = sum(core_energy) + sum(transfer(pair_energy,(/ONE/))) + .BASE:nuclear_repulsion_energy
      stdout.show("SCF energy =",energy)
      stdout.text("Core energies:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("Core energy")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      do i = 1,.n_a
         stdout.put(i)
         stdout.put(core_energy(i))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=1)
      stdout.flush
      stdout.text("Orbital pair energies:")
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("MO_j",int_width=TRUE)
      stdout.put("Pair energy")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)
      do i = 1,.n_a
      do j = 1,i
         stdout.put(i)
         stdout.put(j)
         stdout.put(pair_energy(i,j))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=1)
      stdout.flush
   end

   put_scf_energy_as_mo_parts
   ! Analyze the SCF energy into MO contributions
      self :: INOUT

   ENSURE(.molecular_orbitals.allocated,"no MO's")
   ENSURE(.orbital_energies.associated,"no MO energies")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.scfdata.scf_kind.is_one_of(["rhf","rks"]),"must be rhf/rks")

      H :: MAT{REAL}*
      mo_energy :: VEC{REAL}*
      i :: INT

      mo_energy.create(.n_a)
      H.create(.n_bf,.n_bf)

      .SCF:make_core_matrix
      .core_matrix.restricted.change_basis_to(H,.molecular_orbitals.restricted)

      do i = 1,.n_a
         mo_energy(i) = H(i,i) + .orbital_energies.restricted(i)
      end


      stdout.flush
      stdout.text("SCF MO energy decomposition:")
      stdout.show("SCF electronic energy =",sum(mo_energy))
      stdout.text("MO energies:")
      stdout.flush
      stdout.put(mo_energy)

      H.destroy
      mo_energy.destroy

   end

!  ========================
!  SCF Energy decomposition
!  ========================

   put_AO_energy_partition
   ! Put out the AO energy partition

      Y :: MAT{REAL}*

      Y.create(.n_bf,.n_bf)
      Y.to_unit_matrix
      .:put_energy_partition(Y)
      Y.destroy

   end

   put_SAO_energy_partition
   ! Put out the symmetric AO energy partition

      Smh :: MAT{REAL}*

      .INTS:make_overlap_matrix

      Smh.create(.n_bf,.n_bf)
      .INTS:make_r_overlap_inverse_sqrt(Smh)

      .:put_energy_partition(Smh)

      Smh.destroy
   end

   put_MO_energy_partition
   ! Put out the MO energy partition. NOTE: the MO's must be ordered
   ! contiguously, first group 1 then group 2 MO's, AND the atoms in each group
   ! must be contiguous in the .atom list, first group 1 then group 2. This is
   ! because the atom_group_AO_subspace_set routine is used, and by abuse of its
   ! function with the above cobstraints, it will do the right thing and copy
   ! quadrants.
      self :: INOUT

   ENSURE(.molecular_orbitals.allocated,"no MO's")
   ENSURE(.molecular_orbitals.restricted.allocated,"no restricted MO's")

      .:put_energy_partition(.molecular_orbitals.restricted)

   end

   put_energy_partition(Y)
   ! Put out the energy decomposition specified in the .atom_group array.
   ! The inverse of matrix "Y" is used to back transform the density matrix
   ! (which is taken from disk). The back transformed density matrix is then
   ! partitioned, and transformed back in order to evaluate the interaction
   ! energies between the partitioned systems.
      self :: INOUT
      Y :: MAT{REAL}, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(size(.atom_group)==2,"must have only 2 groups")
   ENSURE(Y.dim1==.n_bf,"incorrect size for Y array")

      X, T,Z,ZZ,C,K,P,PP,W,E_T,E_Z, EE :: MAT{REAL}*
      E_ZZ :: MAT3{REAL}*
      E_C,E_K :: MAT4{REAL}*
      n_group,g,h,i,j :: INT
      fac :: REAL
      unit :: STR
      arch :: ARCHIVE
      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
      coulomb_repulsion,net_coulomb,bicentric_exchange :: REAL
      exchange_attraction,total_interaction :: REAL

      arch.set(.name,"density_matrix,restricted")
      ENSURE(arch.exists,"no density matrix saved on disk")

      P.create(.n_bf,.n_bf)
      PP.create(.n_bf,.n_bf)
      arch.read(P)

      W.create(.n_bf,.n_bf)
      T.create(.n_bf,.n_bf)
      Z.create(.n_bf,.n_bf)
      X.create(.n_bf,.n_bf)

      X.to_inverse_of(Y)

      .INTS:make_kinetic_energy_mx(T)
      .INTS:make_nuclear_attraction_mx(Z)

      n_group = size(.atom_group)
      E_T.create(n_group,n_group); E_T = ZERO
      E_Z.create(n_group,n_group); E_Z = ZERO
      E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
      E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
      E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
      ZZ.create(.n_bf,.n_bf)

      PP = P
      PP.back_transform_using(X)
      X.destroy

         do i = 1,n_group
         do j = 1,i

            W = ZERO
            .:atom_group_AO_subspace_set(W,PP,i,j)
            if (i/=j) &
            .:atom_group_AO_subspace_set(W,PP,j,i)

            W.back_transform_using(Y)

            E_T(i,j) = T.trace_product_with(W)
            E_Z(i,j) = Z.trace_product_with(W)

            do g = 1,n_group
               .INTS:make_nuclear_attraction_mx(ZZ,.atom_group(g).atom_index)
               E_ZZ(i,j,g) = ZZ.trace_product_with(W)
            end

         end
         end

      ZZ.destroy

      C.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)

      do g = 1,n_group
      do h = 1,g

         W = ZERO
         .:atom_group_AO_subspace_set(W,PP,g,h)
         if (g/=h) &
         .:atom_group_AO_subspace_set(W,PP,h,g)
         W.back_transform_using(Y)

         .FOCK:make_r_JK_nosym(C,K,W)

         do i = 1,n_group
         do j = 1,i

            W = ZERO
            .:atom_group_AO_subspace_set(W,PP,i,j)
            if (i/=j) &
            .:atom_group_AO_subspace_set(W,PP,j,i)

            W.back_transform_using(Y)

            E_C(i,j,g,h) =  C.trace_product_with(W)
            E_K(i,j,g,h) = -K.trace_product_with(W)

         end
         end

      end
      end

      K.destroy
      C.destroy

      E_C = HALF*E_C
      E_K = HALF*HALF*E_K
      EE.create(n_group,n_group)

      stdout.text(" ")
      stdout.text("Energies obtained with the current density matrix:")
      stdout.text(" ")
      fac = sum(E_T+E_Z) + sum(E_C+E_K)
      stdout.show("SCF electronic energy =",fac)
      stdout.show("SCF energy            =",fac+.BASE:nuclear_repulsion_energy)
      stdout.show("Kinetic energy        =",sum(E_T))

      unit = "kcal/mol"
      fac = unit.conversion_factor
      E_T = fac*E_T
      E_Z = fac*E_Z
      E_C = fac*E_C
      E_K = fac*E_K
      E_ZZ = fac*E_ZZ
      stdout.text(" ")
      stdout.text("Energy decomposition in kcal/mol ...")
      stdout.text(" ")
      stdout.text("Kinetic interaction terms")
      stdout.put(E_T)
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms")
      stdout.put(E_Z)
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
      stdout.put(E_ZZ(:,:,1))
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
      stdout.put(E_ZZ(:,:,2))
      EE(1,1) = fac*.atom(.atom_group(1).atom_index).nuclear_repulsion_energy
      EE(2,2) = fac*.atom(.atom_group(2).atom_index).nuclear_repulsion_energy
      nuclear_repulsion = fac*.BASE:nuclear_repulsion_energy - EE(1,1) - EE(2,2)
      EE(2,1) = nuclear_repulsion
      EE(1,2) = ZERO
      stdout.text(" ")
      stdout.text("Nuclear nuclear repulsion")
      stdout.put(EE)
      EE(1,1) = E_C(1,1,1,1)
      EE(2,1) = E_C(2,2,1,1)
      EE(1,2) = E_C(1,1,2,2)
      EE(2,2) = E_C(2,2,2,2)
      stdout.text(" ")
      stdout.text("Diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      EE(1,1) = E_C(1,2,1,1)
      EE(2,1) = E_C(2,1,1,1)
      EE(1,2) = E_C(1,2,2,2)
      EE(2,2) = E_C(2,1,2,2)
      stdout.text(" ")
      stdout.text("Semi diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      EE(1,1) = E_C(1,2,1,2)
      EE(2,1) = E_C(2,1,1,2)
      EE(1,2) = E_C(1,2,2,1)
      EE(2,2) = E_C(2,1,2,1)
      stdout.text(" ")
      stdout.text("Off diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      stdout.text(" ")
      stdout.text("All Coulomb repulsion interaction terms")
      stdout.put(E_C)
      EE(1,1) = E_K(1,1,1,1)
      EE(2,1) = E_K(2,2,1,1)
      EE(1,2) = E_K(1,1,2,2)
      EE(2,2) = E_K(2,2,2,2)
      stdout.text(" ")
      stdout.text("Diagonal exchange interaction terms")
      stdout.put(EE)
      EE(1,1) = E_K(1,2,1,1)
      EE(2,1) = E_K(2,1,1,1)
      EE(1,2) = E_K(1,2,2,2)
      EE(2,2) = E_K(2,1,2,2)
      stdout.text(" ")
      stdout.text("Semi diagonal exchange interaction terms")
      stdout.put(EE)
      EE(1,1) = E_K(1,2,1,2)
      EE(2,1) = E_K(2,1,1,2)
      EE(1,2) = E_K(1,2,2,1)
      EE(2,2) = E_K(2,1,2,1)
      stdout.text(" ")
      stdout.text("Off diagonal exchange interaction terms")
      stdout.put(EE)
      stdout.text(" ")
      stdout.text("All exchange interaction terms")
      stdout.put(E_K)

      kinetic_energy      = E_T(2,1)
      nuclear_attraction  = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
      coulomb_repulsion   = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
      net_coulomb         = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
      bicentric_exchange  = E_K(1,1,2,2) + E_K(2,2,1,1)
      exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction

      stdout.text(" ")
      stdout.show("Electron-nuclear attraction =",nuclear_attraction)
      stdout.show("Nuclear-nuclear repulsion   =",nuclear_repulsion)
      stdout.show("Electron coulomb repulsion  =",coulomb_repulsion)
      stdout.text(" ")
      stdout.text("Interaction energies for "//trim(.name)//":")
      stdout.text(" ")
      stdout.show("Kinetic energy              =",kinetic_energy)
      stdout.show("Exchange energy             =",exchange_attraction)
      stdout.show("Kinetic + Exhange           =",kinetic_energy+exchange_attraction)
      stdout.show("Bicentric Exchange          =",bicentric_exchange)
      stdout.show("Net Coulomb energy          =",net_coulomb)
      stdout.show("Net electronic en           =",nuclear_attraction+coulomb_repulsion)
      stdout.show("Total int. energy           =",total_interaction)

      kinetic_energy      = E_T(1,1)
      exchange_attraction = E_K(1,1,1,1)
      net_coulomb         = E_ZZ(1,1,1) + fac*.atom(.atom_group(1).atom_index).nuclear_repulsion_energy + E_C(1,1,1,1)
      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction

      stdout.text(" ")
      stdout.text("Monomer 1 energies:")
      stdout.text(" ")
      stdout.show("Kinetic energy 1            =",kinetic_energy)
      stdout.show("Exchange energy 1           =",exchange_attraction)
      stdout.show("Kinetic+Exhange 1           =",kinetic_energy+exchange_attraction)
      stdout.show("Net Coulomb 1               =",net_coulomb)
      stdout.show("Total 1                     =",total_interaction)

      kinetic_energy      = E_T(2,2)
      exchange_attraction = E_K(2,2,2,2)
      net_coulomb         = E_ZZ(2,2,2) + fac*.atom(.atom_group(2).atom_index).nuclear_repulsion_energy + E_C(2,2,2,2)
      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction

      stdout.text(" ")
      stdout.text("Monomer 2 energies:")
      stdout.text(" ")
      stdout.show("Kinetic energy 2            =",kinetic_energy)
      stdout.show("Exchange energy 2           =",exchange_attraction)
      stdout.show("Kinetic+Exhange 2           =",kinetic_energy+exchange_attraction)
      stdout.show("Net Coulomb 2               =",net_coulomb)
      stdout.show("Total 2                     =",total_interaction)

      EE.destroy
      E_ZZ.destroy
      E_K.destroy
      E_C.destroy
      E_Z.destroy
      E_T.destroy
      Z.destroy
      T.destroy
      W.destroy
      PP.destroy
      P.destroy

   end

   put_roby_smo_energy_partition
   ! Put out the roby energy decomposition specified in the .atom_group array
   ! based on symmetrically orthonormalised monomer molecular (SOMMO) fragments.
   ! A supermolecue density matrix must exist on disk.
      self :: INOUT

      .:put_roby_energy_partition(symorthonormalise=TRUE)

   end

   put_roby_mmo_energy_partition
   ! Put out the roby energy decomposition specified in the .atom_group array
   ! based on monomer molecular (MMO) fragments.  A supermolecue density matrix
   ! must exist on disk.
      self :: INOUT

      .:put_roby_energy_partition(symorthonormalise=FALSE)

   end

   put_roby_energy_partition(symorthonormalise) ::: leaky
   ! Calculate and put out the roby energy decomposition using groups
   ! specified in the .atom_group array.  If "symorthonormalise" is
   ! TRUE, then the occupied monomer molecular orbitals are
   ! symmetrically orthonormalised in order to define the fragments.
   ! NOTE: The density matrix defining the supermolecule is read in
   ! from the disk, so an SCF calculation or a "make_group_density_matrix"
   ! calculation must be done before this routine is called.
      self :: INOUT
      symorthonormalise :: BIN, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")

      unit :: STR
      arch :: ARCHIVE
      E_T,E_T_A,E_T_B, E_Z,E_Z_A,E_Z_B :: REAL
      E0_A,E0_B, E0_T_A,E0_T_B, E0_Z_A,E0_Z_B :: REAL
      E_C,E_C_A,E_C_B, E_K,E_K_A,E_K_B, E_N,E_N_A,E_N_B :: REAL
      E0_C_A,E0_C_B, E0_K_A,E0_K_B :: REAL
      E_kin,E_att,E_rep,E_coul,E_net_coul,E_ex,E_int,E_prom,energy, fac :: REAL
      P,P_A,P_B,D,T,Z,C,K :: MAT{REAL}*
      n,f,l :: INT

      ! Units
      unit = "kcal/mol"
      fac = unit.conversion_factor

      ! Make the ANOs: atom groups need it (leaky)
      .SCF:make_ANO_data

      ! Make the atom_group(:).mol's
    ! .BASE:make_atom_group_info

      ! Make sure ANO data and atom_group(:).mol scfdata is up-to-date (leaky)
      .BASE:update_group_info

      ! Density matrix exists?
      arch.set(.name,"density_matrix,restricted")
      ENSURE(arch.exists,"no density matrix")

      ! Read density from disk
      P.create(.n_bf,.n_bf)
      arch.read(P)

      ! Make the monomer density and MO's
      .SCF:do_group_SCF(MOs=TRUE)

      ! Make the group energies
      .SCF:make_group_energies(1,E0_A,E0_T_A,E0_Z_A,E0_C_A,E0_K_A,fac)
      .SCF:make_group_energies(2,E0_B,E0_T_B,E0_Z_B,E0_C_B,E0_K_B,fac)

      ! Symorthonormalise the occupied monomer MO's
      if (symorthonormalise) then
         .SCF:symorthonormalize_occupied_MOs
      else
         stdout.text(" ")
         stdout.text("WARNING: no symorthonormalisation of occupied MO's")
      end

      ! Do the energy decomposition
      P_A.create(.n_bf,.n_bf)
      P_B.create(.n_bf,.n_bf)
      D.create(.n_bf,.n_bf)

      .INTS:make_overlap_matrix

      P.change_basis_to(P_A,.overlap_matrix)
      P_B = P_A
      n   = .occupation_numbers.restricted(1:).index_of_first_zero_value - 1
      D.to_product_of(.molecular_orbitals.restricted(:,1:n),.molecular_orbitals.restricted(:,1:n),transpose_b=TRUE)
      P_A.change_basis_using(D)

      f  = .occupation_numbers.restricted(n+1:).index_of_first_nonzero_value
      f  = n + f
      l  = .occupation_numbers.restricted(f:).index_of_first_zero_value - 1
      l  = f + l - 1
      D.to_product_of(.molecular_orbitals.restricted(:,f:l),.molecular_orbitals.restricted(:,f:l),transpose_b=TRUE)
      P_B.change_basis_using(D)
      D.destroy

      T.create(.n_bf,.n_bf)
      .INTS:make_kinetic_energy_mx(T)
      E_T   = T.trace_product_with(P)*fac
      E_T_A = T.trace_product_with(P_A)*fac
      E_T_B = T.trace_product_with(P_B)*fac
      T.destroy

      Z.create(.n_bf,.n_bf)
      .INTS:make_nuclear_attraction_mx(Z)
      E_Z   = Z.trace_product_with(P)*fac
      .INTS:make_nuclear_attraction_mx(Z,.atom_group(1).atom_index)
      E_Z_A = Z.trace_product_with(P_A)*fac
      .INTS:make_nuclear_attraction_mx(Z,.atom_group(2).atom_index)
      E_Z_B = Z.trace_product_with(P_B)*fac
      Z.destroy

      C.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      .FOCK:make_r_JK_nosym(C,K,P)
      E_C   = HALF*C.trace_product_with(P)*fac
      E_K   = -QUARTER*K.trace_product_with(P)*fac
      .FOCK:make_r_JK_nosym(C,K,P_A)
      E_C_A = HALF*C.trace_product_with(P_A)*fac
      E_K_A = -QUARTER*K.trace_product_with(P_A)*fac
      .FOCK:make_r_JK_nosym(C,K,P_B)
      E_C_B = HALF*C.trace_product_with(P_B)*fac
      E_K_B = -QUARTER*K.trace_product_with(P_B)*fac
      K.destroy
      C.destroy
      P_B.destroy
      P_A.destroy
      P.destroy

      E_N   = fac*.BASE:nuclear_repulsion_energy
      E_N_A = .atom(.atom_group(1).atom_index).nuclear_repulsion_energy*fac
      E_N_B = .atom(.atom_group(2).atom_index).nuclear_repulsion_energy*fac
      stdout.text(" ")

      stdout.text(" ")
      stdout.text("Supermolecule energies:")
      stdout.text(" ")
      energy     = E_T + E_Z + E_C + E_K
      stdout.show("SCF electronic energy =",(energy/fac))
      stdout.show("... in kcal/mol       =",energy)
      stdout.show("SCF energy =",(energy/fac)+.BASE:nuclear_repulsion_energy)
      stdout.show("... in kcal/mol =",energy+fac*.BASE:nuclear_repulsion_energy)
      stdout.show("Kinetic energy        =",E_T)
      stdout.show("... in kcal/mol       =",(E_T/fac))
      stdout.text(" ")
      stdout.text("Roby interaction energy decomposition (kcal/mol):")

      E_kin      = E_T - E_T_A - E_T_B
      E_ex       = E_K - E_K_A - E_K_B
      E_att      = E_Z - E_Z_A - E_Z_B
      E_rep      = E_N - E_N_A - E_N_B
      E_coul     = E_C - E_C_A - E_C_B
      E_net_coul = E_att + E_rep + E_coul
      E_int      = E_kin + E_net_coul + E_ex
      MOLECULE.PROP:put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_int)

      stdout.text(" ")
      stdout.text("Interacting Monomer 1 energies (kcal/mol):")
      stdout.text(" ")
      E_int      = E_T_A + (E_Z_A + E_N_A + E_C_A) + E_K_A
      E_prom     = E_int - .atom_group(1).mol.scfdata.energy*fac
      MOLECULE.PROP:put_roby_energy_parts(E_T_A,E_K_A,E_C_A,E_Z_A,E_N_A,E_int,E_prom)

      stdout.text(" ")
      stdout.text("Isolated Monomer 1 energies (kcal/mol):")
      stdout.text(" ")
      stdout.show("Monomer 1 energy   =",.atom_group(1).mol.scfdata.energy)
      stdout.show("... in k/cal mol   =",.atom_group(1).mol.scfdata.energy*fac)
      stdout.text(" ")
      MOLECULE.PROP:put_roby_energy_parts(E0_T_A,E0_K_A,E0_C_A,E0_Z_A,E_N_A)

      stdout.text(" ")
      stdout.text("Changes in monomer 1 energy contributions (kcal/mol):")
      E_kin      = E_T_A - E0_T_A
      E_ex       = E_K_A - E0_K_A
      E_coul     = E_C_A - E0_C_A
      E_att      = E_Z_A - E0_Z_A            ! nuclear attraction
      E_rep      = ZERO                      ! change in nuclear repulsion is zero
      E_net_coul = E_att + E_rep + E_coul
      E_prom     = E_kin + E_net_coul + E_ex
      MOLECULE.PROP:put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)

      stdout.text(" ")
      stdout.text("Interacting Monomer 2 energies (kcal/mol):")
      stdout.text(" ")
      E_int      = E_T_B + (E_Z_B + E_N_B + E_C_B) + E_K_B
      E_prom     = E_int - .atom_group(2).mol.scfdata.energy*fac
      MOLECULE.PROP:put_roby_energy_parts(E_T_B,E_K_B,E_C_B,E_Z_B,E_N_B,E_int,E_prom)

      stdout.text(" ")
      stdout.text("Isolated Monomer 2 energies (kcal/mol):")
      stdout.text(" ")
      stdout.show("Monomer 2 energy   =",.atom_group(2).mol.scfdata.energy)
      stdout.show("... in k/cal mol   =",.atom_group(2).mol.scfdata.energy*fac)
      stdout.text(" ")
      MOLECULE.PROP:put_roby_energy_parts(E0_T_B,E0_K_B,E0_C_B,E0_Z_B,E_N_B)

      stdout.text(" ")
      stdout.text("Changes in monomer 2 energy contributions (kcal/mol):")
      E_kin      = E_T_B - E0_T_B
      E_ex       = E_K_B - E0_K_B
      E_coul     = E_C_B - E0_C_B
      E_att      = E_Z_B - E0_Z_B            ! nuclear attraction
      E_rep      = ZERO                      ! change in nuclear repulsion is zero
      E_net_coul = E_att + E_rep + E_coul
      E_prom     = E_kin + E_net_coul + E_ex
      MOLECULE.PROP:put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)

   end

   put_roby_energy_parts(E_T,E_K,E_C,E_Z,E_N,E_int,E_prom) ::: selfless, private
   ! Put of the Roby energy parts
      self :: IN
      E_T,E_K,E_C,E_Z,E_N :: REAL, IN
      E_int,E_prom :: REAL, optional, IN

      stdout.flush
      stdout.show("Kinetic energy       =",E_T)
      stdout.show("Exchange energy      =",E_K)
      stdout.show("Kinetic + Exhange    =",E_T+E_K)
      stdout.show("Nuclear attraction   =",E_Z)
      stdout.show("Nuclear repulsion    =",E_N)
      stdout.show("Electronic repulsion =",E_C)
      stdout.show("Net coulomb energy   =",E_Z+E_N+E_C)

      if (present(E_int)) &
      stdout.show("Total int. energy    =",E_int)

      if (present(E_prom)) &
      stdout.show("Promotion energy     =",E_prom)

   end

!  =========================
!  Crystal Explorer energies
!  =========================

   put_group_12_Grimme2006_energy ::: leaky
   ! Calculate the 1-2 dispersion term from Grimme's C6 coefficients
   ! C6 taken from Grimme (2006) J. Comp. Chem.  27(15) p. 1787

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")

      unit :: STR
      E_disp,fac :: REAL
      mol_A, mol_B :: MOLECULE*

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      E_disp = mol_A.atom.Grimme06_dispersion_energy(mol_B.atom)

      ! Convert units to kJmol-1
      unit = "kJ/mol"
      fac = unit.conversion_factor
      E_disp = E_disp * fac

      ! Output energies

      stdout.flush
      stdout.text("===========================================")
      stdout.text("Grimme (2006) atom-atom dispersion energy")
      stdout.text("===========================================")
      stdout.flush
      stdout.text(". See: Grimme (2006) J. Comp. Chem.  27(15) p. 1787")
      stdout.text(". E_disp = sum over atoms (C6 / r^6).")
      stdout.flush
      stdout.show("Grimme06 dispersion energy (kJ/mol) = ", E_disp)

   end


   put_group_12_Spackman1986_energies ::: leaky
   ! Calculate the 1-2 dispersion and repulsion term from atom-atom potentials
   ! See Spackman M. A. (1986) J. Chem. Phys. 85(11) p6579

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")

      unit :: STR
      E_disp,E_rep,fac :: REAL
      mol_A, mol_B :: MOLECULE*

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      E_disp = mol_A.atom.Spackman86_dispersion_energy(mol_B.atom)
      E_rep  = mol_A.atom.Spackman86_repulsion_energy(mol_B.atom)

      ! Convert units to kJmol-1
      unit = "kJ/mol"
      fac = unit.conversion_factor
      E_disp = E_disp * fac
      E_rep  = E_rep * fac

      ! Output energies

      stdout.flush
      stdout.text("==============================================")
      stdout.text("Spackman (1986) atom-atom interaction energies")
      stdout.text("==============================================")
      stdout.flush
      stdout.text(". See: Spackman (1986) JCP 85 p. 6579")
      stdout.text(". Repulsion is an exponential fit to Gordon-Kim")
      stdout.text("  energies, modified for H-bonding and H-H contacts")
      stdout.text(". Dispersion from C6 London-formula-combined atomic")
      stdout.text("  dipole polarizabilities")

      stdout.flush
      stdout.show("Spackman86 dispersion energy (kJ/mol) = ", E_disp)
      stdout.show("Spackman86 repulsion  energy (kJ/mol) = ", E_rep)

   end

   put_group_12_polarization_energy ::: leaky
   ! Calculate the 1-2 polarization term
   ! Atomic polarizabilities from Thakkar and Lupinetti (2006)

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.allocated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.allocated ,"no mol 2 DM!")

      unit :: STR
      E_pol,fac :: REAL
      mol_A, mol_B :: MOLECULE*
      electronic_at_A, nuclear_at_A, total_at_A, electronic_at_B, nuclear_at_B, total_at_B :: MAT{REAL}*
      F_sq_A, F_sq_B :: VEC{REAL}*

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      ! Electric field from B at A
      electronic_at_A.create(3,mol_A.n_atom)
      nuclear_at_A.create(3,mol_A.n_atom)
      total_at_A.create(3,mol_A.n_atom)

      electronic_at_A =  mol_B.INTS:electronic_E_field_at_atoms(mol_A.atom)
      nuclear_at_A    = mol_B.INTS:nuclear_E_field_at_atoms(mol_A.atom)
      total_at_A      = electronic_at_A + nuclear_at_A

      ! Electric field from A at B
      electronic_at_B.create(3,mol_B.n_atom)
      nuclear_at_B.create(3,mol_B.n_atom)
      total_at_B.create(3,mol_B.n_atom)

      electronic_at_B = mol_A.INTS:electronic_E_field_at_atoms(mol_B.atom)
      nuclear_at_B    = mol_A.INTS:nuclear_E_field_at_atoms(mol_B.atom)
      total_at_B      = electronic_at_B + nuclear_at_B

      ! Magnitude of the electric field squared
      F_sq_A.create(total_at_A.dim2)
      F_sq_B.create(total_at_B.dim2)

      F_sq_A = total_at_A.column_norms
      F_sq_A = F_sq_A**2
      F_sq_B = total_at_B.column_norms
      F_sq_B = F_sq_B**2

      ! Polarization Energy
      E_pol = ZERO
      E_pol = E_pol + mol_A.atom.polarization_energy(F_sq_A, &
                        ((mol_A.charge /= 0) AND (mol_A.n_atom == 1)))
      E_pol = E_pol + mol_B.atom.polarization_energy(F_sq_B, &
                        ((mol_B.charge /= 0) AND (mol_B.n_atom == 1)))

      ! Convert units to kJmol-1
      unit = "kJ/mol"
      fac = unit.conversion_factor
      E_pol = E_pol * fac

      ! Output energies

      stdout.flush
      stdout.text("===========================================")
      stdout.text("Atom-atom polarization energy")
      stdout.text("===========================================")
      stdout.flush
      stdout.text(". Atomic dipole polarizabilities from Thakkar and Lupinetti (2006)")
      stdout.flush
      stdout.show("Polarization energy (kJ/mol) = ", E_pol)

      ! Tidy up
      electronic_at_A.destroy
      nuclear_at_A.destroy
      total_at_A.destroy

      electronic_at_B.destroy
      nuclear_at_B.destroy
      total_at_B.destroy

      F_sq_A.destroy
      F_sq_B.destroy

   end

   intermolecular_polarization_energy(mol_B) result(res) ::: leaky
   ! Calculate the 1-2 polarization term
   ! Atomic polarizabilities from Thakkar and Lupinetti (2006)
      self :: PTR
      mol_B :: MOLECULE*
      res :: REAL
   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.allocated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.allocated ,"no mol 2 DM!")

      E_pol :: REAL
      mol_A :: MOLECULE* 
      electronic_at_A, nuclear_at_A, total_at_A, electronic_at_B, nuclear_at_B, total_at_B :: MAT{REAL}*
      F_sq_A, F_sq_B :: VEC{REAL}*

      ! A & B molecules
      mol_A => self

      ! Electric field from B at A
      electronic_at_A.create(3,mol_A.n_atom)
      nuclear_at_A.create(3,mol_A.n_atom)
      total_at_A.create(3,mol_A.n_atom)

      electronic_at_A =  mol_B.INTS:electronic_E_field_at_atoms(mol_A.atom)
      nuclear_at_A    = mol_B.INTS:nuclear_E_field_at_atoms(mol_A.atom)
      total_at_A      = electronic_at_A + nuclear_at_A

      ! Electric field from A at B
      electronic_at_B.create(3,mol_B.n_atom)
      nuclear_at_B.create(3,mol_B.n_atom)
      total_at_B.create(3,mol_B.n_atom)

      electronic_at_B = mol_A.INTS:electronic_E_field_at_atoms(mol_B.atom)
      nuclear_at_B    = mol_A.INTS:nuclear_E_field_at_atoms(mol_B.atom)
      total_at_B      = electronic_at_B + nuclear_at_B

      ! Magnitude of the electric field squared
      F_sq_A.create(total_at_A.dim2)
      F_sq_B.create(total_at_B.dim2)

      F_sq_A = total_at_A.column_norms
      F_sq_A = F_sq_A**2
      F_sq_B = total_at_B.column_norms
      F_sq_B = F_sq_B**2

      ! Polarization Energy
      E_pol = ZERO
      E_pol = E_pol + mol_A.atom.polarization_energy(F_sq_A, &
                        ((mol_A.charge /= 0) AND (mol_A.n_atom == 1)))
      E_pol = E_pol + mol_B.atom.polarization_energy(F_sq_B, &
                        ((mol_B.charge /= 0) AND (mol_B.n_atom == 1)))

      res = E_pol

      ! Tidy up
      electronic_at_A.destroy
      nuclear_at_A.destroy
      total_at_A.destroy

      electronic_at_B.destroy
      nuclear_at_B.destroy
      total_at_B.destroy

      F_sq_A.destroy
      F_sq_B.destroy

   end


   intermolecular_overlap_repulsion(mol_B) result(res)
   ! Calculate the exchange-repulsion energy based on the following
   ! overlap formula (see Soderhjelm et al. JCP 124 (2006) eq. 14)
   ! E = S^2 (1 + 20 e ^(-R))
      self :: PTR
      mol_B :: MOLECULE*
      res :: REAL

      mol_A :: MOLECULE*
      S2 :: REAL
      X, Y :: MAT{REAL}@
      n_a, n_b :: INT

      merged :: MOLECULE*
      MO_a, MO_b :: MAT{REAL}@
      S_ab :: MAT{REAL}*

      mol_A => self
      merged.BASE:create_from_mols(mol_A, mol_B)

      merged.SCF:merge_group_MOs
      merged.scfdata.set_output(FALSE)

      ! Make SCF density matrices
      merged.INTS:make_overlap_matrix


      ! Overlap between phi_i and phi_j
      ! = sum_{a b} c_{a i} S_{ab} c_{b j}
      S2 = ZERO
      n_a = mol_A.occupation_numbers.restricted(1:).index_of_first_zero_value - 1
      n_b = mol_B.occupation_numbers.restricted(1:).index_of_first_zero_value - 1

      allocate(MO_a(merged.n_bf, n_a))
      allocate(MO_b(merged.n_bf, n_b))
      MO_a = ZERO
      MO_b = ZERO
      MO_a(:.n_bf, :) = .molecular_orbitals.restricted(:,1:n_a)
      MO_b(.n_bf+1:, :) = mol_B.molecular_orbitals.restricted(:,1:n_b)
      S_ab => merged.overlap_matrix

      Y = matmul(S_ab, MO_b(:,:))
      X = matmul(transpose(MO_a(:,:)), Y)
      S2 = sum(X*X)

      res = 0.92 * S2
      stdout.show("Overlap repulsion", res)
      nullify(merged.atom_group(1).mol)
      nullify(merged.atom_group(2).mol)
      merged.BASE:destroy

   end

   symmetric_intermolecular_qm_energies(mol_B, monomer_energies) result(res) 
   ! Calculate the group 1-2 interaction energies.
   ! monomer energies is a vector if TWO * -monomer energies
   ! Effectively avoiding calculating the expectations for the
   ! monomers each time
   !!!! IF mol_B and  self are symmetry related !!!!
   ! For simplicity the notations follows the reference:
   ! P. Su & H. Li (2009) JCP 131 p. 014102
   ! It has references to the original work and is explained fairly
   ! clearly, except for their use of "X" for supermolecule (X=AB).
   ! NOTE: make sure the MO's and density matrices for each group exist!

      self :: PTR
      mol_B :: MOLECULE*
      monomer_energies :: VEC{REAL}(4) ! E_en, E_1e, E_ee, E_ex
      res :: VEC{REAL}(2) ! E_coul, E_rep

      ! Terms regardless of unrestricted/restricted
      E_en,E_ke,E_1e,E_nn,E_ee,E_ex,r :: REAL
      E_tot,E_net,E_ABn,E_ABo,E_rep,E_XR :: REAL
      J :: OPMATRIX@
      K :: OPMATRIX@
      mol_A :: MOLECULE*
      saved_MOs_A, saved_MOs_B :: OPMATRIX@
      exchange_factor :: REAL = -HALF

      merged :: MOLECULE*


      ! A & B molecules
      mol_A => self

     mol_A.atom.get_distance_to(mol_B.atom, r)
     ! If the molecules are too far apart use multipoles
     ! Set to use where the minimum separation is nearly 8 A
     if (r > 13.6) then ! 7.2 Angstroms
        res = ZERO
        res(1) = .:intermolecular_coulomb_atomic_multipole_energy(mol_B)
        return
     end



      ! Hacky method to reuse code, should be rewritten
      merged.BASE:create_from_mols(mol_A, mol_B)


      saved_MOs_A = mol_A.molecular_orbitals
      saved_MOs_B = mol_B.molecular_orbitals

      mol_A.molecular_orbitals = mol_A.natural_orbitals
      mol_B.molecular_orbitals = mol_B.natural_orbitals
      mol_A.scfdata.set_scf_kind(mol_A.molecular_orbitals.spinorbital_kind)
      mol_B.scfdata.set_scf_kind(mol_B.molecular_orbitals.spinorbital_kind)

      merged.SCF:merge_group_MOs
      merged.scfdata.set_output(FALSE)
      if (merged.scfdata.is_restricted) then
         exchange_factor = -QUARTER
      end if

      ! Make SCF density matrices
     merged.BASE:make_scf_density_matrix

      ! Make integrals
     merged.SCF:make_core_matrix

      ! >> Nuclear attraction energy << 
     merged.nuclear_attraction_matrix.uncompress

      E_ABn = ZERO; E_ABo = ZERO; 
      E_en = ZERO; E_1e = ZERO;
      E_ex = ZERO; E_nn = ZERO;
      E_ke = ZERO;

      E_en = merged.BASE:expectation(merged.nuclear_attraction_matrix) + monomer_energies(1)

      merged.nuclear_attraction_matrix.compress

      ! Non-orthogonal & orthogonalized electronic energies

      ! >> One electron interaction energy <<
      E_1e = merged.BASE:expectation(merged.core_matrix)
      E_ABn = E_ABn + E_1e
      E_1e = E_1e + monomer_energies(2)
      E_ke = E_1e - E_en

      J.create(merged.n_bf, merged.density_matrix.spinorbital_kind)
      K.create(merged.n_bf, merged.density_matrix.spinorbital_kind)

      merged.FOCK:make_JK_engine(J  ,K  ,merged.density_matrix  )

      ! Alpha density matrix with beta, beta density matrix with alpha
      E_ee = merged.BASE:expectation(J) * HALF
      E_ABn = E_ABn + E_ee
      E_ee = E_ee + monomer_energies(3)
      E_ex = merged.BASE:expectation(K) * exchange_factor
      E_ABn = E_ABn + E_ex
      E_ex = E_ex + monomer_energies(4)


      ! >> Nuclear-nuclear repulsion energy term <<
      E_nn = merged.:group_12_NR_int_energy
      ! >> Electron repulsion energy term <<

      ! >> Total <<
      E_tot = E_ke + E_nn + E_en + E_ee + E_ex
      E_net =        E_nn + E_en + E_ee


      ! ======================
      ! Now symmorthonormalize
      ! ======================

      merged.SCF:symmorthonormalize_occupied_MOs
      merged.BASE:make_scf_density_matrix

      ! One electron hamiltonian
      E_ABo = merged.BASE:expectation(merged.core_matrix)

      ! Two-electron integrals
      J.destroy; K.destroy
      J.create(merged.n_bf, merged.density_matrix.spinorbital_kind)
      K.create(merged.n_bf, merged.density_matrix.spinorbital_kind)

      merged.FOCK:make_JK_engine(J, K, merged.density_matrix)

      E_ABo = E_ABo +    HALF * merged.BASE:expectation(J, TRUE)
      E_ABo = E_ABo + exchange_factor * merged.BASE:expectation(K)
      ! Get repulsion energy
      E_rep = E_ABo - E_ABn ! Accounts for orthogonalization
      E_XR  = E_ex + E_rep


      ! Clean up remaining temporaries

      res = [E_net, E_XR]
      if (abs(E_XR) <0.00001) then
          stdout.show("Extremely small repulsion (could have avoided calculation)", &
                      E_XR * KJOULEMOL_PER_HARTREE)
          stdout.show("E_ele", E_net * KJOULEMOL_PER_HARTREE)
          stdout.show("separation", r * ANGSTROM_PER_BOHR)
      end if

      J.destroy; K.destroy
      merged.molecular_orbitals.destroy
      merged.natural_orbitals.destroy
      merged.density_matrix.destroy

      mol_A.molecular_orbitals = saved_MOs_A
      mol_B.molecular_orbitals = saved_MOs_B

      ! need to destroy but don't want to destroy atom_group
      nullify(merged.atom_group(1).mol)
      nullify(merged.atom_group(2).mol)
      merged.BASE:destroy

   end


   intermolecular_qm_energies(mol_B) result(res)
   ! Calculate the group 1-2 interaction energies.
   ! For simplicity the notations follows the reference:
   ! P. Su & H. Li (2009) JCP 131 p. 014102
   ! It has references to the original work and is explained fairly
   ! clearly, except for their use of "X" for supermolecule (X=AB).
   ! NOTE: make sure the MO's and density matrices for each group exist!
      self :: PTR
      res :: VEC{REAL}(2) ! E_coul, E_rep
      mol_B :: MOLECULE*

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 atom groups")
   ENSURE(.atom_group(1).mol.density_matrix.allocated, "no density matrix for atom group 1")
   ENSURE(.atom_group(2).mol.density_matrix.allocated, "no density matrix for atom group 2")
   ENSURE(.atom_group(1).mol.molecular_orbitals.allocated , "no molecular orbitals for atom group 1")
   ENSURE(.atom_group(2).mol.molecular_orbitals.allocated , "no molecular orbitals for atom group 2")

      ! Terms regardless of unrestricted/restricted
      E_en,E_ke,E_1e,E_nn,E_ee,E_ex,r :: REAL
      E_tot,E_net,E_ABn,E_ABo,E_rep,E_XR :: REAL
      P :: OPMATRIX@ 
      J,J_A,J_B :: OPMATRIX@
      K,K_A,K_B :: OPMATRIX@
      mol_A :: MOLECULE*
      saved_MOs_A, saved_MOs_B :: OPMATRIX@
      exchange_factors :: VEC{REAL}(3) = [-HALF, -HALF, -HALF]

      merged :: MOLECULE*


      ! A & B molecules
      mol_A => self

      mol_A.atom.get_distance_to(mol_B.atom, r)
      ! If the molecules are too far apart use multipoles
      ! Set to use where the minimum separation is approximately 6.35 Angstrom
      if (r > 13.6) then ! 7.2 Angstroms
         res = ZERO
         res(1) = .:intermolecular_coulomb_atomic_multipole_energy(mol_B)
         return
      end

      ! Hacky method to reuse code, should be rewritten
      merged.BASE:create_from_mols(mol_A, mol_B)

      mol_A.INTS:make_overlap_matrix
      mol_A.BASE:make_natural_orbitals
      mol_B.INTS:make_overlap_matrix
      mol_B.BASE:make_natural_orbitals

      saved_MOs_A = mol_A.molecular_orbitals
      saved_MOs_B = mol_B.molecular_orbitals

      mol_A.molecular_orbitals = mol_A.natural_orbitals
      mol_B.molecular_orbitals = mol_B.natural_orbitals
      mol_A.scfdata.set_scf_kind(mol_A.molecular_orbitals.spinorbital_kind)
      mol_B.scfdata.set_scf_kind(mol_B.molecular_orbitals.spinorbital_kind)

      merged.SCF:merge_group_MOs
      merged.scfdata.set_output(FALSE)
      if (merged.scfdata.is_restricted) then
         exchange_factors = -QUARTER
      end if

      if (mol_A.molecular_orbitals.spinorbital_kind == "restricted") exchange_factors(2) = -QUARTER
      if (mol_B.molecular_orbitals.spinorbital_kind == "restricted") exchange_factors(3) = -QUARTER

      ! Make SCF density matrices
     merged.BASE:make_scf_density_matrix
      mol_A.BASE:make_scf_density_matrix
      mol_B.BASE:make_scf_density_matrix

      ! Make integrals
     merged.SCF:make_core_matrix
      mol_A.SCF:make_core_matrix
      mol_B.SCF:make_core_matrix

      ! >> Nuclear attraction energy << 
     merged.nuclear_attraction_matrix.uncompress
      mol_A.nuclear_attraction_matrix.uncompress
      mol_B.nuclear_attraction_matrix.uncompress

      E_ABn = ZERO; E_ABo = ZERO; 
      E_en = ZERO; E_1e = ZERO;
      E_ex = ZERO; E_nn = ZERO;
      E_ke = ZERO;

      E_en = merged.:group_12_int_energy(merged.nuclear_attraction_matrix, mol_A.nuclear_attraction_matrix, mol_B.nuclear_attraction_matrix)

      merged.nuclear_attraction_matrix.compress
      mol_A.nuclear_attraction_matrix.compress
      mol_B.nuclear_attraction_matrix.compress

      ! Non-orthogonal & orthogonalized electronic energies

      ! >> One electron interaction energy <<
      E_1e = merged.:group_12_int_energy(P, mol_A.core_matrix, mol_B.core_matrix, E_AB=E_ABn)
      E_ke = E_1e - E_en

      J.create(merged.n_bf, merged.density_matrix.spinorbital_kind)
      K.create(merged.n_bf, merged.density_matrix.spinorbital_kind)
      J_A.create(mol_A.n_bf, mol_A.density_matrix.spinorbital_kind)
      K_A.create(mol_A.n_bf, mol_A.density_matrix.spinorbital_kind)
      J_B.create(mol_B.n_bf, mol_B.density_matrix.spinorbital_kind)
      K_B.create(mol_B.n_bf, mol_B.density_matrix.spinorbital_kind)


      ! Two-electron matrices
      merged.FOCK:make_JK_engine(J  ,K  ,merged.density_matrix)
      mol_A.FOCK:make_JK_engine(J_A,K_A,mol_A.density_matrix)
      mol_B.FOCK:make_JK_engine(J_B,K_B,mol_B.density_matrix)

      ! Alpha density matrix with beta, beta density matrix with alpha
      E_ee = merged.:group_12_int_energy(J, J_A, J_B, HALF, E_ABn, TRUE)
      E_ex = merged.:group_12_exchange_int_energy(K, K_A, K_B, exchange_factors, E_ABn)

      K_A.destroy; K_B.destroy
      J_A.destroy; J_B.destroy  

      ! >> Nuclear-nuclear repulsion energy term <<
      E_nn = merged.:group_12_NR_int_energy
      ! >> Electron repulsion energy term <<

      ! >> Total <<
      E_tot = E_ke + E_nn + E_en + E_ee + E_ex
      E_net =        E_nn + E_en + E_ee

      ! ======================
      ! Now symmorthonormalize
      ! ======================

      merged.SCF:symmorthonormalize_occupied_MOs
      merged.BASE:make_scf_density_matrix

      ! One electron hamiltonian
      E_ABo = merged.BASE:expectation(merged.core_matrix)

      ! Two-electron integrals
      J.destroy; K.destroy
      J.create(merged.n_bf, merged.density_matrix.spinorbital_kind)
      K.create(merged.n_bf, merged.density_matrix.spinorbital_kind)

      merged.FOCK:make_JK_engine(J, K, merged.density_matrix)

      E_ABo = E_ABo +    HALF * merged.BASE:expectation(J, TRUE)
      E_ABo = E_ABo + exchange_factors(1) * merged.BASE:expectation(K)

      ! Get repulsion energy
      E_rep = E_ABo - E_ABn ! Accounts for orthogonalization
      E_XR  = E_ex + E_rep

      ! Clean up remaining temporaries
      J.destroy; K.destroy

      res = [E_net, E_XR]
      ! In kJ/mol
      mol_A.natural_orbitals.destroy
      mol_B.natural_orbitals.destroy
      mol_A.molecular_orbitals = saved_MOs_A
      mol_B.molecular_orbitals = saved_MOs_B
      merged.molecular_orbitals.destroy
      merged.natural_orbitals.destroy
      merged.density_matrix.destroy
    end 

   put_group_12_energies ::: leaky
   ! Calculate the classical and QM group 1-2 interaction energies.
   ! NOTE: make sure the density matrices and MOs for each group exist!
   ! e.g. by reading gaussian or by "make_group_density_matrix"
      self :: INOUT
      .:put_group_12_QM_energies
   end

   put_group_12_multipole_energies ::: leaky
   ! Calculate the interaction (coulomb) energy with multipoles
      self :: INOUT
      ! A & B molecules
      E :: VEC{REAL}(5)
      E_tot :: REAL
      .PROP:make_coulomb_atomic_multipole_energy(E, E_tot)
      stdout.flush
      stdout.text("===========================================")
      stdout.text("Atom-atom multipole coulomb energy ")
      stdout.text("===========================================")
      stdout.flush
      stdout.text("Up to and including octapole-charge/quadrupole-dipole interactions")
      stdout.flush
      stdout.show("Charge-charge                         = ", E(1), right=TRUE)
      stdout.show("Charge-dipole                         = ", E(2), right=TRUE)
      stdout.show("Charge-quadrupole/dipole-dipole       = ", E(3), right=TRUE)
      stdout.show("Charge-octapole/quadrupole-dipole     = ", E(4), right=TRUE)
      stdout.show("quadrupole-quadrupole/dipole-octapole = ", E(5), right=TRUE)
      stdout.show("E_coulomb (multipole)                 = ",E_tot,right=TRUE)
      stdout.show("E_coulomb (multipole) (kJ/mol)        = ",E_tot.to_units("kJ/mol"),right=TRUE)
      stdout.text("The following are shown for crystalexplorer")
      stdout.text("the only calculated value is the coulomb term")
      stdout.show("Delta E_repulsion (kJ/mol)            = ",ZERO,right=TRUE)
      stdout.show("Delta E_ee-exchange (kJ/mol)          = ",ZERO,right=TRUE)
      stdout.show("Delta E_exch-rep (kJ/mol)             = ",ZERO,right=TRUE)
      stdout.show("Delta E_coul (kJ/mol)                 = ",E_tot.to_units("kJ/mol"),right=TRUE)


      stdout.flush
   end

   make_coulomb_multipole_energy(E, E_tot)
   ! Make the intermolecular coulomb repulsion energy using
   ! multipoles. Assumes there are two atom groups present.
      self :: INOUT
      E :: VEC{REAL}(5), OUT
      E_tot :: REAL, OUT

      ! A & B molecules
      mol_A,mol_B :: MOLECULE*
      q_a, q_b :: REAL
      m_a, m_b :: VEC{REAL}(3)
      Qu_a, Qu_b :: MAT{REAL}(3,3)
      O_a, O_b :: MAT3{REAL}(3,3,3)
      T :: T_TENSOR

      E = ZERO
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol
      m_a = mol_A.PROP:make_dipole
      m_b = mol_B.PROP:make_dipole
      Qu_a = mol_A.PROP:make_quadrupole
      Qu_b = mol_B.PROP:make_quadrupole
      O_a = mol_A.PROP:make_octupole
      O_b = mol_B.PROP:make_octupole
      T.create(mol_A.atom.center_of_mass, mol_B.atom.center_of_mass)
      q_a = mol_A.charge
      q_b = mol_B.charge
      E = T.interaction_energy(q_a, q_b, m_a, m_b, Qu_a, Qu_b, O_a, O_b)
      E_tot = sum(E)

   end 

   make_coulomb_atomic_multipole_energy(E, E_tot)
   ! ???
      self :: INOUT
      E :: VEC{REAL}(5), OUT
      E_tot :: REAL, OUT

      ! A & B molecules
      mol_A,mol_B :: MOLECULE*
      charges_a :: VEC{REAL}*
      dipoles_a, quadrupoles_a, octupoles_a :: MAT{REAL}*
      charges_b :: VEC{REAL}*
      dipoles_b, quadrupoles_b, octupoles_b :: MAT{REAL}*
      q_a, q_b :: REAL
      m_a, m_b :: VEC{REAL}(3)
      Qu_a, Qu_b :: MAT{REAL}(3,3)
      O_a, O_b :: MAT3{REAL}(3,3,3)
      i, j :: INT
      T :: T_TENSOR

      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      charges_a.create(mol_A.n_atom)
      dipoles_a.create(mol_A.n_atom, 3)
      quadrupoles_a.create(mol_A.n_atom, 6)
      octupoles_a.create(mol_A.n_atom, 10)
      charges_b.create(mol_B.n_atom)
      dipoles_b.create(mol_B.n_atom, 3)
      quadrupoles_b.create(mol_B.n_atom, 6)
      octupoles_b.create(mol_B.n_atom, 10)

      mol_A.BASE:make_atomic_multipoles(charges_a,dipoles_a,quadrupoles_a,octupoles_a)
      mol_B.BASE:make_atomic_multipoles(charges_b,dipoles_b,quadrupoles_b,octupoles_b)
      E = ZERO

      do i = 1, mol_A.n_atom
         q_a = mol_A.atom(i).atomic_number - charges_a(i)
         m_a = dipoles_a(i,:)
         Qu_a = MAT{REAL}:expand_quadrupole(quadrupoles_a(i,:))
         O_a = MAT3{REAL}:expand_octupole(octupoles_a(i,:))

      do j = 1, mol_B.n_atom
         q_b = mol_B.atom(j).atomic_number - charges_b(j)
         m_b = dipoles_b(j,:)
         Qu_b = MAT{REAL}:expand_quadrupole(quadrupoles_b(j,:))
         O_b = MAT3{REAL}:expand_octupole(octupoles_b(j,:))

         T.create(mol_A.atom(i).position, mol_B.atom(j).position)
         E = E + T.interaction_energy(q_a, q_b, m_a, m_b, Qu_a, Qu_b, O_a, O_b)
      end do
      end do
      E_tot = sum(E)
      charges_a.destroy; charges_b.destroy
      dipoles_a.destroy; dipoles_b.destroy
      quadrupoles_a.destroy; charges_b.destroy
      octupoles_a.destroy; charges_b.destroy
   end 

   intermolecular_coulomb_atomic_multipole_energy(mol_B) result(E_coul)
      self :: PTR
      E_coul :: REAL
      ! A & B molecules
      mol_B :: MOLECULE*
      ENSURE(.charges.associated, "no atomic charge information")
      ENSURE(.dipoles.associated, "no atomic dipole information")
      ENSURE(.quadrupoles.associated, "no atomic quadrupole information")
      ENSURE(.octupoles.associated, "no atomic octupole information")
      ENSURE(mol_B.charges.associated, "no atomic charge information")
      ENSURE(mol_B.dipoles.associated, "no atomic dipole information")
      ENSURE(mol_B.quadrupoles.associated, "no atomic quadrupole information")
      ENSURE(mol_B.octupoles.associated, "no atomic octupole information")



      E :: VEC{REAL}(5)
      mol_A :: MOLECULE*
      q_a, q_b :: REAL
      m_a, m_b :: VEC{REAL}(3)
      Qu_a, Qu_b :: MAT{REAL}(3,3)
      O_a, O_b :: MAT3{REAL}(3,3,3)
      i, j :: INT
      T :: T_TENSOR

      mol_A => self

      E = ZERO

      do i = 1, mol_A.n_atom
         q_a = mol_A.atom(i).atomic_number - mol_A.charges(i)
         m_a = mol_A.dipoles(i,:)
         Qu_a = MAT{REAL}:expand_quadrupole(mol_A.quadrupoles(i,:))
         O_a = MAT3{REAL}:expand_octupole(mol_A.octupoles(i,:))

      do j = 1, mol_B.n_atom
         q_b = mol_B.atom(j).atomic_number - mol_B.charges(j)
         m_b = mol_B.dipoles(j,:)
         Qu_b = MAT{REAL}:expand_quadrupole(mol_B.quadrupoles(j,:))
         O_b = MAT3{REAL}:expand_octupole(mol_B.octupoles(j,:))

         T.create(mol_A.atom(i).position, mol_B.atom(j).position)
         E = E + T.interaction_energy(q_a, q_b, m_a, m_b, Qu_a, Qu_b, O_a, O_b)
      end do
      end do
      E_coul = sum(E)
   end 



   put_group_12_QM_energies ::: leaky
   ! Calculate the group 1-2 interaction energies.
   ! For simplicity the notations follows the reference:
   ! P. Su & H. Li (2009) JCP 131 p. 014102
   ! It has references to the original work and is explained fairly
   ! clearly, except for their use of "X" for supermolecule (X=AB).
   ! NOTE: make sure the MO's and density matrices for each group exist!
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 atom groups")
   ENSURE(.atom_group(1).mol.density_matrix.allocated, "no density matrix for atom group 1")
   ENSURE(.atom_group(2).mol.density_matrix.allocated, "no density matrix for atom group 2")
   ENSURE(.atom_group(1).mol.molecular_orbitals.allocated , "no molecular orbitals for atom group 1")
   ENSURE(.atom_group(2).mol.molecular_orbitals.allocated , "no molecular orbitals for atom group 2")

      ! Terms regardless of unrestricted/restricted
      E_en,E_ke,E_1e,E_nn,E_ee,E_ex,r :: REAL
      E_tot,E_net,E_ABn,E_ABo,E_rep,E_XR :: REAL
      J,J_A,J_B :: OPMATRIX@
      K,K_A,K_B :: OPMATRIX@
      mol_A,mol_B :: MOLECULE*
      saved_MOs_A, saved_MOs_B :: OPMATRIX@
      exchange_factors :: VEC{REAL}(3) = [-HALF, -HALF, -HALF]
      a_b :: VEC{REAL}(3)


      ! ======================
      ! Get non orthogonal MOs
      ! ======================

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      a_b = mol_A.atom.center_of_mass - mol_B.atom.center_of_mass
      r = a_b.norm
      ! If the molecules are too far apart use multipoles
      if (r.to_units("ANGSTROMS") > 12.0d0) then
         .PROP:put_group_12_multipole_energies
         return
      end

      mol_A.INTS:make_overlap_matrix
      mol_A.BASE:make_natural_orbitals
      mol_B.INTS:make_overlap_matrix
      mol_B.BASE:make_natural_orbitals

      saved_MOs_A = mol_A.molecular_orbitals
      saved_MOs_B = mol_B.molecular_orbitals

      mol_A.molecular_orbitals = mol_A.natural_orbitals
      mol_B.molecular_orbitals = mol_B.natural_orbitals
      mol_A.scfdata.set_scf_kind(mol_A.molecular_orbitals.spinorbital_kind)
      mol_B.scfdata.set_scf_kind(mol_B.molecular_orbitals.spinorbital_kind)

      .SCF:merge_group_MOs
      .scfdata.set_output(FALSE)
      if (.scfdata.is_restricted) then
         exchange_factors = -QUARTER
      end if

      if (mol_A.molecular_orbitals.spinorbital_kind == "restricted") exchange_factors(2) = -QUARTER
      if (mol_B.molecular_orbitals.spinorbital_kind == "restricted") exchange_factors(3) = -QUARTER

      ! Make SCF density matrices
           .BASE:make_scf_density_matrix
      mol_A.BASE:make_scf_density_matrix
      mol_B.BASE:make_scf_density_matrix

      ! Make integrals
           .SCF:make_core_matrix
      mol_A.SCF:make_core_matrix
      mol_B.SCF:make_core_matrix

      ! >> Nuclear attraction energy << 
           .nuclear_attraction_matrix.uncompress
      mol_A.nuclear_attraction_matrix.uncompress
      mol_B.nuclear_attraction_matrix.uncompress

      E_ABn = ZERO; E_ABo = ZERO; 
      E_en = ZERO; E_1e = ZERO;
      E_ex = ZERO; E_nn = ZERO;
      E_ke = ZERO;

      E_en = .:group_12_int_energy(.nuclear_attraction_matrix, mol_A.nuclear_attraction_matrix, mol_B.nuclear_attraction_matrix)

           .nuclear_attraction_matrix.compress
      mol_A.nuclear_attraction_matrix.compress
      mol_B.nuclear_attraction_matrix.compress

      ! Non-orthogonal & orthogonalized electronic energies

      ! >> One electron interaction energy <<
      E_1e = .:group_12_int_energy(.core_matrix, mol_A.core_matrix, mol_B.core_matrix, E_AB=E_ABn)
      E_ke = E_1e - E_en

      J.create(.n_bf, .density_matrix.spinorbital_kind)
      K.create(.n_bf, .density_matrix.spinorbital_kind)
      J_A.create(mol_A.n_bf, mol_A.density_matrix.spinorbital_kind)
      K_A.create(mol_A.n_bf, mol_A.density_matrix.spinorbital_kind)
      J_B.create(mol_B.n_bf, mol_B.density_matrix.spinorbital_kind)
      K_B.create(mol_B.n_bf, mol_B.density_matrix.spinorbital_kind)

           .FOCK:make_JK_engine(J  ,K  ,.density_matrix  )
      mol_A.FOCK:make_JK_engine(J_A,K_A,mol_A.density_matrix)
      mol_B.FOCK:make_JK_engine(J_B,K_B,mol_B.density_matrix)

      ! Alpha density matrix with beta, beta density matrix with alpha
      E_ee = .:group_12_int_energy(J, J_A, J_B, HALF, E_ABn, TRUE)
      E_ex = .:group_12_exchange_int_energy(K, K_A, K_B, exchange_factors, E_ABn)

      K_A.destroy; K_B.destroy
      J_A.destroy; J_B.destroy  

      ! >> Nuclear-nuclear repulsion energy term <<
      E_nn = .:group_12_NR_int_energy
      ! >> Electron repulsion energy term <<

      ! >> Total <<
      E_tot = E_ke + E_nn + E_en + E_ee + E_ex
      E_net =        E_nn + E_en + E_ee

      ! ======================
      ! Now symmorthonormalize
      ! ======================

      .SCF:symmorthonormalize_occupied_MOs
      .BASE:make_scf_density_matrix

      ! One electron hamiltonian
      E_ABo = .BASE:expectation(.core_matrix)

      ! Two-electron integrals
      J.destroy; K.destroy
      J.create(.n_bf, .density_matrix.spinorbital_kind)
      K.create(.n_bf, .density_matrix.spinorbital_kind)

      .FOCK:make_JK_engine(J, K, .density_matrix)

      E_ABo = E_ABo +    HALF*.BASE:expectation(J, TRUE)
      E_ABo = E_ABo + exchange_factors(1)*.BASE:expectation(K)

      ! Get repulsion energy
      E_rep = E_ABo - E_ABn ! Accounts for orthogonalization
      E_XR  = E_ex + E_rep

      ! Clean up remaining temporaries
      J.destroy; K.destroy

      stdout.flush
      stdout.text("=======================================")
      stdout.text("Quantum mechanical interaction energies")
      stdout.text("=======================================")
      stdout.flush
      stdout.text(". E_pro-supermol(non-orthog) = E(Psi) where Psi = Psi_1 Psi_2")
      stdout.text(". is the non-orthogonal pro-supermolecule product wavefunction")
      stdout.flush
      stdout.text(". E_pro-supermol(orthog) = E(Psi) where Psi = A(Psi_1 Psi_2)")
      stdout.text("  is the antisymmetrized normalized pro-supermolecule wavefunction")
      stdout.flush
      stdout.text(". Delta E_X = E_X(Psi) - E_X(Psi_1) - E_X(Psi_2) where the")
      stdout.text("  terms on the right are calculated as  expectation values of")
      stdout.text("  of operators X which are the subterms of the Hamiltonian")
      stdout.flush
      stdout.text(". This dcomposition was first defined by Kitaura & Morokuma.")
      stdout.text("  The code follows: P. Su and H. Li (2009) JCP 131 p. 014102.")
      stdout.text("  See there for references, or Stone's 'Intermolecular Forces'.")
      stdout.flush
      stdout.text(". NOTE: E_pro-supermol(orthog) is the only QM valid number since")
      stdout.text("  it arises from an antisymmetric wavefunction; however the non-")
      stdout.text("  orthogonal promolecule does produce good electronic densities")
      stdout.text("  for use in X-ray crystallography, so the sub terms which come")
      stdout.text("  from it, produce here, may also be reasonable.")
      stdout.flush
      stdout.text(". NOTE: The energies here always apply to determinant orbital")
      stdout.text("  wavefunctions NOT correlated density matrices. However for")
      stdout.text("  correlated wavefunctions the highest occupied natural orbitals")
      stdout.text("  (HONOs) are used instead of the molecular orbitals (MOs).")

      stdout.flush
      stdout.show("Separation (Å)                        = ", r.to_units("ANGSTROMS"), right=TRUE)
      stdout.show("1. Delta E_kinetic-energy             = ",E_ke ,right=TRUE)
      stdout.show("2. Delta E_nn-repulsion               = ",E_nn ,right=TRUE)
      stdout.show("3. Delta E_en-attraction              = ",E_en ,right=TRUE)
      stdout.show("4. Delta E_ee-repulsion               = ",E_ee,right=TRUE)
      stdout.show("5. Delta E_ee-exchange                = ",E_ex,right=TRUE)
      stdout.flush
      stdout.show("6. E_pro-supermol(non-orthog)         = ",E_ABn,right=TRUE)
      stdout.show("7. E_pro-supermol(orthog)             = ",E_ABo,right=TRUE)
      stdout.flush
      stdout.show("Delta E         (1+2+3+4+5)           = ",E_tot,right=TRUE)
      stdout.show("Delta E_coulomb   (2+3+4)             = ",E_net,right=TRUE)
      stdout.show("Delta E_repulsion        (-6+7)       = ",E_rep,right=TRUE)
      stdout.show("Delta E_exch-repulsion  (5-6+7)       = ",E_XR ,right=TRUE)

      ! In kJ/mol
      E_net = E_net.to_units("kJ/mol")
      E_ex  = E_ex.to_units("kJ/mol")
      E_rep = E_rep.to_units("kJ/mol")
      E_XR  = E_XR.to_units("kJ/mol")

      stdout.flush
      stdout.show("Delta E_coul (kJ/mol)                 = ",E_net,right=TRUE)
      stdout.show("Delta E_ee-exchange (kJ/mol)          = ",E_ex,right=TRUE)
      stdout.show("Delta E_repulsion (kJ/mol)            = ",E_rep,right=TRUE)
      stdout.show("Delta E_exch-rep (kJ/mol)             = ",E_XR ,right=TRUE)

      mol_A.natural_orbitals.destroy
      mol_B.natural_orbitals.destroy
      mol_A.molecular_orbitals = saved_MOs_A
      mol_B.molecular_orbitals = saved_MOs_B

   end

   group_12_int_energy(X,X_A,X_B,fac,E_AB,with_cross_terms) result (res) ::: private
   ! Return the group 1-2 interaction energy for one electron
   ! operators for the total system "X" and subsystems "XA" and "XB",
   ! in the supermolecule and subsystem bases, respectively.
   ! If present, "E_AB" is incremented with the expectation of "X".
   ! If present, overall factor "fac" is included.
      self :: IN
      X    :: OPMATRIX, IN
      X_A  :: OPMATRIX, IN
      X_B  :: OPMATRIX, IN
      fac  :: REAL, optional, IN
      E_AB :: REAL, optional, INOUT
      with_cross_terms :: BIN, optional
      res  :: REAL


   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")

      E, E_A, E_B :: REAL
      mol_A,mol_B :: MOLECULE*

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      ! Energies
      E   =      .BASE:expectation(X, with_cross_terms)
      E_A = mol_A.BASE:expectation(X_A, with_cross_terms)
      E_B = mol_B.BASE:expectation(X_B, with_cross_terms)

      ! Interaction energy
      res = (E - (E_A + E_B))

      if (present(fac))  res = fac*res

      if (present(E_AB)) then
         if (present(fac)) then; E_AB = E_AB + fac*E
         else;                 ; E_AB = E_AB +     E
         end
      end
   end

   group_12_exchange_int_energy(X,X_A,X_B,factors,E_AB,with_cross_terms) result (res) ::: private
   ! Return the group 1-2 interaction energy for one electron
   ! operators for the total system "X" and subsystems "XA" and "XB",
   ! in the supermolecule and subsystem bases, respectively.
   ! If present, "E_AB" is incremented with the expectation of "X".
   ! If present, overall factor "fac" is included.
      self :: IN
      X    :: OPMATRIX, IN
      X_A  :: OPMATRIX, IN
      X_B  :: OPMATRIX, IN
      factors  :: VEC{REAL}(3), optional, IN
      E_AB :: REAL, optional, INOUT
      with_cross_terms :: BIN, optional
      res :: REAL


   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")

      E, E_A, E_B :: REAL
      fac :: VEC{REAL}(3) = [1.0, 1.0, 1.0]
      mol_A,mol_B :: MOLECULE*

      if (present(factors)) fac = factors

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol
      
      ! Energies
      E   =      .BASE:expectation(X, with_cross_terms)
      E_A = mol_A.BASE:expectation(X_A, with_cross_terms)
      E_B = mol_B.BASE:expectation(X_B, with_cross_terms)

      ! Interaction energy
      res = fac(1) * E - (fac(2) * E_A + fac(3) * E_B)

      if (present(E_AB)) then
         E_AB = E_AB + (E * fac(1))
      end
   end

   group_12_NR_int_energy result (res) ::: private
   ! Return the group 1-2 nuclear-repulsion interaction energy.
      self :: IN
      res :: REAL

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim==2 ,"must have only 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.allocated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.allocated ,"no mol 2 DM!")

      E,E_A,E_B :: REAL
      mol_A,mol_B :: MOLECULE*

      ! A & B molecules
      mol_A => .atom_group(1).mol
      mol_B => .atom_group(2).mol

      ! Nuclear-nuclear repulsion energies
      E   =      .BASE:nuclear_repulsion_energy
      E_A = mol_A.BASE:nuclear_repulsion_energy
      E_B = mol_B.BASE:nuclear_repulsion_energy

      ! Interaction energy
      res   = E - (E_A + E_B)

   end

!  ==================
!  Atom group setting
!  ==================

   atom_group_AO_subspace_set(P,Q,row_group,col_group)
   ! Set P=Q only for the block whose rows correspond to basis functions
   ! on the atoms in the atom group "row_group" and whose columns are
   ! on the atoms in the atom group "col_group", as given in the
   ! .atom_group array vector.
      P,Q :: MAT{REAL}
      row_group,col_group :: INT

   ENSURE(P.dim1==.n_bf,"wrong size for P")
   ENSURE(P.dim2==.n_bf,"wrong size for P")
   ENSURE(Q.dim1==.n_bf,"wrong size for Q")
   ENSURE(Q.dim2==.n_bf,"wrong size for Q")
   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(row_group<=size(.atom_group),"no such row group")
   ENSURE(col_group<=size(.atom_group),"no such column group")
   ENSURE(row_group>0,"row group index must be positive")
   ENSURE(col_group>0,"column group index must be positive")

      i_a,i_b,a,b,fa,fb,la,lb :: INT

      do i_a = 1,.atom_group(row_group).atom_index.dim
      do i_b = 1,.atom_group(col_group).atom_index.dim

         a = .atom_group(row_group).atom_index(i_a)
         b = .atom_group(col_group).atom_index(i_b)

         fa = .first_basis_fn_for_atom(a)
         fb = .first_basis_fn_for_atom(b)
         la = .last_basis_fn_for_atom(a)
         lb = .last_basis_fn_for_atom(b)

         P(fa:la,fb:lb) = Q(fa:la,fb:lb)

      end
      end

   end

!  =====================
!  Roby analysis methods
!  =====================

   roby_analysis ::: leaky
   ! Do one of the many kind of Roby population analysis
      self :: INOUT

   ENSURE(.roby.associated,"no robydata= supplied")
   ENSURE(.density_matrix.allocated,"no density")

      allowed_kind :: BIN

      allowed_kind = .density_matrix.spinorbital_kind==  "restricted" &
                  OR .density_matrix.spinorbital_kind=="unrestricted"

      DIE_IF(NOT allowed_kind,"only restricted or unrestricted densities are allowed")

      ! Set up ANOs/NAOs
      .SCF:make_ANO_data
      .SCF:make_NAOs

      ! If there are atom_groups use them as default groups
      if (.roby.atom_group.destroyed) then
      if (.atom_group.associated) then
      if (.atom_group.has_atom_indices) then
         .roby.atom_group => .atom_group.atom_lists
      end
      end
      end

      ! Set defaults (density_matrix, etc.)
      .roby.set_defaults(self)

      ! What to do?
      select case (.roby.roby_kind)

      case("atom_bond_analysis       ")
         .roby.atom_bond_analysis

      case("atom_energy_bond_analysis")
         DIE_IF(.fock_matrix.deallocated,"no fock_matrix")
         .roby.atom_energy_bond_analysis

      case("atom_hyper_analysis       ")
         .roby.atom_hyper_analysis

      case("group_bond_analysis      ")
         .roby.group_bond_analysis

      case("group_hyper_analysis      ")
         .roby.group_hyper_analysis

      case default
         UNKNOWN(.roby.roby_kind)

      end

   end

   put_KM_atom_multipoles
   ! Put the KM multipoles
      ENSURE(.basis_info_made,"no basis info")
      ENSURE(.atom.associated,"no atom list")
      ENSURE(.density_matrix.allocated,"no density_matrix")
      ENSURE(.density_matrix.restricted.allocated,"no restricted density_matrix")
      ENSURE(NOT .use_spherical_basis,"not implememnted for spherical")

      charge :: VEC{REAL}*
      dipole, quadrupole, octupole :: MAT{REAL}*
      a :: INT
      dp :: REAL

      charge.create(.n_atom)
      dipole.create(.n_atom, 3)
      quadrupole.create(.n_atom, 6)
      octupole.create(.n_atom, 10)
      .BASE:make_atomic_multipoles(charge,dipole,quadrupole,octupole)

      stdout.flush
      stdout.text("Koritsanszky-Michael atomic populations: ")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=5)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Charge")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush
      charge(:) = .atom(:).atomic_number - charge(:) ! <<< redefine charge
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(charge(a))
         stdout.put(dipole(a,1))
         stdout.put(dipole(a,2))
         stdout.put(dipole(a,3))
         dp = dipole(a,:).norm
         stdout.put(dp)
         stdout.flush
      end
      stdout.dash(int_fields=1, real_fields=6)
      stdout.flush

      ! Write results in au
      stdout.flush
      stdout.text("Koritsanszky-Michael quadrupole moments (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Qxx")
      stdout.put("Qyy")
      stdout.put("Qzz")
      stdout.put("Qxy")
      stdout.put("Qxz")
      stdout.put("Qyz")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(quadrupole(a,1))
         stdout.put(quadrupole(a,2))
         stdout.put(quadrupole(a,3))
         stdout.put(quadrupole(a,4))
         stdout.put(quadrupole(a,5))
         stdout.put(quadrupole(a,6))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)

      ! Write results in au
      stdout.flush
      stdout.text("Koritsanszky-Michael octupole moments (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=10)
      stdout.tab(int_fields=1)
      stdout.put("Oxxx")
      stdout.put("Oyyy")
      stdout.put("Ozzz")
      stdout.put("Oxxy")
      stdout.put("Oxxz")
      stdout.put("Oyyx")
      stdout.put("Oyyz")
      stdout.put("Ozzx")
      stdout.put("Ozzy")
      stdout.put("Oxyz")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=10)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(octupole(a,1))
         stdout.put(octupole(a,2))
         stdout.put(octupole(a,3))
         stdout.put(octupole(a,4))
         stdout.put(octupole(a,5))
         stdout.put(octupole(a,6))
         stdout.put(octupole(a,7))
         stdout.put(octupole(a,8))
         stdout.put(octupole(a,9))
         stdout.put(octupole(a,10))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=10)

      quadrupole.destroy
      charge.destroy
      dipole.destroy

   end

!  =============
!  Bader methods
!  =============

   get_Bader_regions
   ! Calculate the electron density and integrate
      self :: IN

   ENSURE(.plot_grid.associated,"No plot_grid!")

      n,nx,ny,nz :: INT
      axes :: MAT{REAL}(3,3)
      CP :: MAT3{INT}*
      EDS,VOL :: VEC{REAL}*
      grid :: VEC{REAL}*
      g3 :: MAT3{REAL}*
      pt :: MAT{REAL}*
#ifdef MPI      
      CP1 :: MAT4{INT}*
#endif      

      nx = .plot_grid.n_x
      ny = .plot_grid.n_y
      nz = .plot_grid.n_z
      n  = .plot_grid.n_pt

      ! Make space for grid values and grid points
      g3.create(nx,ny,nz)
      grid.create(n)
      pt.create(n,3)
      
      ! Make the grid points
      .plot_grid.make_points(pt)
      
      ! Make the ED grid values
      .GRID:make_density_grid_r(grid,pt)

      ! Clean up
      pt.destroy

      ! Do it
      axes = .plot_grid.plot_axes

      g3=reshape(grid,[nx,ny,nz])
#ifdef MPI
      call cubes_to_basin_parallel(g3,nx,ny,nz,.plot_grid.width,axes,CP1,EDS,VOL)
#else
      call cubes_to_basin(g3,nx,ny,nz,.plot_grid.width,axes,CP,EDS,VOL)
#endif


      ! Clean
      VOL.destroy
      EDS.destroy
      CP.destroy
      g3.destroy

   end

   cubes_to_basin(grid,nx,ny,nz,gridlength,gridvector,CP,EDS,VOL) ::: leaky, selfless
   ! A tonto implementation of the cubes to basin code, originally
   ! implemented by Florian from Tobias (spelling).
    nx,ny,nz :: INT, IN
    grid :: MAT3{REAL}, IN
    gridlength :: VEC{REAL}(3), IN
    gridvector :: MAT{REAL}(3,3), IN
    CP :: MAT3{INT}*, OUT
    EDS,VOL :: VEC{REAL}*, OUT

    i,x,y,z,xs,ys,zs,ix,iy,iz,ListMax,iCP :: INT
    GradMax,distance,MaxVal,dv,t1,t2,t3 :: REAL
    Max :: VEC{INT}(3)
    List :: VEC{VEC_{INT}}*
    ED :: MAT3{REAL}*
    Maxima :: VEC{REAL}*

    ED.create(nx+2,ny+2,nz+2)
    CP.create(nx+2,ny+2,nz+2)
    Maxima.create(1)
    
    ED = ZERO
    ED(2:nx+1,2:ny+1,2:nz+1)=grid 
    CP = ZERO
    iCP = ZERO
    GradMax = 1

    call cpu_time(t1)
    
    do x=2,nx+1
    do y=2,ny+1
    do z=2,nz+1
       if (CP(x,y,z) == ZERO) then
       ! Only perform if critical direction not known
          List.create(3,0)
          ListMax = 0
          ! Gives the length of the number of points in the
          ! current list
          
          Max(1) = x
          Max(2) = y
          Max(3) = z

          do while (NOT(GradMax == ZERO OR CP(Max(1),Max(2),Max(3)) > 0))
             xs = Max(1)
             ys = Max(2)
             zs = Max(3)
             MaxVal = ED(xs,ys,zs)
             ListMax = ListMax + 1
             
             ! Appends to list if necessary
             if(size(List(1).element) < ListMax) then
                List(1).element.append(xs)
             else
                List(1).element(ListMax) = xs
             end if
             if(size(List(2).element) < ListMax) then
                List(2).element.append(ys)
             else
                List(2).element(ListMax) = ys
             end if
             if(size(List(3).element) < ListMax) then
                List(3).element.append(zs)
             else
                List(3).element(ListMax) = zs
             end if

             GradMax = 0

             do ix = xs-1,xs+1
             do iy = ys-1,ys+1
             do iz = zs-1,zs+1

                ! NOTE: Initial version used xs for all distances, if
                ! errors are occurring consider altering zs and ys.
                
                distance = sqrt(((ix-xs)*gridlength(1))**2 &
                         + ((iy-ys)*gridlength(2))**2      &
                         + ((iz-zs)*gridlength(3))**2)
                
                if ((ED(ix,iy,iz) - ED(xs,ys,zs))/distance > GradMax) then
                ! Determines the optimal gradient direction
                   Max(1)  = ix
                   Max(2)  = iy
                   Max(3)  = iz
                   MaxVal  = ED(ix,iy,iz)
                   GradMax = (ED(ix,iy,iz)-ED(xs,ys,zs))/distance
                end if
             end do
             end do
             end do
          end do
       

       if(CP(Max(1),Max(2),Max(3)) > 0) then
          do i=1,ListMax
             CP(List(1).element(i),List(2).element(i),List(3).element(i))=&
             CP(Max(1),Max(2),Max(3))
          end do
       else
          if (iCP == ZERO) then
             Maxima(1) = MaxVal
          else
             Maxima.append(MaxVal)
          end if
          iCP = iCP + 1
          do i =1,ListMax
             CP(List(1).element(i),List(2).element(i),List(3).element(i))=&
             iCP
          end do
       end if
       List.destroy
       GradMax = 1
       end if
    end do
    end do
    end do
    
    call cpu_time(t2)
    stdout.show("Elapsed time for gradient search",t2-t1)

    EDS.create(iCP)
    VOL.create(iCP)
    EDS = ZERO
    VOL = ZERO

    ! Cross product for the volume (or so I am told)
    ! Divide by total number of points! Move to plot grid

    dv = abs(gridvector(1,1)*gridvector(2,2)*gridvector(3,3) &
       -     gridvector(3,1)*gridvector(2,2)*gridvector(1,3) &
       +     gridvector(1,2)*gridvector(2,3)*gridvector(3,1) &
       -     gridvector(3,2)*gridvector(2,3)*gridvector(1,1) &
       +     gridvector(1,3)*gridvector(2,1)*gridvector(3,2) &
       -     gridvector(3,3)*gridvector(2,1)*gridvector(1,2))
    
    
    ! Corrects dv with the gridsize
    dv = dv/(nx-1)/(ny-1)/(nz-1)                             &
       *     gridlength(1)*gridlength(2)*gridlength(3)       

    do x=1,nx+2
    do y=1,ny+2
    do z=1,nz+2
    do i=1,iCP
       if(i==CP(x,y,z)) then
          EDS(i) = EDS(i) + ED(x,y,z)*dv ! electrons in this voxel
          VOL(i) = VOL(i) + dv           ! size of voxel
       end if
    end do
    end do
    end do
    end do
    dv = 0
    do i=1,iCP
          stdout.show("Critical point", i)
          stdout.show("Number of electrons",EDS(i))
          dv = dv + EDS(i)
          stdout.show("Volume of CP",VOL(i))
    end do
    stdout.show("Total electrons", dv)
    ED.destroy
    Maxima.destroy

    call cpu_time(t3)
    stdout.show("Elapsed time for summation and output",t3-t2)
   
   
   end

   cubes_to_basin_parallel(grid,nx,ny,nz,gridlength,gridvector,CP_master,EDS,VOL) ::: leaky, selfless
   ! A parallel tonto implementation of the cubes to basin code, originally
   ! implemented by Florian from Tobias (spelling).
      nx,ny,nz :: INT, IN
      grid :: MAT3{REAL}, IN
      gridlength :: VEC{REAL}(3), IN
      gridvector :: MAT{REAL}(3,3), IN
      CP_master :: MAT4{INT}*, OUT
      EDS,VOL :: VEC{REAL}*, OUT

      nprocs,i,ii,px,mx,x,y,z,xs,ys,zs,ix,iy,iz,ListMax,iCP :: INT
      GradMax,distance,dv,t1,t2,t3,t4 :: REAL
      Max,Replace :: VEC{INT}(3)
      List :: MAT{INT}*
      CP :: MAT4{INT}*
      CP_hisend,CP_losend,CP_hirecv,CP_lorecv :: MAT3{INT}*
      ED :: MAT3{REAL}*
      CPS :: MAT{INT}*
      Maxima :: VEC{REAL}*
      changes :: BIN

      ! Establishes the partitions on each processor.
      nprocs = tonto.n_processors
      mx = nx - (nprocs-1)*int(nx/nprocs)
      px = int(nx/nprocs)
      if(tonto.processor_rank==tonto.master_rank)then
         ED.create(mx+2,ny+2,nz+2)
         CP.create(mx+2,ny+2,nz+2,3)
      else if(tonto.processor_rank<nprocs - 1)then
         ED.create(px+2,ny+2,nz+2)
         CP.create(px+2,ny+2,nz+2,3)
      else
         ED.create(px+2,ny+2,nz+2)
         CP.create(px+2,ny+2,nz+2,3)
      end if
      
      ! Fills the partitions with the electron density grid.
      ! Boundaries in between processors are filled wiht more ED grid
      ! points, all other boundaries are zeroed.
      if(tonto.processor_rank==tonto.master_rank)then
         ED = ZERO
         ED(2:mx+2,2:ny+1,2:nz+1)=grid(1:mx+1,:,:)
         px = mx 
      else if(tonto.processor_rank<nprocs - 1)then
         ED = ZERO
         ED(1:px+2,2:ny+1,2:nz+1)= &
         grid(mx+(tonto.processor_rank-1)*px:mx+(tonto.processor_rank)*px+1,:,:)
      else 
         ED = ZERO
         ED(1:px+1,2:ny+1,2:nz+1)= &
         grid(mx+(tonto.processor_rank-1)*px:mx+(tonto.processor_rank)*px,:,:)
      end if
      
      ! Initialises the partition
      CP = ZERO
      GradMax = 1
      
      ! Used for process timing.
      if (tonto.processor_rank == tonto.master_rank) then
         call cpu_time(t1)
      end if
      
      ! Enables multiple threads to be set, if that is available on
      ! the hardware
      !call omp_set_num_threads(3)
      
      ! Cycles through the partition to determine all gradient paths
      ! within this partition.
      do x=2,px+1
      do y=2,ny+1
      do z=2,nz+1
         
         ! Avoids unnecessary computation in the partition if a
         ! gradient path has already been found.
         if (sum(abs(CP(x,y,z,:))) == ZERO) then
         
            ! Creates a list for gradient path following. Chnaging the
            ! order of this list will improve the efficiency of this
            ! program.
            List.create(3,0)
            ! Gives the length of the number of points in the
            ! current list
            ListMax = 0
            
            ! Initialises the Maximum direction to be the starting
            ! point of the 3x3x3 cube
            Max(1) = x
            Max(2) = y
            Max(3) = z

            ! Follows the gradient path until either it becomes a
            ! previous gradient path (CP > 0) OR a maximum is found
            ! (GradMax = ZERO)
            do while (NOT(GradMax == ZERO OR sum(abs(CP(Max(1),Max(2),Max(3),:)))> 0))
               ! Stores the initial value of this iteration
               xs = Max(1)
               ys = Max(2)
               zs = Max(3)
               
               ! Gives the list size (Given the access to the dim
               ! function, this actually may be unnecessary)
               ListMax = ListMax + 1
               
               ! Appends the current point to the list
               List.append_column([xs,ys,zs])

               ! Leaves the loop, if it is on the x-boundaries, as
               ! this could cause incorrect gradient paths due to a
               ! lack of information
               if ( Max(1) == 1) exit
               if ( Max(1) == px+2) exit
               
               !Re-initialises the gradient
               GradMax = 0
               
               ! Loops through all the neighbouring points (3x3x3) to
               ! determine the gradient path
               do ix = xs-1,xs+1
               do iy = ys-1,ys+1
               do iz = zs-1,zs+1
                  ! Calculates the distance in each of the grid
                  ! directions
                  distance = sqrt(((ix-xs)*gridlength(1))**2 &
                           + ((iy-ys)*gridlength(2))**2      &
                           + ((iz-zs)*gridlength(3))**2)
                  
                  ! Separate option at current grid point to avoid
                  ! divide by zero error
                  if (ix == xs AND iy == ys AND iz == zs) then
                     
                     ! Only update if this is the correct direction
                     if (ZERO >= GradMax) then
                        Max(1)  = ix
                        Max(2)  = iy
                        Max(3)  = iz
                        GradMax = ZERO
                     end if
                  
                  ! Only update if this is a steeper gradient to
                  ! follow.
                  else if ((ED(ix,iy,iz) - ED(xs,ys,zs))/distance > GradMax) then
                     Max(1)  = ix
                     Max(2)  = iy
                     Max(3)  = iz
                     GradMax = (ED(ix,iy,iz)-ED(xs,ys,zs))/distance
                  end if
               end do
               end do
               end do
            end do
         
         ! Checks if this is an old or a new gradient path. This is
         ! for old paths
         if(sum(abs(CP(Max(1),Max(2),Max(3),:))) /= 0) then
            
            ! Update all points on the path to point to the same
            ! maxima on this path
            !$OMP parallel shared(CP) private(i)
            !$OMP do
            do i=1,ListMax
               CP(List(1,i),List(2,i),List(3,i),:)=CP(Max(1),Max(2),Max(3),:)
            end do
            !$OMP end do
            !$OMP end parallel
         ! New path
         else
            
            ! Update all points on the path to point to the same
            ! maxima on this path
            !$OMP parallel shared(CP) private(i)
            !$OMP do
            do i=1,ListMax
               CP(List(1,i),List(2,i),List(3,i),:)=Max(:)
            end do
            !$OMP end do
            !$OMP end parallel
         
         end if
         
         ! Resets the list for the next iteration
         List.destroy
         
         ! Rests the gradient, so it will enter the do while loop at
         ! the next iteration.
         GradMax = 1
         end if
      end do
      end do
      end do
      
      ! Prints how long the gradient path following method takes. The
      ! barrier is use to ensure all processors have completed the
      ! job.
      tonto.barrier
      if (tonto.processor_rank == tonto.master_rank) then
         call cpu_time(t2)
         stdout.show("Elapsed time for gradient search:", t2-t1)
      end if
      
      
      ! The partition is not used after this, so it is destroyed to
      ! clear memory
      ED.destroy

      ! Gives all processors information about the size of each
      ! partition, for sending and receiving purposes.
      px = int(nx/nprocs)
      mx = nx - (nprocs-1)*int(nx/nprocs)
      
      
      ! Create sending and receiving matrices for each processor.
      if(tonto.processor_rank==tonto.master_rank)then
         CP_hisend.create(ny+2,nz+2,3)
         CP_hirecv.create(ny+2,nz+2,3)
      else if (tonto.processor_rank < nprocs - 1) then
         
         ! Update the critical points to reflect the index in the
         ! entire grid.
         CP(:,:,:,1) = CP(:,:,:,1)+mx+(tonto.processor_rank-1)*px 
         
         CP_hisend.create(ny+2,nz+2,3)
         CP_hirecv.create(ny+2,nz+2,3)
         CP_losend.create(ny+2,nz+2,3)
         CP_lorecv.create(ny+2,nz+2,3)
      else
         
         ! Update the critical points to reflect the index in the
         ! entire grid.
         CP(:,:,:,1) = CP(:,:,:,1)+mx+(tonto.processor_rank-1)*px 
         
         CP_losend.create(ny+2,nz+2,3)
         CP_lorecv.create(ny+2,nz+2,3)
      end if
      
      ! Ensures the program enters the loops 
      changes = TRUE
      
      ! Loops as long as one partition has changed
      do while (changes EQV TRUE)
         
         ! Initialises the logical to be false, so it only loops again
         ! if "changes" occur later on in the do loop.
         changes = FALSE

         ! Send and receive boundaries between processors.
         if(tonto.processor_rank==tonto.master_rank)then
            CP_hisend = CP(mx+1,:,:,:)
            tonto.sendrecv(CP_hisend,CP_hirecv,tonto.processor_rank+1)
         else if (tonto.processor_rank < nprocs - 1) then
            CP_hisend = CP(px+1,:,:,:)
            tonto.sendrecv(CP_hisend,CP_hirecv,tonto.processor_rank+1)
            CP_losend = CP(2,:,:,:)
            tonto.sendrecv(CP_losend,CP_lorecv,tonto.processor_rank-1)
         else
            CP_losend = CP(2,:,:,:)
            tonto.sendrecv(CP_losend,CP_lorecv,tonto.processor_rank-1)
         end if

         ! Master instructions
         if(tonto.processor_rank==tonto.master_rank)then
            
            ! Only perform on the upper boundary
            x = mx + 1 
            do y = 2,ny+1
            do z = 2,nz+1
               
               ! Cycles if the critical point is interior to this
               ! boundary, as no merging is required.
               if(CP(x,y,z,1) < x + 1) cycle
               
               ! Save what values need to be replaced, as if the
               ! current points maxima is updated, it will not be able
               ! to be used as a reference.
               Replace(:) = CP(x,y,z,:)
               
               ! Check if the maxima of the point is different from
               ! the maxima of the maxima
               if (sum(abs(CP(x,y,z,:)-CP_hirecv(Replace(2),Replace(3),:))) /= 0) then
                  ! Saves the value of the maxima to replace old
                  ! values.
                  Max(:) = CP_hirecv(y,z,:)
                  
                  ! Cycle through the grid.
                  !$OMP parallel shared(CP) private(xs,ys,zs)
                  !$OMP do
                  do xs = 2,x
                  do ys = 2,ny+1
                  do zs = 2,nz+1
                     
                     ! Cycles if the critical point is interior to this
                     ! boundary, as no merging is required.
                     if(CP(xs,ys,zs,1) < x + 1) cycle
                     
                     ! Updates only if the critical point is the same
                     ! as the one in Replace.
                     if (CP(xs,ys,zs,1) == Replace(1) AND CP(xs,ys,zs,2) == Replace(2) AND CP(xs,ys,zs,3) == Replace(3) ) then
                           CP(xs,ys,zs,:) = Max(:)
                     end if

                  end do
                  end do
                  end do
                 !$OMP end do
                 !$OMP end parallel
               end if

            end do
            end do

            ! See if any other thread had changes that occured at both
            ! boundaries. NOTE: This could be better updated, so it
            ! better reflects where the changes are specific to. This
            ! would ensure a faster process.
            tonto.parallel_or(changes)
         
         ! Instructions for the central processor merges
         else if (tonto.processor_rank < nprocs - 1) then
            
            ! Only perform on the upper boundary
            x = px+1 
            do y = 2,ny+1
            do z = 2,nz+1
               
               ! Cycles if the critical point is interior to this
               ! boundary, as no merging is required.
               if(CP(x,y,z,1) < mx + tonto.processor_rank*px + 2) cycle
               
               ! Save what values need to be replaced, as if the
               ! current points maxima is updated, it will not be able
               ! to be used as a reference.
               Replace(:) = CP(x,y,z,:)
               
               ! Check if the maxima of the point is different from
               ! the maxima of the maxima
               if (sum(abs(CP(x,y,z,:)-CP_hirecv(Replace(2),Replace(3),:))) /= 0) then
                  ! Saves the value of the maxima to replace old
                  ! values.
                  Max(:) = CP_hirecv(y,z,:)
                  
                  ! Cycle through the grid.
                  !$OMP parallel shared(CP) private(xs,ys,zs)
                  !$OMP do
                  do xs = 2,x
                  do ys = 2,ny+1
                  do zs = 2,nz+1
                     
                     ! Cycles if the critical point is interior to this
                     ! boundary, as no merging is required.
                     if(CP(xs,ys,zs,1) < mx + tonto.processor_rank*px + 2) cycle
                     
                     ! Updates only if the critical point is the same
                     ! as the one in Replace.
                     if (CP(xs,ys,zs,1) == Replace(1) AND CP(xs,ys,zs,2) == Replace(2) AND CP(xs,ys,zs,3) == Replace(3) ) then
                           CP(xs,ys,zs,:) = Max(:)
                           if (xs == 2) changes = TRUE
                     end if
                  
                  end do
                  end do
                  end do
                  !$OMP end do
                  !$OMP end parallel
               
               end if

            end do
            end do
            
            ! Only perform on the lower boundary
            x = 2 
            do y = 2,ny+1
            do z = 2,nz+1
                  
               ! Cycles if the critical point is interior to this
               ! boundary, as no merging is required.
               if(CP(x,y,z,1) > mx + (tonto.processor_rank - 1)*px + 1) cycle
               
               ! Save what values need to be replaced, as if the
               ! current points maxima is updated, it will not be able
               ! to be used as a reference.
               Replace(:) = CP(x,y,z,:)
            
               ! Check if the maxima of the point is different from
               ! the maxima of the maxima
               if (sum(abs(CP(x,y,z,:)-CP_lorecv(Replace(2),Replace(3),:))) /= 0) then
                  ! Saves the value of the maxima to replace old
                  ! values.
                  Max(:) = CP_lorecv(y,z,:)
                  
                  ! Cycle through the grid.
                  !$OMP parallel shared(CP) private(xs,ys,zs)
                  !$OMP do
                  do xs = x,px+1
                  do ys = 2,ny+1
                  do zs = 2,nz+1
                     
                     ! Cycles if the critical point is interior to this
                     ! boundary, as no merging is required.
                     if(CP(xs,ys,zs,1) > mx + (tonto.processor_rank-1)*px+1) cycle
                     
                     ! Updates only if the critical point is the same
                     ! as the one in Replace.
                     if (CP(xs,ys,zs,1) == Replace(1) AND CP(xs,ys,zs,2) == Replace(2) AND CP(xs,ys,zs,3) == Replace(3) ) then
                           CP(xs,ys,zs,:) = Max(:)
                           if (xs == px+1) changes = TRUE
                     end if
                  
                  end do
                  end do
                  end do
                  !$OMP end do
                  !$OMP end parallel
               
               end if

            end do
            end do
            
            ! See if any other thread had changes that occured at both
            ! boundaries. NOTE: This could be better updated, so it
            ! better reflects where the changes are specific to. This
            ! would ensure a faster process.
            tonto.parallel_or(changes)
         
         ! Instructions for the end processor merges
         else
            
            ! Only perform on the lower boundary
            x = 2 
            do y = 2,ny+1
            do z = 2,nz+1
            
               ! Cycles if the critical point is interior to this
               ! boundary, as no merging is required.
               if(CP(x,y,z,1) > mx + (tonto.processor_rank - 1)*px+1) cycle
               
               ! Save what values need to be replaced, as if the
               ! current points maxima is updated, it will not be able
               ! to be used as a reference.
               Replace(:) = CP(x,y,z,:)
              
               ! Check if the maxima of the point is different from
               ! the maxima of the maxima
               if (sum(abs(CP(x,y,z,:)-CP_lorecv(Replace(2),Replace(3),:))) /= 0) then
                  ! Saves the value of the maxima to replace old
                  ! values.
                  Max(:) = CP_lorecv(y,z,:)
                  
                  ! Cycle through the grid.
                  !$OMP parallel shared(CP) private(xs,ys,zs)
                  !$OMP do
                  do xs = x,px+1
                  do ys = 2,ny+1
                  do zs = 2,nz+1
                     
                     ! Cycles if the critical point is interior to this
                     ! boundary, as no merging is required.
                     if(CP(xs,ys,zs,1) > mx + (tonto.processor_rank - 1)*px+1) cycle
                     
                     ! Updates only if the critical point is the same
                     ! as the one in Replace.
                     if (CP(xs,ys,zs,1) == Replace(1) AND CP(xs,ys,zs,2) == Replace(2) AND CP(xs,ys,zs,3) == Replace(3) ) then
                           CP(xs,ys,zs,:) = Max(:)
                     end if
                  
                  end do
                  end do
                  end do
                  !$OMP end do
                  !$OMP end parallel
              
               end if

            end do
            end do
            
            ! See if any other thread had changes that occured at both
            ! boundaries. NOTE: This could be better updated, so it
            ! better reflects where the changes are specific to. This
            ! would ensure a faster process.
            tonto.parallel_or(changes)
         
         end if
      
      end do
      
      ! Send all the completed merges to the master and cleanup
      ! send and recv matrices.
      if(tonto.processor_rank==tonto.master_rank)then
         
         ! Cleanup
         CP_hisend.destroy
         CP_hirecv.destroy
         
         ! Creates a grid to merge all the critical points
         CP_master.create(grid.dim1,ny,nz,3)
         
         ! Remove the boundary from the index notation
         CP(:,:,:,:) =CP(:,:,:,:) - 1

         ! Initialise the grid
         CP_master(1:mx,:,:,:) = ZERO
         
         ! Assign the master's partition to the grid
         CP_master(1:mx,:,:,:) = CP(2:mx+1,2:ny+1,2:nz+1,:)
         
         ! Cleanup the partition
         CP.destroy
         
         ! Receive the partitions from the other processors
         do i = 1, nprocs - 1
            tonto.recv(CP_master(mx+(i-1)*px+1:mx+i*px,:,:,:),i,i)
         end do
      
      else if (tonto.processor_rank < nprocs - 1) then
         
         ! Cleanup
         CP_hisend.destroy
         CP_losend.destroy
         CP_hirecv.destroy
         CP_lorecv.destroy
         
         ! Remove the boundary from the index notation
         CP(:,:,:,:) = CP(:,:,:,:) - 1
      
         ! Send the partition to the master processor for merging
         tonto.send(CP(2:px+1,2:ny+1,2:nz+1,:),tonto.master_rank,tonto.processor_rank)
      
      else
         
         ! Cleanup
         CP_lorecv.destroy
         CP_losend.destroy
         
         ! Remove the boundary from the index notation
         CP(:,:,:,:) = CP(:,:,:,:) - 1
      
         ! Send the partition to the master processor for merging
         tonto.send(CP(2:px+1,2:ny+1,2:nz+1,:),tonto.master_rank,tonto.processor_rank)
      end if
      
      if(tonto.processor_rank == tonto.master_rank) then
            
         
         ! Prints how long the communication takes. The
         ! barrier is use to ensure all processors have completed the
         ! job.
         if (tonto.processor_rank == tonto.master_rank) then
            call cpu_time(t3)
            stdout.show("Elapsed time for communication:", t3-t2)
         end if
      
         ! This is the determinant of the grid vectors
         dv = abs(gridvector(1,1)*gridvector(2,2)*gridvector(3,3) &
            -     gridvector(3,1)*gridvector(2,2)*gridvector(1,3) &
            +     gridvector(1,2)*gridvector(2,3)*gridvector(3,1) &
            -     gridvector(3,2)*gridvector(2,3)*gridvector(1,1) &
            +     gridvector(1,3)*gridvector(2,1)*gridvector(3,2) &
            -     gridvector(3,3)*gridvector(2,1)*gridvector(1,2))
         
         
         ! Scales dv to the correct grid size
         dv = dv/(nx-1)/(ny-1)/(nz-1)                             &
            *     gridlength(1)*gridlength(2)*gridlength(3)

         ! Initialise the output variables

         ! Stores each maxima that exists. The index in this matrix is
         ! used in each subsequent vector
         CPS.create(3,0) 
         ! Stores the some of the electron density across all voxels
         EDS.create(0)
         ! Stores the sum of the volume covered by these voxels
         VOL.create(0)
         ! Stores the ED value of each maxima. (not currently output,
         ! but can easily be added
         Maxima.create(0)
         ! Illustrates the current number of maxima, and the index of
         ! the current maxima.
         iCP = 0

         ! Cycles through all space to sum the volume and ED sum of
         ! the grid for each CP
         do x = 1, CP_master.dim1
         do y = 1, CP_master.dim2
         do z = 1, CP_master.dim3
            
            ! This is essentially a logical
            ii = 0
            
            ! Checks this maxima against already appended maxima 
            do i = 1,CPS.dim2
               if(CP_master(x,y,z,1) == CPS(1,i) AND CP_master(x,y,z,2) == CPS(2,i) AND CP_master(x,y,z,3) == CPS(3,i)) then
                  ii = 1
                  iCP = i
                  exit
               end if
            end do
            
            ! Append the maxima if it is a new maxima, and add the
            ! volume and electron densities to their respective
            ! matrices
            if (ii == 0) then
               CPS.append_column(CP_master(x,y,z,:))
               Maxima.append(grid(CP_master(x,y,z,1),CP_master(x,y,z,2),CP_master(x,y,z,3)))
               EDS.append(grid(x,y,z)*dv)
               VOL.append(dv)
            else
               EDS(iCP) = EDS(iCP) + grid(x,y,z)*dv
               VOL(iCP) = VOL(iCP) + dv
            end if

         end do
         end do
         end do
         
         ! Puts the output into the stdout, note this could be made to
         ! look a lot nicer, and to utilise the tonto system
         ! functions. 
         do i=1,EDS.dim
           stdout.show("CP:",i)
           stdout.put(CPS(:,i))
           stdout.put([EDS(i), VOL(i)])
         end do
         
      end if

      ! Prints how long the summation procedure takes. The
      ! barrier is use to ensure all processors have completed the
      ! job.
      tonto.barrier
      if (tonto.processor_rank == tonto.master_rank) then
         call cpu_time(t4)
         stdout.show("Elapsed time for summation and output:", t4-t3)
      end if
      
      ! Idles the other processor
      tonto.barrier

      ! Finalises the MPI program
      tonto.finalize

   end


end


