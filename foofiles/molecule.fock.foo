!===============================================================================
!
! MOLECULE.FOCK: Make specific-types of fock matrices, J and K
! matrices, the two-electron integral archives.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!===============================================================================

module MOLECULE.FOCK

   implicit none

contains

!  ============================
!  Fock matrix - specific kinds
!  ============================

   make_fock_matrix(P,F,core,r12,xc) ::: leaky
   ! If core is present and FALSE, the core part is not computed
   ! If r12  is present and FALSE, the r12  part is not computed
   ! If xc   is present and FALSE, the XC   part is not computed
   ! NOTE: If you set core=TRUE then for ROHF, both types of core
   !       matrix should exist. See initialize_scf. If possible, use
   !       the SCF:make_fock_matrix routine.
      P,F :: OPMATRIX@
      core,r12,xc :: BIN, optional

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(P.allocated,"no density matrix")
   ENSURE(P.is_allocated_with_genre(.scfdata.spinorbital_kind),"incompatible density")

      direct :: BIN

      direct = .scfdata.using_direct_scf
      if (NOT direct) .FOCK:get_ERI_integrals

      .scfdata.dft_energy_correction       = ZERO ! Set these to zero since
      .scfdata.dft_alpha_energy_correction = ZERO ! they may be calculated
      .scfdata.dft_beta_energy_correction  = ZERO

      select case (.scfdata.scf_kind)

        case ("rhf","xray_rhf","embedded_rhf")

           .:make_r_fock(P,F,direct,core,r12)

        case ("rks","xray_rks")

           .:make_r_KS_fock(P,F,direct,core,r12,xc)

        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")

           .:make_u_KS_fock(P,F,core,r12,xc)

        case ("rohf")

           .:make_ro_fock(P,F,direct,core,r12)

        case ("uhf","xray_uhf","pnd_uhf","xray_pnd_uhf")

           .:make_u_fock(P,F,direct,core,r12)

        case ("gchf","xray_gchf")

           .:make_gc_fock(P,F,direct,core,r12)
           .:add_gc_so_fock(P,F)

        case ("ghf", "no_ghf")
           
           .:make_g_fock(P,F,core,r12)
        
        case default

           DIE("unknown SCF kind, "//trim(.scfdata.scf_kind))

      end

   end

   add_core_hamiltonian(F)
   ! Add the core hamiltonain to "F"
      F :: OPMATRIX

      .BASE:put_debug(F,"add_core_hamiltonian: F, before")

      ! Add
      F.plus(.core_matrix)

      .BASE:put_debug(F,"add_core_hamiltonian: F, after")

   end

   make_r_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      direct,core,r12 :: BIN, optional
      P,F :: OPMATRIX@

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.allocated, "no density matrix")

      J,K :: MAT{REAL}*
      do_direct,add_core,add_r12 :: BIN
      ad :: REAL
      fm :: BIN

      ! Recreate
      F.destroy("restricted")
      F.create("restricted")

      do_direct= TRUE
      add_core = TRUE
      add_r12  = TRUE
      if (present(direct)) do_direct = direct
      if (present(core))   add_core = core
      if (present(r12))    add_r12  = r12

      if (add_r12) then

         J.create(.n_bf,.n_bf)
         K.create(.n_bf,.n_bf)

         if (do_direct) then
            if(.use_spherical_basis) then; .:make_r_JK_direct(J,K,P.restricted)
            else;                          .:make_r_JK_engine(J,K,P.restricted)
            end
         else;                             .:make_r_JK_disk(J,K,P.restricted)
         end

         fm= .scfdata.use_Fermi_Amaldi
         ad = .scfdata.ee_adiabatic_constant

         ! Checked with AG 11/06/16
         if (ad.equals(ONE)) then
            F.restricted = J - HALF*K
         else
            if (fm) then
               F.restricted = REALIFY(.n_e-1+ad)/REALIFY(.n_e)*J - ad*HALF*K
            else
               F.restricted = ad*J - ad*HALF*K
            end
         end

         K.destroy
         J.destroy

         .BASE:put_debug(F.restricted,"make_r_fock: 2e F")

      else

         F.restricted = ZERO

      end

      ! Add core
      if (add_core) .:add_core_hamiltonian(F)

      .BASE:put_debug(F.restricted,"make_r_fock: F")

   end

   make_r_KS_fock(P,F,direct,core,r12,xc) ::: leaky
   ! Make a new restricted Kohn-Sham Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
   ! If present and FALSE, "xc"  removes the exchange correlation part
      direct,core,r12,xc :: BIN, optional
      P,F :: OPMATRIX@

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.allocated, "no density matrix")

      K :: MAT{REAL}@
      do_direct,add_core,add_r12,add_xc :: BIN

      ! Recreate
      F.destroy("restricted")
      F.create("restricted")

      do_direct= TRUE
      add_core = TRUE
      add_r12  = TRUE
      add_xc   = TRUE
      if (present(direct)) do_direct = direct
      if (present(core))   add_core  = core
      if (present(r12))    add_r12   = r12
      if (present(xc))     add_xc    = xc
    

      if (add_r12) then

        if (do_direct) then

           if (.use_spherical_basis) then

              if (.scfdata.using_hybrid_exchange) then
                 K.create(.n_bf, .n_bf)
                 .:make_r_JK_direct(F.restricted,K,P.restricted)
                 K = K * (-HALF) * .scfdata.hybrid_exchange_factor
                 F.restricted = F.restricted + K
                 K.destroy
              else
                 .:make_r_J_direct(F.restricted,P.restricted)
              end

           else

              if (.scfdata.using_hybrid_exchange) then
                 K.create(.n_bf, .n_bf)
                 .:make_r_JK_engine(F.restricted,K,P.restricted)
                 K = K * (-HALF) * .scfdata.hybrid_exchange_factor
                 F.restricted = F.restricted + K
                 K.destroy
              else
                 .:make_r_J_engine(F.restricted,P.restricted)
              end

           end

        else                             
              if (.scfdata.using_hybrid_exchange) then
                 K.create(.n_bf, .n_bf)
                 .:make_r_JK_disk(F.restricted,K,P.restricted)
                 K = K * (-HALF) * .scfdata.hybrid_exchange_factor
                 F.restricted = F.restricted + K
                 K.destroy
              else
                  .:make_r_J_disk(F.restricted,P.restricted)
              end

        end

        ! Exchange correlation matrix
        if (add_xc) .:add_XC_matrix_KS(F)

      else

        F.restricted = ZERO

      end

      ! Add core
      if (add_core) .:add_core_hamiltonian(.fock_matrix)

   end

   make_u_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new unrestricted Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      P,F :: OPMATRIX@
      direct,core,r12 :: BIN, optional

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(P.alpha.allocated,"no density matrix")
   ENSURE(P.beta.allocated, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")

      J,K :: OPMATRIX@
      do_direct,add_core,add_r12 :: BIN

      F.destroy("unrestricted")
      F.create("unrestricted")

      do_direct= TRUE
      add_core = TRUE
      add_r12  = TRUE
      if (present(direct)) do_direct = direct
      if (present(core))   add_core = core
      if (present(r12))    add_r12  = r12

      J.create(.n_bf,"unrestricted")
      K.create(.n_bf,"unrestricted")

      if (add_r12) then

         if (do_direct) then
            if(.use_spherical_basis) then; .:make_u_JK_direct(J,K,P)
            else;                          .:make_u_JK_engine(J,K,P)
            end
         else
            DIE("disk UHF not implemented")
         end

         F.alpha = J.alpha + J.beta - K.alpha
         F.beta  = J.alpha + J.beta - K.beta

      else

         F.alpha = ZERO
         F.beta  = ZERO

      end

      ! Clean
      K.destroy
      J.destroy

      ! Add core
      if (add_core) .:add_core_hamiltonian(.fock_matrix)

   end

   make_u_KS_fock(P,F,core,r12,xc) ::: leaky
   ! Make a new restricted Kohn-Sham Fock matrix "F" from the density matrix "P".
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
   ! If present and FALSE, "xc"   removes the exchange correlation
      core,r12,xc :: BIN, optional
      P,F :: OPMATRIX@

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.alpha.allocated, "no density matrix")
   ENSURE(P.beta.allocated, "no density matrix")

      J,K :: OPMATRIX@
      add_core,add_r12,add_xc :: BIN

      F.destroy("unrestricted")
      F.create("unrestricted")

      add_core = TRUE
      add_r12  = TRUE
      add_xc   = TRUE
      if (present(core))   add_core = core
      if (present(r12))    add_r12  = r12
      if (present(xc))     add_xc   = xc

      J.create(.n_bf, "unrestricted")
      K.create(.n_bf, "unrestricted")

      if (add_r12) then
            if(.use_spherical_basis) then
               .:make_u_JK_direct(J,K,P)
            else
               .:make_u_JK_engine(J,K,P)
            end

         F.alpha = J.alpha + J.beta
         F.beta  = J.alpha + J.beta

         if(.scfdata.using_hybrid_exchange) then
            K.alpha = K.alpha * (-HALF) * .scfdata.hybrid_exchange_factor
            K.beta = K.beta * (-HALF) * .scfdata.hybrid_exchange_factor
            F.alpha = F.alpha + K.alpha + K.beta
            F.beta = F.beta + K.alpha + K.beta 
         end if

         if (add_xc) .:add_XC_matrix_KS(F)

      else

         F.alpha = ZERO
         F.beta  = ZERO

      end

      ! Clean
      J.destroy
      K.destroy

      ! Add core
      if (add_core) .:add_core_hamiltonian(.fock_matrix)

   end

   make_ro_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted open shell Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      F,P :: OPMATRIX@
      direct,core,r12 :: BIN, optional

      W :: MAT{REAL}@

      ! Clean
      F.destroy("restricted")
      F.create("restricted")

      ! Make UHF Fock
      .:make_u_fock(P,F,direct,core,r12)

      ! Change Fa & Fb to MO basis
      F.alpha.change_basis_using(.molecular_orbitals.restricted)
      F.beta.change_basis_using(.molecular_orbitals.restricted)

      ! Define the Fr in the MO basis
      F.restricted  = HALF*(F.alpha+F.beta)
      F.restricted(.n_b+1:.n_a,     1:.n_b) = F.beta(.n_b+1:.n_a,     1:.n_b)
      F.restricted(     1:.n_b,.n_b+1:.n_a) = F.beta(     1:.n_b,.n_b+1:.n_a)
      F.restricted(.n_a+1:    ,.n_b+1:.n_a) = F.alpha(.n_a+1:    ,.n_b+1:.n_a)
      F.restricted(.n_b+1:.n_a,.n_a+1:    ) = F.alpha(.n_b+1:.n_a,.n_a+1:    )

      ! Change Fr back to AO basis
      .INTS:make_overlap_matrix
      W = F.alpha
      W.to_product_of(.molecular_orbitals.restricted,.overlap_matrix,transpose_a=TRUE)
      F.restricted.change_basis_using(W)


   end

   make_g_fock(P,F,core,r12) ::: leaky
   ! Make a new general Fock matrix.
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      self :: INOUT
      P,F :: OPMATRIX@
      core,r12 :: BIN, optional, IN

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(P.general.allocated, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")

      Ka,Kb,Kba,Pa,Pb,Pba :: MAT{REAL}*
      J, Pab :: MAT{REAL}*
      add_core,add_r12 :: BIN

      F.destroy("general")
      F.create("general")
      F.general = ZERO
      add_core = TRUE
      add_r12  = TRUE
      if (present(core)) add_core = core
      if (present(r12))  add_r12  = r12

      if (add_r12) then

         J.create(.n_bf,.n_bf)
         Ka.create(.n_bf,.n_bf)
         Kb.create(.n_bf,.n_bf)
         Kba.create(.n_bf,.n_bf)

         Pa.create(.n_bf,.n_bf);  P.general.alpha_alpha_put_to(Pa)
         Pb.create(.n_bf,.n_bf);  P.general.beta_beta_put_to(Pb)
         Pba.create(.n_bf,.n_bf); P.general.beta_alpha_put_to(Pba)
         Pab.create(.n_bf,.n_bf);

         Pab = Pa + Pb
         .:make_g_JK_direct(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
         

         Pab.destroy
         Pba.destroy
         Pb.destroy
         Pa.destroy

         Ka  = J - Ka; F.general.alpha_alpha_set_to(Ka)
         Kb  = J - Kb; F.general.beta_beta_set_to(Kb)
         Kba = -Kba;   F.general.beta_alpha_set_to(Kba)

         Kba.destroy
         Kb.destroy
         Ka.destroy
         J.destroy

      else

         F.general = ZERO

      end

      F.general.symmetrize

      ! Add core
      if (add_core) .:add_core_hamiltonian(F)

   end

   make_gc_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new complex general Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      direct,core,r12 :: BIN, optional
      P,F :: OPMATRIX@

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(P.general_complex.allocated, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")

      Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}*
      J, Pab :: MAT{REAL}*
      do_direct,add_core,add_r12 :: BIN

      F.destroy("general_complex")
      F.create("general_complex")

      do_direct= TRUE
      add_core = TRUE
      add_r12  = TRUE
      if (present(direct)) do_direct = direct
      if (present(core)) add_core = core
      if (present(r12))  add_r12  = r12

      if (add_r12) then

         J.create(.n_bf,.n_bf)
         Ka.create(.n_bf,.n_bf)
         Kb.create(.n_bf,.n_bf)
         Kba.create(.n_bf,.n_bf)

         Pa.create(.n_bf,.n_bf);  P.general_complex.alpha_alpha_put_to(Pa)
         Pb.create(.n_bf,.n_bf);  P.general_complex.beta_beta_put_to(Pb)
         Pba.create(.n_bf,.n_bf); P.general_complex.beta_alpha_put_to(Pba)
         Pab.create(.n_bf,.n_bf)

         Pab = RE(Pa) + RE(Pb)
         if (do_direct) then; .:make_gc_JK_direct(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
         else;                .:make_gc_JK_disk(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
         end

         Pab.destroy
         Pba.destroy
         Pb.destroy
         Pa.destroy

         Ka  = J - Ka; F.general_complex.alpha_alpha_set_to(Ka)
         Kb  = J - Kb; F.general_complex.beta_beta_set_to(Kb)
         Kba = -Kba;   F.general_complex.beta_alpha_set_to(Kba)

         Kba.destroy
         Kb.destroy
         Ka.destroy
         J.destroy

      else

         F.general_complex = ZERO

      end

      F.general_complex.make_hermitian

      ! Add core
      if (add_core) .:add_core_hamiltonian(F)

   end

   add_gc_so_fock(P,F,direct) ::: leaky
   ! Make the general complex two electron spin orbit contribution to the Fock
   ! matrix.
      P,F :: OPMATRIX@
      direct :: BIN, optional

   ENSURE(P.allocated,"no density matrix")
   ENSURE(F.allocated,"no fock matrix")
   ENSURE(P.general_complex.allocated, "no density matrix")
   ENSURE(F.general_complex.allocated, "no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")

      JS,KS,JO,KO :: MAT5{CPX}*
      Pgc :: MAT4{CPX}*
      Faa,Fbb,Fba :: MAT{CPX}*
      I :: CPX
      fac :: REAL
      a,b,x,y,z :: INT
      do_direct :: BIN

      do_direct= TRUE
      if (present(direct)) do_direct = direct

      if (.scfdata.using_2e_sl_term) then

         .:get_spin_orbit_integrals

         Faa.create(.n_bf,.n_bf)
         Fbb.create(.n_bf,.n_bf)
         Fba.create(.n_bf,.n_bf)

         JS.create(.n_bf,.n_bf,2,2,3); KS.create(.n_bf,.n_bf,2,2,3)
         JO.create(.n_bf,.n_bf,2,2,3); KO.create(.n_bf,.n_bf,2,2,3)

         Pgc.create(.n_bf,.n_bf,2,2)

         P.general_complex.alpha_alpha_put_to(Pgc(:,:,1,1))
         P.general_complex.beta_alpha_put_to(Pgc(:,:,2,1))
         P.general_complex.alpha_beta_put_to(Pgc(:,:,1,2))
         P.general_complex.beta_beta_put_to(Pgc(:,:,2,2))

         if (do_direct) then

            .:make_gc_so_JK_direct(JS,KS,JO,KO,Pgc)

         else

            .:make_gc_so_JK_disk(JS(:,:,:,:,1),KS(:,:,:,:,1),JO(:,:,:,:,1),KO(:,:,:,:,1),Pgc,"x")
            .:make_gc_so_JK_disk(JS(:,:,:,:,2),KS(:,:,:,:,2),JO(:,:,:,:,2),KO(:,:,:,:,2),Pgc,"y")
            .:make_gc_so_JK_disk(JS(:,:,:,:,3),KS(:,:,:,:,3),JO(:,:,:,:,3),KO(:,:,:,:,3),Pgc,"z")

         end

         Pgc.destroy

         I = (ZERO,ONE)

         a = 1; b = 2
         x = 1; y = 2; z = 3

         Faa =  THREE*JO(:,:,a,a,z) +       JO(:,:,b,b,z) + THREE*JS(:,:,a,a,z) -   JS(:,:,b,b,z) &
             +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
             +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
             -    TWO*KO(:,:,b,a,x) -       KO(:,:,a,b,x) -   TWO*KS(:,:,a,b,x) -   KS(:,:,b,a,x) &
             +  I*TWO*KO(:,:,b,a,y) -     I*KO(:,:,a,b,y) - I*TWO*KS(:,:,a,b,y) + I*KS(:,:,b,a,y) &
             -  THREE*KO(:,:,a,a,z) - THREE*KS(:,:,a,a,z)
         Fbb = -THREE*JO(:,:,b,b,z) -       JO(:,:,a,a,z) - THREE*JS(:,:,b,b,z) +   JS(:,:,a,a,z) &
             +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
             +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
             -    TWO*KO(:,:,a,b,x) -       KO(:,:,b,a,x) -   TWO*KS(:,:,b,a,x) -   KS(:,:,a,b,x) &
             -  I*TWO*KO(:,:,a,b,y) + I*KO(:,:,b,a,y)     + I*TWO*KS(:,:,b,a,y) - I*KS(:,:,a,b,y) &
             +  THREE*KO(:,:,b,b,z) + THREE*KS(:,:,b,b,z)
         Fba =    TWO*JO(:,:,a,a,x) +   TWO*JO(:,:,b,b,x) +       JS(:,:,a,a,x) +   JS(:,:,b,b,x) &
             +  I*TWO*JO(:,:,a,a,y) + I*TWO*JO(:,:,b,b,y) +     I*JS(:,:,a,a,y) + I*JS(:,:,b,b,y) &
             -    TWO*KO(:,:,a,a,x) -       KO(:,:,b,b,x) -   TWO*KS(:,:,b,b,x) -   KS(:,:,a,a,x) &
             -  I*TWO*KO(:,:,a,a,y) -     I*KO(:,:,b,b,y) - I*TWO*KS(:,:,b,b,y) - I*KS(:,:,a,a,y) &
             +        KO(:,:,b,a,z) -       KS(:,:,b,a,z)

         KO.destroy
         JO.destroy
         KS.destroy
         JS.destroy

         fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
         fac = fac * .scfdata.sl_2e_factor

         F.general_complex.alpha_alpha_plus(Faa,I*fac)
         F.general_complex.beta_beta_plus(Fbb,I*fac)
         F.general_complex.beta_alpha_plus(Fba,I*fac)
         Fbb = conjg(transpose(Fba))
         F.general_complex.alpha_beta_plus(Fbb,-I*fac)

         Fba.destroy
         Fbb.destroy
         Faa.destroy

      end

   end

!  =====================
!  J & K matrix routines
!  =====================

   make_r_JK_direct(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
   ! symmetric density matrix "P" directly.
      J,K :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed shell pair information")

      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J = ZERO
      K = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)

      .:make_max_density_elements(max_P,P)
      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff) cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff) cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            factor = ONE
            if (aa==bb) factor = HALF
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J(a,b) = J(a,b) + I_abcd*P(d,c)
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               K(a,c) = K(a,c) + I_abcd*P(d,b)
               K(a,d) = K(a,d) + I_abcd*P(c,b)
               K(b,c) = K(b,c) + I_abcd*P(d,a)
               K(b,d) = K(b,d) + I_abcd*P(c,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab
      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_symmetric_fold(K)

      J = TWO*J
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
        PARALLEL_SYMMETRIC_SUM(K)
      else
        J.symmetric_reflect
        K.symmetric_reflect
      end

      ! Debug
      .BASE:put_debug(J,"make_r_JK_direct: J")
      .BASE:put_debug(K,"make_r_JK_direct: K")

   end

   make_r_JK_engine(J,K,P)
   ! Make the restricted real coulomb matrix "J" from a symmetric
   ! density matrix "P" directly. This uses the J matrix engine, but
   ! it can be easily disabled.
      J,K :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed shell pair information")

      PP,JJ :: VEC{VEC_{REAL}}*
      max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,JP_cut,KP_cut,P_max,IP_max :: REAL
      skip_J,skip_K,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN

      ! Prepare for J-matrix engine
      .:reverse_transfer(P,PP)
      .:create_transfer(JJ)

      ! Schwarz test and density test cutoffs
      cutoff = .scfdata.eri_schwarz_cutoff
      JP_cut = .scfdata.eri_J_density_cutoff
      KP_cut = .scfdata.eri_K_density_cutoff

      ! Get Schwarz test integrals and densities
      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      .:make_max_density_elements(max_P,P)

      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      ! Initialise J, K
      J = ZERO
      K = ZERO

      ! Loop over (ab| basis function pairs
      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff)  cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         ! Set primitive-pair skipped and non-skipped quartets
         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         ! Set up (ab| J/P matrix vectors
         Jab => JJ(ab).element
         Pab => PP(ab).element

         ! Loop over |cd) basis function pairs
         do cd = 1,ab

           if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle

           .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

           cd_same = atom_c==atom_d

           ::schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,aa,bb,cc,dd,max_P,.max_I)

           if (skip_J AND skip_K) cycle

           ! Set up |cd) J/P matrix vectors
           Jcd => JJ(cd).element
           Pcd => PP(cd).element

           ! Integral (ab|cd) permutation factor
           ab_eq_cd = FALSE
           if (aa==bb) then; factor = HALF
           else;             factor = ONE
           end
           if (cc==dd) factor = HALF * factor
           if (aa==cc AND bb==dd) then
              ab_eq_cd = TRUE
              factor = HALF * factor
           end

           ! Make the J/K matrix contributions
           any_same = ab_same OR cd_same OR &
                      atom_a==atom_c OR atom_a==atom_d OR &
                      atom_b==atom_c OR atom_b==atom_d

           if (any_same) then

              .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
              sh4n.make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
              sh4n.destroy_cd

           else

              .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
              sh4s.make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
              sh4s.destroy_cd

           end

         end

         ! Clean (ab| quartet info
         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      ! Do the J matrix forward transfer
      .:forward_transfer(JJ,J)

      ! Add in diagonal block factors
      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_symmetric_fold(K)
      J = TWO*J

      ! Parallel sums, if reqd.
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
        PARALLEL_SYMMETRIC_SUM(K)
      else
        J.symmetric_reflect
        K.symmetric_reflect
      end

      JJ.destroy
      PP.destroy

      ! Debug
      .BASE:put_debug(J,"make_r_JK_engine: J")
      .BASE:put_debug(K,"make_r_JK_engine: K")

   end

   make_r_J_direct(J,P)
   ! Make the real coulomb matrix "J" matrix from a
   ! symmetric density matrix "P" directly.
      J :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed shell pair information")

      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)

      .:make_max_density_elements(max_P,P)
      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff) cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff) cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            factor = ONE
            if (aa==bb) factor = HALF
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J(a,b) = J(a,b) + I_abcd*P(d,c)
               J(c,d) = J(c,d) + I_abcd*P(b,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab
      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:weight_diagonal_blocks(J,TWO)

      J = TWO*J
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
      else
        J.symmetric_reflect
      end

      ! Debug
      .BASE:put_debug(J,"make_r_JK_direct: J")

   end

   make_u_J_engine(J,P)
   ! Make the alpha and beta coulomb matrix "J" from the corresponding
   ! components of the density matrix "P" directly. This uses the J
   ! matrix engine, but it can be easily disabled.
      self :: INOUT
      J :: OPMATRIX, OUT
      P :: OPMATRIX, IN

      .:make_r_J_engine(J.alpha, P.alpha)
      .:make_r_J_engine(J.beta, P.beta)

   end

   make_r_J_engine(J,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      self :: INOUT
      J :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed shell pair information")

      PP,JJ :: VEC{VEC_{REAL}}*
      max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,P_max,IP_max :: REAL
      skip,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN

      .:reverse_transfer(P,PP)
      .:create_transfer(JJ)

      J = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      .:make_max_density_elements(max_P,P)

      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff)  cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         Jab => JJ(ab).element
         Pab => PP(ab).element

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            ::schwarz_J_test(skip,cutoff,ab,cd,max_P,.max_I)

            if (skip) cycle

            Jcd => JJ(cd).element
            Pcd => PP(cd).element

            if (aa==bb) then; factor = HALF
            else;             factor = ONE
            end
            if (cc==dd) factor = HALF * factor

            ab_eq_cd = FALSE
            if (aa==cc AND bb==dd) then
               ab_eq_cd = TRUE
               factor = HALF * factor
            end

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               sh4n.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,ab_eq_cd)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               sh4s.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,ab_eq_cd)
               sh4s.destroy_cd

            end

         end

         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:forward_transfer(JJ,J)
      .:weight_diagonal_blocks(J,TWO)
      J = TWO*J

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
      else
        J.symmetric_reflect
      end

      JJ.destroy
      PP.destroy

   end

   make_r_K_direct(K,P)
   ! Make the real exchange matrix "K" from a symmetric density matrix "P"
   ! directly.
      K :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      K = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      .:make_max_density_elements(max_P,P)

      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff)  cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            ::schwarz_K_test(skip,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            if (aa==bb) then                   ! Evaluate the integrals'
              factor = HALF                    ! coincidence factors
            else
              factor = ONE
            end
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               K(a,c) = K(a,c) + I_abcd*P(d,b)
               K(a,d) = K(a,d) + I_abcd*P(c,b)
               K(b,c) = K(b,c) + I_abcd*P(d,a)
               K(b,d) = K(b,d) + I_abcd*P(c,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:blockwise_symmetric_fold(K)

      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(K)
      else
         K.symmetric_reflect
      end

   end

   make_r_JK_disk(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
   ! symmetric density matrix "P" from disk integral archive "eri_integrals"
      J,K :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      eri_archive,ind_archive :: ARCHIVE
      I :: MAT4{REAL}*
      q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
      I_abcd,P_dc,P_db,P_cb :: REAL

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open_for("read-only")
      ind_archive.open_for("read-only")

      J = ZERO
      K = ZERO

      n_quartets = .atom.no_of_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .BASE:get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             P_dc = P(d,c)
             do b = fb,lb
               P_db = P(d,b)
               P_cb = P(c,b)
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  J(c,d) = J(c,d) + I_abcd*P(b,a)
                  K(a,c) = K(a,c) + I_abcd*P_db
                  K(a,d) = K(a,d) + I_abcd*P_cb
                  K(b,c) = K(b,c) + I_abcd*P(d,a)
                  K(b,d) = K(b,d) + I_abcd*P(c,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.close
      eri_archive.close

      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_symmetric_fold(K)

      J.symmetric_reflect
      K.symmetric_reflect

      J = TWO*J

   end

   make_r_J_disk(J,P)
   ! Make the real coulomb matrix "J" from a
   ! symmetric density matrix "P" from disk integral archive "eri_integrals"
      J :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      eri_archive,ind_archive :: ARCHIVE
      I :: MAT4{REAL}*
      q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
      I_abcd,P_dc :: REAL

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open_for("read-only")
      ind_archive.open_for("read-only")

      J = ZERO

      n_quartets = .atom.no_of_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .BASE:get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             P_dc = P(d,c)
             do b = fb,lb
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  J(c,d) = J(c,d) + I_abcd*P(b,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.close
      eri_archive.close

      .:weight_diagonal_blocks(J,TWO)

      J.symmetric_reflect
      J = TWO*J

   end

   make_r_K_disk(K,P)
   ! Make the real exchange matrix "K" from a symmetric density matrix "P" from
   ! disk integral archive "eri_integrals"
      K :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      eri_archive,ind_archive :: ARCHIVE
      I :: MAT4{REAL}*
      q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
      I_abcd,P_db,P_cb :: REAL

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open_for("read-only")
      ind_archive.open_for("read-only")

      K = ZERO

      n_quartets = .atom.no_of_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .BASE:get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             do b = fb,lb
               P_db = P(d,b)
               P_cb = P(c,b)
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  K(a,c) = K(a,c) + I_abcd*P_db
                  K(a,d) = K(a,d) + I_abcd*P_cb
                  K(b,c) = K(b,c) + I_abcd*P(d,a)
                  K(b,d) = K(b,d) + I_abcd*P(c,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.close
      eri_archive.close

      .:blockwise_symmetric_fold(K)
      K.symmetric_reflect

   end

   make_r_J_nosym(J,P)
   ! Make the only the real coulomb matrix "J" from the
   ! density matrix "P" which has no permutational symmetry.
      J :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

      I :: VEC{REAL}*
      max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd :: INT
      a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J = ZERO

      cutoff = SCFDATA_ERI_DISK_CUTOFF

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      .:make_max_density_elements(max_P,P)

      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff)  cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            if (aa==bb) then; factor = HALF      ! coincidence factors
            else;             factor = ONE
            end
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            abcd = 0

            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
               J(a,b) = J(a,b) + I_abcd*P(c,d)
               J(b,a) = J(b,a) + I_abcd*P(d,c)
               J(b,a) = J(b,a) + I_abcd*P(c,d)
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               J(c,d) = J(c,d) + I_abcd*P(a,b)
               J(d,c) = J(d,c) + I_abcd*P(b,a)
               J(d,c) = J(d,c) + I_abcd*P(a,b)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

   end

   make_r_JK_nosym(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
   ! density matrix "P" which has no permutational symmetry.
      J,K :: MAT{REAL}, OUT
      P :: MAT{REAL}, IN

      I :: VEC{REAL}*
      max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd :: INT
      a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J = ZERO
      K = ZERO

      cutoff = SCFDATA_ERI_DISK_CUTOFF

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      .:make_max_density_elements(max_P,P)

      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff)  cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            if (aa==bb) then; factor = HALF      ! coincidence factors
            else;             factor = ONE
            end
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            abcd = 0

            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
               J(a,b) = J(a,b) + I_abcd*P(c,d)
               J(b,a) = J(b,a) + I_abcd*P(d,c)
               J(b,a) = J(b,a) + I_abcd*P(c,d)
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               J(c,d) = J(c,d) + I_abcd*P(a,b)
               J(d,c) = J(d,c) + I_abcd*P(b,a)
               J(d,c) = J(d,c) + I_abcd*P(a,b)
               K(a,d) = K(a,d) + I_abcd*P(b,c) ! These are asymmetric
               K(a,c) = K(a,c) + I_abcd*P(b,d)
               K(b,c) = K(b,c) + I_abcd*P(a,d)
               K(b,d) = K(b,d) + I_abcd*P(a,c)
               K(d,a) = K(d,a) + I_abcd*P(c,b)
               K(c,a) = K(c,a) + I_abcd*P(d,b)
               K(c,b) = K(c,b) + I_abcd*P(d,a)
               K(d,b) = K(d,b) + I_abcd*P(c,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

   end

   make_u_JK_direct(J,K,P)
   ! Make the unrestricted coulomb matrices "J" and unrestricted
   ! exchange matrix "K" matrix from density matrix "P".
   ! This does not use th JK matrix engine
      J,K,P :: OPMATRIX@

   ENSURE(J.is_allocated_with_genre("unrestricted"),"unrestricted J not created")
   ENSURE(K.is_allocated_with_genre("unrestricted"),"unrestricted K not created")
   ENSURE(P.is_allocated_with_genre("unrestricted"),"unrestricted P not created")

      PP :: MAT{REAL}*
      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J.set_to_zero
      K.set_to_zero

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      PP.create(.n_bf,.n_bf)
      PP = P.alpha + P.beta
      .:make_max_density_elements(max_P,PP)
      PP.destroy

      do ab = 1, .n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            ! (ab|cd)) < sqrt(ab|ab) * sqrt(cd|cd) test.
            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            ! Evaluate the integral coincidence factor
            factor = ONE
            if (aa==bb) factor = HALF
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor
            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            ! Calculate I = (ab|cd)
            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            ! Evlauate J, K from (ab|cd)
            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J.alpha(a,b) = J.alpha(a,b) + I_abcd*P.alpha(d,c)
               J.alpha(c,d) = J.alpha(c,d) + I_abcd*P.alpha(b,a)
               K.alpha(a,c) = K.alpha(a,c) + I_abcd*P.alpha(d,b)
               K.alpha(a,d) = K.alpha(a,d) + I_abcd*P.alpha(c,b)
               K.alpha(b,c) = K.alpha(b,c) + I_abcd*P.alpha(d,a)
               K.alpha(b,d) = K.alpha(b,d) + I_abcd*P.alpha(c,a)
               J.beta(a,b) = J.beta(a,b) + I_abcd*P.beta(d,c)
               J.beta(c,d) = J.beta(c,d) + I_abcd*P.beta(b,a)
               K.beta(a,c) = K.beta(a,c) + I_abcd*P.beta(d,b)
               K.beta(a,d) = K.beta(a,d) + I_abcd*P.beta(c,b)
               K.beta(b,c) = K.beta(b,c) + I_abcd*P.beta(d,a)
               K.beta(b,d) = K.beta(b,d) + I_abcd*P.beta(c,a)
            end
            end
            end
            end

            I.destroy

         end

         ! Clean
         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:weight_diagonal_blocks(J.alpha,TWO)
      .:weight_diagonal_blocks(J.beta,TWO)
      .:blockwise_symmetric_fold(K.alpha)
      .:blockwise_symmetric_fold(K.beta)

      J.alpha.symmetric_reflect
      J.beta.symmetric_reflect
      K.alpha.symmetric_reflect
      K.beta.symmetric_reflect

      J.alpha = TWO*J.alpha
      J.beta  = TWO*J.beta

   end


   make_JK_engine(J,K,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,K,P :: OPMATRIX@

   ENSURE(J.spinorbital_kind == K.spinorbital_kind, "J and K have different spinorbital kinds")
   ENSURE(J.spinorbital_kind == P.spinorbital_kind, "J and P have different spinorbital kinds")

      if (J.is_allocated_with_genre("unrestricted")) then
         .FOCK:make_u_JK_engine(J, K, P)
      else
         .FOCK:make_r_JK_engine(J.restricted, K.restricted, P.restricted)
      end if

    end

    make_JK_direct(J,K,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,K,P :: OPMATRIX@
      ENSURE(J.spinorbital_kind == K.spinorbital_kind, "J and K have different spinorbital kinds")
      ENSURE(J.spinorbital_kind == P.spinorbital_kind, "J and P have different spinorbital kinds")

      if (J.is_allocated_with_genre("unrestricted")) then
         .FOCK:make_u_JK_direct(J, K, P)
      else
         .FOCK:make_r_JK_direct(J.restricted, K.restricted, P.restricted)
      end if
    end


    make_J_engine(J,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,P :: OPMATRIX@
      ENSURE(J.spinorbital_kind == P.spinorbital_kind, "J and P have different spinorbital kinds")
      K :: OPMATRIX@

      if (J.is_allocated_with_genre("unrestricted")) then
         K.create(J.n_bf, "unrestricted")
         ! TODO WRITE make_u_J_engine routine
         .FOCK:make_u_JK_engine(J, K, P)
         K.destroy
      else
         .FOCK:make_r_J_engine(J.restricted, P.restricted)
      end if
    end

   make_u_JK_engine(J,K,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,K,P :: OPMATRIX@

   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed shell pair information")
   ENSURE(J.is_allocated_with_genre("unrestricted"),"unrestricted J not created")
   ENSURE(K.is_allocated_with_genre("unrestricted"),"unrestricted K not created")
   ENSURE(P.is_allocated_with_genre("unrestricted"),"unrestricted P not created")

      PA,PB,JA,JB :: VEC{VEC_{REAL}}*
      max_P,JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,JP_cut,KP_cut,P_max,IP_max :: REAL
      skip_J,skip_K,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN

      ! Prepare for J-matrix engine
      .:reverse_transfer(P.alpha,PA)
      .:reverse_transfer( P.beta,PB)
      .:create_transfer(JA)
      .:create_transfer(JB)

      ! Schwarz test and density test cutoffs
      cutoff = .scfdata.eri_schwarz_cutoff
      JP_cut = .scfdata.eri_J_density_cutoff
      KP_cut = .scfdata.eri_K_density_cutoff

      ! Get Schwarz test integrals and densities
      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      .:make_max_density_elements(max_P,P.alpha,P.beta)

      P_max  = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      ! Initialise J, K
      J.alpha = ZERO; J.beta = ZERO
      K.alpha = ZERO; K.beta = ZERO

      ! Loop over (ab| basis function pairs
      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff)  cycle

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         ! Set primitive-pair skipped and non-skipped quartets
         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         ! Set up (ab| J/P matrix vectors
         JAab => JA(ab).element; JBab => JB(ab).element
         PAab => PA(ab).element; PBab => PB(ab).element

         ! Loop over |cd) basis function pairs
         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            ::schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,aa,bb,cc,dd,max_P,.max_I)

            if (skip_J AND skip_K) cycle

            ! Set up |cd) J/P matrix vectors
            JAcd => JA(cd).element; JBcd => JA(cd).element
            PAcd => PA(cd).element; PBcd => PB(cd).element

            ! Integral (ab|cd) permutation factor
            ab_eq_cd = FALSE
            if (aa==bb) then; factor = HALF
            else;             factor = ONE
            end
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) then
               ab_eq_cd = TRUE
               factor = HALF * factor
            end

            ! Make the J/K matrix contributions
            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               sh4n.make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,K.alpha,K.beta,P.alpha,P.beta &
                                    ,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               sh4s.make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,K.alpha,K.beta,P.alpha,P.beta &
                                    ,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
               sh4s.destroy_cd

            end

         end

         ! Clean (ab| quartet info
         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      ! Do the J matrix forward transfer
      .:forward_transfer(JA,J.alpha)
      .:forward_transfer(JB, J.beta)

      ! Add in diagonal block factors
      .:weight_diagonal_blocks(J.alpha,TWO)
      .:weight_diagonal_blocks( J.beta,TWO)
      .:blockwise_symmetric_fold(K.alpha)
      .:blockwise_symmetric_fold(K.beta)
      J.alpha = TWO*J.alpha
      J.beta  = TWO*J.beta

      ! Parallel sums, if reqd.
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J.alpha)
        PARALLEL_SYMMETRIC_SUM(J.beta)
        PARALLEL_SYMMETRIC_SUM(K.alpha)
        PARALLEL_SYMMETRIC_SUM(K.beta)
      else
        J.alpha.symmetric_reflect
         J.beta.symmetric_reflect
        K.alpha.symmetric_reflect
         K.beta.symmetric_reflect
      end

      ! Clean up transfer arrays
      JB.destroy; JA.destroy
      PB.destroy; PA.destroy

   end

   make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
      J,Ka,Kb :: MAT{REAL}, OUT
      P,Pa,Pb :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      I :: MAT4{REAL}*
      eri_archive,ind_archive :: ARCHIVE*
      q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
      I_abcd,P_dc,Pa_db,Pa_cb,Pb_db,Pb_cb :: REAL

      eri_archive.create(.name,"eri_integrals")
      ind_archive.create(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open_for("read-only")
      ind_archive.open_for("read-only")

      J  = ZERO
      Ka = ZERO
      Kb = ZERO

      n_quartets = .atom.no_of_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .BASE:get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             P_dc = P(d,c)
             do b = fb,lb
               Pa_db = Pa(d,b)
               Pb_db = Pb(d,b)
               Pa_cb = Pa(c,b)
               Pb_cb = Pb(c,b)
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  J(c,d) = J(c,d) + I_abcd*P(b,a)
                  Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
                  Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
                  Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
                  Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
                  Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
                  Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
                  Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
                  Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.destroy
      eri_archive.destroy

      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_symmetric_fold(Ka)
      .:blockwise_symmetric_fold(Kb)

      J.symmetric_reflect
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      J = TWO*J

   end

   make_g_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the general matrices "J" and exchange matrices "Ka", "Kb"
   ! and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
   ! directly from the integrals.
      self :: INOUT
      J,Ka,Kb,Kba :: MAT{REAL}, OUT
      P,Pa,Pb,Pba :: MAT{REAL}, IN

      I :: VEC{REAL}*
      abs_P :: MAT{REAL}*
      max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd :: INT
      a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      I_abcd,factor,cutoff :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J   = ZERO
      Ka  = ZERO
      Kb  = ZERO
      Kba = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      abs_P.create(.n_bf,.n_bf)
      abs_P = max(abs(P),abs(Pa),abs(Pb),abs(Pba))
      .:make_max_density_elements(max_P,abs_P)
      abs_P.destroy

      do ab = 1,.n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            factor = ONE                             ! Evaluate the integrals
            if (aa==bb) factor = HALF                ! Coincidence factors
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            I = factor * I

            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = I(abcd)
               J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
               J(c,d)   = J(c,d)   + I_abcd*P(b,a)
               Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric
               Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  ! but must be folded
               Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
               Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
               Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric
               Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  ! but must be folded
               Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
               Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
               Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
               Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
               Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
               Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
               Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
               Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
               Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
               Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_symmetric_fold(Ka)
      .:blockwise_symmetric_fold(Kb)

      J.symmetric_reflect
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      J = TWO*J

   end

   make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the general complex matrices "J" and exchange matrices
   ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
   ! directly from the integrals.
      J :: MAT{REAL}, OUT
      Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}, OUT
      P :: MAT{REAL}, IN

      I :: VEC{REAL}*
      abs_P :: MAT{REAL}*
      max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd :: INT
      a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      I_abcd,factor,cutoff :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J   = ZERO
      Ka  = ZERO
      Kb  = ZERO
      Kba = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff

      no_max_I = FALSE
      if (.max_I.disassociated) no_max_I = TRUE
      if (no_max_I) .:initialize_max_I

      max_P.create(.n_shell_pairs)
      abs_P.create(.n_bf,.n_bf)
      abs_P = max(abs(P),abs(Pa),abs(Pb),abs(Pba))
      .:make_max_density_elements(max_P,abs_P)
      abs_P.destroy

      do ab = 1,.n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ab_same = atom_a==atom_b

         .BASE:set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)

            cd_same = atom_c==atom_d

            skip = ::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            factor = ONE                             ! Evaluate the integrals
            if (aa==bb) factor = HALF                ! Coincidence factors
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d

            if (any_same) then

               .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd

            else

               .BASE:set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd

            end

            I = factor * I

            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = I(abcd)
               J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
               J(c,d)   = J(c,d)   + I_abcd*P(b,a)
               Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric
               Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  ! but must be folded
               Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
               Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
               Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric
               Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  ! but must be folded
               Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
               Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
               Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
               Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
               Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
               Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
               Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
               Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
               Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
               Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_hermitian_fold(Ka)
      .:blockwise_hermitian_fold(Kb)
      J.symmetric_reflect
      J = TWO*J

      Ka.make_hermitian
      Kb.make_hermitian

   end

   make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
      J :: MAT{REAL}, OUT
      Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}, OUT
      P :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      I :: MAT4{REAL}*
      eri_archive,ind_archive :: ARCHIVE*
      q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
      I_abcd :: REAL

      eri_archive.create(.name,"eri_integrals")
      ind_archive.create(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open_for("read-only")
      ind_archive.open_for("read-only")

      J   = ZERO
      Ka  = ZERO
      Kb  = ZERO
      Kba = ZERO

      n_quartets = .atom.no_of_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .BASE:get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

       ! I.create(fa,la,fb,lb,fc,lc,fd,ld)
         allocate(I(fa:la,fb:lb,fc:lc,fd:ld))

         eri_archive.Bfile.read(I)

         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
             I_abcd = I(a,b,c,d)
             J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
             J(c,d)   = J(c,d)   + I_abcd*P(b,a)
             Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
             Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)
             Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
             Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
             Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
             Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)
             Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
             Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
             Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
             Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
             Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
             Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
             Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
             Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
             Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
             Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
         end
         end
         end
         end

       ! I.destroy
         deallocate(I)

      end

      ind_archive.destroy
      eri_archive.destroy

      .:weight_diagonal_blocks(J,TWO)
      .:blockwise_hermitian_fold(Ka)
      .:blockwise_hermitian_fold(Kb)

      J.symmetric_reflect

      Ka.make_hermitian
      Kb.make_hermitian

      J = TWO*J

   end

   make_gc_so_JK_direct(JS,KS,JO,KO,P)
   ! Make the general complex spin orbit Classical and Exchange matrices.
   ! Make them directly from integrals on the fly.
      JS,KS,JO,KO :: MAT5{CPX}, OUT
      P :: MAT4{CPX}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      S,O :: MAT5{REAL}*
      ab,cd,aa,bb,cc,dd,na,nb,nc,nd :: INT
      a,b,c,d,k,fa,fb,fc,fd,la,lb,lc,ld,m,n :: INT
      S_abcd,O_abcd,factor :: REAL
      sh4 :: SHELL4*

      JS = ZERO
      KS = ZERO
      JO = ZERO
      KO = ZERO

      sh4.create

      do ab = 1,.n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb)

         do cd = 1,ab

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd)
            .BASE:copy_shell_quartet(sh4,aa,bb,cc,dd)

            if (sh4.skip_ERI) then ! ??????
               sh4.destroy_ptr_part
               cycle
            end

            allocate(S(fa:la,fb:lb,fc:lc,fd:ld,3))
            allocate(O(fa:la,fb:lb,fc:lc,fd:ld,3))

            sh4.make_spin_orbit_ints(S,O)

            factor = ONE                                   ! Evaluate the integrals
            if (aa==bb) factor = HALF                      ! Coincidence factors
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor
            S = factor * S
            O = factor * O

            do k = 1,3
            do a = fa,la
            do b = fb,lb
            do c = fc,lc
            do d = fd,ld

               S_abcd = S(a,b,c,d,k)
               O_abcd = O(a,b,c,d,k)

               do m = 1,2
               do n = 1,2

                  JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(d,c, m,n)
                  JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(c,d, m,n)
                  JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(d,c, m,n)
                  JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(c,d, m,n)
                  JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(b,a, m,n)
                  JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(a,b, m,n)
                  JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(b,a, m,n)
                  JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(a,b, m,n)

                  JO(a,b, m,n,k) = JO(a,b, m,n,k) + O_abcd*P(d,c, m,n)
                  JO(a,b, m,n,k) = JO(a,b, m,n,k) - O_abcd*P(c,d, m,n)
                  JO(b,a, m,n,k) = JO(b,a, m,n,k) + O_abcd*P(d,c, m,n)
                  JO(b,a, m,n,k) = JO(b,a, m,n,k) - O_abcd*P(c,d, m,n)
                  JO(c,d, m,n,k) = JO(c,d, m,n,k) + S_abcd*P(b,a, m,n)
                  JO(c,d, m,n,k) = JO(c,d, m,n,k) - S_abcd*P(a,b, m,n)
                  JO(d,c, m,n,k) = JO(d,c, m,n,k) + S_abcd*P(b,a, m,n)
                  JO(d,c, m,n,k) = JO(d,c, m,n,k) - S_abcd*P(a,b, m,n)

                  KS(a,d, m,n,k) = KS(a,d, m,n,k) + S_abcd*P(b,c, m,n)
                  KS(a,c, m,n,k) = KS(a,c, m,n,k) + S_abcd*P(b,d, m,n)
                  KS(b,d, m,n,k) = KS(b,d, m,n,k) - S_abcd*P(a,c, m,n)
                  KS(b,c, m,n,k) = KS(b,c, m,n,k) - S_abcd*P(a,d, m,n)
                  KS(c,b, m,n,k) = KS(c,b, m,n,k) + O_abcd*P(d,a, m,n)
                  KS(c,a, m,n,k) = KS(c,a, m,n,k) + O_abcd*P(d,b, m,n)
                  KS(d,b, m,n,k) = KS(d,b, m,n,k) - O_abcd*P(c,a, m,n)
                  KS(d,a, m,n,k) = KS(d,a, m,n,k) - O_abcd*P(c,b, m,n)

                  KO(a,d, m,n,k) = KO(a,d, m,n,k) + O_abcd*P(b,c, m,n)
                  KO(a,c, m,n,k) = KO(a,c, m,n,k) - O_abcd*P(b,d, m,n)
                  KO(b,d, m,n,k) = KO(b,d, m,n,k) + O_abcd*P(a,c, m,n)
                  KO(b,c, m,n,k) = KO(b,c, m,n,k) - O_abcd*P(a,d, m,n)
                  KO(c,b, m,n,k) = KO(c,b, m,n,k) + S_abcd*P(d,a, m,n)
                  KO(c,a, m,n,k) = KO(c,a, m,n,k) - S_abcd*P(d,b, m,n)
                  KO(d,b, m,n,k) = KO(d,b, m,n,k) + S_abcd*P(c,a, m,n)
                  KO(d,a, m,n,k) = KO(d,a, m,n,k) - S_abcd*P(c,b, m,n)

               end
               end

            end
            end
            end
            end
            end

            deallocate(O)
            deallocate(S)
            sh4.destroy_ptr_part

         end
      end

      sh4.destroy

   end

   make_gc_so_JK_disk(JS,KS,JO,KO,P,component)
   ! Make the general complex spin orbit Classical and Exchange matrices
   ! for a particular "component", either "x", "y" or "z".
      JS,KS,JO,KO :: MAT4{CPX}, OUT
      P :: MAT4{CPX}, IN
      component :: STR(len=1), IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      S,O :: MAT4{REAL}*
      SO_archive,ind_archive :: ARCHIVE
      q,n_quartets :: INT
      a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,m,n :: INT
      S_abcd,O_abcd :: REAL

      SO_archive.set(.name,"SO"//component//"_integrals")
      ind_archive.set(.name,"SO_indices")

      ENSURE(SO_archive.exists,  "no spin orbit integral file!")
      ENSURE(ind_archive.exists, "no spin orbit integral index file")

      SO_archive.open_for("read-only")
      ind_archive.open_for("read-only")

      JS = ZERO
      KS = ZERO
      JO = ZERO
      KO = ZERO

      n_quartets = .atom.no_of_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .BASE:get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         S.create(fa,la,fb,lb,fc,lc,fd,ld)
         O.create(fa,la,fb,lb,fc,lc,fd,ld)

         SO_archive.Bfile.read(S)
         SO_archive.Bfile.read(O)

         do a = fa,la
         do b = fb,lb
         do c = fc,lc
         do d = fd,ld

            S_abcd = S(a,b,c,d)
            O_abcd = O(a,b,c,d)

            do m = 1,2
            do n = 1,2

               JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(d,c, m,n)
               JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(c,d, m,n)
               JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(d,c, m,n)
               JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(c,d, m,n)
               JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(b,a, m,n)
               JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(a,b, m,n)
               JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(b,a, m,n)
               JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(a,b, m,n)

               JO(a,b, m,n) = JO(a,b, m,n) + O_abcd*P(d,c, m,n)
               JO(a,b, m,n) = JO(a,b, m,n) - O_abcd*P(c,d, m,n)
               JO(b,a, m,n) = JO(b,a, m,n) + O_abcd*P(d,c, m,n)
               JO(b,a, m,n) = JO(b,a, m,n) - O_abcd*P(c,d, m,n)
               JO(c,d, m,n) = JO(c,d, m,n) + S_abcd*P(b,a, m,n)
               JO(c,d, m,n) = JO(c,d, m,n) - S_abcd*P(a,b, m,n)
               JO(d,c, m,n) = JO(d,c, m,n) + S_abcd*P(b,a, m,n)
               JO(d,c, m,n) = JO(d,c, m,n) - S_abcd*P(a,b, m,n)

               KS(a,d, m,n) = KS(a,d, m,n) + S_abcd*P(b,c, m,n)
               KS(a,c, m,n) = KS(a,c, m,n) + S_abcd*P(b,d, m,n)
               KS(b,d, m,n) = KS(b,d, m,n) - S_abcd*P(a,c, m,n)
               KS(b,c, m,n) = KS(b,c, m,n) - S_abcd*P(a,d, m,n)
               KS(c,b, m,n) = KS(c,b, m,n) + O_abcd*P(d,a, m,n)
               KS(c,a, m,n) = KS(c,a, m,n) + O_abcd*P(d,b, m,n)
               KS(d,b, m,n) = KS(d,b, m,n) - O_abcd*P(c,a, m,n)
               KS(d,a, m,n) = KS(d,a, m,n) - O_abcd*P(c,b, m,n)

               KO(a,d, m,n) = KO(a,d, m,n) + O_abcd*P(b,c, m,n)
               KO(a,c, m,n) = KO(a,c, m,n) - O_abcd*P(b,d, m,n)
               KO(b,d, m,n) = KO(b,d, m,n) + O_abcd*P(a,c, m,n)
               KO(b,c, m,n) = KO(b,c, m,n) - O_abcd*P(a,d, m,n)
               KO(c,b, m,n) = KO(c,b, m,n) + S_abcd*P(d,a, m,n)
               KO(c,a, m,n) = KO(c,a, m,n) - S_abcd*P(d,b, m,n)
               KO(d,b, m,n) = KO(d,b, m,n) + S_abcd*P(c,a, m,n)
               KO(d,a, m,n) = KO(d,a, m,n) - S_abcd*P(c,b, m,n)

            end
            end

         end
         end
         end
         end

         O.destroy
         S.destroy

      end

      SO_archive.close
      ind_archive.close

   end

!  =============
!  Schwarz tests
!  =============

   schwarz_inequality_test(cutoff,ab,cd,a,b,c,d,P_max,I_max) result(skip) ::: selfless
   ! Return "skip", a logical variable which is TRUE if the maximum contribution
   ! to the restricted Fock matrix (based on the schwarz inequality test) from a
   ! shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd" is
   ! smaller than a preset "cutoff". "P_max" is the maximum density matrix
   ! elements for each shell pair "ab", and "I_max(ab)" is maximum value of the
   ! square root of the integral (ab|ab) for the shell pair with index "ab".
      skip :: BIN
      cutoff :: REAL
      ab,cd, a,b,c,d :: INT
      P_max,I_max :: VEC{REAL}

      Pmax :: REAL
      ac,ad,bc,bd,k,l,m,n :: INT

      ! Indices for (ab|cd) < sqrt(ab|ab) * sqrt(cd|cd) test.
      k = max(b,c); l = min(b,c)
      m = max(b,d); n = min(b,d)
      ac = ((a-1)*a)/2 + c
      ad = ac - c + d
      bc = ((k-1)*k)/2 + l
      bd = ((m-1)*m)/2 + n

      Pmax = max(P_max(ab),P_max(cd),P_max(ac),P_max(ad),P_max(bc),P_max(bd))

      if (Pmax < TOL(20)) then

        skip = TRUE

      else

        if (Pmax*I_max(ab)*I_max(cd) > cutoff) then; skip = FALSE
        else;                                        skip = TRUE
        end

      end

   end

   schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,a,b,c,d,P_max,I_max) ::: selfless, private
   ! contribution to the J and K matrices (based on the schwarz inequality test)
   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
      skip_J,skip_K :: BIN, OUT
      cutoff,JP_cut,KP_cut :: REAL, IN
      ab,cd, a,b,c,d :: INT, IN
      P_max,I_max :: VEC{REAL}, IN

      JP_max,KP_max :: REAL
      ac,ad,bc,bd,k,l,m,n :: INT

      ! Indices for (ab|cd) < sqrt(ab|ab) * sqrt(cd|cd) test.
      k = max(b,c); l = min(b,c)
      m = max(b,d); n = min(b,d)
      ac = (a-1)*a/2 + c
      ad = ac - c + d
      bc = (k-1)*k/2 + l
      bd = (m-1)*m/2 + n

      JP_max = max(P_max(ab),P_max(cd))
      KP_max = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))

      skip_J = FALSE
      if      (JP_max < JP_cut) then;                     skip_J = TRUE
      else if (JP_max*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
      end

      skip_K = FALSE
      if      (KP_max < KP_cut) then;                     skip_K = TRUE
      else if (KP_max*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
      end

   end

   schwarz_J_test(skip_J,cutoff,ab,cd,P_max,I_max) ::: selfless, private
   ! Return "skip_J" which is set TRUE if the maximum contribution to the J
   ! matrix (based on the schwarz inequality test) from a shell of ERI integrals
   ! (ab|cd) with shell pair indices "ab" and "cd" is smaller than a preset
   ! "cutoff". "P_max(ab)" is the maximum density matrix elements for each shell
   ! pair "ab", and "I_max(ab)" is maximum value of the square root of the
   ! integral (ab|ab) for the shell pair with index "ab".
      skip_J :: BIN, OUT
      cutoff :: REAL, IN
      ab,cd :: INT, IN
      P_max,I_max :: VEC{REAL}, IN

      Jmax :: REAL

      Jmax = max(P_max(ab),P_max(cd))

      skip_J = FALSE
      if      (Jmax < TOL(20)) then;                    skip_J = TRUE
      else if (Jmax*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
      end

   end

   schwarz_K_test(skip_K,cutoff,ab,cd,a,b,c,d,P_max,I_max) ::: selfless, private
   ! Return "skip_K", logical variables are TRUE if the maximum
   ! contribution to the K matrices (based on the schwarz inequality test)
   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
      skip_K :: BIN, OUT
      cutoff :: REAL, IN
      ab,cd, a,b,c,d :: INT, IN
      P_max,I_max :: VEC{REAL}, IN

      Kmax :: REAL
      ac,ad,bc,bd,k,l,m,n :: INT

      k = max(b,c); l = min(b,c)
      m = max(b,d); n = min(b,d)

      ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
      ac = (a-1)*a/2 + c
      ad = ac - c + d
      bc = (k-1)*k/2 + l
      bd = (m-1)*m/2 + n

      Kmax = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))

      skip_K = FALSE
      if      (Kmax < TOL(20)) then;                    skip_K = TRUE
      else if (Kmax*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
      end

   end

   make_max_density_elements(P_max,P)
   ! Make "P_max", the maximum of the (a,b) density elements of "P" over each
   ! shell pair, for use in the schwarz test.
      P_max :: VEC{REAL}
      P :: MAT{REAL}

   ENSURE(size(P_max)==.n_shell_pairs,"wrong size, P_max")
   ENSURE(P.is_square,"wrong shape, P")
   ENSURE(P.dim1==.n_bf,"wrong size, P")

      ab,aa,bb,fa,fb,la,lb,na,nb, a,b :: INT
      Pmax :: REAL

      ! Store the largest integral for each shell pair ab|ab
      do ab = 1, .n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb)

         Pmax = ZERO
         do a = fa,la
         do b = fb,lb
            Pmax = max(abs(P(a,b)),Pmax)
         end
         end

         P_max(ab) = Pmax

      end

   end

   make_max_density_elements(P_max,Pa,Pb)
   ! Make "P_max", the maximum of the (a,b) density elements of "Pa"
   ! and "Pb" over each shell pair, for use in the schwarz test.
      P_max :: VEC{REAL}
      Pa,Pb :: MAT{REAL}

   ENSURE(size(P_max)==.n_shell_pairs,"wrong size, P_max")
   ENSURE(Pa.is_square,"wrong shape, Pa")
   ENSURE(Pb.is_square,"wrong shape, Pb")
   ENSURE(Pa.dim1==.n_bf,"wrong size, Pa")
   ENSURE(Pb.dim1==.n_bf,"wrong size, Pb")

      ab,aa,bb,fa,fb,la,lb,na,nb, a,b :: INT
      Pmax :: REAL

      ! Store the largest integral for each shell pair ab|ab
      do ab = 1, .n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb)

         Pmax = ZERO
         do a = fa,la
         do b = fb,lb
            Pmax = max(abs(Pa(a,b)),abs(Pb(a,b)),Pmax)
         end
         end
         P_max(ab) = Pmax

      end

   end

   initialize_max_I ::: leaky
   ! Initialize Schwarz inequality test integrals
      self :: INOUT

      .max_I.destroy
      .max_I.create(.n_shell_pairs)
      .FOCK:make_max_abab_integrals(.max_I)

   end

   make_max_abab_integrals(I_max)
   ! Make "I_max", the square root of the maximum of the (ab|ab) ERI integrals.
      I_max :: VEC{REAL}, OUT

   ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")

      ab,sa,sb,fa,fb,la,lb,na,nb, a,b :: INT
      sh4q :: SHELL1QUARTET
      Iabab :: MAT4{REAL}*
      Imax :: REAL

      do ab = 1, .n_shell_pairs

         .BASE:get_shell_pair_indices(ab,sa,sb,fa,la,na,fb,lb,nb)

         .BASE:set_new_shell_quartet_ab(sh4q,sa,sb,skip=FALSE) ! (ab|ab} shell
         .BASE:set_new_shell_quartet_cd(sh4q,sa,sb,skip=FALSE)

         Iabab.create(na,nb,na,nb)
         SHELL1QUARTET::make_ERI(sh4q,Iabab)

         sh4q.destroy_ptr_part

         Imax = ZERO
         do a = 1,na
         do b = 1,nb
            Imax = max(abs(Iabab(a,b,a,b)),Imax)
         end
         end

         I_max(ab) = sqrt(Imax)

         Iabab.destroy

      end

   end

   make_max_abab_so_integrals(I_max)
   ! Make "I_max", the square root of the maximum of the all (ab|ab) spin orbit
   ! integrals.
      I_max :: VEC{REAL}

   ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")

      ab,sa,sb,fa,fb,la,lb,na,nb, a,b :: INT
      sh4 :: SHELL4
      S,O :: MAT5{REAL}*
      Imax :: REAL

      sh4.set_spherical(.use_spherical_basis)

      ! Store the largest integral for each shell pair ab|ab
      do ab = 1, .n_shell_pairs           ! Store the largest integral for each

         .BASE:get_shell_pair_indices(ab,sa,sb,fa,la,na,fb,lb,nb)

         .BASE:copy_shell_quartet_ab(sh4,sa,sb)
         .BASE:copy_shell_quartet_cd(sh4,sa,sb)

         S.create(na,nb,na,nb,3)
         O.create(na,nb,na,nb,3)
         sh4.make_spin_orbit_ints(S,O)

         sh4.destroy_ptr_part

         Imax = ZERO
         do a = 1,na
         do b = 1,nb
            Imax = max(abs(S(a,b,a,b,1)),abs(S(a,b,a,b,2)),abs(S(a,b,a,b,3)), &
                       abs(O(a,b,a,b,1)),abs(O(a,b,a,b,2)),abs(O(a,b,a,b,3)),Imax)
         end
         end

         I_max(ab) = sqrt(Imax)

         O.destroy
         S.destroy

      end

   end

   make_max_S_integrals(S_max)
   ! Make "S_max", the maximum of the overlap integrals between basis
   ! functions in all pairs of shells.
      S_max :: VEC{REAL}

   ENSURE(S_max.dim==.n_shell_pairs,"wrong size, S_max")

      ab,sa,sb,fa,la,fb,lb,na,nb :: INT

      do ab = 1,.n_shell_pairs
         .BASE:get_shell_pair_indices(ab,sa,sb,fa,la,na,fb,lb,nb)
         S_max(ab) = maxval(abs(.overlap_matrix(fa:la,fb:lb)))
      end

   end

!  ===============
!  J-matrix engine
!  ===============

   reverse_transfer(P,PV) ::: leaky
   ! Apply the reverse horizontal recursion relation (i.e. the reverse
   ! transfer relation) to matrix "P" to produce the shell pair vector
   ! "PV" which has to be multipled by the (es|fs) source integrals to
   ! give the J-matrix.
      P :: MAT{REAL}
      PV :: VEC{VEC_{REAL}}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom info")

      R :: VEC{REAL}(3)
      R1,R2,R3,T1,T2,T3,fx,fy,fz,P_ab :: REAL
      Rx,Ry,Rz,ab :: VEC{REAL}*
      ax,ay,az,bx,by,bz,binx,biny,binz :: VEC{INT}*
      q,fa,la,na,fb,lb,nb,atom_a,atom_b,aa,bb,af,al,bf,bl,f :: INT
      i,k,a,b,x,y,z,xa,ya,za,xb,yb,zb,xx,yy,zz :: INT
      new_atom_pair,same_atoms,a_gt_b,a_lt_b :: BIN
      sh :: SHELL2

      Rx.create(.basis_l_max+1)
      Ry.create(.basis_l_max+1)
      Rz.create(.basis_l_max+1)
      PV.create(.n_shell_pairs)                                ! leaky

      a_gt_b = TRUE
      a_lt_b = TRUE
      aa = 0
      bb = 0

      do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         PV(q).element.create(sh.n_gaussian)                   ! leaky
         ab => PV(q).element

         if      (sh.l_sum==0) then                            ! SS case

            ab(1) = P(fa,fb)

         else if (sh.a.l==0) then                              ! XS case

            fb = fb - 1
            if (sh.l_max<2) then                               ! No normalisers
               do b = 1,sh.b.n_comp
                  ab(b) = P(fa,fb+b)
               end
            else                                               ! Include normalisers
               do b = 1,sh.b.n_comp
                  ab(b) = P(fa,fb+b)
               end
            end

         else if (sh.b.l==0) then                              ! SX case

            fa = fa - 1
            if (sh.l_max<2) then                               ! No normalisers
               do a = 1,sh.a.n_comp
                  ab(a) = P(fa+a,fb)
               end
            else                                               ! Include normalisers
               do a = 1,sh.a.n_comp
                  ab(a) = P(fa+a,fb)
               end
            end

         else                                                  ! General case

            ab = ZERO
            af =  GAUSSIAN_DATA:n_comp_up_to(sh.a.l-1) + 1; al = af + sh.a.n_comp - 1
            bf =  GAUSSIAN_DATA:n_comp_up_to(sh.b.l-1) + 1; bl = bf + sh.b.n_comp - 1
            ax => GAUSSIAN_DATA::nx(af:al)
            ay => GAUSSIAN_DATA::ny(af:al)
            az => GAUSSIAN_DATA::nz(af:al)
            bx => GAUSSIAN_DATA::nx(bf:bl)
            by => GAUSSIAN_DATA::ny(bf:bl)
            bz => GAUSSIAN_DATA::nz(bf:bl)
            af = af - 1
            bf = bf - 1
            fa = fa - 1
            fb = fb - 1
            new_atom_pair = atom_a/=aa OR atom_b/=bb
            same_atoms = atom_a==atom_b
            aa = atom_a; bb = atom_b

            if (same_atoms) then                               ! No transfer

               if (sh.a.l > sh.b.l) then; f = af
               else;                      f = bf
               end

               if (sh.l_max<2) then                            ! No normalising factors

                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        xx = xa + xb - 1
                        yy = ya + yb - 1
                        zz = za + zb - 1
                        i = GAUSSIAN_DATA::index_of(xx,yy,zz) - f
                        ab(i) = ab(i) + P_ab
                     end
                  end

               else                                            ! Include normalisers

                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        k = k + 1
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        xx = xa + xb - 1
                        yy = ya + yb - 1
                        zz = za + zb - 1
                        i = index_of(xx,yy,zz) - f
                        ab(i) = ab(i) + P_ab
                     end
                  end

               end

            else if (sh.a.l > sh.b.l) then                     ! Transfer to a

               if (new_atom_pair OR a_lt_b) then

                  a_gt_b = TRUE; a_lt_b = FALSE
                  R = sh.a.position - sh.b.position
                  R1 = R(1);   R2 = R(2);   R3 = R(3)
                  T1 = R1;     T2 = R2;     T3 = R3
                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
                  do i = 2,sh.l_max+1
                     Rx(i) = T1; T1 = R1*T1
                     Ry(i) = T2; T2 = R2*T2
                     Rz(i) = T3; T3 = R3*T3
                  end

               end

               if (sh.l_max<2) then                            ! No normalisers

                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     binx => GAUSSIAN_DATA::binomial_p1(xb)%element
                     biny => GAUSSIAN_DATA::binomial_p1(yb)%element
                     binz => GAUSSIAN_DATA::binomial_p1(zb)%element
                     do a = 1,sh.a.n_comp
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        do x = 1,xb
                           xx = xa + x - 1
                           fx = binx(x)*Rx(xb-x+1)*P_ab
                           do y = 1,yb
                              yy = ya + y - 1
                              fy = biny(y)*Ry(yb-y+1)
                              do z = 1,zb
                                 zz = za + z - 1
                                 fz = binz(z)*Rz(zb-z+1)
                                 i = index_of(xx,yy,zz) - af
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end

               else                                            ! Include normalisers

                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     binx => GAUSSIAN_DATA::binomial_p1(xb)%element
                     biny => GAUSSIAN_DATA::binomial_p1(yb)%element
                     binz => GAUSSIAN_DATA::binomial_p1(zb)%element
                     do a = 1,sh.a.n_comp
                        k = k + 1
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        do x = 1,xb
                           xx = xa + x - 1
                           fx = binx(x)*Rx(xb-x+1)*P_ab
                           do y = 1,yb
                              yy = ya + y - 1
                              fy = biny(y)*Ry(yb-y+1)
                              do z = 1,zb
                                 zz = za + z - 1
                                 fz = binz(z)*Rz(zb-z+1)
                                 i = index_of(xx,yy,zz) - af
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               end

            else                                              ! Transfer to b

               if (new_atom_pair OR a_gt_b) then

                  a_gt_b = FALSE; a_lt_b = TRUE
                  R = sh.b.position - sh.a.position
                  R1 = R(1);   R2 = R(2);   R3 = R(3)
                  T1 = R1;     T2 = R2;     T3 = R3
                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
                  do i = 2,sh.l_max+1
                     Rx(i) = T1; T1 = R1*T1
                     Ry(i) = T2; T2 = R2*T2
                     Rz(i) = T3; T3 = R3*T3
                  end

               end

               if (sh.l_max<2) then                           ! No normalisers

                  do a = 1,sh.a.n_comp
                     xa = ax(a); ya = ay(a); za = az(a)
                     binx => GAUSSIAN_DATA::binomial_p1(xa)%element
                     biny => GAUSSIAN_DATA::binomial_p1(ya)%element
                     binz => GAUSSIAN_DATA::binomial_p1(za)%element
                     do b = 1,sh.b.n_comp
                        P_ab = P(fa+a,fb+b)
                        xb = bx(b); yb = by(b); zb = bz(b)
                        do x = 1,xa
                           xx = xb + x - 1
                           fx = binx(x)*Rx(xa-x+1)*P_ab
                           do y = 1,ya
                              yy = yb + y - 1
                              fy = biny(y)*Ry(ya-y+1)
                              do z = 1,za
                                 zz = zb + z - 1
                                 fz = binz(z)*Rz(za-z+1)
                                 i = index_of(xx,yy,zz) - bf
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end

               else                                           ! Include normalisers

                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        xa = ax(a); ya = ay(a); za = az(a)
                        binx => GAUSSIAN_DATA::binomial_p1(xa)%element
                        biny => GAUSSIAN_DATA::binomial_p1(ya)%element
                        binz => GAUSSIAN_DATA::binomial_p1(za)%element
                        k = k + 1
                        P_ab = P(fa+a,fb+b)
                        do x = 1,xa
                           xx = xb + x - 1
                           fx = binx(x)*Rx(xa-x+1)*P_ab
                           do y = 1,ya
                              yy = yb + y - 1
                              fy = biny(y)*Ry(ya-y+1)
                              do z = 1,za
                                 zz = zb + z - 1
                                 fz = binz(z)*Rz(za-z+1)
                                 i = index_of(xx,yy,zz) - bf
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end

               end

            end  ! Trasfer to b
         end     ! general case

         sh.destroy_ptr_part

      end        ! loop over shell pairs

      Rz.destroy
      Ry.destroy
      Rx.destroy

   end

   forward_transfer(JJ,J) ::: leaky
   ! Apply the horizontal recursion relation (i.e. the transfer
   ! relation) to shellpair vector "JJ" to produce the matrix "J".
   ! This is a post-processing operation to shift momentum from
   ! center a -> b.
      JJ :: VEC{VEC_{REAL}}
      J :: MAT{REAL}

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom info")
   ENSURE(JJ.dim==.n_shell_pairs,"wrong size, JJ")
   ENSURE(J.dim1==.n_bf,"wrong size, J")
   ENSURE(J.is_square,"wrong shape, J")

      q,fa,la,na,fb,lb,nb :: INT
      ab :: VEC{REAL}*
      W  :: MAT{REAL}*
      sh :: SHELL2

      do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         ab => JJ(q).element
         W.create(sh.a.n_comp,sh.b.n_comp)
         sh.transfer(ab,W)
         J(fa:la,fb:lb) = W
         W.destroy

         sh.destroy_ptr_part

      end

   end

   create_transfer(JJ) ::: leaky
   ! Create space for the transfer vector "JJ". It is a shellpair vector of
   ! flattened es-type componenets from which ab components can be formed by the
   ! transfer relation.
      JJ :: VEC{VEC_{REAL}}*
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom info")

      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      JJ.create(.n_shell_pairs)                        ! leaky

      do q = 1,.n_shell_pairs
         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
         JJ(q).element.create(sh.n_gaussian)           ! leaky
         JJ(q).element = ZERO
         sh.destroy_ptr_part
      end

   end

!  ===========================
!  J & K shell-block weighting
!  ===========================

   weight_diagonal_blocks(X,fac) ::: pure
   ! Weight the diagonal blocks of matrix "X" by "fac"
      self :: IN
      X :: MAT{REAL}, INOUT
      fac :: REAL, IN

      n,f,l :: INT

      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac*X(f:l,f:l)
      end

   end

   weight_diagonal_blocks(X,fac) ::: pure
   ! Weight the diagonal blocks of matrix "X" by "fac"
      self :: IN
      X :: MAT{CPX}, INOUT
      fac :: REAL, IN

      n,f,l :: INT

      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac*X(f:l,f:l)
      end

   end

   set_diagonal_blocks(X,fac) ::: pure
   ! Set the diagonal blocks of matrix "X" to "fac"
      self :: IN
      X :: MAT{REAL}, INOUT
      fac :: REAL, IN

      n,f,l :: INT

      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac
      end

   end

   blockwise_symmetric_fold(X)
   ! Symmetrically fold the matrix "X" blockwise
      X :: MAT{REAL}, INOUT

      a,fa,la,b,fb,lb :: INT

      do a = 1,.n_shell
      do b = 1,a
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
      end
      end

   end

   blockwise_hermitian_fold(X)
   ! Hermitian fold the matrix "X" blockwise
      X :: MAT{CPX}, INOUT

      a,fa,la,b,fb,lb :: INT

      do a = 1,.n_shell
      do b = 1,a
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
      end
      end

   end

!  ==================
!  Atom group testing
!  ==================

   in_same_atom_group(atom_a,atom_b,group) result (res)
   ! Return TRUE if the atoms are all in the same atom_group
   ! If present, "group" is set to the common group index.
      atom_a,atom_b :: INT
      group :: INT, optional
      res :: BIN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(atom_a<=.atom.dim,"atom_a out of range")
   ENSURE(atom_b<=.atom.dim,"atom_b out of range")

      n,n_group :: INT
      found :: BIN

      n_group = .atom_group.dim

      res   = TRUE
      found = FALSE

      do n = 1,n_group
         if (any(atom_a==.atom_group(n).atom_index)) then
            found = TRUE
            if (NOT any(atom_b==.atom_group(n).atom_index)) res = FALSE
            exit
         end
      end

      DIE_IF(NOT found,"atom_a was not found in any atom_group")

      if (present(group)) then
         if (res) then; group = n
         else;          group = 0
         end
      end

   end

   in_same_atom_group(atom_a,atom_b,atom_c,atom_d) result (res)
   ! Return TRUE if the atoms are all in the same atom_group
      atom_a,atom_b,atom_c,atom_d :: INT
      res :: BIN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(atom_a<=.atom.dim,"atom_a out of range")
   ENSURE(atom_b<=.atom.dim,"atom_b out of range")
   ENSURE(atom_c<=.atom.dim,"atom_c out of range")
   ENSURE(atom_d<=.atom.dim,"atom_d out of range")

      n,n_group :: INT
      found :: BIN

      n_group = .atom_group.dim

      res   = TRUE
      found = FALSE

      do n = 1,n_group
         if (any(atom_a==.atom_group(n).atom_index)) then
            found = TRUE
            if (NOT any(atom_b==.atom_group(n).atom_index)) res = FALSE
            if (NOT any(atom_c==.atom_group(n).atom_index)) res = FALSE
            if (NOT any(atom_d==.atom_group(n).atom_index)) res = FALSE
            exit
         end
      end

      DIE_IF(NOT found,"atom_a was not found in any atom_group")

   end

!  ==============
!  Restricted DFT
!  ==============

   add_XC_matrix_KS(K) ::: leaky
   ! Add the DFT exchange correlation matrix to "K".
      K :: OPMATRIX@

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.scfdata.is_DFT_calculation,"this is not a DFT calculation")
   ENSURE(.density_matrix.allocated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(K.allocated,"K not created")
   ENSURE(K.is_allocated_with_genre(.scfdata.spinorbital_kind),"appropriate part of K not created")

      ! Now add the contribution
      select case (.scfdata.scf_kind)

      case ("rks","xray_rks")
         .:add_XC_matrix_r_KS(K.restricted)

      case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
         .:add_XC_matrix_u_KS(K.alpha, K.beta)

      case default
         DIE("unknown DFT SCF kind, "//trim(.scfdata.scf_kind))

      end

   end

   add_XC_matrix_r_KS(K)
   ! Calculate the exchange correlation matrix numerically.
      self :: INOUT
      K :: MAT{REAL}, INOUT

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.scfdata.is_DFT_calculation,"this is not a DFT calculation")

      E :: REAL

      if (.scfdata.using_GGA_functional) then

       ! if (.BASE:debugging("use_add_GGA_XC_matrix_old")) then
       !    .:add_GGA_XC_matrix_old(K,E)
       ! else
            .:add_GGA_XC_matrix(K,E)
       ! end


      else

       ! if (.BASE:debugging("use_add_LDA_XC_matrix_old")) then
       !    .:add_LDA_XC_matrix_old(K,E)
       ! else
            .:add_LDA_XC_matrix(K,E)
       ! end

      end
      
   ! dj
 ! stdout.text("K:")
 ! stdout.put(K)

      .scfdata.dft_energy_correction = E

   end

   add_XC_matrix_u_KS(Ka,Kb)
   ! Calculate the exchange correlation matrix numerically.
      Ka,Kb :: MAT{REAL}, INOUT

      E,Ea,Eb :: REAL

      if (NOT .scfdata.using_GGA_functional) then

       ! if (.BASE:debugging("use_add_LDA_XC_matrix_old")) then
       !    .:add_LDA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
       ! else
            .:add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb)
       ! end

      else

       ! if (.BASE:debugging("use_add_GGA_XC_matrix_old")) then
       !    .:add_GGA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
       ! else
            .:add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb)
       ! end

      end

      .scfdata.dft_energy_correction       = E
      .scfdata.dft_alpha_energy_correction = Ea
      .scfdata.dft_beta_energy_correction  = Eb

   end

! LDA

   add_LDA_XC_matrix(K,E) ::: leaky
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      K :: MAT{REAL}
      E :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.restricted.allocated,"no restricted density matrix")

      wt, N0,V0,E0 :: VEC{REAL}*
      V, pt  :: MAT{REAL}*
      D :: MAT{REAL}@
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      E = ZERO
      V.create(.n_bf,.n_bf); V = ZERO

      ! Make the AO density matrix
      D = .density_matrix.restricted

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .GRID:make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,.density_matrix.restricted)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim
         E0.create(n_pt) ! The energy density
         V0.create(n_pt) ! local potential grids
         .:new_set_r_XC_potentials(V0,N0)
         .:new_set_r_XC_energy_density(E0,N0)

         ! Incorporate grid & partition weights
         E0 = wt*E0
         V0 = wt*V0

         ! Clean
         N0.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E
         ! for atom "c" Becke-grid
         .:add_LDA_XC_matrix(V,E,V0,E0,bf_skip,bf_grid0,c,.density_matrix.restricted)

         ! Clean up
         V0.destroy
         E0.destroy
         bf_grid0.destroy
         bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      K = K + V
      K.symmetric_reflect

      ! Get DFT energy correction
      V.symmetric_reflect
      E = E - HALF*V.trace_product_with(.density_matrix.restricted)

      ! Clean
      V.destroy

   end

   add_LDA_XC_matrix(V,E,V0,E0,bf_skip,bf_grid0,c,D)
   ! Add XC potential matrix elements to "V", the XC energy to "E".
   ! "V0" is XC potential density on the becke grid for atom "c",
   ! weighted by the partition function for that atom. Likewise, "E0"
   ! is the (partition-weighted) XC energy density of the grid.
   ! "bf_skip" and "bf_grid0 are basis function grids.  "D" is the
   ! density matrix.  This routine supports local functional only.
      V :: MAT{REAL}, target
      E :: REAL
      V0,E0 :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grid0 :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      D :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.restricted.allocated,"no restricted density matrix")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")

      ga0,gb0 :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      VV,DD :: MAT{REAL}*
      grida0,gridb0 :: MAT{REAL}*
      Dab, fac,val,wal, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.disassociated) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element
            grida0 => bf_grid0(sa).element

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VV => V(fa:la,fb:lb)
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     val = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        val = val + V0(n)*gab
                        wal = wal + E0(n)*gab
                     end
                     VV(1,1) = VV(1,1) + val
                     E       = E       + wal*Dab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           val = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              val = val + V0(n)*gab
                              wal = wal + E0(n)*gab
                           end
                           VV(a,b) = VV(a,b) + val
                           E       = E       + wal*Dab
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

!   add_LDA_XC_matrix_old(K,E)
!   ! Add the exchange and correlation matrices to K. This routine supports
!   ! local functional only, either exchange or correlation.
!      K :: MAT{REAL}
!      E :: REAL
!
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.becke_grid.allocated, "need to specify becke_grid for DFT integrations")
!
!      pt,a0,b0,V,W :: MAT{REAL}*
!      wt,rho0,V0,E0,ab0 :: VEC{REAL}*
!      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
!      atom_a,atom_b :: INT
!      same_atoms :: BIN
!      atom1 :: VEC{INT}(1), target
!      atom2 :: VEC{INT}(2), target
!      atoms :: VEC{INT}*
!      V_ab :: REAL
!
!      W.create(.n_bf,.n_bf)
!      V.create(.n_bf,.n_bf)                     ! Use temporary V for parallelisation
!      V = ZERO
!
!      nullify(a0)
!      nullify(b0)
!
!      do q = 1,.BASE:no_of_atom_pairs
!
!         if (NOT .overlapping_atoms(q)) cycle
!
!         .BASE:get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
!
!         same_atoms = atom_a==atom_b
!         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
!         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
!         end
!
!         ! Make the grid points and weights
!         ! Keep the weight_is_0 array
!         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
!
!         ! The energy density &
!         ! local potential grids
!         n_pt = pt.dim1
!         V0.create(n_pt)
!         E0.create(n_pt)
!         ab0.create(n_pt)
!         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
!
!         ! The density grids
!         rho0.create(n_pt)
!         .GRID:make_density_grid_r_B(rho0,pt,atoms,a0,b0)
!
!         ! Evaluation the XC potentials
!         .:new_set_r_XC_potentials(V0,rho0)
!         .:new_set_r_XC_energy_density(E0,rho0)
!         rho0.destroy
!
!         V0 = wt*V0
!         E0 = wt*E0
!
!         wt.destroy
!         pt.destroy
!
!         ! Make the exchange correlation matrix
!         do a = 1,na
!         do b = 1,nb
!            ab0 = a0(:,a)*b0(:,b)
!            V_ab = VEC{REAL}:sum_elements(V0*ab0)
!            aa = fa + a
!            bb = fb + b
!            V(aa,bb) = V_ab
!            ! Make the DFT energy correction matrix
!            W(aa,bb) = -HALF*V_ab + VEC{REAL}:sum_elements(E0*ab0)
!         end
!         end
!
!         ab0.destroy
!         E0.destroy
!         V0.destroy
!         if (same_atoms) then
!            a0.destroy
!            nullify(b0)
!         else
!            b0.destroy
!            a0.destroy
!         end
!
!      end
!
!      ! Debug
!      .BASE:put_debug(V,"add_LDA_XC_matrix: V")
!      .BASE:put_debug(W,"add_LDA_XC_matrix: W")
!
!      K = K + V
!      V.destroy
!      K.symmetric_reflect
!
!      W.symmetric_reflect
!      E = W.trace_product_with(.density_matrix.restricted)
!      W.destroy
!
!   end

! GGA

   add_GGA_XC_matrix(K,E) ::: leaky
   ! Add the exchange and correlation matrices to K. This routine
   ! supports non-local functionals, either exchange or correlation.
      self :: INOUT
      K :: MAT{REAL}, INOUT
      E :: REAL, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.restricted.allocated,"no restricted density matrix")

      wt, N0,Nx,Ny,Nz, V0,Vx,Vy,Vz, E0 :: VEC{REAL}*
      V,pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      E = ZERO
      V.create(.n_bf,.n_bf); V = ZERO

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .GRID:make_rho_becke_atom_grid( &
            N0,Nx,Ny,Nz, &
            pt,wt, &
            bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz, &
            c,.density_matrix.restricted)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy

         ! The energy density &
         ! local potential grids
         n_pt = wt.dim
         E0.create(n_pt)
         V0.create(n_pt)
         Vx.create(n_pt)
         Vy.create(n_pt)
         Vz.create(n_pt)
         .:new_set_r_XC_potentials(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)
         .:new_set_r_XC_energy_density(E0,N0,Nx,Ny,Nz)

         ! Incorporate grid & partition weights
         E0 = wt*E0
         V0 = wt*V0
         Vx = wt*Vx
         Vy = wt*Vy
         Vz = wt*Vz

         ! Clean
         Nz.destroy
         Ny.destroy
         Nx.destroy
         N0.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E
         ! for atom "c" Becke-grid
         .:add_GGA_XC_matrix(V,E,V0,Vx,Vy,Vz,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,.density_matrix.restricted)

         ! Clean up
         Vz.destroy
         Vy.destroy
         Vx.destroy
         V0.destroy
         E0.destroy
         bf_gridz.destroy
         bf_gridy.destroy
         bf_gridx.destroy
         bf_grid0.destroy
         bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      K = K + V
      K.symmetric_reflect

      ! Get DFT energy correction
      V.symmetric_reflect
      E = E - HALF*V.trace_product_with(.density_matrix.restricted)
      
      ! Clean
      V.destroy

   end

   add_GGA_XC_matrix(V,E,V0,Vx,Vy,Vz,E0,bf_skip,bf_grd0,bf_grdx,bf_grdy,bf_grdz,c,D)
   ! Add XC potential matrix elements to "V", the XC energy to "E".
   ! "V0" is XC potential density on the becke grid for atom "c",
   ! weighted by the partition function for that atom. "Vx", "Vy",
   ! "Vz" are XC potential gradients. Likewise, "E0" is the
   ! (partition-weighted) XC energy density of the grid.  "bf_skip",
   ! "bf_grd0", "bf_grdx", "bf_grdy", "bf_grdz" are basis function
   ! grids and their derivatives.  "D" is the density matrix.  This
   ! routine supports non-local functionals.
      self :: INOUT
      V :: MAT{REAL}, target
      E :: REAL
      V0,Vx,Vy,Vz,E0 :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grd0,bf_grdx,bf_grdy,bf_grdz :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      D :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.restricted.allocated,"no restricted density matrix")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms_for_atom")

      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      VV,DD :: MAT{REAL}*
      Dab, fac,val,wal, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.disassociated) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element
            grida0 => bf_grd0(sa).element
            gridax => bf_grdx(sa).element
            griday => bf_grdy(sa).element
            gridaz => bf_grdz(sa).element

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grd0(sb).element
                  gridbx => bf_grdx(sb).element
                  gridby => bf_grdy(sb).element
                  gridbz => bf_grdz(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VV => V(fa:la,fb:lb)
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     val = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        val = val + V0(n)* gab                  &
                                  + Vx(n)*(gax(i)*gb+ga*gbx(j)) &
                                  + Vy(n)*(gay(i)*gb+ga*gby(j)) &
                                  + Vz(n)*(gaz(i)*gb+ga*gbz(j))
                        wal = wal + E0(n)*gab
                     end
                     VV(1,1) = VV(1,1) + val
                     E       = E       + wal*Dab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a)
                        gay => griday(:,a)
                        gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b)
                           gby => gridby(:,b)
                           gbz => gridbz(:,b)
                           Dab = fac*DD(a,b)
                           val = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              val = val + V0(n)* gab                  &
                                        + Vx(n)*(gax(i)*gb+ga*gbx(j)) &
                                        + Vy(n)*(gay(i)*gb+ga*gby(j)) &
                                        + Vz(n)*(gaz(i)*gb+ga*gbz(j))
                              wal = wal + E0(n)*gab
                           end
                           VV(a,b) = VV(a,b) + val
                           E       = E       + wal*Dab
                        end
                     end

                   ! stdout.text("VV:")
                   ! stdout.put(VV)

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

!   add_GGA_XC_matrix_old(K,E)
!   ! Add the exchange and correlation matrices to K. This routine
!   ! supports non-local functionals, either exchange or correlation.
!      K :: MAT{REAL}
!      E :: REAL
!
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.becke_grid.allocated, "need to specify becke_grid for DFT integrations")
!
!      a1,b1 :: MAT3{REAL}*
!      pt,rho1,V1,a0,b0,V :: MAT{REAL}*
!      wt,rho0,V0,E0,ab0 :: VEC{REAL}*
!      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb,n_occ :: INT
!      atom_a,atom_b,i :: INT
!      same_atoms :: BIN
!      atom1 :: VEC{INT}(1), target
!      atom2 :: VEC{INT}(2), target
!      atoms :: VEC{INT}*
!      V_ab,E_ab,fac :: REAL
!
!      ! No. of occupied NO's
!      n_occ = .occupation_numbers.no_of_occupied("restricted")
!
!      ! Basis function grids and gradients
!      nullify(a0); nullify(a1)
!      nullify(b0); nullify(b1)
!
!      ! The exchange correlation matrix
!      V.create(.n_bf,.n_bf)
!
!      ! The exchange correlation energy
!      E = ZERO
!
!      do q = 1,.BASE:no_of_atom_pairs
!
!         if (NOT .overlapping_atoms(q)) cycle
!
!         .BASE:get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
!
!         ! Which "atoms" to be integrated?
!         same_atoms = atom_a==atom_b
!         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
!         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
!         end
!
!         ! Make pair integration grid. Keep the weight_is_0 array
!         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
!
!         ! Local/non-local potential grids, energy densities
!         n_pt = pt.dim1
!         V0.create(n_pt); V1.create(n_pt,3)
!         E0.create(n_pt)
!         ab0.create(n_pt) ! temporary
!
!         ! Make the atomic basis function grids a0, b0, etc.
!         ! Uses the becke_grid.weight_is_0_array
!         .becke_grid.make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms)
!
!         ! Make the density/nabla density grids. Re-use a0, b0 grids
!         rho0.create(n_pt)
!         rho1.create(n_pt,3)
!         .GRID:make_nabla_density_grid_r_B( &
!            rho1,rho0,pt, &
!            atoms,a1,a0,b1,b0,ma,mb,n_occ, &
!            .becke_grid.basis_function_cutoff)
!
!         ! Evaluate XC potentials and energy density.
!         V0 = ZERO
!         V1 = ZERO
!         .:new_set_r_XC_potentials(V0,rho0 &
!            ,V1(:,1),V1(:,2),V1(:,3) &
!            ,rho1(:,1),rho1(:,2),rho1(:,3)) ! Evaluation the XC potentials
!         .:new_set_r_XC_energy_density(E0,rho0 &
!            ,rho1(:,1),rho1(:,2),rho1(:,3)) ! Evaluation the XC potentials
!
!         rho1.destroy
!         rho0.destroy
!
!         ! Incorporate weights into XC potential
!         V0 = wt*V0
!         E0 = wt*E0
!         forall (i=1:3) V1(:,i) = wt*V1(:,i)
!
!         wt.destroy
!         pt.destroy
!
!         ! Make V, the exchange correlation matrix
!         ! Make E, the exchange correlation energy
!         do a = 1,na
!         do b = 1,nb
!            ab0 = a0(:,a)*b0(:,b)
!            V_ab = VEC{REAL}:sum_elements(V0*ab0) &
!                 + VEC{REAL}:sum_elements(V1(:,1)*(a1(:,a,1)*b0(:,b)+a0(:,a)*b1(:,b,1))) &
!                 + VEC{REAL}:sum_elements(V1(:,2)*(a1(:,a,2)*b0(:,b)+a0(:,a)*b1(:,b,2))) &
!                 + VEC{REAL}:sum_elements(V1(:,3)*(a1(:,a,3)*b0(:,b)+a0(:,a)*b1(:,b,3)))
!            E_ab = VEC{REAL}:sum_elements(E0*ab0)
!            aa = fa + a
!            bb = fb + b
!            V(aa,bb) = V_ab
!            E = E + fac*E_ab*.density_matrix.restricted(aa,bb)
!         end
!         end
!         ab0.destroy; E0.destroy
!         V1.destroy; V0.destroy
!
!         ! Clean up
!         if (same_atoms) then
!            a1.destroy; a0.destroy
!            nullify(b1); nullify(b0)
!         else
!            b1.destroy; b0.destroy
!            a1.destroy; a0.destroy
!         end
!
!      end
!
!      ! Add the contribution to "K" matrix
!      V.symmetric_reflect
!      K = K + V
!      E = E - HALF*.density_matrix.restricted.trace_product_with(V)
!      V.destroy
!
!   end

! Set functional

   new_set_r_XC_energy_density(E,N0,Nx,Ny,Nz)
   ! Set the *restricted* exchange correlation energy density "E", for
   ! given densities "N0" and gradient densities "Nn".
      E  :: VEC{REAL}, OUT
      N0 :: VEC{REAL}, IN
      Nx,Ny,Nz :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.becke_grid.allocated,"no becke_grid")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      ! Return?
      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      ! Set to zero
      E = ZERO

      if (exch/="none") add.new_r_energy_density(exch,E,N0,Nx,Ny,Nz)
      if (corr/="none") add.new_r_energy_density(corr,E,N0,Nx,Ny,Nz)

   end

   new_set_r_XC_potentials(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)
   ! For given densities "N0" and gradient densities "Nn", return
   ! "V0" and "Vn", the local and non_local terms necessary to
   ! calculate the matrix elements of the *restricted* exchange
   ! correlation potential.
      V0 :: VEC{REAL}, INOUT
      N0 :: VEC{REAL}, IN
      Vx,Vy,Vz :: VEC{REAL}, INOUT, optional
      Nx,Ny,Nz :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.becke_grid.allocated,"no becke_grid")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      ! Return?
      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      ! Set to zero
      V0 = ZERO
      if (present(Vx)) then
         Vx = ZERO; Vy = ZERO; Vz = ZERO
      end

      if (exch/="none") add.new_r_potential(exch,V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)
      if (corr/="none") add.new_r_potential(corr,V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)

   end

!  ================
!  Unrestricted DFT
!  ================

! LDA

   add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb) ::: leaky
   ! Add the exchange and correlation matrices to "Ka", "Kb". Return
   ! the DFT energy corrections "Ea", "Eb" and the total "E". This
   ! routine supports local functional only, either exchange or
   ! correlation.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.alpha.allocated,"no alpha density matrix")
   ENSURE(.density_matrix.beta.allocated,"no alpha density matrix")

      wt, N0a,N0b,V0a,V0b,E0 :: VEC{REAL}*
      Va,Vb, pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      Ea = ZERO; Eb = ZERO
      Va.create(.n_bf,.n_bf); Va = ZERO
      Vb.create(.n_bf,.n_bf); Vb = ZERO

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .GRID:make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,.density_matrix.alpha,.density_matrix.beta)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim

         ! The energy density &
         ! local potential grid
         E0.create(n_pt)
         V0a.create(n_pt)
         V0b.create(n_pt)
         .:new_set_u_XC_potentials(V0a,V0b,N0a,N0b)
         .:new_set_u_XC_energy_density(E0,N0a,N0b)

         ! Incorporate grid & partition weights
         E0  = wt*E0
         V0a = wt*V0a
         V0b = wt*V0b

         ! Clean
         N0b.destroy
         N0a.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E
         ! for atom "c" Becke-grid
         .:add_LDA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,E0,bf_skip,bf_grid0,c,.density_matrix.alpha,.density_matrix.beta)

         ! Clean up
         V0b.destroy
         V0a.destroy
         E0.destroy
         bf_grid0.destroy
         bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      Ka = Ka + Va
      Kb = Kb + Vb
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      ! Get DFT energy correction
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ea = Ea - HALF*Va.trace_product_with(.density_matrix.alpha)
      Eb = Eb - HALF*Vb.trace_product_with(.density_matrix.beta)
      E  = Ea + Eb

      ! Clean
      Vb.destroy
      Va.destroy

   end

   add_LDA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,E0,bf_skip,bf_grid0,c,Da,Db)
   ! Add XC potential matrix elements to "Va", "Vb", the XC energy
   ! corrections to "Ea", "Eb". "V0a", "V0b" are the XC potential
   ! densities on the becke grid for atom "c", weighted by the
   ! partition function for that atom. Likewise, "E0" is the
   ! (partition-weighted) XC energy density of the grid.  "bf_skip"
   ! and "bf_grid0 are basis function grids.  "Da", "Db" are the
   ! density matrices.  This routine supports local functional only.
      Va,Vb :: MAT{REAL}, target
      Ea,Eb :: REAL
      V0a,V0b,E0 :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grid0 :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms_for_atom")

      ga0,gb0 :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      VVa,VVb,DDa,DDb :: MAT{REAL}*
      grida0,gridb0 :: MAT{REAL}*
      Da_ab,Db_ab, fac,vala,valb,wal, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0a.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.disassociated) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element
            grida0 => bf_grid0(sa).element

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VVa => Va(fa:la,fb:lb)
                  VVb => Vb(fa:la,fb:lb)
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     vala = ZERO; valb = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        vala = vala + V0a(n)*gab
                        valb = valb + V0b(n)*gab
                        wal  = wal  + E0(n) *gab
                     end
                     VVa(1,1) = VVa(1,1) + vala
                     VVb(1,1) = VVb(1,1) + valb
                     Ea       = Ea       + wal*Da_ab
                     Eb       = Eb       + wal*Db_ab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           vala = ZERO; valb = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              vala = vala + V0a(n)*gab
                              valb = valb + V0b(n)*gab
                              wal  = wal  + E0(n)*gab
                           end
                           VVa(a,b) = VVa(a,b) + vala
                           VVb(a,b) = VVb(a,b) + valb
                           Ea       = Ea       + wal*Da_ab
                           Eb       = Eb       + wal*Db_ab
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

!   add_LDA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
!   ! Add the exchange and correlation matrices to K. This routine supports
!   ! local functional only, either exchange or correlation.
!      Ka,Kb :: MAT{REAL}
!      E,Ea,Eb :: REAL
!
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.becke_grid.allocated, "need to specify becke_grid for DFT integrations")
!
!      pt,a0,b0,Vb,Va,W :: MAT{REAL}*
!      wt,rho0a,rho0b,V0a,V0b,E0,ab0 :: VEC{REAL}*
!      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt,ma,mb :: INT
!      atom_a,atom_b :: INT
!      same_atoms :: BIN
!      atom1 :: VEC{INT}(1), target
!      atom2 :: VEC{INT}(2), target
!      atoms :: VEC{INT}*
!      Va_ab,Vb_ab,E_ab,Da_ab,Db_ab,fac :: REAL
!
!      W.create(.n_bf,.n_bf)
!      Va.create(.n_bf,.n_bf)                    ! Use temporary V for parallelisation
!      Vb.create(.n_bf,.n_bf)
!      nullify(a0); nullify(b0)
!
!    ! E = ZERO
!      Ea = ZERO
!      Eb = ZERO
!
!      do q = 1,.BASE:no_of_atom_pairs
!
!         if (NOT .overlapping_atoms(q)) cycle
!
!         .BASE:get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
!
!         same_atoms = atom_a==atom_b
!         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
!         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
!         end
!
!         ! Make the grid points and weights
!         ! Keep the weight_is_0 array
!       ! .becke_grid.make_grid(pt,wt,atoms,compress=FALSE)
!       ! .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=FALSE)
!         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
!
!         n_pt = pt.dim1
!
!         ! The energy density &
!         ! Local potential grids
!         V0a.create(n_pt)
!         V0b.create(n_pt)
!         E0.create(n_pt)
!         ab0.create(n_pt)
!         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
!
!         ! The density grids
!         ! re-use a0, b0 grids
!         rho0a.create(n_pt)
!         rho0b.create(n_pt)
!         .GRID:make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0)
!
!         ! Evaluation the XC potentials
!         .:new_set_u_XC_potentials(V0a,V0b,rho0a,rho0b)
!         .:new_set_u_XC_energy_density(E0,rho0a,rho0b)
!
!         rho0b.destroy; rho0a.destroy
!
!         V0a = wt*V0a
!         V0b = wt*V0b
!         E0  = wt*E0
!
!         wt.destroy
!         pt.destroy
!
!         ! Make the exchange correlation matrix
!         do a = 1,na
!         do b = 1,nb
!            ab0 = a0(:,a)*b0(:,b)
!            Va_ab = VEC{REAL}:sum_elements(V0a*ab0)
!            Vb_ab = VEC{REAL}:sum_elements(V0b*ab0)
!            E_ab  = fac*VEC{REAL}:sum_elements(E0 *ab0)
!            aa = fa + a
!            bb = fb + b
!            Va(aa,bb) = Va_ab
!            Vb(aa,bb) = Vb_ab
!            ! Make the DFT energy correction matrix
!          ! W(aa,bb)  = -HALF*(Va_ab+Vb_ab) + VEC{REAL}:sum_elements(E0*ab0)
!          ! W(aa,bb)  = VEC{REAL}:sum_elements(E0*ab0)  ! Make the DFT energy correction matrix
!            Da_ab = .density_matrix.alpha(aa,bb)
!            Db_ab = .density_matrix.beta(aa,bb)
!          ! E  = E  + fac*E_ab*(Da_ab+Db_ab)
!            Ea = Ea + E_ab*Da_ab
!            Eb = Eb + E_ab*Db_ab
!         end
!         end
!
!         ab0.destroy
!         E0.destroy
!         V0b.destroy
!         V0a.destroy
!
!         if (same_atoms) then
!            a0.destroy
!            nullify(b0)
!         else
!            b0.destroy
!            a0.destroy
!         end
!
!      end
!
!      Va.symmetric_reflect
!      Vb.symmetric_reflect
!
!      Ka = Ka + Va
!      Kb = Kb + Vb
!      Ea = Ea - HALF*.density_matrix.alpha.trace_product_with(Va)
!      Eb = Eb - HALF*.density_matrix.beta.trace_product_with(Vb)
!      E  = Ea + Eb
!
!      Vb.destroy
!      Va.destroy
!      W.destroy
!
!   end

! GGA

   add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb) ::: leaky
   ! Add the exchange and correlation matrices to "Ka", "Kb". Return
   ! the DFT energy coorections "Ea", "Eb" and total "E". This routine
   ! supports non-local functionals, either exchange or correlation.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.density_matrix.alpha.allocated,"no alpha density matrix")
   ENSURE(.density_matrix.beta.allocated,"no alpha density matrix")

      wt, E0 :: VEC{REAL}*
      N0a,Nxa,Nya,Nza, V0a,Vxa,Vya,Vza :: VEC{REAL}*
      N0b,Nxb,Nyb,Nzb, V0b,Vxb,Vyb,Vzb :: VEC{REAL}*
      Va,Vb, pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      Ea = ZERO; Eb = ZERO
      Va.create(.n_bf,.n_bf); Va = ZERO
      Vb.create(.n_bf,.n_bf); Vb = ZERO

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .GRID:make_rho_becke_atom_grid( &
            N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb, &
            pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz, &
            c,.density_matrix.alpha,.density_matrix.beta)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim

         ! The energy density &
         ! local potential grids
         E0.create(n_pt)
         V0a.create(n_pt); Vxa.create(n_pt); Vya.create(n_pt); Vza.create(n_pt)
         V0b.create(n_pt); Vxb.create(n_pt); Vyb.create(n_pt); Vzb.create(n_pt)
         .:new_set_u_XC_potentials( &
            V0a,V0b, &
            N0a,N0b, &
            Vxa,Vya,Vza,Vxb,Vyb,Vzb, &
            Nxa,Nya,Nza,Nxb,Nyb,Nzb)
         .:new_set_u_XC_energy_density(E0, &
            N0a,N0b, &
            Nxa,Nya,Nza,Nxb,Nyb,Nzb)

         ! Incorporate grid & partition weights
         E0  = wt*E0
         V0a = wt*V0a; Vxa = wt*Vxa; Vya = wt*Vya; Vza = wt*Vza
         V0b = wt*V0b; Vxb = wt*Vxb; Vyb = wt*Vyb; Vzb = wt*Vzb

         ! Clean
         Nzb.destroy
         Nyb.destroy
         Nxb.destroy
         N0b.destroy
         Nza.destroy
         Nya.destroy
         Nxa.destroy
         N0a.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E
         ! for atom "c" Becke-grid
         .:add_GGA_XC_matrix( &
            Va,Vb, &
            Ea,Eb, &
            V0a,V0b, &
            Vxa,Vya,Vza, &
            Vxb,Vyb,Vzb, &
            E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz, &
            c,.density_matrix.alpha,.density_matrix.beta)

         ! Clean up
         Vzb.destroy
         Vyb.destroy
         Vxb.destroy
         V0b.destroy
         Vza.destroy
         Vya.destroy
         Vxa.destroy
         V0a.destroy
         E0.destroy
         bf_gridz.destroy
         bf_gridy.destroy
         bf_gridx.destroy
         bf_grid0.destroy
         bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      Ka = Ka + Va
      Kb = Kb + Vb
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      ! Get DFT energy correction
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ea = Ea - HALF*Va.trace_product_with(.density_matrix.alpha)
      Eb = Eb - HALF*Vb.trace_product_with(.density_matrix.beta)
      E  = Ea + Eb

      ! Clean
      Vb.destroy
      Va.destroy

   end

   add_GGA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,E0,bf_skip,bf_gr0,bf_grx,bf_gry,bf_grz,c,Da,Db)
   ! Add XC potential matrix elements to "Va", "Vb", the XC energy
   ! corrections to "Ea", "Eb". "V0a", "V0b", "Vxa" ... "Vzb" are the
   ! XC potential densities and their derivatives on the becke grid
   ! for atom "c", weighted by the
   ! partition function for that atom. Likewise, "E0" is the
   ! (partition-weighted) XC energy density of the grid.  "bf_skip"
   ! and "bf_gr0" ... "bf_grz" are basis function (derivative)
   ! grids.  "Da", "Db" are the density matrices.  This routine
   ! supports non-local functionals.
      Va,Vb :: MAT{REAL}, target
      Ea,Eb :: REAL
      V0a,V0b, E0 :: VEC{REAL}, IN
      Vxa,Vya,Vza :: VEC{REAL}, IN
      Vxb,Vyb,Vzb :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_gr0,bf_grx,bf_gry,bf_grz :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms_for_atom")

      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      VVa,VVb,DDa,DDb :: MAT{REAL}*
      Da_ab,Db_ab, fac,vala,valb,wal, ga,gb,gab,gx,gy,gz :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0a.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.disassociated) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element
            grida0 => bf_gr0(sa).element
            gridax => bf_grx(sa).element
            griday => bf_gry(sa).element
            gridaz => bf_grz(sa).element

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_gr0(sb).element
                  gridbx => bf_grx(sb).element
                  gridby => bf_gry(sb).element
                  gridbz => bf_grz(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VVa => Va(fa:la,fb:lb)
                  VVb => Vb(fa:la,fb:lb)
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     vala = ZERO; valb = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        gx  = gax(i)*gb+ga*gbx(j)
                        gy  = gay(i)*gb+ga*gby(j)
                        gz  = gaz(i)*gb+ga*gbz(j)
                        vala = vala + V0a(n)*gab + Vxa(n)*gx + Vya(n)*gy + Vza(n)*gz
                        valb = valb + V0b(n)*gab + Vxb(n)*gx + Vyb(n)*gy + Vzb(n)*gz
                        wal  = wal  + E0(n) *gab
                     end
                     VVa(1,1) = VVa(1,1) + vala
                     VVb(1,1) = VVb(1,1) + valb
                     Ea       = Ea       + wal*Da_ab
                     Eb       = Eb       + wal*Db_ab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           vala = ZERO; valb = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              gx  = gax(i)*gb+ga*gbx(j)
                              gy  = gay(i)*gb+ga*gby(j)
                              gz  = gaz(i)*gb+ga*gbz(j)
                              vala = vala + V0a(n)*gab + Vxa(n)*gx + Vya(n)*gy + Vza(n)*gz
                              valb = valb + V0b(n)*gab + Vxb(n)*gx + Vyb(n)*gy + Vzb(n)*gz
                              wal  = wal  + E0(n) *gab
                           end
                           VVa(a,b) = VVa(a,b) + vala
                           VVb(a,b) = VVb(a,b) + valb
                           Ea       = Ea       + wal*Da_ab
                           Eb       = Eb       + wal*Db_ab
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

!   add_GGA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
!   ! Add the exchange and correlation matrices to K. This routine supports
!   ! local functional only, either exchange or correlation.
!      Ka,Kb :: MAT{REAL}
!      E,Ea,Eb :: REAL
!
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.becke_grid.allocated, "need to specify becke_grid for DFT integrations")
!
!      a1,b1 :: MAT3{REAL}*
!      pt,rho1a,rho1b,a0,b0,V1a,V1b,Vb,Va :: MAT{REAL}*
!      wt,rho0a,rho0b,V0a,V0b,E0,ab0 :: VEC{REAL}*
!      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
!      atom_a,atom_b,i :: INT
!      same_atoms :: BIN
!      atom1 :: VEC{INT}(1), target
!      atom2 :: VEC{INT}(2), target
!      atoms :: VEC{INT}*
!      Va_ab,Vb_ab,E_ab,Da_ab,Db_ab,fac :: REAL
!
!      ! Use temporary V for parallelisation
!      Va.create(.n_bf,.n_bf)
!      Vb.create(.n_bf,.n_bf)
!      nullify(a0); nullify(b0)
!
!    ! E  = ZERO
!      Ea = ZERO
!      Eb = ZERO
!
!      do q = 1,.BASE:no_of_atom_pairs
!
!         if (NOT .overlapping_atoms(q)) cycle
!
!         .BASE:get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
!
!         same_atoms = atom_a==atom_b
!         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
!         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
!         end
!
!         ! Make the grid points and weights
!         ! Keep the weight_is_0 array
!         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
!
!         ! Local potential grids
!         ! & non-local potential grids
!         n_pt = pt.dim1
!         V0a.create(n_pt); V0b.create(n_pt)
!         V1a.create(n_pt,3); V1b.create(n_pt,3)
!         E0.create(n_pt)
!         ab0.create(n_pt)
!         .becke_grid.make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms)
!
!         ! The density grids
!         rho0a.create(n_pt); rho0b.create(n_pt)
!         rho1a.create(n_pt,3); rho1b.create(n_pt,3)
!         .GRID:make_nabla_density_grid_u_A( &
!             rho1a,rho1b,rho0a,rho0b,pt,atoms, &
!             a1,a0,b1,b0,.becke_grid.rho_cutoff) ! re-use a0, b0 grids
!
!         ! Evaluation the XC potentials
!         .:new_set_u_XC_potentials(V0a,V0b,rho0a,rho0b &
!            ,V1a(:,1),V1a(:,2),V1a(:,3),V1b(:,1),V1b(:,2),V1b(:,3) &
!            ,rho1a(:,1),rho1a(:,2),rho1a(:,3),rho1b(:,1),rho1b(:,2),rho1b(:,3))
!         .:new_set_u_XC_energy_density(E0 &
!            ,rho0a,rho0b &
!            ,rho1a(:,1),rho1a(:,2),rho1a(:,3),rho1b(:,1),rho1b(:,2),rho1b(:,3))
!
!         rho1b.destroy; rho1a.destroy
!         rho0b.destroy; rho0a.destroy
!
!         V0a = wt*V0a
!         V0b = wt*V0b
!         E0  = wt*E0
!         forall (i=1:3)
!            V1a(:,i) = wt*V1a(:,i)
!            V1b(:,i) = wt*V1b(:,i)
!         end
!
!         wt.destroy
!         pt.destroy
!
!         ! Make the exchange correlation matrix
!         do a = 1,na
!         do b = 1,nb
!            ab0 = a0(:,a)*b0(:,b)
!            Va_ab = VEC{REAL}:sum_elements(V0a*ab0)
!            Vb_ab = VEC{REAL}:sum_elements(V0b*ab0)
!            E_ab  = fac*VEC{REAL}:sum_elements(E0 *ab0)
!            ! Make the DFT energy correction matrix
!            do i = 1,3
!               ab0 = a1(:,a,i)*b0(:,b) + a0(:,a)*b1(:,b,i)
!               Va_ab = Va_ab + VEC{REAL}:sum_elements(V1a(:,i)*ab0)
!               Vb_ab = Vb_ab + VEC{REAL}:sum_elements(V1b(:,i)*ab0)
!            end
!            aa = fa + a
!            bb = fb + b
!            Va(aa,bb) = Va_ab
!            Vb(aa,bb) = Vb_ab
!            Da_ab = .density_matrix.alpha(aa,bb)
!            Db_ab = .density_matrix.beta(aa,bb)
!          ! E  = E  + fac*E_ab*(Da_ab+Db_ab)
!            Ea = Ea + E_ab*Da_ab
!            Eb = Eb + E_ab*Db_ab
!         end
!         end
!
!         ab0.destroy; E0.destroy
!         V1b.destroy; V1a.destroy
!         V0b.destroy; V0a.destroy
!         if (same_atoms) then
!            a1.destroy; a0.destroy
!            nullify(b1); nullify(b0)
!         else
!            b1.destroy; b0.destroy
!            a1.destroy; a0.destroy
!         end
!
!      end
!
!      Va.symmetric_reflect
!      Vb.symmetric_reflect
!
!      Ka = Ka + Va
!      Kb = Kb + Vb
!      Ea = Ea - HALF*.density_matrix.alpha.trace_product_with(Va)
!      Eb = Eb - HALF* .density_matrix.beta.trace_product_with(Vb)
!      E  = Ea + Eb
!    ! E = E - HALF*.density_matrix.alpha.trace_product_with(Va) &
!    !       - HALF* .density_matrix.beta.trace_product_with(Vb)
!
!      Vb.destroy; Va.destroy
!
!   end

! Set functional

   new_set_u_XC_energy_density(E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
   ! Return the *unrestricted* exchange correlation energy density "E", for
   ! given alpha and beta densities "rho0a", "rho0b" and for the alpha and beta
   ! gradient densities "rho1a", "rho1b".
      E :: VEC{REAL}, OUT
      N0a,N0b :: VEC{REAL}, IN
      Nxa,Nya,Nza,Nxb,Nyb,Nzb :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.associated,"no scfdata")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      ! Return?
      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      ! Set to zero
      E = ZERO

      if (exch/="none") add.new_u_energy_density(exch,E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
      if (corr/="none") add.new_u_energy_density(corr,E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)

   end

   new_set_u_XC_potentials(V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
   ! For given alpha and beta densities "N0a", "N0b" and gradient
   ! densities "Nxa", ..., "Nzb" return the alpha and beta local
   ! potentials, "V0a" and "V0b", and the non local potentails "Vxa",
   ! ... , "Vzb" needed to calculate the matrix elements of the
   ! *unrestricted* exchange correlation potentials.
      V0a,V0b :: VEC{REAL}, INOUT
      N0a,N0b :: VEC{REAL}, IN
      Vxa,Vya,Vza,Vxb,Vyb,Vzb :: VEC{REAL}, OUT, optional
      Nxa,Nya,Nza,Nxb,Nyb,Nzb :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.associated,"no scfdata")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      ! Return?
      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      ! Set to zero
      V0a = ZERO; V0b = ZERO
      if (present(Vxa)) then
         Vxa = ZERO; Vya = ZERO; Vza = ZERO
         Vxb = ZERO; Vyb = ZERO; Vzb = ZERO
      end

      if (exch/="none") add.new_u_potential(exch,V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
      if (corr/="none") add.new_u_potential(corr,V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)

   end

! Numerical J matrix -- calculated two ways

!   make_numerical_J_matrix_v1(J)
!   ! Evaluate the coulomb matrix "J" using numerical evaluation of the potential
!   ! on a DFT integration grid.
!     J :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.dftgrid.associated, "need to specify dftgrid")
!     pt :: MAT{REAL}*
!     wt,p :: VEC{REAL}*
!     n_pt :: INT
!     n_pt = .dftgrid.n_pts*.n_atom
!     p.create(n_pt)
!     pt.create(n_pt,3)
!     wt.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(p,pt)
!     p = wt*p ! Now we have the effective charges
!     wt.destroy
!     .make_nuclear_attraction_mx(J,charges=p,points=pt)
!     pt.destroy
!     p.destroy
!   end

!   make_numerical_J_matrix_v2(J)
!   ! Evaluate the coulomb matrix "J" using numerical evaluation of the potential
!   ! on a DFT integration grid.
!     J :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.dftgrid.associated, "need to specify dftgrid")
!     JJ,pt :: MAT{REAL}*
!     wt,q :: VEC{REAL}*
!     n_pt, p,fa,la,fb,lb,atom_a,atom_b :: INT
!     sh :: SHELL2
!     atom :: VEC{ATOM}*
!     n_pt = .dftgrid.n_pts*.n_atom
!     q.create(n_pt)
!     pt.create(n_pt,3)
!     wt.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(q,pt)
!     q = wt*q ! Now we have the effective charges
!     wt.destroy
!     J = ZERO
!     do p = 1,.n_shell_pairs
!        .get_precomputed_shell_pair(sh,p,fa,la,fb,lb,atom_a,atom_b)
!        if (atom_a==atom_b) then
!           atom.create(1)
!           atom(1) = .atom(atom_a)
!        else
!           atom.create(2)
!           atom(1) = .atom(atom_a)
!           atom(2) = .atom(atom_b)
!        end
!        JJ.create(sh.a.n_comp,sh.b.n_comp)
!        .dftgrid.make_potential_MEs_of(MOLECULE::electric_potential,q,pt,sh,atom,JJ)
!        atom.nullify_ptr_part; atom.destroy
!        J(fa:la,fb:lb) = J(fa:la,fb:lb) - JJ
!        JJ.destroy
!        sh.destroy_ptr_part
!     end
!     J.symmetric_reflect
!     pt.destroy
!     q.destroy
!   end

!  ======================
!  Two electron integrals
!  ======================

   get_ERI_integrals
   ! Get the electron repulsion integrals on disk. If the integral
   ! file is already there, do nothing.

      eri_archive,ind_archive :: ARCHIVE

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      if ((NOT eri_archive.exists) OR (NOT ind_archive.exists)) then

         eri_archive.open_for("write-only")
         ind_archive.open_for("write-only")

         .:make_ERI_integrals(eri_archive,ind_archive)

         ind_archive.close
         eri_archive.close

      end

   end

   make_ERI_integrals(eri_archive,eri_index)
   ! Calculate the electron repulsion integrals (ERI's) over all basis
   ! functions Outputs to archive "eri_archive".
   ! NOTE: that index coincidence factors are included.
   ! NOTE: Replace SHELL4 in here with SHELL1QUARTET
      eri_archive,eri_index :: ARCHIVE

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sh4 :: SHELL4
      ERI :: MAT4{REAL}*
      q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d :: INT
      n_shell_quartets :: INT
      factor :: REAL

      skipped = 0

      if (.scfdata.output) then

         stdout.set_real_style("e")
         stdout.show("Skipping electron repulsion integrals less than ",.scfdata.eri_disk_cutoff)
         stdout.set_real_style("f")

      end

      n_shell_quartets = .atom.no_of_shell_quartets

      if (.scfdata.using_NDDO) then

         do q = 1,n_shell_quartets

            .BASE:get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)

            if (atom_a==atom_b AND atom_c==atom_d) then
               .BASE:copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end

            if (sh4.skip_ERI) then
               skipped = skipped + 1
               sh4.destroy_ptr_part
               cycle
            end

            ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
            sh4.get_ERI(ERI)

            ! Coincidence factors
            factor = ONE
            if (a==b)          factor = HALF
            if (c==d)          factor = HALF * factor
            if (a==c AND b==d) factor = HALF * factor
            ERI = factor * ERI

            eri_archive.Bfile.write(ERI)
            eri_index.Bfile.write(q)

            ERI.destroy
            sh4.destroy_ptr_part

         end

      else if (.scfdata.using_NUDO) then

         do q = 1,n_shell_quartets

            .BASE:get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)

            if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
               .BASE:copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end

            if (sh4.skip_ERI) then
               skipped = skipped + 1
               sh4.destroy_ptr_part
               cycle
            end

            ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
            sh4.get_ERI(ERI)

            ! Coincidence factors
            factor = ONE
            if (a==b)          factor = HALF
            if (c==d)          factor = HALF * factor
            if (a==c AND b==d) factor = HALF * factor
            ERI = factor * ERI

            eri_archive.Bfile.write(ERI)
            eri_index.Bfile.write(q)

            ERI.destroy
            sh4.destroy_ptr_part

         end

      else

         do q = 1,n_shell_quartets

            .BASE:copy_shell_quartet(sh4,q,a,b,c,d)

            if (sh4.skip_ERI(.scfdata.eri_disk_cutoff)) then
              skipped = skipped + 1
              sh4.destroy_ptr_part
              cycle
            end

            ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
            sh4.get_ERI(ERI)

            ! Coincidence factors
            factor = ONE
            if (a==b)          factor = HALF
            if (c==d)          factor = HALF * factor
            if (a==c AND b==d) factor = HALF * factor
            ERI = factor * ERI

            eri_archive.Bfile.write(ERI)
            eri_index.Bfile.write(q)

            ERI.destroy
            sh4.destroy_ptr_part

         end

      end

      if (.scfdata.output) then
         a = n_shell_quartets
         stdout.text("Skipped "//skipped.to_str.trim//" out of "//a.to_str.trim//" blocks.")
      end

      eri_index.Bfile.write(n_shell_quartets+1)

   end

   get_spin_orbit_integrals
   ! Get the spin orbit integrals on disk. If the integral files are
   ! file is already there, do nothing.

      SOx_archive,SOy_archive,SOz_archive,ind_archive :: ARCHIVE

      SOx_archive.set(.name,"SOx_integrals")
      SOy_archive.set(.name,"SOy_integrals")
      SOz_archive.set(.name,"SOz_integrals")
      ind_archive.set(.name,"SO_indices")

      if (NOT SOx_archive.exists) then

         SOx_archive.open_for("write-only")
         SOy_archive.open_for("write-only")
         SOz_archive.open_for("write-only")
         ind_archive.open_for("write-only")

         .:make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)

         SOx_archive.close
         SOy_archive.close
         SOz_archive.close
         ind_archive.close

      end

   end

   make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
   ! Calculate the spin orbit integrals. Outputs the spin same-orbit integrals
   ! to for each component i to "SOi_archive". The shell quartet index for
   ! these integrals are put in "ind_archive". Note that index coincidence
   ! factors are included.
      SOx_archive,SOy_archive,SOz_archive,ind_archive :: ARCHIVE

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sh4 :: SHELL4
      Sx,Sy,Sz,Ox,Oy,Oz :: MAT4{REAL}*
      q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d,na,nb,nc,nd :: INT
      n_shell_quartets :: INT
      factor :: REAL
      cutoff :: STR

      cutoff.from_real(SHELL4_ERI_CUTOFF)
      if (.scfdata.output) then
         stdout.text("Skipping electron repulsion integrals less than "//trim(cutoff)//".")
      end

      n_shell_quartets = .atom.no_of_shell_quartets
      skipped = 0

      do q = 1,n_shell_quartets

         if (.scfdata.using_NDDO) then

            .BASE:get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
            if (atom_a==atom_b AND atom_c==atom_d) then
               .BASE:copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end

         else if (.scfdata.using_NUDO) then

            .BASE:get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
            if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
               .BASE:copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end

         else

            .BASE:copy_shell_quartet(sh4,q,a,b,c,d)

         end

         if (sh4.skip_ERI) then
            skipped = skipped + 1
            sh4.destroy_ptr_part
            cycle
         end

         na = sh4.a.n_comp; nb = sh4.b.n_comp
         nc = sh4.c.n_comp; nd = sh4.d.n_comp

         Sx.create(na,nb,nc,nd)
         Sy.create(na,nb,nc,nd)
         Sz.create(na,nb,nc,nd)
         Ox.create(na,nb,nc,nd)
         Oy.create(na,nb,nc,nd)
         Oz.create(na,nb,nc,nd)

         sh4.make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)

         ! Coincidence factors
         factor = ONE
         if (a==b)          factor = HALF
         if (c==d)          factor = HALF * factor
         if (a==c AND b==d) factor = HALF * factor
         Sx = factor*Sx; Sy = factor*Sy; Sz = factor*Sz
         Ox = factor*Ox; Oy = factor*Oy; Oz = factor*Oz

         SOx_archive.Bfile.write(Sx); SOx_archive.Bfile.write(Ox)
         SOy_archive.Bfile.write(Sy); SOy_archive.Bfile.write(Oy)
         SOz_archive.Bfile.write(Sz); SOz_archive.Bfile.write(Oz)
         ind_archive.Bfile.write(q)

         Oz.destroy
         Oy.destroy
         Ox.destroy
         Sz.destroy
         Sy.destroy
         Sx.destroy
         sh4.destroy_ptr_part

      end

      if (.scfdata.output) then
         a = n_shell_quartets
         stdout.text("Skipped "//skipped.to_str.trim//" out of "//a.to_str.trim//" blocks.")
      end

      ind_archive.Bfile.write(n_shell_quartets+1)

   end

!  ================
!  For geminal code
!  ================

   make_ERI_integrals(v)
   ! Calculate the electron repulsion integrals (ERI's) over all basis
   ! functions and in array "v". This uses up a lot of space!
     v :: MAT4{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(all(shape(v)==[.n_bf,.n_bf,.n_bf,.n_bf]),"wrong shape for array v")

     sh4n :: SHELL1QUARTET
     I :: VEC{REAL}*
     ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT
     cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d, a,b,c,d,abcd :: INT
     val :: REAL

     do ab = 1,.n_shell_pairs

         .BASE:get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)
         .BASE:set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            .BASE:get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d)
            .BASE:set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)

            I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd

            ! Now symmetrise the integrals
            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               val = I(abcd)
               v(a,b,c,d) = val
               v(a,b,d,c) = val
               v(b,a,c,d) = val
               v(b,a,d,c) = val
               v(c,d,a,b) = val
               v(c,d,b,a) = val
               v(d,c,a,b) = val
               v(d,c,b,a) = val
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab

     end

   end

   make_MO_ERI_integrals(v,eri_archive,add_core,new_n_bf)
   ! Calculate the electron repulsion integrals (ERI's) in the MO basis from the
   ! AO integrals stored in "v" and write them to disk in "eri_archive". If
   ! "add_core" is present and true, the one electron core integrals are added
   ! into the two electron MO integrals.
   ! optional arguments if one uses a reduced mo basis set
     v :: MAT4{REAL}
     eri_archive :: ARCHIVE
     add_core :: BIN, optional
     new_n_bf :: INT, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.molecular_orbitals.allocated,"no molecular orbitals")
   ENSURE(.molecular_orbitals.restricted.allocated,"no molecular orbitals")
   ENSURE(.core_matrix.allocated,"no core matrix")
   ENSURE(.core_matrix.restricted.allocated,"no restricted core matrix")
   ENSURE(.overlap_matrix.associated,"no overlap matrix")

     new_v :: MAT4{REAL}*
     P :: MAT{REAL}*
     H,S :: MAT{REAL}*
     a,b,c,d :: INT
     core :: BIN

     if (present(new_n_bf)) then
        P.create(.n_bf,new_n_bf)
        P = .molecular_orbitals.restricted(:,1:new_n_bf)
        new_v.create(new_n_bf,new_n_bf,new_n_bf,new_n_bf)
     else
        P.create(.n_bf,.n_bf)
        P = .molecular_orbitals.restricted
     end

     core = FALSE
     if (present(add_core)) core = add_core

     H.create(.n_bf,.n_bf)
     S.create(.n_bf,.n_bf)

     if (core) then
        H = .core_matrix.restricted/(TWO*.n_a-1)
        S = .overlap_matrix
     end

     do a = 1,.n_bf
       do b = 1,a-1
         !pcc should swap a and b to make it faster
         if (core) v(a,b,:,:) = v(a,b,:,:) + H * S(a,b) + S * H(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       if (core) v(a,a,:,:) = v(a,a,:,:) + H * S(a,a) + S * H(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,.n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end
     P.destroy

     if (present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       H.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           H = new_v(:,d,c,:)
           new_v(:,d,c,:)=new_v(:,c,d,:)
           new_v(:,c,d,:)=H
         end
       end

       eri_archive.write(new_v)
       new_v.destroy

     else

       do c = 1,.n_bf
         do d = 1,c-1
           H = v(:,d,c,:)
           v(:,d,c,:)=v(:,c,d,:)
           v(:,c,d,:)=H
         end
       end

       eri_archive.write(v)

     end

     S.destroy
     H.destroy

   end

   make_read_MO_ERI_integrals(v,eri_archive,add_core,new_n_bf)
   ! Calculate the electron repulsion integrals (ERI's) in read-in MO basis from the
   ! AO integrals stored in "v" and write them to disk in "eri_archive". If
   ! "add_core" is present and true, the one electron core integrals are added
   ! into the two electron MO integrals.
   ! optional arguments if one uses a reduced mo basis set
     v :: MAT4{REAL}
     eri_archive :: ARCHIVE
     add_core :: BIN, optional
     new_n_bf :: INT, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.core_matrix.allocated,"no core matrix")
   ENSURE(.core_matrix.restricted.allocated,"no restricted core matrix")
   ENSURE(.overlap_matrix.associated,"no overlap matrix")

     new_v :: MAT4{REAL}*
     P,H,S :: MAT{REAL}*
     a,b,c,d :: INT
     core :: BIN
     in :: TEXTFILE*

     if (present(new_n_bf)) then
        P.create(.n_bf,new_n_bf)
        new_v.create(new_n_bf,new_n_bf,new_n_bf,new_n_bf)
     else
        P.create(.n_bf,.n_bf)
     end

     in.create("readin_mos")
     in.open_for("read")
     in.read(P,by_column=TRUE)
     in.close
     in.destroy

     stdout.text("readin mos")
     stdout.put(P)
     stdout.text(" ")

     core = FALSE
     if (present(add_core)) core = add_core

     H.create(.n_bf,.n_bf)
     S.create(.n_bf,.n_bf)

     if (core) then
        ENSURE(.core_matrix.restricted.allocated,"no restricted core matrix")
        H = .core_matrix.restricted/(TWO*.n_a-1)
        S = .overlap_matrix
     end

     do a = 1,.n_bf
       do b = 1,a-1
         if (core) v(a,b,:,:) = v(a,b,:,:) + H * S(a,b) + S * H(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       if (core) v(a,a,:,:) = v(a,a,:,:) + H * S(a,a) + S * H(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,.n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     P.destroy

     if(present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       H.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           H = new_v(:,d,c,:)
           new_v(:,d,c,:) = new_v(:,c,d,:)
           new_v(:,c,d,:) = H
         end
       end
       eri_archive.write(new_v)
       new_v.destroy

     else

       do c = 1,.n_bf
         do d = 1,c-1
           H = v(:,d,c,:)
           v(:,d,c,:)=v(:,c,d,:)
           v(:,c,d,:)=H
         end
       end
       eri_archive.write(v)

     end

     S.destroy
     H.destroy

   end

   make_MO_EDM_integrals(new_n_bf)
   ! Calculate the electric dipole moment (EDM) integrals in the MO basis
   ! optional arguments if one uses a reduced mo basis set
     new_n_bf :: INT, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.molecular_orbitals.allocated,"no molecular orbitals")
   ENSURE(.molecular_orbitals.restricted.allocated,"no molecular orbitals")

     n_bf :: INT
     Dx_archive,Dy_archive,Dz_archive :: ARCHIVE
     v,new_v :: MAT4{REAL}*
     P :: MAT{REAL}*
     Dx,Dy,Dz,S :: MAT{REAL}*
     a,b,c,d :: INT

     Dx_archive.set(.name,"Dx_integrals")
     Dy_archive.set(.name,"Dy_integrals")
     Dz_archive.set(.name,"Dz_integrals")

     n_bf=.n_bf

     v.create(n_bf,n_bf,n_bf,n_bf)

     if (present(new_n_bf)) then
        P.create(n_bf,new_n_bf)
        P = .molecular_orbitals.restricted(:,1:new_n_bf)
        new_v.create(new_n_bf,new_n_bf,new_n_bf,new_n_bf)
     else
        P.create(n_bf,n_bf)
        P = .molecular_orbitals.restricted
     end

     Dx.create(n_bf,n_bf)
     Dy.create(n_bf,n_bf)
     Dz.create(n_bf,n_bf)
     S.create(n_bf,n_bf)

     .INTS:make_dipole_matrices(Dx,Dy,Dz)
     .INTS:make_overlap_matrix

     ! Minus for electronic charge
     Dx = -Dx/(2*.n_a-1)
     Dy = -Dy/(2*.n_a-1)
     Dz = -Dz/(2*.n_a-1)

     S = .overlap_matrix

     ! Do x component
     v = ZERO
     do a = 1,n_bf
       do b = 1,a-1
         v(a,b,:,:) =  Dx * S(a,b) + S * Dx(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       v(a,a,:,:) =  Dx * S(a,a) + S *Dx(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     if (present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       Dx.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           Dx = new_v(:,d,c,:)
           new_v(:,d,c,:) = new_v(:,c,d,:)
           new_v(:,c,d,:) = Dx
         end
       end
       Dx_archive.write(new_v)

     else

       do c = 1,.n_bf
         do d = 1,c-1
           Dx=v(:,d,c,:)
           v(:,d,c,:) = v(:,c,d,:)
           v(:,c,d,:) = Dx
         end
       end
       Dx_archive.write(v)

     end
     Dx.destroy

     ! Do y component
     v = ZERO
     do a = 1,n_bf
       do b = 1,a-1
         v(a,b,:,:) =  Dy * S(a,b) + S * Dy(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       v(a,a,:,:) =  Dy * S(a,a) + S *Dy(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     if (present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       Dy.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           Dy = new_v(:,d,c,:)
           new_v(:,d,c,:) = new_v(:,c,d,:)
           new_v(:,c,d,:) = Dy
         end
       end
       Dy_archive.write(new_v)

     else

       do c = 1,.n_bf
         do d = 1,c-1
           Dy = v(:,d,c,:)
           v(:,d,c,:) = v(:,c,d,:)
           v(:,c,d,:) = Dy
         end
       end
       Dy_archive.write(v)
     end
     Dy.destroy

     ! Do z component
     v = ZERO
     do a = 1,n_bf
       do b = 1,a-1
         v(a,b,:,:) =  Dz * S(a,b) + S * Dz(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       v(a,a,:,:) =  Dz * S(a,a) + S *Dz(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     if (present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       Dz.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           Dz = new_v(:,d,c,:)
           new_v(:,d,c,:) = new_v(:,c,d,:)
           new_v(:,c,d,:) = Dz
         end
       end
       Dz_archive.write(new_v)

     else

       do c = 1,.n_bf
         do d = 1,c-1
           Dz = v(:,d,c,:)
           v(:,d,c,:) = v(:,c,d,:)
           v(:,c,d,:) = Dz
         end
       end
       Dz_archive.write(v)

     end
     Dz.destroy

     P.destroy
     S.destroy
     new_v.destroy
     v.destroy

   end

   make_read_MO_EDM_integrals(new_n_bf)
   ! Calculate the electric dipole moment (EDM) integrals in the
   ! readin MO basis
   ! optional arguments if one uses a reduced mo basis set
     new_n_bf :: INT, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

     n_bf :: INT
     Dx_archive,Dy_archive,Dz_archive :: ARCHIVE
     v,new_v :: MAT4{REAL}*
     P :: MAT{REAL}*
     Dx,Dy,Dz,S :: MAT{REAL}*
     a,b,c,d :: INT
     in :: TEXTFILE*

     if (present(new_n_bf)) then
        P.create(.n_bf,new_n_bf)
        new_v.create(new_n_bf,new_n_bf,new_n_bf,new_n_bf)
     else
        P.create(.n_bf,.n_bf)
     end

     in.create("readin_mos")
     in.open_for("read")
     in.read(P,by_column=TRUE)
     in.close
     in.destroy

     Dx_archive.set(.name,"Dx_integrals")
     Dy_archive.set(.name,"Dy_integrals")
     Dz_archive.set(.name,"Dz_integrals")

     n_bf = .n_bf

     v.create(n_bf,n_bf,n_bf,n_bf)
     Dx.create(n_bf,n_bf)
     Dy.create(n_bf,n_bf)
     Dz.create(n_bf,n_bf)
     S.create(n_bf,n_bf)

     .INTS:make_dipole_matrices(Dx,Dy,Dz)
     .INTS:make_overlap_matrix

     Dx = -Dx/(TWO*.n_a-1) !minus for electronic charge
     Dy = -Dy/(TWO*.n_a-1)
     Dz = -Dz/(TWO*.n_a-1)
     S = .overlap_matrix

     ! Do x component
     v = ZERO
     do a = 1,n_bf
       do b = 1,a-1
         v(a,b,:,:) =  Dx * S(a,b) + S * Dx(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       v(a,a,:,:) =  Dx * S(a,a) + S *Dx(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     if(present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       Dx.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           Dx = new_v(:,d,c,:)
           new_v(:,d,c,:) = new_v(:,c,d,:)
           new_v(:,c,d,:) = Dx
         end
       end
       Dx_archive.write(new_v)

     else

       do c = 1,.n_bf
         do d = 1,c-1
           Dx=v(:,d,c,:)
           v(:,d,c,:)=v(:,c,d,:)
           v(:,c,d,:)=Dx
         end
       end
       Dx_archive.write(v)

     end
     Dx.destroy

    ! Do y component
     v = ZERO
     do a = 1,n_bf
       do b = 1,a-1
         v(a,b,:,:) =  Dy * S(a,b) + S * Dy(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       v(a,a,:,:) =  Dy * S(a,a) + S *Dy(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     if (present(new_n_bf)) then
       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       Dy.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           Dy = new_v(:,d,c,:)
           new_v(:,d,c,:) = new_v(:,c,d,:)
           new_v(:,c,d,:) = Dy
         end
       end
       Dy_archive.write(new_v)

     else

       do c = 1,.n_bf
         do d = 1,c-1
           Dy = v(:,d,c,:)
           v(:,d,c,:)=v(:,c,d,:)
           v(:,c,d,:)=Dy
         end
       end
       Dy_archive.write(v)

     end
     Dy.destroy

    ! Do z component
     v = ZERO
     do a = 1,n_bf
       do b = 1,a-1
         v(a,b,:,:) =  Dz * S(a,b) + S * Dz(a,b)
         v(a,b,:,:).change_basis_using(P)
         v(b,a,:,:) = v(a,b,:,:)
       end
       v(a,a,:,:) =  Dz * S(a,a) + S *Dz(a,a)
       v(a,a,:,:).change_basis_using(P)
     end

     do c = 1,n_bf
       do d = 1,c-1
         v(:,:,c,d).change_basis_using(P)
         v(:,:,d,c) = v(:,:,c,d)
       end
       v(:,:,c,c).change_basis_using(P)
     end

     if(present(new_n_bf)) then

       new_v = v(1:new_n_bf,1:new_n_bf,1:new_n_bf,1:new_n_bf)

       Dz.shrink(new_n_bf,new_n_bf)

       do c = 1,new_n_bf
         do d = 1,c-1
           Dz=new_v(:,d,c,:)
           new_v(:,d,c,:)=new_v(:,c,d,:)
           new_v(:,c,d,:)=Dz
         end
       end
       Dz_archive.write(new_v)

     else

       do c = 1,.n_bf
         do d = 1,c-1
           Dz = v(:,d,c,:)
           v(:,d,c,:) = v(:,c,d,:)
           v(:,c,d,:) = Dz
         end
       end
       Dz_archive.write(v)

     end
     Dz.destroy

     P.destroy
     S.destroy
     if(present(new_n_bf)) then
         new_v.destroy
     end
     v.destroy

   end

!  ========================================
!  Electron repulsion integrals - in memory
!  ========================================

   make_MO_ERI_chem_integrals(v)
   ! Calculate the electron repulsion integrals (ERI's) in the MO basis
   ! from the AO integrals

      v :: MAT4{REAL}
      P :: MAT{REAL}*
      a,b,c,d :: INT

      P.create(.n_bf,.n_bf)
      P = .molecular_orbitals.restricted

      v=ZERO
      .:make_ERI_integrals(v)

      do a = 1,.n_bf
         v(a,a,:,:).change_basis_using(P)
         do b = 1,a-1
            v(a,b,:,:).change_basis_using(P)
            v(b,a,:,:) = v(a,b,:,:)
         end
      end

      do c = 1,.n_bf
         v(:,:,c,c).change_basis_using(P)
         do d = 1,c-1
            v(:,:,c,d).change_basis_using(P)
            v(:,:,d,c) = v(:,:,c,d)
         end
      end

      P.destroy

   end

   make_MO_ERI_integrals(v)
   ! Calculate the electron repulsion integrals (ERI's) in the MO basis from the
   ! AO integrals

      v :: MAT4{REAL}
      P,H :: MAT{REAL}*
      a,b,r,s :: INT
 
      P.create(.n_bf,.n_bf)
      P = .molecular_orbitals.restricted
 
      v=ZERO
      .:make_ERI_integrals(v)
 
      do a = 1,.n_bf
         do b = 1,a-1
           !pcc should swap a and b to make it faster
           v(a,b,:,:).change_basis_using(P)
           v(b,a,:,:) = v(a,b,:,:)
         end
         v(a,a,:,:).change_basis_using(P)
      end
 
      stdout.flush
      stdout.text(" First half (ab) of ERI has been transformed! ")
 
      do r = 1,.n_bf
         do s = 1,r-1
           v(:,:,r,s).change_basis_using(P)
           v(:,:,s,r) = v(:,:,r,s)
         end
         v(:,:,r,r).change_basis_using(P)
      end
      P.destroy
 
    ! stdout.flush
    ! stdout.text(" Second half (rs) of ERI has been transformed! ")
 
      H.create(.n_bf,.n_bf)
 
      ! Swap b and c to have it like <a1b2|c1d2> and not (a1b1c2d2) order
      ! hence the Szabo Ostlund notation will work
      do r = 1,.n_bf
        do s = 1,r-1
          H = v(:,s,r,:)
          v(:,s,r,:)=v(:,r,s,:)
          v(:,r,s,:)=H
        end
      end
 
    ! stdout.flush
    ! stdout.text(" Swap (br) of ERI has been performed! ")
 
      H.destroy

   end

   make_u_MO_ERI_integrals(vaa,vbb,vab)
   ! Calculate the electron repulsion integrals (ERI's) in the MO basis from the
   ! AO integrals for the unrestricted MP2
   ! could be split into three separate routines to lower the the core memory demands
   ! by a factor of three

     vaa,vbb,vab :: MAT4{REAL}
     Pa,Pb,H :: MAT{REAL}*
     a,b,r,s :: INT

     Pa.create(.n_bf,.n_bf)
     Pb.create(.n_bf,.n_bf)
     Pa = .molecular_orbitals.alpha
     Pb = .molecular_orbitals.beta

     vaa=ZERO; vab=ZERO; vbb=ZERO
    .:make_ERI_integrals(vaa)
    vab=vaa; vbb=vaa

      do a = 1,.n_bf
        do b = 1,a-1
          !pcc should swap a and b to make it faster
          vaa(a,b,:,:).change_basis_using(Pa)
          vab(a,b,:,:).change_basis_using(Pb)
          vbb(a,b,:,:).change_basis_using(Pb)
          vaa(b,a,:,:) = vaa(a,b,:,:)
          vab(b,a,:,:) = vab(a,b,:,:)
          vbb(b,a,:,:) = vbb(a,b,:,:)
        end
        vaa(a,a,:,:).change_basis_using(Pa)
        vab(a,a,:,:).change_basis_using(Pb)
        vbb(a,a,:,:).change_basis_using(Pb)
      end

     stdout.flush
     stdout.text(" First half (ab) of ERI has been transformed! ")

      do r = 1,.n_bf
        do s = 1,r-1
          vaa(:,:,r,s).change_basis_using(Pa)
          vab(:,:,r,s).change_basis_using(Pa)
          vbb(:,:,r,s).change_basis_using(Pb)
          vaa(:,:,s,r) = vaa(:,:,r,s)
          vab(:,:,s,r) = vab(:,:,r,s)
          vbb(:,:,s,r) = vbb(:,:,r,s)
        end
        vaa(:,:,r,r).change_basis_using(Pa)
        vab(:,:,r,r).change_basis_using(Pa)
        vbb(:,:,r,r).change_basis_using(Pb)
      end
     Pa.destroy
     Pb.destroy

     stdout.flush
     stdout.text(" Second half (rs) of ERI has been transformed! ")

    H.create(.n_bf,.n_bf)

   ! swap b and c to have it like <a1b2|c1d2> and not (a1b1c2d2) order
   ! hence the Szabo Ostlund notation will work
     do r = 1,.n_bf
       do s = 1,r-1
         H = vaa(:,s,r,:)
         vaa(:,s,r,:)=vaa(:,r,s,:)
         vaa(:,r,s,:)=H
         H = vab(:,s,r,:)
         vab(:,s,r,:)=vab(:,r,s,:)
         vab(:,r,s,:)=H
         H = vbb(:,s,r,:)
         vbb(:,s,r,:)=vbb(:,r,s,:)
         vbb(:,r,s,:)=H
       end
     end

     stdout.flush
     stdout.text(" Swap (br) of ERI has been performed! ")

    H.destroy

   end

   make_gc_MO_ERI_integrals(v)
   ! Calculate the electron repulsion integrals (ERI's) in the MO basis from the
   ! AO integrals
   !
   ! current version: L. Rispanova, Diploma Thesis, STUBA, 2016. (supervisor: L.
   ! Bucinsky)
   !
     v :: MAT4{CPX}
     va_new,vb_new :: MAT4{CPX}*
     P,H :: MAT{CPX}*
     vr :: MAT4{REAL}*
     m1,m2 :: MAT{CPX}*
     a,b,r,s :: INT
     x1 :: CPX

     P.create(2*.n_bf,2*.n_bf)
     P = .molecular_orbitals.general_complex
     x1=(ONE,ZERO)

     v=(ZERO,ZERO)
     vr.create(.n_bf,.n_bf,.n_bf,.n_bf)
     vr=ZERO
     .:make_ERI_integrals(vr)

     !
     va_new.create(.n_bf,.n_bf,2*.n_bf,2*.n_bf)
     vb_new.create(.n_bf,.n_bf,2*.n_bf,2*.n_bf)
     va_new=(ZERO,ZERO)
     vb_new=(ZERO,ZERO)
     do a = 1,.n_bf
     do b = 1,.n_bf
        vr(a,b,:,:).change_basis_to(va_new(a,b,:,:),P(1:.n_bf,:))
        vr(a,b,:,:).change_basis_to(vb_new(a,b,:,:),P(1+.n_bf:,:))
     end
     end
     vr.destroy

     stdout.flush
     stdout.text(" First half (ab) of ERI has been transformed! ")

     m1.create(.n_bf,.n_bf)
     m2.create(2*.n_bf,2*.n_bf)
     do r = 1,2*.n_bf
     do s = 1,2*.n_bf
        m1 = va_new(:,:,r,s)
        m2=(ZERO,ZERO)
        m1.change_basis_to(m2,P(1:.n_bf,:)) !aa
        v(:,:,r,s)=m2

        m2=(ZERO,ZERO)
        m1.change_basis_to(m2,P(1+.n_bf:,:)) !ba
        v(:,:,r,s)=m2+v(:,:,r,s)

        m1 = vb_new(:,:,r,s)
        m2=(ZERO,ZERO)
        m1.change_basis_to(m2,P(1:.n_bf,:)) !ab
        v(:,:,r,s)=m2+v(:,:,r,s)

        m2=(ZERO,ZERO)
        m1.change_basis_to(m2,P(1+.n_bf:,:)) !bb
        v(:,:,r,s)=m2+v(:,:,r,s)
     end
     end

     stdout.flush
     stdout.text(" Second half (rs) of ERI has been transformed! ")
    
     m1.destroy
     m2.destroy
     va_new.destroy
     vb_new.destroy

     H.create(2*.n_bf,2*.n_bf)

   ! swap b and c to have it like <a1b2|c1d2> and not (a1b1|c2d2) order
   ! hence the Szabo Ostlund notation will work
      do r = 1,2*.n_bf
         do s = 1,r-1
          H = v(:,s,r,:)
          v(:,s,r,:)=v(:,r,s,:)
          v(:,r,s,:)=H
        end
      end

     stdout.flush
     stdout.text(" Swap (br) of ERI has been performed! ")
     stdout.flush
     WARN("The FOCK routine on ERI GCHF should be OK now.")
     stdout.flush

    H.destroy

   end

end

