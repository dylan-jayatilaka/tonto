!---------------------------------------------------------------------------
!
! FOCK_DIIS: DIIS Extrapolation technique for Fock vectors
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! There are two kinds of DIIS in this module. One is a generic DIIS
! used for extrapolating sequences of real vectors according to the
! usual Pulay scheme.  The second kind are made for SCF procedures and
! inlcude the Pulay scheme, the energy DIIS scheme, and the density
! DIIS scheme. For the energy DIIS scheme See reference Kudin,
! Scuseria, Cances (2002) JCP 116, p. 8255
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: fock_diis.foo 3535 2011-10-09 18:11:27Z dylan_ $
!---------------------------------------------------------------------------

module FOCK_DIIS

   implicit none

   saved_self :: FOCK_DIIS*, private   DEFAULT_NULL

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   create(root_name,name,diis_kind,format,keep) ::: leaky
   ! Create the DIIS object, but no archive name
      self :: PTR
      root_name,name :: STR
      diis_kind,format :: STR, optional
      keep :: INT, IN, optional
      .create
      .archive.set(root_name,name,diis_kind,format)
      .set_keep(keep)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      .archive.nullify_ptr_part
      .nullify_matrices
   end

   nullify_matrices
   ! Nullify the matrices which are stored for DIIS. 
      nullify(.oldest)
      ! The following should never be destroyed
      nullify(.S) 
      nullify(.F)
      nullify(.D)
      nullify(.J)
      nullify(.energy)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
      .delete_archives
      .oldest.destroy
      .archive.destroy_ptr_part
   end

   create_copy(diis) ::: leaky
   ! Make a copy of the diis object
      self :: PTR
      diis :: FOCK_DIIS
      .create
      .copy(diis)
   end

   copy(diis) ::: leaky
   ! Make a copy of the diis object
      diis :: FOCK_DIIS
      self = diis
      .nullify_ptr_part
      .archive.copy(diis.archive)
   end

   set_defaults ::: leaky
   ! Set up the default settings
      .set_genre(DIIS_GENRE)
      .start_iteration = DIIS_START_ITERATION
      .save_iteration = DIIS_SAVE_ITERATION
      .iteration = -1 ! The first time called it is iteration 0
      .keep = DIIS_KEEP
      .kept = 0
      .new = 0
      .oldest.destroy ! Leaky here
      .oldest.create(.keep)
      .oldest = 0
      .error_length = huge(ONE)
      .convergence_tolerance = DIIS_CONVERGENCE_TOLERANCE
      .start_tolerance = DIIS_START_TOLERANCE
      .encore_iterations = DIIS_ENCORE_ITERATIONS
      .encore = 0
      .stage = 0
      .replacement_method = DIIS_REPLACEMENT_METHOD
      .par_tag = "fock_mx"
      .err_tag = "pulay_error"
      .lhs_tag = "lhs,diis,restricted"
      .F_tag = "fock_mx"
      .J_tag = "coulomb_mx"
      .D_tag = "density_mx"
      .e_tag = "energy"
      .force_convexity = DIIS_FORCE_CONVEXITY ! FALSE for DIIS and DDIIS
      .micro_iteration_method = DIIS_MICRO_ITERATION_METHOD
      .micro_convergence_tol = DIIS_MICRO_CONVERGENCE_TOL
      .micro_max_iterations = DIIS_MICRO_MAX_ITERATIONS
      .micro_damp_factor = DIIS_MICRO_DAMP_FACTOR
      .archive.set_defaults
      .archive.destroy_ptr_part
   end

   reset_iteration_defaults ::: leaky
   ! Set up the default settings
      .iteration = -1 ! The first time called it is iteration 0
      .kept = 0
      .new = 0
      .oldest.destroy ! Leaky here
      .oldest.create(.keep)
      .oldest = 0
      .encore = 0
      .stage = 0
      .archive.set_defaults
      .archive.destroy_ptr_part
   end

! ===========
! Set methods
! ===========

   set_genre(genre)
   ! Set the DIIS kind
      genre :: STR, IN
      .genre = genre
      .genre.to_lower_case
      select case (.genre)
         case("ddiis","density_diis")
            .set_force_convexity(TRUE)
         case("fdiis","fock_diis")
            .set_force_convexity(FALSE)
         case("ediis","energy_diis")
            .set_force_convexity(TRUE)
            .set_save_iteration(0)
            .set_start_iteration(0)
         case("ediis+diis")
             .set_force_convexity(TRUE)
            .set_save_iteration(0)
            .set_start_iteration(0)
         case default; UNKNOWN(.genre)
      end
   end

   set_convergence_tolerance(tolerance)
   ! Read the DIIS convergence tolerance
      tolerance :: REAL, IN
   ENSURE(tolerance>ZERO,"must have positive convergence tolerance")
   WARN_IF(tolerance<TOL(6),"convergence tolerance may be too small")
      .convergence_tolerance = tolerance
   end

   set_start_tolerance(tolerance)
   ! Read the start tolerance, when EDIIS is supposed to finish and
   ! when DIIS is supposed to start again.
      tolerance :: REAL, IN
   ENSURE(tolerance>ZERO,"must have positive start tolerance")
   ENSURE(tolerance>.convergence_tolerance,"start tolerance must be larger than convergence tolerance")
   WARN_IF(tolerance<TOL(6),"start tolerance may be too small")
      .start_tolerance = tolerance
   end

   set_keep(keep) ::: leaky
   ! Set the number of DIIS objects to keep for use in extrapolation
   ! or interpolation
      keep :: INT, IN
   ENSURE(keep>1,"no. to keep must be more than 2")
      .keep = keep
      .oldest.destroy
      .oldest.create(.keep)
      .oldest = 0
   end

   set_start_iteration(start)
   ! Set at what iteration the DIIS procedure should start
      start :: INT, IN
   ENSURE(start>=0,"start_iteration must be non-negative")
   ENSURE(.save_iteration<=start,"start_iteration must be equal or exceed save_iteration")
      .start_iteration = start
   end

   set_save_iteration(save_it)
   ! Set at what iteration the DIIS procedure should start saving vectors
      save_it :: INT, IN
   ENSURE(save_it>=0,"save_iteration must be non-negative")
   ENSURE(save_it<=.start_iteration,"save_iteration must not exceed start_iteration")
      .save_iteration = save_it
   end

   set_encore_iterations(encore)
   ! Set thye number of encore iterations to use in the EDIIS+DIIS method.
      encore :: INT, IN
   ENSURE(encore>0,"encore iteration must be positive")
      .encore_iterations = encore
   end

   set_force_convexity(force)
   ! Set whether to force convexity.
      force :: BIN, IN
      .force_convexity = force
      WARN_IF(NOT force AND (.genre=="ediis" OR .genre=="energy_diis"),"EDIIS may fail if convexity is not enforced")
   end

   set_replacement_method(method)
   ! Set the method to use for replaceing DIIS vctors, when the DIIS space
   ! become saturated.
      method :: STR, IN
      .replacement_method = method
      select case (method)
         case ("oldest")
         case ("worst")
         case default; UNKNOWN(method)
      end
   end

   set_micro_iteration_method(method)
   ! Set the micor iteration method to use.
      method :: STR, IN
      .micro_iteration_method = method
      select case (method)
         case ("bfgs")
         case ("linearisation")
         case default; UNKNOWN(method)
      end
   end

   set_micro_starting_guess(guess)
   ! Set the micro iteration starting guess to use.
      guess :: STR, IN
      .micro_starting_guess = guess
      select case (guess)
         case ("diis")
         case ("last")
         case default; UNKNOWN(guess)
      end
   end

   set_micro_convergence_tol(tol)
   ! Set the convergence tolerance "tol" used in the iterative solution of the
   ! non-linear DDIIS equations.
      tol :: REAL, IN
   ENSURE(tol>ZERO,"tol must be positive")
      .micro_convergence_tol = tol
   end

   set_micro_damp_factor(damp)
   ! Set the "damp" factor used in the iterative solution of the non-linear
   ! DDIIS equations.
      damp :: REAL, IN
   ENSURE(damp.is_in_range([ZERO,ONE]),"damp is not between zero and one")
      .micro_damp_factor = damp
   end

   set_micro_max_iterations(maxit)
   ! Set the maximum iterations "maxit" allowed in the iterative solution of the
   ! non-linear DDIIS equations.
      maxit :: INT, IN
   ENSURE(maxit>0,"maxit must be positive")
      .micro_max_iterations = maxit
   end

! ==============================================
! Define the files where DIIS stores information
! ==============================================

   set_archive_root_name(root_name)
   ! Set the DIIS archive to have root name "root_name".
      root_name :: STR
      .archive.set_root_name(root_name)
   end

   set_archive_name(name)
   ! Set the DIIS archive name.
      name :: STR
      .archive.set_name(name)
   end

   set_archive_format(format)
   ! Set the DIIS archive format.
      format :: STR
      .archive.set_format(format)
   end

! ======================================
! Clean up all the DIIS files and object
! ======================================

   cleanup
   ! Cleanup the DIIS files and matrices, and other objects, but don't
   ! resort back to default parameters. In particular, don't reset
   ! .kept.
      .delete_archives
      .archive.destroy_ptr_part
   ! .destroy_ptr_part
      .iteration = -1
      .new = 0
      .error_length = huge(ONE)
   end

   delete_archives
   ! Delete the archive files on disk.
      name :: STR
      name = .archive.name
      .delete_archives(name)
   end

   delete_archives(name)
   ! Delete the archive files on disk.
      name :: STR, IN
      i :: INT
      i_str :: STR
      .archive.set_name(trim(name)//",lhs,diis");  .archive.delete_all_genres
      .archive.set_name(trim(name)//",lhs,ediis"); .archive.delete_all_genres
      .archive.set_name(trim(name)//",lhs,ddiis"); .archive.delete_all_genres
      do i = 1,.keep+1
        i_str = i.to_str
        .archive.set_name(trim(name)//",fock_mx,"//trim(i_str));       .archive.delete_all_genres
        .archive.set_name(trim(name)//",pulay_error,"//trim(i_str));       .archive.delete_all_genres
        .archive.set_name(trim(name)//",density_mx,"//trim(i_str));    .archive.delete_all_genres
        .archive.set_name(trim(name)//",coulomb_mx,"//trim(i_str));    .archive.delete_all_genres
        .archive.set_name(trim(name)//",constraint_mx,"//trim(i_str)); .archive.delete_all_genres
        .archive.set_name(trim(name)//",energy,"//trim(i_str));            .archive.delete_all_genres
      end
      .archive.set_name(trim(name))
      .iteration = -1
      .new = 0
      .error_length = huge(ONE)
   end

   delete_CPHF_archives(n_pert)
   ! Delete the archive files on disk to do with a generic CPHF extrapolation
      n_pert :: INT, IN
      i,n :: INT
      n_str,ni_str :: STR
      name :: STR
      name = .archive.name
      do n = 1,n_pert
        n_str = n.to_str
        .archive.set_name(trim(name)//",lhs,diis,U"//trim(n_str)); .archive.delete_all_genres
        do i = 1,.keep+1
           ni_str = trim(n_str)//","//trim(i.to_str)
           .archive.set_name(trim(name)//",U"//trim(ni_str));       .archive.delete_all_genres
           .archive.set_name(trim(name)//",delta_U"//trim(ni_str)); .archive.delete_all_genres
        end
      end
      .archive.set_name(trim(name))
      .iteration = -1
      .new = 0
      .error_length = huge(ONE)
   end

! ==============================
! Read the keywords and settings
! ==============================

   read_keywords ::: get_from(OBJECT)
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process a command "keyword". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}                       ")  ! exit case
         case ("convergence_tolerance=  "); .read_convergence_tolerance
         case ("encore_iterations=      "); .read_encore_iterations
         case ("force_convexity=        "); .read_force_convexity
         case ("genre=                  "); .read_genre
         case ("keep=                   "); .read_keep
         case ("kind=                   "); .read_genre
         case ("micro_convergence_tol=  "); .read_micro_convergence_tol
         case ("micro_damp_factor=      "); .read_micro_damp_factor
         case ("micro_iteration_method= "); .read_micro_iteration_method
         case ("micro_max_iterations=   "); .read_micro_max_iterations
         case ("micro_starting_guess=   "); .read_micro_starting_guess
         case ("replacement_method=     "); .read_replacement_method
         case ("save_iteration=         "); .read_save_iteration
         case ("start_iteration=        "); .read_start_iteration
         case ("start_tolerance=        "); .read_start_tolerance
         case default;           UNKNOWN(word)
      end
   end

   read_genre
   ! Read the kind of DIIS procedure to use
      genre :: STR
      stdin.read(genre)
      .set_genre(genre)
   end

   read_convergence_tolerance
   ! Read the DIIS convergence tolerance
      tolerance :: REAL
      stdin.read(tolerance)
      .set_convergence_tolerance(tolerance)
   end

   read_start_tolerance
   ! Read the DIIS convergence tolerance
      tolerance :: REAL
      stdin.read(tolerance)
      .set_start_tolerance(tolerance)
   end

   read_keep ::: leaky
   ! Read the maximum number of DIIS vectors to keep
      keep :: INT
      stdin.read(keep)
      .set_keep(keep)
   end

   read_force_convexity
   ! Set whether to force convexity or not.
      force :: BIN
      stdin.read(force)
      .set_force_convexity(force)
   end

   read_replacement_method
   ! Read the replacement method to use for the DIIS vectors, when the
   ! DIIS space bcomes saturated.
      method :: STR
      stdin.read(method)
      .set_replacement_method(method)
   end

   read_micro_iteration_method
   ! Read the micro iteration method to use in the iterative solution of the
   ! non-linear DDIIS equations.
      method :: STR
      stdin.read(method)
      .set_micro_iteration_method(method)
   end

   read_micro_starting_guess
   ! Read the micro iteration starting guess to use in the iterative solution of
   ! the non-linear DDIIS equations.
      guess :: STR
      stdin.read(guess)
      .set_micro_starting_guess(guess)
   end

   read_micro_convergence_tol
   ! Set the convergence tolerance used in the iterative soltion of th
   ! non-linear DDIIS equations.
      tol :: REAL
      stdin.read(tol)
      .set_micro_convergence_tol(tol)
   end

   read_micro_damp_factor
   ! Read the damp factor used in the iterative soltion of th non-linear DDIIS
   ! equations.
      damp :: REAL
      stdin.read(damp)
      .set_micro_damp_factor(damp)
   end

   read_micro_max_iterations
   ! Read the maximum iterations allowed in the iterative soltion of
   ! th non-linear DDIIS equations.
      maxit :: INT
      stdin.read(maxit)
      .set_micro_max_iterations(maxit)
   end

   read_start_iteration
   ! Read the starting iteration for the DIIS procedures.
      start :: INT
      stdin.read(start)
      .set_start_iteration(start)
   end

   read_save_iteration
   ! Read the iteration for saving the DIIS vectors
      save_it :: INT
      stdin.read(save_it)
      .set_save_iteration(save_it)
   end

   read_encore_iterations
   ! Read the number of  encoreiteration for the EDIIS procedures.
      encore :: INT
      stdin.read(encore)
      .set_encore_iterations(encore)
   end

! ==========================================
! Queries related to the DIIS procedure ....
! ==========================================

   apply_diis result (res)
   ! Return TRUE if DIIS must be applied this iteration, or has been
   ! applied this iteration.  Here, applying can mean that the
   ! DIIS procedure merely saves the vectors in the archive, but
   ! does not yet do any acceleration. If you want to know if the
   ! DIIS equations are to be solved for a meaningful
   ! extrapolation or interpolation, see the ".solve_equations"
   ! method. 
      res :: BIN
      res = .saved_iteration >= 1 AND .keep > 1
   end

   subspace_saturated result (res)
   ! Return TRUE if DIIS subspace is saturated; no more new DIIS
   ! vectors can be stored on the archive.
      res :: BIN
      res = .kept == .keep
   end

   is_stuck_or_oscillating result (res)
   ! Return TRUE if DIIS is stuck or oscillating
      res :: BIN
      res = .subspace_saturated AND .keep>=4  
      if (NOT res) return
      res = res &
        AND .oldest(.keep  )==.oldest(.keep-2) &
        AND ( &
            .oldest(.keep-1)==.oldest(.keep-3) )
      ! OR  .oldest(.keep-1)==.oldest(.keep-2) )
   end

   was_stuck result (res)
   ! Return TRUE if DIIS was stuck or oscillating some time in the past.
   ! This routine only returns TRUE once.
      res :: BIN
      res = .keep>=4   &
        AND .oldest(.keep  )==.oldest(.keep-2) &
        AND ( &
            .oldest(.keep-1)==.oldest(.keep-3) )
      ! OR  .oldest(.keep-1)==.oldest(.keep-2) )
      if (res) .oldest(.keep) = -1
   end

   solve_equations result (res)
   ! Return TRUE if DIIS method will really be used to solve the
   ! DIIS equations.
      res :: BIN
      res = .actual_iteration > 0 AND .kept > 1 AND .keep > 1
   end

   switch_to_diis result (res)
   ! Switch to DIIS after doing EDIIS
      res :: BIN
      res = .stage==0 AND .error_length<.start_tolerance
   end

   switch_to_encore_ediis result (res)
   ! Switch back to DIIS after doing EDIIS, because convergence has
   ! got worse.
      res :: BIN
      res = .stage==1 AND .error_length>=.start_tolerance
   end

   switch_back_to_diis result (res)
   ! Switch back to DIIS after doing encore EDIIS.
      res :: BIN
      res = .stage==2 AND .encore==.encore_iterations
   end

! ==========================
! Iteration information ....
! ==========================

   actual_iteration result (res)
   ! Return the actual DIIS iteration number -- since the DIIS
   ! procedure really starts to do an acceleration, as opposed to just
   ! storing things in the archive. (Even though the first actual DIIS
   ! iteration may do nothing, it is still counted as an actual
   ! iteration).
      res :: INT
      res = .iteration - .start_iteration + 1
   end

   saved_iteration result (res)
   ! Return the actual DIIS iteration number since starting to save
   ! vectors and construct left hand side matrices -- not just the
   ! total number of iterations in the procedure. This is usually
   ! equal to .kep but not always -- especially in constrained SCF
   ! calculations where we reuse past vectors.
      res :: INT
      res = .iteration - .save_iteration + 1
   end

   next_replacement(best) result (res) ::: private
   ! Return the index of the next item in the DIIS expansion which is
   ! to be replaced or archived.  Keep a record of this item in
   ! .oldest so we know when the DIIS is stuck or oscillating.  Also
   ! return the "best" index if the DIIS procedure becomes stuck. 
   ! NOTE: .kept is not updated until later (see .update_kept)
   ! NOTE: do not call this more than once per cycle.
      best :: INT
      res :: INT

      ! Get the index of the next replacement
      if (.kept<.keep) then; res = .kept+1
      else;                  res = .the_replacement
      end
      DIE_IF(res>.keep,"next replacement index exceeds DIIS subspace size")

      ! Append the index of the next replacement to history list
      if (.subspace_saturated) then
         .oldest(1:.keep-1) = .oldest(2:.keep)
         .oldest(.keep) = res
      else
         .oldest(res) = res
      end

      ! If the DIIS is stuck keep the best item provided it is not the
      ! oldest one; otherwise reset completely.
      best = 0
      if (.is_stuck_or_oscillating) then
         best = .best_item             
         if (best/=.oldest(1)) then 
            .kept = 1        ! We must swap best to first position 
            .oldest(1) = 1
         else
            .kept = 0                   
            best = 0
         end
         res = .kept + 1
         .oldest(res) = res
         ! Reset these in case the method is "ediis+diis"
         .stage = 0  
         .encore = 0
      end
   end

   the_replacement result (res) ::: private
   ! Return the index of the item which should be replaced in the DIIS archive
   ! when the archive reaches the ".keep" limit. This is the either the item
   ! with the worst DIIS error or the one which is oldest.
      res :: INT
      select case(.replacement_method)
         case("oldest"); res = .oldest_item
         case("worst");  res = .worst_item
         case default;   UNKNOWN(.replacement_method)
      end
   end

   oldest_item result (res) ::: private
   ! Return the index of the current item (if it is less than or equal to the
   ! number of vectors to be kept), otherwise return the index of the oldest
   ! item. EDIIS usually replaces the oldest item.  NOTE: This assumes that the
   ! .iteration counter has been incremented or set to the index of the current
   ! item.
      res :: INT
   ENSURE(.keep>0,"no vectors kept")
   ENSURE(.kept>0,"must have some archived vectors")
   ENSURE(.oldest.associated,"oldest list not created")
      res = .oldest(1)
   end

   worst_item result (res) ::: private
   ! Return the index of the worst item which should be replaced in the DIIS
   ! archive when the archive reaches the ".keep" limit. 
      res :: INT

   ENSURE(.lhs_tag/=" ","no lhs tag specified")
   ENSURE(.kept>0,"no stored vectors")

      lhs :: MAT{REAL}*
      diag,rhs :: VEC{REAL}*
  !   clhs :: MAT{CPX}*
      dim :: INT

      dim = .dimension

      select case (.lhs_tag)

         case("lhs,diis,restricted","lhs,ddiis,restricted","lhs,diis,unrestricted","lhs,diis,general_complex")
            .get_old_r_lhs(lhs)
            diag.create(dim)
            lhs.put_diagonal_to(diag)            ! the error vector lengths^2
            res = diag.index_of_largest_value    ! Worst item has the largest error
            diag.destroy
            lhs.destroy

!         case("lhs,diis,general_complex")
!            .get_old_gc_lhs(clhs)
!            diag.create(dim)
!            clhs.put_diagonal_to(diag)           ! the error vector lengths^2
!            res = diag.index_of_largest_value    ! Worst item has the largest error
!            diag.destroy
!            clhs.destroy

         case("lhs,ddiis,unrestricted")
            .get_old_u_lhs(lhs)
            rhs.create(2*dim)
            diag.create(2*dim)
            lhs.put_diagonal_to(rhs)             ! the error vector lengths^2
            diag = sum(reshape(rhs,[dim,2]),dim=2)
            res = diag(1:dim).index_of_largest_value    ! Worst item has the largest error
            diag.destroy
            rhs.destroy
            lhs.destroy

         case("lhs,ediis,restricted")
            .get_old_r_rhs(rhs)
            res = rhs(1:dim-1).index_of_maximum ! Worst item has the highest energy
            rhs.destroy

         case("lhs,ediis,unrestricted")
            .get_old_u_rhs(rhs)                 ! This seems wrong for u-EDIIS
            diag.create(dim)                    ! ... we need E = R.LHS.R
            diag = sum(reshape(rhs,[dim,2]),dim=2)
            res = diag(1:dim-1).index_of_maximum ! Worst item has the highest energy
            diag.destroy
            rhs.destroy

         case default
            .get_old_lhs(lhs)             
            diag.create(dim)
            lhs.put_diagonal_to(diag)            ! the error vector lengths^2
            res = diag.index_of_largest_value    ! Worst item has the largest error
            diag.destroy
            lhs.destroy
      end

   end

!   best_item result (res) ::: private
!   ! Return the index of the best item which should be kept in the DIIS
!   ! archive when the procedure is reset.
!      res :: INT
!   ENSURE(.lhs_tag/=" ","no lhs tag specified")
!   ENSURE(.kept>0,"no stored vectors")
!      lhs :: MAT{REAL}*
!      diag,rhs :: VEC{REAL}*
!      dim :: INT
!      dim = .dimension
!      select case (.lhs_tag)
!         case("lhs,diis,restricted","lhs,ddiis,restricted","lhs,diis,unrestricted")
!            .get_old_r_lhs(lhs)
!            diag.create(dim)
!            lhs.put_diagonal_to(diag)            ! the error vector lengths^2
!            res = diag(1:dim-1).index_of_smallest_value   
!            diag.destroy
!            lhs.destroy
!         case("lhs,ddiis,unrestricted")
!            .get_old_u_lhs(lhs)
!            rhs.create(2*dim)
!            lhs.put_diagonal_to(rhs)            ! the error vector lengths^2
!            diag.create(dim)
!            diag = sum(reshape(rhs,[dim,2]),dim=2)
!            res = diag(1:dim-1).index_of_smallest_value 
!            if (res>dim) res = res - dim
!            diag.destroy
!            rhs.destroy
!            lhs.destroy
!         case("lhs,ediis,restricted")
!          ! res = .oldest_item
!            .get_old_r_rhs(rhs)
!            diag.create(dim)
!            res = diag(1:dim-1).index_of_minimum 
!            diag.destroy
!            rhs.destroy
!         case("lhs,ediis,unrestricted")
!          ! res = .oldest_item
!            .get_old_u_rhs(rhs)
!            diag.create(dim)
!            diag = sum(reshape(rhs,[dim,2]),dim=2)
!            res = diag(1:dim-1).index_of_maximum 
!            diag.destroy
!            rhs.destroy
!         case default
!            .get_old_lhs(lhs)
!            diag.create(dim)
!            lhs.put_diagonal_to(diag)            ! the error vector lengths^2
!            res = diag(1:dim-1).index_of_smallest_value   
!            diag.destroy
!            lhs.destroy
!      end
!   end

   best_item result (res) ::: private
   ! Return the index of the best item which should be kept in the DIIS
   ! archive when the procedure is reset.
      res :: INT
   ENSURE(.lhs_tag/=" ","no lhs tag specified")
   ENSURE(.kept>0,"no stored vectors")
      lhs :: MAT{REAL}*
      diag,rhs :: VEC{REAL}*
      dim :: INT
      dim = .dimension
      select case (.lhs_tag)
         case("lhs,diis,restricted","lhs,ddiis,restricted","lhs,diis,unrestricted")
            .get_old_r_lhs(lhs)
            diag.create(dim)
            lhs.put_diagonal_to(diag)            ! the error vector lengths^2
            res = diag(1:dim-1).index_of_smallest_value   
            diag.destroy
            lhs.destroy
         case("lhs,ddiis,unrestricted")
            .get_old_u_lhs(lhs)
            rhs.create(2*dim)
            lhs.put_diagonal_to(rhs)            ! the error vector lengths^2
            diag.create(dim)
            diag = sum(reshape(rhs,[dim,2]),dim=2)
            res = diag(1:dim-1).index_of_smallest_value 
            if (res>dim) res = res - dim
            diag.destroy
            rhs.destroy
            lhs.destroy
         case("lhs,ediis,restricted")
          ! res = .oldest_item
            .get_old_r_rhs(rhs)
            diag.create(dim)
            res = diag(1:dim-1).index_of_minimum 
            diag.destroy
            rhs.destroy
         case("lhs,ediis,unrestricted")
          ! res = .oldest_item
            .get_old_u_rhs(rhs)
            diag.create(dim)
            diag = sum(reshape(rhs,[dim,2]),dim=2)
            res = diag(1:dim-1).index_of_maximum 
            diag.destroy
            rhs.destroy
         case default
            .get_old_lhs(lhs)
            diag.create(dim)
            lhs.put_diagonal_to(diag)            ! the error vector lengths^2
            res = diag(1:dim-1).index_of_smallest_value   
            diag.destroy
            lhs.destroy
      end
   end

   dimension result (res) ::: private
   ! Return the dimension of the DIIS matrix assuming that another set of
   ! vectors will be stored in the archive. It can never exceed one more than
   ! the number of DIIS iterates to be kept on the disk.
   ! WARNING: set dimension before calling .update_kept_info.
      res :: INT
      res = min(.kept+1,.keep) + 1
   end

   update_kept ::: private
   ! Update the info regarding how many vectors were kept.
   ! NOTE: this should be called only after all DIIS matrices are made
   ! NOTE: this assumes .new has been set to the latest updated vector.
      .kept = min(.kept+1,.keep)
   end

!   keep_the_best
!   ! Keep only the best item
!   ENSURE(.kept>1,"no vectors kept")
!      W :: OPMATRIX*
!      dimv,best :: INT
!      e,ea,eb :: REAL
!      genre :: STR
!      best = .best_item
!      if      (best==.oldest(1)) then ! the best is the oldest, 
!         .kept = 0                    ! we can't keep any, must reset completely
!      else if (best/=.oldest(1)) then 
!         .kept = 1
!         .oldest(1) = 1
!         if (.F.associated) then
!            ENSURE(.F.associated,"no Fock matrix")
!            ENSURE(.D.associated,"no density matrix")
!            ENSURE(.S.associated,"no overlap matrix")
!            ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
!            ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")
!            genre = .F.spinorbital_kind
!            dimv = .S.dim1
!            if (.archive_exists(.F_tag,best)) then
!               .read_item(.F,.F_tag,best)
!               .save_item(.F,.F_tag,1)
!            end
!            if (.archive_exists(.D_tag,best)) then
!               .read_item(.D,.D_tag,best)
!               .save_item(.D,.D_tag,1)
!            end
!            if (.archive_exists("constraint_mx",best)) then
!               W.create(dimv,genre)
!               .read_item(W,"constraint_mx",best)
!               .save_item(W,"constraint_mx",1)
!               W.destroy
!            end
!            if (.archive_exists(.J_tag,best)) then
!               W.create(dimv,genre)
!               .read_item(W,.J_tag,best)
!               .save_item(W,.J_tag,1)
!               W.destroy
!            end
!            if (.archive_exists(.e_tag,best)) then
!               .read_item(e,.e_tag,best)
!               .save_item(e,.e_tag,1)
!            end
!            if (.archive_exists(.e_tag.trim//","//.new.to_str.trim//",alpha",best)) then
!               .read_item(ea,.e_tag,best)
!               .save_item(ea,.e_tag,1)
!            end
!            if (.archive_exists(.e_tag.trim//","//.new.to_str.trim//",beta",best)) then
!               .read_item(eb,.e_tag,best)
!               .save_item(eb,.e_tag,1)
!            end
!            .remake_diis_lhs(genre)
!            .remake_ediis_lhs(genre)
!         else
!            if (.archive_exists(.err_tag,best)) then
!               .read_item(.F,.F_tag,best)
!               .save_item(.F,.F_tag,1)
!            end
!         end
!      end
!      ! DO this in case the method is "ediis+diis"
!      .stage = 0
!      .encore = 0
!   end

! ==========================
! Setting the DIIS error ...
! ==========================

   set_diis_error_length(length)
   ! Set the DIIS error length
      length :: REAL
      .error_length = length
   end

   set_diis_error_length
   ! Make the real DIIS commutator matrix, C = FDS - SDF and set the diis
   ! .error_length to be sqrt(C-.C). The minus sign is because C is
   ! antisymmetric.
      .set_diis_error_length(.F,.D,.S)
   end

   set_diis_error_length(F,D,S)
   ! Make the real DIIS commutator matrix, C = FDS - SDF and set the diis
   ! .error_length to be sqrt(C-.C). The minus sign is because C is
   ! antisymmetric.
      F,D :: OPMATRIX*
      S :: MAT{REAL}*

   ENSURE(F.associated,"no Fock matrix")
   ENSURE(F.has_any_genre,"no Fock matrix")
   ENSURE(D.associated,"no density matrix")
   ENSURE(D.has_any_genre,"no density matrix")
   ENSURE(S.associated,"no overlap matrix")
   ENSURE(F.n_bf==S.dim1,"Incompatible F and S")
   ENSURE(D.n_bf==S.dim1,"Incompatible D and S")

      C :: OPMATRIX*
      spinorbital_kind :: STR

      spinorbital_kind = F.spinorbital_kind
      C.create(F.n_bf,spinorbital_kind)
      .make_diis_commutator(C,F,D,S)
      select case (spinorbital_kind)
         case("restricted");      .error_length = sqrt(abs(C.restricted.dot(C.restricted)))
         case("unrestricted");    .error_length = sqrt(abs(C.alpha.dot(C.alpha)+C.beta.dot(C.beta)))
         case("general_complex"); .error_length = sqrt(abs(C.general_complex.dot(C.general_complex)))
         case default;            UNKNOWN(spinorbital_kind)
      end
      C.destroy

   end

   make_diis_commutator(C,F,D,S)
   ! Make the DIIS commutator opmatrix, C = FDS - SDF.
      C :: OPMATRIX
      F,D :: OPMATRIX, IN
      S :: MAT{REAL}, IN
   ENSURE(C.n_bf==S.dim1,"Incompatible C and S")
   ENSURE(F.n_bf==S.dim1,"Incompatible F and S")
   ENSURE(D.n_bf==S.dim1,"Incompatible D and S")
      select case (F.spinorbital_kind)
         case("restricted")
            .make_diis_commutator(C.restricted,F.restricted,D.restricted,S)
         case("unrestricted")
            .make_diis_commutator(C.alpha,F.alpha,D.alpha,S)
            .make_diis_commutator(C.beta,F.beta,D.beta,S)
            C.alpha = C.alpha + C.beta
         case("general")
            .make_diis_commutator_g(C.general,F.general,D.general,S)
         case("general_complex")
            .make_diis_commutator_gc(C.general_complex,F.general_complex,D.general_complex,S)
         case default
            DIE("unimplemented")
      end
   end

   make_diis_commutator(C,F,D,S)
   ! Make the real DIIS commutator matrix, C = FDS - SDF.
      C :: MAT{REAL}
      F,D,S :: MAT{REAL}, IN
      W :: MAT{REAL}*

      W.create(F.dim1,F.dim1)
      W.to_product_of(D,S)
      C.to_product_of(F,W)
      W.destroy
      C.antisymmetric_fold
      C.antisymmetric_reflect

   end

   make_diis_commutator_g(C,F,D,S)
   ! Make the complex DIIS commutator matrix, C = FDS - SDF.
      C :: MAT{REAL}
      F,D :: MAT{REAL}, IN
      S :: MAT{REAL}, IN
      O,W :: MAT{REAL}*

      W.create(F.dim1,F.dim1)

      ! Make the overlap matrix
      O.create(F.dim1,F.dim1)
      O = ZERO
      O.alpha_alpha_set_to(S)
      O.beta_beta_set_to(S)

      ! D x S
      W.to_product_of(D,O)
      O.destroy

      ! F x D x S
      C.to_product_of(F,W)
      W.destroy

      ! Make FDS - SDF
      C.antisymmetric_fold
      C.antisymmetric_reflect

   end

   make_diis_commutator_gc(C,F,D,S)
   ! Make the complex DIIS commutator matrix, C = FDS - SDF.
      C :: MAT{CPX}
      F,D :: MAT{CPX}, IN
      S :: MAT{REAL}, IN
      O,W :: MAT{CPX}*

      W.create(F.dim1,F.dim1)

      ! Make the overlap matrix
      O.create(F.dim1,F.dim1)
      O = ZERO
      O.alpha_alpha_set_to(S)
      O.beta_beta_set_to(S)

      ! D x S
      W.to_product_of(D,O)
      O.destroy

      ! F x D x S
      C.to_product_of(F,W)
      W.destroy

      ! Make FDS - SDF
      C.antihermitian_fold
      C.antihermitian_reflect

   end

! ==========================
! Generic DIIS Extrapolation
! ==========================

! Extrapolate without error vectors

   extrapolate(par) ::: template
   ! Generic DIIS extrapolation of the parameter vector "par".
   ! No error vector is required.
      par :: PAR?

   ENSURE(.archive.file_name/=" ","no archive name specified")

      err :: PAR?*

      ! Create the error vector
      err.create_copy(par)
      if (.kept<=1) then
         err = 100d0
      else
         .read_item(err,.err_tag,.oldest(.oldest(.kept-1)))
         err = par - err
      end

      ! Extrapolate as usual
      .extrapolate(par,err)

      ! Destroy the error vector
      err.destroy

   end

   extrapolate(par) ::: get_from(FOCK_DIIS, PAR?=>VEC{REAL})
   ! Generic DIIS extrapolation of the parameter vector "par".
   ! No error vector is required.
   end

   extrapolate(par) ::: get_from(FOCK_DIIS, PAR?=>MAT{REAL})
   ! Generic DIIS extrapolation of the parameter vector "par".
   ! No error vector is required.
   end

! Extrapolate with error vectors

   extrapolate(par,err) ::: template
   ! Generic DIIS extrapolation of the parameter vector "par", using "err" as the 
   ! error vector. This assumes that the DIIS object has been repeatedly called,
   ! previously, so that it has all the previous information on disk.
      par,err :: PAR?

   ENSURE(.archive.file_name/=" ","no archive name specified")

      best :: INT

      ! Increment iteration, get the next item to be replaced
      .iteration = .iteration + 1      
      .new   = .next_replacement(best)       

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         .save_item(par,.par_tag,.keep+1) ! store this
         .save_item(err,.err_tag,.keep+1) 
         .read_item(par,.par_tag,best)
         .save_item(par,.par_tag,1)
         .read_item(err,.err_tag,best)
         .save_item(err,.err_tag,1)
         .remake_diis_lhs(err,par)
         .read_item(par,.par_tag,.keep+1) ! now put back 
         .read_item(err,.err_tag,.keep+1)
      end

      ! Replace the parameter & error pair on disk
      .save_item(par,.par_tag,.new)    
      .save_item(err,.err_tag,.new)

      ! Set the error length
      .error_length = sqrt(err.dot(err))

      ! Finally, do the extrapolation
      .do_extrapolate(par,err)         

   end

   extrapolate(par,err) ::: get_from(FOCK_DIIS, PAR?=>VEC{REAL})
   ! Generic DIIS extrapolation of the parameter vector "par", using "err" as the 
   ! error vector. This assumes that the DIIS object has been repeatedly called,
   ! previously, so that it has all the previous information on disk. 
   end

   extrapolate(par,err) ::: get_from(FOCK_DIIS, PAR?=>MAT{REAL})
   ! Generic DIIS extrapolation of the parameter vector "par", using "err" as the 
   ! error vector. This assumes that the DIIS object has been repeatedly called,
   ! previously, so that it has all the previous information on disk.
   end

   extrapolate(par,err) ::: get_from(FOCK_DIIS, PAR?=>MAT3{REAL})
   ! Generic DIIS extrapolation of the parameter vector "par", using "err" as the 
   ! error vector. This assumes that the DIIS object has been repeatedly called,
   ! previously, so that it has all the previous information on disk. 
   end

   do_extrapolate(par,err) ::: template
   ! This is a private helper routine which does the work. "par" is the
   ! parameter vector, "err" is the corresponding error vector.
      par :: PAR?, OUT
      err :: PAR?

   ENSURE(.archive.file_name/=" ","no archive name specified")

      dim,old :: INT
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*

      ! The dimension of the new LHS (never larger than .keep+1)
      dim = .dimension 

      ! Make the new DIIS left hand side, "lhs"
      .make_diis_lhs(lhs,err,par)              
      .update_kept

      ! Now set up and solve the DIIS equations
      if (.solve_equations) then               

         ! The DIIS coefficients and rhs set up here
         coeff.create(dim)
         rhs.create(dim)
         rhs = ZERO 
         rhs(dim) = ONE

         ! Solve DIIS equations
         lhs.solve_linear_equation(rhs,coeff)  
         rhs.destroy

         ! We have the coefficients, now do the interpolation
         par = ZERO
         do old = 1,dim-1                      
            ! Use err as work space
            .read_item(err,.par_tag,old)       
            par = par + coeff(old)*err
         end

         ! Put back the current error vector
         .read_item(err,.err_tag,.new)         
         coeff.destroy
      else
         .read_item(par,.par_tag,.new)         
      end

      lhs.destroy

   end

   do_extrapolate(par,err) ::: get_from(FOCK_DIIS, PAR?=>VEC{REAL}), private
   ! This is a private helper routine which does the work. "par" is the
   ! parameter vector, "err" is the corresponding error vector.
   end

   do_extrapolate(par,err) ::: get_from(FOCK_DIIS, PAR?=>MAT{REAL}), private
   ! This is a private helper routine which does the work. "par" is the
   ! parameter vector, "err" is the corresponding error vector.
   end

   do_extrapolate(par,err) ::: get_from(FOCK_DIIS, PAR?=>MAT3{REAL}), private
   ! This is a private helper routine which does the work. "par" is the
   ! parameter vector, "err" is the corresponding error vector.
   end

   make_diis_lhs(lhs,err,old_err,save_lhs) ::: template
   ! Make the current DIIS left hand side matrix, "lhs", using "err" as the
   ! current error vector. The error vector "err" has index ".new". "old_err" is
   ! simply used as space to hold the old error vectors. NOTE: whatever is in
   ! "old_err" is trashed.  The "lhs" is saved to disk for the next iteration
   ! unless "save_lhs" is present and set to FALSE.
      lhs :: MAT{REAL}*
      err :: ERR?, IN
      old_err :: ERR?, INOUT
      save_lhs :: BIN, optional

   ENSURE(.err_tag/=" ","no err_tag specified")
   ENSURE(.lhs_tag/=" ","no lhs_tag specified")
   ENSURE(lhs.disassociated,"lhs created")

      dim,old :: INT
      sayv_lhs :: BIN 
      fac :: REAL

      ! Get the previous on disk LHS (leaky)
      .get_old_lhs(lhs)             

      ! Dimension of the new LHS
      dim = .dimension

      ! Calculate the triangle of the new DIIS matrix by looping
      ! over the .new row or column to be replaced/added.
      do old = 1,dim-1              
         .read_item(old_err,.err_tag,old)
         fac = ONE
         if (.new==old) fac = fac + 0.02d0 ! Hamilton/Pulay factor
         lhs(max(.new,old),min(.new,old)) = fac*err.dot(old_err)
         lhs(dim,old) = ONE         ! Here we set the auxiliary row on the bottom
      end
      lhs(dim,dim) = ZERO           ! And here we set the corner
      lhs.symmetric_reflect

      ! Save the LHS on the disk for next time 
      sayv_lhs = TRUE
      if (present(save_lhs)) sayv_lhs = save_lhs
      if (sayv_lhs) then
      .save_item(lhs,.lhs_tag)      
      end
    ! .condition_diis_lhs(lhs)

   end

   make_diis_lhs(lhs,err,old_err,save_lhs) ::: get_from(FOCK_DIIS, ERR?=>VEC{REAL}), leaky, private
   ! Make the current DIIS left hand side matrix, "lhs", using "err" as the
   ! current error vector. The error vector "err" has index ".new". "old_err" is
   ! simply used as space to hold the old error vectors. NOTE: whatever is in
   ! "old_err" is trashed.  The "lhs" is saved to disk for the next iteration
   ! unless "save_lhs" is present and set to FALSE.
   end

   make_diis_lhs(lhs,err,old_err,save_lhs) ::: get_from(FOCK_DIIS, ERR?=>MAT{REAL}), leaky, private
   ! Make the current DIIS left hand side matrix, "lhs", using "err" as the
   ! current error vector. The error vector "err" has index ".new". "old_err" is
   ! simply used as space to hold the old error vectors. NOTE: whatever is in
   ! "old_err" is trashed.  The "lhs" is saved to disk for the next iteration
   ! unless "save_lhs" is present and set to FALSE.
   end

   make_diis_lhs(lhs,err,old_err,save_lhs) ::: get_from(FOCK_DIIS, ERR?=>MAT3{REAL}), leaky, private
   ! Make the current DIIS left hand side matrix, "lhs", using "err" as the
   ! current error vector. The error vector "err" has index ".new". "old_err" is
   ! simply used as space to hold the old error vectors. NOTE: whatever is in
   ! "old_err" is trashed.  The "lhs" is saved to disk for the next iteration
   ! unless "save_lhs" is present and set to FALSE.
   end

   condition_diis_lhs(lhs) 
   ! Rescale using the diagonals to make the linear equations solution a
   ! bit more numerically stable. It's not *really* necessary ...
   ! This code was pinched from CADPAC, as I recall ....
   ! --dylan
      lhs :: MAT{REAL}
   ENSURE(.err_tag/=" ","no err_tag specified")
   ENSURE(.lhs_tag/=" ","no lhs_tag specified")
      diag :: VEC{REAL}*
      dim,j :: INT
      val :: REAL
      dim = .dimension
      diag.create(dim-1)
      lhs(1:dim-1,1:dim-1).put_diagonal_to(diag)
      forall (j=1:dim-1)
        lhs(1:dim-1,j) = lhs(1:dim-1,j)/diag(:)
      end
   ! The 10^-8 factor comes from using a langrange multiplier 10^-8.lambda.
   ! After this, the DIIS matrix is premultiplied by the diagonal elements of
   ! the non-augmented part, augmented by a 1 in the corner. This does not
   ! affect the right hand side which is just 0's for the first dim-1
   ! elements. The rescaled DIIS matrix has 1's on the diagonal. The TOL(8)
   ! factor seems a bit sus to me. --dylan
    ! lhs(1:dim-1,dim) = TOL(8)/diag(:)
      val = TOL(3)*maxval(abs(diag))
      lhs(1:dim-1,dim) = val/diag(:)
      diag.destroy
      lhs(dim,:) = ONE
      lhs(dim,dim) = ZERO
      ! We could weight the newest element a bit more. Since the DIIS expression
      ! is quadratic in the extrapolation coefficients, this makes the last term
      ! slightly bigger. Thus, it has slightly more influence in the DIIS solution. 
      ! When the DIIS extrapolation becomes a bit stagnant, this causes the last
      ! term to dominate a bit and the procedure can inch forward, slowly. The
      ! best idea is to use another method in the case of stagnant DIIS; DIIS
      ! is really designed for fast convergence in the quadratic region i.e. it
      ! is designed for the end-game.
      lhs(.new,.new).times(1.02d0)    ! Weight the last vector a bit more anyway
   end

   remake_diis_lhs(e_i,e_j) ::: template
   ! Rebuild the DIIS left hand side matrix, "lhs", using the error vectors on
   ! disk. The "lhs" matrix is saved to disk. Also, resets the index ".new".
   ! "e_i" and "e_j" are used as workspace; whatever is in them is trashed.
      e_i,e_j :: ERR?
      lhs :: MAT{REAL}*
      dim,i,j :: INT
      fac :: REAL

      dim = .dimension
      lhs.create(dim,dim)

      lhs = ZERO
      do i=1,dim-1
         .read_item(e_i,.err_tag,i)
         do j=1,i
            fac = ONE
            if (i==j) fac = fac + 0.02d0 ! Hamilton/Pulay factor
            .read_item(e_j,.err_tag,j)
            lhs(i,j) = e_i.dot(e_j)
         end
         lhs(dim,i) = ONE
      end
      lhs(dim,dim) = ZERO
      lhs.symmetric_reflect

      .save_item(lhs,.lhs_tag) ! Now save it for next time

      .error_length = sqrt(lhs(.new,.new))

      lhs.destroy

   end

   remake_diis_lhs(e_i,e_j) ::: get_from(FOCK_DIIS, ERR?=>VEC{REAL}), leaky, private
   ! Rebuild the DIIS left hand side matrix, "lhs", using the error vectors on
   ! disk. The "lhs" matrix is saved to disk. Also, resets the index ".new".
   ! "e_i" and "e_j" are used as workspace; whatever is in them is trashed.
   end

   remake_diis_lhs(e_i,e_j) ::: get_from(FOCK_DIIS, ERR?=>MAT{REAL}), leaky, private
   ! Rebuild the DIIS left hand side matrix, "lhs", using the error vectors on
   ! disk. The "lhs" matrix is saved to disk. Also, resets the index ".new".
   ! "e_i" and "e_j" are used as workspace; whatever is in them is trashed.
   end

   remake_diis_lhs(e_i,e_j) ::: get_from(FOCK_DIIS, ERR?=>MAT3{REAL}), leaky, private
   ! Rebuild the DIIS left hand side matrix, "lhs", using the error vectors on
   ! disk. The "lhs" matrix is saved to disk. Also, resets the index ".new".
   ! "e_i" and "e_j" are used as workspace; whatever is in them is trashed.
   end

! ============================================================================
! DIIS Fock Extrapolation, DDIIS density interpolation and EDIIS interpolation
! ============================================================================

! Main controller

   accelerate(F,D,S,energy,J)
   ! DIIS acceleration -- includes Pulay DIIS, Cances EDIIS, and Jayatilaka
   ! DDIIS methods.
      F,D :: OPMATRIX*
      S :: MAT{REAL}*
      energy :: VEC{REAL}*
      J :: OPMATRIX*, optional
   ENSURE(.archive.file_name/=" ","no archive name specified")
      .F => F; .D => D; .S => S
      .energy => energy
      if (present(J))   .J => J
      select case (.genre)
         case("fdiis","fock_diis","diis"); .fdiis(F,D,S,energy,J)
         case("ediis","energy_diis");      .ediis(F,D,S,energy,J)
         case("ddiis","density_diis");     .ddiis(D,F,S,energy,J)
         case("ediis+diis");               .ediis_plus_diis(F,D,S,energy,J)
      !  case("ediis+ddiis");              .ediis_plus_ddiis(F,D,S,energy,J)
         case default;                     UNKNOWN (.genre)
      end
   end

   modify_constraint(FF,SS,lambda_step)
   ! Recalculates the Fock matrices saved in the archive so that an extra amount
   ! "lambda_step" of the constraint is added to them. Only the archives of
   ! "genre" are recalculated.
      FF :: OPMATRIX*
      SS :: MAT{REAL}*
      lambda_step :: REAL
   ENSURE(FF.associated,"no Fock matrix")
   ENSURE(FF.has_any_genre,"no Fock matrix")
   ENSURE(SS.associated,"no overlap matrix")
   ENSURE(FF.n_bf==SS.dim1,"Incompatible FF and SS")
   ENSURE(.new>0,"No vector was last saved")
   ENSURE(.new<.dimension,"index of last saved vector exceeds DIIS subspace dimension")
      dimv,i :: INT
      F,C :: OPMATRIX*
      genre :: STR
      .F => FF
      .S => SS
      genre = .F.spinorbital_kind
      dimv = .S.dim1
      C.create(dimv,genre)
      F.create(dimv,genre)
      do i = 1,.kept
    ! stdout.show("updating fock # =",i)
         .read_item(C,"constraint_mx",i)
         .read_item(F,"fock_mx",i)
         F.plus_scaled(C,fac=lambda_step)
         .save_item(F,"fock_mx",i)
         if (i/=.new) cycle
         FF.set_to(F)
      end
      F.destroy; C.destroy
      .remake_diis_lhs(genre)
      .remake_ediis_lhs(genre,modify_rhs=TRUE,lambda_step=lambda_step)
      ! DO this in case the method is "ediis+diis"
      .stage = 0
      .encore = 0
   end

! EDIIS + DIIS, EDIIS + DDIIS

   ediis_plus_diis(F,D,S,energy,J)
   ! Combined EDIIS at the start + DIIS or FDIIS at the end.
      F,D :: OPMATRIX*
      S :: MAT{REAL}*
      energy :: VEC{REAL}*
      J :: OPMATRIX*, optional
   ENSURE(.archive.file_name/=" ","no archive name specified")
      .F => F; .D => D; .S => S
      .energy => energy
      if (present(J))   .J => J
      .set_diis_error_length
      select case (.stage)
         case (0) ! Still doing first EDIIS .....
            if (.error_length>=.start_tolerance) then
               .set_force_convexity(TRUE)
               .ediis(F,D,S,energy,J)                ! Keep doing EDIIS
            else
               .stage = 1                            ! Begin first DIIS
               .set_force_convexity(FALSE)
               .fdiis(F,D,S,energy,J)
            end
         case (1) ! EDIIS has converged, but .....
            if (.error_length>=.start_tolerance) then
               .stage = 2                            ! Must go back to EDIIS
               .encore = 1
               .set_force_convexity(TRUE)
               .ediis(F,D,S,energy,J)                ! Do first encore EDIIS
            else
               .set_force_convexity(FALSE)
               .fdiis(F,D,S,energy,J)                ! Keep doing DIIS
            end
         case (2) ! Keep doing EDIIS until reached the encore level
            if (.encore==.encore_iterations) then
               .encore = 0
               .stage = 1                            ! Go back to DIIS
               .set_force_convexity(FALSE)
               .fdiis(F,D,S,energy,J) 
            else
               .encore = .encore + 1
               .set_force_convexity(TRUE)
               .ediis(F,D,S,energy,J)                ! Keep doing EDIIS
            end
      end
   end

!   ediis_plus_ddiis(F,D,S,energy,J)
!   ! Combined EDIIS at the start + DIIS or FDIIS at the end.
!      F,D :: OPMATRIX*
!      S :: MAT{REAL}*
!      energy :: VEC{REAL}*
!      J :: OPMATRIX*, optional
!   ENSURE(.archive.file_name/=" ","no archive name specified")
!      .F => F; .D => D; .S => S
!      .energy => energy
!      if (present(J))   .J => J
!      .set_diis_error_length
!      select case (.stage)
!         case (0) ! Still doing first EDIIS .....
!            if (.error_length>=.start_tolerance) then
!               .set_force_convexity(TRUE)
!               .ediis(F,D,S,energy,J)                ! Keep doing EDIIS
!            else
!               .stage = 1                            ! Begin first DIIS
!               .set_force_convexity(FALSE)
!               .ddiis(F,D,S,energy,J)
!            end
!         case (1) ! EDIIS has converged, but .....
!            if (.error_length>=.start_tolerance) then
!               .stage = 2                            ! Must go back to EDIIS
!               .encore = 1
!               .set_force_convexity(TRUE)
!               .ediis(F,D,S,energy,J)                ! Do first encore EDIIS
!            else
!               .set_force_convexity(FALSE)
!               .ddiis(F,D,S,energy,J)                ! Keep doing DIIS
!            end
!         case (2) ! Keep doing EDIIS until reached the encore level
!            if (.encore==.encore_iterations) then
!               .encore = 0
!               .stage = 1                            ! Go back to DIIS
!               .set_force_convexity(FALSE)
!               .ddiis(F,D,S,energy,J) 
!            else
!               .encore = .encore + 1
!               .set_force_convexity(TRUE)
!               .ediis(F,D,S,energy,J)                ! Keep doing EDIIS
!            end
!      end
!   end

! Normal Fock DIIS (Pulay)

   fdiis(F,D,S,energy,J)
   ! DIIS extrapolation of the fock matrix ".F". ".D" is the density matrix
   ! which generated ".F". ".S" is the overlap matrix. This assumes that the DIIS
   ! object has been repeatedly called, previously, so that it has all the
   ! previous information on disk. 
      F,D :: OPMATRIX*
      S :: MAT{REAL}*
      energy :: VEC{REAL}*
      J :: OPMATRIX*, optional
      spinorbital_kind :: STR
      .F => F; .D => D; .S => S
      .energy => energy
      if (present(J)) .J => J
      .set_diis_error_length
      spinorbital_kind = F.spinorbital_kind
      select case (spinorbital_kind)
         case("restricted");      .r_fdiis
         case("unrestricted");    .u_fdiis
         case("general_complex"); .gc_fdiis
         case default;         UNKNOWN(spinorbital_kind)
      end
   end

   r_fdiis ::: private
   ! Restricted DIIS extrapolation of the fock matrix ".F". ".D" is the density
   ! matrix which generated ".F". ".S" is the overlap matrix. This assumes that
   ! the DIIS object has been repeatedly called, previously, so that it has all
   ! the previous information on disk. 
   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.F.associated("restricted"),"no Fock matrix")
   ENSURE(.D.associated("restricted"),"no density matrix")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.energy.associated,"no RHF electronic energy")
   ENSURE(.energy.dim==1,"must have 1 RHF energy")
   ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
   ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")
      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*
      dim,old,best :: INT
      e :: REAL

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,diis,restricted" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         C.destroy
         .read_item(e,.e_tag,best)
         .save_item(e,.e_tag,1)
         .remake_r_diis_lhs 
         if (.genre=="ediis+diis") .remake_r_ediis_system
      end

      ! Store fock, density, and energy on disk
      .save_item(.F,.F_tag,.new,genre="restricted") 
      .save_item(.D,.D_tag,.new,genre="restricted")
      .save_item(.energy(1),.e_tag,.new)   


      ! Make EDIIS system and save to disk
      nullify(lhs); nullify(rhs)
      if (.genre=="ediis+diis") then
      .make_r_ediis_system(lhs,rhs)            
      rhs.destroy; lhs.destroy
      end

      ! Make normal DIIS system and save to disk
      .make_r_diis_system(lhs,rhs)             

      ! Update number of items kept on disk
      .update_kept

      ! Now solve the DIIS equations
      if (.solve_equations) then               

         ! Solve here
         coeff.create(dim)
         .solve_r_diis_equations(lhs,rhs,coeff)

         ! Construct the interpolation
         C.create(.F.n_bf,"restricted")
         .F.restricted = 0                           
         do old = 1,dim-1                      
            ! Use "C" as work space for old "F"
            .read_item(C,.F_tag,old)           
            .F.restricted = .F.restricted + coeff(old)*C.restricted
         end
         C.destroy
         coeff.destroy
      end
      rhs.destroy; lhs.destroy
   end

   u_fdiis ::: private
   ! Unrestricted DIIS extrapolation of the fock matrix ".F" using a
   ! concatenation of the alpha and beta parts, with a single set of
   ! coefficients. ".D" is the density matrix which generated ".F". ".S" is the
   ! overlap matrix. This assumes that the DIIS object has been repeatedly
   ! called, previously, so that it has all the previous information on disk. 
   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.J.associated,"no coulomb matrix")
   ENSURE(.F.associated("unrestricted"),"no Fock matrix")
   ENSURE(.D.associated("unrestricted"),"no density matrix")
   ENSURE(.J.associated("unrestricted"),"no coulomb matrix")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.energy.dim==2,"no UHF energies")
   ENSURE(.energy.dim==2,"must have two UHF energies")
   ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
   ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")
      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*
      dim,old,best :: INT
      e :: VEC{REAL}(2)

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,diis,unrestricted" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         .read_item(C,.J_tag,best)
         .save_item(C,.J_tag,1)
         C.destroy
         old = 1
         .read_item(e(1),.e_tag.trim//","//best.to_str.trim//",alpha")
         .save_item(e(1),.e_tag.trim//","// old.to_str.trim//",alpha")
         .read_item(e(2),.e_tag.trim//","//best.to_str.trim//",beta")
         .save_item(e(2),.e_tag.trim//","// old.to_str.trim//",beta")
         .remake_u_diis_lhs 
         if (.genre=="ediis+diis") .remake_u_ediis_system
      end

      ! Store fock, density, J, and energy on disk
      .save_item(.F,.F_tag,.new,genre="unrestricted")
      .save_item(.D,.D_tag,.new,genre="unrestricted")
      .save_item(.J,.J_tag,.new,genre="unrestricted")   
      .save_item(.energy(1),.e_tag.trim//","//.new.to_str.trim//",alpha")
      .save_item(.energy(2),.e_tag.trim//","//.new.to_str.trim//",beta")

      ! Make EDIIS system and save to disk
      nullify(lhs); nullify(rhs)
      if (.genre=="ediis+diis") then
      .make_u_ediis_system(lhs,rhs)            ! Need to make and save to disk
      rhs.destroy; lhs.destroy
      end

      ! Make normal DIIS system and save to disk
      .make_u_diis_system(lhs,rhs) 

      ! Update number of items kept on disk
      .update_kept

      ! Now solve the DIIS equations
      if (.solve_equations) then 

         ! Solve here <<< RESTRICTED
         coeff.create(dim)
         .solve_r_diis_equations(lhs,rhs,coeff)

         ! Construct the interpolation
         C.create(.F.n_bf,"unrestricted")
         .F.alpha = ZERO; .F.beta = ZERO
         do old = 1,dim-1 
             ! Use "C" as work space for old "F"
            .read_item(C,.F_tag,old)
            .F.alpha = .F.alpha + coeff(old)*C.alpha
            .F.beta  = .F.beta  + coeff(old)*C.beta
         end
         C.destroy
         coeff.destroy
      end

      rhs.destroy; lhs.destroy

   end

   u2_fdiis ::: private
   ! Unrestricted DIIS extrapolation of the fock matrix ".F". ".D" is the density
   ! matrix which generated ".F". ".S" is the overlap matrix. This assumes that
   ! the DIIS object has been repeatedly called, previously, so that it has all
   ! the previous information on disk. 
   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.J.associated,"no coulomb matrix")
   ENSURE(.F.associated("unrestricted"),"no Fock matrix")
   ENSURE(.D.associated("unrestricted"),"no density matrix")
   ENSURE(.J.associated("unrestricted"),"no coulomb matrix")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.energy.dim==2,"no UHF energies")
   ENSURE(.energy.dim==2,"must have two UHF energies")
   ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
   ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")
      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff,coeff_a,coeff_b :: VEC{REAL}*
      dim,old,best :: INT
      e :: VEC{REAL}(2)

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,diis,unrestricted" 
      ! WARNING: need to modify .best_item routine if using this
      ! WARNING: need to modify .worst_item routine if using this
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         .read_item(C,.J_tag,best)
         .save_item(C,.J_tag,1)
         C.destroy
         old = 1
         .read_item(e(1),.e_tag.trim//","//best.to_str.trim//",alpha")
         .save_item(e(1),.e_tag.trim//","// old.to_str.trim//",alpha")
         .read_item(e(2),.e_tag.trim//","//best.to_str.trim//",beta")
         .save_item(e(2),.e_tag.trim//","// old.to_str.trim//",beta")
         .remake_u_diis_lhs 
         if (.genre=="ediis+diis") .remake_u_ediis_system
      end

      ! Store fock, density, J, and energy on disk
      .save_item(.F,.F_tag,.new,genre="unrestricted") 
      .save_item(.D,.D_tag,.new,genre="unrestricted")
      .save_item(.J,.J_tag,.new,genre="unrestricted")   
      .save_item(.energy(1),.e_tag.trim//","//.new.to_str.trim//",alpha")
      .save_item(.energy(2),.e_tag.trim//","//.new.to_str.trim//",beta")

      ! Make normal DIIS system and save to disk
      nullify(lhs); nullify(rhs)
      if (.genre=="ediis+diis") then
      .make_u_ediis_system(lhs,rhs) 
      rhs.destroy; lhs.destroy
      end

      ! Make normal DIIS system and save to disk
      .make_u2_diis_system(lhs,rhs) 

      ! Update number of items kept on disk
      .update_kept

      ! Now solve the DIIS equations
      if (.solve_equations) then               

         ! Solve here
         coeff.create(2*dim)
         .solve_u_diis_equations(lhs,rhs,coeff)
         coeff_a => coeff.alpha
         coeff_b => coeff.beta

         ! Construct the interpolation
         C.create(.F.n_bf,"unrestricted")
         .F.alpha = ZERO; .F.beta = ZERO
         do old = 1,dim-1                      ! Construct the interpolation
            .read_item(C,.F_tag,old)           ! Use "C" as work space for old "F"
            .F.alpha = .F.alpha + coeff_a(old)*C.alpha
            .F.beta  = .F.beta  + coeff_b(old)*C.beta
         end
         C.destroy
         coeff.destroy

      end

      rhs.destroy; lhs.destroy

   end

   gc_fdiis ::: private
   ! General complex DIIS extrapolation of the fock matrix ".F". ".D"
   ! is the density matrix which generated ".F". ".S" is the overlap
   ! matrix. This assumes that the DIIS object has been repeatedly
   ! called, previously, so that it has all the previous information
   ! on disk. 

   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.F.associated("general_complex"),"no Fock matrix")
   ENSURE(.D.associated("general_complex"),"no density matrix")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.energy.associated,"no RHF electronic energy")
   ENSURE(.energy.dim==1,"must have 1 RHF energy")
   ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
   ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")

      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*
      dim,old,best :: INT
      e :: REAL

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,diis,general_complex" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         C.destroy
         .read_item(e,.e_tag,best)
         .save_item(e,.e_tag,1)
         .remake_gc_diis_lhs 
       ! if (.genre=="ediis+diis") .remake_r_ediis_system
      end

      ! Store fock, density, and energy on disk
      .save_item(.F,.F_tag,.new,genre="general_complex") 
      .save_item(.D,.D_tag,.new,genre="general_complex")
      .save_item(.energy(1),.e_tag,.new)   


!      ! Make EDIIS system and save to disk
!      nullify(lhs); nullify(rhs)
!      if (.genre=="ediis+diis") then
!      .make_r_ediis_system(lhs,rhs)            
!      rhs.destroy; lhs.destroy
!      end

      ! Make normal DIIS system and save to disk
      .make_gc_diis_system(lhs,rhs)             

      ! Update number of items kept on disk
      .update_kept

      ! Now solve the DIIS equations
      if (.solve_equations) then               

         ! Solve here
         coeff.create(dim)
         .solve_r_diis_equations(lhs,rhs,coeff)

         ! Construct the interpolation
         C.create(.F.n_bf,"general_complex")
         .F.general_complex = 0                           
         do old = 1,dim-1                      
            ! Use "C" as work space for old "F"
            .read_item(C,.F_tag,old)           
            .F.general_complex = .F.general_complex + coeff(old)*C.general_complex
         end
         C.destroy
         coeff.destroy

      end
      rhs.destroy; lhs.destroy

   end

!   gc_fdiis ::: private
!   ! Restricted DIIS extrapolation of the fock matrix ".F". ".D" is the density
!   ! matrix which generated ".F". ".S" is the overlap matrix. This assumes that
!   ! the DIIS object has been repeatedly called, previously, so that it has all
!   ! the previous information on disk. 
!   ENSURE(.archive.file_name/=" ","no archive name specified")
!   ENSURE(.F.associated,"no Fock matrix")
!   ENSURE(.D.associated,"no density matrix")
!   ENSURE(.F.associated("general_complex"),"no Fock matrix")
!   ENSURE(.D.associated("general_complex"),"no density matrix")
!   ENSURE(.S.associated,"no overlap matrix")
!   ENSURE(.energy.associated,"no GCHF electronic energy")
!   ENSURE(.energy.dim==1,"must have 1 GCHF energy")
!   ! LB xxx  ??? how to make this properly
!   ! ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
!   ! ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")
!      C :: OPMATRIX*
!      lhs :: MAT{CPX}*
!      rhs,coeff :: VEC{CPX}*
!   !   rhs,coeff :: VEC{REAL}*
!      dimf,dim,dim2,old,best :: INT
!      e :: REAL
!
!      stdout.flush
!      stdout.text("  IN GC FDIIS  ")
!
! 
!      ! Increment iteration
!      .iteration = .iteration + 1
!
!      ! Proceed only if beyond the .saved_iteration
!      if (.saved_iteration<=0) return
!
!      ! Replace this index in the DIIS system
!      .lhs_tag = "lhs,diis,general_complex" 
!      .new = .next_replacement(best)
!      dim = .dimension
!      dimf = .S.dim1
!      dim2= 2*dimf
!
!      stdout.flush
!      stdout.text("  IN GC FDIIS 2 ")
!      stdout.flush
!      stdout.text(" .S.dim1  ")
!      stdout.put(dimf)
!      stdout.flush
!      stdout.text(" 2*.S.dim1  ")
!      stdout.put(dim2)
! 
!      ! If stuck, replace with the best items and remake LHS
!      if (best/=0) then
!    !     C.create(.F.n_bf,.F.spinorbital_kind)
!         C.create(dim2,.F.spinorbital_kind)
!         .read_item(C,.F_tag,best)
!         .save_item(C,.F_tag,1)
!         .read_item(C,.D_tag,best)
!         .save_item(C,.D_tag,1)
!         C.destroy
!         .read_item(e,.e_tag,best)
!         .save_item(e,.e_tag,1)
!         .remake_gc_diis_lhs 
!      !   if (.genre=="ediis+diis") .remake_r_ediis_system
!      end
!
!      stdout.flush
!      stdout.text("  IN GC FDIIS 3 ")
!      stdout.flush
!      
!      ! Store fock, density, and energy on disk
!      .save_item(.F,.F_tag,.new,genre="general_complex") 
!      .save_item(.D,.D_tag,.new,genre="general_complex")
!      .save_item(.energy(1),.e_tag,.new)   
!
!      stdout.flush
!      stdout.text("  IN GC FDIIS 4 ")
!      stdout.flush
!
!      ! Make EDIIS system and save to disk
!      nullify(lhs); nullify(rhs)
!    ! if (.genre=="ediis+diis") then
!    ! .make_r_ediis_system(lhs,rhs)            
!    ! rhs.destroy; lhs.destroy
!    ! end
!
!      ! Make normal DIIS system and save to disk
!      .make_gc_diis_system(lhs,rhs)             
!
!      stdout.flush
!      stdout.text("  IN GC FDIIS 5")
!      stdout.flush
!
!      ! Update number of items kept on disk
!      .update_kept
!
!      stdout.flush
!      stdout.text("  IN GC FDIIS 6")
!      stdout.flush
!      
!      ! Now solve the DIIS equations
!      if (.solve_equations) then               
!        stdout.flush
!        stdout.text("  IN GC FDIIS 7")
!        stdout.flush
!
!         ! Solve here
!         coeff.create(dim)
!         .solve_gc_diis_equations(lhs,rhs,coeff)
!
!         ! Construct the interpolation
!         C.create(dimf,"general_comlex")
!         .F.general_complex = ZERO                       
!         do old = 1,dim-1                      
!            ! Use "C" as work space for old "F"
!            .read_item(C,.F_tag,old)           
!            .F.general_complex = .F.general_complex + coeff(old)*C.general_complex
!         end
!         C.destroy
!         coeff.destroy
!        stdout.flush
!        stdout.text("  IN GC FDIIS 8")
!        stdout.flush
!
!      ! F make hermitian   
!        .F.general_complex.make_hermitian
!      end
!      rhs.destroy; lhs.destroy
!   end

   make_r_diis_system(lhs,rhs) ::: private, leaky
   ! Make the restricted DIIS left hand side matrix, "lhs", and the right hand
   ! side, "rhs". "dimv" is the dimension of the DIIS vector. We replace only
   ! column/row ".new" in the old DIIS "lhs" matrix. The DIIS "lhs" matrix is
   ! saved to disk and reused next time.
      lhs :: MAT{REAL}*
      rhs :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
   ENSURE(.S.associated,"no overlap matrix")
      F,D,C_new,C_old :: OPMATRIX*
      dim,dimv,old :: INT

      ! Get the saved LHS (leaky)
      .lhs_tag = "lhs,diis,restricted" 
      .get_old_r_lhs(lhs)

      dimv = .S.dim1
      dim = .dimension
      rhs.create(dim); rhs = ZERO
      F.create(dimv,"restricted")
      D.create(dimv,"restricted")
      C_new.create(dimv,"restricted")
      C_old.create(dimv,"restricted")

      ! Make the new error vector
      .make_diis_commutator(C_new,.F,.D,.S)

      ! Calculate the lower triangle of the DIIS matrix
      do old = 1,dim-1              
         .read_item(F,.F_tag,old)
         .read_item(D,.D_tag,old)
         .make_diis_commutator(C_old,F,D,.S)
         ! The column or row .new is the one we are replacing....
         lhs(max(.new,old),min(.new,old)) = -C_new.restricted.dot(C_old.restricted)
         ! The max and min are because we are doing only the lower triangle
         ! We will symmetric reflect later.... 
         lhs(dim,old) = ONE         ! Here we set the auxiliary row on the bottom
      end
      C_old.destroy; C_new.destroy 
      D.destroy; F.destroy

      rhs(dim) = ONE                ! Set the last element
      lhs(dim,dim) = ZERO           ! And here we set the corner
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag)
   end

   make_u_diis_system(lhs,rhs) ::: private, leaky
   ! Make the unrestricted DIIS left hand side matrix, "lhs", and the right hand
   ! side, "rhs". "dimv" is the dimension of the DIIS vector. We replace only
   ! column/row ".new" in the old DIIS "lhs". The DIIS "lhs" matrix is saved to
   ! disk and reused next time.  NOTE: this version uses a concatenation of the
   ! alpha and beta parts.
      lhs :: MAT{REAL}*
      rhs :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
      F,D,C_new,C_old :: OPMATRIX*
      dimv,dim,old :: INT

      ! Get the saved LHS (leaky)
      .lhs_tag = "lhs,diis,unrestricted" 
      .get_old_r_lhs(lhs) ! <<<<<<  Restricted LHS

      dimv = .S.dim1
      dim = .dimension
      rhs.create(dim); rhs = ZERO
      F.create(dimv,"unrestricted")
      D.create(dimv,"unrestricted")
      C_new.create(dimv,"unrestricted")
      C_old.create(dimv,"unrestricted")

      ! Make the new error vector
      .make_diis_commutator(C_new,.F,.D,.S)

      ! Calculate the lower triangle of the DIIS matrix
      do old = 1,dim-1              
         .read_item(F,.F_tag,old)
         .read_item(D,.D_tag,old)
         .make_diis_commutator(C_old,F,D,.S)
         ! The column or row .new is the one we are replacing....
         lhs(max(.new,old),min(.new,old)) = -C_new.alpha.dot(C_old.alpha) ! &
                                          ! -C_new.beta.dot(C_old.beta)
         ! The max and min are because we are doing only the lower triangle
         ! We will symmetric reflect later.... 
         lhs(dim,old) = ONE         ! Here we set the auxiliary row on the bottom
      end
      C_old.destroy; C_new.destroy
      D.destroy; F.destroy

      rhs(dim) = ONE                ! Set the last element
      lhs(dim,dim) = ZERO           ! And here we set the corner
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag)
   end

   make_u2_diis_system(lhs,rhs) ::: private, leaky
   ! Make the unrestricted DIIS left hand side matrix, "lhs", and the right hand
   ! side, "rhs". "dimv" is the dimension of the DIIS vector. We replace only
   ! column/row ".new" in the alpha-alpha and beta-beta part of the old DIIS
   ! "lhs". The DIIS "lhs" matrix is saved to disk and reused next time.
      lhs :: MAT{REAL}*
      rhs :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
      F,D,C_new,C_old :: OPMATRIX*
      lhs_aa,lhs_bb :: MAT{REAL}*
      rhs_a,rhs_b :: VEC{REAL}*
      dimv,dim,old :: INT

      ! Get the saved LHS
      .lhs_tag = "lhs,diis,unrestricted" 
      .get_old_u_lhs(lhs)     ! <<<<<<<< Unrestricted, Leaky here
      lhs_aa => lhs.alpha_alpha
      lhs_bb => lhs.beta_beta

      dimv = .S.dim1
      dim = .dimension
      rhs.create(2*dim); rhs = ZERO
      rhs_a => rhs.alpha
      rhs_b => rhs.beta
      F.create(dimv,"unrestricted")
      D.create(dimv,"unrestricted")
      C_new.create(dimv,"unrestricted")
      C_old.create(dimv,"unrestricted")

      ! Make the new error vector
      .make_diis_commutator(C_new,.F,.D,.S)

      ! Calculate the lower triangle of the DIIS matrix
      do old = 1,dim-1  
         .read_item(F,.F_tag,old)
         .read_item(D,.D_tag,old)
         .make_diis_commutator(C_old,F,D,.S)
         ! The column or row .new is the one we are replacing....
         lhs_aa(max(.new,old),min(.new,old)) = -C_new.alpha.dot(C_old.alpha)
         lhs_bb(max(.new,old),min(.new,old)) = -C_new.beta.dot(C_old.beta)
         ! The max and min are because we are doing only the lower triangle
         ! We will symmetric reflect later.... 
         lhs_aa(dim,old) = ONE      ! Here we set the auxiliary row on the bottom
         lhs_bb(dim,old) = ONE 
      end
      C_old.destroy; C_new.destroy
      D.destroy; F.destroy

      rhs_a(dim) = ONE              ! Set the last element
      rhs_b(dim) = ONE 
      lhs_aa(dim,dim) = ZERO        ! And here we set the corner
      lhs_bb(dim,dim) = ZERO 
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag) 

   end

   make_gc_diis_system(lhs,rhs) ::: private, leaky
   ! Make the general complex DIIS left hand side matrix, "lhs", and
   ! the right hand side, "rhs". "dimv" is the dimension of the DIIS
   ! vector. We replace only column/row ".new" in the old DIIS "lhs"
   ! matrix. The DIIS "lhs" matrix is saved to disk and reused next
   ! time.
      lhs :: MAT{REAL}*
      rhs :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
   ENSURE(.S.associated,"no overlap matrix")
      F,D,C_new,C_old :: OPMATRIX*
      Wr,Wi :: MAT{REAL}*
      dim,dimv,dim2,old :: INT

      ! Get the saved LHS (leaky)
      .lhs_tag = "lhs,diis,general_complex" 
      .get_old_r_lhs(lhs)

      dimv = .S.dim1
      dim = .dimension
      rhs.create(dim); rhs = ZERO
      F.create(dimv,"general_complex")
      D.create(dimv,"general_complex")
      C_new.create(dimv,"general_complex")
      C_old.create(dimv,"general_complex")

      ! Make the new error vector
      .make_diis_commutator(C_new,.F,.D,.S)

      ! Workspace for dot product
      dim2 = 2*dimv
      Wr.create(dim2,dim2)
      Wi.create(dim2,dim2)
      Wr = real(C_new.general_complex)
      Wi = aimag(C_new.general_complex)

      ! Calculate the lower triangle of the DIIS matrix
      do old = 1,dim-1              
         .read_item(F,.F_tag,old)
         .read_item(D,.D_tag,old)
         .make_diis_commutator(C_old,F,D,.S)
         ! The column or row .new is the one we are replacing....
         lhs(max(.new,old),min(.new,old)) = &
            -Wr.dot(real(C_old.general_complex)) &
            -Wi.dot(aimag(C_old.general_complex))
         ! The max and min are because we are doing only the lower triangle
         ! We will symmetric reflect later.... 
         lhs(dim,old) = ONE         ! Here we set the auxiliary row on the bottom
      end
      Wi.destroy; Wr.destroy
      C_old.destroy; C_new.destroy 
      D.destroy; F.destroy

      rhs(dim) = ONE                ! Set the last element
      lhs(dim,dim) = ZERO           ! And here we set the corner
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag)

   end

!   make_gc_diis_system(lhs,rhs) ::: private, leaky
!   ! Make the restricted DIIS left hand side matrix, "lhs", and the right hand
!   ! side, "rhs". "dimv" is the dimension of the DIIS vector. We replace only
!   ! column/row ".new" in the old DIIS "lhs" matrix. The DIIS "lhs" matrix is
!   ! saved to disk and reused next time.
!   !   lhs :: MAT{CPX}*
!   !   rhs :: VEC{CPX}*
!      lhs :: MAT{CPX}*
!      rhs :: VEC{CPX}*
!   ENSURE(lhs.disassociated,"lhs exists")
!   ENSURE(rhs.disassociated,"rhs exists")
!   ENSURE(.S.associated,"no overlap matrix")
!      F,D,C_new,C_old :: OPMATRIX*
!   !   F,D,C_new,C_old :: MAT{CPX}*
!      dim,dim1,dim2,dimv,old :: INT
!      e :: REAL
!
!      ! Get the saved LHS (leaky)
!      .lhs_tag = "lhs,diis,general_complex" 
!      .get_old_gc_lhs(lhs)
!
!      dim1 = .S.dim1
!      dim2 = 2*dim1
!      dim = .dimension
!
!      stdout.text(" .S.dim1  ")
!      stdout.put(dim1)
!      stdout.flush
!      stdout.text(" 2*.S.dim1  ")
!      stdout.put(dim2)
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system ")
!      
!      rhs.create(dim); rhs = ZERO
!      F.create(dim2,"general_complex")
!      D.create(dim2,"general_complex")
!      C_new.create(dim2,"general_complex")
!      C_old.create(dim2,"general_complex")
!
!      ! Make the new error vector
!      .make_diis_commutator(C_new,.F,.D,.S)
!
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system 2")
!      
!      ! Calculate the lower triangle of the DIIS matrix
!      do old = 1,dim-1              
!         .read_item(F,.F_tag,old)
!         .read_item(D,.D_tag,old)
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system 3")
!         .make_diis_commutator(C_old,F,D,.S)
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system 4")
!         ! The column or row .new is the one we are replacing....
!         lhs(max(.new,old),min(.new,old)) = -C_new.general_complex.dot(C_old.general_complex)
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system 5")
!         ! The max and min are because we are doing only the lower triangle
!         ! We will symmetric reflect later.... 
!         lhs(dim,old) = (ONE,ZERO)         ! Here we set the auxiliary row on the bottom
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system 6")
!      end
!      C_old.destroy; C_new.destroy 
!      D.destroy; F.destroy
!
!      rhs(dim) = (ONE,ZERO)                ! Set the last element
!      lhs(dim,dim) = (ZERO,ZERO)           ! And here we set the corner
!      ! Symetric or hermitian reflect ???? :(
!      lhs.hermitian_reflect
!
!      ! Save LHS to disk for next time
!      .save_item(lhs,.lhs_tag)
!      stdout.flush
!      stdout.text("  IN make_gc_diis_system END")
!   end

   remake_diis_lhs(genre)
   ! Remake the DIIS left hand side matrix. The lhs matrix is saved
   ! disk so that it can be reused next time.
      genre :: STR
      select case (genre)
         case ("restricted");   .remake_r_diis_lhs
         case ("unrestricted"); .remake_u_diis_lhs
         case default;          UNKNOWN(genre)
      end
   end

   remake_r_diis_lhs 
   ! Remake the restricted DIIS left hand side matrix. The lhs matrix is saved
   ! disk so that it can be reused next time.
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F_tag/=" ","no fock matrix tag")
   ENSURE(.D_tag/=" ","no density matrix tag")
      lhs :: MAT{REAL}*
      C_i,C_j,F_i,F_j,D_i,D_j :: OPMATRIX*
      dimv,dim,i,j :: INT

      ! Make temporaries
      dimv = .S.dim1
      dim = .kept + 1
      lhs.create(dim,dim)
      F_i.create(dimv,"restricted")
      F_j.create(dimv,"restricted")
      D_i.create(dimv,"restricted")
      D_j.create(dimv,"restricted")
      C_i.create(dimv,"restricted")
      C_j.create(dimv,"restricted")

      ! Remake the LHS
      lhs = ZERO
      do i = 1,dim-1
         .read_item(F_i,.F_tag,i)
         .read_item(D_i,.D_tag,i)
         .make_diis_commutator(C_i,F_i,D_i,.S)
         do j = 1,i
            .read_item(F_j,.F_tag,j)
            .read_item(D_j,.D_tag,j)
            .make_diis_commutator(C_j,F_j,D_j,.S)
            lhs(i,j) = -C_i.restricted.dot(C_j.restricted)
         end
         lhs(dim,i) = ONE
      end
      C_j.destroy; C_i.destroy
      D_j.destroy; D_i.destroy
      F_j.destroy; F_i.destroy

      ! Symmetrize and set corner
      lhs(dim,dim) = ZERO
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .lhs_tag = "lhs,diis,restricted" 
      .save_item(lhs,.lhs_tag) 
      lhs.destroy
   end

   remake_u_diis_lhs
   ! Make the unrestricted DIIS left hand side matrix. The lhs matrix is saved
   ! to disk and reused next time.
   ENSURE(.err_tag/=" ","no error tag specified")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F_tag/=" ","no fock matrix tag")
   ENSURE(.D_tag/=" ","no density matrix tag")
      lhs :: MAT{REAL}*
      C_i,C_j,F_i,F_j,D_i,D_j :: OPMATRIX*
      dimv,dim,i,j :: INT

      ! Make temporaries
      dimv = .S.dim1
      dim = .kept + 1
      lhs.create(dim,dim)
      F_i.create(dimv,"unrestricted")
      F_j.create(dimv,"unrestricted")
      D_i.create(dimv,"unrestricted")
      D_j.create(dimv,"unrestricted")
      C_i.create(dimv,"unrestricted")
      C_j.create(dimv,"unrestricted")

      ! Remake the LHS
      lhs = ZERO
      do i = 1,dim-1
         .read_item(F_i,.F_tag,i)
         .read_item(D_i,.D_tag,i)
         .make_diis_commutator(C_i,F_i,D_i,.S)
         do j = 1,i
            .read_item(F_j,.F_tag,j)
            .read_item(D_j,.D_tag,j)
            .make_diis_commutator(C_j,F_j,D_j,.S)
            lhs(i,j) = -C_i.alpha.dot(C_j.alpha) - C_i.beta.dot(C_j.beta)
         end
         lhs(dim,i) = ONE
      end
      C_j.destroy; C_i.destroy
      D_j.destroy; D_i.destroy
      F_j.destroy; F_i.destroy

      ! Symmetrize and set corner
      lhs(dim,dim) = ZERO 
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .lhs_tag = "lhs,diis,unrestricted"
      .save_item(lhs,.lhs_tag)
      lhs.destroy
   end

   remake_gc_diis_lhs 
   ! Remake the restricted DIIS left hand side matrix. The lhs matrix is saved
   ! disk so that it can be reused next time.
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F_tag/=" ","no fock matrix tag")
   ENSURE(.D_tag/=" ","no density matrix tag")
      lhs :: MAT{CPX}*
      C_i,C_j,F_i,F_j,D_i,D_j :: OPMATRIX*
      dimv,dim,i,j :: INT

      ! Make temporaries
      dimv = .S.dim1
      dim  = .kept + 1
      lhs.create(dim,dim)
      F_i.create(dimv,"general_complex")
      F_j.create(dimv,"general_complex")
      D_i.create(dimv,"general_complex")
      D_j.create(dimv,"general_complex")
      C_i.create(dimv,"general_complex")
      C_j.create(dimv,"general_complex")

      ! Remake the LHS
      lhs = ZERO
      do i = 1,dim-1
         .read_item(F_i,.F_tag,i)
         .read_item(D_i,.D_tag,i)
         .make_diis_commutator(C_i,F_i,D_i,.S)
         do j = 1,i
            .read_item(F_j,.F_tag,j)
            .read_item(D_j,.D_tag,j)
            .make_diis_commutator(C_j,F_j,D_j,.S)
            lhs(i,j) = -C_i.general_complex.dot(C_j.general_complex)
         end
         lhs(dim,i) = ONE
      end
      C_j.destroy; C_i.destroy
      D_j.destroy; D_i.destroy
      F_j.destroy; F_i.destroy

      ! Symmetrize and set corner
      lhs(dim,dim) = ZERO
      lhs.hermitian_reflect

      ! Save LHS to disk for next time
      .lhs_tag = "lhs,diis,general_complex" 
      .save_item(lhs,.lhs_tag) 
      lhs.destroy

   end

! The version below is for non-averaged DIIS

!   remake_u_diis_lhs
!   ! Make the unrestricted DIIS left hand side matrix. The lhs matrix is saved
!   ! to disk and reused next time.
!   ENSURE(.err_tag/=" ","no error tag specified")
!   ENSURE(.S.associated,"no overlap matrix")
!   ENSURE(.F_tag/=" ","no fock matrix tag")
!   ENSURE(.D_tag/=" ","no density matrix tag")
!      lhs :: MAT{REAL}*
!      C_i,C_j,F_i,F_j,D_i,D_j :: OPMATRIX*
!      lhs_aa,lhs_bb :: MAT{REAL}*
!      dimv,dim,i,j :: INT
!
!      ! Make temporaries
!      dimv = .S.dim1
!      dim = .kept + 1
!      lhs.create(2*dim,2*dim)
!      lhs_aa => lhs.alpha_alpha
!      lhs_bb => lhs.beta_beta
!      F_i.create(dimv,"unrestricted")
!      F_j.create(dimv,"unrestricted")
!      D_i.create(dimv,"unrestricted")
!      D_j.create(dimv,"unrestricted")
!      C_i.create(dimv,"unrestricted")
!      C_j.create(dimv,"unrestricted")
!
!      ! Remake the LHS
!      lhs = ZERO
!      do i = 1,dim-1
!         .read_item(F_i,.F_tag,i)
!         .read_item(D_i,.D_tag,i)
!         .make_diis_commutator(C_i,F_i,D_i,.S)
!         do j = 1,i
!            .read_item(F_j,.F_tag,j)
!            .read_item(D_j,.D_tag,j)
!            .make_diis_commutator(C_j,F_j,D_j,.S)
!            lhs_aa(i,j) = -C_i.alpha.dot(C_j.alpha)
!            lhs_bb(i,j) = -C_i.beta.dot(C_j.beta)
!         end
!         lhs_aa(dim,i) = ONE
!         lhs_bb(dim,i) = ONE
!      end
!      C_j.destroy; C_i.destroy
!      D_j.destroy; D_i.destroy
!      F_j.destroy; F_i.destroy
!
!      ! Symmetrize and set corner
!      lhs_aa(dim,dim) = ZERO 
!      lhs_bb(dim,dim) = ZERO 
!      lhs.symmetric_reflect
!
!      ! Save LHS to disk for next time
!      .lhs_tag = "lhs,diis,unrestricted"
!      .save_item(lhs,.lhs_tag)
!      lhs.destroy
!   end

! Energy DIIS (Cances)

   ediis(F,D,S,energy,J)
   ! Energy DIIS interpolation of the fock matrix ".F". ".D" is the density
   ! matrix which generated ".F". ".S" is the overlap matrix. ".energy" are the
   ! SCF energies (only one energy for RHF). "J" are the coulomb matrices,
   ! required only for unrestricted EDIIS.  This assumes that the DIIS object
   ! has been repeatedly called, previously, so that it has all the previous
   ! information on disk. 
      F,D :: OPMATRIX*
      S :: MAT{REAL}*
      energy :: VEC{REAL}*
      J :: OPMATRIX*, optional
      spinorbital_kind :: STR
      .F => F; .D => D; .S => S
      .energy => energy
      if (present(J)) .J => J
      spinorbital_kind = .F.spinorbital_kind
      .set_diis_error_length
      ! These rouines do not use the overlap matrix S
      select case (spinorbital_kind)
         case("restricted");   .r_ediis
         case("unrestricted"); .u_ediis
         case("general_complex"); DIE("general_complex not implemented yet")
         case default;         UNKNOWN(spinorbital_kind)
      end
   end

   r_ediis ::: private
   ! Energy DIIS extrapolation of the fock matrix ".F". ".D" is the density
   ! matrix which generated ".F". ".energy" is the RHF energies. This assumes
   ! that the DIIS object has been repeatedly called, previously, so that it has
   ! all the previous information on disk. 
   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.F.associated("restricted"),"no Fock matrix")
   ENSURE(.D.associated("restricted"),"no density matrix")
   ENSURE(.energy.associated,"no RHF electronic energy")
   ENSURE(.energy.dim==1,"must have 1 RHF energy")
   ENSURE(.F.n_bf==.D.n_bf,"Incompatible F and D")
      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*
      dim,old,best :: INT 
      e,emin :: REAL

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,ediis,restricted" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         C.destroy
         .read_item(e,.e_tag,best)
         .save_item(e,.e_tag,1)
         .remake_r_ediis_system
         if (.genre=="ediis+diis") .remake_r_diis_lhs 
      end

      ! Store fock, density, and energy on disk
      .save_item(.D,.D_tag,.new,genre="restricted") ! Store on disk
      .save_item(.F,.F_tag,.new,genre="restricted")   
      .save_item(.energy(1),.e_tag,.new)   

      ! Make EDIIS system and save to disk
      nullify(lhs); nullify(rhs)
      if (.genre=="ediis+diis") then
      .make_r_diis_system(lhs,rhs)
      rhs.destroy; lhs.destroy
      end

      ! Make EDIIS system and save to disk
      .make_r_ediis_system(lhs,rhs)

      ! Update number of items kept on disk
      .update_kept

      ! Now solve the DIIS equations
      if (.solve_equations) then

         ! Solve here
         coeff.create(dim)
         .solve_r_diis_equations(lhs,rhs,coeff,emin)

         ! Construct the interpolation
         C.create(.F.n_bf,"restricted")
         .F.restricted = 0                           
         do old = 1,dim-1 
            ! Use "C" as work space for old "F"
            .read_item(C,.F_tag,old)
            .F.restricted = .F.restricted + coeff(old)*C.restricted
         end
         C.destroy
         coeff.destroy
      end
      lhs.destroy; rhs.destroy
   end

   u_ediis ::: private
   ! Unrestricted energy DIIS extrapolation of the fock matrix ".F". ".D" is the
   ! density matrix which generated ".F". ".energy" are the UHF energies. "J"
   ! are the coulomb matrices, required only for unrestricted EDIIS.  This
   ! assumes that the DIIS object has been repeatedly called, previously, so
   ! that it has all the previous information on disk. 
   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.J.associated,"no coulomb matrix")
   ENSURE(.F.associated("unrestricted"),"no Fock matrix")
   ENSURE(.D.associated("unrestricted"),"no density matrix")
   ENSURE(.J.associated("unrestricted"),"no coulomb matrix")
   ENSURE(.energy.dim==2,"no UHF energies")
   ENSURE(.energy.dim==2,"must have two UHF energies")
   ENSURE(.F.n_bf==.D.n_bf,"Incompatible F and D")
   ENSURE(.J.n_bf==.D.n_bf,"Incompatible J and D")
      C :: OPMATRIX*
      lhs, lhs_aa,lhs_bb,lhs_ba,lhs_ab :: MAT{REAL}*
      rhs,coeff,coeff_a,coeff_b, rhs_a,rhs_b :: VEC{REAL}*
      dim,old,best :: INT
      compress :: BIN
      e :: VEC{REAL}(2)

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,ediis,unrestricted" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         .read_item(C,.J_tag,best)
         .save_item(C,.J_tag,1)
         C.destroy
         old = 1
         .read_item(e(1),.e_tag.trim//","//best.to_str.trim//",alpha")
         .save_item(e(1),.e_tag.trim//","// old.to_str.trim//",alpha")
         .read_item(e(2),.e_tag.trim//","//best.to_str.trim//",beta")
         .save_item(e(2),.e_tag.trim//","// old.to_str.trim//",beta")
         .remake_u_ediis_system
         if (.genre=="ediis+diis") .remake_u_diis_lhs 
      end

      ! Store fock, density, J, and energy on disk
      .save_item(.D,.D_tag,.new,genre="unrestricted") 
      .save_item(.F,.F_tag,.new,genre="unrestricted")   
      .save_item(.J,.J_tag,.new,genre="unrestricted")   
      .save_item(.energy(1),.e_tag.trim//","//.new.to_str.trim//",alpha")
      .save_item(.energy(2),.e_tag.trim//","//.new.to_str.trim//",beta")

      ! Make EDIIS system and save to disk
      nullify(lhs); nullify(rhs)
      if (.genre=="ediis+diis") then
    ! .make_u2_diis_system(lhs,rhs)
      .make_u_diis_system(lhs,rhs)
      rhs.destroy; lhs.destroy
      end

      ! Make EDIIS system and save to disk
      .make_u_ediis_system(lhs,rhs)            ! Need to make and save to disk

      ! Update number of items kept on disk
      .update_kept

      ! Now solve the DIIS equations
      if (.solve_equations) then  

         compress = FALSE

         ! Normal solution
         if (NOT compress) then

            ! Solve here
            coeff.create(2*dim)
            .solve_u_diis_equations(lhs,rhs,coeff)

            ! Construct the interpolation
            coeff_a => coeff.alpha
            coeff_b => coeff.beta
            C.create(.F.n_bf,"unrestricted")
            .F.alpha = ZERO; .F.beta = ZERO
            do old = 1,dim-1                      
               ! Use "C" as work space for old "F"
               .read_item(C,.F_tag,old)           
               .F.alpha = .F.alpha + coeff_a(old)*C.alpha
               .F.beta  = .F.beta  + coeff_b(old)*C.beta
            end
            C.destroy
            coeff.destroy

         ! Semi-restricted solution
         else
            ! compress the alpha-beta sectors
            lhs_aa => lhs.alpha_alpha  
            lhs_bb => lhs.beta_beta
            lhs_ab => lhs.alpha_beta
            lhs_ba => lhs.beta_alpha
            lhs_aa = lhs_aa + lhs_bb + lhs_ba + lhs_ab
            lhs_aa(:,dim) = lhs_bb(:,dim)
            lhs_aa(dim,:) = lhs_bb(dim,:)
            rhs_a => rhs.alpha
            rhs_b => rhs.beta
            rhs_a = rhs_a + rhs_b
            rhs_a(dim) = rhs_b(dim)
            lhs.shrink(dim,dim)  
            rhs.shrink(dim)

            ! Solve as a restricted problem
            coeff.create(dim)                     
            .solve_r_diis_equations(lhs,rhs,coeff)

            ! Construct the interpolation
            C.create(.F.n_bf,"unrestricted")
            .F.alpha = 0; .F.beta = 0                           
            do old = 1,dim-1 
               .read_item(C,.F_tag,old) 
               ! Use "C" as work space for old "F"
               .F.alpha = .F.alpha + coeff(old)*C.alpha
               .F.beta  = .F.beta  + coeff(old)*C.beta
            end
            C.destroy
            coeff.destroy
         end
      end
      lhs.destroy; rhs.destroy
   end

   make_r_ediis_system(lhs,rhs) ::: private, leaky
   ! Make the current restricted EDIIS left hand side matrix, "lhs", and the
   ! right hand side, "rhs". ".F" and ".D" are the current Fock and Density
   ! matrices, respectively. They are used to replace column/row ".new" in the
   ! EDIIS equations. The EDIIS "lhs" matrix is saved to disk. See reference
   ! Kudin, Scuseria, Cances (2002) JCP 116, p. 8255
      lhs :: MAT{REAL}*
      rhs :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
      F_old,D_old :: OPMATRIX*
      dimv,dim,old :: INT

      ! Get the saved LHS & RHS (leaky)
      ! For RHS, just get the energies, and put 1
      .lhs_tag = "lhs,ediis,restricted" 
      .get_old_r_lhs(lhs)
      .get_old_r_rhs(rhs) 

      dim = .dimension
      dimv = .F.n_bf
      F_old.create(dimv,"restricted")
      D_old.create(dimv,"restricted")

      ! Calculate the lower triangle of the DIIS matrix
      do old = 1,dim-1               
         .read_item(F_old,.F_tag,old)
         .read_item(D_old,.D_tag,old)
         F_old.restricted = .F.restricted - F_old.restricted
         D_old.restricted = .D.restricted - D_old.restricted
         ! The column or row .new is the one we are replacing....
         lhs(max(.new,old),min(.new,old)) = F_old.restricted.dot(D_old.restricted)
         ! The max and min are because we are doing only the lower triangle
         ! We will symmetric reflect later.... 
         lhs(dim,old) = ONE         ! Here we set the auxiliary row on the bottom
      end
      D_old.destroy; F_old.destroy

      ! Set corners and ends and symmetrise
      rhs(dim) = ONE            
      lhs(dim,dim) = ZERO      
      lhs.symmetric_reflect
   
      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag)
   end

   make_u_ediis_system(lhs,rhs) ::: private, leaky
   ! Make the unrestricted EDIIS left hand side matrix, "lhs", and the right
   ! hand side, "rhs". "F", "J" and "D" are the current Fock, Coulomb and
   ! Density matrices, respectively. They are used to replace column/row ".new"
   ! in the EDIIS equations. The EDIIS "lhs" matrix is saved to disk. See
   ! reference Kudin, Scuseria, Cances (2002) JCP 116, p. 8255
      lhs :: MAT{REAL}*
      rhs :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
      F_old,J_old,D_old :: OPMATRIX*
      lhs_aa,lhs_bb,lhs_ba :: MAT{REAL}*
      rhs_a,rhs_b :: VEC{REAL}*
      dimv,dim,old,i,j :: INT

      ! Get the saved LHS & RHS (leaky)
      .lhs_tag = "lhs,ediis,unrestricted"  
      .get_old_u_lhs(lhs)
      lhs = TWO*lhs                  ! Double ... later halve it
      lhs_aa => lhs.alpha_alpha
      lhs_bb => lhs.beta_beta
      lhs_ba => lhs.beta_alpha
      .get_old_u_rhs(rhs)            ! Just get energies, and add some 1's
      rhs_a => rhs.alpha
      rhs_b => rhs.beta

      dim = .dimension
      dimv = .F.n_bf
      F_old.create(dimv,"unrestricted")
      J_old.create(dimv,"unrestricted")
      D_old.create(dimv,"unrestricted")

      ! Calculate the DIIS matrix
      do old = 1,dim-1               
         .read_item(F_old,.F_tag,old) 
         .read_item(J_old,.J_tag,old) ! Read in the "old" matrices
         .read_item(D_old,.D_tag,old)
         J_old.alpha = .J.alpha - J_old.alpha
         J_old.beta  = .J.beta  - J_old.beta
         ! The column or row .new is the one we are replacing....
         i = .new          
         j =  old          ! beta-alpha block
         lhs_ba(i,j) =    .D.beta.dot(J_old.alpha) &
                     - D_old.alpha.dot(J_old.beta)
         i =  old          
         j = .new          ! beta-alpha block
         lhs_ba(i,j) =    .D.alpha.dot(J_old.beta) &
                     - D_old.beta.dot(J_old.alpha)
         ! Max and min are for lower triangle
         i = max(.new,old)
         j = min(.new,old) ! alpha-alpha & beta-beta block
         F_old.alpha = .F.alpha - F_old.alpha - J_old.beta
         F_old.beta  = .F.beta -  F_old.beta  - J_old.alpha
         D_old.alpha = .D.alpha - D_old.alpha
         D_old.beta  = .D.beta -  D_old.beta
         lhs_aa(i,j) = D_old.alpha.dot(F_old.alpha) 
         lhs_bb(i,j) = D_old.beta.dot(F_old.beta) 
         ! Here we set the auxiliary row on the bottom
         lhs_aa(dim,old) = TWO
         lhs_bb(dim,old) = TWO
      end

      lhs = HALF*lhs ! Halve

      D_old.destroy; J_old.destroy; F_old.destroy

      ! Set corners and ends and symmetrise
      rhs_a(dim) = ONE     
      rhs_b(dim) = ONE    
      lhs_aa(dim,dim) = ZERO   
      lhs_bb(dim,dim) = ZERO  
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag) 
   end

   remake_ediis_lhs(genre,modify_rhs,lambda_step)
   ! Remake the EDIIS left hand side matrix and rhigh hand side energies. The
   ! lhs matrix and energies is saved disk so that it can be reused next time.
      genre :: STR
      modify_rhs :: BIN, optional
      lambda_step :: REAL, optional
      select case (genre)
         case ("restricted");   .remake_r_ediis_system(modify_rhs,lambda_step)
         case ("unrestricted"); .remake_r_ediis_system(modify_rhs,lambda_step)
         case default;          UNKNOWN(genre)
      end
   end

   remake_r_ediis_system(modify_rhs,lambda_step) ::: private
   ! Remake the current *restricted* EDIIS left hand side matrix, "lhs" and
   ! save it to disk. See reference Kudin, Scuseria, Cances (2002) JCP 116, p.
   ! 8255
      modify_rhs :: BIN, optional
      lambda_step :: REAL, optional
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F_tag/=" ","no F_tag specified")
   ENSURE(.D_tag/=" ","no D_tag specified")
   ENSURE(.e_tag/=" ","e_tag is not specified")
      lhs :: MAT{REAL}*
      F_i,F_j,D_i,D_j :: OPMATRIX*
      dimv,dim,i,j :: INT
      modify :: BIN
      e :: REAL

      modify = FALSE
      if (present(modify_rhs)) then
         ENSURE(present(lambda_step),"lambda_step must be present")
         modify = modify_rhs
      end

      ! Make temporaries
      dimv = .S.dim1
      dim = .kept + 1
      lhs.create(dim,dim)
      F_i.create(dimv,"restricted")
      F_j.create(dimv,"restricted")
      D_i.create(dimv,"restricted")
      D_j.create(dimv,"restricted")

      ! Remake the LHS
      lhs = ZERO
      do i = 1,dim-1
         .read_item(F_i,.F_tag,i)
         .read_item(D_i,.D_tag,i)
         do j = 1,i
            .read_item(F_j,.F_tag,j)
            .read_item(D_j,.D_tag,j)
            F_j.restricted = F_i.restricted - F_j.restricted
            D_j.restricted = D_i.restricted - D_j.restricted
            lhs(i,j) = F_j.restricted.dot(D_j.restricted)
         end
         lhs(dim,i) = TWO
         ! Rhs ...
         if (NOT modify) cycle
         .read_item(e,.e_tag,i)
         .read_item(F_i,"constraint_mx",i)
         e = e + HALF*lambda_step*F_i.restricted.dot(D_i.restricted)
         .save_item(e,.e_tag,i)
      end
      D_j.destroy; D_i.destroy
      F_j.destroy; F_i.destroy

      lhs = HALF*lhs

      ! Symmetrize and set corner
      lhs(dim,dim) = ZERO       
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .lhs_tag = "lhs,ediis,restricted" 
      .save_item(lhs,.lhs_tag)   
      lhs.destroy
   end

   remake_u_ediis_system(modify_rhs,lambda_step) ::: private
   ! Remake the current *unrestricted* EDIIS left hand side matrix, "lhs" and
   ! save it to disk. See reference Kudin, Scuseria, Cances (2002) JCP 116, p.
   ! 8255
      modify_rhs :: BIN, optional
      lambda_step :: REAL, optional
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F_tag/=" ","no F_tag specified")
   ENSURE(.D_tag/=" ","no D_tag specified")
   ENSURE(.e_tag/=" ","e_tag is not specified")
      lhs,lhs_aa,lhs_bb,lhs_ba :: MAT{REAL}*
      F_i,F_j,J_i,J_j,D_i,D_j :: OPMATRIX*
      dimv,dim,i,j :: INT
      e_a,e_b :: REAL
      modify :: BIN

      modify = FALSE
      if (present(modify_rhs)) then
         ENSURE(present(lambda_step),"lambda_step must be present")
         modify = modify_rhs
      end

      ! Make temporaries
      dimv = .S.dim1
      dim = .kept + 1
      lhs.create(2*dim,2*dim)
      lhs = ZERO
      lhs_aa => lhs.alpha_alpha
      lhs_bb => lhs.beta_beta
      lhs_ba => lhs.beta_alpha
      F_i.create(dimv,"unrestricted"); F_j.create(dimv,"unrestricted")
      D_i.create(dimv,"unrestricted"); D_j.create(dimv,"unrestricted")
      J_i.create(dimv,"unrestricted"); J_j.create(dimv,"unrestricted")

      ! Remake the LHS
      do i = 1,dim-1
         .read_item(F_i,.F_tag,i)
         .read_item(J_i,.J_tag,i)
         .read_item(D_i,.D_tag,i)
         do j = 1,dim-1
            .read_item(F_j,.F_tag,j) 
            .read_item(J_j,.J_tag,j) ! Read in the "j" matrices
            .read_item(D_j,.D_tag,j)
            J_j.alpha = J_i.alpha - J_j.alpha
            J_j.beta  = J_i.beta  - J_j.beta
            lhs_ba(i,j) = D_j.beta.dot(J_j.alpha) - D_j.alpha.dot(J_j.beta)
            if (j>i) cycle
            F_j.alpha = F_i.alpha - F_j.alpha - J_j.beta
            F_j.beta  = F_i.beta -  F_j.beta  - J_j.alpha
            D_j.alpha = D_i.alpha - D_j.alpha
            D_j.beta  = D_i.beta -  D_j.beta
            lhs_aa(i,j) = D_j.alpha.dot(F_j.alpha) 
            lhs_bb(i,j) = D_j.beta.dot(F_j.beta) 
         end
         ! Here we set the auxiliary row on the bottom
         lhs_aa(dim,i) = TWO
         lhs_bb(dim,i) = TWO
         ! Rhs ...
         if (NOT modify) cycle
         .read_item(e_a,.e_tag.trim//","//i.to_str.trim//",alpha")
         .read_item(e_b,.e_tag.trim//","//i.to_str.trim//",beta")
         .read_item(F_i,"constraint_mx",i)
         e_a = e_a + HALF*lambda_step*F_i.alpha.dot(D_i.alpha)
         e_b = e_b + HALF*lambda_step*F_i.beta.dot(D_i.beta)
         .save_item(e_a,.e_tag.trim//","//i.to_str.trim//",alpha")
         .save_item(e_b,.e_tag.trim//","//i.to_str.trim//",beta")
      end
      J_j.destroy; J_i.destroy
      D_j.destroy; D_i.destroy
      F_j.destroy; F_i.destroy

      lhs = HALF*lhs

      ! Symmetrize and set corner
      lhs.symmetric_reflect
      .lhs_tag = "lhs,ediis,unrestricted" 

      ! Save LHS to disk for next time
      .save_item(lhs,.lhs_tag) 
      lhs.destroy
   end

! Density DIIS (Jayatilaka)

   ddiis(D,F,S,energy,J)
   ! Density DIIS extrapolation of the fock matrix ".F". ".D" is the density matrix
   ! which generated ".F". Even though this technique is based on a density
   ! matrix extrapolation, only ".F" is updated. This assumes that the DIIS
   ! object has been repeatedly called, previously, so that it has all the
   ! previous information on disk. 
      D,F :: OPMATRIX*
      S :: MAT{REAL}*
      energy :: VEC{REAL}*
      J :: OPMATRIX*, optional
      spinorbital_kind :: STR
      .D => D; .F => F; .S => S
      .energy => energy
      if (present(J)) .J => J
      spinorbital_kind = .F.spinorbital_kind
      .set_diis_error_length
      select case (spinorbital_kind)
         case("restricted");   .r_ddiis
         case("unrestricted"); .u_ddiis
         case("general_complex"); DIE("general_complex not implemented yet")
         case default;         UNKNOWN(spinorbital_kind)
      end
   end

   r_ddiis ::: private
   ! Restricted Density DIIS extrapolation of the fock matrix ".F". ".D" is the
   ! density matrix which generated ".F". Even though this technique is based on
   ! a density matrix extrapolation, in the end only ".F" is updated. This
   ! assumes that the DIIS object has been repeatedly called, previously, so
   ! that it has all the previous information on disk. 
      self :: target

   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.F.associated("restricted"),"no Fock matrix")
   ENSURE(.D.associated("restricted"),"no density matrix")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
   ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")

      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff,old_coeff :: VEC{REAL}*
      dim,old,iter,best :: INT
      length,tol,e :: REAL

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,diis,restricted" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         C.destroy
         .read_item(e,.e_tag,best)
         .save_item(e,.e_tag,1)
         .remake_r_diis_lhs 
      end

      ! Store fock, density, and energy on disk
      .save_item(.D,.D_tag,.new,genre="restricted")
      .save_item(.F,.F_tag,.new,genre="restricted")   
      .save_item(.energy(1),.e_tag,.new)   

      ! Make normal DIIS system and save to disk
      nullify(lhs); nullify(rhs)
      .make_r_diis_system(lhs,rhs)
    ! .update_kept

      coeff.create(dim)

      ! Set up micro-iteration starting guess
      if      (.micro_starting_guess=="last_density") then
         coeff = ZERO
         coeff(.new) = ONE
         coeff(dim+.new) = ONE
      else if (.micro_starting_guess=="diis") then
         .solve_r_diis_equations(lhs,rhs,coeff)
      end
      rhs.destroy; lhs.destroy

      ! Now solve the DIIS equations
      if (.solve_equations) then 

         ! BFGS method for micro-iterations
         if      (.micro_iteration_method=="bfgs") then
            tol = .micro_convergence_tol
            saved_self => self
            VEC{REAL}:minimize_BFGS_v2(FOCK_DIIS::r_ddiis_length,coeff(1:dim-2),length, &
               tol,tol,step=TOL(2),max_it=.micro_max_iterations)
            nullify(saved_self)
            coeff(dim-1) = ONE - VEC{REAL}:sum_elements(coeff(1:dim-2))
            .update_kept

         ! Linearisation method for micro-iterations
         else if (.micro_iteration_method=="linearisation") then
            .update_kept
            old_coeff.create(dim)
            iter = 0
            do
               iter = iter + 1
               old_coeff = coeff
               .make_r_ddiis_system(lhs,rhs,coeff)
               .solve_r_diis_equations(lhs,rhs,coeff)
               lhs.destroy; rhs.destroy
               coeff = .micro_damp_factor*old_coeff + (ONE-.micro_damp_factor)*coeff
               DIE_IF(iter>.micro_max_iterations,"too many DDIIS iterations") 
               if (coeff.same_as(old_coeff,eps=.micro_convergence_tol)) exit
            end
            old_coeff.destroy
         end

         ! Construct the interpolation
         C.create(.F.n_bf,"restricted")
         .F.restricted = 0                           
         do old = 1,dim-1  
             ! Use "C" as work space for old "F"
            .read_item(C,.F_tag,old) 
            .F.restricted = .F.restricted + coeff(old)*C.restricted
         end
         C.destroy
      end
      coeff.destroy
   end

   u_ddiis ::: private
   ! Unrestricted Density DIIS extrapolation of the fock matrix ".F". ".D" is
   ! the density matrix which generated ".F". Even though this technique is
   ! based on a density matrix extrapolation, in the end only ".F" is updated.
   ! This assumes that the DIIS object has been repeatedly called, previously,
   ! so that it has all the previous information on disk. 
      self :: target
   ENSURE(.archive.file_name/=" ","no archive name specified")
   ENSURE(.F.associated,"no Fock matrix")
   ENSURE(.D.associated,"no density matrix")
   ENSURE(.J.associated,"no coulomb matrix")
   ENSURE(.F.associated("unrestricted"),"no Fock matrix")
   ENSURE(.D.associated("unrestricted"),"no density matrix")
   ENSURE(.J.associated("unrestricted"),"no coulomb matrix")
   ENSURE(.S.associated,"no overlap matrix")
   ENSURE(.F.n_bf==.S.dim1,"Incompatible F and S")
   ENSURE(.D.n_bf==.S.dim1,"Incompatible D and S")
   ENSURE(.J.n_bf==.S.dim1,"Incompatible D and S")
      C :: OPMATRIX*
      lhs :: MAT{REAL}*
      rhs,coeff,coeff1,old_coeff,coeff_a,coeff_b,c1a,c1b :: VEC{REAL}*
      length,tol :: REAL
      dim,old,iter,best :: INT
      e :: VEC{REAL}(2)

      ! Increment iteration
      .iteration = .iteration + 1

      ! Proceed only if beyond the .saved_iteration
      if (.saved_iteration<=0) return

      ! Replace this index in the DIIS system
      .lhs_tag = "lhs,diis,unrestricted" 
      .new = .next_replacement(best)
      dim = .dimension

      ! If stuck, replace with the best items and remake LHS
      if (best/=0) then
         C.create(.F.n_bf,.F.spinorbital_kind)
         .read_item(C,.F_tag,best)
         .save_item(C,.F_tag,1)
         .read_item(C,.D_tag,best)
         .save_item(C,.D_tag,1)
         .read_item(C,.J_tag,best)
         .save_item(C,.J_tag,1)
         C.destroy
         old = 1
         .read_item(e(1),.e_tag.trim//","//best.to_str.trim//",alpha")
         .save_item(e(1),.e_tag.trim//","// old.to_str.trim//",alpha")
         .read_item(e(2),.e_tag.trim//","//best.to_str.trim//",beta")
         .save_item(e(2),.e_tag.trim//","// old.to_str.trim//",beta")
         .remake_u_diis_lhs 
      end

      ! Store fock, density, J, and energy on disk
      .save_item(.D,.D_tag,.new,genre="unrestricted") ! Store on disk
      .save_item(.F,.F_tag,.new,genre="unrestricted")   
      .save_item(.J,.J_tag,.new,genre="unrestricted")   
      .save_item(.energy(1),.e_tag.trim//","//.new.to_str.trim//",alpha")
      .save_item(.energy(2),.e_tag.trim//","//.new.to_str.trim//",beta")

      coeff.create(2*dim)

      ! Make DIIS system and save to disk
      nullify(lhs); nullify(rhs)
      .make_u_diis_system(lhs,rhs)  
    ! .update_kept

      ! Set up micro-iteration starting guess
      if      (.micro_starting_guess=="last") then
         coeff = ZERO
         coeff(.new) = ONE
         coeff(dim+.new) = ONE
      else if (.micro_starting_guess=="diis") then
         .solve_r_diis_equations(lhs,rhs,coeff(1:dim))
         coeff(dim+1:) = coeff(1:dim)
         rhs.destroy; lhs.destroy
      end
      rhs.destroy; lhs.destroy
      coeff_a => coeff.alpha
      coeff_b => coeff.beta

      ! Now solve the DIIS equations
      if (.solve_equations) then    

         ! BFGS method for the micor-iterations
         if      (.micro_iteration_method=="bfgs") then
            tol = .micro_convergence_tol
            saved_self => self
            coeff1.create(2*(dim-2)) 
            c1a => coeff1.alpha
            c1b => coeff1.beta
            c1a = coeff_a(1:dim-2) 
            c1b = coeff_b(1:dim-2) 
            VEC{REAL}:minimize_BFGS_v2(FOCK_DIIS::u_ddiis_length,coeff1,length, &
               tol,tol,step=TOL(2),max_it=.micro_max_iterations)
            nullify(saved_self)
            coeff_a(1:dim-2) = c1a
            coeff_b(1:dim-2) = c1b
            coeff_a(dim-1) = ONE - VEC{REAL}:sum_elements(c1a)
            coeff_b(dim-1) = ONE - VEC{REAL}:sum_elements(c1b)
            coeff1.destroy
            .update_kept

         ! Linearisation method for the micor-iterations
         else if (.micro_iteration_method=="linearisation") then
            .update_kept
            old_coeff.create(2*dim)
            iter = 0
            do
               iter = iter + 1
               old_coeff = coeff
               .make_u_ddiis_system(lhs,rhs,coeff)
               .solve_u_diis_equations(lhs,rhs,coeff)
               lhs.destroy; rhs.destroy
               coeff = .micro_damp_factor*old_coeff + (ONE-.micro_damp_factor)*coeff
               DIE_IF(iter>.micro_max_iterations,"too many DDIIS iterations") 
               if (coeff.same_as(old_coeff,eps=.micro_convergence_tol)) exit
            end
            old_coeff.destroy
         end

         ! Construct the interpolation
         C.create(.F.n_bf,"unrestricted")
         .F.alpha = ZERO; .F.beta = ZERO
         do old = 1,dim-1   
             ! Use "C" as work space for old "F"
            .read_item(C,.F_tag,old) 
            .F.alpha = .F.alpha + coeff_a(old)*C.alpha
            .F.beta  = .F.beta  + coeff_b(old)*C.beta
         end
         C.destroy
      end
      coeff.destroy
   end

   make_r_ddiis_system(lhs,rhs,coeff) ::: private, leaky
   ! Make the current restricted DDIIS left hand side matrix, "lhs", and the
   ! right hand side, "rhs". "coeff" are the previous list of expansion
   ! coefficients obtained from solving the linearised DDIIS equations. 
   ! This routine makes only *one* version of the "lhs" which depends on the
   ! "coeff" solution.  Every DDIIS "lhs" matrix is saved to disk but it is NOT
   ! reused.
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
   ENSURE(coeff.associated,"no coeff's supplied")
      F,D :: OPMATRIX*
      e1 :: MAT3{REAL}*
      C :: MAT{REAL}*
      dim,dimv,i,j :: INT

      ! Make temporaries
      dim = .dimension
      dimv = .S.dim1
      e1.create(dimv,dimv,dim-1) ! This is a lot of storage !
      e1 = ZERO
      C.create(dimv,dimv)
      F.create(dimv,"restricted")
      D.create(dimv,"restricted")

      ! First make the e1 intermediate if it has not already been made
      dim = .kept + 1
      do i = 1,dim-1     ! Make e1 from the start
         .read_item(F,.F_tag,i)
         do j = 1,dim-1       
            .read_item(D,.D_tag,j)
            .make_diis_commutator(C,F.restricted,D.restricted,.S)
            e1(:,:,i).plus_scaled(C,HALF*coeff(j))
            e1(:,:,j).plus_scaled(C,HALF*coeff(i))
         end
      end
      D.destroy; F.destroy; C.destroy

      ! Now reconstruct the "rhs" and "lhs" ...
      rhs.create(dim); rhs = ZERO
      lhs.create(dim,dim); lhs = ZERO
      do i = 1,dim-1
         do j = 1,i
            lhs(i,j) = -e1(:,:,i).dot(e1(:,:,j))
         end
         lhs(dim,i) = ONE   ! Here we set the auxiliary row on the bottom
      end
      e1.destroy

      ! Symmetrize and set ends and corners
      rhs(dim) = ONE        
      lhs(dim,dim) = ZERO
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .lhs_tag = "lhs,ddiis,restricted" 
      .save_item(lhs,.lhs_tag) 
   end

   make_u_ddiis_system(lhs,rhs,coeff) ::: private, leaky
   ! Make the current unrestricted DDIIS left hand side matrix, "lhs", and the
   ! right hand side, "rhs". "coeff" are the previous list of expansion
   ! coefficients obtained from solving the linearised DDIIS equations. "S" is
   ! the overlap matrix which must be consistent with the Fock and Density
   ! matrices stored on disk. "e1" is the intermediate required to reconstruct
   ! the "lhs" from scratch. This routine makes only *one* version of the "lhs"
   ! which depends on the "coeff" solution.  Every DDIIS "lhs" matrix is saved
   ! to disk but it is NOT reused.
      lhs :: MAT{REAL}*
      rhs,coeff :: VEC{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(rhs.disassociated,"rhs exists")
   ENSURE(coeff.associated,"no rhs supplied")
      F,G,D :: OPMATRIX*
      dim,dimv,i,j,aj,bj,ai,bi :: INT
      C,Wa,Wb,lhs_aa,lhs_bb,lhs_ab,lhs_ba :: MAT{REAL}*
      rhs_a,rhs_b :: VEC{REAL}*
      e1 :: MAT3{REAL}*

      ! Make temporaries
      dim = .kept + 1
      dimv = .S.dim1
      e1.create(dimv,dimv,2*dim-1) ! This is a lot of storage !
      e1 = ZERO
      F.create(dimv,"unrestricted")
      G.create(dimv,"unrestricted")
      D.create(dimv,"unrestricted")
      C.create(dimv,dimv)
      Wa.create(dimv,dimv); Wb.create(dimv,dimv)

      ! First make the e1 intermediate if it has not already been made
      ! Make e1 from the start
      do i = 1,dim-1     
         ai = i
         bi = i + dim
         .read_item(F,.F_tag,i)
         .read_item(G,.J_tag,i)
         Wa = F.alpha - G.beta
         Wb = F.beta  - G.alpha
         do j = 1,dim-1
            aj = j
            bj = j + dim
            .read_item(D,.D_tag,j)
            .make_diis_commutator(C,Wa,D.alpha,.S)
            e1(:,:,aj).plus_scaled(C,coeff(ai))
            .make_diis_commutator(C,Wb,D.beta,.S)
            e1(:,:,bj).plus_scaled(C,coeff(bi))
            ! This sums e2 on the first index, giving decoupled equations
            ! (The e1.e1 equations are summed over sigma on the 2nd index)
            .make_diis_commutator(C,G.beta, D.alpha,.S)
            e1(:,:,aj).plus_scaled(C,coeff(bi))
            .make_diis_commutator(C,G.alpha,D.beta, .S)
            e1(:,:,bj).plus_scaled(C,coeff(ai))

        !   .make_diis_commutator(C,Wa,D.alpha,.S)
        !   e1(:,:,ai).plus_scaled(C,HALF*coeff(aj))
        !   e1(:,:,aj).plus_scaled(C,HALF*coeff(ai))
        !   .make_diis_commutator(C,Wb,D.beta,.S)
        !   e1(:,:,bi).plus_scaled(C,HALF*coeff(bj))
        !   e1(:,:,bj).plus_scaled(C,HALF*coeff(bi))
        !   ! This sums e2 on the first index, giving decoupled equations
        !   ! (The e1.e1 equations are summed over sigma on the 2nd index)
        !   .make_diis_commutator(C,G.beta, D.alpha,.S)
        !   e1(:,:,aj).plus_scaled(C,HALF*coeff(bi))
        !   e1(:,:,bi).plus_scaled(C,HALF*coeff(aj))
        !   .make_diis_commutator(C,G.alpha,D.beta, .S)
        !   e1(:,:,ai).plus_scaled(C,HALF*coeff(bj))
        !   e1(:,:,bj).plus_scaled(C,HALF*coeff(ai))

            ! This sums e2 on the second index, which is wrong.
            ! I thought we could get coupled equations this way.
          ! .make_diis_commutator(C,G.beta, D.alpha,.S)
          ! e1(:,:,bi).plus_scaled(C,HALF*coeff(aj))
          ! e1(:,:,aj).plus_scaled(C,HALF*coeff(bi))
          ! .make_diis_commutator(C,G.alpha,D.beta,.S)
          ! e1(:,:,ai).plus_scaled(C,HALF*coeff(bj))
          ! e1(:,:,bj).plus_scaled(C,HALF*coeff(ai))
         end
      end
      Wb.destroy; Wa.destroy; C.destroy
      D.destroy; G.destroy; F.destroy

      ! Now reconstruct the "rhs" and "lhs" ...
      rhs.create(2*dim); rhs = ZERO
      rhs_a => rhs.alpha
      rhs_b => rhs.beta
      lhs.create(2*dim,2*dim); lhs = ZERO
      lhs_aa => lhs.alpha_alpha; lhs_ab => lhs.alpha_beta
      lhs_bb => lhs.beta_beta;   lhs_ba => lhs.beta_alpha
      do i = 1,2*dim
         if (i<dim) then
         lhs_aa(dim,i) = ONE   ! Here we set the auxiliary row on the bottom
         lhs_bb(dim,i) = ONE 
         lhs_aa(i,dim) = ONE   ! Here we set the auxiliary row on the bottom
         lhs_bb(i,dim) = ONE 
         end
         if (i==dim OR i==2*dim) cycle
         do j = 1,2*dim
            if (j==dim OR j==2*dim) cycle
            lhs(i,j) = -TWO*e1(:,:,i).dot(e1(:,:,j))
         end
      end
      e1.destroy

      ! Symmetrize and set ends and corners
      lhs_ba = ZERO            ! For decoupled equations
      lhs_ab = ZERO
      rhs_a(dim) = ONE         ! Set the last element
      rhs_b(dim) = ONE              
      lhs.symmetric_reflect

      ! Save LHS to disk for next time
      .lhs_tag = "lhs,ddiis,unrestricted" 
      .save_item(lhs,.lhs_tag) 
   end

   r_ddiis_length(coeff,l,dl) ::: selfless
   ! For the first (.dimension-2) DDIIS coefficients "coeff", return the DDIIS
   ! length vector "l" and its gradient "dl". The last DDIIS coefficient is
   ! determined from the other by the condition that the coeficients sum to 1.
      coeff :: VEC{REAL}, IN
      l :: REAL, OUT
      dl :: VEC{REAL}, optional, OUT
   ENSURE(saved_self.associated,"saved_self not defined")
   ENSURE(saved_self.dimension>=3,"dimension too small")
      F,D :: OPMATRIX*
      e1 :: MAT3{REAL}*
      C,lhs :: MAT{REAL}*
      coeff1 :: VEC{REAL}*
      dim,dimv,i,j :: INT
      self :: FOCK_DIIS*

      self => saved_self

      ! Make temporaries
      dim = .dimension
      dimv = .S.dim1
      coeff1.create(dim-1)                ! Last coefficient is the sum of the first
      lhs.create(dim-1,dim-1)             ! Define a reduced LHS
      e1.create(dimv,dimv,dim-1)          ! Define the partial sums to make the LHS
      e1 = ZERO
      C.create(dimv,dimv)                 ! These are for commutators
      F.create(dimv,"restricted")
      D.create(dimv,"restricted")
      coeff1(1:dim-2) = coeff
      coeff1(dim-1) = ONE - VEC{REAL}:sum_elements(coeff)

      ! Make e1 from the start
      do i = 1,dim-1                      
         .read_item(F,.F_tag,i)
         do j = 1,dim-1       
            .read_item(D,.D_tag,j)
            .make_diis_commutator(C,F.restricted,D.restricted,.S)
            e1(:,:,i).plus_scaled(C,HALF*coeff1(j))
            e1(:,:,j).plus_scaled(C,HALF*coeff1(i))
         end
      end
      D.destroy; F.destroy; C.destroy

      ! Now reconstruct the reduced "lhs" ...
      lhs = ZERO                          
      do i = 1,dim-1
      do j = 1,i
         lhs(i,j) = -e1(:,:,i).dot(e1(:,:,j))
      end
      end
      e1.destroy

      ! Symmetrize
      lhs.symmetric_reflect

      ! Finally make the value and derivative
      l = dot_product(coeff1,matmul(lhs,coeff1))
      if (present(dl)) then
         ENSURE(dl.dim==(dim-2),"wrong size, dl")
         dl = matmul(lhs(1:dim-2,:),coeff1)
         dl = dl - dot_product(lhs(dim-1,:),coeff1)
         dl = FOUR*dl
      end
      lhs.destroy; coeff1.destroy
   end

   u_ddiis_length(coeff,l,dl) ::: selfless
   ! For the first (.dimension-2) alpha and beta DDIIS coefficients "coeff",
   ! return the DDIIS length vector "l" and its gradient "dl". The last DDIIS
   ! coefficients are determined from the others by the condition that the
   ! alpha and beta coefficients separately sum to 1.
      coeff :: VEC{REAL}, IN
      l :: REAL, OUT
      dl :: VEC{REAL}, optional, OUT
   ENSURE(saved_self.associated,"saved_self not defined")
   ENSURE(saved_self.dimension>=3,"dimension too small")
      F,G,D :: OPMATRIX*
      dim,dimv,i,j,aj,bj,ai,bi :: INT
      lhs,C,Wa,Wb, lhs_aa,lhs_bb,lhs_ab,lhs_ba :: MAT{REAL}*
      coeff0,coeff1,c1a,c1b,dla,dlb,da,db :: VEC{REAL}*
      outside :: VEC{BIN}*
      e0,e1 :: MAT3{REAL}*
      self :: FOCK_DIIS*

      self => saved_self

      ! Make temporaries
      dim = .dimension
      dimv = .S.dim1
      outside.create(coeff.dim)    
      outside = coeff<ZERO OR coeff>ONE
      coeff0.create_copy(coeff)      ! Set to zero any outside values
      if (.force_convexity) then
      coeff0.chop_small_values(ZERO)
      coeff0.chop_large_values(ONE)
      end
      coeff1.create(2*(dim-1))       ! Last coefficient is the sum of the first
      c1a => coeff1.alpha; c1b => coeff1.beta
      c1a(1:dim-2) = coeff0(1:dim-2)
      c1b(1:dim-2) = coeff0(dim-2+1:2*(dim-2))
      c1a(dim-1)   = ONE - VEC{REAL}:sum_elements(coeff0(1:dim-2))
      c1b(dim-1)   = ONE - VEC{REAL}:sum_elements(coeff0(dim-2+1:2*(dim-2)))
      lhs.create(2*(dim-1),2*(dim-1))
      F.create(dimv,"unrestricted")  ! Temporaries for commutators
      G.create(dimv,"unrestricted")
      D.create(dimv,"unrestricted")
      C.create(dimv,dimv)
      Wa.create(dimv,dimv); Wb.create(dimv,dimv)
      e0.create(dimv,dimv,2)         ! This is a lot of storage !
      e0 = ZERO
      e1.create(dimv,dimv,2*(dim-1)) ! This is a lot of storage !
      e1 = ZERO

      ! Make e0 & e1 from the start
      do i = 1,dim-1                 
         ai = i                      ! This sums on the first index
         bi = i + dim-1              ! which is an unrestricted sum
         .read_item(F,.F_tag,i)
         .read_item(G,.J_tag,i)
         Wa = F.alpha - G.beta
         Wb = F.beta  - G.alpha
         do j = 1,dim-1
            aj = j
            bj = j + dim-1
            .read_item(D,.D_tag,j)
            .make_diis_commutator(C,Wa,D.alpha,.S)
            e1(:,:,aj).plus_scaled(C,coeff1(ai))
            .make_diis_commutator(C,Wb,D.beta,.S)
            e1(:,:,bj).plus_scaled(C,coeff1(bi))
            ! This sums e2 on the first index, giving decoupled equations
            ! (The e1.e1 equations are summed over sigma on the 2nd index)
            .make_diis_commutator(C,G.beta, D.alpha,.S)
            e1(:,:,aj).plus_scaled(C,coeff1(bi))
            .make_diis_commutator(C,G.alpha,D.beta, .S)
            e1(:,:,bj).plus_scaled(C,coeff1(ai))

          ! .make_diis_commutator(C,Wa,D.alpha,.S)
          ! e1(:,:,ai).plus_scaled(C,HALF*coeff1(aj))
          ! e1(:,:,aj).plus_scaled(C,HALF*coeff1(ai))
          ! .make_diis_commutator(C,Wb,D.beta, .S)
          ! e1(:,:,bi).plus_scaled(C,HALF*coeff1(bj))
          ! e1(:,:,bj).plus_scaled(C,HALF*coeff1(bi))
          ! ! This sums e2 on the first index, giving decoupled equations
          ! ! (The e1.e1 equations are summed over sigma on the 2nd index)
          ! .make_diis_commutator(C,G.beta, D.alpha,.S)
          ! e1(:,:,aj).plus_scaled(C,HALF*coeff1(bi))
          ! e1(:,:,bi).plus_scaled(C,HALF*coeff1(aj))
          ! .make_diis_commutator(C,G.alpha,D.beta, .S)
          ! e1(:,:,ai).plus_scaled(C,HALF*coeff1(bj))
          ! e1(:,:,bj).plus_scaled(C,HALF*coeff1(ai))
         end
      end

      ! Now reconstruct the reduced "lhs" ...
      lhs_aa => lhs.alpha_alpha; lhs_ab => lhs.alpha_beta
      lhs_bb => lhs.beta_beta;   lhs_ba => lhs.beta_alpha
      lhs = ZERO
      do i = 1,2*(dim-1)
      do j = 1,2*(dim-1)
         lhs(i,j) = -e1(:,:,i).dot(e1(:,:,j))
      end
      end
      lhs_ba = ZERO
      lhs_ab = ZERO
    ! lhs.symmetric_reflect

      ! Finally make the value and derivative
      l = dot_product(coeff1,matmul(lhs,coeff1))
      if (present(dl)) then
         ENSURE(dl.dim==2*(dim-2),"wrong size, dl")
         dla => dl.alpha
         dlb => dl.beta                ! No cross terms in the (dim-1) derivative
         dla = TWO*(matmul(lhs_aa(1:dim-2,:),c1a) - dot_product(lhs_aa(dim-1,:),c1a))
         dlb = TWO*(matmul(lhs_bb(1:dim-2,:),c1b) - dot_product(lhs_bb(dim-1,:),c1b))
         do i = 1,dim-1                ! Make the derivative term which
            ai = i                     ! sums over the second e index
            bi = i + dim-1
            e0(:,:,1) = e0(:,:,1) + e1(:,:,ai)*coeff1(ai)
            e0(:,:,2) = e0(:,:,2) + e1(:,:,bi)*coeff1(bi)
         end
         da.create(dim-1); da = ZERO
         db.create(dim-1); db = ZERO
         do i = 1,dim-1                ! Make the derivative term which
            ai = i                     ! sums over the second e index
            bi = i + dim-1
            .read_item(F,.F_tag,i)
            .read_item(G,.J_tag,i)
            Wa = F.alpha - G.beta
            Wb = F.beta  - G.alpha
            do j = 1,dim-1
               aj = j
               bj = j + dim-1
               .read_item(D,.D_tag,j)   ! Include factor two from derivative
               .make_diis_commutator(C,Wa,D.alpha,.S) ! minus sign for dot
               da(i) = da(i) - C.dot(e0(:,:,1))*c1a(j)*TWO
               .make_diis_commutator(C,Wb,D.beta, .S)
               db(i) = db(i) - C.dot(e0(:,:,2))*c1b(j)*TWO
               ! This sums e2 on the second index
               .make_diis_commutator(C,G.beta, D.alpha,.S)
               db(i) = db(i) - C.dot(e0(:,:,1))*c1a(j)*TWO
               .make_diis_commutator(C,G.alpha,D.beta,.S)
               da(i) = da(i) - C.dot(e0(:,:,2))*c1b(j)*TWO
            end
         end
         dla = dla + da(1:dim-2) - da(dim-1)
         dlb = dlb + db(1:dim-2) - db(dim-1)
         db.destroy; da.destroy
         if (.force_convexity AND any(outside)) then
          ! do i = 1,outside.dim
          !    if (NOT outside(i)) cycle
          !    dl(i) = ZERO 
          ! end
            l = huge(ONE)
         end
      end
      e1.destroy; e0.destroy
      Wb.destroy; Wa.destroy; C.destroy
      D.destroy; G.destroy; F.destroy
      lhs.destroy; coeff1.destroy; coeff0.destroy; outside.destroy
   end

! ==========================
! Solving the DIIS equations
! ==========================

   solve_r_diis_equations(lhs,rhs,solution,emin)
   ! Solve the restricted DIIS equations. This solver can enforce the positivity
   ! of the coefficients to ensure that the corresponding extrapolated density
   ! has eigenvalues between 0 and 1.
      lhs :: MAT{REAL}
      rhs,solution :: VEC{REAL}

   ENSURE(lhs.is_square,"lhs must be square")
   ENSURE(lhs.dim1==rhs.dim,"lhs and rhs are incompatible")
   ENSURE(lhs.dim1==solution.dim,"lhs and solution are incompatible")

      emin :: REAL, optional
      plist,keep0 :: VEC{INT}*
      dim,k :: INT
      fail :: BIN

      if (.force_convexity) then
         dim = rhs.dim
         plist.create(dim-1); plist = [(k,k=1,dim-1)] ! ; plist.prune([.new])
         keep0.create(1); keep0(1) = .new
         FOCK_DIIS::solve_convex(self,lhs,rhs,solution,plist,keep0,emin,fail) 
         DIE_IF(fail,"failed to find a convex solution")
       ! if (fail) then
       ! lhs.solve_convex_linear_equation(rhs,coeff,plist,keep1=[.new],fail=fail) 
       ! DIE_IF(fail,"failed to find a convex solution")
       ! end
         keep0.destroy
         plist.destroy
      else
         lhs.solve_linear_equation(rhs,solution)  ! Solve diis equations
      end

   end

   solve_u_diis_equations(lhs,rhs,solution)
   ! Solve the unrestricted DIIS equations. This solver can enforce the positivity
   ! of the coefficients to ensure that the corresponding extrapolated density
   ! has eigenvalues between 0 and 1.
      lhs :: MAT{REAL}
      rhs,solution :: VEC{REAL}

   ENSURE(lhs.is_square,"lhs must be square")
   ENSURE(lhs.dim1==rhs.dim,"lhs and rhs are incompatible")
   ENSURE(lhs.dim1==solution.dim,"lhs and solution are incompatible")
   ENSURE(rhs.dim.is_even,"rhs must have an even dimension")

      plist :: VEC{INT}*
      dim,k :: INT
      fail :: BIN

      if (.force_convexity) then
         dim = rhs.dim/2
         plist.create(2*dim); plist = [(k,k=1,2*dim)] 
         plist.prune([dim,2*dim])
       ! lhs.solve_convex_linear_equation(rhs,solution,plist,keep0=[.new,dim+.new],fail=fail) 
         FOCK_DIIS::solve_convex(self,lhs,rhs,solution,plist,keep0=[.new,dim+.new],fail=fail) 
         DIE_IF(fail,"failed to find a convex solution")
       ! if (fail) then
       ! lhs.solve_convex_linear_equation(rhs,solution,plist,keep1=[.new,dim+.new],fail=fail) 
       ! DIE_IF(fail,"failed to find a convex solution")
       ! end
         plist.destroy
      else
         lhs.solve_linear_equation(rhs,solution)  ! Solve diis equations
      end

   end

!   solve_gc_diis_equations(lhs,rhs,solution,emin)
!   ! Solve the restricted DIIS equations. This solver can enforce the positivity
!   ! of the coefficients to ensure that the corresponding extrapolated density
!   ! has eigenvalues between 0 and 1.
!      lhs :: MAT{CPX}
!      rhs,solution :: VEC{CPX}
!   ENSURE(lhs.is_square,"lhs must be square")
!   ENSURE(lhs.dim1==rhs.dim,"lhs and rhs are incompatible")
!   ENSURE(lhs.dim1==solution.dim,"lhs and solution are incompatible")
!      emin :: REAL, optional
!
!      i,j,dim :: INT
!      a,b :: REAL
!      lhs2 :: MAT{REAL}*
!      rhs2,solution2 :: VEC{REAL}*
!  !    coeff :: VEC{CPX}*
!  !    plist,keep0 :: VEC{INT}*
!  !    dim,k :: INT
!  !    fail :: BIN
!   !   if (.force_convexity) then
!   !      dim = rhs.dim
!   !      plist.create(dim-1); plist = [(k,k=1,dim-1)] ! ; plist.prune([.new])
!   !      keep0.create(1); keep0(1) = .new
!   !      FOCK_DIIS::solve_convex(self,lhs,rhs,solution,plist,keep0,emin,fail) 
!   !      DIE_IF(fail,"failed to find a convex solution")
!   !    ! if (fail) then
!   !    ! lhs.solve_convex_linear_equation(rhs,coeff,plist,keep1=[.new],fail=fail) 
!   !    ! DIE_IF(fail,"failed to find a convex solution")
!   !    ! end
!   !      keep0.destroy
!   !      plist.destroy
!   !   else
!        dim= lhs.dim1
!        lhs2.create(2*dim-1,2*dim-1)
!        rhs2.create(2*dim-1)
!        solution2.create(2*dim-1)
!
!        ! because it seeems the imaginary equation will be numerically
!        ! dependent I (LBxxx) skip that part
!        do i=1,dim-1
!          do j=1,dim-1
!            lhs2(2*i-1,2*j-1) =  real(lhs(i,j))
!            lhs2(2*i,2*j)     = -aimag(lhs(i,j))
!          end do
!          lhs2(2*dim-1,i)     = real(lhs(dim,i))
!          lhs2(i,2*dim-1)     = real(lhs(i,dim))
!    !      rhs2(2*i-1) =  real(lhs(i))
!    !      rhs2(2*i)   =  aimag(lhs(i))
!        end do
!           rhs2=ZERO
!           rhs2(2*dim-1)=ONE
!        lhs2.solve_linear_equation(rhs2,solution2)  ! Solve diis equations
!
!        do i=1,dim-1
!           a=solution2(2*i-1)
!           b=solution2(2*i)
!           solution(i)=cmplx(a,b) 
!        end do
!           a=solution2(2*dim-1)
!           b=ZERO
!           solution(dim)=cmplx(a,b) 
!        
!        lhs2.destroy
!        rhs2.destroy
!        solution2.destroy
!   !   end
!   end

   solve_convex(lhs,rhs,solution,plist,keep0,fmin,fail) ::: private
   ! This routine solves the quadratic minimisation problem:
   !    f(X) = rhs . X  -  HALF * X^T . self . X 
   ! where, in addition, X >= 0 for all elements in "plist" and any elements of
   ! the "solution" X not in "plist" are not constrained to be positive AND do
   ! not participate in the evaluation of the quadratic function f -- they are
   ! usually lagrange multipliers. This routine involves solving reduced linear
   ! equations with "self" as the LHS and "rhs" as the RHS, over all partitions
   ! of the elements in "plist".  If "keep0" is present, then at least one of
   ! the indices in this sublist of "plist" must be kept when considering all
   ! partitions. If present, "fail" is set TRUE if no solutions are found,
   ! otherwise the routine terminates with an error.  WARNING: if the dimension
   ! of the matrix is too large, this routine will take a long time.  NOTE: it
   ! appears that if keep0 is even, one of the combonation indices must be in
   ! the first half, and the other must be in the second half.
      lhs :: MAT{REAL}
      rhs,solution :: VEC{REAL}
      plist :: VEC{INT}, IN
      keep0 :: VEC{INT}, optional
      fmin :: REAL, OUT, optional
      fail :: BIN, OUT, optional
   ENSURE(lhs.is_square,"non-square matrix")
   ENSURE(rhs.dim==lhs.dim1,"incompatible rhs")
   ENSURE(solution.dim==lhs.dim1,"incompatible solution vector")
   ENSURE(plist.dim<=lhs.dim1,"plist to large")
   ENSURE(plist.all_in_range([1,lhs.dim1]),"plist indices out of range")
      pdim,rdim,k,n,n_combinations :: INT
      ulist,list,comb :: VEC{INT}*
      combination :: MAT{INT}*
      lhs0 :: MAT{REAL}*
      sol,sol0,rhs0 :: VEC{REAL}*
      e,e0 :: REAL
      found_one,no_solution :: BIN
    ! even :: BIN

    ! even = FALSE
      if (present(keep0)) then
         ENSURE(keep0.has_all_elements_common_with(plist),"keep0 not a sublist of plist")
    !    even = keep0.dim.is_even
      end

      pdim = plist.dim
      WARN_IF(pdim>=20,"LHS dimension may be too large")

      found_one = FALSE
      e = huge(ONE)
      sol.create(lhs.dim1)

      ! ulist = all - plist = unconstrained 
      ulist.create(lhs.dim1); ulist = [(k,k=1,lhs.dim1)]
      ulist.prune(plist)  

      ! Loop over indice groups of length "k" which are non-zero
      do k = pdim,1,-1 

         n_combinations = int(pdim.choose(k)) 
         combination.create(k,n_combinations)         
         plist.make_combinations_of_length(k,combination)
         rdim = k + lhs.dim1 - pdim

         lhs0.create(rdim,rdim)
         rhs0.create(rdim)
         sol0.create(rdim)
         list.create(rdim)  ! list = comb(plist) + ulist

         ! Loop over a particular "k" length combo
         do n = 1,n_combinations                  

            comb => combination(:,n)

            ! if present, keep at least one of these elements
            if (present(keep0)) then               
               if (NOT keep0.has_elements_common_with(comb)) cycle
             ! if (even AND all(combination(:,n)> lhs.dim1/2)) cycle
             ! if (even AND all(combination(:,n)<=lhs.dim1/2)) cycle
            end

            ! The "list" of non-zero solution elements
            ! ... always add the list of unconstrained elements
            list(1:k)  = comb                     
            list(k+1:) = ulist                    

            rhs0 = rhs(list)
            lhs0 = lhs(list,list)
            lhs0.solve_linear_equation(rhs0,sol0,no_solution) ! Find the subset solution, "sol"

            if (no_solution) cycle

            sol = ZERO
            sol(list) = sol0

            e0 = dot_product(rhs(comb),sol(comb)) &
               - HALF*dot_product(sol(comb),matmul(lhs(comb,comb),sol(comb)))

            ! Unacceptable solution ...
            if (any(sol(comb)<ZERO)) cycle        

            ! Found a better solution before
            if (e0>=e) cycle                      

           ! OK ... Keep this solution and E value
            solution = sol                        
            e = e0 
            found_one = TRUE
            if (present(fmin)) fmin = e

         end
         list.destroy
         sol0.destroy; rhs0.destroy; lhs0.destroy
         combination.destroy
      end

      ulist.destroy
      sol.destroy

      ! Deal with failure conditions
      if (present(fail)) then
         if (NOT found_one) then; fail = TRUE
         else;                    fail = FALSE
         end
      else
         DIE_IF(NOT found_one,"acceptable solution was not found")
      end

   end

! =========================
! Getting lhs/rhs from disk
! =========================

   get_old_lhs(lhs) ::: leaky
   ! Get the old DIIS left hand side matrix in "lhs". The "lhs" is created to be
   ! the correct size for the *current* DIIS problem. The new parts required are
   ! not set. This is a GENERIC version.
      lhs :: MAT{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(.lhs_tag/=" ","no lhs_tag specified")
      dim,iter :: INT

      dim = .dimension
      lhs.create(dim,dim)

      iter = .kept + 1

      if (iter==1) then
         ! This is the first item; there is nothing to extrapolate.
         ! So, we set the diis lhs matrix to zero.
         lhs = ZERO

      else if (iter<=.keep) then
         ! We still have not exceeded ".keep" number of vectors.
         ! The dimension of "lhs" must now be: iter+1 by iter+1;
         ! The dimension of the previous "lhs" was: iter by iter;
         ! We are reading that in here ...
         .read_item(lhs(1:iter,1:iter),.lhs_tag)
         ! The row and column iter will be replaced in the DIIS procedure.
         ! This row and column were the previous DIIS auxiliary row and column, 
         ! so they can be trashed without loss of information.

      else
         ! Here iter exceeds .keep; so one of the parameter and error vectors
         ! from 1 to .keep must be replaced. The dimension of the matrix is
         ! .keep+1 by .keep+1; previously, the dimension of the matrix was also
         ! this big, so we read in the whole matrix ...
         .read_item(lhs,.lhs_tag)
      end
   end

   get_old_r_lhs(lhs) ::: leaky
   ! Get the old restricted DIIS left hand side matrix in "lhs". The "lhs" is
   ! created to be the correct size for the *current* DIIS problem. The new
   ! parts required are not set.
      lhs :: MAT{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(.lhs_tag/=" ","no lhs_tag specified")
      dim,iter :: INT

      dim = .dimension
      lhs.create(dim,dim)

      iter = .kept + 1

      if (iter==1) then
         ! This is the first item; there is nothing to extrapolate.
         ! So, we set the diis lhs matrix to zero.
         lhs = ZERO

      else if (iter<=.keep) then
         ! We still have not exceeded ".keep" number of vectors.
         ! The dimension of "lhs" must now be: iter+1 by iter+1;
         ! The dimension of the previous "lhs" was: iter by iter;
         ! We are reading that in here ...
         .read_item(lhs(1:iter,1:iter),.lhs_tag)
         ! The row and column iter will be replaced in the DIIS procedure.
         ! This row and column were the previous DIIS auxiliary row and column, 
         ! so they can be trashed without loss of information.

      else
         ! Here iter exceeds .keep; so one of the parameter and error vectors
         ! from 1 to .keep must be replaced. The dimension of the matrix is
         ! .keep+1 by .keep+1; previously, the dimension of the matrix was also
         ! this big, so we read in the whole matrix ...
         .read_item(lhs,.lhs_tag)
      end

   end

!   get_old_gc_lhs(lhs) ::: leaky
!   ! Get the old restricted DIIS left hand side matrix in "lhs". The "lhs" is
!   ! created to be the correct size for the *current* DIIS problem. The new
!   ! parts required are not set.
!      lhs :: MAT{CPX}*
!   ENSURE(lhs.disassociated,"lhs exists")
!   ENSURE(.lhs_tag/=" ","no lhs_tag specified")
!      dim,iter :: INT
!
!      dim = .dimension
!      lhs.create(dim,dim)
!
!      iter = .kept + 1
!
!      if (iter==1) then
!         ! This is the first item; there is nothing to extrapolate.
!         ! So, we set the diis lhs matrix to zero.
!         lhs = (ZERO,ZERO)
!
!      else if (iter<=.keep) then
!         ! We still have not exceeded ".keep" number of vectors.
!         ! The dimension of "lhs" must now be: iter+1 by iter+1;
!         ! The dimension of the previous "lhs" was: iter by iter;
!         ! We are reading that in here ...
!         .read_item(lhs(1:iter,1:iter),.lhs_tag)
!         ! The row and column iter will be replaced in the DIIS procedure.
!         ! This row and column were the previous DIIS auxiliary row and column, 
!         ! so they can be trashed without loss of information.
!
!      else
!         ! Here iter exceeds .keep; so one of the parameter and error vectors
!         ! from 1 to .keep must be replaced. The dimension of the matrix is
!         ! .keep+1 by .keep+1; previously, the dimension of the matrix was also
!         ! this big, so we read in the whole matrix ...
!         .read_item(lhs,.lhs_tag)
!      end
!
!   end

   get_old_u_lhs(lhs) ::: leaky
   ! Get the old unrestricted DIIS left hand side matrix in "lhs". The "lhs" is
   ! created to be the correct size for the *current* DIIS problem. It is twice
   ! as big as the restricted DIIS matrix. WARNING: The new parts required are
   ! not set.
      lhs :: MAT{REAL}*
   ENSURE(lhs.disassociated,"lhs exists")
   ENSURE(.lhs_tag/=" ","no lhs_tag specified")
      dim,iter :: INT
      old_lhs,lhs_aa,lhs_bb,lhs_ba,lhs_ab :: MAT{REAL}*

      dim = 2*.dimension
      lhs.create(dim,dim)

      iter = .kept + 1

      if (iter==1) then
         ! This is the first item; there is nothing to extrapolate.
         ! So, we set the diis lhs matrix to zero.
         lhs = ZERO

      else if (iter<=.keep) then
         ! We still have not exceeded ".keep" number of vectors.
         ! The dimension of "lhs" must now be: 2*(iter+1) by 2*(iter+1);
         ! The dimension of the previous "lhs" was: 2*iter by 2*iter;
         ! We are reading the previous one in here ...
         old_lhs.create(2*iter,2*iter)
         .read_item(old_lhs,.lhs_tag)
         lhs = ZERO
         lhs_aa => lhs.alpha_alpha
         lhs_bb => lhs.beta_beta
         lhs_ba => lhs.beta_alpha
         lhs_ab => lhs.alpha_beta
         lhs_aa(1:iter,1:iter) = old_lhs.alpha_alpha
         lhs_bb(1:iter,1:iter) = old_lhs.beta_beta
         lhs_ba(1:iter,1:iter) = old_lhs.beta_alpha
         lhs_ab(1:iter,1:iter) = old_lhs.alpha_beta
         old_lhs.destroy
         ! The row and column iter will be replaced in the DIIS procedure.
         ! This row and column were the previous DIIS auxiliary row and column, 
         ! so they can be trashed without loss of information.

      else
         ! Here iter exceeds .keep; so one of the parameter and error vectors
         ! from 1 to .keep must be replaced. The dimension of the matrix is
         ! .keep+1 by .keep+1; previously, the dimension of the matrix was also
         ! this big, so we read in the whole matrix ...
         .read_item(lhs,.lhs_tag)
      end
   end

   get_old_r_rhs(rhs) ::: leaky, private
   ! Get the old EDIIS "rhs" from disk. These will usually be energies. In fact,
   ! one of these energies should be new, not old.
      rhs :: VEC{REAL}*
   ENSURE(rhs.disassociated,"rhs exists")
   ENSURE(.e_tag/=" ","e_tag is not specified")
      dim,old :: INT
      e :: REAL

      dim = .dimension
      rhs.create(dim)

      do old = 1,dim-1 
         .read_item(e,.e_tag,old)
         rhs(old) = e               ! One of these energies is new!
      end
   end

   get_old_u_rhs(rhs) ::: leaky, private
   ! Get the old EDIIS "rhs" from disk. These will usually be energies. In fact,
   ! one of these energies should be new, not old.
      rhs :: VEC{REAL}*
   ENSURE(rhs.disassociated,"rhs exists")
   ENSURE(.e_tag/=" ","e_tag is not specified")
      dim,old :: INT
      rhs_a,rhs_b :: VEC{REAL}*
      e_a,e_b :: REAL

      dim = .dimension
      rhs.create(2*dim); rhs = ZERO
      rhs_a => rhs.alpha
      rhs_b => rhs.beta

      do old = 1,dim-1
         .read_item(e_a,.e_tag.trim//","//old.to_str.trim//",alpha")
         .read_item(e_b,.e_tag.trim//","//old.to_str.trim//",beta")
         rhs_a(old) = e_a           ! One of these energies is new!
         rhs_b(old) = e_b
      end
   end

! ==================================
! Saving and reading items from disk
! ==================================

   save_item(item,name,i,genre) ::: template
   ! Save "item" to disk with identifiers: label "name", and number "i".
      item :: ITEM?, IN
      name :: STR, IN
      i :: INT, IN, optional
      genre :: STR, IN, optional

   ENSURE(.saved_iteration>0,"cannot save before the save_iteration") 

      old_name,new_name :: STR

      old_name = .archive.name
      new_name = .archive_name(name,i)

      .archive.set_name(new_name)
      .archive.write(item,genre)
      .archive.set_name(old_name)

   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>REAL)
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>VEC{REAL})
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>VEC{CPX})
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>MAT{REAL})
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>MAT{CPX})
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>MAT3{REAL})
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_item(item,name,i,genre) ::: get_from(FOCK_DIIS, ITEM?=>OPMATRIX)
   ! Save "item" to disk with identifiers: label "name", and number "i".
   end

   save_current_item(item,name) ::: template
   ! Save "item" to disk with identifiers: label "name", and number ".new".
   ! That is, the item is given the current number.
      item :: ITEM?, IN
      name :: STR, IN
      if (.saved_iteration<=0) return
      .save_item(item,name,.new)
   end

   save_current_item(item,name) ::: get_from(FOCK_DIIS, ITEM?=>OPMATRIX)
   ! Save "item" to disk with identifiers: label "name", and number ".new".
   ! That is, the item is given the current number.
   end

   read_item(item,name,i) ::: template
   ! Get the "item" from disk with identifiers: label "name", and number "i".
      item :: ITEM?
      name :: STR, IN
      i :: INT, IN, optional

      old_name,new_name :: STR

      old_name = .archive.name
      new_name = .archive_name(name,i)

      .archive.set_name(new_name)
      .archive.read(item)
      .archive.set_name(old_name)

   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>REAL)
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>VEC{REAL})
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>VEC{CPX})
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>MAT{REAL})
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>MAT{CPX})
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>MAT3{REAL})
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>OPVECTOR)
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   read_item(item,name,i) ::: get_from(FOCK_DIIS, ITEM?=>OPMATRIX)
   ! Get the "item" from disk with identifiers: label "name", and number "i".
   end

   archive_name(name,i) result (res)
   ! Get the file name of the DIIS archive with "name", and number "i".
      res :: STR
      name :: STR, IN
      i :: INT, IN, optional
      res = .archive.name
      res = res.trim // "," // name.trim
      if (present(i)) res = res.trim // "," // i.to_str.trim
   end

   archive_exists(name,i) result (res)
   ! Does the DIIS archive with "name", and number "i" exist?.
      res :: BIN
      name :: STR, IN
      i :: INT, IN, optional
      old_name,new_name :: STR
      old_name = .archive.name
      new_name = .archive_name(name,i)
      .archive.set_name(new_name)
      res = .archive.exists
      .archive.set_name(old_name)
   end

   delete_archive(name,i) 
   ! Delete the archive with identifiers: label "name", and number "i".
      name :: STR, IN
      i :: INT, IN, optional
      old_name,new_name :: STR
      old_name = .archive.name
      new_name = .archive_name(name,i)
      .archive.set_name(new_name)
      .archive.delete_all_genres
      .archive.set_name(old_name)
   end

! ==========
! Converged?
! ==========

   is_converged result (res)
   ! Return TRUE if the DIIS procedure is converged
      res :: BIN
      res = .error_length<.convergence_tolerance
   end

! ======================
! Output the DIIS object
! ======================

   put
   ! Prints out the DIIS data to stdout

      stdout.flush
      stdout.text("FOCK_DIIS options: ")
      stdout.flush
      stdout.show("Kind of DIIS                   =",.genre.trim)
      stdout.show("Convergence tolerance          =",.convergence_tolerance)
      stdout.show("Start iteration                =",.start_iteration)
      stdout.show("Start saving iteration         =",.save_iteration)
      stdout.show("No. of entities to keep        =",.keep)
      stdout.show("DIIS replacement method        =",.replacement_method)
      stdout.show("Force convexity?               =",.force_convexity)

      if (.genre=="ediis+diis") then
      stdout.show("EDIIS finish/DIIS start        =",.start_tolerance)
      stdout.show("# EDIIS encore iterations      =",.encore_iterations)
      end

      if (.genre=="ddiis") then
      stdout.show("Micro iteration method         =",.micro_iteration_method)
      stdout.show("Micro it. starting guess       =",.micro_starting_guess)
      stdout.show("Micro it. convergence tol      =",.micro_convergence_tol)
      stdout.show("Micro it. maximum iters        =",.micro_max_iterations)
      stdout.show("Micro it. damp factor          =",.micro_damp_factor)
      end

      stdout.show("Archive root name              =", .archive.root_name)

   end

end
