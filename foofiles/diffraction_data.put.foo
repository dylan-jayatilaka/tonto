!====================================================================
!
! DIFFRACTION_DATA.put: 
!
! Diffraction data structure for crystals: put methods
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
! Copyright (C) Dylan Jayatilaka 2023
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!====================================================================

module DIFFRACTION_DATA.PUT

   implicit none

contains

! =======
! Put CIF
! =======

   put_CIF_refinement
   ! Put refinement information in CIF format
   ! No refinement info. possible without reflections!
      self :: IN

      n :: INT
      R :: REAL
      val :: STR

      if (.reflections.deallocated) return

      stdout.flush
      stdout.text("# ===============")
      stdout.text("# Refinement data")
      stdout.text("# ===============")

      stdout.flush
      stdout.text("_refine_ls_kind                     'Hirshfeld atom refinement (HAR)'")
      stdout.text("_refine_ls_method_description")
      stdout.text(";")
      stdout.text("   S.C. Capelli, H.-B. Burgi, B. Dittrich, S.Grabowsky")
      stdout.text("   and Dylan Jayatilaka, IUCrJ (2014). 1, 361-379")
      stdout.text(";")
      if (.XCW) then                                
      stdout.text("_refine_QCr_Psi_constraint          'lambda*chi2'")
      stdout.text("_refine_QCr_method_description")
      stdout.text(";")
      stdout.text("  'The Significance of Ionic Bonding in Sulfur Dioxide: ")
      stdout.text("   Bond Orders from X-ray Diffraction Data' ")
      stdout.text("   S. Grabowsky,* P. Luger, J. Buschmann, T. Schneider")
      stdout.text("   T. Schirmeister, A.N. Sobolev, and D. Jayatilaka")
      stdout.text(";")
      else                                          
      stdout.text("_refine_QCr_Psi_constraint          'none'")
      end

      stdout.flush
      val = .near_0_tol.to_str("e9.1")
      stdout.text("_refine_ls_SVD_threshold            "//trim(val))
      stdout.text("_refine_ls_coordinate_system        cartesian")
      stdout.text("_refine_ls_structure_factor_coef    F")
      stdout.text("_refine_ls_matrix_type              full")

      R   = .reflections.F_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_R_factor_gt              "//trim(val))
      stdout.text("_refine_ls_R_factor_ref             "//trim(val))
      stdout.text("_refine_ls_R_factor_all             "//trim(val))

      R   = .reflections.F_weighted_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_wR_factor_gt             "//trim(R.to_str("f10.4")))
      stdout.text("_refine_ls_wR_factor_ref            "//trim(R.to_str("f10.4")))
      stdout.text("_refine_ls_wR_factor_all            "//trim(R.to_str("f10.4")))

      R   = .reflections.F2_r_factor
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_R_Fsqd_factor            "//trim(R.to_str("f10.4")))

      R   = (.chi2)
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_chi2                     "//trim(val))

      R   = sqrt(.chi2)
      val = R.to_str("f10.4")
      stdout.text("_refine_ls_goodness_of_fit_gt       "//trim(val))
      stdout.text("_refine_ls_goodness_of_fit_ref      "//trim(val))
      stdout.text("_refine_ls_goodness_of_fit_all      "//trim(val))
    ! stdout.text("_refine_ls_restrained_S_all             "//trim(val))
      n   = .reflections.dim
      val = n.to_str
      stdout.text("_refine_ls_number_reflns            "//trim(val))
      stdout.text("_refine_ls_number_parameters        "//trim(.n_param.to_str))
      stdout.text("_refine_ls_number_restraints        0")
      val = .near_0.to_str
      stdout.text("_refine_ls_number_constraints       "//trim(val))

      if (.refine_H_ADPs) then
      if (.INQ:refine_positions_and_ADPs) then
      stdout.text("_refine_ls_hydrogen_treatment       refall")
      else if (.refine_ADPs_only) then
      stdout.text("_refine_ls_hydrogen_treatment       refU")
      end
      else
      stdout.text("_refine_ls_hydrogen_treatment       refxyz")
      end

      stdout.text("_refine_ls_weighting_scheme         sigma")
      stdout.text("_refine_ls_weighting_details        'w=1/\s(F)'")

      val = adjustl(.tol_for_shift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_conv_tol        "//trim(val))
      val = adjustl(.max_refshift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_max             "//trim(val))
      val = adjustl(.ave_refshift_on_esd.to_str("f10.4"))
      stdout.text("_refine_ls_shift/su_max_mean        "//trim(val))
      stdout.text("_refine_ls_shift/su_max_par         '"//trim(.max_refshift_on_esd_par)//"'")

      if (.refine_extinction) then
      stdout.text("_refine_ls_extinction_method        Zachariasen/Larson")
      else
      stdout.text("_refine_ls_extinction_method        none")
      end

      if (.do_residual_cube) then
      stdout.flush
      val = adjustl(.max_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_max            "//trim(val))
      val = adjustl(.min_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_min            "//trim(val))
      val = adjustl(.rms_residual.to_str("f10.4"))
      stdout.text("_refine_diff_density_rms            "//trim(val))
      val = (.max_atom_residual.to_str("f10.4"))
!     stdout.text("_refine_diff_density_max_atom       "//trim(val))
!     stdout.text("_refine_diff_density_max_atom_tag   "//trim(.max_atom_residual_tag))
!     val = (.min_atom_residual.to_str("f10.4"))
!     stdout.text("_refine_diff_density_min_atom       "//trim(val))
!     stdout.text("_refine_diff_density_min_atom_tag   "//trim(.min_atom_residual_tag))
!     val = (.rms_atom_residual.to_str("f10.4"))
!     stdout.text("_refine_diff_density_rms_atom       "//trim(val))
      end

      stdout.flush
      stdout.text("_refine_special_details")
      stdout.text(";")
      stdout.text(". If constraints were applied they are defined by zero")
      stdout.text("  eigenvalues of the least-squares hessian, see the")
      stdout.text("  value of _refine_ls_SVD_threshold")
      stdout.text(";")

   end

   put_CIF_covariance_matrices(cif)
   ! Output the covariance matrix in CIF format
      self :: IN
      cif :: CIF, IN

      ! Asymmetric unit covariance
      if (cif.use_CIF2) then
      if (.covariance_mx.allocated) then
         ::put_CIF_covariance_mx("asym_unit",.covariance_mx,cif.use_CIF2)
      end
      end

      ! Fragment covariance?
      if (cif.use_CIF2) then
      if (.fragment_covariance_mx.allocated) then
         ::put_CIF_covariance_mx("fragment",.fragment_covariance_mx,cif.use_CIF2)
      end
      end

   end

   put_CIF_covariance_mx(kind,covariance_mx,CIF2) ::: selfless
   ! Output the covariance matrix in CIF format
      self :: IN
      kind :: STR, IN
      covariance_mx :: MAT{REAL}, IN
      CIF2 :: BIN, IN

   ENSURE(covariance_mx.is_square,"covariance is not square")

      ! Change defaults
      stdout.save_style
      stdout.set_real_fortran_fmt("e")
      stdout.set_real_width(16)
      stdout.set_real_precision(8)

      stdout.flush
      stdout.text("# NOTE: Cartesian 9Nx9N covariance matrix in BOHR units")
      stdout.text("# The order of the variables (per atom) is as follows:")
      stdout.text("# . Elements 1-3: positions: x y x")
      stdout.text("# . Elements 4-9: 2nd order ADPs:")
      stdout.text("#      U 11 22 33 12 13 23")
      stdout.text("# . Elements 10-19: 3rd order ADPs (if refined):")
      stdout.text("#      U 111 222 333 112 113 122 223 133 233 123")
      stdout.text("# . Elements 20-34: 4th order ADPs (if refined):")
      stdout.text("#      U 1112 1113 1222 2223 1333 2333")
      stdout.text("#        1122 1133 2233 1123 1223 1233")
      stdout.text("# . Matrix is output in (fortran) column order")

      stdout.flush
      stdout.text("_"//trim(kind)//"_covariance_mx")

      ! Opening brace
      if (CIF2) then
      stdout.text("[")
      else
      stdout.text(";")
      end

      ! Matrix contents
      stdout.put(covariance_mx,by_column=TRUE)
      stdout.flush

      ! Closing brace
      if (CIF2) then
      stdout.text("]")
      else
      stdout.text(";")
      end

      ! Put back defaults
      stdout.unsave_style

   end

! =========================
! Put fit/refinement output
! =========================

   put_fit_header ::: selfless
   ! Put the fit header
      self :: IN

      stdout.flush
      stdout.text("===================================")
      stdout.text("Crystal structure fit (rigid atoms)")
      stdout.text("===================================")
      stdout.flush
      stdout.text("A single SCF/rigid hirshfeld atom fit is performed.")
      stdout.flush
      stdout.text("Consider non-rigid hirshfeld_atom_refinement instead.")

   end

   put_refinement_header ::: selfless
   ! Put the fit header
      self :: IN

      stdout.flush
      stdout.text("==============================================")
      stdout.text("Crystal structure refinement (non-rigid atoms)")
      stdout.text("==============================================")
      
      stdout.flush
      stdout.text("Repeated SCF/rigid hirshfeld atom fits are performed")
      stdout.text("which eventually removes the rigid atom constraint.")
      
      stdout.flush
      stdout.text("Agreement statistics are shown at the start and end")
      stdout.text("of each 'micro' rigid fit cycle.")
      
      stdout.flush
      stdout.text("Convergence criteria for each fit-cycle are the same")
      stdout.text("as for convergence of the overall refinement")

   end

   put_refinement_switches
   ! Put the fit/refinement switches
      self :: IN

      list :: STR

      stdout.flush
      if (.use_KM_atoms) then
      stdout.text("Koritsanszky-Michael atom refinement")
      end
   
      stdout.flush
      stdout.show("Refine hydrogen ADP's       =",.refine_H_ADPs)
      stdout.show("Refine hydrogen U_iso       =",.refine_H_U_iso)
      stdout.show("Refine only ADP's           =",.refine_ADPs_only)
      stdout.show("Refine only positions       =",.INQ:refine_positions_only)
   
      if (.refine_anharmonicity) then
      stdout.flush
      stdout.show("Refine anharmonicity        =",TRUE)
      stdout.show("Refine 4th order only?      =",.refine_4th_order_only)
      list = .refine_4th_order_for_atom.to_concatenated_str
      stdout.show("Anharmonic atoms            =",trim(list))
      end
   
      stdout.flush
      stdout.show("Refine scale factor         =",.refine_scale)
      stdout.show("Refine multiple scales      =",.INQ:use_multiple_scale_factors)
      stdout.show("Refine extinction parameter =",.refine_extinction)
      stdout.show("Correct dispersion?         =",.INQ:correct_dispersion)
      if (.INQ:correct_dispersion) then
      stdout.show("Add dispersion into F_calc  =",.add_dispersion_to_F_calc)
      stdout.show("Remove dispersion frm F_exp =",.remove_dispersion_from_F_exp)
      end
   
      stdout.flush
      stdout.show("Max allowed parameter shift =",.max_allowed_param_shift)
      stdout.show("Max iterations              =",.max_iterations)
      stdout.show("Min iterations              =",.min_iterations)
   
      stdout.flush
      stdout.show("Conv. tol. for shift on esd =",.tol_for_shift_on_esd)
      stdout.show("Nearly zero tolerance       =",.near_0_tol)

   end

   put_fit_table_headings
   ! Put the fit table header
      self :: IN

      stdout.flush
      stdout.text("====================")
      stdout.text("Begin rigid-atom fit")
      stdout.text("====================")
      stdout.flush
      
      ! Put table headings
      .fit_table.put_headings

   end

   put_refinement_table_headings
   ! Put the refinement table header
      self :: IN

      stdout.flush
      stdout.text("================")
      stdout.text("Begin refinement")
      stdout.text("================")
      stdout.flush
      
      ! Put table headings
      .ref_table.put_headings

   end

   put_fit_table_body
   ! Print the current iterations results
      self :: INOUT

      ! Set table body (leaky)
      .fit_table(1).set_values([.fit_iteration])
      .fit_table(2).set_values([.chi2_fit])
      .fit_table(3).set_values([.reflections.F_r_factor])
      .fit_table(4).set_values([.reflections.F_weighted_r_factor])
      .fit_table(5).set_values([.max_shift_on_esd])
      .fit_table(6).set_values([.max_shift])
      .fit_table(7).set_values([.max_shift_on_esd_par])
      .fit_table(8).set_values([.n_param])
      .fit_table(9).set_values([.near_0])
      
      ! Put out the body
      .fit_table.put_body
      
      ! Clear thje columns for next time (UNleaky!)
      .fit_table.clear_columns

   end

   put_refinement_table_body
   ! Print the current iterations results
      self :: INOUT

      ! Set table body (leaky)
       .ref_table(1).set_values([.ref_iteration])
       .ref_table(2).set_values([.fit_iteration])
       .ref_table(3).set_values([.chi2_ref0])
       .ref_table(4).set_values([.chi2_ref])
       .ref_table(5).set_values([.reflections.F_r_factor])
       .ref_table(6).set_values([.reflections.F_weighted_r_factor])
       .ref_table(7).set_values([.max_refshift_on_esd])
       .ref_table(8).set_values([.max_refshift])
       .ref_table(9).set_values([.max_refshift_on_esd_par])
      .ref_table(10).set_values([.n_param])
      .ref_table(11).set_values([.near_0])
      
      ! Put out the body
      .ref_table.put_body
      
      ! Clear thje columns for next time (UNleaky!)
      .ref_table.clear_columns

   end

   put_fit_results
   ! Put the fit results
      self :: IN

      ! Results
      stdout.flush
      stdout.text("======================")
      stdout.text("Rigid-atom fit results")
      stdout.text("======================")
      stdout.flush
      
      ! Print how it finished
      if      (.fit_converged)            then; stdout.text("Structure fit converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: fit stopped: chi2 has increased.")
                                                stdout.text("WARNING: fit results are unreliable.")
      else if (.too_many_fit_iterations)  then; stdout.text("WARNING: fit stopped: too many iterations.")
      end
      
      ! Put final fitting statistics
      .PUT:put_F_statistics

   end

   put_refinement_results
   ! Put the refinement results
      self :: IN

      ! Results
      stdout.flush
      stdout.text("============================")
      stdout.text("Structure refinement results")
      stdout.text("============================")
      stdout.flush
      
      ! Print how it finished
      if      (.refinement_converged)     then; stdout.text("Structure refinement converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: refinement stopped: chi2 has increased.")
      else if (.too_many_ref_iterations)  then; stdout.text("WARNING: refinement stopped: too many iterations.")
      end
      
      ! Put final fitting statistics
      .PUT:put_F_statistics

   end

   put_near_0_evecs(n_p)
   ! Put the near zero (linearly dependent) parameter eigenvectors
      self :: IN
      n_p :: INT, IN

         stdout.flush
         stdout.text("=======================================")
         stdout.text("Near 0 eigenvalues of the normal matrix")
         stdout.text("=======================================")
         stdout.flush
         stdout.show("No. of redundant parameters   =",n_p)
         stdout.show("No. of unique parameters      =",.n_param)
         stdout.flush
         stdout.show("Near-zero tolerance           =",.near_0_tol)
         stdout.show("No. of near-zero eigenvalues  =",.near_0)


      if (.near_0>0) then
      if (.near_0_evecs.allocated) then

         stdout.flush
         stdout.text("Near-zero eigenvalues:")
         stdout.flush
         stdout.save_style
         stdout.set_real_fortran_fmt("e")
         stdout.put(.near_0_evals)
         stdout.unsave_style

         stdout.flush
         if (.near_0<=10 OR .show_near_0_eigenvectors) then
         stdout.text("Near-zero eigenvectors:")
         stdout.flush
         stdout.put(.near_0_evecs)
         else
         stdout.text("Too many near-zero eigenvectors to write out")
         end

      end
      end

   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put out the diffraction data to file "out"
      self :: IN

      stdout.flush
      stdout.text("================")
      stdout.text("Diffraction data")
      stdout.text("================")
      stdout.flush
      stdout.show("Data kind                     =",.data_kind)
      stdout.show("Wavelength                    =",.wavelength.to_units("angstrom"))
      stdout.show("Temperature                   =",.temperature)
      stdout.show("NKA T sequence no.            =",.NKA_T_sequence_no)
      stdout.flush
      stdout.show("F_sigma_cutoff                =",.F_sigma_cutoff)
      stdout.show("F_sigma_cutoff                =",.I_sigma_cutoff)
      stdout.show("F_z_cutoff                    =",.F_z_cutoff)
      stdout.show("I_z_cutoff                    =",.I_z_cutoff)
      stdout.show("F_calc_cutoff                 =",.F_calc_cutoff)
      stdout.show("F_pred_cutoff                 =",.F_pred_cutoff)
      stdout.show("I_pred_cutoff                 =",.I_pred_cutoff)
      stdout.show("stl_high_cutoff               =",.stl_high_cutoff)
      stdout.show("stl_low_cutoff                =",.stl_low_cutoff)
      stdout.show("stl_limit                     =",.stl_limit)
      stdout.show("show_rejects?                 =",.show_rejects)
      stdout.flush
      stdout.show("partition_model               =",.partition_model)
      stdout.show("thermal_smearing_model        =",.temperature_factor_model)
      stdout.show("use_Voronoi_atoms?            =",.use_Voronoi_atoms)
      stdout.show("use_IAM_density?              =",.use_IAM_density)   
      stdout.show("use_IAM_ITC_FFs?              =",.use_IAM_ITC_FFs)   
      stdout.show("use_KM_atoms?                 =",.use_KM_atoms)   
      stdout.show("use_zero_overlap?             =",.use_zero_overlap)   
      stdout.flush
      stdout.show("refine_scale?               =",.refine_scale)
      stdout.show("scale_factor                  =",.scale_factor)
      stdout.show("refine_extinction?          =",.refine_extinction)
      stdout.show("extinction_factor             =",.extinction_factor)
      stdout.show("Correct dispersion?           =",.INQ:correct_dispersion)
      if (.INQ:correct_dispersion) then
      stdout.show("Add dispersion into F_calc    =",.add_dispersion_to_F_calc)
      stdout.show("Remove dispersion frm F_exp   =",.remove_dispersion_from_F_exp)
      end
      stdout.flush
      stdout.show("n_param                       =",.n_param)
      stdout.show("n_param_manually_set?         =",.n_param_manually_set)
      stdout.show("chi2                          =",.chi2)
      stdout.flush
      stdout.show("fit_structure?                =",.fit_structure)
      stdout.show("refine_structure?             =",.refine_structure)
      stdout.show("refine_F?                     =",.refine_F)
      stdout.show("refine_positions_only?        =",.refine_positions_only)
      stdout.show("refine_H_positions            =",.refine_H_positions)
      stdout.show("refine_ADPs_only?             =",.refine_ADPs_only)
      stdout.show("refine_H_ADPs?                =",.refine_H_ADPs)
      stdout.show("refine_H_U_iso?               =",.refine_H_U_iso)
      stdout.show("refine_anharmonicity?         =",.refine_anharmonicity)
      stdout.show("restart_HAR_with_promolecule? =",.restart_HAR_with_promolecule)
      stdout.show("XCW?                          =",.XCW)
      stdout.flush
      stdout.show("min_iterations                =",.min_iterations)
      stdout.show("max_iterations                =",.max_iterations)
      stdout.show("max_allowed_param_shift       =",.max_allowed_param_shift)
      stdout.show("tol_for_shift_on_esd          =",.tol_for_shift_on_esd)
      stdout.show("near_0_tol                    =",.near_0_tol)
      stdout.flush
      stdout.show("show_fit_output?              =",.show_fit_output)
      stdout.show("show_near_0_eigenvectors?     =",.show_near_0_eigenvectors)
      stdout.show("show_correlation_mx?          =",.show_correlation_mx)
      stdout.show("min_correlation               =",.min_correlation)
      stdout.flush
      stdout.show("fit_iteration                 =",.fit_iteration)
      stdout.show("chi2_fit                      =",.chi2_fit)
      stdout.show("chi2_fit0                     =",.chi2_fit0)
      stdout.show("max_shift                     =",.max_shift)
      stdout.show("max_shift_on_esd              =",.max_shift_on_esd)
      stdout.show("max_shift_on_esd_ind          =",.max_shift_on_esd_ind)
      stdout.show("max_shift_on_esd_par          =",.max_shift_on_esd_par)
      stdout.show("fit_converged?                =",.fit_converged)
      stdout.show("chi2_increased?               =",.chi2_increased)
      stdout.show("too_many_fit_iterations?      =",.too_many_fit_iterations)
      stdout.flush
      stdout.show("ref_iteration                 =",.ref_iteration)
      stdout.show("chi2_ref                      =",.chi2_ref)
      stdout.show("chi2_ref0                     =",.chi2_ref0)
      stdout.show("max_refshift                  =",.max_refshift)
      stdout.show("max_refshift_on_esd           =",.max_refshift_on_esd)
      stdout.show("ave_refshift_on_esd           =",.ave_refshift_on_esd)
      stdout.show("max_refshift_on_esd_ind       =",.max_refshift_on_esd_ind)
      stdout.show("max_refshift_on_esd_par       =",.max_refshift_on_esd_par)
      stdout.show("refinement_converged?         =",.refinement_converged)
      stdout.show("too_many_ref_iterations?      =",.too_many_ref_iterations)

      if (.do_residual_cube) then
      stdout.flush
      stdout.show("max_residual                  =",.max_residual)
      stdout.show("min_residual                  =",.min_residual)
      stdout.show("rms_residual                  =",.rms_residual)
      stdout.show("max_atom_residual             =",.max_atom_residual)
      stdout.show("min_atom_residual             =",.min_atom_residual)
      stdout.show("min_atom_residual_tag         =",.min_atom_residual_tag)
      stdout.show("rms_atom_residual             =",.rms_atom_residual)
      end
      
      stdout.flush
      stdout.show("n_0                           =",.n_0)
      stdout.show("near_0                        =",.near_0)

      if (.reflections.allocated) then
      stdout.flush
      stdout.text("===========")
      stdout.text("Reflections")
      stdout.text("===========")
      stdout.flush
      .PUT:put_reflection_data
      end

   end

   put_wavelength
   ! Put out the wavelength - for testing
      self :: IN
      stdout.show("DIFFRACTION_DATA wavelength =", .wavelength.to_units("angstrom"))
   end

   put_sin_theta_on_lambda
   ! Output sin(theta)/lambda for all reflections.
      self :: IN

   ENSURE(.reflections.allocated,"No list of reflections")
   ENSURE(.reflections.have_indices,"No list of reflections")

      n :: INT

      stdout.text("sin(theta)/lambda for the reflections")
      stdout.dash(int_fields=3,real_fields=1)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.put("stl")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      do n = 1,.reflections.dim
         stdout.put(.reflections(n).h1)
         stdout.put(.reflections(n).h2)
         stdout.put(.reflections(n).h3)
         stdout.put(.reflections(n).stl)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=1)

   end

   put_F_statistics
   ! Output the structure factor goodness of fit statistics.
      self :: IN

      n_unmatched :: INT

      ! Show stats without chi2(N=1)
      .reflections.put_F_statistics(show_chi2=FALSE)

      ! Get this info
      n_unmatched = .reflections.n_unmatched_Friedel_pairs

      ! No. of eflections/parameters
      stdout.show("# of reflections,    N_r       =", .reflections.dim)
      stdout.show("# of unmatched Fridel pairs    =", n_unmatched)
      stdout.show("# of fit parameters, N_p       =", .n_param)

      ! GOF statistics
      stdout.show("chi^2(N_p)                     =", .chi2)
      stdout.show("Goodness of fit (N_p)          =", sqrt(.chi2))
      stdout.show("Effective (mean) sigma^2       =", .reflections.sigma2_eff)

      ! Extinction?
      if (.refine_extinction) then;
      stdout.show("Secondary extinction factor    =", .extinction_factor)
      end

      ! Optimize scale
      if (.refine_scale AND .INQ:use_multiple_scale_factors) then
         stdout.show("Optimize extinction            =", .refine_extinction)
         stdout.show("Scale factors                  =", .scale_factors)
      else if (.refine_scale) then
         stdout.show("Using single scale factor      =", TRUE)
         stdout.show("Scale factor                   =", .scale_factor)
      else
         stdout.show("Using single scale factor      =", FALSE)
         stdout.show("Scale factor                   =", .scale_factor)
      end

   end

   put_F_free_stats
   ! Output the structure factor goodness of fit statistics.
      self :: IN
      .reflections.put_F_free_stats
   end

   put_I_free_stats
   ! Output the intensity goodness of fit statistics
      self :: IN
      .reflections.put_I_free_stats
      .PUT:put_correction_data
   end

   put_correction_data
   ! Output the correction data
      self :: IN

      stdout.flush
      stdout.show("Using scale factor(s)          =", .refine_scale)
      stdout.show("Using extinction               =", .refine_extinction)
      stdout.show("Thermal smearing model         =", .temperature_factor_model)
      stdout.show("Density partition model        =", .partition_model)
      stdout.show("Correct dispersion?            =",.INQ:correct_dispersion)
      if (.INQ:correct_dispersion) then
      stdout.show("Add dispersion into F_calc     =",.add_dispersion_to_F_calc)
      stdout.show("Remove dispersion frm F_exp    =",.remove_dispersion_from_F_exp)
      end

      if (.refine_extinction) then;
      stdout.show("Optimize extinction            =", TRUE)
      stdout.show("Secondary extinction factor    =", .extinction_factor)
      else
      stdout.show("Optimize extinction            =", FALSE)
      end

      if (.refine_scale  AND .INQ:use_multiple_scale_factors) then
      stdout.show("Using multiple scale factors   =", TRUE)
      stdout.show("Scale factors                  =", .scale_factors)
      else if (.refine_scale) then
      stdout.show("Using single scale factor      =", TRUE)
      else
      stdout.show("Using single scale factor      =", FALSE)
      end
      stdout.show("Scale factor                   =", .scale_factor)

   end


   put_reflection_data
   ! Output the reflection data and corresponding fit statistic,
   ! if available
      self :: IN

      .PUT:put_N_worst_reflections
      .PUT:put_reflections

   end

   put_worst_reflections
   ! Put out a selection of the worst-fitting reflections
      self :: IN

      n :: INT

      if (stdin.n_line_items==2) then

         ! Not nice, state not saved
         stdin.read(n)
         DIE_IF(n.is_odd,"must have an even number reflections")
         .PUT:put_N_worst_reflections(n)

      else

         .PUT:put_N_worst_reflections

      end

   end

   put_N_worst_reflections
   ! Put out a salection of the worst-fitting reflections
      self :: IN

   ENSURE(.reflections.allocated,"no reflections")

      n_refl,n :: INT

      if (.INQ:have_F_pred) then
      if (.INQ:have_F_exp) then

         n_refl = .reflections.dim

         if (.n_worst_reflections<0) then

            ! Put out a reasonable no. of bad reflections
            if      (n_refl>1000) then; .PUT:put_N_worst_reflections(n=40)
            else if (n_refl>100)  then; .PUT:put_N_worst_reflections(n=20)
            else if (n_refl>50)   then; .PUT:put_N_worst_reflections(n=10)
            end

         else

            ! Make sure users no. of reflections is reasonable
            n = min(.n_worst_reflections,n_refl)
            n = 2 * (n/2)
            .PUT:put_N_worst_reflections(n)

         end

      end
      end

   end

   put_N_worst_reflections(n)
   ! Show the "n" worst reflections, with "n" even
      self :: IN
      n :: INT

   ENSURE(.INQ:have_F_exp,"No experimental data")
   ENSURE(n.is_even,"no. of reflections n is not even")

      F_z :: VEC{REAL}@
      ind :: VEC{INT}@
      n_refl,n2 :: INT

      ! No. of old reflections
      n_refl = .reflections.dim
      if (n_refl<n) return
      n2 = n/2

      ! Get the F_z values
      F_z.create(n_refl)
      F_z = REFLECTION:F_z(.reflections)

      ! Sort
      ind.create(n_refl)
      F_z.quick_sort(ind,decreasing_order=TRUE)

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("Worst reflections")
      stdout.text("=================")
      stdout.flush
      stdout.text(". Below are the "//trim(n.to_str)//" worst-fitted reflections")
      stdout.text(". The criteria is F_z = (F_calc-F_pred)/sigma, in sigma units")
      stdout.text(". The full list of reflections is in the produced CIF file")
      stdout.flush

      ! Put worst from either end
      ind(n2+1:n) = ind(n_refl-n2+1:)
      .reflections(ind(1:n)).put

      ! Clean
      ind.destroy
      F_z.destroy

   end

   put_reflections
   ! Show all the reflections
      self :: IN

   ENSURE(.reflections.allocated,"No reflection data")

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("X-ray reflections")
      stdout.text("=================")

      ! Put
      .reflections.put

   end


   put_reflection_intensities
   ! Show all the reflections
      self :: IN

   ENSURE(.reflections.allocated,"No reflection data")

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("X-ray intensities")
      stdout.text("=================")

      ! Put
      .reflections.put_intensities

   end

   put_reflection_intensities_XD
   ! Show all the reflections
      self :: IN

   ENSURE(.reflections.allocated,"No reflection data")

      ! Header
      stdout.flush
      stdout.text("=================")
      stdout.text("X-ray intensities")
      stdout.text("=================")

      ! Put
      .reflections.put_intensities_XD

   end


   put_labelled_qq_plot(tag)
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
      self :: IN
      tag :: STR, optional, IN

   ENSURE(.reflections.allocated, "no reflection data")

      .reflections.put_labelled_F_qq_plot(tag)

   end


   put_GOF_vs_STL_table
   ! Output GOF and ratio vs. sin(theta)/lambda bins.
      self :: IN

      n_sections,i :: INT
      X_min,X_max,X_bin :: REAL
      C :: VEC{INT}@
      stl,bin,GOF,ratio,RF,RwF,RF2,RwF2, dF,Fexp,Fz,Feos :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@

      n_sections = 20

      ! Sin theta on lambda
      stl.create(.reflections.dim)
      stl = REFLECTION:stl(.reflections)

      ! Bin size ...
      X_min = minval(stl)
      X_max = maxval(stl)
      X_bin = (X_max - X_min)/n_sections

      ! Sin theta on lambda bins array for table
      bin.create(n_sections)
      bin = [ (X_min + i*X_bin, i=1,n_sections) ]

      ! GOF
      GOF.create(n_sections)
      C.create(n_sections)
      GOF.to_histogram_from_data(REFLECTION:F_z2(.reflections),stl,X_min,X_max,X_bin,C)
      GOF = sqrt(GOF/max(C-.n_param,1))

      ! ratio
      ratio.create(n_sections)
      ratio.to_histogram_from_data(REFLECTION:F_ratio(.reflections),stl,X_min,X_max,X_bin)
      ratio = ratio/max(C,1)

      ! R(F)
      RF.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
        dF.to_histogram_from_data(REFLECTION:abs_delta_F(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F_exp(.reflections)      ,stl,X_min,X_max,X_bin)
      RF = dF/Fexp
      Fexp.destroy
      dF.destroy

      ! R(F2)
      RF2.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
        dF.to_histogram_from_data(REFLECTION:abs_delta_F2(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F2_exp(.reflections)      ,stl,X_min,X_max,X_bin)
      RF2 = dF/Fexp
      Fexp.destroy
      dF.destroy

      ! Rw(F)
      RwF.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
        Fz.to_histogram_from_data(REFLECTION:F_z2(.reflections)            ,stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_2(.reflections),stl,X_min,X_max,X_bin)
      RwF = sqrt(Fz/Feos)
      Feos.destroy
      Fz.destroy

      ! Rw(F2)
      RwF2.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
        Fz.to_histogram_from_data(REFLECTION:F2_z2(.reflections)           ,stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_4(.reflections),stl,X_min,X_max,X_bin)
      RwF2 = sqrt(Fz/Feos)
      Feos.destroy
      Fz.destroy

      ! Header
      stdout.flush
      stdout.text("========================")
      stdout.text("Fit statistics vs. angle")
      stdout.text("========================")
      stdout.flush
      stdout.text("An analysis of the fit versus sin(theta)/lambda.")
      stdout.flush

      ! Table
      bin = bin*BOHR_PER_ANGSTROM
      table.create(8)
      table(1).set_heading("sin(th)/lambda"); table(1).set_values(bin)
      table(1).set_subhead("max value/A^-1")
      table(2).set_heading("# of");           table(2).set_values(C)
      table(2).set_subhead("refl")
      table(3).set_heading("GOF");            table(3).set_values(GOF)
      table(4).set_heading("F_exp");          table(4).set_values(ratio)
      table(4).set_subhead("/F_pred")
      table(5).set_heading("R(F)");           table(5).set_values(RF)
      table(6).set_heading("Rw(F)");          table(6).set_values(RwF)
      table(7).set_heading("R(F2)");          table(7).set_values(RF2)
      table(8).set_heading("Rw(F2)");         table(8).set_values(RwF2)
      table.put

      ! Clean
      table.destroy
      RwF2.destroy
      RF2.destroy
      RwF.destroy
      RF.destroy
      ratio.destroy
      C.destroy
      GOF.destroy
      bin.destroy
      stl.destroy

   end

   put_GOF_vs_F_exp_table
   ! Output GOF and ratio vs. F_exp bins.
      self :: IN

      n_sections,i :: INT
      X_min,X_max,X_bin :: REAL
      C :: VEC{INT}@
      stl,bin,GOF,ratio,RF,RwF,RF2,RwF2, dF,Fexp,Fz,Feos :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@

      n_sections = 20

      ! F_exp
      stl.create(.reflections.dim)
      stl = REFLECTION:F_exp(.reflections)

      ! Bin size ...
      X_min = minval(stl)
      X_max = maxval(stl)
      X_bin = (X_max - X_min)/n_sections

      ! Sin theta on lambda bins array for table
      bin.create(n_sections)
      bin = [ (X_min + i*X_bin, i=1,n_sections) ]

      ! GOF
      GOF.create(n_sections)
      C.create(n_sections)
      GOF.to_histogram_from_data(REFLECTION:F_z2(.reflections),stl,X_min,X_max,X_bin,C)
      GOF = sqrt(GOF/max(C-.n_param,1))

      ! ratio
      ratio.create(n_sections)
      ratio.to_histogram_from_data(REFLECTION:F_ratio(.reflections),stl,X_min,X_max,X_bin)
      ratio = ratio/max(C,1)

      ! R(F)
      RF.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
      dF.to_histogram_from_data(REFLECTION:abs_delta_F(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F_exp(.reflections),stl,X_min,X_max,X_bin)
      RF = ZERO
      where (abs(Fexp)>TOL(6))
         RF = dF/Fexp
      end
      Fexp.destroy
      dF.destroy

      ! R(F2)
      RF2.create(n_sections)
      dF.create(n_sections)
      Fexp.create(n_sections)
      dF.to_histogram_from_data(REFLECTION:abs_delta_F2(.reflections),stl,X_min,X_max,X_bin)
      Fexp.to_histogram_from_data(REFLECTION:F2_exp(.reflections),stl,X_min,X_max,X_bin)
      RF2 = ZERO
      where (abs(Fexp)>TOL(6))
         RF2 = dF/Fexp
      end
      Fexp.destroy
      dF.destroy

      ! Rw(F)
      RwF.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
      Fz.to_histogram_from_data(REFLECTION:F_z2(.reflections),stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_2(.reflections),stl,X_min,X_max,X_bin)
      RwF = ZERO
      where (abs(Feos)>TOL(6))
         RwF = sqrt(Fz/Feos)
      end
      Feos.destroy
      Fz.destroy

      ! Rw(F2)
      RwF2.create(n_sections)
      Fz.create(n_sections)
      Feos.create(n_sections)
      Fz.to_histogram_from_data(REFLECTION:F2_z2(.reflections),stl,X_min,X_max,X_bin)
      Feos.to_histogram_from_data(REFLECTION:F_exp_on_sigma_4(.reflections),stl,X_min,X_max,X_bin)
      RwF2 = ZERO
      where (abs(Feos)>TOL(6))
         RwF2 = sqrt(Fz/Feos)
      end
      Feos.destroy
      Fz.destroy

      ! Header
      stdout.flush
      stdout.text("============================")
      stdout.text("Fit statistics vs. intensity")
      stdout.text("============================")
      stdout.flush
      stdout.text("An analysis of the fit versus F_exp is shown in the table below.")
      stdout.flush

      ! Table
      table.create(8)
      table(1).set_heading("F_exp");          table(1).set_values(bin)
      table(1).set_subhead("max value")
      table(2).set_heading("# of");           table(2).set_values(C)
      table(2).set_subhead("refl")
      table(3).set_heading("GOF");            table(3).set_values(GOF)
      table(4).set_heading("F_exp");          table(4).set_values(ratio)
      table(4).set_subhead("/F_pred")
      table(5).set_heading("R(F)");           table(5).set_values(RF)
      table(6).set_heading("Rw(F)");          table(6).set_values(RwF)
      table(7).set_heading("R(F2)");          table(7).set_values(RF2)
      table(8).set_heading("Rw(F2)");         table(8).set_values(RwF2)
      table.put

      ! Clean
      table.destroy
      RwF2.destroy
      RF2.destroy
      RwF.destroy
      RF.destroy
      ratio.destroy
      C.destroy
      GOF.destroy
      bin.destroy
      stl.destroy

   end


   put_GOF_vs_STL_plot
   ! Output GOF vs. sin(theta)/lambda bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}@
      C :: VEC{INT}@
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:stl(.reflections))
      X_max = maxval(REFLECTION:stl(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_z2(.reflections),REFLECTION:stl(.reflections),X_min,X_max,X_bin,C)
      H = sqrt(H/max(C-.n_param,1))

      stdout.flush
      stdout.text("Chi^2 vs angle plot")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("GOF")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush

      C.destroy
      H.destroy

   end

   put_ratio_vs_STL_plot
   ! Output ratio vs. sin(theta)/lambda bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}@
      C :: VEC{INT}@
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:stl(.reflections))
      X_max = maxval(REFLECTION:stl(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_ratio(.reflections),REFLECTION:stl(.reflections),X_min,X_max,X_bin,C)
      H = H/max(C-.n_param,1)

      stdout.flush
      stdout.text("Ratio (F_exp/F_pred) vs. angle")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("exp/pred")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush

      C.destroy
      H.destroy

   end

   put_GOF_vs_F_exp_plot
   ! Output GOF vs. F_pred bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}@
      C :: VEC{INT}@
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:F_exp(.reflections))
      X_max = maxval(REFLECTION:F_exp(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_z2(.reflections),REFLECTION:F_exp(.reflections),X_min,X_max,X_bin,C)
      H = sqrt(H/max(C-.n_param,1))

      stdout.flush
      stdout.text("Chi^2 vs F_exp")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("GOF")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush

      C.destroy
      H.destroy

   end

   put_ratio_vs_F_exp_plot
   ! Output ratio vs. F_exp bins.
      self :: IN

      n_sections,i :: INT
      H :: VEC{REAL}@
      C :: VEC{INT}@
      X_min,X_max,X_bin,mid :: REAL

      n_sections = 20

      X_min = minval(REFLECTION:F_exp(.reflections))
      X_max = maxval(REFLECTION:F_exp(.reflections))
      X_bin = (X_max - X_min)/n_sections

      H.create(n_sections)
      C.create(n_sections)
      H.to_histogram_from_data(REFLECTION:F_ratio(.reflections),REFLECTION:F_exp(.reflections),X_min,X_max,X_bin,C)
      H = H/max(C-.n_param,1)

      stdout.flush
      stdout.text("Ratio (F_exp/F_pred) vs. F_exp")
      stdout.flush
      stdout.put("sin(T)/L")
      stdout.put("exp/pred")
      stdout.flush
      stdout.dash(real_fields=2)
      do i = 1,n_sections
         mid = (i-1)*X_min + HALF*X_bin
         stdout.put(mid)
         stdout.put(H(i))
         stdout.flush
      end
      stdout.flush

      C.destroy
      H.destroy

   end

   put_F_calc_plots(tag)
   ! Output some different plots about the calculated structure factors.
      self :: IN
      tag :: STR, optional, IN

      ext :: VEC{REAL}@
      ext_refs :: VEC{REFLECTION}@
      n,n_refl :: INT
      y,w :: REAL
      name :: STR

      name = " "
      if (present(tag)) name = tag

      n_refl = .reflections.dim

      stdout.redirect("stdout.F_z_vs_stl")

      stdout.text("# Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs sin(theta)/lambda :")
      stdout.text("# 1st column: sin(theta)/lambda")
      stdout.text("# 2nd column: (F_exp-F_pred)/F_sigma")
      stdout.text("# Note: F_exp & F_pred may have dispersion removed")
      stdout.text("# Note: Fpred may include extinction correction")
      stdout.flush

      do n = 1,n_refl
         stdout.put(.reflections(n).stl)
         stdout.put(.reflections(n).F_z)
         stdout.flush
      end

      stdout.revert

      stdout.redirect("stdout.Delta_F_vs_stl")

      stdout.text("# Scatter plot of Delta F = (F_exp-F_pred) vs sin(theta)/lambda :")
      stdout.text("# 1st column: sin(theta)/lambda")
      stdout.text("# 2nd column: Delta F = (F_exp-F_pred)")
      stdout.text("# Note: F_exp & F_pred may have dispersion removed")
      stdout.text("# Note: F_pred may include extinction correction")
      stdout.flush
      stdout.flush

      do n = 1,n_refl
         stdout.put(.reflections(n).stl)
         stdout.put(.reflections(n).delta_F)
         stdout.flush
      end

      stdout.revert

      stdout.redirect("stdout.F_z_vs_F_exp")

      stdout.text("# Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs F_exp :")
      stdout.text("# 1st column: Fexp")
      stdout.text("# 2nd column: (Fexp-Fpred)/F_sigma")
      stdout.text("# Note: F_exp & F_pred may have dispersion removed")
      stdout.text("# Note: F_pred may include extinction correction")
      stdout.flush

      do n = 1,n_refl
         stdout.put(.reflections(n).F_corr)
         stdout.put(.reflections(n).F_z)
         stdout.flush
      end

      stdout.revert

      if (NOT .refine_extinction) return

      ! Only do this if extinction was used
      ext_refs.create(n_refl)
      ext.create(n_refl)
      ext = .INQ:F_scale_and_extn_correction
      ext_refs.set_F_corr( .reflections.F_pred/ext)
      ext_refs.set_F_pred( .reflections.F_pred)
      ext_refs.set_F_sigma(.reflections.F_sigma)
      ext.destroy

      w = ZERO
      y = ZERO
      do n = 1,n_refl
         y = y + abs(ext_refs(n).F_z)
         w = w + abs(ext_refs(n).F_r)
      end
      y = y / n_refl
      w = w / n_refl

      stdout.redirect("stdout.Delta_F_pred_z_vs_F_pred")

      stdout.text("# The effects of intensity on extinction:")
      stdout.text("# ")
      stdout.text("# Plot of [F_pred(without ext)-F_pred(with ext)]/F_sigma vs F_pred(without ext):")
      stdout.text("# 1st column: F_pred(without extinction")
      stdout.text("# 2nd column: [F_pred(without ext)-F_pred(with ext)]/F_sigma")
      stdout.text("# Note: Fexp & F_pred may have dispersion removed")
      stdout.text("# ")
      stdout.show("# Average value of abs[Fpred(without ext)-Fcalc(with ext)]/F_sigma  = ",y)
      stdout.show("# Average value of abs(extinction correction)                       = ",w)
      do n = 1,n_refl
         stdout.put(ext_refs(n).F_pred)
         stdout.put(ext_refs(n).F_z)
         stdout.flush
      end

      stdout.revert

      stdout.redirect("stdout.Delta_F_pred_z_vs_stl")

      stdout.text("# The effects of scattering angle on extinction:")
      stdout.text("# ")
      stdout.text("# Plot of [Fpred(without ext)-Fpred(with ext)]/F_sigma vs sin(theta)/lambda:")
      stdout.text("# 1st column: sin(theta)/lambda")
      stdout.text("# 2nd column: [F_pred(without ext)-F_pred(with ext)]/F_sigma")
      stdout.text("# Note: F_exp & F_pred may have dispersion removed")
      do n = 1,n_refl
         stdout.put(.reflections(n).stl)
         stdout.put(ext_refs(n).F_z)
         stdout.flush
      end

      stdout.revert

      ext_refs.destroy

   end

!   put_PND_sf(name)
!   ! Output the magnetic structure factors
!      self :: IN
!      name :: STR, IN
!
!      FM_s,FM_l :: VEC{CPX}@
!      arch :: ARCHIVE
!      n :: INT
!
!      FM_s.create(.reflections.dim)
!      arch.set(name,"PND_spin_sf")
!      arch.read(FM_s)
!
!      FM_l.create(.reflections.dim)
!      arch.set(name,"PND_nabla_sf")
!      arch.read(FM_l)
!
!      stdout.text("PND magnetic structure factors:")
!      stdout.flush
!      stdout.dash(int_fields=3,real_fields=3)
!      stdout.put("h", int_width=TRUE)
!      stdout.put("k", int_width=TRUE)
!      stdout.put("l", int_width=TRUE)
!      stdout.put("FM_s")
!      stdout.put("FM_l")
!      stdout.put("FM")
!      stdout.flush
!      stdout.dash(int_fields=3,real_fields=3)
!      do n = 1, .reflections.dim
!         stdout.put(.reflections(n).h1)
!         stdout.put(.reflections(n).h2)
!         stdout.put(.reflections(n).h3)
!         stdout.put(real(FM_s(n)) )
!         stdout.put(real(FM_l(n)) )
!         stdout.put(real(FM_s(n)+FM_l(n)) )
!         stdout.flush
!      end
!      stdout.dash(int_fields=3,real_fields=3)
!
!      FM_l.destroy
!      FM_s.destroy
!
!   end

end
