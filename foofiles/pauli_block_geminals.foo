!-------------------------------------------------------------------------------
!
! PAULI_BLOCK_GEMINALS
!
! Copyright (C) Patrick Cassam-Chenai and Thomas Perez, 2018
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module PAULI_BLOCK_GEMINALS

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

   !!!
!   saved_self :: PAULI_BLOCK_GEMINALS* DEFAULT_NULL
   pbg_saved :: PAULI_BLOCK_GEMINALS*
   !!!

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create ::: leaky
   ! Create a pauli_block_geminals
      self :: PTR
      nullify(self)
      allocate(self)
   !   .nullify_ptr_part
   end

   create(vec,n) ::: leaky
   ! Create a vector of PAULI_BLOCK_GEMINALS
     vec :: VEC{PAULI_BLOCK_GEMINALS}*
     n :: INT

     nullify(vec)
     allocate(vec(n))

   end

   create(vec,n_geminals) ::: leaky
   ! Create a set of PBT
     vec :: VEC{PAULI_BLOCK_TENSOR}*
     n_geminals :: INT

     nullify(vec)
     allocate(vec(n_geminals))

   end

   create(vec,n) ::: leaky
   ! Create a vector of 2RDM non zero elements
     vec :: VEC{PAULI_BLOCK_2RDM_ELT}*
     n :: INT

     nullify(vec)
     allocate(vec(n))

   end

   create(vec,n) ::: leaky
   ! Create a vector of objects with information to compute the
   ! derivative of the 2RDM
     vec :: VEC{PAULI_BLOCK_2RDM_GRAD_INFO}*
     n :: INT

     nullify(vec)
     allocate(vec(n))

   end

   create(gradient,n) ::: leaky
   ! Create a vector of energy gradient elements
     gradient :: VEC{ENERGY_GRADIENT_ELT}*
     n :: INT

     nullify(gradient)
     allocate(gradient(n))

   end

   create_ptr_part(grad_info,nterms,ngem,nblk) ::: leaky
   ! Create the pointer parts of a PAULI_BLOCK_2RDM_GRAD_INFO object
     grad_info :: PAULI_BLOCK_2RDM_GRAD_INFO
     nterms, ngem, nblk :: INT

     grad_info.ex_gem.create(nterms,ngem)
     grad_info.ex_blk.create(nterms,nblk)
     grad_info.term.create(nterms)
     grad_info.factor.create(nterms)
     grad_info.all_pairs.create(nterms)
     grad_info.coef_prod.create(nterms)

   end

   destroy(gradient) ::: leaky
   ! Destroy a vector of energy gradient elements
     gradient :: VEC{ENERGY_GRADIENT_ELT}*

     deallocate(gradient)
     nullify(gradient)

   end

   destroy(vec) ::: leaky
   ! Destroy a vector of PAULI_BLOCK_GEMINALS
     vec :: VEC{PAULI_BLOCK_GEMINALS}*
     i,n :: INT
     n=size(vec)
     do i=1,n
       vec(i).destroy_ptr_part
     end
     deallocate(vec)
     nullify(vec)

   end

   destroy_ptr_part(grad_info) ::: leaky
   ! Destroy the pointer parts of a PAULI_BLOCK_2RDM_GRAD_INFO object
     grad_info :: PAULI_BLOCK_2RDM_GRAD_INFO

     grad_info.ex_gem.destroy
     grad_info.ex_blk.destroy
     grad_info.term.destroy
     grad_info.factor.destroy
     grad_info.all_pairs.destroy
     grad_info.coef_prod.destroy

   end


   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   destroy_ptr_part ::: leaky
   ! destroy the pointer parts of a PAULI_BLOCK_GEMINALS object
     new_item :: VEC_INT_LIST*
     
     .nonzero_coef_ind.destroy
     .nonzero_coef_prod.destroy
     new_item=>.int_term_ind
     do
       if (NOT associated(new_item)) exit
       .int_term_ind.item.destroy
       new_item=>.int_term_ind.next
       deallocate(.int_term_ind)
       .int_term_ind=>new_item
     end
     nullify(new_item)
     .nonzero_1ortho_ind.destroy
     .rdm_1.destroy
     if(associated(.rdm_2_ab)) then 
       deallocate(.rdm_2_ab)
     end
     if(associated(.rdm_2_aa)) then 
       deallocate(.rdm_2_aa)
     end
     if(associated(.rdm_2_bb)) then 
       deallocate(.rdm_2_bb)
     end
     .orbital_block_mapping.destroy
     .block_types.destroy
     .non_diag_set.destroy
     .diag_set.destroy
     .block_1orthos.destroy

   end

!  ===========
!  Set methods
!  ===========

      
! davide: 16-11-2018
   set_defaults(n_el,n_bf,mol_name, nuclear_repulsion_energy)
   ! set defaults for n_geminals, n_blocks, mat_size, 
   ! n_1D_blocks, bra_is_ket, spin_restricted, mol_name
   n_el, n_bf :: INT, IN
   mol_name :: STR, IN
   nuclear_repulsion_energy :: REAL, IN
   nn, dif :: INT
   ms :: INT
     
     ! set nuclear_repulsion_energy
     .nuclear_repulsion_energy=nuclear_repulsion_energy
     ! set number of electrons
     .n_el = n_el
     ! set number of basis functions
     .n_bf = n_bf
     ! set n_geminals
     .n_geminals = (n_el+1)/2
     ! set n_gem_singlet
     ms = .spin_multi
     .n_gem_singlet = (n_el-ms+1)/2 
     ! set n_blocks
     .n_blocks = .n_geminals+(n_bf-.n_geminals+1)/2
     ! set mat_size (PBT size)
     nn = (n_el/2)*2
     if (nn /= n_el) then
        .mat_size = n_bf+1
     else
        .mat_size = n_bf
     end
     !
     ! set n_1D_blocks (number of 1-orthogonal blocks in each PBT)
     dif = .mat_size-.n_gem_singlet
     nn = (dif/2)*2
     if (nn /= dif) then
       .n_1D_blocks = .n_gem_singlet+1
     else
       .n_1D_blocks = .n_gem_singlet
     end
     !
     .n_2D_blocks = .n_blocks-.n_1D_blocks
     .n_2D_3typ_blocks = 0
     .n_2D_4typ_blocks = .n_blocks-.n_1D_blocks
     !
     ! set first_block
     if (.n_1D_blocks > 0) then
       .first_block = 0
     else
       .first_block = 1
     end
     !
     .gen_block=FALSE
     ! set bra_is_ket (if bra set is equal to ket set)
     .bra_is_ket = TRUE
     ! set spin_restricted
     .spin_restricted = TRUE
     ! set mol_name
     .name = mol_name
     ! set guess_type
     .guess_type = "hf"
     ! set random_scaling
     .random_scaling = 0.01d0
     !
     .only_4typ = FALSE

   end
! de

   set_matrix_form
   ! make matrix form from coef and block types for bra_set and ket_set if different
     .make_matrix_form(.bra_set)
     if (NOT .bra_is_ket) then
       .make_matrix_form(.ket_set)
     end
   end
      
   initialize_GD2 ::: leaky
   ! initialize GD2 diagonal elements
   i :: INT

     if (NOT .first_GD2_elt.created) then
        .first_GD2_elt.create(.n_2D_3typ_blocks)
     end
     if (NOT .second_GD2_elt.created) then
        .second_GD2_elt.create(.n_2D_3typ_blocks)
     end
     ! compute GD2 diagonal elements
     do i=1,.n_2D_3typ_blocks
       .first_GD2_elt(i) = sin(.GD2_info(i))*SQRT_2
       .second_GD2_elt(i) = cos(.GD2_info(i))*SQRT_2
     end

   end

   make_matrix_form(mat_set)
   ! make matrix form from coef and block types
     mat_set :: PAULI_BLOCK_TENSOR_SET
     i,j,last :: INT
     !
     do i=1,.n_geminals
       allocate(mat_set.vec(i).matrix_form(.mat_size,.mat_size))
       mat_set.vec(i).matrix_form=ZERO
       last=0
       do j=1,.n_blocks         
         select case (mat_set.vec(i).block_type(j))
           case ("ID1");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("ID2");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("SZ");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=-mat_set.vec(i).coef(j)
           case ("SX");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case ("ISY");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=-mat_set.vec(i).coef(j)
           case ("GD2");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)*.first_GD2_elt(j-.n_1D_blocks)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)*.second_GD2_elt(j-.n_1D_blocks)
           case ("E11");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last-1)=mat_set.vec(i).coef(j)
           case ("E22");
             last=last+2
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("S+");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
           case ("S-");
             last=last+2
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case  default ; stdout.text("unknown matrix type")
             stop
         end
       end
     end           

   end

   make_type_numbers(subset) ::: leaky
   ! make type_numbers for each block of a subset of pauli_block_tensor
     subset :: PAULI_BLOCK_TENSOR_SET
     n_gem,i :: INT
     n_blocks,j :: INT

     n_gem=subset.vec.dim
     n_blocks=subset.vec(1).block_type.dim
     
     if(NOT subset.type_nb.created) then
       subset.type_nb.create(n_blocks)
     end

     do j=1,n_blocks
       subset.type_nb(j).element.create(9)
       subset.type_nb(j).element=0
     end
     
     do i=1,n_gem
       do j=1,n_blocks
         select case (subset.vec(i).block_type(j))       
            case("ID1"); 
              subset.type_nb(j).element(1)=subset.type_nb(j).element(1)+1     
            case("ID2");                                               
              subset.type_nb(j).element(2)=subset.type_nb(j).element(2)+1
            case("SZ"); 
              subset.type_nb(j).element(3)=subset.type_nb(j).element(3)+1
            case("SX");                                               
              subset.type_nb(j).element(4)=subset.type_nb(j).element(4)+1     
            case("ISY");                                              
              subset.type_nb(j).element(5)=subset.type_nb(j).element(5)+1
            case("GD2"); 
              subset.type_nb(j).element(6)=subset.type_nb(j).element(6)+1      
            case("E11");                                              
              subset.type_nb(j).element(7)=subset.type_nb(j).element(7)+1     
            case("E22");                                              
              subset.type_nb(j).element(8)=subset.type_nb(j).element(8)+1     
            case("S+");                                               
              subset.type_nb(j).element(9)=subset.type_nb(j).element(9)+1
            case("S-");                                               
              subset.type_nb(j).element(10)=subset.type_nb(j).element(10)+1
            case default ;
              stdout.text("Error unknown block type")
              stop
         end
       end
     end
   end

   prep_red_pbg(red_pbg,g) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g :: INT, IN
     i, j, siz :: INT
     siz_prod :: INT


     ! prepare information to compute the overlap, excluding geminal g
     do i=1,.n_geminals
        if (i < g) then
           ! create vector of nonzero block indices
           siz = .nonzero_coef_ind(i).element.dim
           red_pbg.nonzero_coef_ind(i).element.destroy
           red_pbg.nonzero_coef_ind(i).element.create(siz)
           red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(i).element.destroy
           red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
        else if (i > g) then
           j = i-1
           ! create vector of nonzero block indices
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.destroy
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.destroy
           red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
        end
     end
   end

   prep_red_pbg(red_pbg,g,gg) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg :: INT, IN
     ENSURE(g /= gg,"the two geminals are the same")
     i, j, k, siz :: INT
     t, tt :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end     
!     ! alternative:
!     t = min(g,gg)
!     tt = max(g,gg)

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        if (i < t) then
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(i).element.destroy
           red_pbg.nonzero_coef_ind(i).element.create(siz)
           red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(i).element.destroy
           red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(j).element.destroy
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.destroy
           red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(k).element.destroy
           red_pbg.nonzero_coef_ind(k).element.create(siz)
           red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(k).element.destroy
           red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
        end
     end
   end

   prep_red_pbg(red_pbg,g,b,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g and block b;
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! belonging to the 1-orthogonal blocks space
   !problem is true when a geminal other than g, deprived from block b, becomes 0
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, b :: INT, IN
     problem :: BIN
     i, j, k, siz :: INT
     presence :: BIN
     ind :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     ! and block b

     problem = FALSE

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence = FALSE
        do k=1,siz
           if (.nonzero_coef_ind(i).element(k) == b) then
              presence = TRUE
              ind = k
              exit
           end
        end
        if (i < g) then
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(i).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
        else if (i > g) then  ! to skip geminal g and shift the geminals with i > g by -1
           j = i-1
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vectors of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(j).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create list of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (NOT presence) then
              ! create vectors of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create list of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg,g,b,bb,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
   !problem is true when a geminal other than g, deprived from block b or bb, becomes 0
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, b, bb :: INT, IN
     problem :: BIN
     ENSURE(b /= bb,"the two blocks are the same")
     i, j, l, siz :: INT
     b1, b2 :: INT
     presence1, presence2 :: BIN
     ind1, ind2 :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     ! and blocks b and bb

     problem = FALSE

     if (b < bb) then
        b1=b
        b2=bb
     else if (b > bb) then
        b1=bb
        b2=b
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence1 = FALSE
        presence2 = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b1) then
              presence1 = TRUE
              ind1 = l
              exit
           end
        end
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b2) then
              presence2 = TRUE
              ind2 = l
              exit
           end
        end
        if (i < g) then
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-2)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > g) then ! to skip geminal g and shift the following geminals by -1
           j = i-1
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-2)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg_g(red_pbg,g,gg,b,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
   !problem is true when a geminal other than g or gg, deprived from block b, becomes 0
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg, b :: INT, IN
     problem :: BIN
     ENSURE(g /= gg,"the two geminals are the same")
     i, j, k, l, siz :: INT
     t, tt :: INT
     presence :: BIN
     ind :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     ! and block b

     problem = FALSE

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b) then
              presence = TRUE
              ind = l
              exit
           end
        end

        if (i < t) then
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(i).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(j).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(k).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz)
              red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg,g,gg,b,bb,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
   !problem is true when a geminal other than g or gg, deprived from block b or bb, becomes 0
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg, b, bb :: INT, IN
     problem :: BIN
     ENSURE(g /= gg,"the two geminals are the same")
     ENSURE(b /= bb,"the two blocks are the same")
     i, j, k, l, siz :: INT
     t, tt, b1, b2 :: INT
     presence1, presence2 :: BIN
     ind1, ind2 :: INT
     siz_prod :: INT
     ! prepare information to compute the overlap, excluding geminals g and gg
     ! and blocks b and bb

     problem = FALSE

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end
     if (b < bb) then
        b1=b
        b2=bb
     else if (b > bb) then
        b1=bb
        b2=b
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence1 = FALSE
        presence2 = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b1) then
              presence1 = TRUE
              ind1 = l
              exit
           end
        end
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b2) then
              presence2 = TRUE
              ind2 = l
              exit
           end
        end
        if (i < t) then
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-2)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-2)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(k).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(k).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-2)
              red_pbg.nonzero_coef_ind(k).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(k).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(k).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz)
              red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg, gg) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals "gg";
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! or an element of the derivative of the 2RDM with respect to a given 
   ! block coefficient
   ! --------------------------------------------------------------------
   ! red_pbg = new PBG
   ! gg = indices of the geminals to be excluded
   ! n_ex_gem = total number of geminals to be excluded
     red_pbg :: PAULI_BLOCK_GEMINALS
     gg :: VEC{INT}, IN
 !    n_ex_gem :: INT, IN
     n_ex_gem :: INT
     pbg_created, exclude_gem :: BIN
     i, j, siz, count_ex_gem, ng :: INT

     ! set and check the number of geminals in the PBG 
     ! to be prepared
     n_ex_gem = gg.dim
     ng = .n_geminals-n_ex_gem
     if (ng <= 0) then
        stdout.text("Error in prep_red_pbg gg:")
        stdout.text("the number of geminals to be excluded is equal to") 
        stdout.text("or exceeds the total number of geminals.")
        stop
     end

     ! check if PBG has been already created and, 
     ! if already created, check its size
     ! (actually, here we check only if the vector of vectors
     ! ".nonzero_coef_ind" has been already created)
     pbg_created = red_pbg.nonzero_coef_ind.created
     if (pbg_created) then
        if (ng /= red_pbg.n_geminals) then
           red_pbg.nonzero_coef_ind.destroy
           red_pbg.nonzero_coef_prod.destroy
           red_pbg.n_geminals = ng
           red_pbg.nonzero_coef_ind.create(ng)
           red_pbg.nonzero_coef_prod.create(ng)
           red_pbg.first_block=.first_block
        end
     else
        red_pbg.n_geminals = ng
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
        red_pbg.first_block=.first_block
     end

     ! prepare information to compute the reduced 
     ! overlap, excluding geminals "gg"
     count_ex_gem = 0
     do i=1,.n_geminals
        exclude_gem = any(gg(1:n_ex_gem) == i)
        if (exclude_gem) then
           count_ex_gem = count_ex_gem+1
           cycle
        else
           j = i-count_ex_gem
           ! create a new vector of nonzero block indices
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_ind(j).element.destroy
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create a new vector of nonzero products of coefficients
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_prod(j).element.destroy
           siz = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.create(siz)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
        end
     end

   end

   prep_red_pbg(red_pbg, gg, bb, problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals "gg"
   ! and 2D blocks "bb"; this new PBG will be used to compute an element 
   ! of the 1RDM or 2RDM, or an element of the derivative of the 2RDM
   ! with respect to a given block coefficient
   ! --------------------------------------------------------------------
   ! red_pbg = new PBG
   ! gg = indices of the geminals to be excluded
   ! n_ex_gem = total number of geminals to be excluded
   ! bb = indices of the 2D blocks to be excluded
   ! n_ex_blk = total number of 2D blocks to be excluded
     red_pbg :: PAULI_BLOCK_GEMINALS
     gg, bb :: VEC{INT}, IN
     !n_ex_gem, n_ex_blk :: INT, IN
     problem :: BIN, INOUT
     n_ex_gem, n_ex_blk :: INT
     pbg_created, exclude_gem, exclude_blk :: BIN
     i, j, k, l :: INT
     siz, count_ex_gem, ng :: INT
     count_ex_blk, nb, ib, nz_blk :: INT
     !!! debug
!     stdout.text("Entering routine prep_red_pbg_gg_bb")
     !!!

     ! check if PBG has been created before and, 
     ! if already created, check its size
     ! (actually, here we check only if the vector of vectors
     ! ".nonzero_coef_ind" has been already created)
     n_ex_gem=gg.dim
     n_ex_blk=bb.dim
     pbg_created = red_pbg.nonzero_coef_ind.created
     ng = .n_geminals-n_ex_gem
     if (pbg_created) then
        if (ng /= red_pbg.n_geminals) then
           red_pbg.nonzero_coef_ind.destroy
           red_pbg.nonzero_coef_prod.destroy
           red_pbg.n_geminals = ng
           red_pbg.nonzero_coef_ind.create(ng)
           red_pbg.nonzero_coef_prod.create(ng)
           red_pbg.first_block=.first_block
        end
     else
        red_pbg.n_geminals = ng
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
        red_pbg.first_block=.first_block
     end

     ! prepare information to compute the reduced overlap, 
     ! excluding geminals "gg" and blocks "bb"
     problem = FALSE
     count_ex_gem = 0
     do i=1,.n_geminals
        exclude_gem = any(gg(1:n_ex_gem) == i)
        if (exclude_gem) then
           count_ex_gem = count_ex_gem+1
           cycle
        else
           j = i-count_ex_gem
           ! create a new vector of nonzero block indices
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_ind(j).element.destroy
           nz_blk = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.create(nz_blk)
           ! construct "nonzero_coef_ind" excluding blocks "bb" 
           ! (if present among the nonzero blocks)
           count_ex_blk = 0
           do k=1,nz_blk
              ib = .nonzero_coef_ind(i).element(k)
              exclude_blk = any(bb(1:n_ex_blk) == ib)
              if (exclude_blk) then
                 count_ex_blk = count_ex_blk+1
                 cycle
              else
                 l = k-count_ex_blk
                 red_pbg.nonzero_coef_ind(j).element(l) = .nonzero_coef_ind(i).element(k)
              end
           end
           !!!
           !!! debug
!           stdout.show("geminal", i)
!           stdout.show("nz_blk       =", nz_blk)
!           stdout.show("count_ex_blk =", count_ex_blk)
           ! old
           !!!
!           if (nz_blk <= 1 AND count_ex_blk /= 0) then
!              problem = TRUE
!              return
!           end
!           !!!
!           nb = nz_blk-count_ex_blk
!           red_pbg.nonzero_coef_ind(j).element.shrink(nb)
           !!!
           ! new
           nb = nz_blk-count_ex_blk
           !!! debug
!           stdout.show("nb =", nb)
           !!!
           if (nb == 0) then
              ! all nonzero block in geminal "i" has to be excluded;
              ! hence, the reduced overalp will be ZERO
              problem = TRUE
              !!! debug
!              stdout.text("PROBLEM = TRUE")
              !!!
              return
           end
           red_pbg.nonzero_coef_ind(j).element.shrink(nb)
           !!!
           !!! debug
!           stdout.show("block indices, geminal", i)
!           stdout.put(red_pbg.nonzero_coef_ind(j).element)
           !!!
           ! create a new vector of nonzero products of coefficients
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_prod(j).element.destroy
           siz = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.create(siz)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
           !!! debug
!           stdout.show("coefficient products, geminal", i)
!           stdout.put(red_pbg.nonzero_coef_prod(j).element)
           !!!
        end
     end

   end

! davide: 27-11-2018
   prep_orbital_block_mapping
   ! prepare the vector containing the orbital 
   ! to block correspondence 
     i, d :: INT

     .orbital_block_mapping.create(.mat_size)

     ! 1-orthogonal blocks
     do i=1,.n_1D_blocks 
        .orbital_block_mapping(i) = 0
     end

     ! Pauli blocks
     do i=.n_1D_blocks+1,.mat_size 
         d = i-.n_1D_blocks+1
        .orbital_block_mapping(i) = int(d/2)
     end

   !debug stdout.text(" ")
   !debug stdout.text("Orbitals to blocks mapping:")
   !debug stdout.put(.orbital_block_mapping)

   end

   prep_block_types
   ! prepare the vector of vectors containing the indices of geminal
   ! for the 5 block types ID2, SZ, SX, ISY, GD2
     i :: INT
     n_pauli_blocks :: INT
     
     ! create vector of vectors "block_types"
     n_pauli_blocks = .n_blocks-.n_1D_blocks 
     .block_types.create(n_pauli_blocks)
     do i=1,n_pauli_blocks
        .block_types(i).element.create(5)
        .block_types(i).element = 0
     end

     ! prepare "block_types"
     do i=1,.n_geminals
        .prep_block_types(.bra_set.vec(i),i)
     end

     ! write "block_types"
   !debug stdout.text(" ")
   !debug stdout.text("Block types vectors:")
!     do i=1,n_pauli_blocks
!      !debug stdout.text(" ")
!      !debug stdout.show("2D block", i)
!      !debug stdout.put(.block_types(i).element)
!     end

   end

   prep_geminal_sets ::: leaky
   ! prepare the diagonal and non-diagonal sets of geminals for each 2D-block
     ENSURE(.n_2D_blocks>0,"no 2D-block")
     ENSURE(.block_types(1).element.created,"block_types(1).element does not exist")
     i,counter_diag,counter_ndiag :: INT
     n_pauli_blocks :: INT
     geminal_set :: VEC{INT}(5)
     
     n_pauli_blocks=.n_2D_blocks
     ! create vector of vectors "diag_set" and "non_diag_set"
     .diag_set.create(n_pauli_blocks)
     .non_diag_set.create(n_pauli_blocks)
     .any_type_set.create(n_pauli_blocks)

     do i=1,n_pauli_blocks
       geminal_set=.block_types(i).element

       counter_diag=0
       if(geminal_set(1)>0) counter_diag=counter_diag+1
       if(geminal_set(2)>0) counter_diag=counter_diag+1
       if(geminal_set(5)>0) counter_diag=counter_diag+1
       .diag_set(i).element.create(counter_diag)
       counter_ndiag=0
       if(geminal_set(3)>0) counter_ndiag=counter_ndiag+1
       if(geminal_set(4)>0) counter_ndiag=counter_ndiag+1
       .non_diag_set(i).element.create(counter_ndiag)
       .any_type_set(i).element.create(counter_ndiag+counter_diag)

       counter_diag=0
       if(geminal_set(1)>0) then
         counter_diag=counter_diag+1
         .diag_set(i).element(counter_diag)=geminal_set(1)
         .any_type_set(i).element(counter_diag)=geminal_set(1)
       end
       if(geminal_set(2)>0) then
         counter_diag=counter_diag+1
         .diag_set(i).element(counter_diag)=geminal_set(2)
         .any_type_set(i).element(counter_diag)=geminal_set(2)
       end
       if(geminal_set(5)>0) then
         counter_diag=counter_diag+1
         .diag_set(i).element(counter_diag)=geminal_set(5)
         .any_type_set(i).element(counter_diag)=geminal_set(5)
       end
       counter_ndiag=0
       if(geminal_set(3)>0) then
         counter_ndiag=counter_ndiag+1
         .non_diag_set(i).element(counter_ndiag)=geminal_set(3)
         .any_type_set(i).element(counter_diag+counter_ndiag)=geminal_set(3)
       end
       if(geminal_set(4)>0) then
         counter_ndiag=counter_ndiag+1
         .non_diag_set(i).element(counter_ndiag)=geminal_set(4)
         .any_type_set(i).element(counter_diag+counter_ndiag)=geminal_set(4)
       end
     end

   end

   make_set_intersection(set_1,set_2,set_3) ::: leaky
   ! make a vector which contains the common values of two vectors of integers
     set_1,set_2 :: VEC{INT}*, IN
     set_3 :: VEC{INT}*, OUT
     i,counter :: INT
     
     if(set_1.dim==0 OR set_2.dim==0) then
       set_3.create(0)
       return
     end

     counter=0
     do i=1,set_1.dim
       if ( any(set_2 == set_1(i)) ) counter=counter+1
     end
     set_3.create(counter)

     counter=0
     do i=1,set_1.dim
       if ( any(set_2 == set_1(i)) ) then
         counter=counter+1
         set_3(counter)=set_1(i)
       end
     end

   end

   make_set_complement(set_1,set_2) ::: leaky
   ! make a vector which contains the common values of two vectors of integers
     set_1 :: VEC{INT}*, IN
     set_2 :: VEC{INT}*, OUT
     i, counter :: INT
     set_2.create(.n_geminals-set_1.dim)

     counter=0
     do i=1,.n_geminals
       if (NOT any(set_1 == i) ) then
         counter=counter+1
         set_2(counter)=i
       end
     end

   end

   prep_block_types(pbt,g)
   ! prepare "block types", checking each geminal
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT, IN
     i, j, n :: INT

     do i=.n_1D_blocks+1,.n_blocks
        if (abs(pbt.coef(i)) > NON_ZERO_BLOCK_TOL ) then
           n = .select_block_type(pbt.block_type(i))
           j = i - .n_1D_blocks
           .block_types(j).element(n) = g
        end
     end

   end

   select_block_type(bty) result(n)
   ! select the block type and provide an integer
   ! for the preparation of "block types"
     bty :: STR, IN
     n :: INT

     select case (bty)
        case("ID2") 
           n = 1
        case("SZ") 
           n = 2
        case("SX") 
           n = 3
        case("ISY") 
           n = 4
        case("GD2") 
           n = 5
        case default   
           stdout.text("unrecognized block type")
           stop
     end

   end
! de

   prep_block_1orthos
   ! prepare the vector containing the indices of geminal
   ! for the 1-orthogonal part
     i :: INT
     
     ! create vector "block_1orthos"
     .block_1orthos.create(.n_1D_blocks)
     do i=1,.n_1D_blocks
        .block_1orthos(i) = 0
     end

     ! prepare "block_1orthos"
     do i=1,.n_geminals
        .prep_block_1orthos(.bra_set.vec(i),i)
     end

     ! write "block_1orthos"
   !debug stdout.text(" ")
   !debug stdout.text("1-orthogonal block vector:")
     do i=1,.n_1D_blocks
      !debug stdout.text(" ")
      !debug stdout.show("1-orthogonal block", i)
      !debug stdout.show("geminal", .block_1orthos(i))
     end

   end

   prep_block_1orthos(pbt,g)
   ! prepare "block 1orthos", checking each geminal
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT, IN
     i :: INT

     do i=1,.n_1D_blocks
        if (abs(pbt.coef(i)) > NON_ZERO_BLOCK_TOL ) then
           .block_1orthos(i) = g
        end
     end

   end


!  ====================================
!  RANDOM GENARATOR OF SETS OF GEMINALS
!  ====================================

! davide: 20-11-2018 / 01-10-2019
   random_geminals_generator ::: leaky
   ! generate random geminals which satisfy 
   ! the constraints of the model
     bra_not_created, ket_not_created :: BIN
     !bra_not_alloc, ket_not_alloc :: BIN

     ! if guess_type is "hf-random", set block partition;
     ! else the block partition defined in routine "set_defaults"
     ! or in the input (keyword "block_partition=") will be employed
     if (.guess_type == "hf-random") then
       .set_block_partition_hf
     end

     ! check if the bra and ket sets are already created;
     ! if not, create them
     bra_not_created = NOT .bra_set.vec(1).coef.created
!     ket_not_created = NOT .ket_set.vec(1).coef.created
!     stdout.show("bra_not_created =",bra_not_created)
!     stdout.text(" ")
     if (bra_not_created) then 
        .create_pbt_set(.bra_set)
     else
        .destroy_pbt_set(.bra_set)
        .create_pbt_set(.bra_set)
     end
     !
     if (NOT .bra_is_ket) then
        ket_not_created = NOT .ket_set.vec(1).coef.created
!        stdout.show("ket_not_created =",ket_not_created)
!        stdout.text(" ")
        if (ket_not_created) then 
           .create_pbt_set(.ket_set)
        else
           .destroy_pbt_set(.ket_set)
           .create_pbt_set(.ket_set)
        end
     end

     !!!!!!!!
     ! debug
     !     stdout.show("spin_restricted =",.spin_restricted)
     !!!!!!!!

     if (.spin_restricted) then
        .guess_geminals_restricted
     else
        .guess_geminals_unrestricted
     end

   end

   create_pbt_set(pbt_set) ::: leaky
   ! create a set of geminals (i.e. Pauli Block Tensors) 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, n_1D_blocks_plus_1 :: INT

!     stdout.text(" ")
!     stdout.text("creation of a set of geminals")

     ! allocate a set of Pauli Block Tensors (PBT) 
     allocate(pbt_set.vec(.n_geminals))

     ! set the number of geminals, 
     ! the number of blocks and
     ! the spin restrictions
     pbt_set.set_size=.n_geminals
     pbt_set.set_size_sing=.n_gem_singlet
     pbt_set.n_blocks=.n_blocks
     pbt_set.n_1D_blocks=.n_1D_blocks
     pbt_set.n_2D_blocks=.n_2D_blocks
     pbt_set.n_2D_3typ_blocks=.n_2D_3typ_blocks
     pbt_set.n_2D_4typ_blocks=.n_2D_4typ_blocks
     pbt_set.spin_restricted=.spin_restricted

     n_1D_blocks_plus_1 = .n_1D_blocks+1
     do i=1,.n_geminals 
        ! create the vectors of block types,
        ! block dimensions and coefficients
        pbt_set.vec(i).block_type.create(.n_blocks)
        pbt_set.vec(i).block_dim.create(.n_blocks)
        pbt_set.vec(i).coef.create(.n_blocks)
        ! set the block dimensions
        pbt_set.vec(i).block_dim(1:.n_1D_blocks) = 1
        pbt_set.vec(i).block_dim(n_1D_blocks_plus_1:.n_blocks) = 2
        ! set the number of 1D and 2D blocks
        ! in each PBT
        pbt_set.vec(i).n_1D_blocks=.n_1D_blocks
        pbt_set.vec(i).n_2D_blocks=.n_2D_blocks
     end

     ! make the vector of numbers of block types
     ! for each block
     .make_type_numbers(pbt_set)

   end

   destroy_pbt_set(pbt_set) ::: leaky
   ! destroy a set of geminals (i.e. Pauli Block Tensors) 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, set_size, n_blocks :: INT

!     stdout.text(" ")
!     stdout.text("destruction of a set of geminals")

     ! destroy the set of geminals
     set_size = pbt_set.set_size
     do i=1,set_size
        ! create the vectors of block types,
        ! block dimensions and coefficients
        pbt_set.vec(i).block_type.destroy
        pbt_set.vec(i).block_dim.destroy
        pbt_set.vec(i).coef.destroy
     end
     ! deallocate a set of Pauli Block Tensors (PBT) 
     deallocate(pbt_set.vec)

     ! destroy the vector of numbers of block types
     ! for each block
     if(pbt_set.type_nb.created) then
        n_blocks = pbt_set.type_nb.dim
        do i=1,n_blocks
          pbt_set.type_nb(i).element.destroy
        end
        pbt_set.type_nb.destroy
     end

   end

   set_block_partition_hf
   ! set block partition in case of HF or 
   ! HF-random set of geminals
     ms, dif, nn :: INT

     ! set number of geminals
     .n_geminals = (.n_el+1)/2
     !
     ! set number of spin singlet geminals
     ms = .spin_multi
     .n_gem_singlet = (.n_el-ms+1)/2 
     !
     ! set number of blocks
     .n_blocks = .n_geminals+(.n_bf-.n_geminals+1)/2
     !
     ! set number of blocks of size 1 in each PBT
     dif = .mat_size-.n_gem_singlet
     nn = (dif/2)*2
     if (nn /= dif) then
       .n_1D_blocks = .n_gem_singlet+1
     else
       .n_1D_blocks = .n_gem_singlet
     end
     ! set first_block
     if (.n_1D_blocks > 0) then
       .first_block = 0
     else
       .first_block = 1
     end
     !
     ! set number of blocks of size 2 in each PBT
     .n_2D_blocks = .n_blocks-.n_1D_blocks
     .n_2D_3typ_blocks = 0
     .gen_block=FALSE
     .n_2D_4typ_blocks = .n_blocks-.n_1D_blocks
     !
     if (.GD2_info.created) then 
       .GD2_info.destroy
     end

   end

! spin restricted

! davide: 20-11-2018 / 01-10-2019
   guess_geminals_restricted ::: leaky
   ! generate guess set of geminals in the 
   ! spin restricted case
     i :: INT

   !debug 
     stdout.text(" ")
   !debug 
     if (.guess_type == "hf-random") then
        !stdout.text("Mixed HF-random guess set:")
        stdout.text(" ")
        stdout.show("random_scaling =",.random_scaling)
!     else
!        stdout.text("Random guess set:")
     end
     stdout.text(" ")
     stdout.text("Bra set:")
     !
     ! make 1D block structure
     .make_1D_blocks(.bra_set)
     ! make 2D block structure
     .make_2D_blocks_restricted(.bra_set)
     !
     !!!!!!!!!!
     ! debug
     stdout.text(" ")
     stdout.show("# 1D blocks =",.bra_set.n_1D_blocks)
     stdout.show("# 2D blocks =",.bra_set.n_2D_blocks)
     stdout.show("# 2D 3type blocks =",.bra_set.n_2D_3typ_blocks)
     stdout.show("# 2D 4type blocks =",.bra_set.n_2D_4typ_blocks)
     stdout.text(" ")
     !
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end
     if (.bra_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end
     !!!!!!!!!!

     if (.bra_is_ket) then
        ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
       ! stdout.text(" ")
       ! stdout.text("Randomly generated ket set:")
       ! 
       ! do i=1,.n_geminals
       !  !debug stdout.text(" ")
       !  !debug stdout.show("geminal",i)
       !  !debug stdout.text("block structure:")
       !  !debug stdout.put(.ket_set.vec(i).block_type)
       !  !debug stdout.text("coefficients:")
       !  !debug stdout.put(.ket_set.vec(i).coef)
       ! end
     else
        stdout.text(" ")
        stdout.text("Ket set:")
        !
        ! make 1D block structure
        .make_1D_blocks(.ket_set)
        ! make 2D block structure
        .make_2D_blocks_restricted(.ket_set)
        !
        !!!!!!!!!!
        ! debug
        stdout.text(" ")
        stdout.show("# 1D blocks =",.ket_set.n_1D_blocks)
        stdout.show("# 2D blocks =",.ket_set.n_2D_blocks)
        stdout.show("# 2D 3type blocks =",.ket_set.n_2D_3typ_blocks)
        stdout.show("# 2D 4type blocks =",.ket_set.n_2D_4typ_blocks)
        stdout.text(" ")
        do i=1,.n_geminals
           stdout.text(" ")
           stdout.show("geminal",i)
           stdout.text("block structure:")
           stdout.put(.ket_set.vec(i).block_type)
           stdout.text("coefficients:")
           stdout.put(.ket_set.vec(i).coef)
        end
        if (.ket_set.n_2D_3typ_blocks > 0) then
           stdout.text(" ")
           stdout.text("Angles defining GD2 matrices:")
           !stdout.text("GD2 info vector:")
           stdout.put(.GD2_info)
        end
        !!!!!!!!!!
     end

   end

   make_1D_blocks(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the blocks of size 1 (of each geminal)
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, set_size, n_1D_blocks :: INT
     num :: REAL
     mixed_hf_random :: BIN

     set_size = pbt_set.set_size  ! number of geminals
     n_1D_blocks = pbt_set.n_1D_blocks  ! number of blocks of size 1 (1D)
     !
     ! in case of spin restricted, if a doublet or triplet state
     ! is selected, build the 1D block structure for the last geminal
     ! (zero coefficient for each 1D block), and decrement "set_size" by 1
     if (.spin_restricted AND .spin_multi>1) then
        pbt_set.vec(set_size).block_type(1:n_1D_blocks) = "ID1"
        pbt_set.vec(set_size).coef(1:n_1D_blocks) = ZERO
        set_size = set_size-1
     end
     !
     ! check if the random set has to be: (i) mixed HF-random,
     ! or (ii) random
     mixed_hf_random = FALSE
     if (.guess_type == "hf-random")  mixed_hf_random = TRUE
     !
     if (mixed_hf_random) then
        do i=1,set_size
           ! assign block type ID1 to each 1D block
           pbt_set.vec(i).block_type(1:n_1D_blocks) = "ID1"
           ! set coefficients for the the first "set_size" 1D blocks (HF part)
           pbt_set.vec(i).coef(1:n_1D_blocks) = ZERO
           pbt_set.vec(i).coef(i) = ONE
        end
     else
        do i=1,set_size
           ! assign block type ID1 to each 1D block
           pbt_set.vec(i).block_type(1:n_1D_blocks) = "ID1"
           ! generate coefficients for the first "set_size" 1D blocks
           pbt_set.vec(i).coef(1:n_1D_blocks) = ZERO
           call random_number(num)
           pbt_set.vec(i).coef(i) = (num - HALF)*TWO
        end
     end
     ! generate coefficients for the last 
     ! (n_1D_blocks-set_size) 1D blocks
     ! (if n_1D_blocks > set_size)
     do i=set_size+1,n_1D_blocks
        call random_number(num)
        j = int(num*set_size)+1  ! selection of the j-th geminal
        call random_number(num)                    ! generation of the coefficient for
        pbt_set.vec(j).coef(i) = (num - HALF)*TWO  ! the i-th 1D block of geminal j
        ! in case of a mixed HF-random set of geminals,
        ! the coefficient is scaled
        if (mixed_hf_random) then
           num = pbt_set.vec(j).coef(i)
           pbt_set.vec(j).coef(i) = num*.random_scaling
        end
     end

   end

   make_2D_blocks_restricted(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the blocks of size 2 (2D) of each geminal 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, k, set_size, n_1D_blocks, n_blocks :: INT
     set_size_minus_1, set_size_minus_2 :: INT
     gem :: VEC{INT}(3)
     num :: REAL
     n_2D_3typ_blocks :: INT
     n_2D_4typ_blocks :: INT
     b_3typ :: VEC{STR}(2)
     b_4typ :: VEC{STR}(3)
     n_2D_blocks :: INT
!     n_2D_blocks_plus_1 :: INT
     mixed_hf_random :: BIN

     set_size = pbt_set.set_size ! number of geminals
     n_blocks = pbt_set.n_blocks ! number of blocks
     n_1D_blocks = pbt_set.n_1D_blocks ! number of blocks of size 1 (1D)
     n_2D_blocks = pbt_set.n_2D_blocks ! number of blocks of size 2 (2D)

     ! check if the random set has to be: (i) mixed HF-random,
     ! or (ii) random
     mixed_hf_random = FALSE
     if (.guess_type == "hf-random")  mixed_hf_random = TRUE

!     !!!!
!     ! check if only 4-type blocks have to be included in the 2D part 
!     !!!!

     ! if a doublet or a triplet state is selected,
     ! build the 2D block structure for the last geminal
     ! (and decrement "set_size" by 1)
     if (.spin_multi == 2) then
        ! doublet state:
        ! nonzero coefficient only for the last 2D block,
        ! the one with one orbital at infinity
        pbt_set.vec(set_size).block_type(n_1D_blocks+1:n_blocks-1) = "ID2"
        pbt_set.vec(set_size).block_type(n_blocks) = "SX"
        pbt_set.vec(set_size).coef(n_1D_blocks+1:n_blocks-1) = ZERO
        call random_number(num)
        pbt_set.vec(set_size).coef(n_blocks) = (num - HALF)*TWO
        set_size = set_size-1
     else if (.spin_multi == 3) then
        ! triplet state:
        ! all 2D blocks of type "ISY", each with a nonzero coefficient
        if (mixed_hf_random) then
           i = n_1D_blocks+1
           pbt_set.vec(set_size).block_type(i) = "ISY"
           pbt_set.vec(set_size).coef(i) = ONE/SQRT_2
           do i=n_1D_blocks+2,n_blocks
              pbt_set.vec(set_size).block_type(i) = "ISY"
              call random_number(num)
              pbt_set.vec(set_size).coef(i) = (num - HALF)*TWO*.random_scaling
           end
        else
           do i=n_1D_blocks+1,n_blocks
              pbt_set.vec(set_size).block_type(i) = "ISY"
              call random_number(num)
              pbt_set.vec(set_size).coef(i) = (num - HALF)*TWO
           end
        end
        set_size = set_size-1
     end

     ! inizialize the 2D block structure and coefficients
     do i=1,set_size
        pbt_set.vec(i).coef(n_1D_blocks+1:n_blocks) = ZERO
        pbt_set.vec(i).block_type(n_1D_blocks+1:n_blocks) = "ID2"
     end
     ! decide the number of 2D blocks with at most 3 types (3typ)
     ! and the one with at most 4 types (4typ)
     !!!!
     if (.only_3typ) then
        n_2D_3typ_blocks = n_2D_blocks
        n_2D_4typ_blocks = 0
     else if (.only_4typ) then
        n_2D_3typ_blocks = 0
        n_2D_4typ_blocks = n_2D_blocks
     else
        call random_number(num)
        n_2D_3typ_blocks = int(num*(n_2D_blocks+1))
        n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     end if
!     n_2D_blocks_plus_1 = n_2D_blocks+1
!     call random_number(num)
!     n_2D_3typ_blocks = int(num*n_2D_blocks_plus_1)
!     n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     !!!!
     ! total number of 2D 3typ blocks
     pbt_set.n_2D_3typ_blocks = n_2D_3typ_blocks
     .n_2D_3typ_blocks = n_2D_3typ_blocks
!     stdout.show("# 2D 3typ blocks =", n_2D_3typ_blocks)
     ! set binary variable "gen_block"
     if (n_2D_3typ_blocks > 0) then
        .gen_block = TRUE
        ! prepare vector of angles for 3typ blocks
        if (.GD2_info.created) then
           .GD2_info.destroy
           .GD2_info.create(n_2D_3typ_blocks)
        else
           .GD2_info.create(n_2D_3typ_blocks)
        end
     else
        .gen_block = FALSE
     end
     ! total number of 2D 4typ blocks
     pbt_set.n_2D_4typ_blocks = n_2D_4typ_blocks
     .n_2D_4typ_blocks = n_2D_4typ_blocks
!     stdout.show("# 2D 4typ blocks =", n_2D_4typ_blocks)
     !
     set_size_minus_1 = set_size-1
     set_size_minus_2 = set_size-2
     !
     ! loop over the 2D 3TYP BLOCKS
     !
     do i=n_1D_blocks+1,n_1D_blocks+n_2D_3typ_blocks
        ! select 2 singlet geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
        end
        ! assign a type of Pauli block (type3) and a coefficient
        ! to each of the 2 selected geminals
        call random_number(num)
        j = int(num*2)
        b_3typ = .select_block_2D_3typ_res(j)
        do k=1,min(2,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_3typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
        ! assign an angle (between 0 and Pi, Pi excluded)
        call random_number(num)
        j = i-n_1D_blocks
        .GD2_info(j) = num*PI 
     end
     !
     ! loop over the 2D 4TYP BLOCKS
     !
     do i=n_1D_blocks+n_2D_3typ_blocks+1,n_blocks
        ! select 3 spin singlet geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
           end
        end
        ! assign a type of Pauli block (type4) and a coefficient
        ! to each of the 3 selected geminals
        call random_number(num)
        j = int(num*6)
        b_4typ = .select_block_2D_4typ_res(j)
        do k=1,min(3,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_4typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
     end

     ! in case of a mixed HF-random set of geminals,
     ! all the coefficients of the 2D blocks (of the
     ! spin singlet geminals) are scaled
     if (mixed_hf_random) then
        j = n_1D_blocks+1
        k = n_blocks
        do i=1,set_size
           pbt_set.vec(i).coef(j:k) = pbt_set.vec(i).coef(j:k)*.random_scaling
        end
     end

   end

   select_block_2D_3typ_res(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the block types (GD2, SX)
     integ :: INT, IN
     b_types :: VEC{STR}(2)

     select case (integ)
        case(0)
           b_types(1) = "GD2"
           b_types(2) = "SX"
        case(1)
           b_types(1) = "SX"
           b_types(2) = "GD2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
     end

   end

   select_block_2D_4typ_res(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the pauli block types (ID2, SX, SZ)
     integ :: INT, IN
     b_types :: VEC{STR}(3)

     select case (integ)
        case(0)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "SZ"
        case(1)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "SX"
        case(2)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
        case(3)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
        case(4)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "SX"
        case(5)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ID2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
      end

   end
! de

! spin unrestricted

! davide 01-10-2019
   guess_geminals_unrestricted ::: leaky
   ! generate guess set of geminals in the 
   ! spin unrestricted case
     i :: INT

   !debug 
     stdout.text(" ")
   !debug 
     if (.guess_type == "hf-random") then
!        stdout.text("Mixed HF-random guess bra set:")
        stdout.text(" ")
        stdout.show("random_scaling =",.random_scaling)
!     else
!        stdout.text("Random guess bra set:")
     end
     stdout.text(" ")
     stdout.text("Bra set:")
     !
     ! make 1D block structure
     .make_1D_blocks(.bra_set)
     ! make 2D block structure
     .make_2D_blocks_unrestricted(.bra_set)
     !
     !!!!!!!!!!
     ! debug
     stdout.text(" ")
     stdout.show("n_1D_blocks =",.bra_set.n_1D_blocks)
     stdout.show("n_2D_blocks =",.bra_set.n_2D_blocks)
     stdout.show("n_2D_3typ_blocks =",.bra_set.n_2D_3typ_blocks)
     stdout.show("n_2D_4typ_blocks =",.bra_set.n_2D_4typ_blocks)
     stdout.text(" ")
     do i=1,.n_geminals
       stdout.text(" ")
       stdout.show("geminal",i)
       stdout.text("block structure:")
       stdout.put(.bra_set.vec(i).block_type)
       stdout.text("coefficients:")
       stdout.put(.bra_set.vec(i).coef)
     end
     if (.bra_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end
     !!!!!!!!!!

     if (.bra_is_ket) then
        ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
       ! stdout.text(" ")
       ! stdout.text("Randomly generated ket set:")
       ! 
       ! do i=1,.n_geminals
       !  !debug stdout.text(" ")
       !  !debug stdout.show("geminal",i)
       !  !debug stdout.text("block structure:")
       !  !debug stdout.put(.ket_set.vec(i).block_type)
       !  !debug stdout.text("coefficients:")
       !  !debug stdout.put(.ket_set.vec(i).coef)
       ! end
     else
        stdout.text(" ")
        stdout.text("Ket set:")
        !
        ! make 1D block structure
        .make_1D_blocks(.ket_set)
        ! make 2D block structure
        .make_2D_blocks_unrestricted(.ket_set)
        !
        !!!!!!!!!!!!!
        !!!! debug
        stdout.text(" ")
        stdout.show("n_1D_blocks =",.ket_set.n_1D_blocks)
        stdout.show("n_2D_blocks =",.ket_set.n_2D_blocks)
        stdout.show("n_2D_3typ_blocks =",.ket_set.n_2D_3typ_blocks)
        stdout.show("n_2D_4typ_blocks =",.ket_set.n_2D_4typ_blocks)
        stdout.text(" ")
        do i=1,.n_geminals
          stdout.text(" ")
          stdout.show("geminal",i)
          stdout.text("block structure:")
          stdout.put(.ket_set.vec(i).block_type)
          stdout.text("coefficients:")
          stdout.put(.ket_set.vec(i).coef)
        end
        if (.ket_set.n_2D_3typ_blocks > 0) then
           stdout.text(" ")
           stdout.text("Angles defining GD2 matrices:")
           !stdout.text("GD2 info vector:")
           stdout.put(.GD2_info)
        end
        !!!!!!!!!!!!!
     end

   end

   make_2D_blocks_unrestricted(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the blocks of size 2 (2D) of each geminal 
   ! in the spin unrestricted case
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, k, set_size, n_1D_blocks, n_blocks :: INT
     set_size_minus_1, set_size_minus_2 :: INT
     set_size_minus_3 :: INT
     gem :: VEC{INT}(4)
     num :: REAL
     n_2D_3typ_blocks :: INT
     n_2D_4typ_blocks :: INT
     b_3typ :: VEC{STR}(3)
     b_4typ :: VEC{STR}(4)
     n_2D_blocks :: INT
     !
     l, n, dum :: INT
     w :: VEC{INT}(3)
     !

     set_size = pbt_set.set_size ! set_size = n_geminals
     n_blocks = pbt_set.n_blocks ! n_blocks = total number of blocks
     n_1D_blocks = pbt_set.n_1D_blocks ! n_1D_blocks = number of blocks of size 1
     n_2D_blocks = pbt_set.n_2D_blocks ! n_2D_blocks = number of blocks of size 2

     ! inizialize the 2D block structure and coefficients
     do i=1,set_size
        pbt_set.vec(i).coef(n_1D_blocks+1:n_blocks) = ZERO
        pbt_set.vec(i).block_type(n_1D_blocks+1:n_blocks) = "ID2"
     end

     ! decide the number of 2D blocks with at most 3 types (3typ)
     ! and the one with at most 4 types (4typ)
     !!!
     if (.only_3typ) then
        n_2D_3typ_blocks = n_2D_blocks
        n_2D_4typ_blocks = 0
     else if (.only_4typ) then
        n_2D_3typ_blocks = 0
        n_2D_4typ_blocks = n_2D_blocks
     else
        call random_number(num)
        n_2D_3typ_blocks = int(num*(n_2D_blocks+1))
        n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     end if

     ! total number of 2D 3typ blocks 
     pbt_set.n_2D_3typ_blocks = n_2D_3typ_blocks
     .n_2D_3typ_blocks = n_2D_3typ_blocks
!     stdout.show("# 2D 3typ blocks =", n_2D_3typ_blocks)
     ! set binary variable "gen_block"
     if (n_2D_3typ_blocks > 0) then
        .gen_block = TRUE
        ! prepare vector of angles for 3typ blocks
        if (.GD2_info.created) then
           .GD2_info.destroy
           .GD2_info.create(n_2D_3typ_blocks)
        else
           .GD2_info.create(n_2D_3typ_blocks)
        end
     else
        .gen_block = FALSE
     end
!     ! prepare vector of angles for 3typ blocks
!     if (.GD2_info.created) then
!        .GD2_info.destroy
!        .GD2_info.create(n_2D_3typ_blocks)
!     else
!        .GD2_info.create(n_2D_3typ_blocks)
!     end
     ! total number of 2D 4typ blocks 
     pbt_set.n_2D_4typ_blocks = n_2D_4typ_blocks
     .n_2D_4typ_blocks = n_2D_4typ_blocks
!     stdout.show("# 2D 4typ blocks =", n_2D_4typ_blocks)

     set_size_minus_1 = set_size-1
     set_size_minus_2 = set_size-2
     set_size_minus_3 = set_size-3
     !
     ! loop over the 2D 3TYP BLOCKS
     !
     do i=n_1D_blocks+1,n_1D_blocks+n_2D_3typ_blocks
        ! select 3 geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
           end
        end
        ! assign a type of Pauli block (type3) and a coefficient
        ! to each of the 2 selected geminals
        call random_number(num)
        j = int(num*6)
        b_3typ = .select_block_2D_3typ_unres(j)
        do k=1,min(3,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_3typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
        ! assign an angle (between 0 and Pi, Pi excluded)
        call random_number(num)
        j = i-n_1D_blocks
        .GD2_info(j) = num*PI 
     end
     !
     ! loop over the 2D 4TYP BLOCKS
     !
     do i=n_1D_blocks+n_2D_3typ_blocks+1,n_blocks
        ! select 4 geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
              if (set_size > 3) then
                   ! 4th geminal
                 call random_number(num)
                 j = int(num*set_size_minus_3)+1
                 !!!!!!!!!!
                 ! sort indices of the 3 previously selected 
                 ! geminals in increasing order (and store 
                 ! them in working array "w")
                 n = 3
                 do k=1,n
                    w(k) = gem(k)
                 end
                 do k=1,n-1
                    do l=k+1,n
                       if (w(k) > w(l)) then
                          ! swap w(k) and w(l)
                          dum = w(l)
                          w(l) = w(k)
                          w(k) = dum
                       end
                    end
                 end
                 !!!!!!!!!!
                 ! select the 4th geminal
                 if ( j < w(1) ) then
                    gem(4) = j
                 else if ( j >= w(3)-2 ) then
                    gem(4) = j+3
                 else if ( j >= w(1) AND j < w(2)-1 ) then 
                    gem(4) = j+1
                 else
                    ! if ( j >= w(2)-1 AND j < w(3)-2 )
                    gem(4) = j+2
                 end
              end
           end
        end
        ! assign a type of Pauli block (type4) and a coefficient
        ! to each of the 4 selected geminals
        call random_number(num)
        j = int(num*24)
        b_4typ = .select_block_2D_4typ_unres(j)
        do k=1,min(4,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_4typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
     end

     ! in case of a mixed HF-random set of geminals,
     ! all the coefficients of the 2D blocks are scaled
     if (.guess_type == "hf-random") then
        j = n_1D_blocks+1
        k = n_blocks
        do i=1,set_size
           pbt_set.vec(i).coef(j:k) = pbt_set.vec(i).coef(j:k)*.random_scaling
        end
     end

   end

   select_block_2D_3typ_unres(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the block types (GD2, SX, ISY)
     integ :: INT, IN
     b_types :: VEC{STR}(3)

     select case (integ)
        case(0)
           b_types(1) = "GD2"
           b_types(2) = "SX"
           b_types(3) = "ISY"
        case(1)
           b_types(1) = "GD2"
           b_types(2) = "ISY"
           b_types(3) = "SX"
        case(2)
           b_types(1) = "SX"
           b_types(2) = "GD2"
           b_types(3) = "ISY"
        case(3)
           b_types(1) = "SX"
           b_types(2) = "ISY"
           b_types(3) = "GD2"
        case(4)
           b_types(1) = "ISY"
           b_types(2) = "GD2"
           b_types(3) = "SX"
        case(5)
           b_types(1) = "ISY"
           b_types(2) = "SX"
           b_types(3) = "GD2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
      end

   end

   select_block_2D_4typ_unres(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the 4 pauli block types (ID2, SX, SZ, ISY)
     integ :: INT, IN
     b_types :: VEC{STR}(4)

     select case (integ)
        case(0)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "SZ"
           b_types(4) = "ISY"
        case(1)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "ISY"
           b_types(4) = "SZ"
        case(2)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "SX"
           b_types(4) = "ISY"
        case(3)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "ISY"
           b_types(4) = "SX"
        case(4)
           b_types(1) = "ID2"
           b_types(2) = "ISY"
           b_types(3) = "SX"
           b_types(4) = "SZ"
        case(5)
           b_types(1) = "ID2"
           b_types(2) = "ISY"
           b_types(3) = "SZ"
           b_types(4) = "SX"
        !
        case(6)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
           b_types(4) = "ISY"
        case(7)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "ISY"
           b_types(4) = "SZ"
        case(8)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
           b_types(4) = "ISY"
        case(9)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ISY"
           b_types(4) = "ID2"
        case(10)
           b_types(1) = "SX"
           b_types(2) = "ISY"
           b_types(3) = "ID2"
           b_types(4) = "SZ"
        case(11)
           b_types(1) = "SX"
           b_types(2) = "ISY"
           b_types(3) = "SZ"
           b_types(4) = "ID2"
        !
        case(12)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "SX"
           b_types(4) = "ISY"
        case(13)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "ISY"
           b_types(4) = "SX"
        case(14)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ID2"
           b_types(4) = "ISY"
        case(15)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ISY"
           b_types(4) = "ID2"
        case(16)
           b_types(1) = "SZ"
           b_types(2) = "ISY"
           b_types(3) = "ID2"
           b_types(4) = "SX"
        case(17)
           b_types(1) = "SZ"
           b_types(2) = "ISY"
           b_types(3) = "SX"
           b_types(4) = "ID2"
        !
        case(18)
           b_types(1) = "ISY"
           b_types(2) = "ID2"
           b_types(3) = "SX"
           b_types(4) = "SZ"
        case(19)
           b_types(1) = "ISY"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
           b_types(4) = "SX"
        case(20)
           b_types(1) = "ISY"
           b_types(2) = "SX"
           b_types(3) = "ID2"
           b_types(4) = "SZ"
        case(21)
           b_types(1) = "ISY"
           b_types(2) = "SX"
           b_types(3) = "SZ"
           b_types(4) = "ID2"
        case(22)
           b_types(1) = "ISY"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
           b_types(4) = "SX"
        case(23)
           b_types(1) = "ISY"
           b_types(2) = "SZ"
           b_types(3) = "SX"
           b_types(4) = "ID2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
      end

   end
! de

! davide 07-10-2019
   guess_geminals_hf ::: leaky
   ! generate Hartree-Fock (HF) set of geminals
     i :: INT
     bra_not_created, ket_not_created :: BIN

     ! set block partition;
     .set_block_partition_hf

     ! check if the bra and ket sets are already created;
     ! if not, create them
     bra_not_created = NOT .bra_set.vec(1).coef.created
!     ket_not_created = NOT .ket_set.vec(1).coef.created
!     stdout.show("bra_not_created =",bra_not_created)
!     stdout.text(" ")
     if (bra_not_created) then 
        .create_pbt_set(.bra_set)
     else
        .destroy_pbt_set(.bra_set)
        .create_pbt_set(.bra_set)
     end
     !
     if (NOT .bra_is_ket) then
        ket_not_created = NOT .ket_set.vec(1).coef.created
!        stdout.show("ket_not_created =",ket_not_created)
!        stdout.text(" ")
        if (ket_not_created) then 
           .create_pbt_set(.ket_set)
        else
           .destroy_pbt_set(.ket_set)
           .create_pbt_set(.ket_set)
        end
     end

!     ! check if the bra and ket sets are already created;
!     ! if not, create them
!     bra_not_created = NOT .bra_set.vec(1).coef.created
!     ket_not_created = NOT .ket_set.vec(1).coef.created
!!     stdout.show("bra_not_created =",bra_not_created)
!!     stdout.show("ket_not_created =",ket_not_created)
!!     stdout.text(" ")
!     if (.bra_is_ket) then
!        ! if bra and ket sets are the same
!        if (bra_not_created) then 
!           .create_pbt_set(.bra_set)
!        end
!     else
!        ! if bra and ket sets are different
!        if (bra_not_created AND ket_not_created) then 
!           .create_pbt_set(.bra_set)
!           .create_pbt_set(.ket_set)
!        else if (bra_not_created) then 
!           .create_pbt_set(.bra_set)
!        else if (ket_not_created) then 
!           .create_pbt_set(.ket_set)
!        end
!     end
     
     stdout.text("Hartree-Fock guess bra set:")
     ! make the block structure of the set
     .make_blocks_hf(.bra_set)
     !!!!!!!!!!
     ! debug
     stdout.text(" ")
     stdout.show("# 1D blocks =",.bra_set.n_1D_blocks)
     stdout.show("# 2D blocks =",.bra_set.n_2D_blocks)
     stdout.show("# 2D 3type blocks =",.bra_set.n_2D_3typ_blocks)
     stdout.show("# 2D 4type blocks =",.bra_set.n_2D_4typ_blocks)
     stdout.text(" ")
     !
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end
     !
     if (.bra_is_ket) then
        ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
     else
        stdout.text(" ")
        stdout.text("Hartree-Fock guess ket set:")
        ! make the block structure of the set
        .make_blocks_hf(.ket_set)
        !
        do i=1,.n_geminals
           stdout.text(" ")
           stdout.show("geminal",i)
           stdout.text("block structure:")
           stdout.put(.ket_set.vec(i).block_type)
           stdout.text("coefficients:")
           stdout.put(.ket_set.vec(i).coef)
        end
     end

   end

   make_blocks_hf(pbt_set)
   ! make the block structure of the Hartree-Fock (HF) set of geminals
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     set_size, n_blocks, n_1D_blocks :: INT
     i :: INT
     !
     set_size = pbt_set.set_size  ! number of geminals
     n_blocks = pbt_set.n_blocks ! number of blocks
     n_1D_blocks = pbt_set.n_1D_blocks  ! number of blocks of size 1 (1D)
     !
!     ! in case of a spin restricted calculation,
!     ! if a doublet or a triplet state is selected,
!     ! build the 2D block structure for the last geminal
!     ! (and decrement "set_size" by 1)
!     if (.spin_restricted) then
!        if (.spin_multi == 2) then
!           ! doublet state:
!           ! nonzero coefficient only for the last (2D) block,
!           ! the one with one orbital at infinity
!           pbt_set.vec(set_size).block_type(1:n_1D_blocks) = "ID1"
!           pbt_set.vec(set_size).block_type(n_1D_blocks+1:n_blocks-1) = "ID2"
!           pbt_set.vec(set_size).block_type(n_blocks) = "SX"
!           pbt_set.vec(set_size).coef(1:n_blocks-1) = ZERO
!           pbt_set.vec(set_size).coef(n_blocks) = ONE/SQRT_2
!           set_size = set_size-1
!        else if (.spin_multi == 3) then
!           ! triplet state:
!           ! nonzero coefficient only for the first 2D block,
!           pbt_set.vec(set_size).block_type(1:n_1D_blocks) = "ID1"
!           pbt_set.vec(set_size).block_type(n_1D_blocks+1:n_blocks) = "ISY"
!           pbt_set.vec(set_size).coef(1:n_blocks) = ZERO
!           pbt_set.vec(set_size).coef(n_1D_blocks+1) = ONE/SQRT_2
!           set_size = set_size-1
!        end
!     end
     !
     ! make the block structure
     do i=1,set_size
        ! assign block type ID1 to each 1D block
        pbt_set.vec(i).block_type(1:n_1D_blocks) = "ID1"
        ! assign block type ID2 to each 2D block
        pbt_set.vec(i).block_type(n_1D_blocks+1:n_blocks) = "ID2"
        ! set block coefficients
        pbt_set.vec(i).coef(1:n_blocks) = ZERO
        pbt_set.vec(i).coef(i) = ONE
     end

   end
! de


!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end


!  ===============
!  INPUT Routines
!  ===============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
 !      case ("do_overlap              "); .do_overlap
 !      case ("do_hamiltonian          "); .do_hamiltonian
       case ("junk=                   "); .read_junk
 !      case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       case ("n_geminals=             "); .read_n_geminals
!       case ("n_blocks=               "); .read_n_blocks
       case ("bra_is_ket=             "); .read_bra_is_ket
       case ("bra_set=                "); .read_bra_set
       case ("ket_set=                "); .read_ket_set
       case ("readin_mos=             "); .read_readin_mos
       case ("guess_type=             "); .read_guess_type
       case ("gd2_info=               "); .read_GD2_info
       case ("make_integrals=         "); .read_make_integrals
       case ("add_core=               "); .read_add_core
 !      case ("gen_block=              "); .read_gen_block
       case ("set_matrix_form         "); .set_matrix_form
       case ("spin_restricted=        "); .read_spin_restricted
       case ("block_partition=        "); .read_block_partition
       case ("n_singlet_geminals=     "); .read_n_singlet_geminals
       case ("random_scaling=         "); .read_random_scaling
       case ("calc_gradient=          "); .read_calc_gradient
       case ("opt_gd2_angles=         "); .read_opt_GD2_angles
       case ("max_it=                 "); .read_max_it
       case ("step=                   "); .read_step
       case ("coef_tol=               "); .read_coef_tol
       case ("grad_tol=               "); .read_grad_tol
       !!!
       case ("only_3typ=              "); .read_only_3typ
       case ("only_4typ=              "); .read_only_4typ
       !!!
       !!! to debug code
       case ("debug=                  "); .read_debug
       !!!
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_make_integrals
   ! Read  make_integrals flag
     stdin.read(.make_integrals)
   end

   read_add_core
   ! Read  add_core flag
     stdin.read(.add_core)
   end

   read_n_geminals
   ! Read number of geminals
   !  self :: PTR
     n_geminals :: INT
     stdin.read(n_geminals)
     .n_geminals=n_geminals
   end

   read_bra_is_ket
   ! Read TRUE if the bra and the ket have the same geminals, else read FALSE
   !  self :: PTR
     bra_is_ket :: BIN
     stdin.read(bra_is_ket)
     .bra_is_ket=bra_is_ket
   end 

   read_bra_set ::: leaky
   ! Read all the blocks of the geminals of the bra
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT

     ! check if guess_type is "readin";
     ! if not, stop the program execution
     if (.guess_type /= "readin") then
        stdout.text(" ")
        stdout.text("provide keyword guess_type= readin, before the input bra_set")
        stop
     end
!     ! check if block partition has already been read;
!     ! if not, call routine "read_block_partiton"
!     if (NOT .block_partition_read) then
!        .read_block_partition 
!     end
!     ! check if GD2 angles have already been read;
!     ! if not, call routine "read_GD2_info"
!     if (NOT .GD2_info_read) then
!        .read_GD2_info
!     end
     !
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.bra_set.vec(.n_geminals))
     .bra_set.set_size=.n_geminals
     .bra_set.set_size_sing=.n_gem_singlet
     .bra_set.n_blocks=.n_blocks
     .bra_set.n_1D_blocks=.n_1D_blocks
     .bra_set.n_2D_blocks=.n_2D_blocks
     .bra_set.n_2D_3typ_blocks=.n_2D_3typ_blocks
     .bra_set.n_2D_4typ_blocks=.n_2D_4typ_blocks
     .bra_set.spin_restricted=.spin_restricted
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       .bra_set.vec(i).block_type.create(.n_blocks)
       .bra_set.vec(i).block_dim.create(.n_blocks)
       .bra_set.vec(i).block_dim=2
       .bra_set.vec(i).coef.create(.n_blocks)
       .bra_set.vec(i).block_type=blocks
       .bra_set.vec(i).coef=coeffs
       ! check the number of 1D blocks
       counter=0
       do j=1,.n_blocks
         if(blocks(j)=='ID1') then
           .bra_set.vec(i).block_dim(j)=1
           counter=counter+1
         end
       end
       if (counter /= .n_1D_blocks) then
       !debug stdout.text("wrong nb of 1D blocks")
         stop
       end
       !
       .bra_set.vec(i).n_1D_blocks=.n_1D_blocks 
       .bra_set.vec(i).n_2D_blocks=.n_2D_blocks
       .bra_set.vec(i).n_2D_3typ_blocks = .n_2D_3typ_blocks
       .bra_set.vec(i).n_2D_4typ_blocks = .n_2D_4typ_blocks
     end
     .make_type_numbers(.bra_set)
!     ! write the bra set to the output file
!     stdout.text(" ")
!     stdout.text("Bra set:")
!     .write_pbt_set(.bra_set)
   end

   read_ket_set ::: leaky
   ! Read all the blocks of the geminals of the ket
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT

     ! check if guess_type is "readin";
     ! if not, stop the program execution
     if (.guess_type /= "readin") then
        stdout.text(" ")
        stdout.text("provide keyword guess_type= readin, before the input ket_set")
        stop
     end
!     ! check if block partition has already been read;
!     ! if not, call routine "read_block_partiton"
!     if (NOT .block_partition_read) then
!        .read_block_partition 
!     end
!     ! check if GD2 angles have already been read;
!     ! if not, call routine "read_GD2_info"
!     if (NOT .GD2_info_read) then
!        .read_GD2_info
!     end
     !
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.ket_set.vec(.n_geminals))
     .ket_set.set_size=.n_geminals
     .ket_set.set_size_sing=.n_gem_singlet
     .ket_set.n_blocks=.n_blocks
     .ket_set.n_1D_blocks=.n_1D_blocks
     .ket_set.n_2D_blocks=.n_2D_blocks
     .ket_set.n_2D_3typ_blocks=.n_2D_3typ_blocks
     .ket_set.n_2D_4typ_blocks=.n_2D_4typ_blocks
     .ket_set.spin_restricted=.spin_restricted
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       if (.bra_is_ket) then
       !debug stdout.text("WARNING: .bra_is_ket has been set to TRUE !")
       !debug stdout.show("For ket ", i)
       !debug stdout.text("read in information will be ignored")
       else
         .ket_set.vec(i).block_type.create(.n_blocks)
         .ket_set.vec(i).block_dim.create(.n_blocks)
         .ket_set.vec(i).block_dim=2
         .ket_set.vec(i).coef.create(.n_blocks)
         .ket_set.vec(i).block_type=blocks
         .ket_set.vec(i).coef=coeffs
         ! check the number of 1D blocks
         counter=0
         do j=1,.n_blocks
           if(blocks(j)=='ID1') then
             .ket_set.vec(i).block_dim(j)=1
             counter=counter+1
           end
         end
         if (counter /= .n_1D_blocks) then
         !debug stdout.text("wrong nb of 1D blocks")
           stop
         end
         !
         .ket_set.vec(i).n_1D_blocks=.n_1D_blocks 
         .ket_set.vec(i).n_2D_blocks=.n_2D_blocks 
         .ket_set.vec(i).n_2D_3typ_blocks = .n_2D_3typ_blocks
         .ket_set.vec(i).n_2D_4typ_blocks = .n_2D_4typ_blocks
       end
     end
     .make_type_numbers(.ket_set)
!     ! write the ket set to the output file
!     stdout.text(" ")
!     stdout.text("Ket set:")
!     .write_pbt_set(.ket_set)
   end

   read_guess_type
   ! Read  guess geminals type
     stdin.read(.guess_type)
     .guess_type.to_lower_case
     select case (.guess_type)
       case ("hf")
         stdout.text(" ")
         stdout.text("guess geminals will be singlet coupled canonical HF orbitals")
         stdout.text(" ")
       case ("pp")
         stdout.text(" ")
         stdout.text("guess geminals will be Perfect Paired orbitals (to be used with readin mos)")
         stdout.text(" ")
       case ("random")
         stdout.text(" ")
         stdout.text("guess geminals will be random")
         stdout.text(" ")
       case ("hf-random")
         stdout.text(" ")
         stdout.text("guess geminals will be mixed HF-random")
         stdout.text(" ")
       case ("readin")
       !  .readin_gems= TRUE
         stdout.text(" ")
         stdout.text("guess geminals will be read in")
         stdout.text(" ")
       case default
         DIE("unknown guess option: "//trim(.guess_type))
     end 
   end

   read_readin_mos
   ! Read yes if MO's are to be read in, else the flag is set to FALSE and scf orbitals
   ! are used
     readin_mos :: BIN
     stdin.read(readin_mos)
     .readin_mos=readin_mos
   end 

   read_GD2_info
   ! Read angles corresponding to GD2 matrices
     ENSURE(.GD2_info.created,"GD2 info does not exist")
     ENSURE(size(.GD2_info)==.n_2D_3typ_blocks,"size problem with GD2 info")
     angles :: VEC{REAL}*

     angles.create(.n_2D_3typ_blocks)
     stdin.read(angles)
     .GD2_info=angles
   end 

   read_spin_restricted
   ! Read TRUE if the spin-restricted approach is selected, else read FALSE
   !  self :: PTR
     spin_restricted :: BIN

     stdin.read(spin_restricted)
     .spin_restricted=spin_restricted

     ! in case of a spin unrestricted calculation,
     ! set to zero the (default) value for the number of
     ! spin restricted geminals
     if (NOT spin_restricted) then
        .n_gem_singlet = 0
     end

   end 

   read_block_partition ::: leaky
   ! Read number of 1-dimensional blocks, 2-dimensional blocks with 3 matrix types, 
   ! and 2-dimensional blocks with 4 matrix types in each geminal
   !  self :: PTR
     block_partition :: VEC{INT}(3)
     calc_size :: INT

     stdin.read(block_partition)
     .n_1D_blocks=block_partition(1)
     .n_2D_3typ_blocks=block_partition(2)
     .n_2D_4typ_blocks=block_partition(3)

     ! check if the block partition is consistent
     ! with mat_size 
     calc_size = block_partition(1) 
     calc_size = calc_size + sum(block_partition(2:3))*2 
     if (calc_size /= .mat_size) then
        stdout.text("The input block partition is not consistent")
        stdout.text("with the size of the Pauli Block Tensors")
        stop
     end

     if(.n_1D_blocks>0) then
       .first_block=0
     else
       .first_block=1
     end

     if(.n_2D_3typ_blocks>0) then
       .gen_block=TRUE
     else
       .gen_block=FALSE
     end
     .GD2_info.create(.n_2D_3typ_blocks)
     .GD2_info=THREEQUARTERS*PI !initialized GD2 as SZ
     
     .n_blocks=sum(block_partition)
     .n_2D_blocks=.n_blocks-.n_1D_blocks

!     ! set related flag variable to TRUE
!     .block_partition_read = TRUE

   end 

   read_n_singlet_geminals
   ! Read number of singlet geminals
   !  self :: PTR
     n_singlet_geminals :: INT
     stdin.read(n_singlet_geminals)
     .n_gem_singlet=n_singlet_geminals
   end

   read_random_scaling
   ! Read scaling factor to build mixed 
   ! HF-random guess set of geminals
   !  self :: PTR
     random_scaling :: REAL
     stdin.read(random_scaling)
     .random_scaling = random_scaling
   end

   read_calc_gradient
   ! Read TRUE if the energy gradient with respect to the block
   ! coefficients has to be computed, else read FALSE
   !  self :: PTR
     calc_gradient :: BIN

     stdin.read(calc_gradient)
     .calc_gradient = calc_gradient

   end

   read_opt_GD2_angles
   ! Read TRUE if optimization of GD2 angles is requested
     opt_GD2_angles :: BIN

     stdin.read(opt_GD2_angles)
     .opt_GD2_angles = opt_GD2_angles

   end

   read_max_it
   ! Read maximum number of iterations allowed in minimization algorithm 
     max_it :: INT

     stdin.read(max_it)
     .coef_opt_info.max_it=max_it
   end

   read_step
   ! Read an integer that determines the size of the initial step in the line minimisation along
   ! the gradient direction in Broyden-Fletcher-Goldfarb-Shanno algorithm
     step :: INT

     stdin.read(step)
     .coef_opt_info.step=step
   end

   read_coef_tol
   ! Read the tolerance on the convergence of the largest coefficient optimized
     coef_tol :: REAL

     stdin.read(coef_tol)
     .coef_opt_info.coef_tol=coef_tol
   end

   read_grad_tol
   ! Read the tolerance on the convergence of the largest gradient element 
     grad_tol :: REAL

     stdin.read(grad_tol)
     .coef_opt_info.grad_tol=grad_tol
   end

   read_only_4typ
   ! Read TRUE if only 4-type blocks have to be included in the 2D
   ! part of geminals
   !  self :: PTR
     only_4typ :: BIN
     stdin.read(only_4typ)
     .only_4typ = only_4typ
   end 

   read_only_3typ
   ! Read TRUE if only 3-type blocks have to be included in the 2D
   ! part of geminals
   !  self :: PTR
     only_3typ :: BIN
     stdin.read(only_3typ)
     .only_3typ = only_3typ
   end 
!!!
   read_debug
   ! Read TRUE if debug mode has to be activated
   !  self :: PTR
     debug :: BIN
     stdin.read(debug)
     .debug = debug
   end 
!!!


!  ==============
!  Output methods
!  ==============

   put
   ! Print out the object
      n_geminals :: INT
      i :: INT

      n_geminals=.n_geminals
    !debug stdout.text(" ")
    !debug stdout.text(" ")
    !debug stdout.text("PBG info:")
    !debug stdout.text(" ")
    !debug stdout.show("number of geminals :",.n_geminals)
    !debug stdout.text(" ")
    !debug stdout.show("number of blocks in each geminal :",.n_blocks)
    !debug stdout.text(" ")
    !debug stdout.show("bra=ket :",.bra_is_ket)
    !debug stdout.text(" ")
    !debug stdout.text(" ")
      do i=1,n_geminals
      !debug stdout.show("block type of bra :",i)
      !debug stdout.put(.bra_set.vec(i).block_type)
      !debug stdout.text(" ")
      !debug stdout.show("block coef. of bra :",i)
      !debug stdout.put(.bra_set.vec(i).coef)
      !debug stdout.text(" ")
      !debug stdout.show("block sizes of bra :",i)
      !debug stdout.put(.bra_set.vec(i).block_dim)
      !debug stdout.text(" ")
      !debug stdout.show("block numbers of bra :",i)
      !debug stdout.put(.bra_set.vec(i).n_blocks)
      !debug stdout.text(" ")
      !debug stdout.show("matrix form of bra :",i)
      !debug stdout.put(.bra_set.vec(i).matrix_form)
      !debug stdout.text(" ")
      !debug stdout.text(" ")
      end
      if(NOT .bra_is_ket) then
        do i=1,n_geminals
        !debug stdout.show("block type of ket :",i)
        !debug stdout.put(.ket_set.vec(i).block_type)
        !debug stdout.text(" ")
        !debug stdout.show("block coef. of ket :",i)
        !debug stdout.put(.ket_set.vec(i).coef)
        !debug stdout.text(" ")
        !debug stdout.show("block sizes of ket :",i)
        !debug stdout.put(.ket_set.vec(i).block_dim)
        !debug stdout.text(" ")
        !debug stdout.show("block numbers of ket :",i)
        !debug stdout.put(.ket_set.vec(i).n_blocks)
        !debug stdout.text(" ")
        !debug stdout.show("matrix form of ket :",i)
        !debug stdout.put(.ket_set.vec(i).matrix_form)
        !debug stdout.text(" ")
        !debug stdout.text(" ")
        end
        .put_type_numbers(.bra_set,.ket_set)
        .make_pauli_trace(.bra_set,.ket_set)
      else
        .put_type_numbers(.bra_set,.bra_set)
        .make_pauli_trace(.bra_set,.bra_set)
      end     
   end

   put_type_numbers(bra_subset,ket_subset)
   ! make type_numbers for a pair of bra subset and ket subset
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks,j :: INT
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     stdout.text("bra type numbers")
     do j=1,n_blocks
      stdout.show("j",j)
      stdout.put(bra_subset.type_nb(j).element)
     end
     stdout.text("ket type numbers")
     do j=1,n_blocks
      stdout.show("j",j)
      stdout.put(ket_subset.type_nb(j).element)
     end
   end

! davide 23-10-2019
   write_pbt_set(pbt_set)
   ! write Pauli Block Tensor (PBT) set 
   ! to the output file
     pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
     i :: INT

     stdout.text(" ")
     stdout.show("# 1D blocks =",pbt_set.n_1D_blocks)
     stdout.show("# 2D blocks =",pbt_set.n_2D_blocks)
     stdout.show("# 2D 3type blocks =",pbt_set.n_2D_3typ_blocks)
     stdout.show("# 2D 4type blocks =",pbt_set.n_2D_4typ_blocks)
!     stdout.show("# 2D 3type blocks(2) =",.n_2D_3typ_blocks)
!     stdout.show("# 2D 4type blocks(2) =",.n_2D_4typ_blocks)
     stdout.text(" ")
     !
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(pbt_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(pbt_set.vec(i).coef)
     end
     if (pbt_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end

   end
! de

! davide: 16-11-2018
   check_spin_multiplicity(spin_multiplicity)
   ! check if the spin multiplicity of the molecule is lower or equal to 3;
   ! if not the program execution is stopped
   spin_multiplicity :: INT, IN

     if (spin_multiplicity > 3) then
     !debug stdout.text("Spin multiplicity greater than 3.")
     !debug stdout.text("Spin multiplicities beyond triplets")
     !debug stdout.text("not yet implemented in geminal model.")
!need to implement geminal with Sz=+/-1 in order to do that
!that is to say 2 extra matrices corresponding to .n_bf-dimensional  
! diagonal blocks of a (2*.n_bf)-dimensional matrix of geminal
! coefficients. The current .n_bf-dimensional matrix used corresponds
! to a symmetrical or antisymmetrical (triplet) linear combination of
! the off-diagonal blocks
        stop
     else
        .spin_multi = spin_multiplicity 
     end

   end
! de

! davide: 26-10-2018
   check_size
   ! check if the size of the geminal matrices is equal to the sum of
   ! the pauli block sizes
   !debug stdout.text(" ")
   !debug stdout.text("Checking size of bra set of geminals")
     .check_size(.bra_set,.mat_size)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking size of ket set of geminals")
       .check_size(.ket_set,.mat_size)
     end
   end

   check_size(pb_tensor_set,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     pb_mat_size :: INT
     i :: INT
     do i=1,.n_geminals
    !debug stdout.show("geminal", i)
      .check_size(pb_tensor_set.vec(i),pb_mat_size) 
     end
   end

   check_size(pbt,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
   pbt :: PAULI_BLOCK_TENSOR
   pb_mat_size :: INT
   nb1, nb2, chk_size :: INT
     nb1 = pbt.n_1D_blocks 
     nb2 = pbt.n_2D_blocks 
     chk_size = nb1 + nb2*2
     if (chk_size == pb_mat_size) then 
      !debug stdout.text("passed")
     else
      !debug stdout.text("not passed")
     end
   end
! de

! davide: 26-10-2018
   check_block_sizes
   ! check if geminal matrices have the same block sizes
   !debug stdout.text(" ")
   !debug stdout.text("Checking block sizes of bra set of geminals")
     .check_block_sizes(.bra_set,.n_blocks)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking block sizes of ket set of geminals")
       .check_block_sizes(.ket_set,.n_blocks)
     !debug stdout.text(" ")
     !debug stdout.text("checking block sizes homogeneity of ket and bra 1st geminals")
       .check_block_sizes(.bra_set.vec(1),.ket_set.vec(1),.n_blocks)
     end
   end

   check_block_sizes(pb_tensor_set,nb)
   !
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     nb :: INT
     i :: INT
     do i=2,.n_geminals
     !debug stdout.show("geminals 1 and", i)
       .check_block_sizes(pb_tensor_set.vec(1),pb_tensor_set.vec(i),nb)
     end
   end

   check_block_sizes(pbt1,pbt2,nb)
   !
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     i :: INT
     chk_bsize :: BIN 
     chk_bsize = pbt1.block_dim.equals(pbt2.block_dim)
     if(chk_bsize) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed for blocks:")
       do i=1,nb 
         if ( pbt1.block_dim(i) /= pbt2.block_dim(i) ) then
         !debug stdout.show(" ", i)
         end
       end
     end
   end
! de

! davide: 12-11-2018
   check_blocks_order
   ! check if in each PBT the blocks are ordered in this way:
   ! first the blocks of size 1, then the blocks of size 2
   !debug stdout.text(" ")
   !debug stdout.text("Checking blocks order in bra set of geminals")
     .check_blocks_order(.bra_set)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking blocks order in ket set of geminals")
       .check_blocks_order(.ket_set)
     end
   end
  
   check_blocks_order(pbt_set)
   ! call to the routine checking the order of blocks in each PBT
   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
   ng, i :: INT
     ng = size(pbt_set.vec)
     do i=1,ng
     !debug stdout.show("geminal", i)
       .check_blocks_order(pbt_set.vec(i))
     end
   end
  
   check_blocks_order(pbt)
   ! check if in the PBT the blocks are ordered in this way:
   ! first the blocks of size 1, then the blocks of size 2
   pbt :: PAULI_BLOCK_TENSOR, IN
   i :: INT
   test :: BIN 
     test = TRUE
     do i=1,pbt.n_1D_blocks
       if (pbt.block_dim(i) /= 1) then
         test = FALSE
         exit
       end
     end
     if (test) then
       do i=pbt.n_1D_blocks+1,pbt.n_2D_blocks
         if (pbt.block_dim(i) /= 2) then
           test = FALSE
           exit
         end
       end
     end
     if (NOT test) then
     !debug stdout.text("not passed")
     else
     !debug stdout.text("passed")
     end
   end
! de

! davide: 01-11-2018
   check_ortho
   ! check if geminals satisfy 1-orthogonality and 2-orthogonality 
   !debug stdout.text(" ")
   !debug stdout.text("Checking 1-orthogonality on bra set")
     .check_1ortho(.bra_set)
   !debug stdout.text(" ")
   !debug stdout.text("Checking 2-orthogonality on bra set")
     .check_2ortho(.bra_set)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking 1-orthogonality on ket set")
       .check_1ortho(.ket_set)
     !debug stdout.text(" ")
     !debug stdout.text("Checking 2-orthogonality on ket set")
       .check_2ortho(.ket_set)
     end
   end

   check_1ortho(pbt_set,only_1,pbt_constr)
   ! call to routines checking 1-orthogonality
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     only_1 :: BIN, optional
     pbt_constr :: BIN, optional
     ng, nb :: INT
     i, j :: INT
     only_n_1D_blocks :: BIN

     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks
     if (present(only_1) AND present(pbt_constr)) then
       only_n_1D_blocks = only_1
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, only_n_1D_blocks, pbt_constr)
         end
       end
     else if (present(only_1)) then
       only_n_1D_blocks = only_1
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, only_n_1D_blocks)
         end
       end
     else
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
         end
       end
     end

   end

   check_1ortho(pbt1,pbt2,nb,only_1,pbt_constr)
   ! check 1-orthogonality
   ! if only_1 is present and TRUE,
   ! the 1-orthogonality is checked only for the
   ! first .n_1D_blocks of each PBT
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   only_1 :: BIN, optional
   pbt_constr :: BIN, optional
   i, counter :: INT
   bb :: VEC{INT}*
   only_n_1D_blocks :: BIN

     if (present(only_1)) then
       only_n_1D_blocks = only_1
     else
       only_n_1D_blocks = FALSE
     end

     counter = 0
     allocate(bb(nb))
     if (only_n_1D_blocks) then
       do i=1,pbt1.n_1D_blocks  ! loop over the first .n_1D_blocks
         if (abs(pbt1.coef(i)) > NON_ZERO_BLOCK_TOL AND abs(pbt2.coef(i)) > NON_ZERO_BLOCK_TOL) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     else
       do i=1,nb                         ! loop over all the blocks
         if (abs(pbt1.coef(i)) > NON_ZERO_BLOCK_TOL AND abs(pbt2.coef(i)) > NON_ZERO_BLOCK_TOL) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     end

     if (counter == 0) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed for blocks:")
       do i=1,counter
       !debug stdout.show(" ", bb(i))
       end
       if (present(pbt_constr)) then
         pbt_constr = FALSE
       end
     end
     deallocate(bb)
   end

! davide: 18-11-2018
   check_2ortho(pbt_set)
   ! call to routines checking 2-orthogonality
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks
     do i=1,ng-1
       do j=i+1,ng
       !debug stdout.text("geminals:")
       !debug stdout.show(" ", i)
       !debug stdout.show(" ", j)
         .check_2ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
       end
     end
   end
! de

! davide: 03-11-2018
   check_2ortho(pbt1, pbt2, nb)
   ! check 2-orthogonality
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   check, tr :: REAL
     check = ZERO
     do i=1,nb
       if (pbt1.block_dim(i) == 1) then
         check = check + pbt1.coef(i)*pbt2.coef(i)  
       else
         tr = .calc_tr( pbt1.block_type(i), pbt2.block_type(i) )
         check = check + pbt1.coef(i)*pbt2.coef(i)*tr  
       end
     end
     if (abs(check) < TOL(15)) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed")
     end
   end
 
   calc_tr(bty1, bty2) result (tr)
   ! compute trace of product of two blocks
   ! of type ID2, E11, E22, S+, S-, SX, ISY or SZ
   bty1, bty2 :: STR, IN
   tr :: REAL
     if (bty1 == bty2) then
       if (bty1=="ID2" OR bty1=="SX" OR bty1=="ISY" OR bty1=="SZ") then
         tr = TWO
       else if (bty1=="E11" OR bty1=="E22" OR bty1=="S+" OR bty1=="S-") then
         tr = ONE 
       else
       !debug stdout.text("unknown block type in calc_tr")
         stop
       end
     else
       if (bty1=="ID2" AND (bty2=="E11" OR bty2=="E22")) then 
         tr = ONE
       else if (bty2=="ID2" AND (bty1=="E11" OR bty1=="E22")) then 
         tr = ONE
       else if (bty1=="SX" AND (bty2=="S+" OR bty2=="S-")) then
         tr = ONE
       else if (bty2=="SX" AND (bty1=="S+" OR bty1=="S-")) then
         tr = ONE
       else if ((bty1=="ISY" AND bty2=="S+") OR (bty2=="ISY" AND bty1=="S+")) then
         tr = ONE
       else if ((bty1=="ISY" AND bty2=="S-") OR (bty2=="ISY" AND bty1=="S-")) then
         tr = -ONE
       else if ((bty1=="SZ" AND bty2=="E11") OR (bty2=="SZ" AND bty1=="E11")) then
         tr = ONE
       else if ((bty1=="SZ" AND bty2=="E22") OR (bty2=="SZ" AND bty1=="E22")) then
         tr = -ONE
       else
         tr = ZERO
       end
     end
   end
! de

! davide: 08-11-2018
   check_bra_ket_homogeneity
   ! check if the i-th bra and ket geminals
   ! have the same block structure and zero coefficients
   ! for the same blocks
   i :: INT
     .homogeneous = TRUE
   !debug stdout.text(" ")
   !debug stdout.text("Checking homogeneity of bra and ket sets")
     do i=1,.n_geminals
     !debug stdout.text(" ")
     !debug stdout.show("bra and ket geminals", i)
     !debug stdout.text("block structure test")
       .check_block_structure(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
     !debug stdout.text("zero coefficients test")
       .check_nonzero_coef(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
     end
   end
 
   check_block_structure(pbt1,pbt2,hom)
   ! check if the two geminals (PBT) have the same block structure,
   ! i.e. the same block types in the same positions
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
   hom :: BIN
   i, nb :: INT
   passed :: BIN
     passed= TRUE
     nb = size(pbt1.block_dim)
     do i=1,nb
       if (pbt1.block_type(i) /= pbt2.block_type(i)) then
       !debug stdout.show("block structure test not passed for block:",i)
         passed= FALSE
         hom= FALSE
       end
     end
     ! debug if (passed) stdout.text("passed")
   end
 
   check_nonzero_coef(pbt1,pbt2,hom)
   ! check if the two geminals have zero coefficients in the same
   ! positions, i.e. for the same blocks 
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
   hom :: BIN
   i, nb :: INT
   passed, test1, test2 :: BIN
     passed = TRUE
     nb = size(pbt1.block_dim)
     do i=1,nb
       test1 = FALSE
       test2 = FALSE
       if (abs(pbt2.coef(i))>NON_ZERO_BLOCK_TOL AND abs(pbt1.coef(i))<NON_ZERO_BLOCK_TOL) then
          test1 = TRUE 
       end
       if (abs(pbt1.coef(i))>NON_ZERO_BLOCK_TOL AND abs(pbt2.coef(i))<NON_ZERO_BLOCK_TOL) then
          test2 = TRUE 
       end
       if (test1 OR test2) then
       !debug stdout.show("not passed for block:",i)
         passed = FALSE
         hom = FALSE
       end
     end
     ! debug if (passed) stdout.text("passed")
   end
! de

! davide: 18-11-2018
   check_pbt_constraints
   ! check if geminals satisfy the following constraints:
   ! 1-orthogonality for the first .n_1D_blocks and
   ! model constraints for the remaining blocks
     n :: INT

     .pbt_constraints = TRUE

   !debug stdout.text(" ")
   !debug stdout.text("Checking pbt constraints on bra set")
   !debug stdout.text(" ")
   !debug stdout.show("1-orthogonality test on the first", .n_1D_blocks)
   !debug stdout.text("blocks:")
     .check_1ortho(.bra_set, TRUE, .pbt_constraints)

     n = .n_blocks - .n_1D_blocks
   !debug stdout.text(" ")
   !debug stdout.show("model constraints test on the remaining", n)
   !debug stdout.text("blocks:")
     .check_model_constraints(.bra_set, TRUE, .pbt_constraints)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking pbt constraints on ket set")
     !debug stdout.text(" ")
     !debug stdout.show("1-orthogonality test on the first", .n_1D_blocks)
     !debug stdout.text("blocks:")
       .check_1ortho(.ket_set, TRUE, .pbt_constraints)
     !debug stdout.text(" ")
     !debug stdout.show("model constraints test on the remaining", n)
     !debug stdout.text("blocks:")
       .check_model_constraints(.ket_set, TRUE, .pbt_constraints)
     end
   end

   check_model_constraints(pbt_set, only_2, pbt_constr)
   ! call to the routine which checks the model constraints
   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
   only_2 :: BIN, optional
   pbt_constr :: BIN, optional
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks
     if (present(only_2) AND present(pbt_constr)) then
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2, pbt_constr)
         end
       end
     else if (present(only_2)) then
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2)
         end
       end
     else
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2)
         end
       end
     end

   end

   check_model_constraints(pbt1,pbt2,nb,only_2,pbt_constr)
   ! check model constraints
   ! if only_2 is present and TRUE, the model constraints are checked
   ! only for the last (.n_blocks-.n_1D_blocks) blocks
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     only_2 :: BIN, optional
     pbt_constr :: BIN, optional
     i, counter :: INT
     bb :: VEC{INT}*
     only_last_blocks :: BIN

     if (present(only_2)) then
       only_last_blocks = only_2
     else
       only_last_blocks = FALSE
     end

     counter = 0
     allocate( bb(nb) )
     if (only_last_blocks) then
       do i=pbt1.n_1D_blocks+1,nb ! loop over the last pbt.n_2D_blocks blocks
         if (pbt1.block_type(i) == pbt2.block_type(i)) then
           if (abs(pbt1.coef(i)) > NON_ZERO_BLOCK_TOL  AND  abs(pbt2.coef(i)) > NON_ZERO_BLOCK_TOL) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     else
       do i=1,nb                          ! loop over all the blocks
         if (pbt1.block_type(i) == pbt2.block_type(i)) then
           if (abs(pbt1.coef(i)) > NON_ZERO_BLOCK_TOL  AND  abs(pbt2.coef(i)) > NON_ZERO_BLOCK_TOL) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     end

     if (counter == 0) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed for blocks:")
       do i=1,counter
       !debug stdout.show(" ", bb(i))
       end
       if (present(pbt_constr)) then 
         pbt_constr = FALSE
       end
     end
     deallocate(bb)

   end
! de
   check_if_nonzero_only_1ortho(nonzero_only_1ortho)
   ! check if the set of geminals has nonzero coefficients only for
   ! the 1D blocks
     nonzero_only_1ortho :: BIN, INOUT
     i, mxval :: INT

     nonzero_only_1ortho = TRUE

     do i=1,.n_geminals 
        mxval = maxval(.bra_set.vec(i).new_nonzero_coef_ind)
        if (mxval > .n_1D_blocks) then
           nonzero_only_1ortho = FALSE
           return
        end
     end

   end


!  =======================
!  Overlap related methods
!  =======================

! davide: 30-10-2018
   normalize_gem(wrt_arg)
   ! normalization of geminals
     wrt_arg :: BIN, IN, optional
     wrt :: BIN
     i :: INT
     !
     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end
     !
     .normalize_gem(.bra_set,.n_blocks)
     !
     if (wrt) then
        stdout.text(" ")
        stdout.text("Normalization of bra set geminals")
        stdout.text("Normalized geminals - coefficients:")
        do i=1,.n_geminals
           stdout.show("geminal", i)
           stdout.put(.bra_set.vec(i).coef)
        end
        stdout.text(" ")
     end
     !
     if (NOT .bra_is_ket) then
        !
        .normalize_gem(.ket_set,.n_blocks)
        !
        if (wrt) then
           stdout.text(" ")
           stdout.text("Normalization of ket set geminals")
           stdout.text("Normalized geminals - coefficients:")
           do i=1,.n_geminals
              stdout.show("geminal", i)
              stdout.put(.ket_set.vec(i).coef)
           end
           stdout.text(" ")
        end
     end

   end

   normalize_gem(pbt_set,nb)
   ! call to the normalization routine for each geminal
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   nb :: INT
   i :: INT
     do i=1,.n_geminals
     !debug stdout.show("geminal", i)
     !!!!!
!       stdout.show("geminal", i)
     !!!!!
       .normalize_gem(pbt_set.vec(i),nb)
     end
   end

   normalize_gem(pbt,nb)
   ! normalization of one geminal
   pbt :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   bty :: STR
   norm :: REAL
   norm = ZERO
     do i=1,nb 
       bty = pbt.block_type(i)
       if (bty=="ID1" OR bty=="S+" OR bty=="S-" OR bty=="E11" OR bty=="E22") then
         norm = norm + pbt.coef(i)*pbt.coef(i)
       else if (bty=="ID2" OR bty=="SX" OR bty=="ISY" OR bty=="SZ" OR bty=="GD2") then
         norm = norm + pbt.coef(i)*pbt.coef(i)*TWO
       else
       !debug stdout.text("unknown block type in normalize_gem(pbt,nb)")
         stop
       end
     end
     norm = sqrt(norm)
     pbt.coef = pbt.coef/norm
   !debug stdout.put(pbt.coef)
     !!!!!!!
 !    stdout.put(pbt.coef)
     !!!!!!!
   end
! de

! davide: 31-10-2018
   find_nonzero_coef
   ! identification of nonzero coefficients in each geminal 
   !debug stdout.text(" ")
   !debug stdout.text("Bra set of geminals - blocks with nonzero coefficient")
     .find_nonzero_coef(.bra_set)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Ket set of geminals - blocks with nonzero coefficient")
       .find_nonzero_coef(.ket_set)
     end
   end

   find_nonzero_coef(pbt_set)
   ! call to the routine for identification of nonzero coefficients
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i :: INT

     .nonzero_1ortho_ind.create(.n_1D_blocks)
     .nonzero_1ortho_ind=0

     do i=1,pbt_set.set_size
     !debug stdout.text(" ")
     !debug stdout.show("geminal", i)
       .find_nonzero_coef(pbt_set.vec(i),i)
     end

   end

   find_nonzero_coef(pbt,g)
   ! identification and storing of nonzero 
   ! coefficients in one geminal 
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT
     i, counter :: INT
     nb, n_1D_blocks :: INT

     nb = size(pbt.block_type) 
     allocate(pbt.nonzero_coef_ind(nb))
     !!!
     allocate(pbt.new_nonzero_coef_ind(nb))
     !!!
     allocate(pbt.red_coef(nb))
     pbt.red_coef(nb) = ZERO
     counter = 0
     n_1D_blocks = pbt.n_1D_blocks
     do i=1,n_1D_blocks   ! loop over 1-orthogonal blocks
        if (abs(pbt.coef(i)) > NON_ZERO_BLOCK_TOL) then
           counter = counter + 1
           pbt.nonzero_coef_ind(counter) = 0
           !!!
           pbt.new_nonzero_coef_ind(counter) = i
           !!!
           pbt.red_coef(counter) = pbt.coef(i)
           .nonzero_1ortho_ind(i) = g  ! geminal g has a nonzero coef. in 1-ortho. block i
        end
     end
     pbt.n_nonzero_1ortho = counter   ! number of nonzero 1-orthogonal blocks
     if(counter==0) pbt.first_block=1
     do i=n_1D_blocks+1,nb   ! loop over Pauli blocks
        if (abs(pbt.coef(i)) > NON_ZERO_BLOCK_TOL) then
           counter = counter + 1
           pbt.nonzero_coef_ind(counter) = i - n_1D_blocks
           !!!
           pbt.new_nonzero_coef_ind(counter) = i
           !!!
           pbt.red_coef(counter) = pbt.coef(i)
        end
     end
     pbt.nonzero_coef_ind.shrink(counter)
     !!!
     pbt.new_nonzero_coef_ind.shrink(counter)
     !!!
     pbt.red_coef.resize(counter)

     !debug do i=1,counter
     !debug    stdout.show( "index =", pbt.nonzero_coef_ind(i) )
     !debug    stdout.show( "coef. =", pbt.red_coef(i) )
     !debug end
   end

   prep_nonzero_coef ::: leaky
   ! prepare indices and products of coefficients
   ! of nonzero blocks for the calculation of integral formulas
   ! (overlap and matrix elements between PBT sets)
     i, j :: INT
     siz_ind, siz_prod :: INT
     ind, ind_prod :: INT
     ng, n_nonzero_1ortho, n_nonzero_blocks :: INT
     p_coef_1ortho :: REAL
     n_pauli_blocks :: INT

   !debug stdout.text(" ")
   !debug stdout.text("Indices and products of coefficients")
   !debug stdout.text("of nonzero blocks:")
     
     ng = .n_geminals
     .nonzero_coef_ind.create(ng)
     .nonzero_coef_prod.create(ng)
     if (.bra_is_ket) then
        do i=1,ng
           ! create vector of nonzero block indices
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1D_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)*TWO
           end
        end
     else
        do i=1,ng
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1D_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)*TWO
           end
        end
     end

     !!! debug
!     do i=1,ng
!      !debug stdout.text(" ")
!      !debug stdout.show("geminal",i)
!        siz = size(.nonzero_coef_ind(i).element)
!        do j=1,siz
!         !debug stdout.show("block index", .nonzero_coef_ind(i).element(j))
!           ind_prod = .nonzero_coef_ind(i).element(j) + 1 -.first_block
!         !debug stdout.show("coef. product", .nonzero_coef_prod(i).element(ind_prod))
!        end
!     end
     !!!

   end
! de

   make_int_term_list(check_arg,prep_arg,write_arg) ::: leaky
   ! make the list of non zero block indices combinations for integral
   ! formula relevant to the standard PBT model
     check_arg :: BIN, optional
     prep_arg :: BIN, optional
     write_arg :: BIN, optional
     current_list :: VEC_INT_LIST*
     new_item :: VEC_INT_LIST*
     new_list :: VEC_INT_LIST*
     i, j :: INT
     siz :: INT
     parity :: INT
     list_ind :: VEC{INT}*
     check :: BIN
     prep :: BIN
     writ :: BIN

     check = TRUE
     if (present(check_arg)) then
        check = check_arg
     end

     prep = TRUE
     if (present(prep_arg)) then
        prep = prep_arg
     end

     writ = TRUE
     if (present(write_arg)) then
        writ = write_arg
     end
  
     if (check) then
        .check_pbt_constraints
        if (NOT .pbt_constraints) then
          stdout.text(" ")
          stdout.text("PBT constraints not enforced")
          stop
        end
        
        if (NOT .bra_is_ket) then
          .check_bra_ket_homogeneity
          if (NOT .homogeneous) then
            stdout.text(" ")
            stdout.text("bra and ket not homogeneous")
            stop
          end
        end
     end

     if (prep) then
        .prep_nonzero_coef
     end
   !  destroy former list if present 
     new_item=>.int_term_ind
     do
       if (NOT associated(new_item)) exit
       .int_term_ind.item.destroy
       new_item=>.int_term_ind.next
       deallocate(.int_term_ind)
       .int_term_ind=>new_item
     end
     ! initialize combinations with geminal 1 nonzero coef
     nullify(current_list)
     nullify(new_item)
     do i=1,size(.nonzero_coef_ind(1).element)
       allocate(new_item)
       allocate(new_item.item(.n_geminals))
       new_item.item(1) = .nonzero_coef_ind(1).element(i)
       new_item.next => current_list
       current_list => new_item
     end
    
     ! produce combinations
     parity = 1 ! parity used to construct combinations always in increasing index order
     do j=2,.n_geminals
       nullify(new_list)
       siz = size(.nonzero_coef_ind(j).element)
       allocate(list_ind(siz))
       list_ind = .nonzero_coef_ind(j).element(1:siz)
       do
         if (NOT associated(current_list)) exit
         if (parity == -1) then 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
           do i=2,siz ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end
         else
           do i=siz,2,-1 ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
         end
         ! deallocating the previous list
         new_item=>current_list
         current_list => current_list.next
         deallocate(new_item.item)
         deallocate(new_item)
       end
       current_list => new_list
       parity = -parity
       deallocate(list_ind)
     end
  
     nullify(.int_term_ind)
     .int_term_ind => current_list
    
     ! write combinations produced
     if (writ) then
       stdout.text(" ")
       stdout.show("number of geminals", .n_geminals)
       stdout.text("List of block indices combinations for integral")
       stdout.text("formula relevant to the standard PBT model:")
       i = 0
       current_list => .int_term_ind
       do
         if (NOT associated(current_list)) exit
         i = i + 1
         !debug stdout.show("Combination", i)
         !debug stdout.put(current_list.item)
         current_list => current_list.next 
       end
       stdout.show("Total combination number", i)
     end
  
   end

! davide: 19-11-2018
   calc_overlap_integral(overlap_value,wrt_arg)
   ! compute the overlap integral between the bra and ket
   ! PBT sets
     overlap_value :: REAL, optional
     wrt_arg :: BIN, optional
     comb_list :: VEC_INT_LIST*
     term, overlap :: REAL 
     i :: INT
     j :: INT
     wrt :: BIN

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     nullify(comb_list)
     comb_list => .int_term_ind

     overlap = ZERO

     do
        if (NOT associated(comb_list)) exit
        term = ONE
        do i=1,.n_geminals
           j = comb_list.item(i)+1-.first_block
           term = term*.nonzero_coef_prod(i).element(j)
        end
        overlap = overlap + term
        comb_list => comb_list.next 
     end

     if (present(overlap_value)) then
        overlap_value = overlap
     end

     if (wrt) then
       stdout.text(" ")
       stdout.show("Overlap integral between bra and ket PBT sets =", overlap)
     end 

   end
! de


!  =======================
!  1RDM related methods
!  =======================

! davide: 28-11-2018
   calc_1rdm ::: leaky
   ! compute the 1-reduced density matrix
   ! for a set of PBT
     i, j :: INT
 !debug    trace :: REAL

     allocate(.rdm_1(.mat_size,.mat_size))
     .rdm_1 = ZERO

     .prep_orbital_block_mapping
     .prep_block_types

   !debug stdout.text(" ")
   !debug stdout.text("Calculation of the 1-reduced density matrix")

     ! 1-orthogonal blocks space
     do i=1,.n_1D_blocks
        .calc_1rdm_element(i,i)
     end

     ! Pauli blocks space
     do i=.n_1D_blocks+1,.mat_size-1,2
        .calc_1rdm_element(i,i)
        j = i+1
        .rdm_1(j,j) = .rdm_1(i,i)
     end

     ! write 1-RDM
   !debug stdout.text(" ")
   !debug stdout.text("1-reduced density alpha-(or beta-)matrix:")
   !debug stdout.text(" ")
   !debug stdout.put(.rdm_1)

   !debug  ! compute 1-RDM trace
   !debug  trace = ZERO
   !debug  do i=1,.mat_size
   !debug     trace = trace + .rdm_1(i,i)
   !debug  end
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the 1-RDM alpha-(or beta-)matrix", trace)
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the total 1-RDM matrix", trace+trace)
     
   end

   calc_1rdm_element(row,col) 
   ! compute element (row,col) of the 1-reduced 
   ! density matrix (1-RDM) for a set of PBT
     row, col :: INT, IN
     red_pbg :: PAULI_BLOCK_GEMINALS 
     ng :: INT
     overlap :: REAL
     coef_prod, coef1, coef2 :: REAL
     block :: INT
     geminal :: INT
     term :: VEC{REAL}(4)
     j :: INT
     problem :: BIN

     ng = .n_geminals-1
     if (ng /= 0) then
        red_pbg.n_geminals = ng
        red_pbg.first_block = .first_block
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
     end

     if (row == col AND row <= .n_1D_blocks) then  ! 1-orthogonal blocks space - diagonal element
        ! index of the geminal to be skipped
        ! (in the calculation of the reduced overlap)
        geminal = .nonzero_1ortho_ind(row)
        if (geminal /= 0) then
!        if (.nonzero_1ortho_ind(row) /= 0) then
         !debug stdout.show("geminal to be skipped", geminal)
!         !debug stdout.show("geminal to be skipped", .nonzero_1ortho_ind(row))
         !debug stdout.show("nonzero 1-ortho. block", row)
           ! compute product of coefficients of the bra and ket
           ! geminals ".nonzero_1ortho_ind(row)" (1-ortho. block "row")
           coef1 = .bra_set.vec(geminal).coef(row)
!           coef1 = .bra_set.vec(.nonzero_1ortho_ind(row)).coef(row)
           if (.bra_is_ket) then
              coef_prod = coef1*coef1
           else
              coef2 = .ket_set.vec(geminal).coef(row)
!              coef2 = .ket_set.vec(.nonzero_1ortho_ind(row)).coef(row)
              coef_prod = coef1*coef2
           end
           if (ng /= 0) then
              .prep_red_pbg(red_pbg,geminal)
!              .prep_red_pbg(red_pbg,.nonzero_1ortho_ind(row))
              red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              .rdm_1(row,col) = coef_prod*overlap
           else
              .rdm_1(row,col) = coef_prod
           end
         !debug stdout.text(" ")
         !debug stdout.show("Calculation of 1-RDM diagonal element", row)
         !debug stdout.show("product of coef.", coef_prod)
         !debug stdout.show("overlap", overlap)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
        end
     else if (row == col AND row > .n_1D_blocks) then ! Pauli blocks space - diagonal element
      !debug stdout.text(" ")
      !debug stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
         !debug stdout.show("term", j)
           geminal = .block_types(block).element(j) 
         !debug stdout.show("geminal to be skipped", geminal)
         !debug stdout.show("Pauli block to be skipped", block)
           if (geminal /= 0) then
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              if (ng /= 0) then
                 .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                  !debug stdout.show("product of coef.", coef_prod)
                  !debug stdout.show("overlap", overlap)
                 else
                    term(j) = ZERO
                 end
              else
                 term(j) = coef_prod
               !debug stdout.show("product of coef.", coef_prod)
               !debug stdout.show("overlap", overlap)
              end
           else
              term(j) = ZERO
           end
         !debug stdout.show("term", term(j))
        end
        .rdm_1(row,col) = sum(term)
      !debug stdout.show("matrix element", .rdm_1(row,col))
        .rdm_1(row,col) = .rdm_1(row,col)/.overlap
      !debug stdout.show("normalized matrix element", .rdm_1(row,col))
     else
        .rdm_1(row,col) = ZERO
      !debug stdout.text(" ")
      !debug stdout.text("Calculation of 1-RDM off-diagonal element")
      !debug stdout.show(" ", row)
      !debug stdout.show(" ", col)
      !debug stdout.show("matrix element", .rdm_1(row,col))
     end
     if (ng /= 0) then
        red_pbg.destroy_ptr_part
     end

   end
  
   calc_1rdm_gen
   ! compute the 1-reduced density matrix
   ! for a set of PBT
     i, m :: INT

     allocate(.rdm_1(.mat_size,.mat_size))
     .rdm_1 = ZERO

     .prep_orbital_block_mapping
     .prep_block_types

   !debug stdout.text(" ")
   !debug stdout.text("Calculation of the 1-reduced density matrix")

     ! 1D blocks space

     do i=1,.n_1D_blocks
        .calc_1rdm_element_gen(i,i)
     end

     ! 2D blocks space

     m = .n_1D_blocks+2*.n_2D_3typ_blocks

     if (.n_2D_3typ_blocks /= 0) then
        do i=.n_1D_blocks+1,m-1,2
           .calc_1rdm_element_gen(i,i)
        end
     end

     if (.n_2D_4typ_blocks /= 0) then
        do i=m+1,.mat_size-1,2
           .calc_1rdm_element(i,i)
        end
     end

     ! write 1-RDM
   !debug stdout.text(" ")
   !debug stdout.text("1-reduced density alpha-(or beta-)matrix:")
   !debug stdout.text(" ")
   !debug stdout.put(.rdm_1)

   !debug  ! compute 1-RDM trace
   !debug  trace = ZERO
   !debug  do i=1,.mat_size
   !debug     trace = trace + .rdm_1(i,i)
   !debug  end
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the 1-RDM alpha-(or beta-)matrix", trace)
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the total 1-RDM matrix", trace+trace)
     
   end

   calc_1rdm_element_gen(row,col)
   ! compute element (row,col) of the 1-reduced 
   ! density matrix (1-RDM) for a set of PBT
     row, col :: INT, IN
     red_pbg :: PAULI_BLOCK_GEMINALS 
     ng :: INT
     overlap :: REAL
     coef_prod, coef1, coef2 :: REAL
     block :: INT
     geminal :: INT
     term :: VEC{REAL}(5)
     j, r :: INT
     problem :: BIN
     t_1, t_2 :: REAL

     ng = .n_geminals-1
     if (ng /= 0) then
        red_pbg.n_geminals = ng
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
        red_pbg.first_block=.first_block
     end

     term = ZERO

     if (row == col AND row <= .n_1D_blocks) then  ! 1D blocks space - diagonal element
        if (.nonzero_1ortho_ind(row) /= 0) then
         !debug stdout.show("geminal to be skipped", .nonzero_1ortho_ind(row))
         !debug stdout.show("nonzero 1-ortho. block", row)
           ! compute product of coefficients of the bra and ket
           ! geminals ".nonzero_1ortho_ind(row)" (1-ortho. block "row")
           coef1 = .bra_set.vec(.nonzero_1ortho_ind(row)).coef(row)
           if (.bra_is_ket) then
              coef_prod = coef1*coef1
           else
              coef2 = .ket_set.vec(.nonzero_1ortho_ind(row)).coef(row)
              coef_prod = coef1*coef2
           end
           if (ng /= 0) then
              .prep_red_pbg(red_pbg,.nonzero_1ortho_ind(row))
              red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              .rdm_1(row,col) = coef_prod*overlap
           else
              .rdm_1(row,col) = coef_prod
           end
         !debug stdout.text(" ")
         !debug stdout.show("Calculation of 1-RDM diagonal element", row)
         !debug stdout.show("product of coef.", coef_prod)
         !debug stdout.show("overlap", overlap)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
        end
     else if (row == col AND row > .n_1D_blocks) then ! 2D blocks space - diagonal element
      !debug stdout.text(" ")
      !debug stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=3,5 ! geminal with SX, SY or GD2 in block "block" are considered
         !debug stdout.show("term", j)
           geminal = .block_types(block).element(j) 
         !debug stdout.show("geminal to be skipped", geminal)
         !debug stdout.show("2D block to be skipped", block)
           if (geminal /= 0) then
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              if (ng /= 0) then
                 .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                    !stdout.show("product of coef.", coef_prod)
                    !stdout.show("overlap", overlap)
                 end
              else
                 term(j) = coef_prod
                 !stdout.show("product of coef.", coef_prod)
                 !stdout.show("overlap", overlap)
              end
           end
         !debug stdout.show("term", term(j))
        end
        if (abs(term(5)) > TOL(15)) then
           t_1 = term(5)*.first_GD2_elt(block)*.first_GD2_elt(block)
           t_2 = term(5)*.second_GD2_elt(block)*.second_GD2_elt(block)
           .rdm_1(row,col) = t_1+term(3)+term(4)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
           r = row+1
           .rdm_1(r,r) = t_2+term(3)+term(4)
         !debug stdout.show("matrix element", .rdm_1(r,r))
           .rdm_1(r,r) = .rdm_1(r,r)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(r,r))
        else
           .rdm_1(row,col) = term(3)+term(4)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
           r = row+1
           .rdm_1(r,r) = .rdm_1(row,col)
        end
     else
        .rdm_1(row,col) = ZERO
      !debug stdout.text(" ")
      !debug stdout.text("Calculation of 1-RDM off-diagonal element")
      !debug stdout.show(" ", row)
      !debug stdout.show(" ", col)
      !debug stdout.show("matrix element", .rdm_1(row,col))
     end
     if (ng /= 0) then
        red_pbg.destroy_ptr_part
     end

   end


!  =======================
!  2RTM related methods
!  =======================

   calc_2rtm_epi2o(make_grad) ::: leaky
   ! compute the 2-reduced transition matrix for epi2o conditions
   ! for a set of PBT   
   ENSURE(.pbt_constraints,"pbt_constraints not fulfilled") 
   ENSURE(.n_geminals>0,"no geminal") 
     make_grad :: BIN, optional
     ng_1, ng_2 :: INT
     j, size_ab, size_aa :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     grad_info :: BIN
     !
     if(present(make_grad)) then
       grad_info=make_grad
     else
       grad_info=FALSE
     end

     if (.bra_is_ket) then
        .ket_set=.bra_set
     else if (grad_info) then
       stdout.text(" ")
       stdout.text("gradient only implemented for bra=ket")
       stop
     end
     

     if (.debug) then
       stdout.text(" ")
       stdout.text("Entering subroutine calc_2rtm_epi2o")
       stdout.text(" ")
       stdout.text("Calculation of the 2-reduced density matrix")
       stdout.text(" ")
       if (NOT .ket_set.vec(1).coef.created) then 
          stdout.text("ket vector not created ")
          stdout.text(" ")
          stop
       end
     end if

     .prep_orbital_block_mapping
     .prep_block_types
     if(.n_2D_blocks>0) .prep_geminal_sets
     
     size_ab = 4*.mat_size*.mat_size
     size_aa = .mat_size*(.mat_size-1)*2
     
     if (NOT .rdm_2_ab.created) then
!        stdout.text("create .rdm_2_ab")
!        stdout.show("size(.rdm_2_ab) =",size_ab)
        .create(.rdm_2_ab,size_ab)
     end if
     
     if (NOT .rdm_2_aa.created) then
!        stdout.text("create .rdm_2_aa")
!        stdout.show("size(.rdm_2_aa) =",size_aa)
        .create(.rdm_2_aa,size_aa)
     end if
     
     if (NOT .rdm_2_bb.created) then
!        stdout.text("create .rdm_2_bb")
!        stdout.show("size(.rdm_2_bb) =",size_aa)
        .create(.rdm_2_bb,size_aa)
     end if

!these objects will be used in many subroutines, they are created here to avoid
! creating and destroying them in each subroutine
     ng_1 = .n_geminals-1
     ! case not just one geminal
     if (ng_1 > 0) then
        red_pbg_1.n_geminals = ng_1
        red_pbg_1.nonzero_coef_ind.create(ng_1)
        red_pbg_1.nonzero_coef_prod.create(ng_1)
        red_pbg_1.first_block=.first_block
     end

     ng_2 = .n_geminals-2
     ! case more than two geminals
     if (ng_2 > 0) then
        red_pbg_2.n_geminals = ng_2
        red_pbg_2.nonzero_coef_ind.create(ng_2)
        red_pbg_2.nonzero_coef_prod.create(ng_2)
        red_pbg_2.first_block=.first_block
     end

     ! i counts the number of non zero elements in the \alpha\beta 2RTM
     .nonzero_terms_ab = 0
     ! i_a counts the number of non zero elements in the \alpha\alpha 2RTM
     .nonzero_terms_aa = 0 
     ! i_b counts the number of non zero elements in the \beta\beta 2RTM 
     .nonzero_terms_bb = 0

!     timer.start_timing
     .calc_2rtm_two_1D_blocks_epi2o(red_pbg_1,red_pbg_2,make_grad_info=grad_info)
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) calc_2rtm_two_1D_blocks_epi2o: ",timer.elapsed_time_s,14)
!debug     stdout.show(".nonzero_terms_ab after 1D-1D",.nonzero_terms_ab)

!     timer.start_timing
     .calc_2rtm_1D_2D_blocks_epi2o(red_pbg_1,red_pbg_2,make_grad_info=grad_info)
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) calc_2rtm_1D_2D_blocks_epi2o: ",timer.elapsed_time_s,14)
!debug     stdout.show(".nonzero_terms_ab after 1D-2D",.nonzero_terms_ab)

!     timer.start_timing
     .calc_2rtm_two_2D_blocks_epi2o(red_pbg_1,red_pbg_2,make_grad_info=grad_info)
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) calc_2rtm_two_2D_blocks_epi2o: ",timer.elapsed_time_s,14)
!debug     stdout.show(".nonzero_terms_ab after 2D-2D",.nonzero_terms_ab)
     

     if (.debug) then
        stdout.text(" ")
        stdout.show("Overlap =",.overlap)
        if (.n_2D_3typ_blocks > 0) then
           stdout.show("first_GD2_elt =",.first_GD2_elt)
           stdout.show("second_GD2_elt =",.second_GD2_elt)
        end
    
        stdout.text(" ")
        stdout.text("2RDM alpha/beta nonzero elements:")
        stdout.show("Number of nonzero elements =",.nonzero_terms_ab)
        do j=1,.nonzero_terms_ab
           stdout.text(" ")
           stdout.show("element",j)
           stdout.show("indices",.rdm_2_ab(j).indices)
           stdout.show("coefficient",.rdm_2_ab(j).coefficient)
        end
        stdout.text(" ")
        stdout.text("2RDM alpha/alpha nonzero elements:")
        stdout.show("Number of nonzero elements =",.nonzero_terms_aa)
        do j=1,.nonzero_terms_aa
           stdout.text(" ")
           stdout.show("element",j)
           stdout.show("indices",.rdm_2_aa(j).indices)
           stdout.show("coefficient",.rdm_2_aa(j).coefficient)
        end
        stdout.text(" ")
        stdout.text("2RDM beta/beta nonzero elements:")
        stdout.show("Number of nonzero elements =",.nonzero_terms_bb)
        do j=1,.nonzero_terms_bb
           stdout.text(" ")
           stdout.show("element",j)
           stdout.show("indices",.rdm_2_bb(j).indices)
           stdout.show("coefficient",.rdm_2_bb(j).coefficient)
        end
     end !!! debug

     if (ng_1 /= 0) then
        red_pbg_1.destroy_ptr_part
     end
     if (ng_2 > 0) then
        red_pbg_2.destroy_ptr_part
     end
   
   end

   calc_2rtm_two_1D_blocks_epi2o(red_pbg_1,red_pbg_2,make_grad_info)
   ! calculation of the 2RTM elements where at least one block is from the 1-orthogonal part
   ! for the first case and the second case, second possibility, in the thesis when 2 blocks
   ! are from the 1-orthogonal part, and just the first case when one block is 2-orthogonal
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     make_grad_info :: BIN, optional
     grad_info :: BIN
     !
     if(present(make_grad_info)) then
       grad_info=make_grad_info
     else
       grad_info=FALSE
     end

     ! no non zero elements in the \alpha\alpha and \beta\beta 2RTM when case 2
     ! same_block = TRUE in case 2b
     ! same_block = FALSE in all cases but 2b
     if(grad_info) then
       .comp_2rtm_two_1D_blocks_2b_epi2o_grd(red_pbg_1)
       .comp_2rtm_two_1D_blocks_2a_epi2o_grd(red_pbg_1)
       .comp_2rtm_two_1D_blocks_1a_epi2o_grd(red_pbg_2)
     else
       .comp_2rtm_two_1D_blocks_2b_epi2o(red_pbg_1)
       .comp_2rtm_two_1D_blocks_2a_epi2o(red_pbg_1)
       .comp_2rtm_two_1D_blocks_1a_epi2o(red_pbg_2)
     end
   end

   comp_2rtm_two_1D_blocks_2b_epi2o(red_pbg_1)
   ! calculation of the 2RDM elements where we consider just one block
   ! it corresponds to the third case in the thesis
   ! or to case 2b in the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     g, b :: INT
     ng_1 :: INT
     coef_prod :: REAL
     overlap :: REAL

     ! 1-orthogonal case
     ng_1=red_pbg_1.n_geminals
     do b=1,.n_1D_blocks
        g = .nonzero_1ortho_ind(b)
        if (g == 0) cycle
        coef_prod = .bra_set.vec(g).coef(b) * .ket_set.vec(g).coef(b)
        coef_prod = coef_prod/.overlap
        if (ng_1 > 0) then
           .prep_red_pbg(red_pbg_1,g)
           red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg_1.calc_overlap_integral(overlap,FALSE)
        else
           overlap = ONE
           !provided the geminals have been properly normalized
        end
        coef_prod = coef_prod*overlap
        if (abs(coef_prod) > NON_ZERO_2RTM_TOL ) then
           ! increments the number of non zero elements in the \alpha\beta 2RTM
           .add_2rtm_ab_elt((/ b,b,b,b /),coef_prod)
        end
     end
   end

   comp_2rtm_two_1D_blocks_2a_epi2o(red_pbg_1)
   ! calculation of the 2RTM elements when two 1D-blocks
   ! case 2a of the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     r, b :: INT
     block_1, block_2 :: INT
     non_zero_1D, g  :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL
     overlap :: REAL
     terms :: VEC{REAL}(2)

     ng_1=red_pbg_1.n_geminals
     ! same_block = FALSE
     terms = ZERO
     ! here we consider two different 1D blocks 
     do g=1,.n_geminals
        !nb of non zero coef of geminal g for 1D blocks
        non_zero_1D=.bra_set.vec(g).n_nonzero_1ortho
        if (non_zero_1D < 2) cycle
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1,g)
           red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg_1.calc_overlap_integral(overlap,FALSE)
        else
           overlap = ONE
        end
        overlap=overlap/.overlap
        do r=1,non_zero_1D-1
          block_1=.bra_set.vec(g).new_nonzero_coef_ind(r)
          coef_1 = .bra_set.vec(g).coef(block_1)*overlap
          coef_2 = .ket_set.vec(g).coef(block_1)*overlap
          do b=r+1,non_zero_1D
            block_2=.bra_set.vec(g).new_nonzero_coef_ind(b)
            coef_3 = .bra_set.vec(g).coef(block_2)
            coef_4 = .ket_set.vec(g).coef(block_2)
            terms(1)=coef_1*coef_4
            terms(2)=coef_2*coef_3
            if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
              .add_2rtm_ab_elt((/ block_1,block_1,block_2,block_2 /),terms(1))
            end  

            if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
              .add_2rtm_ab_elt((/ block_2,block_2,block_1,block_1 /),terms(2))
            end  
          end
        end
     end

   end

   comp_2rtm_two_1D_blocks_1a_epi2o(red_pbg_2)
   ! calculation of the 2RTM elements when two 1D-blocks
   ! case 1a of the paper
     red_pbg_2 :: PAULI_BLOCK_GEMINALS
     ng_2 :: INT
     r, b :: INT
     geminal, g  :: INT
     coef, coef_prod :: REAL
     overlap :: REAL


     ng_2=red_pbg_2.n_geminals
     ! here we consider two different 1D blocks 
     do r=1,.n_1D_blocks-1
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef = .bra_set.vec(geminal).coef(r)*.ket_set.vec(geminal).coef(r)/.overlap
        do b=r+1,.n_1D_blocks
           g = .nonzero_1ortho_ind(b)
           if (g == 0) cycle
           if (g == geminal) cycle
           ! in the paper case 1a
           coef_prod = coef*.bra_set.vec(g).coef(b)*.ket_set.vec(g).coef(b)
           if (ng_2 > 0) then
              .prep_red_pbg(red_pbg_2,geminal,g)
              red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_2.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ONE
           end
           coef_prod = coef_prod*overlap
           if (abs(coef_prod) > NON_ZERO_2RTM_TOL ) then
              .add_2rtm_ab_elt((/ r,b,r,b /),coef_prod)
              .add_2rtm_aa_elt((/ r,b,r,b /),coef_prod)
              .add_2rtm_bb_elt((/ r,b,r,b /),coef_prod)
              .add_2rtm_ab_elt((/ b,r,b,r /),coef_prod)
           end
        end
     end

   end

   calc_2rtm_1D_2D_blocks_epi2o(red_pbg_1,red_pbg_2,make_grad_info)
   ! calculation of the 2RTM elements for one 1D-block and one 2D-block
   ! case 2a of the paper
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     make_grad_info :: BIN, optional
     grad_info :: BIN
     !
     if(present(make_grad_info)) then
       grad_info=make_grad_info
     else
       grad_info=FALSE
     end

     if(grad_info) then
        .comp_2rtm_1D_2D_blocks_2a_epi2o_grd(red_pbg_1)
        .comp_2rtm_1D_2D_blocks_1bc_epi2o_grd(red_pbg_2)
     else
        .comp_2rtm_1D_2D_blocks_2a_epi2o(red_pbg_1)
        .comp_2rtm_1D_2D_blocks_1bc_epi2o(red_pbg_2)
     end
   end

   comp_2rtm_1D_2D_blocks_2a_epi2o(red_pbg_1)
   ! end of the computation of the 2RTM elements when we have one 1D-block and one 2D-block
   ! in the first case of the thesis
   ! in case 2a of the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     r, b, block :: INT
     geminal :: INT
     s, siz :: INT
     ind_1, ind_2 :: INT
     overlap :: REAL
     problem :: BIN
     coef_1, coef_2 :: REAL
     coef_3, coef_4 :: REAL
     term :: REAL
   
     ng_1=red_pbg_1.n_geminals
     do r=1,.n_1D_blocks
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)/.overlap
        coef_2 = .ket_set.vec(geminal).coef(r)/.overlap
        siz = size(.nonzero_coef_ind(geminal).element)
        !s=1 would correspond to the dzeta of the 1-ortho part of the geminal
        do s=2,siz
           block = .nonzero_coef_ind(geminal).element(s)
           if (ng_1 /= 0) then
              .prep_red_pbg(red_pbg_1, geminal, block, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
                red_pbg_1.calc_overlap_integral(overlap,FALSE)
              else
                ! overlap= ZERO
                cycle
              end
           else
              overlap = ONE
           end
           term=overlap
           !indices of the orbitals of the 2D-block
           ind_1 = .n_1D_blocks+2*block-1
           ind_2 = .n_1D_blocks+2*block
           b = block + .n_1D_blocks
           coef_3 = .bra_set.vec(geminal).coef(b)
           coef_4 = .ket_set.vec(geminal).coef(b)
           if (geminal == .block_types(block).element(1)) then
           ! 2D block matrix is ID2
              term = term*coef_1*coef_4
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_1 /),term)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_2 /),term)
              end 
       
              term = term*coef_2*coef_3
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_1,r,r /),term)
                 .add_2rtm_ab_elt((/ ind_2,ind_2,r,r /),term)
              end
           else if (geminal == .block_types(block).element(2)) then
           ! 2D block matrix is SZ
              term = term*coef_1*coef_4
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_1 /),term)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_2 /),-term)
              end 
              
              term = term*coef_2*coef_3
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_1,r,r /),term)
                 .add_2rtm_ab_elt((/ ind_2,ind_2,r,r /),-term)
              end
           else if (geminal == .block_types(block).element(3)) then
           ! 2D block matrix is SX
              term = term*coef_1*coef_4
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_2 /),term)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_1 /),term)
              end 
              
              term = term*coef_2*coef_3
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_2,r,r /),term)
                 .add_2rtm_ab_elt((/ ind_2,ind_1,r,r /),term)
              end
           else if (geminal == .block_types(block).element(4)) then
           ! 2D block matrix is ISY
              term = term*coef_1*coef_4
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_2 /),term)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_1 /),-term)
              end 
              
              term = term*coef_2*coef_3
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_2,r,r /),term)
                 .add_2rtm_ab_elt((/ ind_2,ind_1,r,r /),-term)
              end
           else if (geminal == .block_types(block).element(5)) then
           ! 2D block matrix is GD2
              term = term*coef_1*coef_4*.first_GD2_elt(block)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_1 /),term)
              end
                 
              term = term*coef_1*coef_4*.second_GD2_elt(block)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_2 /),term)
              end
                 
              term = term*coef_3*coef_2*.first_GD2_elt(block)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_1,r,r /),term)
              end
                 
              term = term*coef_3*coef_2*.second_GD2_elt(block)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_2,ind_2,r,r /),term)
              end
           else 
              stdout.text("geminal corresponds to no block type")
              stop
           end
        end
     end

   end

   comp_2rtm_1D_2D_blocks_1bc_epi2o(red_pbg_2)
   ! calculation of the 2RTM elements for one 1-ortho block and one 2-ortho block
   ! cases 1b and 1c of the paper
   ! (so these elements are not calculated in the calc_2rtm_one_1_ortho_epi2o routine)
     red_pbg_2 :: PAULI_BLOCK_GEMINALS
     ng_2 :: INT
     j, m :: INT
     b1, b2, block_1 :: INT
     geminal_1, geminal_2 :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod, sum_term :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN
     t_1, t_2 :: REAL

     ng_2=red_pbg_2.n_geminals
     m = .n_1D_blocks+.n_2D_3typ_blocks


     ! the 2-ortho block is 3typ
     if (.n_2D_3typ_blocks /= 0) then
       do b1=.n_1D_blocks+1,m
          block_1 = b1 - .n_1D_blocks
          ind_1 = .n_1D_blocks+2*block_1-1
          ind_2 = .n_1D_blocks+2*block_1
          do b2=1,.n_1D_blocks
             geminal_2 = .nonzero_1ortho_ind(b2)
             if (geminal_2 == 0) cycle
             coef_1 = .bra_set.vec(geminal_2).coef(b2)/.overlap
             coef_2 = .ket_set.vec(geminal_2).coef(b2)
             term = ZERO
             do j=3,5 ! geminal with SX, ISY or GD2 in block "block_1" are considered
                geminal_1 = .block_types(block_1).element(j) 
                if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                   coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                   if (ng_2 > 0) then
                      .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                      if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_2+1))) then
                         red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                         red_pbg_2.calc_overlap_integral(overlap,FALSE)
                         term(j) = coef_prod*overlap
                      else
                         term(j) = ZERO
                      end
                   else
                      term(j) = coef_prod
                   end
                end
             end
  
             t_1 = term(5)*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)
             t_2 = term(5)*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)
             sum_term=t_1+term(3)+term(4) 
             if (abs(sum_term) > NON_ZERO_2RTM_TOL) then
               .add_2rtm_ab_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .add_2rtm_aa_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .add_2rtm_bb_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .add_2rtm_ab_elt((/ ind_1,b2,ind_1,b2 /),sum_term)
             end

             sum_term=t_2+term(3)+term(4)
             if (abs(sum_term) > NON_ZERO_2RTM_TOL) then
               .add_2rtm_ab_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .add_2rtm_aa_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .add_2rtm_bb_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .add_2rtm_ab_elt((/ ind_2,b2,ind_2,b2 /),sum_term)
             end
          end
       end
     end

     ! the 2-ortho block is 4typ
     if (.n_2D_4typ_blocks /= 0) then
       do b1=m+1,.n_blocks
          block_1 = b1 - .n_1D_blocks
          ind_1 = .n_1D_blocks+2*block_1-1
          ind_2 = .n_1D_blocks+2*block_1
          do b2=1,.n_1D_blocks
             geminal_2 = .nonzero_1ortho_ind(b2)
             if (geminal_2 == 0) cycle
             coef_1 = .bra_set.vec(geminal_2).coef(b2)/.overlap
             coef_2 = .ket_set.vec(geminal_2).coef(b2)
             term = ZERO
             do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block_1" are considered
                geminal_1 = .block_types(block_1).element(j) 
                if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                   coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                   if (ng_2 > 0) then
                      .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                      if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_2+1))) then
                         red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                         red_pbg_2.calc_overlap_integral(overlap,FALSE)
                         term(j) = coef_prod*overlap
                      else
                         term(j) = ZERO
                      end
                   else
                      term(j) = coef_prod  
                   end  
                end
             end
  
             sum_term=sum(term)
             if (abs(sum_term) > NON_ZERO_2RTM_TOL) then
               .add_2rtm_ab_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .add_2rtm_aa_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .add_2rtm_bb_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .add_2rtm_ab_elt((/ ind_1,b2,ind_1,b2 /),sum_term)
  
               .add_2rtm_ab_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .add_2rtm_aa_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .add_2rtm_bb_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .add_2rtm_ab_elt((/ ind_2,b2,ind_2,b2 /),sum_term)
             end
          end
       end
     end

   end

   calc_2rtm_two_2D_blocks_epi2o(red_pbg_1,red_pbg_2,make_grad_info)
   ! calculation of the 2RTM elements when two 2D-blocks. Case 1d (2 distinct geminals) 
   ! and case 2a (only one geminal has the 2 blocks) of the paper
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     make_grad_info :: BIN, optional
     m :: INT
     block_1, block_2 :: INT
     ind_1, ind_2, ind_3, ind_4 :: INT
     grad_info :: BIN
     !
     if(present(make_grad_info)) then
       grad_info=make_grad_info
     else
       grad_info=FALSE
     end


     if(grad_info) then
       .comp_2rtm_two_2D_blocks_2b_epi2o_grd(red_pbg_1)
     else
       .comp_2rtm_two_2D_blocks_2b_epi2o(red_pbg_1)
     end
!debug    stdout.show(".nonzero_terms_ab after 2D-2D 2b",.nonzero_terms_ab)
     m=.n_2D_blocks
     do block_1=1,m-1
        !orbital indices for block_1
        ind_1 = .n_1D_blocks+2*block_1-1
        ind_2 = .n_1D_blocks+2*block_1

        do block_2=block_1+1,m
           !orbital indices for block_2
           ind_3 = .n_1D_blocks+2*block_2-1
           ind_4 = .n_1D_blocks+2*block_2

           if(grad_info) then
             .comp_2rtm_two_2D_blocks_2a_epi2o_grd(red_pbg_1,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
             .comp_2rtm_two_2D_blocks_1d_epi2o_grd(red_pbg_2,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
           else
             .comp_2rtm_two_2D_blocks_2a_epi2o(red_pbg_1,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
             .comp_2rtm_two_2D_blocks_1d_epi2o(red_pbg_2,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
           end
!debug     stdout.show(".nonzero_terms_ab after 2D-2D 2a",.nonzero_terms_ab)
!debug     stdout.show(".nonzero_terms_ab after 2D-2D 1d",.nonzero_terms_ab)
        end
      end
   end

   comp_2rtm_two_2D_blocks_2b_epi2o(red_pbg_1)
   ! calculation of the 2RDM elements where we consider just one block
   ! it corresponds to the third case in the thesis
   ! or to case 2b in the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     j, m :: INT
     b :: INT
     block, geminal :: INT
     ind_1, ind_2 :: INT
     element_coef :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN

     ng_1=red_pbg_1.n_geminals
     ! 2-orthogonal case
     m = .n_1D_blocks+.n_2D_3typ_blocks     
     
     term=ZERO
     ! the block is 3typ
     if (.n_2D_3typ_blocks /= 0) then
       do b=.n_1D_blocks+1,m
          block = b - .n_1D_blocks
          ! orbital indices for this block
          ind_1 = .n_1D_blocks+2*block-1
          ind_2 = .n_1D_blocks+2*block
          do j=3,5 ! block types ID2, SZ are skipped
             geminal = .block_types(block).element(j) 
             if (geminal /= 0) then
                !must divide by two to get the product of lambda from the dzeta in case of 2D-blocks
                coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO/.overlap
                if (ng_1 /= 0) then
                   .prep_red_pbg(red_pbg_1, geminal, block, problem)
                   if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                      red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
                      red_pbg_1.calc_overlap_integral(overlap,FALSE)
                      term(j) = coef_prod*overlap
                   else
                      term(j) = ZERO
                   end
                else
                ! no overlap left in case there is only one geminal
                   term(j) = coef_prod
                end
             else
                term(j) = ZERO
             end
          end

          element_coef = term(5)*.first_GD2_elt(block)*.first_GD2_elt(block)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_1,ind_1 /),element_coef)
          end
  
          element_coef = term(5)*.second_GD2_elt(block)*.second_GD2_elt(block)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_2,ind_2 /),element_coef)
          end
  
          element_coef = term(5)*.first_GD2_elt(block)*.second_GD2_elt(block)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_2,ind_2 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_1,ind_1 /),element_coef)
          end

          element_coef = term(3)+term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_1,ind_2 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_2,ind_1 /),element_coef)
          end

          element_coef = term(3)-term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_2,ind_1 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_1,ind_2 /),element_coef)
          end
       end
     end

     ! the block is 4typ
     if (.n_2D_4typ_blocks /= 0) then
       do b=m+1,.n_blocks
          block = b - .n_1D_blocks
          ! orbital indices for this block
          ind_1 = .n_1D_blocks+2*block-1
          ind_2 = .n_1D_blocks+2*block
          do j=1,4 ! GD2 type is skipped
             geminal = .block_types(block).element(j) 
             if (geminal /= 0) then
                !must divide by two to get the product of lambda from the dzeta in case of 2D-blocks
                coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO/.overlap
                if (ng_1 /= 0) then
                   .prep_red_pbg(red_pbg_1, geminal, block, problem)
                   if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                      red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
                      red_pbg_1.calc_overlap_integral(overlap,FALSE)
                      term(j) = coef_prod*overlap
                   else
                      term(j) = ZERO
                   end
                else
                ! no overlap left in case there is only one geminal
                   term(j) = coef_prod
                end
             else
                term(j) = ZERO
             end
          end
          element_coef = term(1)+term(2)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_1,ind_1 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_2,ind_2 /),element_coef)
          end
          element_coef = term(3)+term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_1,ind_2 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_2,ind_1 /),element_coef)
          end
          element_coef = term(1)-term(2)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_2,ind_2 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_1,ind_1 /),element_coef)
          end
          element_coef = term(3)-term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_2,ind_1 /),element_coef)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_1,ind_2 /),element_coef)
          end
       end
     end

   end

   comp_2rtm_two_2D_blocks_2a_epi2o(red_pbg_1,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
   ! calculation of the 2RTM elements when two 2D-3typ blocks. Case 1d (2 distinct geminals) 
   ! and case 2a (only one geminal has the 2 blocks) of the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     block_1, block_2 :: INT
     ind_1, ind_2, ind_3, ind_4 :: INT
     ng_1 :: INT
     overlap :: REAL
     diag_diag,diag_ndiag,ndiag_diag,ndiag_ndiag :: VEC{INT}* DEFAULT_NULL
     r :: INT
     b1, b2 :: INT
     geminal :: INT
     terms :: VEC{REAL}(8)
     el11_bra, el11_ket :: REAL DEFAULT(ZERO)
     el22_bra, el22_ket :: REAL DEFAULT(ZERO)
     el12_bra, el12_ket :: REAL DEFAULT(ZERO)
     el21_bra, el21_ket :: REAL DEFAULT(ZERO)
     problem :: BIN

     ng_1 = red_pbg_1.n_geminals
     b1 = .n_1D_blocks + block_1 
     b2 = .n_1D_blocks + block_2 

     .make_set_intersection(.diag_set(block_1).element,.diag_set(block_2).element,diag_diag)
     .make_set_intersection(.diag_set(block_1).element,.non_diag_set(block_2).element,diag_ndiag)
     .make_set_intersection(.non_diag_set(block_1).element,.diag_set(block_2).element,ndiag_diag)
     .make_set_intersection(.non_diag_set(block_1).element,.non_diag_set(block_2).element,ndiag_ndiag)
     
     !2 diagonal block matrices
     terms=ZERO
     do r=1,diag_diag.dim
        geminal = diag_diag(r)
        select case (.bra_set.vec(geminal).block_type(b1))
           case("ID2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = el11_bra
           case("SZ") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = -el11_bra
           case("GD2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)*.first_GD2_elt(block_1)
              el22_bra = .bra_set.vec(geminal).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("ID2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = el11_ket
           case("SZ") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = -el11_ket
           case("GD2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)*.first_GD2_elt(block_2)
              el22_ket = .ket_set.vec(geminal).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! diagonal submatrices implies "i1 = j1 and i2 = j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        if (ng_1 /= 0) then
          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
          if (NOT problem) then
             red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
             red_pbg_1.calc_overlap_integral(overlap,FALSE)
          else
            !     overlap = ZERO
            cycle
          end
        else
           overlap = ONE
        end
        el11_ket = el11_ket*overlap
        el22_ket = el22_ket*overlap

        terms(1) = terms(1) + el11_bra*el11_ket
        terms(2) = terms(2) + el11_bra*el22_ket
        terms(3) = terms(3) + el22_bra*el11_ket
        terms(4) = terms(4) + el22_bra*el22_ket

     end          
     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_3,ind_3 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_1,ind_1 /),terms(1))
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_4,ind_4 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_1,ind_1 /),terms(2))
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_3,ind_3 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_2,ind_2 /),terms(3))
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_4,ind_4 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_2,ind_2 /),terms(4))
     end

     !2 non diagonal block matrices
     terms=ZERO
     do r=1,ndiag_ndiag.dim
        geminal = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal).block_type(b1))
           case("SX") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = el12_bra
           case("ISY") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = -el12_bra
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("SX") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = el12_ket
           case("ISY") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = -el12_ket
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! non diagonal submatrices implies "i1 /= j1" and "i2 /= j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
           if (NOT problem) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ZERO
           end
        else
           overlap = ONE
        end
        el12_ket = el12_ket*overlap
        el21_ket = el21_ket*overlap

        terms(1) = terms(1) + el12_bra*el12_ket
        terms(2) = terms(2) + el12_bra*el21_ket
        terms(3) = terms(3) + el21_bra*el12_ket
        terms(4) = terms(4) + el21_bra*el21_ket
     end          
     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_3,ind_4 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_1,ind_2 /),terms(1))
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_4,ind_3 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_1,ind_2 /),terms(2))
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_3,ind_4 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_2,ind_1 /),terms(3))
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_4,ind_3 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_2,ind_1 /),terms(4))
     end
     

     !diagonal on block_1 non diagonal on block_2 
     terms=ZERO
     do r=1,diag_ndiag.dim
        geminal = diag_ndiag(r)
        select case (.bra_set.vec(geminal).block_type(b1))
           case("ID2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = el11_bra
           case("SZ") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = -el11_bra
           case("GD2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)*.first_GD2_elt(block_1)
              el22_bra = .bra_set.vec(geminal).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("SX") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = el12_ket
           case("ISY") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = -el12_ket
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! diagonal submatrices implies "i1 = j1" 
        ! non diagonal submatrices implies "i2 /= j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        ! they correspond to cases "non diagonal - diagonal"
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
           if (NOT problem) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ZERO
           end
        else
           overlap = ONE
        end
        el12_ket = el12_ket*overlap
        el21_ket = el21_ket*overlap

        terms(1) = terms(1) + el11_bra*el12_ket
        terms(2) = terms(2) + el11_bra*el21_ket
        terms(3) = terms(3) + el22_bra*el12_ket
        terms(4) = terms(4) + el22_bra*el21_ket
     end          
     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_3,ind_4 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_1,ind_1 /),terms(1))
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_4,ind_3 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_1,ind_1 /),terms(2))
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_3,ind_4 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_2,ind_2 /),terms(3))
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_4,ind_3 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_2,ind_2 /),terms(4))
     end


     !non diagonal on block_1 diagonal on block_2 
     terms=ZERO
     do r=1,ndiag_diag.dim
        geminal = ndiag_diag(r)
        select case (.bra_set.vec(geminal).block_type(b1))
           case("SX") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = el12_bra
           case("ISY") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = -el12_bra
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("ID2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = el11_ket
           case("SZ") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = -el11_ket
           case("GD2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)*.first_GD2_elt(block_2)
              el22_ket = .ket_set.vec(geminal).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! non diagonal submatrices implies "i1 /= j1" 
        ! diagonal submatrices implies "i2 = j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        ! they correspond to cases "diagonal - non diagonal"
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
           if (NOT problem) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ZERO
           end
        else
           overlap = ONE
        end
        el11_ket = el11_ket*overlap
        el22_ket = el22_ket*overlap

        terms(1) = terms(1) + el12_bra*el11_ket
        terms(2) = terms(2) + el12_bra*el22_ket
        terms(3) = terms(3) + el21_bra*el11_ket
        terms(4) = terms(4) + el21_bra*el22_ket
     end          
     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_3,ind_3 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_1,ind_2 /),terms(1))
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_4,ind_4 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_1,ind_2 /),terms(2))
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_3,ind_3 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_2,ind_1 /),terms(3))
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_4,ind_4 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_2,ind_1 /),terms(4))
     end

   end

   comp_2rtm_two_2D_blocks_1d_epi2o(red_pbg_2,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
   ! calculation of the 2RTM elements when two 2D-3typ blocks. Case 1d (2 distinct geminals) 
   ! and case 2a (only one geminal has the 2 blocks) of the paper
     red_pbg_2 :: PAULI_BLOCK_GEMINALS
     block_1, block_2 :: INT
     ind_1, ind_2, ind_3, ind_4 :: INT
     ng_2 :: INT
     overlap :: REAL
     diag_diag,diag_ndiag,ndiag_diag,ndiag_ndiag :: VEC{INT}* DEFAULT_NULL
     compl_1,compl_2 :: VEC{INT}* DEFAULT_NULL
     diag_b1_not_b2,ndiag_b1_not_b2,diag_b2_not_b1,ndiag_b2_not_b1 :: VEC{INT}* DEFAULT_NULL
     b1, b2, r, s :: INT
     geminal_1,geminal_2 :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL DEFAULT(ZERO)
     coef_5, coef_6, coef_7, coef_8 :: REAL DEFAULT(ZERO)
     coef_9, coef_10, coef_11, coef_12 :: REAL DEFAULT(ZERO)
     coef_13, coef_16 :: REAL DEFAULT(ZERO)
!     coef_13, coef_14, coef_15, coef_16 :: REAL DEFAULT(ZERO)
     el11_bra_1, el11_bra_2, el11_bra_3, el11_bra_4 :: REAL DEFAULT(ZERO)
     el22_bra_1, el22_bra_2, el22_bra_3, el22_bra_4 :: REAL DEFAULT(ZERO)
     el12_bra_1, el12_bra_2, el12_bra_3, el12_bra_4 :: REAL DEFAULT(ZERO)
     el21_bra_1, el21_bra_2, el21_bra_3, el21_bra_4 :: REAL DEFAULT(ZERO)
     el11_ket_1, el11_ket_2, el11_ket_3, el11_ket_4 :: REAL DEFAULT(ZERO)
     el22_ket_1, el22_ket_2, el22_ket_3, el22_ket_4 :: REAL DEFAULT(ZERO)
     el12_ket_1, el12_ket_2, el12_ket_3, el12_ket_4 :: REAL DEFAULT(ZERO)
     el21_ket_1, el21_ket_2, el21_ket_3, el21_ket_4 :: REAL DEFAULT(ZERO)
     terms :: VEC{REAL}(4)
     problem :: BIN

     ng_2 = red_pbg_2.n_geminals
     b1 = .n_1D_blocks + block_1 
     b2 = .n_1D_blocks + block_2 

     !debug     stdout.show("b1 ",b1)
     !debug     stdout.show("block_1 ",block_1)
     !debug     stdout.show(".diag_set(block_1).element ",.diag_set(block_1).element)
     !debug     stdout.show(".non_diag_set(block_1).element ",.non_diag_set(block_1).element)
     !debug     stdout.show(".any_type_set(block_1).element ",.any_type_set(block_1).element)
     !debug     stdout.show("b2 ",b2)
     !debug     stdout.show("block_2 ",block_2)
     !debug     stdout.show(".diag_set(block_2).element ",.diag_set(block_2).element)
     !debug     stdout.show(".non_diag_set(block_2).element ",.non_diag_set(block_2).element)
     !debug     stdout.show(".any_type_set(block_2).element ",.any_type_set(block_2).element)

     .make_set_intersection(.diag_set(block_1).element,.diag_set(block_2).element,diag_diag)
     .make_set_intersection(.diag_set(block_1).element,.non_diag_set(block_2).element,diag_ndiag)
     .make_set_intersection(.non_diag_set(block_1).element,.diag_set(block_2).element,ndiag_diag)
     .make_set_intersection(.non_diag_set(block_1).element,.non_diag_set(block_2).element,ndiag_ndiag)
     
     .make_set_complement(.any_type_set(block_1).element,compl_1)
     .make_set_complement(.any_type_set(block_2).element,compl_2)
     .make_set_intersection(.diag_set(block_1).element,compl_2,diag_b1_not_b2)
     .make_set_intersection(.non_diag_set(block_1).element,compl_2,ndiag_b1_not_b2)
     .make_set_intersection(.diag_set(block_2).element,compl_1,diag_b2_not_b1)
     .make_set_intersection(.non_diag_set(block_2).element,compl_1,ndiag_b2_not_b1)

     !debug     stdout.show("compl_1 ",compl_1)
     !debug     stdout.show("compl_2 ",compl_2)
     !debug     stdout.show("diag_diag.dim ",diag_diag.dim)
     !debug     stdout.show("diag_diag ",diag_diag)
     !debug     stdout.show("ndiag_diag.dim ",ndiag_diag.dim)
     !debug     stdout.show("ndiag_diag ",ndiag_diag)
     !debug     stdout.show("diag_ndiag.dim ",diag_ndiag.dim)
     !debug     stdout.show("diag_ndiag ",diag_ndiag)
     !debug     stdout.show("ndiag_ndiag.dim ",ndiag_ndiag.dim)
     !debug     stdout.show("ndiag_ndiag ",ndiag_ndiag)
     !debug     stdout.show("diag_b1_not_b2.dim",diag_b1_not_b2.dim)
     !debug     stdout.show("diag_b1_not_b2",diag_b1_not_b2)
     !debug     stdout.show("diag_b2_not_b1.dim",diag_b2_not_b1.dim)
     !debug     stdout.show("diag_b2_not_b1",diag_b2_not_b1)
     !debug     stdout.show("ndiag_b1_not_b2.dim",ndiag_b1_not_b2.dim)
     !debug     stdout.show("ndiag_b1_not_b2",ndiag_b1_not_b2)
     !debug     stdout.show("ndiag_b2_not_b1.dim",ndiag_b2_not_b1.dim)
     !debug     stdout.show("ndiag_b2_not_b1",ndiag_b2_not_b1)

     terms=ZERO
     ! "i1 = i2 and j1 = j2" => 2 diagonal block matrices or 2 non diagonal block matrices
     ! on each block
     do r=1,.diag_set(block_1).element.dim
        geminal_1 = .diag_set(block_1).element(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_1*el11_ket_1
        coef_2 = el22_bra_1*el22_ket_1

        do s=1,diag_b2_not_b1.dim
           geminal_2 = diag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           coef_3 = el11_bra_2*el11_ket_2
           coef_4 = el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b2_not_b1.dim
           geminal_2 = ndiag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el21_bra_2*el21_ket_2
           coef_4 = el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,.diag_set(block_2).element.dim
        geminal_1 = .diag_set(block_2).element(r)
        if (any(diag_b2_not_b1 == geminal_1)) cycle
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_3*el11_ket_3
        coef_2 = el22_bra_3*el22_ket_3

        do s=1,diag_b1_not_b2.dim
           geminal_2 = diag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el11_bra_4*el11_ket_4
           coef_4 = el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b1_not_b2.dim
           geminal_2 = ndiag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4  
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = el12_ket_4  
              case("ISY")                 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4 
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = -el12_ket_4 
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el12_bra_4*el12_ket_4
           coef_4 = el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
!       coef_1_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
!       coef_1_prod_2 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b2)
!       coef_1_prod_3 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)
!       coef_1_prod_4 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)                
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
        coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
        coef_16 = el22_bra_3*el22_ket_3
  
        do s=r+1,diag_diag.dim
           geminal_2 = diag_diag(s)
!          coef_2_prod_1 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b1)
!          coef_2_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
!          coef_2_prod_3 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!          coef_2_prod_4 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)                
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_13 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_16 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_13 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_16 * el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_5 * el11_bra_2*el11_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el11_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el22_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el22_ket_4

           terms(1)=terms(1) + coef_9  * el11_bra_4*el11_ket_2
           terms(2)=terms(2) + coef_10 * el11_bra_4*el22_ket_2
           terms(3)=terms(3) + coef_11 * el22_bra_4*el11_ket_2
           terms(4)=terms(4) + coef_12 * el22_bra_4*el22_ket_2
        end          

        do s=1,ndiag_ndiag.dim
           geminal_2 = ndiag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el21_bra_2*el21_ket_2
           terms(2)=terms(2) + coef_1 * el12_bra_2*el12_ket_2
           terms(3)=terms(3) + coef_4 * el21_bra_2*el21_ket_2
           terms(4)=terms(4) + coef_4 * el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_13 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_16 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_13 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_16 * el21_bra_4*el21_ket_4
        end          

        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el21_bra_2*el21_ket_2
           terms(2)=terms(2) + coef_1 * el12_bra_2*el12_ket_2
           terms(3)=terms(3) + coef_4 * el21_bra_2*el21_ket_2
           terms(4)=terms(4) + coef_4 * el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_13 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_16 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_13 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_16 * el22_bra_4*el22_ket_4
        end          

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_13 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_16 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_13 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_16 * el21_bra_4*el21_ket_4
        end          
     end          

     ! 2 non diagonal block matrices
     do r=1,.non_diag_set(block_1).element.dim
        geminal_1 = .non_diag_set(block_1).element(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_1*el12_ket_1
        coef_2 = el21_bra_1*el21_ket_1

        do s=1,diag_b2_not_b1.dim
           geminal_2 = diag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           coef_3 = el11_bra_2*el11_ket_2
           coef_4 = el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b2_not_b1.dim
           geminal_2 = ndiag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el21_bra_2*el21_ket_2
           coef_4 = el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,.non_diag_set(block_2).element.dim
        geminal_1 = .non_diag_set(block_2).element(r)
        if (any(ndiag_b2_not_b1 == geminal_1)) cycle
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_3*el12_ket_3
        coef_2 = el21_bra_3*el21_ket_3

        do s=1,diag_b1_not_b2.dim
           geminal_2 = diag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el11_bra_4*el11_ket_4
           coef_4 = el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b1_not_b2.dim
           geminal_2 = ndiag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4  
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = el12_ket_4  
              case("ISY")                 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4 
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = -el12_ket_4 
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el12_bra_4*el12_ket_4
           coef_4 = el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,ndiag_ndiag.dim
        geminal_1 = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_1*el12_ket_1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
        coef_4 = el21_bra_1*el21_ket_1
        coef_5 = el12_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_6 = el12_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_7 = el21_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_8 = el21_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_9  = el12_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_10 = el21_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_11 = el12_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_12 = el21_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_13 = el12_bra_3*el12_ket_3 !term2 j1=ind4, j2=ind4  
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
        coef_16 = el21_bra_3*el21_ket_3 !term2 j1=ind3, j2=ind3  

        do s=r+1,ndiag_ndiag.dim
           geminal_2 = ndiag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el12_bra_2*el12_ket_2
           terms(2)=terms(2) + coef_1 * el21_bra_2*el21_ket_2
           terms(3)=terms(3) + coef_4 * el12_bra_2*el12_ket_2
           terms(4)=terms(4) + coef_4 * el21_bra_2*el21_ket_2

           terms(1)=terms(1) + coef_16 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_13 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_16 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_13 * el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_6 * el21_bra_2*el12_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el12_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el21_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el21_ket_4

           terms(1)=terms(1) + coef_10 * el12_bra_4*el21_ket_2
           terms(2)=terms(2) + coef_9  * el12_bra_4*el12_ket_2
           terms(3)=terms(3) + coef_12 * el21_bra_4*el21_ket_2
           terms(4)=terms(4) + coef_11 * el21_bra_4*el12_ket_2
        end          

        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el12_bra_2*el12_ket_2
           terms(2)=terms(2) + coef_1 * el21_bra_2*el21_ket_2
           terms(3)=terms(3) + coef_4 * el12_bra_2*el12_ket_2
           terms(4)=terms(4) + coef_4 * el21_bra_2*el21_ket_2

           terms(1)=terms(1) + coef_16 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_13 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_16 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_13 * el22_bra_4*el22_ket_4
        end          

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_16 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_13 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_16 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_13 * el21_bra_4*el21_ket_4
        end          
     end          

     do r=1,diag_ndiag.dim
        geminal_1 = diag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
        coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_6 = el11_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_7 = el22_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_8 = el22_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_9  = el12_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_10 = el21_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_11 = el12_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_12 = el21_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_13 = el12_bra_3*el12_ket_3 !term2 j1=ind4, j2=ind4
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
        coef_16 = el21_bra_3*el21_ket_3 !term2 j1=ind3, j2=ind3

        do s=r+1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el12_bra_2*el12_ket_2
           terms(2)=terms(2) + coef_1 * el21_bra_2*el21_ket_2
           terms(3)=terms(3) + coef_4 * el12_bra_2*el12_ket_2
           terms(4)=terms(4) + coef_4 * el21_bra_2*el21_ket_2

           terms(1)=terms(1) + coef_16 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_13 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_16 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_13 * el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_6 * el21_bra_2*el11_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el11_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el22_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el22_ket_4

           terms(1)=terms(1) + coef_10 * el11_bra_4*el21_ket_2
           terms(2)=terms(2) + coef_9  * el11_bra_4*el12_ket_2
           terms(3)=terms(3) + coef_12 * el22_bra_4*el21_ket_2
           terms(4)=terms(4) + coef_11 * el22_bra_4*el12_ket_2
        end          

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_16 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_13 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_16 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_13 * el21_bra_4*el21_ket_4
        end          
     end          

     do r=1,ndiag_diag.dim
        geminal_1 = ndiag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_1*el12_ket_1 !term1 i1=ind1, i2=ind1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
        coef_4 = el21_bra_1*el21_ket_1 !term1 i1=ind2, i2=ind2
        coef_5 = el12_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_6 = el12_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_7 = el21_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_8 = el21_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_9  = el11_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3  
        coef_10 = el22_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4  
        coef_11 = el11_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3  
        coef_12 = el22_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4  
        coef_13 = el11_bra_3*el11_ket_3 !term2 j1=ind3, j2=ind3  
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
        coef_16 = el22_bra_3*el22_ket_3 !term2 j1=ind4, j2=ind4  

        do s=r+1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_13 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_16 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_13 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_16 * el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_5 * el11_bra_2*el12_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el12_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el21_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el21_ket_4

           terms(1)=terms(1) + coef_9  * el12_bra_4*el11_ket_2
           terms(2)=terms(2) + coef_10 * el12_bra_4*el22_ket_2
           terms(3)=terms(3) + coef_11 * el21_bra_4*el11_ket_2
           terms(4)=terms(4) + coef_12 * el21_bra_4*el22_ket_2
        end          
     end          
     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_1,ind_3 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_1,ind_3 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_1,ind_3 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_3,ind_1 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_1,ind_4 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_1,ind_4 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_1,ind_4 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_4,ind_1 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_2,ind_3 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_2,ind_3 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_2,ind_3 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_3,ind_2 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_2,ind_4 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_2,ind_4 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_2,ind_4 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_4,ind_2 /),terms(4))
     end

     ! "i1 /= i2 and j1 /= j2" => for each block one diagonal and one non diagonal block matrices
     ! => only third and fourth terms of case 1d to consider 
     terms=ZERO
     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind4
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind3
!       coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
!       coef_16 = el22_bra_3*el22_ket_3
  
        do s=1,ndiag_ndiag.dim
           geminal_2 = ndiag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_6 * el21_bra_2*el21_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el21_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el12_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el12_ket_4

           terms(1)=terms(1) + coef_11 * el12_bra_4*el12_ket_2
           terms(2)=terms(2) + coef_12 * el12_bra_4*el21_ket_2
           terms(3)=terms(3) + coef_9  * el21_bra_4*el12_ket_2
           terms(4)=terms(4) + coef_10 * el21_bra_4*el21_ket_2
        end          
     end          

     do r=1,diag_ndiag.dim
        geminal_1 = diag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind4
        coef_6 = el11_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind3
        coef_7 = el22_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_8 = el22_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_9  = el12_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_10 = el21_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_11 = el12_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind3
        coef_12 = el21_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind4
!       coef_13 = el12_bra_3*el12_ket_3
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
!       coef_16 = el21_bra_3*el21_ket_3

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_5 * el11_bra_2*el21_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el21_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el12_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el12_ket_4

           terms(1)=terms(1) + coef_12 * el12_bra_4*el22_ket_2
           terms(2)=terms(2) + coef_11 * el12_bra_4*el11_ket_2
           terms(3)=terms(3) + coef_10 * el21_bra_4*el22_ket_2
           terms(4)=terms(4) + coef_9  * el21_bra_4*el11_ket_2
        end          
     end          

     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_2,ind_4 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_2,ind_4 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_2,ind_4 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_4,ind_2 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_2,ind_3 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_2,ind_3 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_2,ind_3 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_3,ind_2 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_1,ind_4 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_1,ind_4 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_1,ind_4 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_4,ind_1 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_1,ind_3 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_1,ind_3 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_1,ind_3 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_3,ind_1 /),terms(4))
     end

     ! "i1 = i2 and j1 /= j2" => for block 1 two diagonal or two non diagonal block matrices
     ! for block 2 one diagonal and one non diagonal block matrices
     ! => only third and fourth terms of case 1d to consider 
     terms=ZERO
     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind4
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind3
!       coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
!       coef_16 = el22_bra_3*el22_ket_3
  
        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_6 * el21_bra_2*el11_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el11_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el22_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el22_ket_4

           terms(1)=terms(1) + coef_11 * el22_bra_4*el12_ket_2
           terms(2)=terms(2) + coef_12 * el22_bra_4*el21_ket_2
           terms(3)=terms(3) + coef_9  * el11_bra_4*el12_ket_2
           terms(4)=terms(4) + coef_10 * el11_bra_4*el21_ket_2
        end          
     end          

     do r=1,ndiag_ndiag.dim
        geminal_1 = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el12_bra_1*el12_ket_1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
!       coef_4 = el21_bra_1*el21_ket_1
        coef_5 = el12_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_6 = el12_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_7 = el21_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind4
        coef_8 = el21_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind3
        coef_9  = el12_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_10 = el21_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_11 = el12_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind3
        coef_12 = el21_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind4
!       coef_13 = el12_bra_3*el12_ket_3
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
!       coef_16 = el21_bra_3*el21_ket_3

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_5 * el11_bra_2*el12_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el12_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el21_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el21_ket_4

           terms(1)=terms(1) + coef_10 * el12_bra_4*el22_ket_2
           terms(2)=terms(2) + coef_9  * el12_bra_4*el11_ket_2
           terms(3)=terms(3) + coef_12 * el21_bra_4*el22_ket_2 
           terms(4)=terms(4) + coef_11 * el21_bra_4*el11_ket_2 
        end          
     end          

     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_1,ind_4 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_1,ind_4 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_1,ind_4 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_4,ind_1 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_1,ind_3 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_1,ind_3 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_1,ind_3 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_3,ind_1 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_2,ind_4 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_2,ind_4 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_2,ind_4 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_4,ind_2 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_2,ind_3 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_2,ind_3 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_2,ind_3 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_3,ind_2 /),terms(4))
     end

     ! "i1 /= i2 and j1 = j2" => for block 2 two diagonal or two non diagonal block matrices
     ! for block 1 one diagonal and one non diagonal block matrices
     ! => only third and fourth terms of case 1d to consider 
     terms=ZERO
     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind3
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind4
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind3
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind4
!       coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
!       coef_16 = el22_bra_3*el22_ket_3

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_5 * el11_bra_2*el21_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el21_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el12_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el12_ket_4

           terms(1)=terms(1) + coef_11 * el12_bra_4*el11_ket_2
           terms(2)=terms(2) + coef_12 * el12_bra_4*el22_ket_2
           terms(3)=terms(3) + coef_9  * el21_bra_4*el11_ket_2 
           terms(4)=terms(4) + coef_10 * el21_bra_4*el22_ket_2 
        end          
  
     end          

     do r=1,ndiag_ndiag.dim
        geminal_1 = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el12_bra_1*el12_ket_1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
!       coef_4 = el21_bra_1*el21_ket_1
        coef_5 = el12_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind4  
        coef_6 = el12_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind3  
        coef_7 = el21_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind4  
        coef_8 = el21_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind3  
        coef_9  = el12_bra_3*el12_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind4  
        coef_10 = el21_bra_3*el12_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind3  
        coef_11 = el12_bra_3*el21_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind4  
        coef_12 = el21_bra_3*el21_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind3  
!       coef_13 = el12_bra_3*el12_ket_3
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
!       coef_16 = el21_bra_3*el21_ket_3

        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_6 * el21_bra_2*el22_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el22_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el11_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el11_ket_4

           terms(1)=terms(1) + coef_12 * el11_bra_4*el21_ket_2
           terms(2)=terms(2) + coef_11 * el11_bra_4*el12_ket_2
           terms(3)=terms(3) + coef_10 * el22_bra_4*el21_ket_2
           terms(4)=terms(4) + coef_9  * el22_bra_4*el12_ket_2
        end          
     end          

     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_2,ind_3 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_2,ind_3 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_2,ind_3 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_3,ind_2 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_2,ind_4 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_2,ind_4 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_2,ind_4 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_4,ind_2 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_1,ind_3 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_1,ind_3 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_1,ind_3 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_3,ind_1 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_1,ind_4 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_1,ind_4 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_1,ind_4 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_4,ind_1 /),terms(4))
     end

   end

   comp_2rtm_two_2D_blocks_1d_epi2o_grd(red_pbg_2,block_1,block_2,ind_1,ind_2,ind_3,ind_4)
   ! calculation of the 2RTM elements when two 2D-3typ blocks. Case 1d (2 distinct geminals) 
   ! and case 2a (only one geminal has the 2 blocks) of the paper
     red_pbg_2 :: PAULI_BLOCK_GEMINALS
     block_1, block_2 :: INT
     ind_1, ind_2, ind_3, ind_4 :: INT
     ng_2 :: INT
     overlap :: REAL
     diag_diag,diag_ndiag,ndiag_diag,ndiag_ndiag :: VEC{INT}* DEFAULT_NULL
     compl_1,compl_2 :: VEC{INT}* DEFAULT_NULL
     diag_b1_not_b2,ndiag_b1_not_b2,diag_b2_not_b1,ndiag_b2_not_b1 :: VEC{INT}* DEFAULT_NULL
     b1, b2, r, s :: INT
     geminal_1,geminal_2 :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL DEFAULT(ZERO)
     coef_5, coef_6, coef_7, coef_8 :: REAL DEFAULT(ZERO)
     coef_9, coef_10, coef_11, coef_12 :: REAL DEFAULT(ZERO)
     coef_13, coef_16 :: REAL DEFAULT(ZERO)
!     coef_13, coef_14, coef_15, coef_16 :: REAL DEFAULT(ZERO)
     el11_bra_1, el11_bra_2, el11_bra_3, el11_bra_4 :: REAL DEFAULT(ZERO)
     el22_bra_1, el22_bra_2, el22_bra_3, el22_bra_4 :: REAL DEFAULT(ZERO)
     el12_bra_1, el12_bra_2, el12_bra_3, el12_bra_4 :: REAL DEFAULT(ZERO)
     el21_bra_1, el21_bra_2, el21_bra_3, el21_bra_4 :: REAL DEFAULT(ZERO)
     el11_ket_1, el11_ket_2, el11_ket_3, el11_ket_4 :: REAL DEFAULT(ZERO)
     el22_ket_1, el22_ket_2, el22_ket_3, el22_ket_4 :: REAL DEFAULT(ZERO)
     el12_ket_1, el12_ket_2, el12_ket_3, el12_ket_4 :: REAL DEFAULT(ZERO)
     el21_ket_1, el21_ket_2, el21_ket_3, el21_ket_4 :: REAL DEFAULT(ZERO)
     terms :: VEC{REAL}(4)
     problem :: BIN

     ng_2 = red_pbg_2.n_geminals
     b1 = .n_1D_blocks + block_1 
     b2 = .n_1D_blocks + block_2 

     !debug     stdout.show("b1 ",b1)
     !debug     stdout.show("block_1 ",block_1)
     !debug     stdout.show(".diag_set(block_1).element ",.diag_set(block_1).element)
     !debug     stdout.show(".non_diag_set(block_1).element ",.non_diag_set(block_1).element)
     !debug     stdout.show(".any_type_set(block_1).element ",.any_type_set(block_1).element)
     !debug     stdout.show("b2 ",b2)
     !debug     stdout.show("block_2 ",block_2)
     !debug     stdout.show(".diag_set(block_2).element ",.diag_set(block_2).element)
     !debug     stdout.show(".non_diag_set(block_2).element ",.non_diag_set(block_2).element)
     !debug     stdout.show(".any_type_set(block_2).element ",.any_type_set(block_2).element)

     .make_set_intersection(.diag_set(block_1).element,.diag_set(block_2).element,diag_diag)
     .make_set_intersection(.diag_set(block_1).element,.non_diag_set(block_2).element,diag_ndiag)
     .make_set_intersection(.non_diag_set(block_1).element,.diag_set(block_2).element,ndiag_diag)
     .make_set_intersection(.non_diag_set(block_1).element,.non_diag_set(block_2).element,ndiag_ndiag)
     
     .make_set_complement(.any_type_set(block_1).element,compl_1)
     .make_set_complement(.any_type_set(block_2).element,compl_2)
     .make_set_intersection(.diag_set(block_1).element,compl_2,diag_b1_not_b2)
     .make_set_intersection(.non_diag_set(block_1).element,compl_2,ndiag_b1_not_b2)
     .make_set_intersection(.diag_set(block_2).element,compl_1,diag_b2_not_b1)
     .make_set_intersection(.non_diag_set(block_2).element,compl_1,ndiag_b2_not_b1)

     !debug     stdout.show("compl_1 ",compl_1)
     !debug     stdout.show("compl_2 ",compl_2)
     !debug     stdout.show("diag_diag.dim ",diag_diag.dim)
     !debug     stdout.show("diag_diag ",diag_diag)
     !debug     stdout.show("ndiag_diag.dim ",ndiag_diag.dim)
     !debug     stdout.show("ndiag_diag ",ndiag_diag)
     !debug     stdout.show("diag_ndiag.dim ",diag_ndiag.dim)
     !debug     stdout.show("diag_ndiag ",diag_ndiag)
     !debug     stdout.show("ndiag_ndiag.dim ",ndiag_ndiag.dim)
     !debug     stdout.show("ndiag_ndiag ",ndiag_ndiag)
     !debug     stdout.show("diag_b1_not_b2.dim",diag_b1_not_b2.dim)
     !debug     stdout.show("diag_b1_not_b2",diag_b1_not_b2)
     !debug     stdout.show("diag_b2_not_b1.dim",diag_b2_not_b1.dim)
     !debug     stdout.show("diag_b2_not_b1",diag_b2_not_b1)
     !debug     stdout.show("ndiag_b1_not_b2.dim",ndiag_b1_not_b2.dim)
     !debug     stdout.show("ndiag_b1_not_b2",ndiag_b1_not_b2)
     !debug     stdout.show("ndiag_b2_not_b1.dim",ndiag_b2_not_b1.dim)
     !debug     stdout.show("ndiag_b2_not_b1",ndiag_b2_not_b1)

     terms=ZERO
     ! "i1 = i2 and j1 = j2" => 2 diagonal block matrices or 2 non diagonal block matrices
     ! on each block
     do r=1,.diag_set(block_1).element.dim
        geminal_1 = .diag_set(block_1).element(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_1*el11_ket_1
        coef_2 = el22_bra_1*el22_ket_1

        do s=1,diag_b2_not_b1.dim
           geminal_2 = diag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           coef_3 = el11_bra_2*el11_ket_2
           coef_4 = el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b2_not_b1.dim
           geminal_2 = ndiag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el21_bra_2*el21_ket_2
           coef_4 = el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,.diag_set(block_2).element.dim
        geminal_1 = .diag_set(block_2).element(r)
        if (any(diag_b2_not_b1 == geminal_1)) cycle
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_3*el11_ket_3
        coef_2 = el22_bra_3*el22_ket_3

        do s=1,diag_b1_not_b2.dim
           geminal_2 = diag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el11_bra_4*el11_ket_4
           coef_4 = el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b1_not_b2.dim
           geminal_2 = ndiag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4  
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = el12_ket_4  
              case("ISY")                 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4 
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = -el12_ket_4 
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el12_bra_4*el12_ket_4
           coef_4 = el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
!       coef_1_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
!       coef_1_prod_2 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b2)
!       coef_1_prod_3 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)
!       coef_1_prod_4 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)                
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
        coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
        coef_16 = el22_bra_3*el22_ket_3
  
        do s=r+1,diag_diag.dim
           geminal_2 = diag_diag(s)
!          coef_2_prod_1 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b1)
!          coef_2_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
!          coef_2_prod_3 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!          coef_2_prod_4 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)                
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_13 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_16 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_13 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_16 * el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_5 * el11_bra_2*el11_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el11_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el22_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el22_ket_4

           terms(1)=terms(1) + coef_9  * el11_bra_4*el11_ket_2
           terms(2)=terms(2) + coef_10 * el11_bra_4*el22_ket_2
           terms(3)=terms(3) + coef_11 * el22_bra_4*el11_ket_2
           terms(4)=terms(4) + coef_12 * el22_bra_4*el22_ket_2
        end          

        do s=1,ndiag_ndiag.dim
           geminal_2 = ndiag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el21_bra_2*el21_ket_2
           terms(2)=terms(2) + coef_1 * el12_bra_2*el12_ket_2
           terms(3)=terms(3) + coef_4 * el21_bra_2*el21_ket_2
           terms(4)=terms(4) + coef_4 * el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_13 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_16 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_13 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_16 * el21_bra_4*el21_ket_4
        end          

        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el21_bra_2*el21_ket_2
           terms(2)=terms(2) + coef_1 * el12_bra_2*el12_ket_2
           terms(3)=terms(3) + coef_4 * el21_bra_2*el21_ket_2
           terms(4)=terms(4) + coef_4 * el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_13 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_16 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_13 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_16 * el22_bra_4*el22_ket_4
        end          

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_13 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_16 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_13 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_16 * el21_bra_4*el21_ket_4
        end          
     end          

     ! 2 non diagonal block matrices
     do r=1,.non_diag_set(block_1).element.dim
        geminal_1 = .non_diag_set(block_1).element(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_1*el12_ket_1
        coef_2 = el21_bra_1*el21_ket_1

        do s=1,diag_b2_not_b1.dim
           geminal_2 = diag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           coef_3 = el11_bra_2*el11_ket_2
           coef_4 = el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b2_not_b1.dim
           geminal_2 = ndiag_b2_not_b1(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el21_bra_2*el21_ket_2
           coef_4 = el12_bra_2*el12_ket_2

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_1*coef_4
           terms(3)=terms(3) + coef_2*coef_3
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,.non_diag_set(block_2).element.dim
        geminal_1 = .non_diag_set(block_2).element(r)
        if (any(ndiag_b2_not_b1 == geminal_1)) cycle
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_3*el12_ket_3
        coef_2 = el21_bra_3*el21_ket_3

        do s=1,diag_b1_not_b2.dim
           geminal_2 = diag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el11_bra_4*el11_ket_4
           coef_4 = el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          

        do s=1,ndiag_b1_not_b2.dim
           geminal_2 = ndiag_b1_not_b2(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4  
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = el12_ket_4  
              case("ISY")                 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4 
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el21_ket_4 = -el12_ket_4 
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           coef_3 = el12_bra_4*el12_ket_4
           coef_4 = el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_1*coef_3
           terms(2)=terms(2) + coef_2*coef_3
           terms(3)=terms(3) + coef_1*coef_4
           terms(4)=terms(4) + coef_2*coef_4
        end          
     end          

     do r=1,ndiag_ndiag.dim
        geminal_1 = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_1*el12_ket_1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
        coef_4 = el21_bra_1*el21_ket_1
        coef_5 = el12_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_6 = el12_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_7 = el21_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_8 = el21_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_9  = el12_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_10 = el21_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_11 = el12_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_12 = el21_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_13 = el12_bra_3*el12_ket_3 !term2 j1=ind4, j2=ind4  
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
        coef_16 = el21_bra_3*el21_ket_3 !term2 j1=ind3, j2=ind3  

        do s=r+1,ndiag_ndiag.dim
           geminal_2 = ndiag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el12_bra_2*el12_ket_2
           terms(2)=terms(2) + coef_1 * el21_bra_2*el21_ket_2
           terms(3)=terms(3) + coef_4 * el12_bra_2*el12_ket_2
           terms(4)=terms(4) + coef_4 * el21_bra_2*el21_ket_2

           terms(1)=terms(1) + coef_16 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_13 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_16 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_13 * el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_6 * el21_bra_2*el12_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el12_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el21_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el21_ket_4

           terms(1)=terms(1) + coef_10 * el12_bra_4*el21_ket_2
           terms(2)=terms(2) + coef_9  * el12_bra_4*el12_ket_2
           terms(3)=terms(3) + coef_12 * el21_bra_4*el21_ket_2
           terms(4)=terms(4) + coef_11 * el21_bra_4*el12_ket_2
        end          

        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el12_bra_2*el12_ket_2
           terms(2)=terms(2) + coef_1 * el21_bra_2*el21_ket_2
           terms(3)=terms(3) + coef_4 * el12_bra_2*el12_ket_2
           terms(4)=terms(4) + coef_4 * el21_bra_2*el21_ket_2

           terms(1)=terms(1) + coef_16 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_13 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_16 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_13 * el22_bra_4*el22_ket_4
        end          

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_16 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_13 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_16 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_13 * el21_bra_4*el21_ket_4
        end          
     end          

     do r=1,diag_ndiag.dim
        geminal_1 = diag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
        coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_6 = el11_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_7 = el22_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_8 = el22_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_9  = el12_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_10 = el21_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_11 = el12_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_12 = el21_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_13 = el12_bra_3*el12_ket_3 !term2 j1=ind4, j2=ind4
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
        coef_16 = el21_bra_3*el21_ket_3 !term2 j1=ind3, j2=ind3

        do s=r+1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el12_bra_2*el12_ket_2
           terms(2)=terms(2) + coef_1 * el21_bra_2*el21_ket_2
           terms(3)=terms(3) + coef_4 * el12_bra_2*el12_ket_2
           terms(4)=terms(4) + coef_4 * el21_bra_2*el21_ket_2

           terms(1)=terms(1) + coef_16 * el11_bra_4*el11_ket_4
           terms(2)=terms(2) + coef_13 * el11_bra_4*el11_ket_4
           terms(3)=terms(3) + coef_16 * el22_bra_4*el22_ket_4
           terms(4)=terms(4) + coef_13 * el22_bra_4*el22_ket_4

           terms(1)=terms(1) + coef_6 * el21_bra_2*el11_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el11_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el22_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el22_ket_4

           terms(1)=terms(1) + coef_10 * el11_bra_4*el21_ket_2
           terms(2)=terms(2) + coef_9  * el11_bra_4*el12_ket_2
           terms(3)=terms(3) + coef_12 * el22_bra_4*el21_ket_2
           terms(4)=terms(4) + coef_11 * el22_bra_4*el12_ket_2
        end          

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_16 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_13 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_16 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_13 * el21_bra_4*el21_ket_4
        end          
     end          

     do r=1,ndiag_diag.dim
        geminal_1 = ndiag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        coef_1 = el12_bra_1*el12_ket_1 !term1 i1=ind1, i2=ind1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
        coef_4 = el21_bra_1*el21_ket_1 !term1 i1=ind2, i2=ind2
        coef_5 = el12_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind3
        coef_6 = el12_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind4
        coef_7 = el21_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind3
        coef_8 = el21_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind4
        coef_9  = el11_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind3  
        coef_10 = el22_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind4  
        coef_11 = el11_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind3  
        coef_12 = el22_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind4  
        coef_13 = el11_bra_3*el11_ket_3 !term2 j1=ind3, j2=ind3  
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
        coef_16 = el22_bra_3*el22_ket_3 !term2 j1=ind4, j2=ind4  

        do s=r+1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_1 * el11_bra_2*el11_ket_2
           terms(2)=terms(2) + coef_1 * el22_bra_2*el22_ket_2
           terms(3)=terms(3) + coef_4 * el11_bra_2*el11_ket_2
           terms(4)=terms(4) + coef_4 * el22_bra_2*el22_ket_2

           terms(1)=terms(1) + coef_13 * el12_bra_4*el12_ket_4
           terms(2)=terms(2) + coef_16 * el12_bra_4*el12_ket_4
           terms(3)=terms(3) + coef_13 * el21_bra_4*el21_ket_4
           terms(4)=terms(4) + coef_16 * el21_bra_4*el21_ket_4

           terms(1)=terms(1) + coef_5 * el11_bra_2*el12_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el12_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el21_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el21_ket_4

           terms(1)=terms(1) + coef_9  * el12_bra_4*el11_ket_2
           terms(2)=terms(2) + coef_10 * el12_bra_4*el22_ket_2
           terms(3)=terms(3) + coef_11 * el21_bra_4*el11_ket_2
           terms(4)=terms(4) + coef_12 * el21_bra_4*el22_ket_2
        end          
     end          
     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_1,ind_3 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_1,ind_3 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_1,ind_3 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_3,ind_1 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_1,ind_4 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_1,ind_4 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_1,ind_4 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_4,ind_1 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_2,ind_3 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_2,ind_3 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_2,ind_3 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_3,ind_2 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_2,ind_4 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_2,ind_4 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_2,ind_4 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_4,ind_2 /),terms(4))
     end

     ! "i1 /= i2 and j1 /= j2" => for each block one diagonal and one non diagonal block matrices
     ! => only third and fourth terms of case 1d to consider 
     terms=ZERO
     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind4
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind3
!       coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
!       coef_16 = el22_bra_3*el22_ket_3
  
        do s=1,ndiag_ndiag.dim
           geminal_2 = ndiag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_6 * el21_bra_2*el21_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el21_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el12_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el12_ket_4

           terms(1)=terms(1) + coef_11 * el12_bra_4*el12_ket_2
           terms(2)=terms(2) + coef_12 * el12_bra_4*el21_ket_2
           terms(3)=terms(3) + coef_9  * el21_bra_4*el12_ket_2
           terms(4)=terms(4) + coef_10 * el21_bra_4*el21_ket_2
        end          
     end          

     do r=1,diag_ndiag.dim
        geminal_1 = diag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind4
        coef_6 = el11_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind3
        coef_7 = el22_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_8 = el22_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_9  = el12_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind3
        coef_10 = el21_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind4
        coef_11 = el12_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind3
        coef_12 = el21_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind4
!       coef_13 = el12_bra_3*el12_ket_3
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
!       coef_16 = el21_bra_3*el21_ket_3

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_5 * el11_bra_2*el21_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el21_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el12_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el12_ket_4

           terms(1)=terms(1) + coef_12 * el12_bra_4*el22_ket_2
           terms(2)=terms(2) + coef_11 * el12_bra_4*el11_ket_2
           terms(3)=terms(3) + coef_10 * el21_bra_4*el22_ket_2
           terms(4)=terms(4) + coef_9  * el21_bra_4*el11_ket_2
        end          
     end          

     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_2,ind_4 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_2,ind_4 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_2,ind_4 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_4,ind_2 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_2,ind_3 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_2,ind_3 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_2,ind_3 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_3,ind_2 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_1,ind_4 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_1,ind_4 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_1,ind_4 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_4,ind_1 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_1,ind_3 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_1,ind_3 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_1,ind_3 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_3,ind_1 /),terms(4))
     end

     ! "i1 = i2 and j1 /= j2" => for block 1 two diagonal or two non diagonal block matrices
     ! for block 2 one diagonal and one non diagonal block matrices
     ! => only third and fourth terms of case 1d to consider 
     terms=ZERO
     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind4
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind3
!       coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
!       coef_16 = el22_bra_3*el22_ket_3
  
        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_6 * el21_bra_2*el11_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el11_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el22_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el22_ket_4

           terms(1)=terms(1) + coef_11 * el22_bra_4*el12_ket_2
           terms(2)=terms(2) + coef_12 * el22_bra_4*el21_ket_2
           terms(3)=terms(3) + coef_9  * el11_bra_4*el12_ket_2
           terms(4)=terms(4) + coef_10 * el11_bra_4*el21_ket_2
        end          
     end          

     do r=1,ndiag_ndiag.dim
        geminal_1 = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el12_bra_1*el12_ket_1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
!       coef_4 = el21_bra_1*el21_ket_1
        coef_5 = el12_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_6 = el12_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_7 = el21_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind2, j1=ind3, j2=ind4
        coef_8 = el21_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind2, j1=ind4, j2=ind3
        coef_9  = el12_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind4, j2=ind3
        coef_10 = el21_bra_3*el12_ket_1 !term4 i1=ind1, i2=ind1, j1=ind3, j2=ind4
        coef_11 = el12_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind4, j2=ind3
        coef_12 = el21_bra_3*el21_ket_1 !term4 i1=ind2, i2=ind2, j1=ind3, j2=ind4
!       coef_13 = el12_bra_3*el12_ket_3
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
!       coef_16 = el21_bra_3*el21_ket_3

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_5 * el11_bra_2*el12_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el12_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el21_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el21_ket_4

           terms(1)=terms(1) + coef_10 * el12_bra_4*el22_ket_2
           terms(2)=terms(2) + coef_9  * el12_bra_4*el11_ket_2
           terms(3)=terms(3) + coef_12 * el21_bra_4*el22_ket_2 
           terms(4)=terms(4) + coef_11 * el21_bra_4*el11_ket_2 
        end          
     end          

     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_1,ind_4 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_1,ind_4 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_1,ind_4 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_4,ind_1 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_1,ind_3 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_1,ind_3 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_1,ind_3 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_3,ind_1 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_2,ind_4 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_2,ind_4 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_2,ind_4 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_4,ind_2 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_2,ind_3 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_2,ind_3 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_2,ind_3 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_3,ind_2 /),terms(4))
     end

     ! "i1 /= i2 and j1 = j2" => for block 2 two diagonal or two non diagonal block matrices
     ! for block 1 one diagonal and one non diagonal block matrices
     ! => only third and fourth terms of case 1d to consider 
     terms=ZERO
     do r=1,diag_diag.dim
        geminal_1 = diag_diag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("ID2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = el11_ket_1
           case("SZ") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el22_bra_1 = -el11_bra_1
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el22_ket_1 = -el11_ket_1
           case("GD2") 
              el11_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_bra_1 = .bra_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
              el11_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.first_GD2_elt(block_1)
              el22_ket_1 = .ket_set.vec(geminal_1).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("ID2") 
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = el11_ket_3
           case("SZ")               
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el22_bra_3 = -el11_bra_3
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el22_ket_3 = -el11_ket_3
           case("GD2")              
              el11_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_bra_3 = .bra_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
              el11_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.first_GD2_elt(block_2)
              el22_ket_3 = .ket_set.vec(geminal_1).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el11_bra_1*el11_ket_1
!       coef_2 = el11_bra_1*el22_ket_1
!       coef_3 = el22_bra_1*el11_ket_1
!       coef_4 = el22_bra_1*el22_ket_1
        coef_5 = el11_bra_1*el11_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind3
        coef_6 = el11_bra_1*el22_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind4
        coef_7 = el22_bra_1*el11_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind3
        coef_8 = el22_bra_1*el22_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind4
        coef_9  = el11_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind3
        coef_10 = el22_bra_3*el11_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind4
        coef_11 = el11_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind3
        coef_12 = el22_bra_3*el22_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind4
!       coef_13 = el11_bra_3*el11_ket_3
!       coef_14 = el11_bra_3*el22_ket_3
!       coef_15 = el22_bra_3*el11_ket_3
!       coef_16 = el22_bra_3*el22_ket_3

        do s=1,ndiag_diag.dim
           geminal_2 = ndiag_diag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.ket_set.vec(geminal_2).block_type(b2))
              case("ID2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2
              case("SZ") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el22_bra_2 = -el11_bra_2
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = -el11_ket_2
              case("GD2") 
                 el11_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.first_GD2_elt(block_2)
                 el22_bra_2 = .bra_set.vec(geminal_2).coef(b2)*.second_GD2_elt(block_2)
                 el11_ket_2 = .ket_set.vec(geminal_2).coef(b2)*overlap
                 el22_ket_2 = el11_ket_2*.second_GD2_elt(block_2)
                 el11_ket_2 = el11_ket_2*.first_GD2_elt(block_2)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.bra_set.vec(geminal_2).block_type(b1))
              case("SX") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = el12_ket_4
              case("ISY") 
                 el12_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el21_bra_4 = -el12_bra_4
                 el12_ket_4 = .ket_set.vec(geminal_2).coef(b1)
                 el21_ket_4 = -el12_ket_4
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_5 * el11_bra_2*el21_ket_4
           terms(2)=terms(2) + coef_6 * el22_bra_2*el21_ket_4
           terms(3)=terms(3) + coef_7 * el11_bra_2*el12_ket_4
           terms(4)=terms(4) + coef_8 * el22_bra_2*el12_ket_4

           terms(1)=terms(1) + coef_11 * el12_bra_4*el11_ket_2
           terms(2)=terms(2) + coef_12 * el12_bra_4*el22_ket_2
           terms(3)=terms(3) + coef_9  * el21_bra_4*el11_ket_2 
           terms(4)=terms(4) + coef_10 * el21_bra_4*el22_ket_2 
        end          
  
     end          

     do r=1,ndiag_ndiag.dim
        geminal_1 = ndiag_ndiag(r)
        select case (.bra_set.vec(geminal_1).block_type(b1))
           case("SX") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = el12_ket_1
           case("ISY") 
              el12_bra_1 = .bra_set.vec(geminal_1).coef(b1)
              el21_bra_1 = -el12_bra_1
              el12_ket_1 = .ket_set.vec(geminal_1).coef(b1)
              el21_ket_1 = -el12_ket_1
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.bra_set.vec(geminal_1).block_type(b2))
           case("SX") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = el12_ket_3
           case("ISY") 
              el12_bra_3 = .bra_set.vec(geminal_1).coef(b2)
              el21_bra_3 = -el12_bra_3
              el12_ket_3 = .ket_set.vec(geminal_1).coef(b2)
              el21_ket_3 = -el12_ket_3
           case default   
              stdout.text("unexpected block type")
              stop
        end
!       coef_1 = el12_bra_1*el12_ket_1
!       coef_2 = el12_bra_1*el21_ket_1
!       coef_3 = el21_bra_1*el12_ket_1
!       coef_4 = el21_bra_1*el21_ket_1
        coef_5 = el12_bra_1*el12_ket_3 !term3 i1=ind1, i2=ind2, j1=ind4, j2=ind4  
        coef_6 = el12_bra_1*el21_ket_3 !term3 i1=ind1, i2=ind2, j1=ind3, j2=ind3  
        coef_7 = el21_bra_1*el12_ket_3 !term3 i1=ind2, i2=ind1, j1=ind4, j2=ind4  
        coef_8 = el21_bra_1*el21_ket_3 !term3 i1=ind2, i2=ind1, j1=ind3, j2=ind3  
        coef_9  = el12_bra_3*el12_ket_1 !term4 i1=ind2, i2=ind1, j1=ind4, j2=ind4  
        coef_10 = el21_bra_3*el12_ket_1 !term4 i1=ind2, i2=ind1, j1=ind3, j2=ind3  
        coef_11 = el12_bra_3*el21_ket_1 !term4 i1=ind1, i2=ind2, j1=ind4, j2=ind4  
        coef_12 = el21_bra_3*el21_ket_1 !term4 i1=ind1, i2=ind2, j1=ind3, j2=ind3  
!       coef_13 = el12_bra_3*el12_ket_3
!       coef_14 = el12_bra_3*el21_ket_3
!       coef_15 = el21_bra_3*el12_ket_3
!       coef_16 = el21_bra_3*el21_ket_3

        do s=1,diag_ndiag.dim
           geminal_2 = diag_ndiag(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg_2, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 !overlap = ZERO
                 cycle
              end
           else
              overlap=ONE
           end

           select case (.bra_set.vec(geminal_2).block_type(b2))
              case("SX") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = el12_ket_2
              case("ISY") 
                 el12_bra_2 = .bra_set.vec(geminal_2).coef(b2)
                 el21_bra_2 = -el12_bra_2
                 el12_ket_2 = .ket_set.vec(geminal_2).coef(b2)
                 el21_ket_2 = -el12_ket_2
              case default   
                 stdout.text("unexpected block type")
                 stop
           end
           select case (.ket_set.vec(geminal_2).block_type(b1))
              case("ID2") 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = el11_bra_4  
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = el11_ket_4  
              case("SZ")                 
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)
                 el22_bra_4 = -el11_bra_4 
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)*overlap
                 el22_ket_4 = -el11_ket_4 
              case("GD2")                
                 el11_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.first_GD2_elt(block_1)
                 el22_bra_4 = .bra_set.vec(geminal_2).coef(b1)*.second_GD2_elt(block_1)
                 el11_ket_4 = .ket_set.vec(geminal_2).coef(b1)**overlap
                 el22_ket_4 = el11_ket_4*.second_GD2_elt(block_1)
                 el11_ket_4 = el11_ket_4*.first_GD2_elt(block_1)
              case default   
                 stdout.text("unexpected block type")
                 stop
           end

           terms(1)=terms(1) + coef_6 * el21_bra_2*el22_ket_4
           terms(2)=terms(2) + coef_5 * el12_bra_2*el22_ket_4
           terms(3)=terms(3) + coef_8 * el21_bra_2*el11_ket_4
           terms(4)=terms(4) + coef_7 * el12_bra_2*el11_ket_4

           terms(1)=terms(1) + coef_12 * el11_bra_4*el21_ket_2
           terms(2)=terms(2) + coef_11 * el11_bra_4*el12_ket_2
           terms(3)=terms(3) + coef_10 * el22_bra_4*el21_ket_2
           terms(4)=terms(4) + coef_9  * el22_bra_4*el12_ket_2
        end          
     end          

     terms=terms/.overlap

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_3,ind_2,ind_3 /),terms(1))
        .add_2rtm_aa_elt((/ ind_1,ind_3,ind_2,ind_3 /),terms(1))
        .add_2rtm_bb_elt((/ ind_1,ind_3,ind_2,ind_3 /),terms(1))
        .add_2rtm_ab_elt((/ ind_3,ind_1,ind_3,ind_2 /),terms(1))
     end

     if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_1,ind_4,ind_2,ind_4 /),terms(2))
        .add_2rtm_aa_elt((/ ind_1,ind_4,ind_2,ind_4 /),terms(2))
        .add_2rtm_bb_elt((/ ind_1,ind_4,ind_2,ind_4 /),terms(2))
        .add_2rtm_ab_elt((/ ind_4,ind_1,ind_4,ind_2 /),terms(2))
     end

     if (abs(terms(3)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_3,ind_1,ind_3 /),terms(3))
        .add_2rtm_aa_elt((/ ind_2,ind_3,ind_1,ind_3 /),terms(3))
        .add_2rtm_bb_elt((/ ind_2,ind_3,ind_1,ind_3 /),terms(3))
        .add_2rtm_ab_elt((/ ind_3,ind_2,ind_3,ind_1 /),terms(3))
     end

     if (abs(terms(4)) > NON_ZERO_2RTM_TOL ) then
        .add_2rtm_ab_elt((/ ind_2,ind_4,ind_1,ind_4 /),terms(4))
        .add_2rtm_aa_elt((/ ind_2,ind_4,ind_1,ind_4 /),terms(4))
        .add_2rtm_bb_elt((/ ind_2,ind_4,ind_1,ind_4 /),terms(4))
        .add_2rtm_ab_elt((/ ind_4,ind_2,ind_4,ind_1 /),terms(4))
     end

   end
   
   add_2rtm_ab_elt(indices,coef_prod)
   ! add new 2RTM ab element 
     indices :: VEC{INT}(4), IN
     coef_prod :: REAL, IN
     i :: INT
 
     i=.nonzero_terms_ab+1
     .nonzero_terms_ab = i
     .rdm_2_ab(i).indices = indices
     .rdm_2_ab(i).coefficient = coef_prod
     !debug    stdout.text(" ")
     !debug    stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
     !debug    stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
   end   
      
   add_2rtm_aa_elt(indices,coef_prod)
   ! add new 2RTM aa element 
     indices :: VEC{INT}(4), IN
     coef_prod :: REAL, IN
     i :: INT
 
     i=.nonzero_terms_aa+1
     .nonzero_terms_aa = i
     .rdm_2_aa(i).indices = indices
     .rdm_2_aa(i).coefficient = coef_prod
     !debug    stdout.text(" ")
     !debug    stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
     !debug    stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
   end   
 
   add_2rtm_bb_elt(indices,coef_prod)
   ! add new 2RTM bb element 
     indices :: VEC{INT}(4), IN
     coef_prod :: REAL, IN
     i :: INT
     i=.nonzero_terms_bb+1
 
     .nonzero_terms_bb = i
     .rdm_2_bb(i).indices = indices
     .rdm_2_bb(i).coefficient = coef_prod
     !debug    stdout.text(" ")
     !debug    stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
     !debug    stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
   end   

!  =============================
!  2RDM gradient related methods
!  =============================
 
   comp_2rtm_two_1D_blocks_2b_epi2o_grd(red_pbg_1) 
   ! calculation of the 2RDM elements where we consider just one block
   ! it corresponds to the third case in the thesis
   ! or to case 2b in the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     g, b :: INT
     coef_prod :: REAL
     overlap :: REAL
     grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO

     ng_1=red_pbg_1.n_geminals
     grad_info_tmp.nb_terms=1
     .create_ptr_part(grad_info_tmp,1,1,1)
     grad_info_tmp.factor=TWO
!    grad_info_tmp.all_pairs(1) = FALSE
     ! 1-orthogonal case
     do b=1,.n_1D_blocks
        g = .nonzero_1ortho_ind(b)
        if (g == 0) cycle
        grad_info_tmp.ex_gem(1).element(1)=g
        grad_info_tmp.ex_blk(1).element(1)=b

        coef_prod = .bra_set.vec(g).coef(b) * .ket_set.vec(g).coef(b)
        coef_prod = coef_prod/.overlap
        grad_info_tmp.coef_prod(1)=coef_prod
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1,g)
           red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg_1.calc_overlap_integral(overlap,FALSE)
        else
           overlap = ONE
           !provided the geminals have been properly normalized
        end
        coef_prod = coef_prod*overlap
        if (abs(coef_prod) > NON_ZERO_2RTM_TOL ) then
          ! increments the number of non zero elements in the \alpha\beta 2RTM
          .add_2rtm_ab_elt((/ b,b,b,b /),coef_prod)
          grad_info_tmp.term(1)=coef_prod
          .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
        end
     end
     .destroy_ptr_part(grad_info_tmp)
   end

   comp_2rtm_two_1D_blocks_2a_epi2o_grd(red_pbg_1)
   ! calculation of the 2RTM elements when two 1D-blocks
   ! case 2a of the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     r, b :: INT
     block_1, block_2 :: INT
     non_zero_1D, g  :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL
     terms :: VEC{REAL}(2)
     overlap :: REAL
     grad_info_tmp_1 :: PAULI_BLOCK_2RDM_GRAD_INFO
     grad_info_tmp_2 :: PAULI_BLOCK_2RDM_GRAD_INFO

     grad_info_tmp_1.nb_terms=1
     grad_info_tmp_2.nb_terms=1
     .create_ptr_part(grad_info_tmp_1,1,1,2)
     .create_ptr_part(grad_info_tmp_2,1,1,2)
     grad_info_tmp_1.factor=ONE
     grad_info_tmp_2.factor=ONE
!     grad_info_tmp.all_pairs(1) = FALSE
     ng_1=red_pbg_1.n_geminals
     ! here we consider two different 1D blocks 
     do g=1,.n_geminals
        !nb of non zero coef of geminal g for 1D blocks
        non_zero_1D=.bra_set.vec(g).n_nonzero_1ortho
        if (non_zero_1D < 2) cycle
        grad_info_tmp_1.ex_gem(1).element=g
        grad_info_tmp_2.ex_gem(1).element=g
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1,g)
           red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg_1.calc_overlap_integral(overlap,FALSE)
        else
           overlap = ONE
        end
        do r=1,non_zero_1D-1
          block_1=.bra_set.vec(g).new_nonzero_coef_ind(r)
          grad_info_tmp_1.ex_blk(1).element(1)=block_1
          grad_info_tmp_2.ex_blk(1).element(1)=block_1
          coef_1 = .bra_set.vec(g).coef(block_1)/.overlap
          coef_2 = .ket_set.vec(g).coef(block_1)/.overlap
          do b=r+1,non_zero_1D
            block_2=.bra_set.vec(g).new_nonzero_coef_ind(b)
            grad_info_tmp_1.ex_blk(1).element(2)=block_2
            grad_info_tmp_2.ex_blk(1).element(2)=block_2
            coef_3 = .bra_set.vec(g).coef(block_2)
            coef_4 = .ket_set.vec(g).coef(block_2)

            terms = overlap
            grad_info_tmp_1.coef_prod(1)=coef_1*coef_4
            grad_info_tmp_2.coef_prod(1)=coef_2*coef_3
            terms(1)=terms(1)*grad_info_tmp_1.coef_prod(1)
            terms(2)=terms(2)*grad_info_tmp_2.coef_prod(1)

            if (abs(terms(1)) > NON_ZERO_2RTM_TOL ) then
              .add_2rtm_ab_elt((/ block_1,block_1,block_2,block_2 /),terms(1))
              grad_info_tmp_1.term(1)=terms(1)
              .calc_2rtm_ab_coef_grad_2(grad_info_tmp_1)
            end  

            if (abs(terms(2)) > NON_ZERO_2RTM_TOL ) then
              .add_2rtm_ab_elt((/ block_2,block_2,block_1,block_1 /),terms(2))
              grad_info_tmp_2.term(1)=terms(2)
              .calc_2rtm_ab_coef_grad_2(grad_info_tmp_2)
            end  
          end
        end
     end
     .destroy_ptr_part(grad_info_tmp_1)
     .destroy_ptr_part(grad_info_tmp_2)

   end

   comp_2rtm_two_1D_blocks_1a_epi2o_grd(red_pbg_2) ::: leaky
   ! calculation of the 2RTM elements when two 1D-blocks
   ! case 1a of the paper
     red_pbg_2 :: PAULI_BLOCK_GEMINALS
     ng_2 :: INT
     r, b :: INT
     geminal, g  :: INT
     coef, coef_prod :: REAL
     overlap :: REAL
     grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO

     ng_2=red_pbg_2.n_geminals
     grad_info_tmp.nb_terms=1
     .create_ptr_part(grad_info_tmp,1,2,2)
     grad_info_tmp.factor=TWO
     ! here we consider two different 1D blocks 
     do r=1,.n_1D_blocks-1
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        grad_info_tmp.ex_gem(1).element(1)=geminal
        grad_info_tmp.ex_blk(1).element(1)=r
        coef = .bra_set.vec(geminal).coef(r)*.ket_set.vec(geminal).coef(r)/.overlap
        do b=r+1,.n_1D_blocks
           g = .nonzero_1ortho_ind(b)
           if (g == 0) cycle
           if (g == geminal) cycle
           grad_info_tmp.ex_gem(1).element(2)=g
           grad_info_tmp.ex_blk(1).element(2)=b
           ! in the paper case 1a
           coef_prod = coef*.bra_set.vec(g).coef(b)*.ket_set.vec(g).coef(b)
           grad_info_tmp.coef_prod(1)=coef_prod
           if (ng_2 > 0) then
              .prep_red_pbg(red_pbg_2,geminal,g)
              red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_2.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ONE
           end
           coef_prod = coef_prod*overlap
           if (abs(coef_prod) > NON_ZERO_2RTM_TOL ) then
              .add_2rtm_ab_elt((/ r,b,r,b /),coef_prod)
              grad_info_tmp.term(1) = coef_prod
              .calc_2rtm_ab_coef_grad_1(grad_info_tmp)
              .add_2rtm_aa_elt((/ r,b,r,b /),coef_prod)
              .rdm_2_aa(.nonzero_terms_aa).grad.create(.nb_grad_elt)
              .rdm_2_aa(.nonzero_terms_aa).grad=.rdm_2_ab(.nonzero_terms_ab).grad
              .add_2rtm_bb_elt((/ r,b,r,b /),coef_prod)
              .rdm_2_bb(.nonzero_terms_bb).grad.create(.nb_grad_elt)
              .rdm_2_bb(.nonzero_terms_bb).grad=.rdm_2_ab(.nonzero_terms_ab).grad
              .add_2rtm_ab_elt((/ b,r,b,r /),coef_prod)
              .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
              .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
           end
        end
     end
     .destroy_ptr_part(grad_info_tmp)

   end

   comp_2rtm_1D_2D_blocks_2a_epi2o_grd(red_pbg_1) ::: leaky
   ! end of the computation of the 2RTM elements when we have one 1D-block and one 2D-block
   ! in the first case of the thesis
   ! in case 2a of the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     r, b, block :: INT
     geminal :: INT
     s, siz :: INT
     ind_1, ind_2 :: INT
     overlap :: REAL
     problem :: BIN
     coef_1, coef_2 :: REAL
     coef_3, coef_4 :: REAL
     term :: REAL
     grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO
   
     grad_info_tmp.nb_terms=1
     .create_ptr_part(grad_info_tmp,1,1,2)
     ng_1=red_pbg_1.n_geminals
     do r=1,.n_1D_blocks
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)/.overlap
        coef_2 = .ket_set.vec(geminal).coef(r)/.overlap
        siz = size(.nonzero_coef_ind(geminal).element)
        !s=1 would correspond to the dzeta of the 1-ortho part of the geminal
        do s=2,siz
           block = .nonzero_coef_ind(geminal).element(s)
           if (ng_1 /= 0) then
              .prep_red_pbg(red_pbg_1, geminal, block, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
                red_pbg_1.calc_overlap_integral(overlap,FALSE)
              else
                ! overlap= ZERO
                cycle
              end
           else
              overlap = ONE
           end
           term=overlap
           !indices of the orbitals of the 2D-block
           ind_1 = .n_1D_blocks+2*block-1
           ind_2 = .n_1D_blocks+2*block
           b = block + .n_1D_blocks
           coef_3 = .bra_set.vec(geminal).coef(b)
           coef_4 = .ket_set.vec(geminal).coef(b)
           grad_info_tmp.ex_gem(1).element(1)=geminal
           grad_info_tmp.ex_blk(1).element(1)=r
           grad_info_tmp.ex_blk(1).element(2)=block+.n_1D_blocks
           if (geminal == .block_types(block).element(1)) then
           ! 2D block matrix is ID2
              grad_info_tmp.coef_prod(1) = coef_1*coef_4
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_1 /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_2 /),term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
              end 
       
              grad_info_tmp.coef_prod(1) = coef_2*coef_3
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_1,r,r /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ ind_2,ind_2,r,r /),term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
              end
           else if (geminal == .block_types(block).element(2)) then
           ! 2D block matrix is SZ
              grad_info_tmp.coef_prod(1) = coef_1*coef_4
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_1 /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_2 /),-term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=-.rdm_2_ab(.nonzero_terms_ab-1).grad
              end 
              
              grad_info_tmp.coef_prod(1) = coef_2*coef_3
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_1,r,r /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ ind_2,ind_2,r,r /),-term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
              end
           else if (geminal == .block_types(block).element(3)) then
           ! 2D block matrix is SX
              grad_info_tmp.coef_prod(1) = coef_1*coef_4
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_2 /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_1 /),term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
              end 
              
              grad_info_tmp.coef_prod(1) = coef_2*coef_3
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_2,r,r /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ ind_2,ind_1,r,r /),term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
              end
           else if (geminal == .block_types(block).element(4)) then
           ! 2D block matrix is ISY
              grad_info_tmp.coef_prod(1) = coef_1*coef_4
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_2 /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_1 /),-term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=-.rdm_2_ab(.nonzero_terms_ab-1).grad
              end 
              
              grad_info_tmp.coef_prod(1) = coef_2*coef_3
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_2,r,r /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
                 .add_2rtm_ab_elt((/ ind_2,ind_1,r,r /),-term)
                 .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
                 .rdm_2_ab(.nonzero_terms_ab).grad=-.rdm_2_ab(.nonzero_terms_ab-1).grad
              end
           else if (geminal == .block_types(block).element(5)) then
           ! 2D block matrix is GD2
              grad_info_tmp.coef_prod(1) = coef_1*coef_4*.first_GD2_elt(block)
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_1,ind_1 /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
              end
                 
              grad_info_tmp.coef_prod(1) = coef_1*coef_4*.second_GD2_elt(block)
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ r,r,ind_2,ind_2 /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
              end
                 
              grad_info_tmp.coef_prod(1) = coef_2*coef_3*.first_GD2_elt(block)
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_1,ind_1,r,r /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
              end
                 
              grad_info_tmp.coef_prod(1) = coef_2*coef_3*.second_GD2_elt(block)
              term=term*grad_info_tmp.coef_prod(1)
              if (abs(term) > NON_ZERO_2RTM_TOL) then
                 .add_2rtm_ab_elt((/ ind_2,ind_2,r,r /),term)
                 grad_info_tmp.term(1)=term
                 .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
              end
           else 
              stdout.text("geminal corresponds to no block type")
              stop
           end
        end
     end
     .destroy_ptr_part(grad_info_tmp)

   end
   
   comp_2rtm_1D_2D_blocks_1bc_epi2o_grd(red_pbg_2) ::: leaky
   ! calculation of the 2RTM elements for one 1-ortho block and one 2-ortho block
   ! cases 1b and 1c of the paper
   ! (so these elements are not calculated in the calc_2rtm_one_1_ortho_epi2o routine)
     red_pbg_2 :: PAULI_BLOCK_GEMINALS
     ng_2 :: INT
     j, m :: INT
     b1, b2 :: INT
     block_1 :: INT
     geminal_1, geminal_2 :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod, sum_term :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN
     t_1, t_2 :: REAL
     grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO
   

     ng_2=red_pbg_2.n_geminals
     m = .n_1D_blocks+.n_2D_3typ_blocks


     ! the 2-ortho block is 3typ
     if (.n_2D_3typ_blocks /= 0) then
       grad_info_tmp.nb_terms=3
       .create_ptr_part(grad_info_tmp,3,2,2)
       do b1=.n_1D_blocks+1,m
          block_1 = b1 - .n_1D_blocks
          ind_1 = .n_1D_blocks+2*block_1-1
          ind_2 = .n_1D_blocks+2*block_1
          do b2=1,.n_1D_blocks
             geminal_2 = .nonzero_1ortho_ind(b2)
             if (geminal_2 == 0) cycle
             coef_1 = .bra_set.vec(geminal_2).coef(b2)/.overlap
             coef_2 = .ket_set.vec(geminal_2).coef(b2)
             term = ZERO
             do j=3,5 ! geminal with SX, ISY or GD2 in block "block_1" are considered
                geminal_1 = .block_types(block_1).element(j) 
                if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then !else all terms are 0 so no 2rtm elt to be added
                   grad_info_tmp.ex_blk(j-2).element(1)=b1
                   grad_info_tmp.ex_blk(j-2).element(2)=b2
                   grad_info_tmp.ex_gem(j-2).element(1)=geminal_1
                   grad_info_tmp.ex_gem(j-2).element(2)=geminal_2
                   coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                   grad_info_tmp.coef_prod(j-2)=coef_prod
                   if (ng_2 > 0) then
                      .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                      if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_2+1))) then
                         red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                         red_pbg_2.calc_overlap_integral(overlap,FALSE)
                         term(j) = coef_prod*overlap
                      else
                         term(j) = ZERO
                      end
                   else
                      term(j) = coef_prod
                   end
                end
             end
  
             t_1 = term(5)*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)
             t_2 = term(5)*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)
             sum_term=t_1+term(3)+term(4) 
             if (abs(sum_term) > NON_ZERO_2RTM_TOL) then
               .add_2rtm_ab_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               grad_info_tmp.term(1)=term(3)
               grad_info_tmp.term(2)=term(4)
               grad_info_tmp.term(3)=t_1
               .calc_2rtm_ab_coef_grad_1(grad_info_tmp)
               .add_2rtm_aa_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .rdm_2_aa(.nonzero_terms_aa).grad.create(.nb_grad_elt)
               .rdm_2_aa(.nonzero_terms_aa).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_bb_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .rdm_2_bb(.nonzero_terms_bb).grad.create(.nb_grad_elt)
               .rdm_2_bb(.nonzero_terms_bb).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_ab_elt((/ ind_1,b2,ind_1,b2 /),sum_term)
               .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
               .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
             end

             sum_term=t_2+term(3)+term(4)
             if (abs(sum_term) > NON_ZERO_2RTM_TOL) then
               .add_2rtm_ab_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               grad_info_tmp.term(1)=term(3)
               grad_info_tmp.term(2)=term(4)
               grad_info_tmp.term(3)=t_2
               .calc_2rtm_ab_coef_grad_1(grad_info_tmp)
               .add_2rtm_aa_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .rdm_2_aa(.nonzero_terms_aa).grad.create(.nb_grad_elt)
               .rdm_2_aa(.nonzero_terms_aa).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_bb_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .rdm_2_bb(.nonzero_terms_bb).grad.create(.nb_grad_elt)
               .rdm_2_bb(.nonzero_terms_bb).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_ab_elt((/ ind_2,b2,ind_2,b2 /),sum_term)
               .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
               .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
             end
          end
       end
       .destroy_ptr_part(grad_info_tmp)
     end

     ! the 2-ortho block is 4typ
     if (.n_2D_4typ_blocks /= 0) then
       grad_info_tmp.nb_terms=4
       .create_ptr_part(grad_info_tmp,4,2,2)
       do b1=m+1,.n_blocks
          block_1 = b1 - .n_1D_blocks
          ind_1 = .n_1D_blocks+2*block_1-1
          ind_2 = .n_1D_blocks+2*block_1
          do b2=1,.n_1D_blocks
             geminal_2 = .nonzero_1ortho_ind(b2)
             if (geminal_2 == 0) cycle
             coef_1 = .bra_set.vec(geminal_2).coef(b2)/.overlap
             coef_2 = .ket_set.vec(geminal_2).coef(b2)
             term = ZERO
             do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block_1" are considered
                geminal_1 = .block_types(block_1).element(j) 
                if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                   grad_info_tmp.ex_blk(j).element(1)=b1
                   grad_info_tmp.ex_blk(j).element(2)=b2
                   grad_info_tmp.ex_gem(j).element(1)=geminal_1
                   grad_info_tmp.ex_gem(j).element(2)=geminal_2
                   coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                   grad_info_tmp.coef_prod(j)=coef_prod
                   if (ng_2 > 0) then
                      .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                      if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_2+1))) then
                         red_pbg_2.make_int_term_list(FALSE,FALSE,FALSE)
                         red_pbg_2.calc_overlap_integral(overlap,FALSE)
                         term(j) = coef_prod*overlap
                      else
                         term(j) = ZERO
                      end
                   else
                      term(j) = coef_prod  
                   end  
                   grad_info_tmp.term(j)=term(j)
                end
             end
  
             sum_term=sum(term)
             if (abs(sum_term) > NON_ZERO_2RTM_TOL) then
               .add_2rtm_ab_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .calc_2rtm_ab_coef_grad_1(grad_info_tmp)
               .add_2rtm_aa_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .rdm_2_aa(.nonzero_terms_aa).grad.create(.nb_grad_elt)
               .rdm_2_aa(.nonzero_terms_aa).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_bb_elt((/ b2,ind_1,b2,ind_1 /),sum_term)
               .rdm_2_bb(.nonzero_terms_bb).grad.create(.nb_grad_elt)
               .rdm_2_bb(.nonzero_terms_bb).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_ab_elt((/ ind_1,b2,ind_1,b2 /),sum_term)
               .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
               .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
  
               .add_2rtm_ab_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
               .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
               .add_2rtm_aa_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .rdm_2_aa(.nonzero_terms_aa).grad.create(.nb_grad_elt)
               .rdm_2_aa(.nonzero_terms_aa).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_bb_elt((/ b2,ind_2,b2,ind_2 /),sum_term)
               .rdm_2_bb(.nonzero_terms_bb).grad.create(.nb_grad_elt)
               .rdm_2_bb(.nonzero_terms_bb).grad=.rdm_2_ab(.nonzero_terms_ab).grad
               .add_2rtm_ab_elt((/ ind_2,b2,ind_2,b2 /),sum_term)
               .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
               .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
             end
          end
       end
       .destroy_ptr_part(grad_info_tmp)
     end

   end

   comp_2rtm_two_2D_blocks_2b_epi2o_grd(red_pbg_1) ::: leaky
   ! calculation of the 2RDM elements where we consider just one block
   ! it corresponds to the third case in the thesis
   ! or to case 2b in the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     ng_1 :: INT
     j, m :: INT
     b :: INT
     block, geminal :: INT
     ind_1, ind_2 :: INT
     element_coef :: REAL
     coef_prod :: VEC{REAL}(5)
     term :: VEC{REAL}(5)
     ex_blk :: VEC{INT}(5)
     ex_gem :: VEC{INT}(5)
     overlap :: REAL
     problem :: BIN
     grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO

     ng_1=red_pbg_1.n_geminals
     ! 2-orthogonal case
     m = .n_1D_blocks+.n_2D_3typ_blocks     
     
     ! the block is 3typ
     if (.n_2D_3typ_blocks /= 0) then
       do b=.n_1D_blocks+1,m
          block = b - .n_1D_blocks
          ! orbital indices for this block
          ind_1 = .n_1D_blocks+2*block-1
          ind_2 = .n_1D_blocks+2*block
          term=ZERO
          do j=3,5 ! block types ID2, SZ are skipped
             geminal = .block_types(block).element(j) 
             if (geminal /= 0) then
                ex_blk(j)=b
                ex_gem(j)=geminal
                !must divide by two to get the product of lambda from the dzeta in case of 2D-blocks
                coef_prod(j) = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO/.overlap
                if (ng_1 /= 0) then
                   .prep_red_pbg(red_pbg_1, geminal, block, problem)
                   if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                      red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
                      red_pbg_1.calc_overlap_integral(overlap,FALSE)
                      term(j) = coef_prod(j)*overlap
                   else
                      !term(j) = ZERO
                      cycle
                   end
                else
                ! no overlap left in case there is only one geminal
                   term(j) = coef_prod(j)
                end
             end
          end

          element_coef = term(5)*.first_GD2_elt(block)*.first_GD2_elt(block)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_1,ind_1 /),element_coef)
             grad_info_tmp.nb_terms=1
             .create_ptr_part(grad_info_tmp,1,1,1)
             grad_info_tmp.factor=TWO
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(5)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(5)
             grad_info_tmp.coef_prod(1)=coef_prod(5)*.first_GD2_elt(block)*.first_GD2_elt(block)
             grad_info_tmp.term(1)=element_coef
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
          end
  
          element_coef = term(5)*.second_GD2_elt(block)*.second_GD2_elt(block)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_2,ind_2 /),element_coef)
             grad_info_tmp.nb_terms=1
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,1,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(5)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(5)
             grad_info_tmp.coef_prod(1)=coef_prod(5)*.second_GD2_elt(block)*.second_GD2_elt(block)
             grad_info_tmp.term(1)=element_coef
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
          end
  
          element_coef = term(5)*.first_GD2_elt(block)*.second_GD2_elt(block)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_2,ind_2 /),element_coef)
             grad_info_tmp.nb_terms=1
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,1,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(5)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(5)
             grad_info_tmp.coef_prod(1)=coef_prod(5)*.first_GD2_elt(block)*.second_GD2_elt(block)
             grad_info_tmp.term(1)=element_coef
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_1,ind_1 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end

          element_coef = term(3)+term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_1,ind_2 /),element_coef)
             grad_info_tmp.nb_terms=2
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,2,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(3)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(3)
             grad_info_tmp.coef_prod(1)=coef_prod(3)
             grad_info_tmp.term(1)=term(3)
             grad_info_tmp.ex_blk(2).element(1)=ex_blk(4)
             grad_info_tmp.ex_gem(2).element(1)=ex_gem(4)
             grad_info_tmp.coef_prod(2)=coef_prod(4)
             grad_info_tmp.term(2)=term(4)
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_2,ind_1 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end

          element_coef = term(3)-term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_2,ind_1 /),element_coef)
             grad_info_tmp.nb_terms=2
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,2,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(3)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(3)
             grad_info_tmp.coef_prod(1)=coef_prod(3)
             grad_info_tmp.term(1)=term(3)
             grad_info_tmp.ex_blk(2).element(1)=ex_blk(4)
             grad_info_tmp.ex_gem(2).element(1)=ex_gem(4)
             grad_info_tmp.coef_prod(2)=-coef_prod(4)
             grad_info_tmp.term(2)=-term(4)
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_1,ind_2 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end
       end
     end

     ! the block is 4typ
     if (.n_2D_4typ_blocks /= 0) then
       do b=m+1,.n_blocks
          block = b - .n_1D_blocks
          ! orbital indices for this block
          ind_1 = .n_1D_blocks+2*block-1
          ind_2 = .n_1D_blocks+2*block
          term = ZERO
          do j=1,4 ! GD2 type is skipped
             geminal = .block_types(block).element(j) 
             if (geminal /= 0) then
                ex_blk(j)=b
                ex_gem(j)=geminal
                !must divide by two to get the product of lambda from the dzeta in case of 2D-blocks
                coef_prod(j) = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO/.overlap
                if (ng_1 /= 0) then
                   .prep_red_pbg(red_pbg_1, geminal, block, problem)
                   if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                      red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
                      red_pbg_1.calc_overlap_integral(overlap,FALSE)
                      term(j) = coef_prod(j)*overlap
                   else
                      !term(j) = ZERO
                      cycle
                   end
                else
                ! no overlap left in case there is only one geminal
                   term(j) = coef_prod(j)
                end
             end
          end
          element_coef = term(1)+term(2)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_1,ind_1 /),element_coef)
             grad_info_tmp.nb_terms=2
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,2,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(1)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(1)
             grad_info_tmp.coef_prod(1)=coef_prod(1)
             grad_info_tmp.term(1)=term(1)
             grad_info_tmp.ex_blk(2).element(1)=ex_blk(2)
             grad_info_tmp.ex_gem(2).element(1)=ex_gem(2)
             grad_info_tmp.coef_prod(2)=coef_prod(2)
             grad_info_tmp.term(2)=term(2)
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_2,ind_2 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end
          element_coef = term(3)+term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_1,ind_2 /),element_coef)
             grad_info_tmp.nb_terms=2
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,2,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(3)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(3)
             grad_info_tmp.coef_prod(1)=coef_prod(3)
             grad_info_tmp.term(1)=term(3)
             grad_info_tmp.ex_blk(2).element(1)=ex_blk(4)
             grad_info_tmp.ex_gem(2).element(1)=ex_gem(4)
             grad_info_tmp.coef_prod(2)=coef_prod(4)
             grad_info_tmp.term(2)=term(4)
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_2,ind_1 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end
          element_coef = term(1)-term(2)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_1,ind_2,ind_2 /),element_coef)
             grad_info_tmp.nb_terms=2
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,2,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(1)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(1)
             grad_info_tmp.coef_prod(1)=coef_prod(1)
             grad_info_tmp.term(1)=term(1)
             grad_info_tmp.ex_blk(2).element(1)=ex_blk(2)
             grad_info_tmp.ex_gem(2).element(1)=ex_gem(2)
             grad_info_tmp.coef_prod(2)=-coef_prod(2)
             grad_info_tmp.term(2)=-term(2)
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_2,ind_1,ind_1 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end
          element_coef = term(3)-term(4)
          if (abs(element_coef) > NON_ZERO_2RTM_TOL) then
             .add_2rtm_ab_elt((/ ind_1,ind_2,ind_2,ind_1 /),element_coef)
             grad_info_tmp.nb_terms=2
             grad_info_tmp.factor=TWO
             .create_ptr_part(grad_info_tmp,2,1,1)
             grad_info_tmp.ex_blk(1).element(1)=ex_blk(3)
             grad_info_tmp.ex_gem(1).element(1)=ex_gem(3)
             grad_info_tmp.coef_prod(1)=coef_prod(3)
             grad_info_tmp.term(1)=term(3)
             grad_info_tmp.ex_blk(2).element(1)=ex_blk(4)
             grad_info_tmp.ex_gem(2).element(1)=ex_gem(4)
             grad_info_tmp.coef_prod(2)=-coef_prod(4)
             grad_info_tmp.term(2)=-term(4)
             .calc_2rtm_ab_coef_grad_2(grad_info_tmp)
             .destroy_ptr_part(grad_info_tmp)
             .add_2rtm_ab_elt((/ ind_2,ind_1,ind_1,ind_2 /),element_coef)
             .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
             .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
          end
       end
     end

   end

   comp_2rtm_two_2D_blocks_2a_epi2o_grd(red_pbg_1,block_1,block_2,ind_1,ind_2,ind_3,ind_4) ::: leaky
   ! calculation of the 2RTM elements when two 2D-3typ blocks. Case 1d (2 distinct geminals) 
   ! and case 2a (only one geminal has the 2 blocks) of the paper
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     block_1, block_2 :: INT
     ind_1, ind_2, ind_3, ind_4 :: INT
     ng_1 :: INT
     overlap :: REAL
     diag_diag,diag_ndiag,ndiag_diag,ndiag_ndiag :: VEC{INT}* DEFAULT_NULL
     r,j,siz :: INT
     b1, b2 :: INT
     geminal :: INT
     terms :: VEC{REAL}(8)
     el11_bra, el11_ket :: REAL DEFAULT(ZERO)
     el22_bra, el22_ket :: REAL DEFAULT(ZERO)
     el12_bra, el12_ket :: REAL DEFAULT(ZERO)
     el21_bra, el21_ket :: REAL DEFAULT(ZERO)
     problem :: BIN
     grad_info_tmp :: VEC{PAULI_BLOCK_2RDM_GRAD_INFO}(4)

     ng_1 = red_pbg_1.n_geminals
     b1 = .n_1D_blocks + block_1 
     b2 = .n_1D_blocks + block_2 

     .make_set_intersection(.diag_set(block_1).element,.diag_set(block_2).element,diag_diag)
     .make_set_intersection(.diag_set(block_1).element,.non_diag_set(block_2).element,diag_ndiag)
     .make_set_intersection(.non_diag_set(block_1).element,.diag_set(block_2).element,ndiag_diag)
     .make_set_intersection(.non_diag_set(block_1).element,.non_diag_set(block_2).element,ndiag_ndiag)
     
     siz=diag_diag.dim
     do j=1,4
       grad_info_tmp(j).nb_terms=siz
       .create_ptr_part(grad_info_tmp(j),siz,1,2)
       grad_info_tmp(j).factor=ONE
     end

     !2 diagonal block matrices
     terms=ZERO
     do r=1,siz
        geminal = diag_diag(r)
        do j=1,4
          grad_info_tmp(j).ex_blk(r).element(1)=b1
          grad_info_tmp(j).ex_blk(r).element(2)=b2
          grad_info_tmp(j).ex_gem(r).element=geminal
          !important to initialize term in case overlap is zero 
          !to skip the corresponding term in calc_2rtm_ab_coef_grad
          grad_info_tmp(j).term(r) = ZERO
        end
        select case (.bra_set.vec(geminal).block_type(b1))
           case("ID2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = el11_bra
           case("SZ") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = -el11_bra
           case("GD2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)*.first_GD2_elt(block_1)
              el22_bra = .bra_set.vec(geminal).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("ID2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = el11_ket
           case("SZ") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = -el11_ket
           case("GD2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)*.first_GD2_elt(block_2)
              el22_ket = .ket_set.vec(geminal).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! diagonal submatrices implies "i1 = j1 and i2 = j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        if (ng_1 /= 0) then
          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
          if (NOT problem) then
             red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
             red_pbg_1.calc_overlap_integral(overlap,FALSE)
          else
            !     overlap = ZERO
            cycle
          end
        else
           overlap = ONE
        end
        el11_ket = el11_ket/.overlap
        el22_ket = el22_ket/.overlap

        grad_info_tmp(1).coef_prod(r)=el11_bra*el11_ket
        grad_info_tmp(2).coef_prod(r)=el11_bra*el22_ket
        grad_info_tmp(3).coef_prod(r)=el22_bra*el11_ket
        grad_info_tmp(4).coef_prod(r)=el22_bra*el22_ket
        grad_info_tmp(1).term(r)=grad_info_tmp(1).coef_prod(r) * overlap
        grad_info_tmp(2).term(r)=grad_info_tmp(2).coef_prod(r) * overlap
        grad_info_tmp(3).term(r)=grad_info_tmp(3).coef_prod(r) * overlap
        grad_info_tmp(4).term(r)=grad_info_tmp(4).coef_prod(r) * overlap

        terms(1) = terms(1) + grad_info_tmp(1).term(r)
        terms(2) = terms(2) + grad_info_tmp(2).term(r)
        terms(3) = terms(3) + grad_info_tmp(3).term(r)
        terms(4) = terms(4) + grad_info_tmp(4).term(r)
     end          

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_3,ind_3 /),terms(1))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(1))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_1,ind_1 /),terms(1))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_4,ind_4 /),terms(2))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(2))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_1,ind_1 /),terms(2))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_3,ind_3 /),terms(3))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(3))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_2,ind_2 /),terms(3))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_4,ind_4 /),terms(4))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(4))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_2,ind_2 /),terms(4))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end

     siz=ndiag_ndiag.dim
     do j=1,4
       .destroy_ptr_part(grad_info_tmp(j))
       grad_info_tmp(j).nb_terms=siz
       .create_ptr_part(grad_info_tmp(j),siz,1,2)
       grad_info_tmp(j).factor=ONE
     end

     !2 non diagonal block matrices
     terms=ZERO
     do r=1,ndiag_ndiag.dim
        geminal = ndiag_ndiag(r)
        do j=1,4
          grad_info_tmp(j).ex_blk(r).element(1)=b1
          grad_info_tmp(j).ex_blk(r).element(2)=b2
          grad_info_tmp(j).ex_gem(r).element=geminal
          !important to initialize term in case overlap is zero 
          !to skip the corresponding term in calc_2rtm_ab_coef_grad
          grad_info_tmp(j).term(r) = ZERO
        end
        select case (.bra_set.vec(geminal).block_type(b1))
           case("SX") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = el12_bra
           case("ISY") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = -el12_bra
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("SX") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = el12_ket
           case("ISY") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = -el12_ket
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! non diagonal submatrices implies "i1 /= j1" and "i2 /= j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
           if (NOT problem) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ZERO
           end
        else
           overlap = ONE
        end
        el12_ket = el12_ket/.overlap
        el21_ket = el21_ket/.overlap

        grad_info_tmp(1).coef_prod(r)=el12_bra*el12_ket
        grad_info_tmp(2).coef_prod(r)=el12_bra*el21_ket
        grad_info_tmp(3).coef_prod(r)=el21_bra*el12_ket
        grad_info_tmp(4).coef_prod(r)=el21_bra*el21_ket
        grad_info_tmp(1).term(r)=grad_info_tmp(1).coef_prod(r) * overlap
        grad_info_tmp(2).term(r)=grad_info_tmp(2).coef_prod(r) * overlap
        grad_info_tmp(3).term(r)=grad_info_tmp(3).coef_prod(r) * overlap
        grad_info_tmp(4).term(r)=grad_info_tmp(4).coef_prod(r) * overlap

        terms(1) = terms(1) + grad_info_tmp(1).term(r)
        terms(2) = terms(2) + grad_info_tmp(2).term(r)
        terms(3) = terms(3) + grad_info_tmp(3).term(r)
        terms(4) = terms(4) + grad_info_tmp(4).term(r)
     end          

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_3,ind_4 /),terms(1))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(1))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_1,ind_2 /),terms(1))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_4,ind_3 /),terms(2))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(2))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_1,ind_2 /),terms(2))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_3,ind_4 /),terms(3))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(3))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_2,ind_1 /),terms(3))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_4,ind_3 /),terms(4))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(4))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_2,ind_1 /),terms(4))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     
     siz=diag_ndiag.dim
     do j=1,4
       .destroy_ptr_part(grad_info_tmp(j))
       grad_info_tmp(j).nb_terms=siz
       .create_ptr_part(grad_info_tmp(j),siz,1,2)
       grad_info_tmp(j).factor=ONE
     end

     !diagonal on block_1 non diagonal on block_2 
     terms=ZERO
     do r=1,diag_ndiag.dim
        geminal = diag_ndiag(r)
        do j=1,4
          grad_info_tmp(j).ex_blk(r).element(1)=b1
          grad_info_tmp(j).ex_blk(r).element(2)=b2
          grad_info_tmp(j).ex_gem(r).element=geminal
          !important to initialize term in case overlap is zero 
          !to skip the corresponding term in calc_2rtm_ab_coef_grad
          grad_info_tmp(j).term(r) = ZERO
        end
        select case (.bra_set.vec(geminal).block_type(b1))
           case("ID2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = el11_bra
           case("SZ") 
              el11_bra = .bra_set.vec(geminal).coef(b1)
              el22_bra = -el11_bra
           case("GD2") 
              el11_bra = .bra_set.vec(geminal).coef(b1)*.first_GD2_elt(block_1)
              el22_bra = .bra_set.vec(geminal).coef(b1)*.second_GD2_elt(block_1)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("SX") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = el12_ket
           case("ISY") 
              el12_ket = .ket_set.vec(geminal).coef(b2)
              el21_ket = -el12_ket
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! diagonal submatrices implies "i1 = j1" 
        ! non diagonal submatrices implies "i2 /= j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        ! they correspond to cases "non diagonal - diagonal"
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
           if (NOT problem) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ZERO
           end
        else
           overlap = ONE
        end
        el12_ket = el12_ket/.overlap
        el21_ket = el21_ket/.overlap

        grad_info_tmp(1).coef_prod(r)=el11_bra*el12_ket
        grad_info_tmp(2).coef_prod(r)=el11_bra*el21_ket
        grad_info_tmp(3).coef_prod(r)=el22_bra*el12_ket
        grad_info_tmp(4).coef_prod(r)=el22_bra*el21_ket
        grad_info_tmp(1).term(r)=grad_info_tmp(1).coef_prod(r) * overlap
        grad_info_tmp(2).term(r)=grad_info_tmp(2).coef_prod(r) * overlap
        grad_info_tmp(3).term(r)=grad_info_tmp(3).coef_prod(r) * overlap
        grad_info_tmp(4).term(r)=grad_info_tmp(4).coef_prod(r) * overlap

        terms(1) = terms(1) + grad_info_tmp(1).term(r)
        terms(2) = terms(2) + grad_info_tmp(2).term(r)
        terms(3) = terms(3) + grad_info_tmp(3).term(r)
        terms(4) = terms(4) + grad_info_tmp(4).term(r)
     end          

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_3,ind_4 /),terms(1))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(1))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_1,ind_1 /),terms(1))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_1,ind_4,ind_3 /),terms(2))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(2))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_1,ind_1 /),terms(2))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_3,ind_4 /),terms(3))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(3))
        .add_2rtm_ab_elt((/ ind_3,ind_4,ind_2,ind_2 /),terms(3))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_2,ind_4,ind_3 /),terms(4))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(4))
        .add_2rtm_ab_elt((/ ind_4,ind_3,ind_2,ind_2 /),terms(4))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end

     siz=ndiag_diag.dim
     do j=1,4
       .destroy_ptr_part(grad_info_tmp(j))
       grad_info_tmp(j).nb_terms=siz
       .create_ptr_part(grad_info_tmp(j),siz,1,2)
       grad_info_tmp(j).factor=ONE
     end

     !non diagonal on block_1 diagonal on block_2 
     terms=ZERO
     do r=1,ndiag_diag.dim
        geminal = ndiag_diag(r)
        do j=1,4
          grad_info_tmp(j).ex_blk(r).element(1)=b1
          grad_info_tmp(j).ex_blk(r).element(2)=b2
          grad_info_tmp(j).ex_gem(r).element=geminal
          !important to initialize term in case overlap is zero 
          !to skip the corresponding term in calc_2rtm_ab_coef_grad
          grad_info_tmp(j).term(r) = ZERO
        end
        select case (.bra_set.vec(geminal).block_type(b1))
           case("SX") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = el12_bra
           case("ISY") 
              el12_bra = .bra_set.vec(geminal).coef(b1)
              el21_bra = -el12_bra
           case default   
              stdout.text("unexpected block type")
              stop
        end
        select case (.ket_set.vec(geminal).block_type(b2))
           case("ID2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = el11_ket
           case("SZ") 
              el11_ket = .ket_set.vec(geminal).coef(b2)
              el22_ket = -el11_ket
           case("GD2") 
              el11_ket = .ket_set.vec(geminal).coef(b2)*.first_GD2_elt(block_2)
              el22_ket = .ket_set.vec(geminal).coef(b2)*.second_GD2_elt(block_2)
           case default   
              stdout.text("unexpected block type")
              stop
        end
        ! non diagonal submatrices implies "i1 /= j1" 
        ! diagonal submatrices implies "i2 = j2" 
        ! four possible sub-cases, 
        ! when we swap bra and ket 4 other terms are obtained by complex conjugation of the coefs
        ! which amounts to complex conjugation of the whole terms since the submatrices are real
        ! so which have the same 4 2RTM coefficients when the lambda-coef are real
        ! they correspond to cases "diagonal - non diagonal"
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
           if (NOT problem) then
              red_pbg_1.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg_1.calc_overlap_integral(overlap,FALSE)
           else
              overlap = ZERO
           end
        else
           overlap = ONE
        end
        el11_ket = el11_ket/.overlap
        el22_ket = el22_ket/.overlap

        grad_info_tmp(1).coef_prod(r)=el12_bra*el11_ket
        grad_info_tmp(2).coef_prod(r)=el12_bra*el22_ket
        grad_info_tmp(3).coef_prod(r)=el21_bra*el11_ket
        grad_info_tmp(4).coef_prod(r)=el21_bra*el22_ket
        grad_info_tmp(1).term(r)=grad_info_tmp(1).coef_prod(r) * overlap
        grad_info_tmp(2).term(r)=grad_info_tmp(2).coef_prod(r) * overlap
        grad_info_tmp(3).term(r)=grad_info_tmp(3).coef_prod(r) * overlap
        grad_info_tmp(4).term(r)=grad_info_tmp(4).coef_prod(r) * overlap

        terms(1) = terms(1) + grad_info_tmp(1).term(r)
        terms(2) = terms(2) + grad_info_tmp(2).term(r)
        terms(3) = terms(3) + grad_info_tmp(3).term(r)
        terms(4) = terms(4) + grad_info_tmp(4).term(r)
     end          

     if (abs(terms(1)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_3,ind_3 /),terms(1))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(1))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_1,ind_2 /),terms(1))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(2)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_1,ind_2,ind_4,ind_4 /),terms(2))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(2))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_1,ind_2 /),terms(2))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(3)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_3,ind_3 /),terms(3))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(3))
        .add_2rtm_ab_elt((/ ind_3,ind_3,ind_2,ind_1 /),terms(3))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end
     if (abs(terms(4)) > NON_ZERO_2RTM_TOL) then
        .add_2rtm_ab_elt((/ ind_2,ind_1,ind_4,ind_4 /),terms(4))
        .calc_2rtm_ab_coef_grad_2(grad_info_tmp(4))
        .add_2rtm_ab_elt((/ ind_4,ind_4,ind_2,ind_1 /),terms(4))
        .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
        .rdm_2_ab(.nonzero_terms_ab).grad=.rdm_2_ab(.nonzero_terms_ab-1).grad
     end

     do j=1,4
       .destroy_ptr_part(grad_info_tmp(j))
     end

   end

   calc_2rtm_ab_coef_grad_1(grad_info_tmp) ::: leaky
   !calculate the gradient with respect to lambda coefficients of the 2rtm_ab  
   ! case 1a
      grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO
      red_pbg :: PAULI_BLOCK_GEMINALS
      overlap :: REAL
      gg,bb  :: INT
      k, l, ng, siz :: INT
      gg_bb_in_1, gg_bb_in_2, problem :: BIN
      ex_gem, ex_blk :: VEC{INT}*
 
      .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
      .rdm_2_ab(.nonzero_terms_ab).grad=ZERO
      do l=1,.nb_grad_elt
        gg=.energy_gradient(l).indices(1)
        bb=.energy_gradient(l).indices(2)
        do k=1,grad_info_tmp.nb_terms
          if(abs(grad_info_tmp.term(k))<NON_ZERO_2RTM_TOL) cycle
         ! check if geminal "gg" and block "bb "are present in elt 1
          gg_bb_in_1 = (grad_info_tmp.ex_gem(k).element(1) == gg AND grad_info_tmp.ex_blk(k).element(1) == bb) 
         ! check if geminal "gg" and block "bb "are present in elt 2
          gg_bb_in_2 = (grad_info_tmp.ex_gem(k).element(2) == gg AND grad_info_tmp.ex_blk(k).element(2) == bb)
         ! select the case (A or B), else the term is zero
          if (gg_bb_in_1 OR gg_bb_in_2) then
            !!! debug
!            stdout.text("Selected case A: coef is present in the product of coefficients")
            !!!
            !
            ! case A: "coef" is present in the product of coefficients
            !
            .rdm_2_ab(.nonzero_terms_ab).grad(l)=.rdm_2_ab(.nonzero_terms_ab).grad(l)+ &
            grad_info_tmp.term(k)*TWO/.bra_set.vec(gg).coef(bb)
          else if (any(grad_info_tmp.ex_gem(k).element==gg)) then
            cycle
          else 
            !!! debug
!            stdout.text("Selected case B: coef is in the reduced overlap")
            !!!
            !
            ! case B: "coef" is in the reduced overlap
            !
            ng = .n_geminals-grad_info_tmp.ex_gem(k).element.dim-1
            red_pbg.n_geminals = ng
            red_pbg.nonzero_coef_ind.create(ng)
            red_pbg.nonzero_coef_prod.create(ng)
            ! two subcases (depending on the block size)
            if (bb <= .n_1D_blocks) then 
               !
               ! block "bb" is of size 1
               !
               ! compute the new reduced overlap 
              if (ng > 0) then
                 siz=grad_info_tmp.ex_gem(k).element.dim
                 ex_gem.create(siz+1)
                 ex_gem(1:siz)=grad_info_tmp.ex_gem(k).element
                 ex_gem(siz+1)=gg
                 .prep_red_pbg(red_pbg,ex_gem)
                 ex_gem.destroy
                 red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
              else
                 overlap = ONE
              end
               !!! debug
!               stdout.show("New reduced overlap =", overlap)
               !!!
               ! we suppose .bra_set.vec(gg).coef(bb)=.ket_set.vec(gg).coef(bb) hence the facto TWO
              .rdm_2_ab(.nonzero_terms_ab).grad(l)=.rdm_2_ab(.nonzero_terms_ab).grad(l) &
              +grad_info_tmp.coef_prod(k)*TWO*.bra_set.vec(gg).coef(bb)*overlap
            else
               !
               ! block "bb" is of size 2
               !
               ! compute the new reduced overlap 
              if (ng > 0) then
                 siz=grad_info_tmp.ex_gem(k).element.dim
                 ex_gem.create(siz+1)
                 ex_gem(1:siz)=grad_info_tmp.ex_gem(k).element
                 ex_gem(siz+1)=gg
                 ex_blk.create(siz+1)
                 ex_blk(1:siz)=grad_info_tmp.ex_blk(k).element
                 ex_blk(siz+1)=bb
                 .prep_red_pbg(red_pbg,ex_gem,ex_blk,problem)
                 ex_gem.destroy
                 ex_blk.destroy
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng+1))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                 else 
                    cycle
                 end
              else
                 overlap = ONE
              end
              .rdm_2_ab(.nonzero_terms_ab).grad(l)=.rdm_2_ab(.nonzero_terms_ab).grad(l) + &
              grad_info_tmp.coef_prod(k)*FOUR*.bra_set.vec(gg).coef(bb)*overlap
            end
            red_pbg.destroy_ptr_part
          end
        end
      end
   end   

   calc_2rtm_ab_coef_grad_2(grad_info_tmp) ::: leaky
   !calculate the gradient with respect to lambda coefficients of the 2rtm_ab  
   ! case 2a and 2b
      grad_info_tmp :: PAULI_BLOCK_2RDM_GRAD_INFO
      red_pbg :: PAULI_BLOCK_GEMINALS
      overlap :: REAL
      gg,bb  :: INT
      k, l, ng, siz :: INT
      gg_in_ex_gem, bb_in_ex_blk,problem :: BIN
      ex_gem, ex_blk :: VEC{INT}*
 
      .rdm_2_ab(.nonzero_terms_ab).grad.create(.nb_grad_elt)
      .rdm_2_ab(.nonzero_terms_ab).grad=ZERO
      do l=1,.nb_grad_elt
        gg=.energy_gradient(l).indices(1)
        bb=.energy_gradient(l).indices(2)
        do k=1,grad_info_tmp.nb_terms
          if(abs(grad_info_tmp.term(k))<NON_ZERO_2RTM_TOL) cycle
         ! check if geminal "g" is present in vector "ex_gem(k)"
          gg_in_ex_gem = any(grad_info_tmp.ex_gem(k).element == gg)
         ! check if block "b" is present in vector "ex_blk(k)"
          bb_in_ex_blk = any(grad_info_tmp.ex_blk(k).element == bb)
         ! select the case (A or B), else the term is zero
          if (gg_in_ex_gem AND bb_in_ex_blk) then
            !!! debug
 !           stdout.text("Selected case A: coef is present in the product of coefficients")
            !!!
            !
            ! case A: "coef" is present in the product of coefficients
            !
            .rdm_2_ab(.nonzero_terms_ab).grad(l)=.rdm_2_ab(.nonzero_terms_ab).grad(l)+ &
            grad_info_tmp.term(k)/.bra_set.vec(gg).coef(bb)*grad_info_tmp.factor(k)
          else if (gg_in_ex_gem AND (NOT bb_in_ex_blk)) then
            cycle
          else 
            !!! debug
 !           stdout.text("Selected case B: coef is in the reduced overlap")
            !!!
            !
            ! case B: "coef" is in the reduced overlap
            !
            ng = .n_geminals-grad_info_tmp.ex_gem(k).element.dim-1
            red_pbg.n_geminals = ng
            red_pbg.nonzero_coef_ind.create(ng)
            red_pbg.nonzero_coef_prod.create(ng)
            ! two subcases (depending on the block size)
            if (bb <= .n_1D_blocks) then 
               !
               ! block "bb" is of size 1
               !
               ! compute the new reduced overlap 
              if (ng > 0) then
                 siz=grad_info_tmp.ex_gem(k).element.dim
                 ex_gem.create(siz+1)
                 ex_gem(1:siz)=grad_info_tmp.ex_gem(k).element
                 ex_gem(siz+1)=gg
                 .prep_red_pbg(red_pbg,ex_gem)
                 ex_gem.destroy
                 red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
              else
                 overlap = ONE
              end
               !!! debug
 !              stdout.show("New reduced overlap =", overlap)
               !!!
               ! we suppose .bra_set.vec(gg).coef(bb)=.ket_set.vec(gg).coef(bb) hence the facto TWO
              .rdm_2_ab(.nonzero_terms_ab).grad(l)=.rdm_2_ab(.nonzero_terms_ab).grad(l) &
              +grad_info_tmp.coef_prod(k)*TWO*.bra_set.vec(gg).coef(bb)*overlap
            else
               !
               ! block "bb" is of size 2
               !
               ! compute the new reduced overlap 
              if (ng > 0) then
                 siz=grad_info_tmp.ex_gem(k).element.dim
                 ex_gem.create(siz+1)
                 ex_gem(1:siz)=grad_info_tmp.ex_gem(k).element
                 ex_gem(siz+1)=gg
                 siz=grad_info_tmp.ex_blk(k).element.dim 
                 ex_blk.create(siz+1)
                 ex_blk(1:siz)=grad_info_tmp.ex_blk(k).element
                 ex_blk(siz+1)=bb
                 .prep_red_pbg(red_pbg,ex_gem,ex_blk,problem)
                 ex_gem.destroy
                 ex_blk.destroy
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng+1))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                 else 
                    cycle
                 end
              else
                 overlap = ONE
              end
              .rdm_2_ab(.nonzero_terms_ab).grad(l)=.rdm_2_ab(.nonzero_terms_ab).grad(l) &
              +grad_info_tmp.coef_prod(k)*FOUR*.bra_set.vec(gg).coef(bb)*overlap
            end
            red_pbg.destroy_ptr_part
          end
        end
      end
   end   


!  =========================================
!  COEFFICIENT OPTIMIZATION RELATED ROUTINES
!  =========================================

   optimize_coef
   ! perform the optimization of the block coefficients 
   ! (i.e. find the set of block coefficients which minimize the
   ! electronic energy, for a given block structure)
     self :: target
     coef :: VEC{REAL}*
     i, j, k, siz, n_nonzero_coef :: INT
     el_energy, coef_tol, grad_tol, step :: REAL
     max_it, n_col :: INT
     iter :: VEC{INT}(1)
     energy_min, delta_ene, grd_norm :: VEC{REAL}(1)
     grad :: VEC{REAL}*
     !
     ! check if the bra set is equal to the ket set;
     ! if not, stop the program execution
     !
     if (NOT .bra_is_ket) then
        stdout.text("Bra is not equal to ket:")
        stdout.text("optimization of the block coefficients")
        stdout.text("not implemented yet, for this case.")
        stop
     end
     !
     ! write information about the set of block coefficients to be optimized
     ! and calculate nb of nonzero block coefficients
     !
     stdout.text(" ")
     stdout.text("Indices of blocks with nonzero coefficient:")
     siz = 0
     do i=1,.n_geminals 
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.show("block indices",.bra_set.vec(i).new_nonzero_coef_ind)
        siz=siz+size(.bra_set.vec(i).new_nonzero_coef_ind)
     end
     n_nonzero_coef = siz
     .nb_grad_wrt_coef = siz
     !
     ! prepare initial set of coefficients 
     ! (and angles) to be optimized
     !
     if (.opt_GD2_angles AND .n_2D_3typ_blocks > 0) siz=siz+.n_2D_3typ_blocks
     .nb_grad_elt = siz
     coef.create(siz)
     ! initialize the energy derivative
     .create(.energy_gradient,siz)
     .energy_gradient(siz).elt = ZERO

     siz = 0
     ! nonzero block coefficients
     do i=1,.n_geminals
        do j=1,size(.bra_set.vec(i).new_nonzero_coef_ind)
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           siz = siz + 1
           coef(siz) = .bra_set.vec(i).coef(k)
           ! save the geminal and block indices of the gradient element
           .energy_gradient(siz).indices(1) = i
           .energy_gradient(siz).indices(2) = k
        end do
     end do
     ! write the intial set of nonzero block coefficients
     stdout.text(" ")
     stdout.show("Total number of nonzero coefficient =",n_nonzero_coef)
     stdout.text(" ")
     stdout.text("Initial nonzero coefficients:")
     stdout.put(coef(1:n_nonzero_coef))

     if (.opt_GD2_angles AND .n_2D_3typ_blocks > 0) then
        ! GD2 angles
        do i=1,.n_2D_3typ_blocks
           siz = siz + 1
           coef(siz) = .GD2_info(i) 
           ! save the block index of the gradient element
           .energy_gradient(siz).indices(1) = i
           .energy_gradient(siz).indices(2) = i
        end
        ! write the initial set of GD2 angles to be optimized
        stdout.text(" ")
        stdout.text("Optimization of GD2 angles will be performed as well")
        stdout.text(" ")
        stdout.show("Total number of GD2 angles =",.n_2D_3typ_blocks)
        stdout.text(" ")
        stdout.text("Initial GD2 angles:")
        stdout.put(coef(n_nonzero_coef+1:siz))
     end
     !
     ! perform the minimization of the energy WRT the block coefficients 
     !
     stdout.text(" ")
     stdout.text("* * * Starting BFGS minimization * * *")
     ! initialize variable for writing info.
     ! about the optimization to the output
     .coef_opt_info.iter = 0
     .coef_opt_info.new_iter = FALSE
     .coef_opt_info.energy_min_curr = ZERO
     .coef_opt_info.energy_min_prev = ZERO
     el_energy = ZERO
     ! create a table (for info. about the coef. optimization)
     n_col = 4
     .coef_opt_info.table.create(n_col)
     .coef_opt_info.table(1).set_heading("Iter")
     .coef_opt_info.table(1).force_width(6)
!     .coef_opt_info.table(1).set_width_from(max_it)
     .coef_opt_info.table(2).set_heading("Energy")
     .coef_opt_info.table(2).set_subhead("E/au")
     .coef_opt_info.table(2).set_width_from(el_energy)
     .coef_opt_info.table(3).set_heading("Delta")
     .coef_opt_info.table(3).set_subhead("E")
     .coef_opt_info.table(3).set_width_from(el_energy)
     .coef_opt_info.table(4).set_heading("Gradient")
     .coef_opt_info.table(4).set_subhead("Norm")
     .coef_opt_info.table(4).set_width_from(el_energy)
     .coef_opt_info.table.put_headings
     ! call the routine for energy minimization 
     coef_tol= .coef_opt_info.coef_tol 
     grad_tol= .coef_opt_info.grad_tol 
     step= .coef_opt_info.step 
     max_it= .coef_opt_info.max_it 
     nullify(pbg_saved)
     pbg_saved => self
     VEC{REAL}:minimize_BFGS(::energy_gem,::gradient_gem, coef, el_energy, coef_tol, grad_tol, step, max_it)
     ! store results of the last iteration
     .electronic_energy = el_energy
     energy_min = el_energy
     iter = .coef_opt_info.iter
     delta_ene = el_energy-.coef_opt_info.energy_min_prev
     ! compute the gradient norm at the final energy point
     siz = size(coef)
     grad.create(siz)
     nullify(pbg_saved)
     pbg_saved => self
     grad = ::gradient_gem(coef)
     grd_norm = grad.norm
     grad.destroy
     ! write final results of the optimization to the output
     .coef_opt_info.table(1).set_values(iter)
     .coef_opt_info.table(2).set_values(energy_min)
     .coef_opt_info.table(3).set_values(delta_ene)
     .coef_opt_info.table(4).set_values(grd_norm)
     .coef_opt_info.table.put_body
     !
     .coef_opt_info.table.put_footer
     .coef_opt_info.table.destroy
     !
     stdout.text(" ")
     stdout.text("* * * Optimization completed * * *")
     stdout.text(" ")
     !
     ! write optimized energies and set of geminals to the output
     !
     stdout.text(" ")
     stdout.text("============================")
     stdout.text("Pauli block geminals results")
     stdout.text("============================")
     ! write optimized energies
     stdout.text(" ")
     stdout.text("Optimized energies (in a.u.):")
     stdout.text(" ")
     stdout.show("Electronic energy =",.electronic_energy)
     stdout.show("Nuclear repulsion energy =",.nuclear_repulsion_energy)
     stdout.show("Total energy =",.electronic_energy+.nuclear_repulsion_energy)
     stdout.text(" ")
     ! write optimized "bra_set" of geminals
     stdout.text("Optimized geminals:")
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end
     if (.bra_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("GD2 angles:")
        !stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end
     stdout.text(" ")
     !
     ! destroy previously created arrays
     ! and nullify pointers
     !
     coef.destroy
     nullify(pbg_saved)

   end

   energy_gem(coef) result(ene) ::: selfless
   ! compute the electronic energy associated to the block
   ! coefficients "coef"
     coef :: VEC{REAL}, IN
     ene :: REAL
     overlap :: REAL
     !
     self :: PAULI_BLOCK_GEMINALS*
     !
     counter :: INT, save = 1
     iter :: VEC{INT}(1), save = 0
     energy_min, delta_ene, grd_norm :: VEC{REAL}(1)
     !
     !!! debug
!     stdout.text(" ")
!     stdout.show("Entering function energy_gem(coef)",counter)
!     counter = counter+1
!     !stdout.text("Entering function energy(coef)")
!     stdout.text(" ")
     !!!

     self => pbg_saved

     ! update objects used to compute the energy 
     .update_coef(coef)

     ! compute the squared norm of the wavefunction
     .calc_overlap_integral(overlap,FALSE)
     .overlap = overlap

     ! compute the 2RDM
     .calc_2rtm_epi2o(make_grad=FALSE)
     !.calc_2rdm_gen
     !.calc_2rdm_gen_grd

     ! compute the electronic energy
     .make_ham_expect_val(ham=ene,wrt_arg=FALSE)

     !!!
!     stdout.text(" ")
!     stdout.show("Electronic energy =",ene)
     !!!

     ! this is to save the energy of the first point of the
     ! optimization
     if (counter == 1) then
        !
        ! first energy point of the optimization
        !
        .coef_opt_info.energy_min_prev = ene
        .coef_opt_info.energy_min_curr = ene
     else
        !
        ! subsequent (not first) energy points of the optimization
        !
        if (.coef_opt_info.new_iter) then
        !if (.coef_opt_info.iter /= iter(1)) then
           !
           ! write results of the previous iteration (of the
           ! optimization) to the output
           !
           energy_min = .coef_opt_info.energy_min_curr
           delta_ene = .coef_opt_info.energy_min_curr-.coef_opt_info.energy_min_prev
           grd_norm = .coef_opt_info.grd_norm
           .coef_opt_info.table(1).set_values(iter)
           .coef_opt_info.table(2).set_values(energy_min)
           .coef_opt_info.table(3).set_values(delta_ene)
           .coef_opt_info.table(4).set_values(grd_norm)
           .coef_opt_info.table.put_body
           .coef_opt_info.table.clear_columns
           ! update info. about the optimization
           .coef_opt_info.new_iter = FALSE
           .coef_opt_info.iter = .coef_opt_info.iter+1
           iter = .coef_opt_info.iter
           !iter = .coef_opt_info.iter
           .coef_opt_info.energy_min_prev = .coef_opt_info.energy_min_curr
           .coef_opt_info.energy_min_curr = ene
        else if (ene < .coef_opt_info.energy_min_curr) then
           !
           ! update the minimum energy at the current iteration
           !
           .coef_opt_info.energy_min_curr = ene
        end
     end

     ! "counter" counts the time the function is called 
     ! during the optimization
     counter = counter+1

   end

   update_coef(new_coef)
   ! update "bra_set.vec(:).coef", "bra_set.vec(:).red_coef" and
   ! "nonzero_coef_prod" using nonzero coefficients "new_coef";
   ! after updating "bra_set.vec(:).coef", the geminals are normalized
     new_coef :: VEC{REAL}, IN
     i, j, k :: INT
     n_nonzero_coef :: INT
     counter :: INT
     p_coef_1ortho :: REAL
     n_nonzero_1ortho :: INT
     n_nonzero_blocks :: INT
     ind, ind_prod :: INT
     ang :: REAL
     !!!
!     stdout.text(" ")
!     stdout.text("Entering function update_coef")
     !!!

     ! update "bra_set.vec(:).coef"
     counter = 0
     do i=1,.n_geminals
        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           counter = counter+1
           .bra_set.vec(i).coef(k) = new_coef(counter)
        end
     end

     ! update GD2 angles and matrix elements
     ! (if optimization of GD2 angles is requested)
     if (.opt_GD2_angles) then 
        do i=1,.n_2D_3typ_blocks
           counter = counter+1
           !! new
           ang = new_coef(counter) 
           .GD2_info(i) = ang - (int(ang/PI) * PI)
           !! old
           !.GD2_info(i) = new_coef(counter)
        end
        .initialize_GD2
     end

     ! normalize geminals
     ! ("bra_set.vec(:).coef" will be changed)
     .normalize_gem(wrt_arg=FALSE)

     ! update "bra_set.vec(:).red_coef" and "nonzero_coef_prod"
     do i=1,.n_geminals
        ! "bra_set.vec(i).red_coef"
        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           .bra_set.vec(i).red_coef(j) = .bra_set.vec(i).coef(k)
        end
        ! "nonzero_coef_prod(i).element"
        n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
        n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
        if (.first_block == 0) then 
           p_coef_1ortho = ZERO
           do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
              p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)**2
           end
           .nonzero_coef_prod(i).element(1) = p_coef_1ortho
        end
        ind = 1-.first_block
        do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
           ind = ind + 1
           .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
           ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
           .nonzero_coef_prod(i).element(ind_prod) = TWO*(.bra_set.vec(i).red_coef(j)**2)
        end
     end

   end

   gradient_gem(coef) result(grad) ::: selfless
   ! compute the energy gradient with respec to the block
   ! coefficients "coef"
     coef :: VEC{REAL}, IN
     grad :: VEC{REAL}(size(coef))
     !
     self :: PAULI_BLOCK_GEMINALS*
     overlap :: REAL
     update :: BIN

     self => pbg_saved

     ! check if "coef" and (nonzero) ".bra_set.vec(:).coef" 
     ! differ or not; if they differ, update=TRUE
     .check_coef(coef, update)
     if (update) then
        !
        ! update objects used to compute the energy
        .update_coef(coef)
        !
        ! compute the squared norm of the wavefunction
        .calc_overlap_integral(overlap,FALSE)
        .overlap = overlap
     end !if
     
     ! compute the 2RDM
     ! (and save info. to compute the energy gradient)
     !.calc_2rdm_gen_grd
     .calc_2rtm_epi2o(make_grad=TRUE)

     ! compute the energy gradient
    !tmp .calc_energy_gradient(grad=grad, wrt_arg=FALSE)
     .calc_energy_gradient(grad=grad)

     ! compute the gradient norm
     .coef_opt_info.grd_norm = grad.norm

     ! ".coef_opt_info.new_iter" indicates when a new iteration
     ! of the optimization has started
     .coef_opt_info.new_iter = TRUE

   end

   check_coef(coef, differ_coef)
   ! check if "coef" and nonzero coefficients in "bra_set.vec(:).coef"
   ! are the same; if not, set "differ_coef" to TRUE
     coef :: VEC{REAL}, IN
     differ_coef :: BIN, INOUT
     i, j, k :: INT
     n_nonzero_coef :: INT
     counter :: INT
     diffc :: REAL
     !!!
!     stdout.text(" ")
!     stdout.text("Entering routine check_coef")
     !!!

     differ_coef = FALSE
     counter = 0
     do i=1,.n_geminals
        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           counter = counter+1
           diffc = coef(counter)-.bra_set.vec(i).coef(k)
           if (abs(diffc) > TOL(15)) then
              differ_coef = TRUE
!              stdout.text("Coef has to be updated before computing the gradient")
              return
           end
        end
     end

!     if (NOT differ_coef) then
!        stdout.text(" ")
!        stdout.text("Coef is up-to-date")
!     end

   end

   calc_energy_gradient(grad, wrt_arg)
   ! compute the energy gradient with respect to the block
   ! coefficients
     grad :: VEC{REAL}, INOUT, optional
     !to transfer results to this vector
     wrt_arg :: BIN, IN, optional
     !to print results
     !
     siz, g, i, j :: INT
     integrals :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     wrt :: BIN
     !!!
!     stdout.text(" ")
!     stdout.text("Starting calculation of the energy gradient")
!     stdout.text("(entering subroutine calc_energy_gradient)")
!     stdout.text(" ")
     !!!

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     ! check if the bra set is equal to the ket set;
     ! if not, stop the program execution
     if (NOT .bra_is_ket) then
        stdout.text("Bra is not equal to ket:")
        stdout.text("calculation of the energy gradient")
        stdout.text("not implemented yet, for this case.")
        stop
     end

     ! store and read in the integrals
     eri_archive.set(.name,"h_integrals")
     integrals.create(.mat_size,.mat_size,.mat_size,.mat_size)
     eri_archive.read(integrals)

     ! set the size of the energy gradient vector
     if (.nb_grad_elt > 0) then
       siz=.nb_grad_elt
     else
       siz=0
       do g=1,.n_geminals
          siz = siz + size(.bra_set.vec(g).new_nonzero_coef_ind)
       end
       .nb_grad_wrt_coef=siz
       if (.opt_GD2_angles) siz = siz +.n_2D_3typ_blocks
       .nb_grad_elt=siz
     end

     ! create energy gradient vector
     ! (if not created yet or the size of 
     ! the existing one is different from "siz")
     if (NOT .energy_gradient.created) then
        .create(.energy_gradient, siz)
     else if (size(.energy_gradient) /= siz) then
        .destroy(.energy_gradient)
        .create(.energy_gradient, siz)
     end
     !
     ! compute the energy gradient
     ! elements w.r.t. the block coefficients
     ! ("i" is the index of the gradient element)
     !
     do i = 1,.nb_grad_wrt_coef
     ! compute the energy derivative with respect to the coefficient of
     ! geminal ".energy_gradient(i).indices(1)" and block ".energy_gradient(i).indices(2)"
       .calc_energy_grad_elt(i,integrals)
     end
     !
     ! compute the energy gradient
     ! elements w.r.t. the GD2 angles
     ! (if requested)
     !
!pcc     if (.opt_GD2_angles) then
!pcc        do b=1,.n_2D_3typ_blocks
!pcc           ! compute the energy derivative with respect 
!pcc           ! to the GD2 angle of 3-type block "b"
!pcc           .calc_energy_grad_elt_gd2(b,i,integrals)
!pcc           i = i+1
!pcc        end
!pcc     end
!pcc
     ! destroy matrix of integrals
     integrals.destroy

     ! set the effective size of the energy gradient
     ! (i.e. the number of computed element)
!pcc     siz = i-1

     ! write results
     if (wrt) then
        stdout.text(" ")
        stdout.text("Energy gradient:")
        do j=1,siz
           stdout.text(" ")
           stdout.show("element indices",.energy_gradient(j).indices)
           stdout.show("element value",.energy_gradient(j).elt)
        end
        stdout.text(" ")
     end

     ! copy energy gradient to array "grad"
     ! (if the latter is provided as argument)
     if (present(grad)) then
        do j=1,siz
           grad(j) = .energy_gradient(j).elt
        end
     end

   end

   calc_energy_grad_elt(i, integrals)
   ! compute the derivative of the energy with respect to the
   ! coefficient of geminal "g" associated with block "b"
   ! (i.e. element "i" of the energy gradient with respect to the
   ! block coefficients)
     i :: INT, IN
     integrals :: MAT4{REAL}, IN
     g, b  :: INT
     j :: INT
     ene_deriv, rdm2_deriv :: REAL 
     coef, rov :: REAL
     i1, j1, i2, j2 :: INT
     red_pbg :: PAULI_BLOCK_GEMINALS
     !!!
     gg, bb :: VEC{INT}(1)
     problem :: BIN
     ove_deriv :: REAL
     !!!
!     ng_1, i_rdm2 :: INT
!     indices :: VEC{INT}(4)
     !!! debug
     stdout.text(" ")
     stdout.text("Entering subroutine calc_energy_grad_elt")
     stdout.show("element", i)
     stdout.text(" ")
     !!!
     g = .energy_gradient(i).indices(1)
     b = .energy_gradient(i).indices(2)
     coef = .bra_set.vec(g).coef(b)
     !!!
     stdout.text(" ")
     stdout.text("Coefficient")
     stdout.show("geminal", g)
     stdout.show("block  ", b)
     !!!

     !
     ! start the calculation of the energy derivative:
     ! compute the derivative of the expectation value 
     ! of the electronic hamiltonian (i.e. the numerator 
     ! in the energy formula)
     !
     ene_deriv = ZERO
     !
     ! compute the contribution of the 2RDM ab (using the appropriate integral)
     !
     stdout.text(" ")
     stdout.text("ab 2RTM")
     do j=1,.nonzero_terms_ab
        i1 =.rdm_2_ab(j).indices(1)
        j1 =.rdm_2_ab(j).indices(2)
        i2 =.rdm_2_ab(j).indices(3)
        j2 =.rdm_2_ab(j).indices(4)
        rdm2_deriv = .rdm_2_ab(j).grad(i)
     stdout.show("i1", i1)
     stdout.show("j1", j1)
     stdout.show("i2", i2)
     stdout.show("j2", j2)
     stdout.show("grad",rdm2_deriv)
        ene_deriv = ene_deriv + rdm2_deriv*integrals(i1,j1,i2,j2)
     end
     !
     ! compute the contribution of the 2RDM aa (using the appropriate integral)
     !
     stdout.text(" ")
     stdout.text("aa 2RTM")
     do j=1,.nonzero_terms_aa
        i1 =.rdm_2_aa(j).indices(1)
        j1 =.rdm_2_aa(j).indices(2)
        i2 =.rdm_2_aa(j).indices(3)
        j2 =.rdm_2_aa(j).indices(4)
        rdm2_deriv = .rdm_2_aa(j).grad(i)
     stdout.show("i1", i1)
     stdout.show("j1", j1)
     stdout.show("i2", i2)
     stdout.show("j2", j2)
     stdout.show("grad",rdm2_deriv)
        ene_deriv = ene_deriv + rdm2_deriv*(integrals(i1,j1,i2,j2)-integrals(i1,j1,j2,i2))
     end
     !
     ! compute the contribution of the 2RDM bb (using the appropriate integral)
     !
     stdout.text(" ")
     stdout.text("bb 2RTM")
     do j=1,.nonzero_terms_bb
        i1 =.rdm_2_bb(j).indices(1)
        j1 =.rdm_2_bb(j).indices(2)
        i2 =.rdm_2_bb(j).indices(3)
        j2 =.rdm_2_bb(j).indices(4)
        rdm2_deriv = .rdm_2_bb(j).grad(i)
     stdout.show("i1", i1)
     stdout.show("j1", j1)
     stdout.show("i2", i2)
     stdout.show("j2", j2)
     stdout.show("grad",rdm2_deriv)
        ene_deriv = ene_deriv + rdm2_deriv*(integrals(i1,j1,i2,j2)-integrals(i1,j1,j2,i2))
     end

     ! compute the derivative of the square norm 
     ! of the wavefunction (i.e. of .overlap)
     rov = ONE
     if (.n_geminals > 1) then
        gg(1) = g
        if (b <= .n_1D_blocks) then 
           ! "b" is a 1D block:
           ! compute the reduced overlap, 
           ! excluding geminal "g"
           .prep_red_pbg(red_pbg, gg)
           red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg.calc_overlap_integral(rov,FALSE)
           ove_deriv = TWO*coef*rov
        else
           ! "b" is a 2D block:
           ! compute the reduced overlap, 
           ! excluding geminal "g" and block "b"
           bb(1) = b
           .prep_red_pbg(red_pbg, gg, bb, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg.calc_overlap_integral(rov,FALSE)
           else
              rov = ZERO
           end
           ove_deriv = FOUR*coef*rov
        end
     else !only one geminal
        if (b <= .n_1D_blocks) then 
           ! "b" is a 1D block
           ove_deriv = TWO*coef 
        else
           ! "b" is a 2D block
           ove_deriv = FOUR*coef 
        end
     end

     !!! debug
     stdout.text(" ")
     stdout.show("geminal",g)
     stdout.show("block",b)
     stdout.show("Numerator derivative =",ene_deriv)
     stdout.show("Electronic energy =",.electronic_energy)
     stdout.show("Coefficient =",coef)
     stdout.show("Reduced overlap =",rov)
     stdout.show("Overlap derivative =", ove_deriv)
     !!!
     !
     ! compute the final value of the energy derivative
     ! (including the contribution from the wfu norm) 
     ene_deriv = (ene_deriv - .electronic_energy*ove_deriv)/.overlap
     !
     !!! debug
     stdout.show("Energy gradient element =",ene_deriv)
     !!!

     ! store the value of the energy derivative
     .energy_gradient(i).elt = ene_deriv

   end

!pcc   calc_energy_grad_elt_gd2(b, i, integrals)
!pcc   ! compute the derivative of the energy with 
!pcc   ! respect to the GD2 angle of 3-type block "b"
!pcc   ! (i.e. element "i" of the energy gradient)
!pcc     b, i :: INT, IN
!pcc     integrals :: MAT4{REAL}, IN
!pcc     j, k, m :: INT
!pcc     nt, nt_gd2 :: INT
!pcc     blk1, blk2 :: INT
!pcc     cas1, cas2 :: INT
!pcc     i_rdm2 :: INT
!pcc     nonzero_elt :: VEC{INT}(3)
!pcc     rdm2_type :: VEC{STR}(3)
!pcc     indices :: VEC{INT}(4)
!pcc     i1, j1, i2, j2 :: INT
!pcc     ene_deriv, rdm2_deriv :: REAL 
!pcc     fact1, fact2, cpr, rov :: REAL
!pcc     siz :: VEC{INT}(18)
!pcc
!pcc     ! create object to store temporary information for the
!pcc     ! calculation of the energy gradient with respect to 
!pcc     ! the GD2 angles (if not created yet)
!pcc     if (NOT .grad_info_tmp.coef_prod.created) then
!pcc        nt = 18
!pcc        !nt = 10
!pcc        .create_2rdm_grad_info_tmp(nt)
!pcc     end
!pcc     !
!pcc     ! build array of 2RDM types
!pcc     ! (i.e. alpha/beta, alpha/alpha, beta/beta)
!pcc     ! and of numbers of nonzero 2RDM elements
!pcc     !
!pcc     rdm2_type(1) = "ab"
!pcc     rdm2_type(2) = "aa"
!pcc     rdm2_type(3) = "bb"
!pcc     nonzero_elt(1) = .nonzero_terms_ab
!pcc     nonzero_elt(2) = .nonzero_terms_aa
!pcc     nonzero_elt(3) = .nonzero_terms_bb
!pcc     !
!pcc     ! start the calculation of the energy derivative
!pcc     !
!pcc     ene_deriv = ZERO
!pcc     do i_rdm2=1,3 
!pcc        !
!pcc        ! compute contribution (to the energy derivative) from the 2RDM
!pcc        ! "rdm2_type"
!pcc        !
!pcc        do j=1,nonzero_elt(i_rdm2)
!pcc           !
!pcc           ! compute the derivative of one element of the 2RDM
!pcc           !
!pcc           rdm2_deriv = ZERO
!pcc           ! copy info. about the 2RDM element "j" to ".grad_info_tmp"
!pcc           ! and the indices of the 2RDM element "j" to "indices"
!pcc           .copy_2rdm_grad_info(irdm=j, rdm2_type=rdm2_type(i_rdm2), rdm2_ind=indices, gd2_info_arg=TRUE, gd2_siz=siz)
!pcc           ! set number of terms
!pcc           ! which depend on GD2 angles
!pcc           nt_gd2 = .grad_info_tmp.nb_GD2_terms
!pcc           do k=1,nt_gd2
!pcc              cpr = .grad_info_tmp.GD2_cpr(k)
!pcc              m = .grad_info_tmp.GD2_terms(k)
!pcc              rov = .grad_info_tmp.red_ov(m)
!pcc              select case (siz(k))
!pcc                 case (1)
!pcc                    blk1 = .grad_info_tmp.GD2_blk(k).element(1)
!pcc                    if (b == blk1) then
!pcc                       cas1 = .grad_info_tmp.GD2_cas(k).element(1)
!pcc                       ! multiplication factor needed to
!pcc                       ! compute the derivative
!pcc                       fact1 = .gd2_deri_factor(blk1, cas1)
!pcc                       !
!pcc                       rdm2_deriv = rdm2_deriv + cpr*rov*fact1
!pcc                    end
!pcc                 case (2)
!pcc                    blk1 = .grad_info_tmp.GD2_blk(k).element(1)
!pcc                    blk2 = .grad_info_tmp.GD2_blk(k).element(2)
!pcc                    if (b == blk1) then
!pcc                       cas1 = .grad_info_tmp.GD2_cas(k).element(1)
!pcc                       cas2 = .grad_info_tmp.GD2_cas(k).element(2)
!pcc                       ! multiplication factors needed to
!pcc                       ! compute the derivative
!pcc                       fact1 = .gd2_deri_factor(blk1, cas1)
!pcc                       fact2 = .gd2_mult_factor(blk2, cas2)
!pcc                       !
!pcc                       rdm2_deriv = rdm2_deriv + cpr*rov*fact1*fact2
!pcc                    else if (b == blk2) then
!pcc                       cas1 = .grad_info_tmp.GD2_cas(k).element(1)
!pcc                       cas2 = .grad_info_tmp.GD2_cas(k).element(2)
!pcc                       ! multiplication factors needed to
!pcc                       ! compute the derivative
!pcc                       fact1 = .gd2_deri_factor(blk2, cas2)
!pcc                       fact2 = .gd2_mult_factor(blk1, cas1)
!pcc                       !
!pcc                       rdm2_deriv = rdm2_deriv + cpr*rov*fact1*fact2
!pcc                    end
!pcc                 case default
!pcc                    stdout.text("Error in routine calc_energy_grad_elt_gd2:")
!pcc                    stdout.text("unknown integer to select case.")
!pcc                    stop
!pcc              end !select
!pcc           end
!pcc           ! compute the contribution to the energy gradient element
!pcc           ! (using the appropriate integral)
!pcc           i1 = indices(1)
!pcc           j1 = indices(2)
!pcc           i2 = indices(3)
!pcc           j2 = indices(4)
!pcc           select case (i_rdm2)
!pcc           case(1)
!pcc              ! 2RDM alpha/beta
!pcc              ene_deriv = ene_deriv + rdm2_deriv*integrals(i1,j1,i2,j2)
!pcc           case(2,3)
!pcc              ! 2RDM alpha/alpha or beta/beta
!pcc              ene_deriv = ene_deriv + rdm2_deriv*(integrals(i1,j1,i2,j2)-integrals(i1,j1,j2,i2))
!pcc           case default
!pcc              stdout.text("Error in routine calc_energy_grad_elt_gd2:")
!pcc              stdout.text("unknown integer to select the 2RDM part.")
!pcc              stop
!pcc           end
!pcc        end
!pcc     end
!pcc     ! divide the derivative of <Hel> 
!pcc     ! by the wfu square norm
!pcc     ene_deriv = ene_deriv/.overlap
!pcc
!pcc     ! store the value of the energy derivative
!pcc     .energy_gradient(i).elt = ene_deriv
!pcc     ! store the indices of the gradient element
!pcc     .energy_gradient(i).indices(1) = 0
!pcc     .energy_gradient(i).indices(2) = b
!pcc      
!pcc   end

   gd2_deri_factor(blk, cas) result(factor)
   ! compute multiplicative factor (derivative of one 
   ! of 5 possible combinations of GD2 elements) 
   ! to calculate the derivative of a term in a given 
   ! 2RDM element w.r.t. a GD2 angle
     blk, cas :: INT, IN
     factor :: REAL
     elt1, elt2 :: REAL
     
     elt1 = .first_GD2_elt(blk)
     elt2 = .second_GD2_elt(blk)

     factor = ZERO
     select case (cas)
     case(1)
        factor = elt2
     case(2)
        factor = -elt1
     case(3)
        factor = TWO*elt1*elt2
     case(4)
        factor = -TWO*elt1*elt2
     case(5)
        factor = (elt2**2 - elt1**2)
     case default
        stdout.text("Error in function gd2_deri_factor:")
        stdout.text("unknown integer to select case.")
        stop
     end

   end

   gd2_mult_factor(blk, cas) result(factor)
   ! compute multiplicative factor (one of 5 possible 
   ! combinations of GD2 elements) to calculate the 
   ! derivative of a term in a given 2RDM element 
   ! w.r.t. a GD2 angle
     blk, cas :: INT, IN
     factor :: REAL
     elt1, elt2 :: REAL
     
     elt1 = .first_GD2_elt(blk)
     elt2 = .second_GD2_elt(blk)

     factor = ZERO
     select case (cas)
     case(1)
        factor = elt1
     case(2)
        factor = elt2
     case(3)
        factor = elt1**2
     case(4)
        factor = elt2**2
     case(5)
        factor = elt1*elt2
     case default
        stdout.text("Error in function gd2_mult_factor:")
        stdout.text("unknown integer to select case.")
        stop
     end

   end
! de

! davide - 11/03/2020
!pcc   copy_2rdm_grad_info(irdm, rdm2_type, rdm2_ind, gd2_info_arg, gd2_siz)
!pcc   ! copy gradient information of the 2RDM element "irdm", 
!pcc   ! type "rdm2_type" to the temporary ".grad_info_tmp";
!pcc   ! copy indices of the 2RDM element "irdm" to "rdm2_ind"
!pcc     irdm :: INT, IN
!pcc     rdm2_type :: STR, IN
!pcc     rdm2_ind :: VEC{INT}(4), INOUT
!pcc     gd2_info_arg :: BIN, IN, optional
!pcc     gd2_siz :: VEC{INT}, optional
!pcc     gd2_info :: BIN
!pcc     nt, j :: INT
!pcc     siz :: INT
!pcc     !!!
!pcc     nt_gd2 :: INT
!pcc     !!!
!pcc     !!! debug
!pcc!     stdout.text(" ")
!pcc!     stdout.text("Entering subroutine copy_2rdm_grad_info")
!pcc!     stdout.text(" ")
!pcc     !!!
!pcc
!pcc     if (present(gd2_info_arg)) then
!pcc        gd2_info = gd2_info_arg
!pcc     else
!pcc        gd2_info = FALSE
!pcc     end
!pcc
!pcc     select case (rdm2_type)
!pcc     case("ab")
!pcc        ! set number of terms
!pcc        nt = .rdm_2_ab_grad_info(irdm).nb_terms
!pcc        .grad_info_tmp.nb_terms = nt
!pcc        do j=1,nt
!pcc           ! product of coefficients
!pcc           .grad_info_tmp.coef_prod(j) = .rdm_2_ab_grad_info(irdm).coef_prod(j)
!pcc           ! reduced overlap
!pcc           .grad_info_tmp.red_ov(j) = .rdm_2_ab_grad_info(irdm).red_ov(j)
!pcc           ! indices of excluded geminals
!pcc           siz = size(.rdm_2_ab_grad_info(irdm).ex_gem(j).element)
!pcc           .grad_info_tmp.ex_gem(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).ex_gem(j).element(1:siz)
!pcc           ! indices of excluded blocks
!pcc           siz = size(.rdm_2_ab_grad_info(irdm).ex_blk(j).element)
!pcc           .grad_info_tmp.ex_blk(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).ex_blk(j).element(1:siz)
!pcc           ! multiplication factors
!pcc           siz = size(.rdm_2_ab_grad_info(irdm).factor(j).element)
!pcc           .grad_info_tmp.factor(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).factor(j).element(1:siz)
!pcc        end
!pcc        ! indices of the 2RMD element (i1,j1,i2,j2)
!pcc        rdm2_ind = .rdm_2_ab(irdm).indices
!pcc        ! additional info. about the product of coefficients
!pcc        if (.rdm_2_ab_grad_info(irdm).all_pairs.created) then
!pcc           do j=1,nt
!pcc              .grad_info_tmp.all_pairs(j) = .rdm_2_ab_grad_info(irdm).all_pairs(j)
!pcc           end
!pcc        else
!pcc           .grad_info_tmp.all_pairs = FALSE
!pcc        end
!pcc        ! info. for calculation of gradient w.r.t. GD2 angles
!pcc        if (gd2_info) then
!pcc           nt_gd2 = .rdm_2_ab_grad_info(irdm).nb_GD2_terms
!pcc           .grad_info_tmp.nb_GD2_terms = nt_gd2
!pcc           if (nt_gd2 > 0) then
!pcc              .grad_info_tmp.GD2_terms(1:nt_gd2) = .rdm_2_ab_grad_info(irdm).GD2_terms(1:nt_gd2)
!pcc              .grad_info_tmp.GD2_cpr(1:nt_gd2) = .rdm_2_ab_grad_info(irdm).GD2_cpr(1:nt_gd2)
!pcc              do j=1,nt_gd2
!pcc                 siz = size(.rdm_2_ab_grad_info(irdm).GD2_blk(j).element)
!pcc                 gd2_siz(j) = siz
!pcc                 .grad_info_tmp.GD2_blk(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).GD2_blk(j).element
!pcc                 .grad_info_tmp.GD2_cas(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).GD2_cas(j).element
!pcc              end
!pcc           end
!pcc        end
!pcc     case("aa")
!pcc        ! set number of terms
!pcc        nt = .rdm_2_aa_grad_info(irdm).nb_terms
!pcc        .grad_info_tmp.nb_terms = nt
!pcc        do j=1,nt
!pcc           ! product of coefficients
!pcc           .grad_info_tmp.coef_prod(j) = .rdm_2_aa_grad_info(irdm).coef_prod(j)
!pcc           ! reduced overlap
!pcc           .grad_info_tmp.red_ov(j) = .rdm_2_aa_grad_info(irdm).red_ov(j)
!pcc           ! indices of excluded geminals
!pcc           siz = size(.rdm_2_aa_grad_info(irdm).ex_gem(j).element)
!pcc           .grad_info_tmp.ex_gem(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).ex_gem(j).element(1:siz)
!pcc           ! indices of excluded blocks
!pcc           siz = size(.rdm_2_aa_grad_info(irdm).ex_blk(j).element)
!pcc           .grad_info_tmp.ex_blk(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).ex_blk(j).element(1:siz)
!pcc           ! multiplication factors
!pcc           siz = size(.rdm_2_aa_grad_info(irdm).factor(j).element)
!pcc           .grad_info_tmp.factor(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).factor(j).element(1:siz)
!pcc        end
!pcc        ! indices of the 2RMD element (i1,j1,i2,j2)
!pcc        rdm2_ind = .rdm_2_aa(irdm).indices
!pcc        ! additional info. about the product of coefficients
!pcc        if (.rdm_2_aa_grad_info(irdm).all_pairs.created) then
!pcc           do j=1,nt
!pcc              .grad_info_tmp.all_pairs(j) = .rdm_2_aa_grad_info(irdm).all_pairs(j)
!pcc           end
!pcc        else
!pcc           .grad_info_tmp.all_pairs = FALSE
!pcc        end
!pcc        ! info. for calculation of gradient w.r.t. GD2 angles
!pcc        if (gd2_info) then
!pcc           nt_gd2 = .rdm_2_aa_grad_info(irdm).nb_GD2_terms
!pcc           .grad_info_tmp.nb_GD2_terms = nt_gd2
!pcc           if (nt_gd2 > 0) then
!pcc              .grad_info_tmp.GD2_terms(1:nt_gd2) = .rdm_2_aa_grad_info(irdm).GD2_terms(1:nt_gd2)
!pcc              .grad_info_tmp.GD2_cpr(1:nt_gd2) = .rdm_2_aa_grad_info(irdm).GD2_cpr(1:nt_gd2)
!pcc              do j=1,nt_gd2
!pcc                 siz = size(.rdm_2_aa_grad_info(irdm).GD2_blk(j).element)
!pcc                 gd2_siz(j) = siz
!pcc                 .grad_info_tmp.GD2_blk(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).GD2_blk(j).element
!pcc                 .grad_info_tmp.GD2_cas(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).GD2_cas(j).element
!pcc              end
!pcc           end
!pcc        end
!pcc     case("bb")
!pcc        ! set number of terms
!pcc        nt = .rdm_2_bb_grad_info(irdm).nb_terms
!pcc        .grad_info_tmp.nb_terms = nt
!pcc        do j=1,nt
!pcc           ! product of coefficients
!pcc           .grad_info_tmp.coef_prod(j) = .rdm_2_bb_grad_info(irdm).coef_prod(j)
!pcc           ! reduced overlap
!pcc           .grad_info_tmp.red_ov(j) = .rdm_2_bb_grad_info(irdm).red_ov(j)
!pcc           ! indices of excluded geminals
!pcc           siz = size(.rdm_2_bb_grad_info(irdm).ex_gem(j).element)
!pcc           .grad_info_tmp.ex_gem(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).ex_gem(j).element(1:siz)
!pcc           ! indices of excluded blocks
!pcc           siz = size(.rdm_2_bb_grad_info(irdm).ex_blk(j).element)
!pcc           .grad_info_tmp.ex_blk(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).ex_blk(j).element(1:siz)
!pcc           ! multiplication factors
!pcc           siz = size(.rdm_2_bb_grad_info(irdm).factor(j).element)
!pcc           .grad_info_tmp.factor(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).factor(j).element(1:siz)
!pcc        end
!pcc        ! indices of the 2RMD element (i1,j1,i2,j2)
!pcc        rdm2_ind = .rdm_2_bb(irdm).indices
!pcc        ! additional info. about the product of coefficients
!pcc        if (.rdm_2_bb_grad_info(irdm).all_pairs.created) then
!pcc           do j=1,nt
!pcc              .grad_info_tmp.all_pairs(j) = .rdm_2_bb_grad_info(irdm).all_pairs(j)
!pcc           end
!pcc        else
!pcc           .grad_info_tmp.all_pairs = FALSE
!pcc        end
!pcc        ! info. for calculation of gradient w.r.t. GD2 angles
!pcc        if (gd2_info) then
!pcc           nt_gd2 = .rdm_2_bb_grad_info(irdm).nb_GD2_terms
!pcc           .grad_info_tmp.nb_GD2_terms = nt_gd2
!pcc           if (nt_gd2 > 0) then
!pcc              .grad_info_tmp.GD2_terms(1:nt_gd2) = .rdm_2_bb_grad_info(irdm).GD2_terms(1:nt_gd2)
!pcc              .grad_info_tmp.GD2_cpr(1:nt_gd2) = .rdm_2_bb_grad_info(irdm).GD2_cpr(1:nt_gd2)
!pcc              do j=1,nt_gd2
!pcc                 siz = size(.rdm_2_bb_grad_info(irdm).GD2_blk(j).element)
!pcc                 gd2_siz(j) = siz
!pcc                 .grad_info_tmp.GD2_blk(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).GD2_blk(j).element
!pcc                 .grad_info_tmp.GD2_cas(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).GD2_cas(j).element
!pcc              end
!pcc           end
!pcc        end
!pcc     case default
!pcc        stdout.text("Error in routine copy_2rdm_grad_info:")
!pcc        stdout.text("unknown string to select the 2RDM part.")
!pcc       stop
!pcc     end !select
!pcc
!pcc   end

!pcc   calc_new_red_overlap(iterm, gem, blk, red_overlap)
!pcc   ! compute a new reduced overlap, where geminal "gem" and 2D
!pcc   ! block "blk" (if "blk" is present) are excluded, in addition to 
!pcc   ! the geminals and 2D blocks already excluded in the calculation 
!pcc   ! of term "iterm" of element the 2RDM whose gradient information
!pcc   ! is stored in ".grad_info_tmp"
!pcc     iterm, gem :: INT, IN
!pcc     blk :: INT, IN, optional
!pcc     red_overlap :: REAL, INOUT
!pcc     n_ex_gem, n_ex_blk :: INT
!pcc     ng, nb :: INT
!pcc     gg, bb :: VEC{INT}(3)
!pcc     check_nb_gem, problem :: BIN
!pcc     red_pbg :: PAULI_BLOCK_GEMINALS
!pcc     !!!
!pcc     i_gem, j_gem, k, blk_add :: INT
!pcc     ww :: VEC{INT}(2)
!pcc     idum :: INT
!pcc     !!!
!pcc     !!! debug
!pcc!     stdout.text(" ")
!pcc!     stdout.text("Entering subroutine calc_new_red_overlap(new)")
!pcc!     stdout.text(" ")
!pcc     !!!
!pcc
!pcc     ! prepare geminal indices to be excluded
!pcc     i_gem = .grad_info_tmp.ex_gem(iterm).element(1)
!pcc     j_gem = .grad_info_tmp.ex_gem(iterm).element(2)
!pcc     !!! debug
!pcc!     stdout.show("i_gem  =", i_gem)
!pcc!     stdout.show("j_gem  =", j_gem)
!pcc     !!!
!pcc     if (i_gem /= j_gem) then
!pcc        n_ex_gem = 2
!pcc     else
!pcc        n_ex_gem = 1
!pcc     end
!pcc     gg(1:n_ex_gem) = .grad_info_tmp.ex_gem(iterm).element(1:n_ex_gem)
!pcc     n_ex_gem = n_ex_gem+1
!pcc     gg(n_ex_gem) = gem
!pcc     ! n_ex_gem = number of geminals to be excluded
!pcc     ! ng = number of geminals in the reduced PBG
!pcc     ng = .n_geminals - n_ex_gem
!pcc     if (ng < 0) then
!pcc        stdout.text("Error in calc_new_red_overlap:")
!pcc        stdout.text("the number of geminals to be excluded") 
!pcc        stdout.text("is larger than the size of the PBT set.")
!pcc        stop
!pcc     end
!pcc     check_nb_gem = (ng /= 0)
!pcc     ! prepare block indices to be excluded
!pcc     ww(1:2) = .grad_info_tmp.ex_blk(iterm).element(1:2)
!pcc     idum = 0
!pcc     n_ex_blk = 0
!pcc     do k=1,2
!pcc        ww(k) = ww(k) - .n_1D_blocks
!pcc        if (ww(k) > 0 AND ww(k) /= idum) then
!pcc           idum = ww(k)
!pcc           n_ex_blk = n_ex_blk + 1
!pcc           bb(n_ex_blk) = ww(k)
!pcc        end
!pcc     end
!pcc!     n_ex_blk = 0
!pcc!     ww = .grad_info_tmp.ex_blk(iterm).element
!pcc!     do k=1,2
!pcc!        ww(k) = ww(k)-.n_1D_blocks
!pcc!        if (ww(k) > 0) then
!pcc!           n_ex_blk = n_ex_blk+1
!pcc!           bb(n_ex_blk) = ww(k)
!pcc!        end
!pcc!     end
!pcc     if (present(blk)  AND  blk > .n_1D_blocks) then
!pcc        blk_add = blk - .n_1D_blocks
!pcc        n_ex_blk = n_ex_blk + 1
!pcc        bb(n_ex_blk) = blk_add
!pcc     end
!pcc     ! n_ex_blk = number of 2D blocks to be excluded
!pcc     ! nb = number of 2D blocks in the reduced PBG
!pcc     nb = .n_blocks - n_ex_blk
!pcc     !!! debug
!pcc!     stdout.show("number of geminals in the reduced PBG (ng)  =", ng)
!pcc!     stdout.show("excluded geminals (gg)  =", gg(1:n_ex_gem))
!pcc!     stdout.show("number of 2D blocks in the reduced PBG (nb) =", nb)
!pcc!     stdout.show("excluded 2D blocks (bb) =", bb(1:n_ex_blk))
!pcc     !!!
!pcc     ! compute the reduced overlap
!pcc     if (check_nb_gem AND n_ex_blk > 0) then
!pcc        ! prepare the reduced PBG and compute the reduced overlap
!pcc        .prep_red_pbg_gg_bb(red_pbg, gg, n_ex_gem, bb, n_ex_blk, problem)
!pcc        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!pcc!        if ((NOT problem) AND ((.first_block == 0) OR (nb >= ng))) then
!pcc           red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
!pcc           red_pbg.calc_overlap_integral(red_overlap,FALSE)
!pcc        else
!pcc           red_overlap = ZERO
!pcc        end
!pcc     else if (check_nb_gem) then
!pcc        ! prepare the reduced PBG and compute the reduced overlap
!pcc        !!! debug
!pcc!        stdout.show("excluded geminals", gg(1:n_ex_gem))
!pcc        !!!
!pcc        .prep_red_pbg_gg(red_pbg, gg, n_ex_gem)
!pcc        red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
!pcc        red_pbg.calc_overlap_integral(red_overlap,FALSE)
!pcc     else
!pcc        red_overlap = ONE
!pcc     end
!pcc     
!pcc   end
! de

!pcc   create_2rdm_grad_info_tmp(nb_terms) ::: leaky
!pcc   ! create temporary object employed to save the information, about
!pcc   ! the 2RDM elements, required to compute the energy gradient with
!pcc   ! respect to the block coefficients
!pcc     nb_terms :: INT, IN
!pcc     n_gb :: INT
!pcc     n_gd2_ang :: INT
!pcc     !!!
!pcc     !!! DEBUG
!pcc!     stdout.text(" ")
!pcc!     stdout.text("Enter subroutine create_2rdm_grad_info_tmp")
!pcc     !!!
!pcc
!pcc     ! maximum number of geminals and blocks 
!pcc     ! excluded in the calculation of the reduced overlap 
!pcc     ! for a given term of a 2RDM element
!pcc     n_gb = 2
!pcc
!pcc     ! set number of terms
!pcc     .grad_info_tmp.nb_terms = nb_terms
!pcc     ! create vectors of products of coefficients,
!pcc     ! of reduced overlaps and of binary variables
!pcc     ! with additional info. about the product of 
!pcc     ! coefficients
!pcc     .grad_info_tmp.coef_prod.create(nb_terms)
!pcc     .grad_info_tmp.red_ov.create(nb_terms)
!pcc     .grad_info_tmp.all_pairs.create(nb_terms)
!pcc     ! create vectors of vectors of indices
!pcc     ! of excluded geminals, excluded blocks
!pcc     ! and multiplication factors
!pcc     .grad_info_tmp.ex_gem.create(nb_terms,n_gb)
!pcc     .grad_info_tmp.ex_blk.create(nb_terms,n_gb)
!pcc     .grad_info_tmp.factor.create(nb_terms,n_gb)
!pcc
!pcc     !!!
!pcc     if (.n_2D_3typ_blocks > 0) then
!pcc        ! maximum number of GD2 angles present
!pcc        ! in a given term of a 2RDM element
!pcc        n_gd2_ang = 2
!pcc
!pcc        ! maximum number of terms depending on GD2 angles
!pcc        .grad_info_tmp.nb_GD2_terms = nb_terms
!pcc
!pcc!        ! create vectors of term indices and number of GD2 angles
!pcc!        .grad_info_tmp.GD2_terms.create(nb_terms)
!pcc!        .grad_info_tmp.nb_GD2_ang.create(nb_terms)
!pcc
!pcc        ! create vectors of GD2 term indices and 
!pcc        ! products of coefficients 
!pcc        .grad_info_tmp.GD2_terms.create(nb_terms)
!pcc        .grad_info_tmp.GD2_cpr.create(nb_terms)
!pcc
!pcc        ! create vectors of vectors of GD2 block indices 
!pcc        ! and case numbers
!pcc        .grad_info_tmp.GD2_blk.create(nb_terms,n_gd2_ang)
!pcc        .grad_info_tmp.GD2_cas.create(nb_terms,n_gd2_ang)
!pcc     else
!pcc        .grad_info_tmp.nb_GD2_terms = 0
!pcc     end
!pcc     !!!
!pcc
!pcc   end

! davide - 10/03/2020
!pcc   save_2rdm_grad_info(rdm2_type, irdm, nt, terms, allpairs_arg, nt_gd2, gd2_terms) ::: leaky
!pcc   ! save information about the 2rdm element "irdm"
!pcc   ! (this info. will be used in the calculation 
!pcc   ! of the energy gradient)
!pcc     rdm2_type :: STR, IN
!pcc     irdm, nt :: INT, IN
!pcc     terms :: VEC{INT}, IN
!pcc     allpairs_arg :: BIN, IN, optional
!pcc     nt_gd2 :: INT, IN, optional
!pcc     gd2_terms ::  VEC{INT}, IN, optional
!pcc     allpairs :: BIN
!pcc     ngbf :: INT
!pcc     j, k :: INT
!pcc     !!!
!pcc!     n_gd2_ang :: INT
!pcc     blk1, blk2 :: INT
!pcc     !!!
!pcc     !!! debug
!pcc!     stdout.text(" ")
!pcc!     stdout.text("Entering subroutine save_2rdm_grad_info")
!pcc!     stdout.text("Argument variables:")
!pcc!     stdout.show("rdm2_type =", rdm2_type)
!pcc!     stdout.show("irdm      =", irdm)
!pcc!     stdout.show("nt        =", nt)
!pcc!     stdout.show("terms     =", terms(1:nt))
!pcc     !!!
!pcc
!pcc     ! this is for the possible creation of array "all_pairs"
!pcc     allpairs = FALSE
!pcc     if (present(allpairs_arg)) then
!pcc        allpairs = allpairs_arg
!pcc     end
!pcc
!pcc     ! dimension of vectors "ex_gem(:).element",
!pcc     ! "ex_blk(:).element" and "factor(:).element"
!pcc     ngbf = 2
!pcc
!pcc     select case (rdm2_type)
!pcc     case("ab")
!pcc        ! set number of terms
!pcc        .rdm_2_ab_grad_info(irdm).nb_terms = nt
!pcc        ! destroy vectors (if already created)
!pcc        .rdm_2_ab_grad_info(irdm).coef_prod.destroy
!pcc        .rdm_2_ab_grad_info(irdm).red_ov.destroy
!pcc        .rdm_2_ab_grad_info(irdm).ex_gem.destroy
!pcc        .rdm_2_ab_grad_info(irdm).ex_blk.destroy
!pcc        .rdm_2_ab_grad_info(irdm).factor.destroy
!pcc        ! create vectors and save information
!pcc        .rdm_2_ab_grad_info(irdm).coef_prod.create(nt)
!pcc        .rdm_2_ab_grad_info(irdm).red_ov.create(nt)
!pcc        .rdm_2_ab_grad_info(irdm).ex_gem.create(nt,ngbf)
!pcc        .rdm_2_ab_grad_info(irdm).ex_blk.create(nt,ngbf)
!pcc        .rdm_2_ab_grad_info(irdm).factor.create(nt,ngbf)
!pcc        do j=1,nt
!pcc           k = terms(j)
!pcc           ! product of coefficients
!pcc           .rdm_2_ab_grad_info(irdm).coef_prod(j) = .grad_info_tmp.coef_prod(k)
!pcc           ! reduced overlap
!pcc           .rdm_2_ab_grad_info(irdm).red_ov(j) = .grad_info_tmp.red_ov(k)
!pcc           ! indices of excluded geminals
!pcc           .rdm_2_ab_grad_info(irdm).ex_gem(j).element(1:ngbf) = .grad_info_tmp.ex_gem(k).element(1:ngbf)
!pcc           ! indices of excluded blocks
!pcc           .rdm_2_ab_grad_info(irdm).ex_blk(j).element(1:ngbf) = .grad_info_tmp.ex_blk(k).element(1:ngbf)
!pcc           ! multiplication factors
!pcc           .rdm_2_ab_grad_info(irdm).factor(j).element(1:ngbf) = .grad_info_tmp.factor(k).element(1:ngbf)
!pcc        end
!pcc        ! binaries with additional info. about the product of coefficients
!pcc        ! (creation and storing)
!pcc        .rdm_2_ab_grad_info(irdm).all_pairs.destroy
!pcc        if (allpairs) then
!pcc           .rdm_2_ab_grad_info(irdm).all_pairs.create(nt)
!pcc           do j=1,nt
!pcc              k = terms(j)
!pcc              .rdm_2_ab_grad_info(irdm).all_pairs(j) = .grad_info_tmp.all_pairs(k)
!pcc           end
!pcc        end
!pcc        !!!
!pcc        ! this is for energy gradient calculation w.r.t. GD2 angles
!pcc        if (present(gd2_terms)) then
!pcc           ! set number of GD2 terms
!pcc           .rdm_2_ab_grad_info(irdm).nb_GD2_terms = nt_gd2
!pcc           ! destroy vectors (if already created)
!pcc           .rdm_2_ab_grad_info(irdm).GD2_terms.destroy
!pcc           .rdm_2_ab_grad_info(irdm).GD2_cpr.destroy
!pcc           .rdm_2_ab_grad_info(irdm).GD2_blk.destroy
!pcc           .rdm_2_ab_grad_info(irdm).GD2_cas.destroy
!pcc           ! create vectors and save information
!pcc           .rdm_2_ab_grad_info(irdm).GD2_terms.create(nt_gd2)
!pcc           .rdm_2_ab_grad_info(irdm).GD2_cpr.create(nt_gd2)
!pcc           .rdm_2_ab_grad_info(irdm).GD2_blk.create(nt_gd2)
!pcc           .rdm_2_ab_grad_info(irdm).GD2_cas.create(nt_gd2)
!pcc           ! indices of GD2 terms
!pcc           k = 0
!pcc           do j=1,nt
!pcc              if ( any(gd2_terms(1:nt_gd2) == terms(j)) ) then
!pcc                 k = k+1
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_terms(k) = j
!pcc              end
!pcc           end
!pcc           ! products of coefficients, GD2 block indices and case numbers
!pcc           do j=1,nt_gd2
!pcc              k = gd2_terms(j)
!pcc              .rdm_2_ab_grad_info(irdm).GD2_cpr(j) = .grad_info_tmp.GD2_cpr(k)
!pcc              !
!pcc              blk1 = .grad_info_tmp.GD2_blk(k).element(1)
!pcc              blk2 = .grad_info_tmp.GD2_blk(k).element(2)
!pcc              if (blk1 == blk2) then
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element.create(1)
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element.create(1)
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element(1) = blk1
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
!pcc              else
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element.create(2)
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element.create(2)
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element(1) = blk1
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element(2) = blk2
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
!pcc                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element(2) = .grad_info_tmp.GD2_cas(k).element(2)
!pcc              end
!pcc           end
!pcc        else
!pcc           .rdm_2_ab_grad_info(irdm).nb_GD2_terms = 0
!pcc        end
!pcc        !!!
!pcc        !!! DEBUG
!pcc!        stdout.text("2RDM alpha/beta")
!pcc!        stdout.show("element",irdm)
!pcc!        stdout.show("indices",.rdm_2_ab(irdm).indices)
!pcc!        stdout.show("number of terms =",nt)
!pcc!        stdout.show("coef_prod",.rdm_2_ab(irdm).grad_info.coef_prod)
!pcc!        stdout.show("red_overlap",.rdm_2_ab(irdm).grad_info.red_ov)
!pcc!        stdout.text("excluded geminals")
!pcc!        do j=1,nt
!pcc!           stdout.show("geminals",.rdm_2_ab(irdm).grad_info.ex_gem(j).element)
!pcc!        end
!pcc!        stdout.text("excluded blocks")
!pcc!        do j=1,nt
!pcc!           stdout.show("blocks",.rdm_2_ab(irdm).grad_info.ex_blk(j).element)
!pcc!        end
!pcc!        stdout.text("multiplication factors")
!pcc!        do j=1,nt
!pcc!           stdout.show("factors",.rdm_2_ab(irdm).grad_info.factor(j).element)
!pcc!        end
!pcc!        stdout.text(" ")
!pcc        !!!
!pcc     case("aa")
!pcc        ! set number of terms
!pcc        .rdm_2_aa_grad_info(irdm).nb_terms = nt
!pcc        ! destroy vectors (if already created)
!pcc        .rdm_2_aa_grad_info(irdm).coef_prod.destroy
!pcc        .rdm_2_aa_grad_info(irdm).red_ov.destroy
!pcc        .rdm_2_aa_grad_info(irdm).ex_gem.destroy
!pcc        .rdm_2_aa_grad_info(irdm).ex_blk.destroy
!pcc        .rdm_2_aa_grad_info(irdm).factor.destroy
!pcc        ! create vectors and save information
!pcc        .rdm_2_aa_grad_info(irdm).coef_prod.create(nt)
!pcc        .rdm_2_aa_grad_info(irdm).red_ov.create(nt)
!pcc        .rdm_2_aa_grad_info(irdm).ex_gem.create(nt,ngbf)
!pcc        .rdm_2_aa_grad_info(irdm).ex_blk.create(nt,ngbf)
!pcc        .rdm_2_aa_grad_info(irdm).factor.create(nt,ngbf)
!pcc        do j=1,nt
!pcc           k = terms(j)
!pcc           ! product of coefficients
!pcc           .rdm_2_aa_grad_info(irdm).coef_prod(j) = .grad_info_tmp.coef_prod(k)
!pcc           ! reduced overlap
!pcc           .rdm_2_aa_grad_info(irdm).red_ov(j) = .grad_info_tmp.red_ov(k)
!pcc           ! indices of excluded geminals
!pcc           .rdm_2_aa_grad_info(irdm).ex_gem(j).element(1:ngbf) = .grad_info_tmp.ex_gem(k).element(1:ngbf)
!pcc           ! indices of excluded blocks
!pcc           .rdm_2_aa_grad_info(irdm).ex_blk(j).element(1:ngbf) = .grad_info_tmp.ex_blk(k).element(1:ngbf)
!pcc           ! multiplication factors
!pcc           .rdm_2_aa_grad_info(irdm).factor(j).element(1:ngbf) = .grad_info_tmp.factor(k).element(1:ngbf)
!pcc        end
!pcc        ! binaries with additional info. about the product of coefficients
!pcc        ! (creation and storing)
!pcc        .rdm_2_aa_grad_info(irdm).all_pairs.destroy
!pcc        if (allpairs) then
!pcc           .rdm_2_aa_grad_info(irdm).all_pairs.create(nt)
!pcc           do j=1,nt
!pcc              k = terms(j)
!pcc              .rdm_2_aa_grad_info(irdm).all_pairs(j) = .grad_info_tmp.all_pairs(k)
!pcc           end
!pcc        end
!pcc        !!!
!pcc        ! this is for energy gradient calculation w.r.t. GD2 angles
!pcc        if (present(gd2_terms)) then
!pcc           ! set number of GD2 terms
!pcc           .rdm_2_aa_grad_info(irdm).nb_GD2_terms = nt_gd2
!pcc           ! destroy vectors (if already created)
!pcc           .rdm_2_aa_grad_info(irdm).GD2_terms.destroy
!pcc           .rdm_2_aa_grad_info(irdm).GD2_cpr.destroy
!pcc           .rdm_2_aa_grad_info(irdm).GD2_blk.destroy
!pcc           .rdm_2_aa_grad_info(irdm).GD2_cas.destroy
!pcc           ! create vectors and save information
!pcc           .rdm_2_aa_grad_info(irdm).GD2_terms.create(nt_gd2)
!pcc           .rdm_2_aa_grad_info(irdm).GD2_cpr.create(nt_gd2)
!pcc           .rdm_2_aa_grad_info(irdm).GD2_blk.create(nt_gd2)
!pcc           .rdm_2_aa_grad_info(irdm).GD2_cas.create(nt_gd2)
!pcc           ! indices of GD2 terms
!pcc           k = 0
!pcc           do j=1,nt
!pcc              if ( any(gd2_terms(1:nt_gd2) == terms(j)) ) then
!pcc                 k = k+1
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_terms(k) = j
!pcc              end
!pcc           end
!pcc           ! GD2 block indices and case numbers
!pcc           do j=1,nt_gd2
!pcc              k = gd2_terms(j)
!pcc              .rdm_2_aa_grad_info(irdm).GD2_cpr(j) = .grad_info_tmp.GD2_cpr(k)
!pcc              !
!pcc              blk1 = .grad_info_tmp.GD2_blk(k).element(1)
!pcc              blk2 = .grad_info_tmp.GD2_blk(k).element(2)
!pcc              if (blk1 == blk2) then
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element.create(1)
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element.create(1)
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element(1) = blk1
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
!pcc              else
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element.create(2)
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element.create(2)
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element(1) = blk1
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element(2) = blk2
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
!pcc                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element(2) = .grad_info_tmp.GD2_cas(k).element(2)
!pcc              end
!pcc           end
!pcc        else
!pcc           .rdm_2_aa_grad_info(irdm).nb_GD2_terms = 0
!pcc        end
!pcc        !!!
!pcc        !!! DEBUG
!pcc!        stdout.text("2RDM alpha/alpha")
!pcc!        stdout.show("element",irdm)
!pcc!        stdout.show("indices",.rdm_2_aa(irdm).indices)
!pcc!        stdout.show("number of terms =",nt)
!pcc!        stdout.show("coef_prod",.rdm_2_aa(irdm).grad_info.coef_prod)
!pcc!        stdout.show("red_overlap",.rdm_2_aa(irdm).grad_info.red_ov)
!pcc!        stdout.text("excluded geminals")
!pcc!        do j=1,nt
!pcc!           stdout.show("geminals",.rdm_2_aa(irdm).grad_info.ex_gem(j).element)
!pcc!        end
!pcc!        stdout.text("excluded blocks")
!pcc!        do j=1,nt
!pcc!           stdout.show("blocks",.rdm_2_aa(irdm).grad_info.ex_blk(j).element)
!pcc!        end
!pcc!        stdout.text("multiplication factors")
!pcc!        do j=1,nt
!pcc!           stdout.show("factors",.rdm_2_aa(irdm).grad_info.factor(j).element)
!pcc!        end
!pcc!        stdout.text(" ")
!pcc        !!!
!pcc     case("bb")
!pcc        ! set number of terms
!pcc        .rdm_2_bb_grad_info(irdm).nb_terms = nt
!pcc        ! destroy vectors (if already created)
!pcc        .rdm_2_bb_grad_info(irdm).coef_prod.destroy
!pcc        .rdm_2_bb_grad_info(irdm).red_ov.destroy
!pcc        .rdm_2_bb_grad_info(irdm).ex_gem.destroy
!pcc        .rdm_2_bb_grad_info(irdm).ex_blk.destroy
!pcc        .rdm_2_bb_grad_info(irdm).factor.destroy
!pcc        ! create vectors and save information
!pcc        .rdm_2_bb_grad_info(irdm).coef_prod.create(nt)
!pcc        .rdm_2_bb_grad_info(irdm).red_ov.create(nt)
!pcc        .rdm_2_bb_grad_info(irdm).ex_gem.create(nt,ngbf)
!pcc        .rdm_2_bb_grad_info(irdm).ex_blk.create(nt,ngbf)
!pcc        .rdm_2_bb_grad_info(irdm).factor.create(nt,ngbf)
!pcc        do j=1,nt
!pcc           k = terms(j)
!pcc           ! product of coefficients
!pcc           .rdm_2_bb_grad_info(irdm).coef_prod(j) = .grad_info_tmp.coef_prod(k)
!pcc           ! reduced overlap
!pcc           .rdm_2_bb_grad_info(irdm).red_ov(j) = .grad_info_tmp.red_ov(k)
!pcc           ! indices of excluded geminals
!pcc           .rdm_2_bb_grad_info(irdm).ex_gem(j).element(1:ngbf) = .grad_info_tmp.ex_gem(k).element(1:ngbf)
!pcc           ! indices of excluded blocks
!pcc           .rdm_2_bb_grad_info(irdm).ex_blk(j).element(1:ngbf) = .grad_info_tmp.ex_blk(k).element(1:ngbf)
!pcc           ! multiplication factors
!pcc           .rdm_2_bb_grad_info(irdm).factor(j).element(1:ngbf) = .grad_info_tmp.factor(k).element(1:ngbf)
!pcc        end
!pcc        ! binaries with additional info. about the product of coefficients
!pcc        ! (creation and storing)
!pcc        .rdm_2_bb_grad_info(irdm).all_pairs.destroy
!pcc        if (allpairs) then
!pcc           .rdm_2_bb_grad_info(irdm).all_pairs.create(nt)
!pcc           do j=1,nt
!pcc              k = terms(j)
!pcc              .rdm_2_bb_grad_info(irdm).all_pairs(j) = .grad_info_tmp.all_pairs(k)
!pcc           end
!pcc        end
!pcc        !!!
!pcc        ! this is for energy gradient calculation w.r.t. GD2 angles
!pcc        if (present(gd2_terms)) then
!pcc           ! set number of GD2 terms
!pcc           .rdm_2_bb_grad_info(irdm).nb_GD2_terms = nt_gd2
!pcc           ! destroy vectors (if already created)
!pcc           .rdm_2_bb_grad_info(irdm).GD2_terms.destroy
!pcc           .rdm_2_bb_grad_info(irdm).GD2_cpr.destroy
!pcc           .rdm_2_bb_grad_info(irdm).GD2_blk.destroy
!pcc           .rdm_2_bb_grad_info(irdm).GD2_cas.destroy
!pcc           ! create vectors and save information
!pcc           .rdm_2_bb_grad_info(irdm).GD2_terms.create(nt_gd2)
!pcc           .rdm_2_bb_grad_info(irdm).GD2_cpr.create(nt_gd2)
!pcc           .rdm_2_bb_grad_info(irdm).GD2_blk.create(nt_gd2)
!pcc           .rdm_2_bb_grad_info(irdm).GD2_cas.create(nt_gd2)
!pcc           ! indices of GD2 terms
!pcc           k = 0
!pcc           do j=1,nt
!pcc              if ( any(gd2_terms(1:nt_gd2) == terms(j)) ) then
!pcc                 k = k+1
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_terms(k) = j
!pcc              end
!pcc           end
!pcc           ! GD2 block indices and case numbers
!pcc           do j=1,nt_gd2
!pcc              k = gd2_terms(j)
!pcc              .rdm_2_bb_grad_info(irdm).GD2_cpr(j) = .grad_info_tmp.GD2_cpr(k)
!pcc              !
!pcc              blk1 = .grad_info_tmp.GD2_blk(k).element(1)
!pcc              blk2 = .grad_info_tmp.GD2_blk(k).element(2)
!pcc              if (blk1 == blk2) then
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element.create(1)
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element.create(1)
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element(1) = blk1
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
!pcc              else
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element.create(2)
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element.create(2)
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element(1) = blk1
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element(2) = blk2
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
!pcc                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element(2) = .grad_info_tmp.GD2_cas(k).element(2)
!pcc              end
!pcc           end
!pcc        else
!pcc           .rdm_2_bb_grad_info(irdm).nb_GD2_terms = 0
!pcc        end
!pcc        !!!
!pcc        !!! DEBUG
!pcc!        stdout.text("2RDM beta/beta")
!pcc!        stdout.show("element",irdm)
!pcc!        stdout.show("indices",.rdm_2_bb(irdm).indices)
!pcc!        stdout.show("number of terms =",nt)
!pcc!        stdout.show("coef_prod",.rdm_2_bb(irdm).grad_info.coef_prod)
!pcc!        stdout.show("red_overlap",.rdm_2_bb(irdm).grad_info.red_ov)
!pcc!        stdout.text("excluded geminals")
!pcc!        do j=1,nt
!pcc!           stdout.show("geminals",.rdm_2_bb(irdm).grad_info.ex_gem(j).element)
!pcc!        end
!pcc!        stdout.text("excluded blocks")
!pcc!        do j=1,nt
!pcc!           stdout.show("blocks",.rdm_2_bb(irdm).grad_info.ex_blk(j).element)
!pcc!        end
!pcc!        stdout.text("multiplication factors")
!pcc!        do j=1,nt
!pcc!           stdout.show("factors",.rdm_2_bb(irdm).grad_info.factor(j).element)
!pcc!        end
!pcc!        stdout.text(" ")
!pcc        !!!
!pcc     case default
!pcc        stdout.text("Error in routine save_2rdm_grad_info:") 
!pcc        stdout.text("unknown string to select the 2RDM part.")
!pcc        stop
!pcc     end select
!pcc
!pcc   end
! de



!  ================
!  Integral methods
!  ================

   make_pauli_trace(bra_subset,ket_subset)
   ! make trace of a product of blocks
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks, n_block1, j :: INT
     pauli_trace :: REAL
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     n_block1=bra_subset.vec(1).n_1D_blocks
     pauli_trace = ZERO
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     select case (n_gem)
       case(1);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
           end
         end
         pauli_trace = 2*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
         end
       case(2);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
           end
         end
         pauli_trace = 8*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
         end
       case(3);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
           end
         end
         pauli_trace = 48*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
         end
       case(4);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
           end
         end
         pauli_trace = 384*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
         end
       case default ;
     end
   !debug stdout.show("trace of product of bra and ket geminals :",pauli_trace)
   end
   
   make_ham_expect_val(ham, wrt_arg)
   ! make hamiltonian 
     ham :: REAL, OUT
     wrt_arg :: BIN, IN, optional
     wrt :: BIN
     v :: MAT4{REAL}*
     r,i_1,j_1,i_2,j_2 :: INT
     eri_archive :: ARCHIVE

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     eri_archive.set(.name,"h_integrals")
     v.create(.mat_size,.mat_size,.mat_size,.mat_size)
     eri_archive.read(v)

     ham = ZERO

     do r=1,.nonzero_terms_ab
        i_1 = .rdm_2_ab(r).indices(1)
        j_1 = .rdm_2_ab(r).indices(2)
        i_2 = .rdm_2_ab(r).indices(3)
        j_2 = .rdm_2_ab(r).indices(4)
        ham = ham + .rdm_2_ab(r).coefficient*v(i_1,j_1,i_2,j_2)
     end

     do r=1,.nonzero_terms_aa
        i_1 = .rdm_2_aa(r).indices(1)
        j_1 = .rdm_2_aa(r).indices(2)
        i_2 = .rdm_2_aa(r).indices(3)
        j_2 = .rdm_2_aa(r).indices(4)
        ham = ham + .rdm_2_aa(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
     end

     do r=1,.nonzero_terms_bb
        i_1 = .rdm_2_bb(r).indices(1)
        j_1 = .rdm_2_bb(r).indices(2)
        i_2 = .rdm_2_bb(r).indices(3)
        j_2 = .rdm_2_bb(r).indices(4)
        ham = ham + .rdm_2_bb(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
     end

     ! save the electronic energy
     .electronic_energy = ham

     v.destroy

     if (wrt) then
        stdout.text(" ")
        stdout.show("Electronic energy",ham)
        stdout.show("Nuclear repulsion energy",.nuclear_repulsion_energy)
        stdout.show("Total energy",ham+.nuclear_repulsion_energy)
        stdout.text(" ")
     end

   end

end
