!-------------------------------------------------------------------------------
!
! PAULI_BLOCK_GEMINALS
!
! Copyright (C) Patrick Cassam-Chenai and Thomas Perez, 2018
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module PAULI_BLOCK_GEMINALS

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

   !!!
!   saved_self :: PAULI_BLOCK_GEMINALS* DEFAULT_NULL
   pbg_saved :: PAULI_BLOCK_GEMINALS*
   !!!

contains

!===============================================================================
!                             Create and Destroy Routines
!===============================================================================

   create ::: leaky
   ! Create a pauli_block_geminals
      self :: PTR
      nullify(self)
      allocate(self)
   !   .nullify_ptr_part
   end

   create(vec,n_geminals) ::: leaky
   ! Create a set of PBT
     vec :: VEC{PAULI_BLOCK_TENSOR}*
     n_geminals :: INT

     nullify(vec)
     allocate(vec(n_geminals))

   end


   create(vec,n) ::: leaky
   ! Create a vector of 2RDM non zero elements
     vec :: VEC{PAULI_BLOCK_2RDM_ELT}*
     n :: INT

     nullify(vec)
     allocate(vec(n))

   end

   create(vec,n) ::: leaky
   ! Create a vector of objects with information to compute the
   ! derivative of the 2RDM
     vec :: VEC{PAULI_BLOCK_2RDM_GRAD_INFO}*
     n :: INT

     nullify(vec)
     allocate(vec(n))

   end

   create(gradient,n) ::: leaky
   ! Create a vector of energy gradient elements
     gradient :: VEC{ENERGY_GRADIENT_ELT}*
     n :: INT

     nullify(gradient)
     allocate(gradient(n))

   end

   destroy(gradient) ::: leaky
   ! Destroy a vector of energy gradient elements
     gradient :: VEC{ENERGY_GRADIENT_ELT}*

     deallocate(gradient)
     nullify(gradient)

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   destroy_ptr_part ::: leaky
   ! destroy the pointer parts of a PAULI_BLOCK_GEMINALS object
     i,n :: INT
     new_item :: VEC_INT_LIST*
     
     .nonzero_coef_ind.destroy
     .nonzero_coef_prod.destroy
     new_item=>.int_term_ind
     do
       if (NOT associated(new_item)) exit
       .int_term_ind.item.destroy
       new_item=>.int_term_ind.next
       deallocate(.int_term_ind)
       .int_term_ind=>new_item
     end
     nullify(new_item)
     .nonzero_1ortho_ind.destroy
     .rdm_1.destroy
     if(associated(.rdm_2_ab)) then 
       deallocate(.rdm_2_ab)
     end
     if(associated(.rdm_2_aa)) then 
       deallocate(.rdm_2_aa)
     end
     if(associated(.rdm_2_bb)) then 
       deallocate(.rdm_2_bb)
     end
     .orbital_block_mapping.destroy
     .block_types.destroy
     .block_1orthos.destroy

   end

!  ===========
!  Set methods
!  ===========

      
! davide: 16-11-2018
   set_defaults(n_el,n_bf,mol_name, nuclear_repulsion_energy)
   ! set defaults for n_geminals, n_blocks, mat_size, 
   ! n_1D_blocks, bra_is_ket, spin_restricted, mol_name
   n_el, n_bf :: INT, IN
   mol_name :: STR, IN
   nuclear_repulsion_energy :: REAL, IN
   nn, dif :: INT
   ms :: INT
     
     ! set nuclear_repulsion_energy
     .nuclear_repulsion_energy=nuclear_repulsion_energy
     ! set number of electrons
     .n_el = n_el
     ! set number of basis functions
     .n_bf = n_bf
     ! set n_geminals
     .n_geminals = (n_el+1)/2
     ! set n_gem_singlet
     ms = .spin_multi
     .n_gem_singlet = (n_el-ms+1)/2 
     ! set n_blocks
     .n_blocks = .n_geminals+(n_bf-.n_geminals+1)/2
     ! set mat_size (PBT size)
     nn = (n_el/2)*2
     if (nn /= n_el) then
        .mat_size = n_bf+1
     else
        .mat_size = n_bf
     end
!     ! set n_1D_blocks (number of 1-orthogonal blocks in each PBT)
!     dif = n_bf-.n_geminals
!     nn = (dif/2)*2
!     if (nn /= dif) then
!       .n_1D_blocks = .n_geminals+1
!     else
!       .n_1D_blocks = .n_geminals
!     end
     !
     ! set n_1D_blocks (number of 1-orthogonal blocks in each PBT)
     dif = .mat_size-.n_gem_singlet
     nn = (dif/2)*2
     if (nn /= dif) then
       .n_1D_blocks = .n_gem_singlet+1
     else
       .n_1D_blocks = .n_gem_singlet
     end
     !
     .n_2D_blocks = .n_blocks-.n_1D_blocks
     .n_2D_3typ_blocks = 0
     .n_2D_4typ_blocks = .n_blocks-.n_1D_blocks
     !
     ! set first_block
!     .first_block=0
     if (.n_1D_blocks > 0) then
       .first_block = 0
     else
       .first_block = 1
     end
     !
     .gen_block=FALSE
     ! set bra_is_ket (if bra set is equal to ket set)
     .bra_is_ket = TRUE
     ! set spin_restricted
     .spin_restricted = TRUE
     ! set mol_name
     .name = mol_name
     ! set guess_type
     .guess_type = "hf"
     ! set random_scaling
     .random_scaling = 0.01d0
     !
     .only_4typ = FALSE

   end
! de

   set_matrix_form
   ! make matrix form from coef and block types for bra_set and ket_set if different
     .make_matrix_form(.bra_set)
     if (NOT .bra_is_ket) then
       .make_matrix_form(.ket_set)
     end
   end
      

!  ===============
!  INPUT Routines
!  ===============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
 !      case ("do_overlap              "); .do_overlap
 !      case ("do_hamiltonian          "); .do_hamiltonian
       case ("junk=                   "); .read_junk
 !      case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       case ("n_geminals=             "); .read_n_geminals
!       case ("n_blocks=               "); .read_n_blocks
       case ("bra_is_ket=             "); .read_bra_is_ket
       case ("bra_set=                "); .read_bra_set
       case ("ket_set=                "); .read_ket_set
       case ("readin_mos=             "); .read_readin_mos
       case ("guess_type=             "); .read_guess_type
       case ("gd2_info=               "); .read_GD2_info
       case ("make_integrals=         "); .read_make_integrals
       case ("add_core=               "); .read_add_core
 !      case ("gen_block=              "); .read_gen_block
       case ("set_matrix_form         "); .set_matrix_form
       case ("spin_restricted=        "); .read_spin_restricted
       case ("block_partition=        "); .read_block_partition
 !      case ("n_1D_blocks=            "); .read_n_1D_blocks
 !      case ("n_2D_3typ_blocks=       "); .read_n_2D_3typ_blocks
 !      case ("n_2D_4typ_blocks=       "); .read_n_2D_4typ_blocks
       case ("n_singlet_geminals=     "); .read_n_singlet_geminals
       case ("random_scaling=         "); .read_random_scaling
       case ("calc_gradient=          "); .read_calc_gradient
       case ("opt_gd2_angles=         "); .read_opt_GD2_angles
       !!!
       case ("only_3typ=              "); .read_only_3typ
       case ("only_4typ=              "); .read_only_4typ
       !!!
       !!! to debug code
       case ("debug=                  "); .read_debug
       !!!
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_make_integrals
   ! Read  make_integrals flag
     stdin.read(.make_integrals)
   end

   read_add_core
   ! Read  add_core flag
     stdin.read(.add_core)
   end

   read_n_geminals
   ! Read number of geminals
   !  self :: PTR
     n_geminals :: INT
     stdin.read(n_geminals)
     .n_geminals=n_geminals
   end

   read_bra_is_ket
   ! Read TRUE if the bra and the ket have the same geminals, else read FALSE
   !  self :: PTR
     bra_is_ket :: BIN
     stdin.read(bra_is_ket)
     .bra_is_ket=bra_is_ket
   end 

   read_bra_set ::: leaky
   ! Read all the blocks of the geminals of the bra
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT

     ! check if guess_type is "readin";
     ! if not, stop the program execution
     if (.guess_type /= "readin") then
        stdout.text(" ")
        stdout.text("provide keyword guess_type= readin, before the input bra_set")
        stop
     end
!     ! check if block partition has already been read;
!     ! if not, call routine "read_block_partiton"
!     if (NOT .block_partition_read) then
!        .read_block_partition 
!     end
!     ! check if GD2 angles have already been read;
!     ! if not, call routine "read_GD2_info"
!     if (NOT .GD2_info_read) then
!        .read_GD2_info
!     end
     !
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.bra_set.vec(.n_geminals))
     .bra_set.set_size=.n_geminals
     .bra_set.set_size_sing=.n_gem_singlet
     .bra_set.n_blocks=.n_blocks
     .bra_set.n_1D_blocks=.n_1D_blocks
     .bra_set.n_2D_blocks=.n_2D_blocks
     .bra_set.n_2D_3typ_blocks=.n_2D_3typ_blocks
     .bra_set.n_2D_4typ_blocks=.n_2D_4typ_blocks
     .bra_set.spin_restricted=.spin_restricted
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       .bra_set.vec(i).block_type.create(.n_blocks)
       .bra_set.vec(i).block_dim.create(.n_blocks)
       .bra_set.vec(i).block_dim=2
       .bra_set.vec(i).coef.create(.n_blocks)
       .bra_set.vec(i).block_type=blocks
       .bra_set.vec(i).coef=coeffs
       ! check the number of 1D blocks
       counter=0
       do j=1,.n_blocks
         if(blocks(j)=='ID1') then
           .bra_set.vec(i).block_dim(j)=1
           counter=counter+1
         end
       end
       if (counter /= .n_1D_blocks) then
       !debug stdout.text("wrong nb of 1D blocks")
         stop
       end
       !
       .bra_set.vec(i).n_1D_blocks=.n_1D_blocks 
       .bra_set.vec(i).n_2D_blocks=.n_2D_blocks
       .bra_set.vec(i).n_2D_3typ_blocks = .n_2D_3typ_blocks
       .bra_set.vec(i).n_2D_4typ_blocks = .n_2D_4typ_blocks
     end
     .make_type_numbers(.bra_set)
!     ! write the bra set to the output file
!     stdout.text(" ")
!     stdout.text("Bra set:")
!     .write_pbt_set(.bra_set)
   end

   read_ket_set ::: leaky
   ! Read all the blocks of the geminals of the ket
   !  self :: PTR
     blocks :: VEC{STR}*
     coeffs :: VEC{REAL}*
     i,j,counter :: INT

     ! check if guess_type is "readin";
     ! if not, stop the program execution
     if (.guess_type /= "readin") then
        stdout.text(" ")
        stdout.text("provide keyword guess_type= readin, before the input ket_set")
        stop
     end
!     ! check if block partition has already been read;
!     ! if not, call routine "read_block_partiton"
!     if (NOT .block_partition_read) then
!        .read_block_partition 
!     end
!     ! check if GD2 angles have already been read;
!     ! if not, call routine "read_GD2_info"
!     if (NOT .GD2_info_read) then
!        .read_GD2_info
!     end
     !
     blocks.create(.n_blocks)
     coeffs.create(.n_blocks)
     allocate(.ket_set.vec(.n_geminals))
     .ket_set.set_size=.n_geminals
     .ket_set.set_size_sing=.n_gem_singlet
     .ket_set.n_blocks=.n_blocks
     .ket_set.n_1D_blocks=.n_1D_blocks
     .ket_set.n_2D_blocks=.n_2D_blocks
     .ket_set.n_2D_3typ_blocks=.n_2D_3typ_blocks
     .ket_set.n_2D_4typ_blocks=.n_2D_4typ_blocks
     .ket_set.spin_restricted=.spin_restricted
     do i=1,.n_geminals
       stdin.read(blocks)
       stdin.read(coeffs)
       if (.bra_is_ket) then
       !debug stdout.text("WARNING: .bra_is_ket has been set to TRUE !")
       !debug stdout.show("For ket ", i)
       !debug stdout.text("read in information will be ignored")
       else
         .ket_set.vec(i).block_type.create(.n_blocks)
         .ket_set.vec(i).block_dim.create(.n_blocks)
         .ket_set.vec(i).block_dim=2
         .ket_set.vec(i).coef.create(.n_blocks)
         .ket_set.vec(i).block_type=blocks
         .ket_set.vec(i).coef=coeffs
         ! check the number of 1D blocks
         counter=0
         do j=1,.n_blocks
           if(blocks(j)=='ID1') then
             .ket_set.vec(i).block_dim(j)=1
             counter=counter+1
           end
         end
         if (counter /= .n_1D_blocks) then
         !debug stdout.text("wrong nb of 1D blocks")
           stop
         end
         !
         .ket_set.vec(i).n_1D_blocks=.n_1D_blocks 
         .ket_set.vec(i).n_2D_blocks=.n_2D_blocks 
         .ket_set.vec(i).n_2D_3typ_blocks = .n_2D_3typ_blocks
         .ket_set.vec(i).n_2D_4typ_blocks = .n_2D_4typ_blocks
       end
     end
     .make_type_numbers(.ket_set)
!     ! write the ket set to the output file
!     stdout.text(" ")
!     stdout.text("Ket set:")
!     .write_pbt_set(.ket_set)
   end

   read_guess_type
   ! Read  guess geminals type
     stdin.read(.guess_type)
     .guess_type.to_lower_case
     select case (.guess_type)
       case ("hf")
         stdout.text(" ")
         stdout.text("guess geminals will be singlet coupled canonical HF orbitals")
         stdout.text(" ")
       case ("pp")
         stdout.text(" ")
         stdout.text("guess geminals will be Perfect Paired orbitals (to be used with readin mos)")
         stdout.text(" ")
       case ("random")
         stdout.text(" ")
         stdout.text("guess geminals will be random")
         stdout.text(" ")
       case ("hf-random")
         stdout.text(" ")
         stdout.text("guess geminals will be mixed HF-random")
         stdout.text(" ")
       case ("readin")
       !  .readin_gems= TRUE
         stdout.text(" ")
         stdout.text("guess geminals will be read in")
         stdout.text(" ")
       case default
         DIE("unknown guess option: "//trim(.guess_type))
     end 
   end

   read_readin_mos
   ! Read yes if MO's are to be read in, else the flag is set to FALSE and scf orbitals
   ! are used
     readin_mos :: BIN
     stdin.read(readin_mos)
     .readin_mos=readin_mos
   end 

   read_GD2_info
   ! Read angles corresponding to GD2 matrices
     ENSURE(.GD2_info.created,"GD2 info does not exist")
     ENSURE(size(.GD2_info)==.n_2D_3typ_blocks,"size problem with GD2 info")
     angles :: VEC{REAL}*

     angles.create(.n_2D_3typ_blocks)
     stdin.read(angles)
     .GD2_info=angles
   end 

   read_spin_restricted
   ! Read TRUE if the spin-restricted approach is selected, else read FALSE
   !  self :: PTR
     spin_restricted :: BIN

     stdin.read(spin_restricted)
     .spin_restricted=spin_restricted

     ! in case of a spin unrestricted calculation,
     ! set to zero the (default) value for the number of
     ! spin restricted geminals
     if (NOT spin_restricted) then
        .n_gem_singlet = 0
     end

   end 

   read_block_partition ::: leaky
   ! Read number of 1-dimensional blocks, 2-dimensional blocks with 3 matrix types, 
   ! and 2-dimensional blocks with 4 matrix types in each geminal
   !  self :: PTR
     block_partition :: VEC{INT}(3)
     calc_size :: INT

     stdin.read(block_partition)
     .n_1D_blocks=block_partition(1)
     .n_2D_3typ_blocks=block_partition(2)
     .n_2D_4typ_blocks=block_partition(3)

     ! check if the block partition is consistent
     ! with mat_size 
     calc_size = block_partition(1) 
     calc_size = calc_size + sum(block_partition(2:3))*2 
     if (calc_size /= .mat_size) then
        stdout.text("The input block partition is not consistent")
        stdout.text("with the size of the Pauli Block Tensors")
        stop
     end

     if(.n_1D_blocks>0) then
       .first_block=0
     else
       .first_block=1
     end

     if(.n_2D_3typ_blocks>0) then
       .gen_block=TRUE
     else
       .gen_block=FALSE
     end
     .GD2_info.create(.n_2D_3typ_blocks)
     .GD2_info=THREEQUARTERS*PI !initialized GD2 as SZ
     
     .n_blocks=sum(block_partition)
     .n_2D_blocks=.n_blocks-.n_1D_blocks

!     ! set related flag variable to TRUE
!     .block_partition_read = TRUE

   end 

!   read_n_1D_blocks
!   ! Read number of 1-dimensional blocks in each geminal
!   !  self :: PTR
!     n_1D_blocks :: INT
!
!     stdin.read(n_1D_blocks)
!     .n_1D_blocks=n_1D_blocks
!     if(n_1D_blocks>0) then
!       .first_block=0
!     else
!       .first_block=1
!     end
!
!   end 
!
!   read_n_2D_3typ_blocks
!   ! Read number of 2-dimensional blocks with 3 matrix types in each geminal
!   !  self :: PTR
!     n_2D_3typ_blocks :: INT
!
!     stdin.read(n_2D_3typ_blocks)
!     .n_2D_3typ_blocks=n_2D_3typ_blocks
!     if(n_2D_3typ_blocks>0) then
!       .gen_block=TRUE
!     else
!       .gen_block=FALSE
!     end
!
!   end 
!
!   read_n_2D_4typ_blocks
!   ! Read number of 2-dimensional blocks with 4 matrix types in each geminal
!   !  self :: PTR
!     n_2D_4typ_blocks :: INT
!
!     stdin.read(n_2D_4typ_blocks)
!     .n_2D_4typ_blocks=n_2D_4typ_blocks
!
!   end 

   read_n_singlet_geminals
   ! Read number of singlet geminals
   !  self :: PTR
     n_singlet_geminals :: INT
     stdin.read(n_singlet_geminals)
     .n_gem_singlet=n_singlet_geminals
   end

   read_random_scaling
   ! Read scaling factor to build mixed 
   ! HF-random guess set of geminals
   !  self :: PTR
     random_scaling :: REAL
     stdin.read(random_scaling)
     .random_scaling = random_scaling
   end

   read_calc_gradient
   ! Read TRUE if the energy gradient with respect to the block
   ! coefficients has to be computed, else read FALSE
   !  self :: PTR
     calc_gradient :: BIN

     stdin.read(calc_gradient)
     .calc_gradient = calc_gradient

   end

   read_opt_GD2_angles
   ! Read TRUE if optimization of GD2 angles is requested
   !  self :: PTR
     opt_GD2_angles :: BIN

     stdin.read(opt_GD2_angles)
     .opt_GD2_angles = opt_GD2_angles

   end

   read_only_4typ
   ! Read TRUE if only 4-type blocks have to be included in the 2D
   ! part of geminals
   !  self :: PTR
     only_4typ :: BIN
     stdin.read(only_4typ)
     .only_4typ = only_4typ
   end 

   read_only_3typ
   ! Read TRUE if only 3-type blocks have to be included in the 2D
   ! part of geminals
   !  self :: PTR
     only_3typ :: BIN
     stdin.read(only_3typ)
     .only_3typ = only_3typ
   end 
!!!
   read_debug
   ! Read TRUE if debug mode has to be activated
   !  self :: PTR
     debug :: BIN
     stdin.read(debug)
     .debug = debug
   end 
!!!

!  ===============
!  other Routines
!  ===============

! davide 23-10-2019
   write_pbt_set(pbt_set)
   ! write Pauli Block Tensor (PBT) set 
   ! to the output file
     pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
     i :: INT

     stdout.text(" ")
     stdout.show("# 1D blocks =",pbt_set.n_1D_blocks)
     stdout.show("# 2D blocks =",pbt_set.n_2D_blocks)
     stdout.show("# 2D 3type blocks =",pbt_set.n_2D_3typ_blocks)
     stdout.show("# 2D 4type blocks =",pbt_set.n_2D_4typ_blocks)
!     stdout.show("# 2D 3type blocks(2) =",.n_2D_3typ_blocks)
!     stdout.show("# 2D 4type blocks(2) =",.n_2D_4typ_blocks)
     stdout.text(" ")
     !
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(pbt_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(pbt_set.vec(i).coef)
     end
     if (pbt_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end

   end
! de

   initialize_GD2 ::: leaky
   ! initialize GD2 diagonal elements
   i :: INT

     if (NOT .first_GD2_elt.created) then
        .first_GD2_elt.create(.n_2D_3typ_blocks)
     end
     if (NOT .second_GD2_elt.created) then
        .second_GD2_elt.create(.n_2D_3typ_blocks)
     end
     ! compute GD2 diagonal elements
     do i=1,.n_2D_3typ_blocks
       .first_GD2_elt(i) = sin(.GD2_info(i))*SQRT_2
       .second_GD2_elt(i) = cos(.GD2_info(i))*SQRT_2
     end

   end

   make_matrix_form(mat_set)
   ! make matrix form from coef and block types
     mat_set :: PAULI_BLOCK_TENSOR_SET
     i,j,last :: INT
     !
     do i=1,.n_geminals
       allocate(mat_set.vec(i).matrix_form(.mat_size,.mat_size))
       mat_set.vec(i).matrix_form=ZERO
       last=0
       do j=1,.n_blocks         
         select case (mat_set.vec(i).block_type(j))
           case ("ID1");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("ID2");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("SZ");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=-mat_set.vec(i).coef(j)
           case ("SX");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case ("ISY");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
             mat_set.vec(i).matrix_form(last,last-1)=-mat_set.vec(i).coef(j)
           case ("GD2");
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)*.first_GD2_elt(j-.n_1D_blocks)
             last=last+1
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)*.second_GD2_elt(j-.n_1D_blocks)
           case ("E11");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last-1)=mat_set.vec(i).coef(j)
           case ("E22");
             last=last+2
             mat_set.vec(i).matrix_form(last,last)=mat_set.vec(i).coef(j)
           case ("S+");
             last=last+2
             mat_set.vec(i).matrix_form(last-1,last)=mat_set.vec(i).coef(j)
           case ("S-");
             last=last+2
             mat_set.vec(i).matrix_form(last,last-1)=mat_set.vec(i).coef(j)
           case  default ; stdout.text("unknown matrix type")
             stop
         end
       end
     end           

   end


   make_type_numbers(subset) ::: leaky
   ! make type_numbers for each block of a subset of pauli_block_tensor
     subset :: PAULI_BLOCK_TENSOR_SET
     n_gem,i :: INT
     n_blocks,j :: INT

     n_gem=subset.vec.dim
     n_blocks=subset.vec(1).block_type.dim
     
     if(NOT subset.type_nb.created) then
       subset.type_nb.create(n_blocks)
     end
     do j=1,n_blocks
       subset.type_nb(j).element.create(9)
       subset.type_nb(j).element=0
     end
     
     do i=1,n_gem
       do j=1,n_blocks
         select case (subset.vec(i).block_type(j))       
         case("ID1"); 
           subset.type_nb(j).element(1)=subset.type_nb(j).element(1)+1     
         case("ID2");                                               
           subset.type_nb(j).element(2)=subset.type_nb(j).element(2)+1
         case("SZ"); 
           subset.type_nb(j).element(3)=subset.type_nb(j).element(3)+1
         case("SX");                                               
           subset.type_nb(j).element(4)=subset.type_nb(j).element(4)+1     
         case("ISY");                                              
           subset.type_nb(j).element(5)=subset.type_nb(j).element(5)+1
         case("GD2"); 
           subset.type_nb(j).element(6)=subset.type_nb(j).element(6)+1      
         case("E11");                                              
           subset.type_nb(j).element(7)=subset.type_nb(j).element(7)+1     
         case("E22");                                              
           subset.type_nb(j).element(8)=subset.type_nb(j).element(8)+1     
         case("S+");                                               
           subset.type_nb(j).element(9)=subset.type_nb(j).element(9)+1
         case("S-");                                               
           subset.type_nb(j).element(10)=subset.type_nb(j).element(10)+1
         case default ;
         end
       end
     end
   end


   put_type_numbers(bra_subset,ket_subset)
   ! make type_numbers for a pair of bra subset and ket subset
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks,j :: INT
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
   !debug stdout.text("bra type numbers")
     do j=1,n_blocks
     !debug stdout.show("j",j)
     !debug stdout.put(bra_subset.type_nb(j).element)
     end
   !debug stdout.text("ket type numbers")
     do j=1,n_blocks
     !debug stdout.show("j",j)
     !debug stdout.put(ket_subset.type_nb(j).element)
     end
   end

! davide: 16-11-2018
   check_spin_multiplicity(spin_multiplicity)
   ! check if the spin multiplicity of the molecule is lower or equal to 3;
   ! if not the program execution is stopped
   spin_multiplicity :: INT, IN

     if (spin_multiplicity > 3) then
     !debug stdout.text("Spin multiplicity greater than 3.")
     !debug stdout.text("Spin multiplicities beyond triplets")
     !debug stdout.text("not yet implemented in geminal model.")
!need to implement geminal with Sz=+/-1 in order to do that
!that is to say 2 extra matrices corresponding to .n_bf-dimensional  
! diagonal blocks of a (2*.n_bf)-dimensional matrix of geminal
! coefficients. The current .n_bf-dimensional matrix used corresponds
! to a symmetrical or antisymmetrical (triplet) linear combination of
! the off-diagonal blocks
        stop
     else
        .spin_multi = spin_multiplicity 
     end

   end
! de

! davide: 26-10-2018
   check_size
   ! check if the size of the geminal matrices is equal to the sum of
   ! the pauli block sizes
   !debug stdout.text(" ")
   !debug stdout.text("Checking size of bra set of geminals")
     .check_size(.bra_set,.mat_size)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking size of ket set of geminals")
       .check_size(.ket_set,.mat_size)
     end
   end

   check_size(pb_tensor_set,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     pb_mat_size :: INT
     i :: INT
     do i=1,.n_geminals
    !debug stdout.show("geminal", i)
      .check_size(pb_tensor_set.vec(i),pb_mat_size) 
     end
   end

   check_size(pbt,pb_mat_size)
   ! check if, for each pauli_block_matrix, the sum of block 
   ! sizes is equal to the matrix size
   pbt :: PAULI_BLOCK_TENSOR
   pb_mat_size :: INT
   nb1, nb2, chk_size :: INT
     nb1 = pbt.n_1D_blocks 
     nb2 = pbt.n_2D_blocks 
     chk_size = nb1 + nb2*2
     if (chk_size == pb_mat_size) then 
      !debug stdout.text("passed")
     else
      !debug stdout.text("not passed")
     end
   end
! de

! davide: 26-10-2018
   check_block_sizes
   ! check if geminal matrices have the same block sizes
   !debug stdout.text(" ")
   !debug stdout.text("Checking block sizes of bra set of geminals")
     .check_block_sizes(.bra_set,.n_blocks)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking block sizes of ket set of geminals")
       .check_block_sizes(.ket_set,.n_blocks)
     !debug stdout.text(" ")
     !debug stdout.text("checking block sizes homogeneity of ket and bra 1st geminals")
       .check_block_sizes(.bra_set.vec(1),.ket_set.vec(1),.n_blocks)
     end
   end

   check_block_sizes(pb_tensor_set,nb)
   !
     pb_tensor_set :: PAULI_BLOCK_TENSOR_SET
     nb :: INT
     i :: INT
     do i=2,.n_geminals
     !debug stdout.show("geminals 1 and", i)
       .check_block_sizes(pb_tensor_set.vec(1),pb_tensor_set.vec(i),nb)
     end
   end

   check_block_sizes(pbt1,pbt2,nb)
   !
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     i :: INT
     chk_bsize :: BIN 
     chk_bsize = pbt1.block_dim.equals(pbt2.block_dim)
     if(chk_bsize) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed for blocks:")
       do i=1,nb 
         if ( pbt1.block_dim(i) /= pbt2.block_dim(i) ) then
         !debug stdout.show(" ", i)
         end
       end
     end
   end
! de

! davide: 12-11-2018
   check_blocks_order
   ! check if in each PBT the blocks are ordered in this way:
   ! first the blocks of size 1, then the blocks of size 2
   !debug stdout.text(" ")
   !debug stdout.text("Checking blocks order in bra set of geminals")
     .check_blocks_order(.bra_set)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking blocks order in ket set of geminals")
       .check_blocks_order(.ket_set)
     end
   end
  
   check_blocks_order(pbt_set)
   ! call to the routine checking the order of blocks in each PBT
   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
   ng, i :: INT
     ng = size(pbt_set.vec)
     do i=1,ng
     !debug stdout.show("geminal", i)
       .check_blocks_order(pbt_set.vec(i))
     end
   end
  
   check_blocks_order(pbt)
   ! check if in the PBT the blocks are ordered in this way:
   ! first the blocks of size 1, then the blocks of size 2
   pbt :: PAULI_BLOCK_TENSOR, IN
   i :: INT
   test :: BIN 
     test = TRUE
     do i=1,pbt.n_1D_blocks
       if (pbt.block_dim(i) /= 1) then
         test = FALSE
         exit
       end
     end
     if (test) then
       do i=pbt.n_1D_blocks+1,pbt.n_2D_blocks
         if (pbt.block_dim(i) /= 2) then
           test = FALSE
           exit
         end
       end
     end
     if (NOT test) then
     !debug stdout.text("not passed")
     else
     !debug stdout.text("passed")
     end
   end
! de

! davide: 01-11-2018
   check_ortho
   ! check if geminals satisfy 1-orthogonality and 2-orthogonality 
   !debug stdout.text(" ")
   !debug stdout.text("Checking 1-orthogonality on bra set")
     .check_1ortho(.bra_set)
   !debug stdout.text(" ")
   !debug stdout.text("Checking 2-orthogonality on bra set")
     .check_2ortho(.bra_set)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking 1-orthogonality on ket set")
       .check_1ortho(.ket_set)
     !debug stdout.text(" ")
     !debug stdout.text("Checking 2-orthogonality on ket set")
       .check_2ortho(.ket_set)
     end
   end

   check_1ortho(pbt_set,only_1,pbt_constr)
   ! call to routines checking 1-orthogonality
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     only_1 :: BIN, optional
     pbt_constr :: BIN, optional
     ng, nb :: INT
     i, j :: INT
     only_n_1D_blocks :: BIN

     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks
     if (present(only_1) AND present(pbt_constr)) then
       only_n_1D_blocks = only_1
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, only_n_1D_blocks, pbt_constr)
         end
       end
     else if (present(only_1)) then
       only_n_1D_blocks = only_1
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb, only_n_1D_blocks)
         end
       end
     else
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_1ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
         end
       end
     end

   end

   check_1ortho(pbt1,pbt2,nb,only_1,pbt_constr)
   ! check 1-orthogonality
   ! if only_1 is present and TRUE,
   ! the 1-orthogonality is checked only for the
   ! first .n_1D_blocks of each PBT
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   only_1 :: BIN, optional
   pbt_constr :: BIN, optional
   i, counter :: INT
   bb :: VEC{INT}*
   only_n_1D_blocks :: BIN

     if (present(only_1)) then
       only_n_1D_blocks = only_1
     else
       only_n_1D_blocks = FALSE
     end

     counter = 0
     allocate(bb(nb))
     if (only_n_1D_blocks) then
       do i=1,pbt1.n_1D_blocks  ! loop over the first .n_1D_blocks
         if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     else
       do i=1,nb                         ! loop over all the blocks
         if (abs(pbt1.coef(i)) > TOL(15) AND abs(pbt2.coef(i)) > TOL(15)) then
           counter = counter + 1
           bb(counter) = i
         end
       end
     end

     if (counter == 0) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed for blocks:")
       do i=1,counter
       !debug stdout.show(" ", bb(i))
       end
       if (present(pbt_constr)) then
         pbt_constr = FALSE
       end
     end
     deallocate(bb)
   end

! davide: 18-11-2018
   check_2ortho(pbt_set)
   ! call to routines checking 2-orthogonality
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks
     do i=1,ng-1
       do j=i+1,ng
       !debug stdout.text("geminals:")
       !debug stdout.show(" ", i)
       !debug stdout.show(" ", j)
         .check_2ortho(pbt_set.vec(i), pbt_set.vec(j), nb)
       end
     end
   end
! de

! davide: 03-11-2018
   check_2ortho(pbt1, pbt2, nb)
   ! check 2-orthogonality
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   check, tr :: REAL
     check = ZERO
     do i=1,nb
       if (pbt1.block_dim(i) == 1) then
         check = check + pbt1.coef(i)*pbt2.coef(i)  
       else
         tr = .calc_tr( pbt1.block_type(i), pbt2.block_type(i) )
         check = check + pbt1.coef(i)*pbt2.coef(i)*tr  
       end
     end
     if (abs(check) < TOL(15)) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed")
     end
   end
 
   calc_tr(bty1, bty2) result (tr)
   ! compute trace of product of two blocks
   ! of type ID2, E11, E22, S+, S-, SX, ISY or SZ
   bty1, bty2 :: STR, IN
   tr :: REAL
     if (bty1 == bty2) then
       if (bty1=="ID2" OR bty1=="SX" OR bty1=="ISY" OR bty1=="SZ") then
         tr = TWO
       else if (bty1=="E11" OR bty1=="E22" OR bty1=="S+" OR bty1=="S-") then
         tr = ONE 
       else
       !debug stdout.text("unknown block type in calc_tr")
         stop
       end
     else
       if (bty1=="ID2" AND (bty2=="E11" OR bty2=="E22")) then 
         tr = ONE
       else if (bty2=="ID2" AND (bty1=="E11" OR bty1=="E22")) then 
         tr = ONE
       else if (bty1=="SX" AND (bty2=="S+" OR bty2=="S-")) then
         tr = ONE
       else if (bty2=="SX" AND (bty1=="S+" OR bty1=="S-")) then
         tr = ONE
       else if ((bty1=="ISY" AND bty2=="S+") OR (bty2=="ISY" AND bty1=="S+")) then
         tr = ONE
       else if ((bty1=="ISY" AND bty2=="S-") OR (bty2=="ISY" AND bty1=="S-")) then
         tr = -ONE
       else if ((bty1=="SZ" AND bty2=="E11") OR (bty2=="SZ" AND bty1=="E11")) then
         tr = ONE
       else if ((bty1=="SZ" AND bty2=="E22") OR (bty2=="SZ" AND bty1=="E22")) then
         tr = -ONE
       else
         tr = ZERO
       end
     end
   end
! de

! davide: 08-11-2018
   check_bra_ket_homogeneity
   ! check if the i-th bra and ket geminals
   ! have the same block structure and zero coefficients
   ! for the same blocks
   i :: INT
     .homogeneous = TRUE
   !debug stdout.text(" ")
   !debug stdout.text("Checking homogeneity of bra and ket sets")
     do i=1,.n_geminals
     !debug stdout.text(" ")
     !debug stdout.show("bra and ket geminals", i)
     !debug stdout.text("block structure test")
       .check_block_structure(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
     !debug stdout.text("zero coefficients test")
       .check_nonzero_coef(.bra_set.vec(i), .ket_set.vec(i),.homogeneous)
     end
   end
 
   check_block_structure(pbt1,pbt2,hom)
   ! check if the two geminals (PBT) have the same block structure,
   ! i.e. the same block types in the same positions
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
   hom :: BIN
   i, nb :: INT
   passed :: BIN
     passed= TRUE
     nb = size(pbt1.block_dim)
     do i=1,nb
       if (pbt1.block_type(i) /= pbt2.block_type(i)) then
       !debug stdout.show("block structure test not passed for block:",i)
         passed= FALSE
         hom= FALSE
       end
     end
     ! debug if (passed) stdout.text("passed")
   end
 
   check_nonzero_coef(pbt1,pbt2,hom)
   ! check if the two geminals have zero coefficients in the same
   ! positions, i.e. for the same blocks 
   pbt1, pbt2 :: PAULI_BLOCK_TENSOR, IN
   hom :: BIN
   i, nb :: INT
   passed, test1, test2 :: BIN
     passed = TRUE
     nb = size(pbt1.block_dim)
     do i=1,nb
       test1 = FALSE
       test2 = FALSE
       if (abs(pbt2.coef(i))>TOL(15) AND abs(pbt1.coef(i))<TOL(15)) then
          test1 = TRUE 
       end
       if (abs(pbt1.coef(i))>TOL(15) AND abs(pbt2.coef(i))<TOL(15)) then
          test2 = TRUE 
       end
       if (test1 OR test2) then
       !debug stdout.show("not passed for block:",i)
         passed = FALSE
         hom = FALSE
       end
     end
     ! debug if (passed) stdout.text("passed")
   end
! de

! davide: 18-11-2018
   check_pbt_constraints
   ! check if geminals satisfy the following constraints:
   ! 1-orthogonality for the first .n_1D_blocks and
   ! model constraints for the remaining blocks
     n :: INT

     .pbt_constraints = TRUE

   !debug stdout.text(" ")
   !debug stdout.text("Checking pbt constraints on bra set")
   !debug stdout.text(" ")
   !debug stdout.show("1-orthogonality test on the first", .n_1D_blocks)
   !debug stdout.text("blocks:")
     .check_1ortho(.bra_set, TRUE, .pbt_constraints)

     n = .n_blocks - .n_1D_blocks
   !debug stdout.text(" ")
   !debug stdout.show("model constraints test on the remaining", n)
   !debug stdout.text("blocks:")
     .check_model_constraints(.bra_set, TRUE, .pbt_constraints)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Checking pbt constraints on ket set")
     !debug stdout.text(" ")
     !debug stdout.show("1-orthogonality test on the first", .n_1D_blocks)
     !debug stdout.text("blocks:")
       .check_1ortho(.ket_set, TRUE, .pbt_constraints)
     !debug stdout.text(" ")
     !debug stdout.show("model constraints test on the remaining", n)
     !debug stdout.text("blocks:")
       .check_model_constraints(.ket_set, TRUE, .pbt_constraints)
     end
   end

   check_model_constraints(pbt_set, only_2, pbt_constr)
   ! call to the routine which checks the model constraints
   pbt_set :: PAULI_BLOCK_TENSOR_SET, IN
   only_2 :: BIN, optional
   pbt_constr :: BIN, optional
   ng, nb :: INT
   i, j :: INT
     ng = size(pbt_set.vec)
     nb = pbt_set.n_blocks
     if (present(only_2) AND present(pbt_constr)) then
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2, pbt_constr)
         end
       end
     else if (present(only_2)) then
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2)
         end
       end
     else
       do i=1,ng-1
         do j=i+1,ng
         !debug stdout.text("geminals:")
         !debug stdout.show(" ", i)
         !debug stdout.show(" ", j)
           .check_model_constraints(pbt_set.vec(i), pbt_set.vec(j), nb, only_2)
         end
       end
     end

   end

   check_model_constraints(pbt1,pbt2,nb,only_2,pbt_constr)
   ! check model constraints
   ! if only_2 is present and TRUE, the model constraints are checked
   ! only for the last (.n_blocks-.n_1D_blocks) blocks
     pbt1, pbt2 :: PAULI_BLOCK_TENSOR
     nb :: INT
     only_2 :: BIN, optional
     pbt_constr :: BIN, optional
     i, counter :: INT
     bb :: VEC{INT}*
     only_last_blocks :: BIN

     if (present(only_2)) then
       only_last_blocks = only_2
     else
       only_last_blocks = FALSE
     end

     counter = 0
     allocate( bb(nb) )
     if (only_last_blocks) then
       do i=pbt1.n_1D_blocks+1,nb ! loop over the last pbt.n_2D_blocks blocks
         if (pbt1.block_type(i) == pbt2.block_type(i)) then
           if (abs(pbt1.coef(i)) > TOL(15)  AND  abs(pbt2.coef(i)) > TOL(15)) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     else
       do i=1,nb                          ! loop over all the blocks
         if (pbt1.block_type(i) == pbt2.block_type(i)) then
           if (abs(pbt1.coef(i)) > TOL(15)  AND  abs(pbt2.coef(i)) > TOL(15)) then
             counter = counter + 1
             bb(counter) = i
           end
         end
       end
     end

     if (counter == 0) then
     !debug stdout.text("passed")
     else
     !debug stdout.text("not passed for blocks:")
       do i=1,counter
       !debug stdout.show(" ", bb(i))
       end
       if (present(pbt_constr)) then 
         pbt_constr = FALSE
       end
     end
     deallocate(bb)

   end
! de

! davide: 30-10-2018
   norm_gem(wrt_arg)
   ! normalization of geminals
     wrt_arg :: BIN, IN, optional
     wrt :: BIN
     i :: INT
     !
     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end
     !
     .norm_gem(.bra_set,.n_blocks)
     !
     if (wrt) then
        stdout.text(" ")
        stdout.text("Normalization of bra set of geminals")
        stdout.text("Normalized geminals - coefficients:")
        do i=1,.n_geminals
           stdout.show("geminal", i)
           stdout.put(.bra_set.vec(i).coef)
        end
        stdout.text(" ")
     end
     !
     if (NOT .bra_is_ket) then
        !
        .norm_gem(.ket_set,.n_blocks)
        !
        if (wrt) then
           stdout.text(" ")
           stdout.text("Normalization of ket set of geminals")
           stdout.text("Normalized geminals - coefficients:")
           do i=1,.n_geminals
              stdout.show("geminal", i)
              stdout.put(.ket_set.vec(i).coef)
           end
           stdout.text(" ")
        end
     end

   end

   norm_gem(pbt_set,nb)
   ! call to the normalization routine for each geminal
   pbt_set :: PAULI_BLOCK_TENSOR_SET
   nb :: INT
   i :: INT
     do i=1,.n_geminals
     !debug stdout.show("geminal", i)
     !!!!!
!       stdout.show("geminal", i)
     !!!!!
       .norm_gem(pbt_set.vec(i),nb)
     end
   end

   norm_gem(pbt,nb)
   ! normalization of one geminal
   pbt :: PAULI_BLOCK_TENSOR
   nb :: INT
   i :: INT
   bty :: STR
   norm :: REAL
   norm = ZERO
     do i=1,nb 
       bty = pbt.block_type(i)
       if (bty=="ID1" OR bty=="S+" OR bty=="S-" OR bty=="E11" OR bty=="E22") then
         norm = norm + pbt.coef(i)*pbt.coef(i)
       else if (bty=="ID2" OR bty=="SX" OR bty=="ISY" OR bty=="SZ" OR bty=="GD2") then
         norm = norm + pbt.coef(i)*pbt.coef(i)*TWO
       else
       !debug stdout.text("unknown block type in norm_gem(pbt,nb)")
         stop
       end
     end
     norm = sqrt(norm)
     pbt.coef = pbt.coef/norm
   !debug stdout.put(pbt.coef)
     !!!!!!!
 !    stdout.put(pbt.coef)
     !!!!!!!
   end
! de

! davide: 31-10-2018
   find_nonzero_coef
   ! identification of nonzero coefficients in each geminal 
   !debug stdout.text(" ")
   !debug stdout.text("Bra set of geminals - blocks with nonzero coefficient")
     .find_nonzero_coef(.bra_set)
     if (NOT .bra_is_ket) then
     !debug stdout.text(" ")
     !debug stdout.text("Ket set of geminals - blocks with nonzero coefficient")
       .find_nonzero_coef(.ket_set)
     end
   end

   find_nonzero_coef(pbt_set)
   ! call to the routine for identification of nonzero coefficients
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, ng :: INT

     .nonzero_1ortho_ind.create(.n_1D_blocks)
     .nonzero_1ortho_ind=0

     do i=1,pbt_set.set_size
     !debug stdout.text(" ")
     !debug stdout.show("geminal", i)
       .find_nonzero_coef(pbt_set.vec(i),i)
     end

   end

   find_nonzero_coef(pbt,g)
   ! identification and storing of nonzero 
   ! coefficients in one geminal 
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT
     i, counter :: INT
     nb, n_1D_blocks :: INT

     nb = size(pbt.block_type) 
     allocate(pbt.nonzero_coef_ind(nb))
     !!!
     allocate(pbt.new_nonzero_coef_ind(nb))
     !!!
     allocate(pbt.red_coef(nb))
     pbt.red_coef(nb) = ZERO
     counter = 0
     n_1D_blocks = pbt.n_1D_blocks
     do i=1,n_1D_blocks   ! loop over 1-orthogonal blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           counter = counter + 1
           pbt.nonzero_coef_ind(counter) = 0
           !!!
           pbt.new_nonzero_coef_ind(counter) = i
           !!!
           pbt.red_coef(counter) = pbt.coef(i)
           .nonzero_1ortho_ind(i) = g  ! geminal g has a nonzero coef. in 1-ortho. block i
        end
     end
     pbt.n_nonzero_1ortho = counter   ! number of nonzero 1-orthogonal blocks
     if(counter==0) pbt.first_block=1
     do i=n_1D_blocks+1,nb   ! loop over Pauli blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           counter = counter + 1
           pbt.nonzero_coef_ind(counter) = i - n_1D_blocks
           !!!
           pbt.new_nonzero_coef_ind(counter) = i
           !!!
           pbt.red_coef(counter) = pbt.coef(i)
        end
     end
     pbt.nonzero_coef_ind.shrink(counter)
     !!!
     pbt.new_nonzero_coef_ind.shrink(counter)
     !!!
     pbt.red_coef.resize(counter)

     !debug do i=1,counter
     !debug    stdout.show( "index =", pbt.nonzero_coef_ind(i) )
     !debug    stdout.show( "coef. =", pbt.red_coef(i) )
     !debug end
   end

   prep_nonzero_coef ::: leaky
   ! prepare indices and products of coefficients
   ! of nonzero blocks for the calculation of integral formulas
   ! (overlap and matrix elements between PBT sets)
     i, j :: INT
     siz_ind, siz_prod, siz :: INT
     ind, ind_prod :: INT
     ng, n_nonzero_1ortho, n_nonzero_blocks :: INT
     p_coef_1ortho :: REAL
     n_pauli_blocks :: INT

   !debug stdout.text(" ")
   !debug stdout.text("Indices and products of coefficients")
   !debug stdout.text("of nonzero blocks:")
     
     ng = .n_geminals
     .nonzero_coef_ind.create(ng)
     .nonzero_coef_prod.create(ng)
     if (.bra_is_ket) then
        do i=1,ng
           ! create vector of nonzero block indices
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1D_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.bra_set.vec(i).red_coef(j)*TWO
           end
        end
     else
        do i=1,ng
           n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
           n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
           siz_ind = n_nonzero_blocks - n_nonzero_1ortho + 1 -.first_block
           .nonzero_coef_ind(i).element.create(siz_ind)
           ! create vector of coefficient products
           n_pauli_blocks = .n_blocks-.n_1D_blocks
           siz_prod = n_pauli_blocks+1-.first_block
           .nonzero_coef_prod(i).element.create(siz_prod)
           .nonzero_coef_prod(i).element = ZERO
           .nonzero_coef_ind(i).element(1) = 0
           if (.first_block == 0) then 
             p_coef_1ortho = ZERO
             do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
                p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)
             end
             .nonzero_coef_prod(i).element(1) = p_coef_1ortho
           end
           ind = 1-.first_block
           do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
              ind = ind + 1
              .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
              ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
              .nonzero_coef_prod(i).element(ind_prod) = .bra_set.vec(i).red_coef(j)*.ket_set.vec(i).red_coef(j)*TWO
           end
        end
     end

     !!! debug
!     do i=1,ng
!      !debug stdout.text(" ")
!      !debug stdout.show("geminal",i)
!        siz = size(.nonzero_coef_ind(i).element)
!        do j=1,siz
!         !debug stdout.show("block index", .nonzero_coef_ind(i).element(j))
!           ind_prod = .nonzero_coef_ind(i).element(j) + 1 -.first_block
!         !debug stdout.show("coef. product", .nonzero_coef_prod(i).element(ind_prod))
!        end
!     end
     !!!

   end
! de

! davide: 11-11-2018/12-11-2018
   make_int_term_list(check_arg,prep_arg,write_arg) ::: leaky
   ! make the list of non zero block indices combinations for integral
   ! formula relevant to the standard PBT model
     check_arg :: BIN, optional
     prep_arg :: BIN, optional
     write_arg :: BIN, optional
     current_list :: VEC_INT_LIST*
     new_item :: VEC_INT_LIST*
     new_list :: VEC_INT_LIST*
     i, j, k :: INT
     siz :: INT
     parity :: INT
     list_ind :: VEC{INT}*
     check :: BIN
     prep :: BIN
     writ :: BIN

     check = TRUE
     if (present(check_arg)) then
        check = check_arg
     end

     prep = TRUE
     if (present(prep_arg)) then
        prep = prep_arg
     end

     writ = TRUE
     if (present(write_arg)) then
        writ = write_arg
     end
  
     if (check) then
        .check_pbt_constraints
        if (NOT .pbt_constraints) then
        !debug stdout.text(" ")
        !debug stdout.text("PBT constraints not enforced")
          stop
        end
        
        if (NOT .bra_is_ket) then
          .check_bra_ket_homogeneity
          if (NOT .homogeneous) then
          !debug stdout.text(" ")
          !debug stdout.text("bra and ket not homogeneous")
            stop
          end
        end
     end

     if (prep) then
        .prep_nonzero_coef
     end
   !  destroy former list if present 
     new_item=>.int_term_ind
     do
       if (NOT associated(new_item)) exit
       .int_term_ind.item.destroy
       new_item=>.int_term_ind.next
       deallocate(.int_term_ind)
       .int_term_ind=>new_item
     end
     ! initialize combinations with geminal 1 nonzero coef
     nullify(current_list)
     nullify(new_item)
     do i=1,size(.nonzero_coef_ind(1).element)
       allocate(new_item)
       allocate(new_item.item(.n_geminals))
       new_item.item(1) = .nonzero_coef_ind(1).element(i)
       new_item.next => current_list
       current_list => new_item
     end
    
     ! produce combinations
     parity = 1 ! parity used to construct combinations always in increasing index order
     do j=2,.n_geminals
       nullify(new_list)
       siz = size(.nonzero_coef_ind(j).element)
       allocate(list_ind(siz))
       list_ind = .nonzero_coef_ind(j).element(1:siz)
       do
         if (NOT associated(current_list)) exit
         if (parity == -1) then 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
           do i=2,siz ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end
         else
           do i=siz,2,-1 ! loop on blocks where geminal j has nonzero coef
             if (any(current_list.item(1:j-1) == list_ind(i))) cycle
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(i)
             new_item.next => new_list
             new_list => new_item
           end 
           ! for i=1 block number can be 0 and if so must not be eliminated
           if (list_ind(1) == 0 OR all(current_list.item(1:j-1) /= list_ind(1))) then 
             allocate(new_item)
             allocate(new_item.item(.n_geminals))
             new_item.item(1:j-1) = current_list.item(1:j-1)
             new_item.item(j) = list_ind(1)
             new_item.next => new_list
             new_list => new_item
           end
         end
         ! deallocating the previous list
         new_item=>current_list
         current_list => current_list.next
         deallocate(new_item.item)
         deallocate(new_item)
       end
       current_list => new_list
       parity = -parity
       deallocate(list_ind)
     end
  
     nullify(.int_term_ind)
     .int_term_ind => current_list
    
     ! write combinations produced
     if (writ) then
      !debug stdout.text(" ")
      !debug stdout.text("List of block indices combinations for integral")
      !debug stdout.text("formula relevant to the standard PBT model:")
        i = 0
        current_list => .int_term_ind
        do
           if (NOT associated(current_list)) exit
           i = i + 1
         !debug stdout.show("Combination", i)
         !debug stdout.put(current_list.item)
           current_list => current_list.next 
        end
     end
  
   end
! de

! davide: 19-11-2018
   calc_overlap_integral(overlap_value,wrt_arg)
   ! compute the overlap integral between the bra and ket
   ! PBT sets
     overlap_value :: REAL, optional
     wrt_arg :: BIN, optional
     comb_list :: VEC_INT_LIST*
     term, overlap :: REAL 
     bra_coef, ket_coef :: REAL
     i :: INT
     j :: INT
     wrt :: BIN

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     nullify(comb_list)
     comb_list => .int_term_ind

     overlap = ZERO

     do
        if (NOT associated(comb_list)) exit
        term = ONE
        do i=1,.n_geminals
           j = comb_list.item(i)+1-.first_block
           term = term*.nonzero_coef_prod(i).element(j)
        end
        overlap = overlap + term
        comb_list => comb_list.next 
     end

     if (present(overlap_value)) then
        overlap_value = overlap
     end

!     if (wrt) then
!      !debug stdout.text(" ")
!      !debug stdout.show("Overlap integral between bra and ket PBT sets =", overlap)
!     end 

   end
! de

! davide 24-10-2019
   optimize_coef
   ! perform the optimization of the block coefficients 
   ! (i.e. find the set of block coefficients which minimize the
   ! electronic energy, for a given block structure)
     self :: target
     coef :: VEC{REAL}*
     i, j, k, siz, n_nonzero_coef :: INT
     el_energy, coef_tol, grad_tol, step :: REAL
     max_it, n_col :: INT
     iter :: VEC{INT}(1)
     energy_min, delta_ene, grd_norm :: VEC{REAL}(1)
     grad :: VEC{REAL}*
     nonzero_only_1ortho, reset_n_2D_blocks :: BIN
     n_2D_blocks, n_2D_3typ_blocks, n_2D_4typ_blocks :: INT
     !!!
     !
     ! check if the bra set is equal to the ket set;
     ! if not, stop the program execution
     !
     if (NOT .bra_is_ket) then
        stdout.text("Bra is not equal to ket:")
        stdout.text("optimization of the block coefficients")
        stdout.text("not implemented yet, for this case.")
        stop
     end
     !
     ! write information about the set of block coefficients to be optimized
     !
     stdout.text(" ")
     stdout.text("Indices of blocks with nonzero coefficient:")
     do i=1,.n_geminals 
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.show("block indices",.bra_set.vec(i).new_nonzero_coef_ind)
     end
     !
     ! prepare initial set of coefficients 
     ! (and angles) to be optimized
     !
     if (.opt_GD2_angles AND .n_2D_3typ_blocks > 0) then
        ! set the maximum size of nonzero coefficients
        ! (according to the model constraints),
        ! and GD2 angles
        siz = .n_1D_blocks+4*.n_2D_3typ_blocks+4*.n_2D_4typ_blocks
        ! build the "coef" array of block coefficients 
        ! and GD2 angles to be optimized
        coef.create(siz)
        siz = 0
        ! nonzero block coefficients
        do i=1,.n_geminals
           n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
           do j=1,n_nonzero_coef
              k = .bra_set.vec(i).new_nonzero_coef_ind(j)
              siz = siz + 1
              coef(siz) = .bra_set.vec(i).coef(k)
           end do
        end do
        n_nonzero_coef = siz
        ! GD2 angles
        do i=1,.n_2D_3typ_blocks
           siz = siz + 1
           coef(siz) = .GD2_info(i) 
        end
        coef.resize(siz)
        ! write the initial set of coefficients
        ! to be optimized
        stdout.text(" ")
        stdout.show("Total number of nonzero coefficient =",n_nonzero_coef)
        stdout.text(" ")
        stdout.text("Initial nonzero coefficients:")
        stdout.put(coef(1:n_nonzero_coef))
        stdout.text(" ")
        stdout.text("Optimization of GD2 angles will be performed as well")
        stdout.text(" ")
        stdout.show("Total number of GD2 angles =",.n_2D_3typ_blocks)
        stdout.text(" ")
        stdout.text("Initial GD2 angles:")
        stdout.put(coef(n_nonzero_coef+1:siz))
     else
        ! set the maximum size of nonzero coefficients
        ! (according to the model constraints),
        siz = .n_1D_blocks+3*.n_2D_3typ_blocks+4*.n_2D_4typ_blocks
        ! build the "coef" array of block coefficients 
        ! to be optimized
        coef.create(siz)
        siz = 0
        do i=1,.n_geminals
           n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
           do j=1,n_nonzero_coef
              k = .bra_set.vec(i).new_nonzero_coef_ind(j)
              siz = siz + 1
              coef(siz) = .bra_set.vec(i).coef(k)
           end do
        end do
        n_nonzero_coef = siz
        coef.resize(siz)
        ! write the intial set of nonzero block coefficients
        stdout.text(" ")
        stdout.show("Total number of nonzero coefficient =",n_nonzero_coef)
        stdout.text(" ")
        stdout.text("Initial nonzero coefficients:")
        stdout.put(coef)
     end
     !
     ! perform the minimization of the energy WRT the block coefficients 
     !
     stdout.text(" ")
     stdout.text("* * * Starting BFGS minimization * * *")
     ! initialize variable for writing info.
     ! about the optimization to the output
     .coef_opt_info.iter = 0
     .coef_opt_info.new_iter = FALSE
     .coef_opt_info.energy_min_curr = ZERO
     .coef_opt_info.energy_min_prev = ZERO
     el_energy = ZERO
     ! create a table (for info. about the coef. optimization)
     n_col = 4
     .coef_opt_info.table.create(n_col)
     .coef_opt_info.table(1).set_heading("Iter")
     .coef_opt_info.table(1).force_width(6)
!     .coef_opt_info.table(1).set_width_from(max_it)
     .coef_opt_info.table(2).set_heading("Energy")
     .coef_opt_info.table(2).set_subhead("E/au")
     .coef_opt_info.table(2).set_width_from(el_energy)
     .coef_opt_info.table(3).set_heading("Delta")
     .coef_opt_info.table(3).set_subhead("E")
     .coef_opt_info.table(3).set_width_from(el_energy)
     .coef_opt_info.table(4).set_heading("Gradient")
     .coef_opt_info.table(4).set_subhead("Norm")
     .coef_opt_info.table(4).set_width_from(el_energy)
     .coef_opt_info.table.put_headings
     ! call the routine for energy minimization 
     coef_tol = TOL(4)
     grad_tol = TOL(4)
     step = TOL(2)
     max_it = 200
     nullify(pbg_saved)
     pbg_saved => self
     VEC{REAL}:minimize_BFGS(::energy_gem,::gradient_gem, coef, el_energy, coef_tol, grad_tol, step, max_it)
     ! store results of the last iteration
     .electronic_energy = el_energy
     energy_min = el_energy
     iter = .coef_opt_info.iter
     delta_ene = el_energy-.coef_opt_info.energy_min_prev
     ! compute the gradient norm at the final energy point
     siz = size(coef)
     grad.create(siz)
     nullify(pbg_saved)
     pbg_saved => self
     grad = ::gradient_gem(coef)
     grd_norm = grad.norm
     grad.destroy
     ! write final results of the optimization to the output
     .coef_opt_info.table(1).set_values(iter)
     .coef_opt_info.table(2).set_values(energy_min)
     .coef_opt_info.table(3).set_values(delta_ene)
     .coef_opt_info.table(4).set_values(grd_norm)
     .coef_opt_info.table.put_body
     !
     .coef_opt_info.table.put_footer
     .coef_opt_info.table.destroy
     !
     stdout.text(" ")
     stdout.text("* * * Optimization completed * * *")
     stdout.text(" ")
     !
     ! write optimized energies and set of geminals to the output
     !
     stdout.text(" ")
     stdout.text("============================")
     stdout.text("Pauli block geminals results")
     stdout.text("============================")
     ! write optimized energies
     stdout.text(" ")
     stdout.text("Optimized energies (in a.u.):")
     stdout.text(" ")
     stdout.show("Electronic energy =",.electronic_energy)
     stdout.show("Nuclear repulsion energy =",.nuclear_repulsion_energy)
     stdout.show("Total energy =",.electronic_energy+.nuclear_repulsion_energy)
     stdout.text(" ")
     ! write optimized "bra_set" of geminals
     stdout.text("Optimized geminals:")
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end
     if (.bra_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("GD2 angles:")
        !stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end
     stdout.text(" ")
     !
     ! destroy previously created arrays
     ! and nullify pointers
     !
     coef.destroy
     nullify(pbg_saved)

   end
! this is for debug
!   optimize_coef
!   ! perform the optimization of the block coefficients 
!   ! (i.e. find the set of block coefficients which minimize the
!   ! electronic energy, for a given block structure)
!     self :: target
!     coef :: VEC{REAL}*
!!     siz :: INT
!!     i, ifirst, ilast :: INT
!     i, j, k, siz, n_nonzero_coef :: INT
!     el_energy, coef_tol, grad_tol, step :: REAL
!     max_it, n_col :: INT
!     iter :: VEC{INT}(1)
!     energy_min, delta_ene, grd_norm :: VEC{REAL}(1)
!     grad :: VEC{REAL}*
!     nonzero_only_1ortho, reset_n_2D_blocks :: BIN
!     n_2D_blocks, n_2D_3typ_blocks, n_2D_4typ_blocks :: INT
!!     !
!!     ! check if the set of geminals has nonzero coefficients only for
!!     ! the 1D-blocks, i.e. if only 1D-blocks are present or if all 
!!     ! the coefficients of the 2D-blocks are zero
!!     ! (the optimization of the 2D-block coefficients is not
!!     ! implemented yet)
!!     !
!!     .check_if_nonzero_only_1ortho(nonzero_only_1ortho)
!!     if (NOT nonzero_only_1ortho) then
!!        stdout.text("The input set of geminals is not strongly orthogonal:")
!!        stdout.text("optimization of the block coefficients")
!!        stdout.text("not implemented yet, for this case.")
!!        stop
!!     end
!!!!!!!!!!!!!!!!!!!!!!!
!     !
!     ! check if the set of geminals has nonzero coefficients only for
!     ! the 1D-blocks, i.e. if only 1D-blocks are present or if all 
!     ! the coefficients of the 2D-blocks are zero; if this is the
!     ! case, the number of 2D (3type and 4type) blocks is set to zero 
!     !
!     if (.n_2D_3typ_blocks == 0 AND .n_2D_4typ_blocks == 0) then
!        reset_n_2D_blocks = FALSE
!     else
!        .check_if_nonzero_only_1ortho(nonzero_only_1ortho)
!        reset_n_2D_blocks = nonzero_only_1ortho
!     end if
!     !!!
!!     if (.n_2D_3typ_blocks /= 0 AND .n_2D_4typ_blocks /= 0) then
!!        .check_if_nonzero_only_1ortho(nonzero_only_1ortho)
!!        reset_n_2D_blocks = nonzero_only_1ortho
!!     else
!!        reset_n_2D_blocks = FALSE
!!     end
!     !!!
!!     stdout.text(" ")
!!     stdout.show("reset_n_2D_blocks =", reset_n_2D_blocks)
!!     !stdout.show("nonzero_only_1ortho =", nonzero_only_1ortho)
!     if (reset_n_2D_blocks) then
!     !if (nonzero_only_1ortho) then
!        ! set the number of 2D blocks to zero
!        n_2D_blocks = .n_2D_blocks 
!        .n_2D_blocks = 0
!        n_2D_3typ_blocks = .n_2D_3typ_blocks
!        .n_2D_3typ_blocks = 0
!        n_2D_4typ_blocks = .n_2D_4typ_blocks
!        .n_2D_4typ_blocks = 0
!     end
!!!!!!!!!!!!!!!!!!!!!!!
!     !
!     ! check if the bra set is equal to the ket set;
!     ! if not, stop the program execution
!     !
!     if (NOT .bra_is_ket) then
!        stdout.text("Bra is not equal to ket:")
!        stdout.text("optimization of the block coefficients")
!        stdout.text("not implemented yet, for this case.")
!        stop
!     end
!     !
!     ! set the maximum size of nonzero coefficients
!     ! (according to the model constraints)
!     !
!     siz = .n_1D_blocks+3*.n_2D_3typ_blocks+4*.n_2D_4typ_blocks
!     !
!     ! write information about the set of block coefficients to be optimized
!     !
!     stdout.text(" ")
!     stdout.text("Indices of blocks with nonzero coefficient:")
!     do i=1,.n_geminals 
!        stdout.text(" ")
!        stdout.show("geminal",i)
!        stdout.show("block indices",.bra_set.vec(i).new_nonzero_coef_ind)
!        !!! debug
!!        stdout.show("block indices (new) :",.bra_set.vec(i).new_nonzero_coef_ind)
!!        stdout.show("block indices (old) :",.bra_set.vec(i).nonzero_coef_ind)
!!        stdout.show("block indices (old2):",.nonzero_coef_ind(i).element)
!        !!!
!     end
!     !!! debug
!!     stdout.text(" ")
!!     stdout.text("Geminal indices for 1D blocks")
!!     stdout.show(".nonzero_1ortho_ind:", .nonzero_1ortho_ind)
!     !!!
!     !!! debug
!!     stdout.text(" ")
!!     stdout.text("Pauli block types vectors:")
!!     do i=1,.n_blocks-.n_1D_blocks
!!        stdout.text(" ")
!!        stdout.show("Pauli block",i)
!!        stdout.show("geminal indices",.block_types(i).element)
!!     end
!     !!!
!     !
!     ! build the "coef" array of block coefficients to be optimized
!     !
!     coef.create(siz)
!     siz = 0
!     !!!
!     stdout.text(" ")
!     stdout.text("Preparing initial vector of nonzero coefficients:")
!     !!!
!     do i=1,.n_geminals
!        !!!
!        stdout.text(" ")
!        !!!
!        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
!        do j=1,n_nonzero_coef
!           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
!           siz = siz + 1
!           coef(siz) = .bra_set.vec(i).coef(k)
!           !!!
!           stdout.show("geminal",i)
!           stdout.show("block",k)
!           stdout.show("coef",coef(siz))
!           !!!
!        end do
!     end do
!     coef.resize(siz)
!!     coef.create(siz)
!!     siz = 0
!!     do i=1,.n_geminals
!!        ifirst = siz + 1
!!        ilast = siz + size(.bra_set.vec(i).red_coef)
!!        coef(ifirst:ilast) = .bra_set.vec(i).red_coef
!!        siz = ilast
!!     end
!!     coef.resize(siz)
!     !
!     ! write the intial set of nonzero block coefficients
!     !
!     stdout.text(" ")
!     stdout.show("Total number of nonzero coefficient =",siz)
!     stdout.text(" ")
!     stdout.text("Initial nonzero coefficients:")
!     stdout.put(coef)
!     !
!     ! perform the minimization of the energy WRT the block coefficients 
!     !
!     stdout.text(" ")
!     stdout.text("* * * Starting BFGS minimization * * *")
!     ! initialize variable for writing info.
!     ! about the optimization to the output
!     .coef_opt_info.iter = 0
!     .coef_opt_info.new_iter = FALSE
!     .coef_opt_info.energy_min_curr = ZERO
!     .coef_opt_info.energy_min_prev = ZERO
!     el_energy = ZERO
!     ! create a table (for info. about the coef. optimization)
!     n_col = 4
!     .coef_opt_info.table.create(n_col)
!     .coef_opt_info.table(1).set_heading("Iter")
!     .coef_opt_info.table(1).force_width(6)
!     !.coef_opt_info.table(1).set_width_from(max_it)
!     .coef_opt_info.table(2).set_heading("Energy")
!     .coef_opt_info.table(2).set_subhead("E/au")
!     .coef_opt_info.table(2).set_width_from(el_energy)
!     .coef_opt_info.table(3).set_heading("Delta")
!     .coef_opt_info.table(3).set_subhead("E")
!     .coef_opt_info.table(3).set_width_from(el_energy)
!     .coef_opt_info.table(4).set_heading("Gradient")
!     .coef_opt_info.table(4).set_subhead("Norm")
!     .coef_opt_info.table(4).set_width_from(el_energy)
!     .coef_opt_info.table.put_headings
!     ! call the routine for energy minimization 
!     coef_tol = TOL(4)
!     grad_tol = TOL(4)
!     step = TOL(2)
!     max_it = 200
!     nullify(pbg_saved)
!     pbg_saved => self
!     VEC{REAL}:minimize_BFGS(::energy_gem,::gradient_gem, coef, el_energy, coef_tol, grad_tol, step, max_it)
!     ! store results of the last iteration
!     .electronic_energy = el_energy
!     energy_min = el_energy
!     iter = .coef_opt_info.iter
!     delta_ene = el_energy-.coef_opt_info.energy_min_prev
!     ! compute the gradient norm at the final energy point
!     siz = size(coef)
!     grad.create(siz)
!     nullify(pbg_saved)
!     pbg_saved => self
!     grad = ::gradient_gem(coef)
!     grd_norm = grad.norm
!     grad.destroy
!     ! write final results of the optimization to the output
!     .coef_opt_info.table(1).set_values(iter)
!     .coef_opt_info.table(2).set_values(energy_min)
!     .coef_opt_info.table(3).set_values(delta_ene)
!     .coef_opt_info.table(4).set_values(grd_norm)
!     .coef_opt_info.table.put_body
!     !
!     .coef_opt_info.table.put_footer
!     .coef_opt_info.table.destroy
!     !
!     stdout.text(" ")
!     stdout.text("* * * Optimization completed * * *")
!     stdout.text(" ")
!     !
!     ! write optimized energies and set of geminals to the output
!     !
!     stdout.text(" ")
!     stdout.text("============================")
!     stdout.text("Pauli block geminals results")
!     stdout.text("============================")
!     ! write optimized energies
!     stdout.text(" ")
!     stdout.text("Optimized energies (in a.u.):")
!     stdout.text(" ")
!     stdout.show("Electronic energy =",.electronic_energy)
!     stdout.show("Nuclear repulsion energy =",.nuclear_repulsion_energy)
!     stdout.show("Total energy =",.electronic_energy+.nuclear_repulsion_energy)
!     stdout.text(" ")
!     ! write optimized "bra_set" of geminals
!     stdout.text("Optimized geminals:")
!     do i=1,.n_geminals
!        stdout.text(" ")
!        stdout.show("geminal",i)
!        stdout.text("block structure:")
!        stdout.put(.bra_set.vec(i).block_type)
!        stdout.text("coefficients:")
!        stdout.put(.bra_set.vec(i).coef)
!     end
!     if (.bra_set.n_2D_3typ_blocks > 0) then
!        stdout.text(" ")
!        stdout.text("Angles defining GD2 matrices:")
!        !stdout.text("GD2 info vector:")
!        stdout.put(.GD2_info)
!     end
!     stdout.text(" ")
!     !
!     ! destroy previously created arrays
!     ! and nullify pointers
!     !
!     coef.destroy
!     nullify(pbg_saved)
!!!!!!!!!!!!!!!!!!!!!!!
!     !
!     ! restore the initial number of 2D blocks
!     ! (if only nonzero 1D blocks are present)
!     !
!     if (reset_n_2D_blocks) then
!     !if (nonzero_only_1ortho) then
!        .n_2D_blocks = n_2D_blocks 
!        .n_2D_3typ_blocks = n_2D_3typ_blocks
!        .n_2D_4typ_blocks = n_2D_4typ_blocks
!     end
!!!!!!!!!!!!!!!!!!!!!!!
!
!   end
!!!!!!!!!!!!!!!!!!!!!!
! de

   check_if_nonzero_only_1ortho(nonzero_only_1ortho)
   ! check if the set of geminals has nonzero coefficients only for
   ! the 1D blocks
     nonzero_only_1ortho :: BIN, INOUT
     i, mxval :: INT

     nonzero_only_1ortho = TRUE

     do i=1,.n_geminals 
        mxval = maxval(.bra_set.vec(i).new_nonzero_coef_ind)
        if (mxval > .n_1D_blocks) then
           nonzero_only_1ortho = FALSE
           return
        end
     end

   end

   energy_gem(coef) result(ene) ::: selfless
   ! compute the electronic energy associated to the block
   ! coefficients "coef"
     coef :: VEC{REAL}, IN
     ene :: REAL
     overlap :: REAL
     !
     self :: PAULI_BLOCK_GEMINALS*
     !
     counter :: INT, save = 1
     iter :: VEC{INT}(1), save = 0
     energy_min, delta_ene, grd_norm :: VEC{REAL}(1)
     !
     !!! debug
!     stdout.text(" ")
!     stdout.show("Entering function energy_gem(coef)",counter)
!     counter = counter+1
!     !stdout.text("Entering function energy(coef)")
!     stdout.text(" ")
     !!!

     self => pbg_saved

     ! update objects used to compute the energy 
     .update_coef(coef)

     ! compute the squared norm of the wavefunction
     .calc_overlap_integral(overlap)
     .overlap = overlap

     ! compute the 2RDM
     .calc_2rdm_gen
     !.calc_2rdm_gen_grd

     ! compute the electronic energy
     .make_hamiltonian(ham=ene,wrt_arg=FALSE)

     !!!
!     stdout.text(" ")
!     stdout.show("Electronic energy =",ene)
     !!!

     ! this is to save the energy of the first point of the
     ! optimization
     if (counter == 1) then
        !
        ! first energy point of the optimization
        !
        .coef_opt_info.energy_min_prev = ene
        .coef_opt_info.energy_min_curr = ene
     else
        !
        ! subsequent (not first) energy points of the optimization
        !
        if (.coef_opt_info.new_iter) then
        !if (.coef_opt_info.iter /= iter(1)) then
           !
           ! write results of the previous iteration (of the
           ! optimization) to the output
           !
           energy_min = .coef_opt_info.energy_min_curr
           delta_ene = .coef_opt_info.energy_min_curr-.coef_opt_info.energy_min_prev
           grd_norm = .coef_opt_info.grd_norm
           .coef_opt_info.table(1).set_values(iter)
           .coef_opt_info.table(2).set_values(energy_min)
           .coef_opt_info.table(3).set_values(delta_ene)
           .coef_opt_info.table(4).set_values(grd_norm)
           .coef_opt_info.table.put_body
           .coef_opt_info.table.clear_columns
           ! update info. about the optimization
           .coef_opt_info.new_iter = FALSE
           .coef_opt_info.iter = .coef_opt_info.iter+1
           iter = .coef_opt_info.iter
           !iter = .coef_opt_info.iter
           .coef_opt_info.energy_min_prev = .coef_opt_info.energy_min_curr
           .coef_opt_info.energy_min_curr = ene
        else if (ene < .coef_opt_info.energy_min_curr) then
           !
           ! update the minimum energy at the current iteration
           !
           .coef_opt_info.energy_min_curr = ene
        end
     end

     ! "counter" counts the time the function is called 
     ! during the optimization
     counter = counter+1

   end

   update_coef(new_coef)
   ! update "bra_set.vec(:).coef", "bra_set.vec(:).red_coef" and
   ! "nonzero_coef_prod" using nonzero coefficients "new_coef";
   ! after updating "bra_set.vec(:).coef", the geminals are normalized
     new_coef :: VEC{REAL}, IN
     i, j, k :: INT
     n_nonzero_coef :: INT
     counter :: INT
     p_coef_1ortho :: REAL
     n_nonzero_1ortho :: INT
     n_nonzero_blocks :: INT
     ind, ind_prod :: INT
     ang :: REAL
     !!!
!     stdout.text(" ")
!     stdout.text("Entering function update_coef")
     !!!

     ! update "bra_set.vec(:).coef"
     counter = 0
     do i=1,.n_geminals
        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           counter = counter+1
           .bra_set.vec(i).coef(k) = new_coef(counter)
        end
     end

     ! update GD2 angles and matrix elements
     ! (if optimization of GD2 angles is requested)
     if (.opt_GD2_angles) then 
        do i=1,.n_2D_3typ_blocks
           counter = counter+1
           !! new
           ang = new_coef(counter) 
           .GD2_info(i) = ang - (int(ang/PI) * PI)
           !! old
           !.GD2_info(i) = new_coef(counter)
        end
        .initialize_GD2
     end

     ! normalize geminals
     ! ("bra_set.vec(:).coef" will be changed)
     .norm_gem(wrt_arg=FALSE)

     ! update "bra_set.vec(:).red_coef" and "nonzero_coef_prod"
     do i=1,.n_geminals
        ! "bra_set.vec(i).red_coef"
        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           .bra_set.vec(i).red_coef(j) = .bra_set.vec(i).coef(k)
        end
        ! "nonzero_coef_prod(i).element"
        n_nonzero_1ortho = .bra_set.vec(i).n_nonzero_1ortho
        n_nonzero_blocks = size(.bra_set.vec(i).nonzero_coef_ind)
        if (.first_block == 0) then 
           p_coef_1ortho = ZERO
           do j=1,n_nonzero_1ortho ! loop over nonzero 1-ortho. blocks
              p_coef_1ortho = p_coef_1ortho + .bra_set.vec(i).red_coef(j)**2
           end
           .nonzero_coef_prod(i).element(1) = p_coef_1ortho
        end
        ind = 1-.first_block
        do j=n_nonzero_1ortho+1,n_nonzero_blocks ! loop over nonzero Pauli blocks
           ind = ind + 1
           .nonzero_coef_ind(i).element(ind) = .bra_set.vec(i).nonzero_coef_ind(j)
           ind_prod = .bra_set.vec(i).nonzero_coef_ind(j) + 1 -.first_block
           .nonzero_coef_prod(i).element(ind_prod) = TWO*(.bra_set.vec(i).red_coef(j)**2)
        end
     end

   end

   gradient_gem(coef) result(grad) ::: selfless
   ! compute the energy gradient with respec to the block
   ! coefficients "coef"
     coef :: VEC{REAL}, IN
     grad :: VEC{REAL}(size(coef))
     !
     self :: PAULI_BLOCK_GEMINALS*
     overlap :: REAL
     update :: BIN

     self => pbg_saved

     ! check if "coef" and (nonzero) ".bra_set.vec(:).coef" 
     ! differ or not; if they differ, update=TRUE
     .check_coef(coef, update)
     if (update) then
        !
        ! update objects used to compute the energy
        .update_coef(coef)
        !
        ! compute the squared norm of the wavefunction
        .calc_overlap_integral(overlap)
        .overlap = overlap
     end !if
     
     ! compute the 2RDM
     ! (and save info. to compute the energy gradient)
     .calc_2rdm_gen_grd

     ! compute the energy gradient
     .calc_energy_gradient(grad=grad, wrt_arg=FALSE)

     ! compute the gradient norm
     .coef_opt_info.grd_norm = grad.norm

     ! ".coef_opt_info.new_iter" indicates when a new iteration
     ! of the optimization has started
     .coef_opt_info.new_iter = TRUE

   end
! this is for debug
!   gradient_gem(coef) result(grad) ::: selfless
!   ! compute the energy gradient with respec to the block
!   ! coefficients "coef"
!     coef :: VEC{REAL}, IN
!     grad :: VEC{REAL}(size(coef))
!     !
!     self :: PAULI_BLOCK_GEMINALS*
!     overlap :: REAL
!     update :: BIN
!     !
!     !!!
!     counter :: INT, save = 0
!     stdout.text(" ")
!     counter = counter+1
!     stdout.show("Entering function gradient_gem(coef)",counter)
!     !stdout.text("Entering function gradient(coef)")
!     stdout.text(" ")
!     stdout.flush
!     !!!
!!     if (counter == 5) stop 
!     !!!
!
!     self => pbg_saved
!
!     ! check if "coef" and (nonzero) ".bra_set.vec(:).coef" 
!     ! differ or not
!     .check_coef(coef, update)
!
!     if (update) then
!        !
!        ! update objects used to compute the energy
!        .update_coef(coef)
!        !
!        ! compute the squared norm of the wavefunction
!        .calc_overlap_integral(overlap)
!        .overlap = overlap
!!        !
!!        ! compute the 2RDM
!!        .calc_2rdm_gen_grd
!     end
!     
!     ! compute the 2RDM
!     ! (and save info. to compute the energy gradient)
!     !!! debug
!!     stdout.text("before calling calc_2rdm_gen_grd")
!     stdout.text("call calc_2rdm_gen_grd")
!     stdout.flush
!     !!!
!     .calc_2rdm_gen_grd
!     !!! debug
!!     stdout.text("after calling calc_2rdm_gen_grd")
!     stdout.text("call calc_2rdm_gen_grd, completed")
!     stdout.flush
!!     stop
!     !!!
!
!     !!! debug
!!     stdout.text("coef array before new calculation:")
!!     stdout.show("size =", size(coef))
!!     stdout.show("elements =", coef)
!!     stdout.flush
!!     stdout.text("gradient array before new calculation:")
!!     stdout.show("size =", size(grad))
!!     stdout.show("elements =", grad)
!!     stdout.flush
!     !!!
!
!     ! compute the energy gradient
!     !!! debug
!!     stdout.text("calling calc_energy_gradient")
!     stdout.text("call calc_energy_gradient")
!     stdout.flush
!!     stdout.text(" ")
!!     stdout.text("gradient array before new calculation:")
!!     stdout.flush
!!     stdout.show("size =", size(grad))
!!     stdout.show("elements =", grad)
!!     stdout.flush
!     !!!
!     .calc_energy_gradient(grad=grad, wrt_arg=FALSE)
!!     .calc_energy_gradient(grad)
!     !!! debug
!!     stdout.text("gradient array after new calculation:")
!     stdout.text("call calc_energy_gradient, completed")
!     stdout.flush
!!     stop
!!     stdout.show("size =", size(grad))
!!     stdout.show("elements =", grad)
!     !!!
!
!     ! compute the gradient norm
!     !!! debug
!!     stdout.text("computing gradient norm")
!     stdout.text("compute gradient norm")
!     stdout.flush
!     !!!
!     .coef_opt_info.grd_norm = grad.norm
!     !!! debug
!     stdout.text("compute gradient norm, completed")
!     stdout.flush
!     !!!
!
!!     ! ".coef_opt_info.iter" indicates the number of the current
!!     ! iteration
!!     .coef_opt_info.iter = .coef_opt_info.iter+1
!
!     ! ".coef_opt_info.new_iter" indicates when a new iteration
!     ! of the optimization has started
!     .coef_opt_info.new_iter = TRUE
!
!     !!! debug
!!     stdout.text("exiting function gradient_gem") 
!     stdout.text("exit function gradient_gem") 
!     !!!
!!     stop
!
!   end
!!!!!!!!!!!!!!!!!!!!!!
   check_coef(coef, differ_coef)
   ! check if "coef" and nonzero coefficients in "bra_set.vec(:).coef"
   ! are the same; if not, set "differ_coef" to TRUE
     coef :: VEC{REAL}, IN
     differ_coef :: BIN, INOUT
     i, j, k :: INT
     n_nonzero_coef :: INT
     counter :: INT
     diffc :: REAL
     !!!
!     stdout.text(" ")
!     stdout.text("Entering routine check_coef")
     !!!

     differ_coef = FALSE
     counter = 0
     do i=1,.n_geminals
        n_nonzero_coef = size(.bra_set.vec(i).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           k = .bra_set.vec(i).new_nonzero_coef_ind(j)
           counter = counter+1
           diffc = coef(counter)-.bra_set.vec(i).coef(k)
           if (abs(diffc) > TOL(15)) then
              differ_coef = TRUE
!              stdout.text("Coef has to be updated before computing the gradient")
              return
           end
        end
     end

!     if (NOT differ_coef) then
!        stdout.text(" ")
!        stdout.text("Coef is up-to-date")
!     end

   end


! davide: 19/10/2019 - 20/04/2020
   calc_energy_gradient(grad, wrt_arg)
   ! compute the energy gradient with respect to the block
   ! coefficients
     grad :: VEC{REAL}, INOUT, optional
     wrt_arg :: BIN, IN, optional
     !
     siz, g, b, i, j, block :: INT
     integrals :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     wrt :: BIN
     n_nonzero_coef :: INT
     ! DEBUGG
     i1, j1, i2, j2 :: INT
     nt , k :: INT
     j3, j4 :: INT
     c, k1, k2, k3, k4 :: INT
     !!!
!     stdout.text(" ")
!     stdout.text("Starting calculation of the energy gradient")
!     stdout.text("(entering subroutine calc_energy_gradient)")
!     stdout.text(" ")
     !!!

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     ! check if the bra set is equal to the ket set;
     ! if not, stop the program execution
     if (NOT .bra_is_ket) then
        stdout.text("Bra is not equal to ket:")
        stdout.text("calculation of the energy gradient")
        stdout.text("not implemented yet, for this case.")
        stop
     end

     ! store and read in the integrals
     eri_archive.set(.name,"h_integrals")
     integrals.create(.mat_size,.mat_size,.mat_size,.mat_size)
     eri_archive.read(integrals)

     !!! debug (new)
  if (.debug) then
     stdout.text("2RDM alpha/beta nonzero elements:")
     stdout.show("Number of nonzero elements =",.nonzero_terms_ab)
     c = 0
     do j1=1,.mat_size
        do j2=1,.mat_size
           do j3=1,.mat_size
              do j4=1,.mat_size
                 do j=1,.nonzero_terms_ab
                    k1 = .rdm_2_ab(j).indices(1)
                    k2 = .rdm_2_ab(j).indices(2)
                    k3 = .rdm_2_ab(j).indices(3)
                    k4 = .rdm_2_ab(j).indices(4)
                    if (j1==k1 AND j2==k2 AND j3==k3 AND j4==k4) then
                       c = c + 1
                       stdout.text(" ")
                       stdout.show("counter",c)
                       stdout.show("element",j)
                       stdout.show("indices",.rdm_2_ab(j).indices)
                       stdout.show("coefficient",.rdm_2_ab(j).coefficient)
                       nt = .rdm_2_ab_grad_info(j).nb_terms
                       stdout.show("number of terms =",nt)
                       stdout.show("coef_prod",.rdm_2_ab_grad_info(j).coef_prod)
                       stdout.show("red_overlap",.rdm_2_ab_grad_info(j).red_ov)
                       stdout.text("excluded geminals")
                       do k=1,nt
                          stdout.show("geminals",.rdm_2_ab_grad_info(j).ex_gem(k).element)
                       end
                       stdout.text("excluded blocks")
                       do k=1,nt
                          stdout.show("blocks",.rdm_2_ab_grad_info(j).ex_blk(k).element)
                       end
                       !!!
                       nt = .rdm_2_ab_grad_info(j).nb_GD2_terms
                       stdout.show("number of GD2 terms =",nt)
                       if (nt > 0) then 
                          stdout.show("GD2 terms indices",.rdm_2_ab_grad_info(j).GD2_terms)
                          stdout.show("GD2 coef. prod.",.rdm_2_ab_grad_info(j).GD2_cpr)
                          stdout.text("GD2 blocks")
                          do k=1,nt
                             stdout.show("blocks",.rdm_2_ab_grad_info(j).GD2_blk(k).element)
                          end
                          stdout.text("GD2 cases")
                          do k=1,nt
                             stdout.show("cases",.rdm_2_ab_grad_info(j).GD2_cas(k).element)
                          end
                       end
                       !!!
                       stdout.text(" ")
                       exit
                    end
                 end
              end
           end
        end
     end
  end !!! debug
!  !!! debug (old)
!  if (.debug) then
!     stdout.text("2RDM alpha/beta nonzero elements:")
!     stdout.show("Number of nonzero elements =",.nonzero_terms_ab)
!     do j=1,.nonzero_terms_ab
!        stdout.text(" ")
!        stdout.show("indices",.rdm_2_ab(j).indices)
!        stdout.show("coefficient",.rdm_2_ab(j).coefficient)
!        !!!
!!        i1 = .rdm_2_ab(j).indices(1)
!!        j1 = .rdm_2_ab(j).indices(2)
!!        i2 = .rdm_2_ab(j).indices(3)
!!        j2 = .rdm_2_ab(j).indices(4)
!!        stdout.show("2-el. integral",integrals(i1,j1,i2,j2))
!        nt = .rdm_2_ab_grad_info(j).nb_terms
!        stdout.show("number of terms =",nt)
!        stdout.show("coef_prod",.rdm_2_ab_grad_info(j).coef_prod)
!        stdout.show("red_overlap",.rdm_2_ab_grad_info(j).red_ov)
!        if (.rdm_2_ab_grad_info(j).ex_gem_created) then
!           stdout.text("excluded geminals")
!           do k=1,nt
!              stdout.show("geminals",.rdm_2_ab_grad_info(j).ex_gem(k).element)
!           end
!        end
!        if (.rdm_2_ab_grad_info(j).ex_blk_created) then
!           stdout.text("excluded blocks")
!           do k=1,nt
!              stdout.show("blocks",.rdm_2_ab_grad_info(j).ex_blk(k).element)
!           end
!        end
!        stdout.text(" ")
!        !!!
!     end
!  end !!! debug
!     stdout.text(" ")
!     stdout.text("2RDM alpha/alpha nonzero elements:")
!     stdout.show("Number of nonzero elements =",.nonzero_terms_aa)
!     do j=1,.nonzero_terms_aa
!        stdout.text(" ")
!        stdout.show("indices",.rdm_2_aa(j).indices)
!        stdout.show("coefficient",.rdm_2_aa(j).coefficient)
!     end
!     stdout.text(" ")
!     stdout.text("2RDM beta/beta nonzero elements:")
!     stdout.show("Number of nonzero elements =",.nonzero_terms_bb)
!     do j=1,.nonzero_terms_bb
!        stdout.text(" ")
!        stdout.show("indices",.rdm_2_bb(j).indices)
!        stdout.show("coefficient",.rdm_2_bb(j).coefficient)
!     end
     !!!

     ! set the maximum size of the energy gradient vector
     ! (according to the model constraints)
     if (.opt_GD2_angles) then
        siz = .n_1D_blocks+4*.n_2D_3typ_blocks+4*.n_2D_4typ_blocks
     else
        siz = .n_1D_blocks+3*.n_2D_3typ_blocks+4*.n_2D_4typ_blocks
     end
     ! create energy gradient vector
     ! (if not created yet or the size of 
     ! the existing one is different from "siz")
     if (NOT .energy_gradient.created) then
        .create(.energy_gradient, siz)
     else if (size(.energy_gradient) /= siz) then
        .destroy(.energy_gradient)
        .create(.energy_gradient, siz)
     end
     !
     ! compute the energy gradient
     ! elements w.r.t. the block coefficients
     ! ("i" is the index of the gradient element)
     !
     i = 1
     do g=1,.n_geminals
        n_nonzero_coef = size(.bra_set.vec(g).new_nonzero_coef_ind)
        do j=1,n_nonzero_coef
           b = .bra_set.vec(g).new_nonzero_coef_ind(j)
           ! compute the energy derivative with respect to the coefficient of
           ! geminal "g" associated with block "b"
           .calc_energy_grad_elt(g,b,i,integrals)
           i = i+1
        end
     end
     !
     ! compute the energy gradient
     ! elements w.r.t. the GD2 angles
     ! (if requested)
     !
     if (.opt_GD2_angles) then
        do b=1,.n_2D_3typ_blocks
           ! compute the energy derivative with respect 
           ! to the GD2 angle of 3-type block "b"
           .calc_energy_grad_elt_gd2(b,i,integrals)
           i = i+1
        end
     end

     ! destroy matrix of integrals
     integrals.destroy

     ! set the effective size of the energy gradient
     ! (i.e. the number of computed element)
     siz = i-1

     ! write results
     if (wrt) then
        stdout.text(" ")
        stdout.text("Energy gradient:")
        if (present(grad)) then
           do j=1,siz
              stdout.text(" ")
              stdout.show("element indices",.energy_gradient(j).indices)
              grad(j) = .energy_gradient(j).elt
              stdout.show("element value",.energy_gradient(j).elt)
           end
        else
           do j=1,siz
              stdout.text(" ")
              stdout.show("element indices",.energy_gradient(j).indices)
              stdout.show("element value",.energy_gradient(j).elt)
           end
        end
        stdout.text(" ")
     end

     ! copy energy gradient to array "grad"
     ! (if the latter is provided as argument)
     if (present(grad)) then
        do j=1,siz
           grad(j) = .energy_gradient(j).elt
        end
     end

   end

!   calc_energy_grad_elt(g, b, i, integrals)
!   ! compute the derivative of the energy with respect to the
!   ! coefficient of geminal "g" associated with block "b"
!   ! (i.e. element "i" of the energy gradient with respect to the
!   ! block coefficients)
!     g, b, i :: INT, IN
!     integrals :: MAT4{REAL}, IN
!     j, k, l, m, nt :: INT
!     i_gem, i_blk, i_factor :: INT
!     factor :: REAL
!     g_in_ex_gem, b_in_ex_blk :: BIN
!     ene_deriv, rdm2_deriv :: REAL 
!     coef, cpr, rov :: REAL
!     i1, j1, i2, j2 :: INT
!     red_pbg :: PAULI_BLOCK_GEMINALS
!     gg :: VEC{INT}(1)
!     ng_1, i_rdm2 :: INT
!     dum :: REAL
!     nonzero_elt :: VEC{INT}(3)
!     rdm2_type :: VEC{STR}(3)
!     indices :: VEC{INT}(4)
!     !!! debug
!!     stdout.text(" ")
!!     stdout.text("Entering subroutine calc_energy_grad_elt")
!!     stdout.text(" ")
!     !!!
!
!     coef = .bra_set.vec(g).coef(b)
!     ! check if the block coefficient "coef" (for which the derivative 
!     ! has to be computed) is nonzero; if it is zero or very small,
!     ! set the energy derivative to zero and exit the subroutine
!     if (abs(coef) < TOL(15)) then
!        ! set the value of the energy derivative
!        .energy_gradient(i).elt = ZERO
!        ! save the indices of the gradient element
!        .energy_gradient(i).indices(1) = g
!        .energy_gradient(i).indices(2) = b
!        return
!     end
!     ! create object to store temporary information for the
!     ! calculation of the energy gradient with respect to 
!     ! the block coefficients (if not created yet)
!     if (NOT .grad_info_tmp.coef_prod.created) then
!        nt = 18
!        !nt = 10
!        .create_2rdm_grad_info_tmp(nt)
!     end
!     !
!     ! build array of 2RDM types
!     ! (i.e. alpha/beta, alpha/alpha, beta/beta)
!     ! and of numbers of nonzero 2RDM elements
!     !
!     rdm2_type(1) = "ab"
!     rdm2_type(2) = "aa"
!     rdm2_type(3) = "bb"
!     nonzero_elt(1) = .nonzero_terms_ab
!     nonzero_elt(2) = .nonzero_terms_aa
!     nonzero_elt(3) = .nonzero_terms_bb
!     !
!     ! start the calculation of the energy derivative
!     !
!     ene_deriv = ZERO
!     do i_rdm2=1,3 
!        !
!        ! compute contribution (to the energy derivative) from the 2RDM
!        ! "rdm2_type"
!        !
!        do j=1,nonzero_elt(i_rdm2)
!           !!! debug
!!           stdout.text(" ")
!!           stdout.show("2RDM derivative",rdm2_type(i_rdm2))
!           !!!
!           !
!           ! compute the derivative of one element of the 2RDM
!           !
!           rdm2_deriv = ZERO
!           ! copy info. about the 2RDM element "j" to ".grad_info_tmp"
!           ! and the indices of the 2RDM element "j" to "indices"
!           .copy_2rdm_grad_info(irdm=j, rdm2_type=rdm2_type(i_rdm2), rdm2_ind=indices)
!           ! set number of terms
!           nt = .grad_info_tmp.nb_terms
!           do k=1,nt
!              ! check if geminal "g" is present in vector "ex_gem(k)"
!              g_in_ex_gem = any(.grad_info_tmp.ex_gem(k).element == g)
!              ! check if block "b" is present in vector "ex_blk(k)"
!              b_in_ex_blk = any(.grad_info_tmp.ex_blk(k).element == b)
!              ! select the case (A or B), else the term is zero
!              if (g_in_ex_gem AND b_in_ex_blk) then
!                 !
!                 ! case A: "coef" may be present in the product of coefficients
!                 !
!                 ! check if coefficient "coef" is present in the product of
!                 ! coefficient of term "k"; if present, compute one term
!                 ! of the derivative
!                 if (.grad_info_tmp.all_pairs(k)) then
!                    outer: do l=1,2
!                       inner: do m=1,2
!                          i_gem = .grad_info_tmp.ex_gem(k).element(l)
!                          i_blk = .grad_info_tmp.ex_blk(k).element(m)
!                          if (g == i_gem AND b == i_blk) then
!                             ! in this case the multiplication factor
!                             ! is always ONE, so it is omitted
!                             !
!                             ! product of coefficients
!                             cpr = .grad_info_tmp.coef_prod(k) 
!                             ! reduced overlap
!                             rov = .grad_info_tmp.red_ov(k)
!                             ! compute the contribution to the element of the 2RDM derivative
!                             rdm2_deriv = rdm2_deriv + rov*cpr/coef
!                             !rdm2_deriv = rdm2_deriv + rov*cpr*factor/coef
!                             ! exit the outer loop
!                             exit outer
!                          end if
!                       end do inner
!                    end do outer
!                 else
!                    do l=1,2
!                       i_gem = .grad_info_tmp.ex_gem(k).element(l)
!                       i_blk = .grad_info_tmp.ex_blk(k).element(l)
!                       if (g == i_gem AND b == i_blk) then
!                          ! multiplication factor (= ONE or TWO)
!                          factor = real(.grad_info_tmp.factor(k).element(l), 8)
!                          !!! debug
!!                          stdout.show("mult.factor",factor)
!                          !!!
!                          ! product of coefficients
!                          cpr = .grad_info_tmp.coef_prod(k) 
!                          ! reduced overlap
!                          rov = .grad_info_tmp.red_ov(k)
!                          ! compute the contribution to the element of the 2RDM derivative
!                          rdm2_deriv = rdm2_deriv + rov*cpr*factor/coef
!                          ! exit the loop
!                          exit
!                       end
!                    end
!                 end
!              else if (NOT g_in_ex_gem AND NOT b_in_ex_blk) then
!                 !
!                 ! case B: "coef" is in the reduced overlap
!                 !
!                 ! product of coefficients
!                 cpr = .grad_info_tmp.coef_prod(k) 
!                 ! two subcases (depending on the block size)
!                 if (b <= .n_1D_blocks) then 
!                    !
!                    ! block "b" is of size 1
!                    !
!                    ! compute the new reduced overlap ("rov")
!                    .calc_new_red_overlap(iterm=k, gem=g, red_overlap=rov)
!                    !!! debug
!!                    stdout.show("New reduced overlap =", rov) 
!                    !!!
!                    ! compute the contribution to the element of the 2RDM derivative
!                    rdm2_deriv = rdm2_deriv + TWO*rov*cpr*coef
!                 else
!                    !
!                    ! block "b" is of size 2
!                    !
!                    ! compute the new reduced overlap ("rov")
!                    .calc_new_red_overlap(iterm=k, gem=g, blk=b, red_overlap=rov)
!                    !!! debug
!!                    stdout.show("New reduced overlap =", rov) 
!                    !!!
!                    ! compute the contribution to the element of the 2RDM derivative
!                    rdm2_deriv = rdm2_deriv + FOUR*rov*cpr*coef
!                 end
!              end
!           end
!           ! compute the contribution to the energy gradient element
!           ! (using the appropriate integral)
!           i1 = indices(1)
!           j1 = indices(2)
!           i2 = indices(3)
!           j2 = indices(4)
!           !!! debug
!!           stdout.show("indices", indices)
!!           stdout.show("element", rdm2_deriv)
!           !!!
!           select case (i_rdm2)
!           case(1)
!              ! 2RDM alpha/beta
!              ene_deriv = ene_deriv + rdm2_deriv*integrals(i1,j1,i2,j2)
!           case(2,3)
!              ! 2RDM alpha/alpha or beta/beta
!              ene_deriv = ene_deriv + rdm2_deriv*(integrals(i1,j1,i2,j2)-integrals(i1,j1,j2,i2))
!           case default
!              stdout.text("Error in routine calc_energy_grad_elt:")
!              stdout.text("unknown integer to select the 2RDM part.")
!              stop
!           end
!        end
!     end
!
!     ! compute the reduced overlap, excluding geminal "g"
!     ! (this is to include in the energy derivative the 
!     ! contribution from the norm of the wavefunction) 
!     ng_1 = .n_geminals-1
!     if (ng_1 > 0) then
!        !!! debug
!!        stdout.text("computing new reduced overlap") 
!        !!!
!        gg(1) = g
!        .prep_red_pbg_gg(red_pbg, gg, 1)
!        red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
!        red_pbg.calc_overlap_integral(rov,FALSE)
!     else
!        rov = ONE
!     end
!
!     !!! debug
!!     stdout.show("geminal",g)
!!     stdout.show("block",b)
!!     stdout.show("Numerator derivative =",ene_deriv)
!!     stdout.show("Electronic energy =",.electronic_energy)
!!     stdout.show("Coefficient =",coef)
!!     stdout.show("Reduced overlap =",rov)
!!     dum = TWO*coef*rov*.electronic_energy
!     !!!
!     ! compute the final value of the energy derivative
!     ! (including the contribution from the norm) 
!     if (b <= .n_1D_blocks) then 
!        ! block "b" is of size 1
!        ene_deriv = ene_deriv - TWO*coef*rov*.electronic_energy
!     else
!        ! block "b" is of size 2
!        ene_deriv = ene_deriv - FOUR*coef*rov*.electronic_energy
!        !!! debug
!!        dum = dum*TWO
!        !!!
!     end
!     !!! debug
!!     stdout.show("Norm contribution =",dum)
!     !!!
!
!     ! store the value of the energy derivative
!     .energy_gradient(i).elt = ene_deriv
!     ! store the indices of the gradient element
!     .energy_gradient(i).indices(1) = g
!     .energy_gradient(i).indices(2) = b
!      
!   end

   calc_energy_grad_elt(g, b, i, integrals)
   ! compute the derivative of the energy with respect to the
   ! coefficient of geminal "g" associated with block "b"
   ! (i.e. element "i" of the energy gradient with respect to the
   ! block coefficients)
     g, b, i :: INT, IN
     integrals :: MAT4{REAL}, IN
     j, k, l, m, nt :: INT
     i_gem, i_blk, i_factor :: INT
     factor :: REAL
     g_in_ex_gem, b_in_ex_blk :: BIN
     ene_deriv, rdm2_deriv :: REAL 
     coef, cpr, rov :: REAL
     i1, j1, i2, j2 :: INT
     red_pbg :: PAULI_BLOCK_GEMINALS
     !gg :: VEC{INT}(1)
     !!!
     gg, bb :: VEC{INT}(1)
     problem :: BIN
     ove_deriv :: REAL
     !!!
     ng_1, i_rdm2 :: INT
     dum :: REAL
     nonzero_elt :: VEC{INT}(3)
     rdm2_type :: VEC{STR}(3)
     indices :: VEC{INT}(4)
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine calc_energy_grad_elt")
!     stdout.text(" ")
     !!!
     !!!
!     stdout.text(" ")
!     stdout.text("Coefficient")
!     stdout.show("geminal", g)
!     stdout.show("block  ", b)
     !!!

     coef = .bra_set.vec(g).coef(b)
     ! check if the block coefficient "coef" (for which the derivative 
     ! has to be computed) is nonzero; if it is zero or very small,
     ! set the energy derivative to zero and exit the subroutine
     if (abs(coef) < TOL(15)) then
        ! set the value of the energy derivative
        .energy_gradient(i).elt = ZERO
        ! save the indices of the gradient element
        .energy_gradient(i).indices(1) = g
        .energy_gradient(i).indices(2) = b
        return
     end
     ! create object to store temporary information for the
     ! calculation of the energy gradient with respect to 
     ! the block coefficients (if not created yet)
     if (NOT .grad_info_tmp.coef_prod.created) then
        nt = 18
        !nt = 10
        .create_2rdm_grad_info_tmp(nt)
     end
     !
     ! build array of 2RDM types
     ! (i.e. alpha/beta, alpha/alpha, beta/beta)
     ! and of numbers of nonzero 2RDM elements
     !
     rdm2_type(1) = "ab"
     rdm2_type(2) = "aa"
     rdm2_type(3) = "bb"
     nonzero_elt(1) = .nonzero_terms_ab
     nonzero_elt(2) = .nonzero_terms_aa
     nonzero_elt(3) = .nonzero_terms_bb
     !
     ! start the calculation of the energy derivative:
     ! compute the derivative of the expectation value 
     ! of the electronic hamiltonian (i.e. the numerator 
     ! in the energy formula)
     !
     ene_deriv = ZERO
     do i_rdm2=1,3 
        !
        ! compute the derivative of the 2RDM (type "rdm2_type")
        !
        !!! debug
!        stdout.text(" ")
!        stdout.show("2RDM derivative",rdm2_type(i_rdm2))
        !!!
        do j=1,nonzero_elt(i_rdm2)
           !
           ! compute the derivative of one element of the 2RDM
           !
           rdm2_deriv = ZERO
           ! copy info. about the 2RDM element "j" to ".grad_info_tmp"
           ! and the indices of the 2RDM element "j" to "indices"
           .copy_2rdm_grad_info(irdm=j, rdm2_type=rdm2_type(i_rdm2), rdm2_ind=indices)
           !!! debug
!           stdout.text(" ")
!           stdout.show("element", j)
!           stdout.show("indices", indices)
           !!!
           ! set number of terms
           nt = .grad_info_tmp.nb_terms
           do k=1,nt
              ! check if geminal "g" is present in vector "ex_gem(k)"
              g_in_ex_gem = any(.grad_info_tmp.ex_gem(k).element == g)
              ! check if block "b" is present in vector "ex_blk(k)"
              b_in_ex_blk = any(.grad_info_tmp.ex_blk(k).element == b)
              ! select the case (A or B), else the term is zero
              if (g_in_ex_gem AND b_in_ex_blk) then
                 !!! debug
!                 stdout.text("Selected case A: coef may be present in the product of coefficients")
                 !!!
                 !
                 ! case A: "coef" may be present in the product of coefficients
                 !
                 ! check if coefficient "coef" is present in the product of
                 ! coefficient of term "k"; if present, compute one term
                 ! of the derivative
                 if (.grad_info_tmp.all_pairs(k)) then
                    outer: do l=1,2
                       inner: do m=1,2
                          i_gem = .grad_info_tmp.ex_gem(k).element(l)
                          i_blk = .grad_info_tmp.ex_blk(k).element(m)
                          if (g == i_gem AND b == i_blk) then
                             ! in this case the multiplication factor
                             ! is always ONE, so it is omitted
                             !
                             ! product of coefficients
                             cpr = .grad_info_tmp.coef_prod(k) 
                             ! reduced overlap
                             rov = .grad_info_tmp.red_ov(k)
                             ! compute the contribution to the element of the 2RDM derivative
                             rdm2_deriv = rdm2_deriv + rov*cpr/coef
                             !rdm2_deriv = rdm2_deriv + rov*cpr*factor/coef
                             ! exit the outer loop
                             exit outer
                          end if
                       end do inner
                    end do outer
                 else
                    do l=1,2
                       i_gem = .grad_info_tmp.ex_gem(k).element(l)
                       i_blk = .grad_info_tmp.ex_blk(k).element(l)
                       if (g == i_gem AND b == i_blk) then
                          ! multiplication factor (= ONE or TWO)
                          factor = real(.grad_info_tmp.factor(k).element(l), 8)
                          !!! debug
!                          stdout.show("mult.factor",factor)
                          !!!
                          ! product of coefficients
                          cpr = .grad_info_tmp.coef_prod(k) 
                          ! reduced overlap
                          rov = .grad_info_tmp.red_ov(k)
                          ! compute the contribution to the element of the 2RDM derivative
                          rdm2_deriv = rdm2_deriv + rov*cpr*factor/coef
                          ! exit the loop
                          exit
                       end
                    end
                 end
              else if (NOT g_in_ex_gem AND NOT b_in_ex_blk) then
                 !!! debug
!                 stdout.text("Selected case B: coef is in the reduced overlap")
                 !!!
                 !
                 ! case B: "coef" is in the reduced overlap
                 !
                 ! product of coefficients
                 cpr = .grad_info_tmp.coef_prod(k) 
                 ! two subcases (depending on the block size)
                 if (b <= .n_1D_blocks) then 
                    !
                    ! block "b" is of size 1
                    !
                    ! compute the new reduced overlap ("rov")
                    .calc_new_red_overlap(iterm=k, gem=g, red_overlap=rov)
                    !!! debug
!                    stdout.show("New reduced overlap =", rov)
                    !!!
                    ! compute the contribution to the element of the 2RDM derivative
                    rdm2_deriv = rdm2_deriv + TWO*rov*cpr*coef
                 else
                    !
                    ! block "b" is of size 2
                    !
                    ! compute the new reduced overlap ("rov")
                    .calc_new_red_overlap(iterm=k, gem=g, blk=b, red_overlap=rov)
                    !!! debug
!                    stdout.show("New reduced overlap =", rov)
                    !!!
                    ! compute the contribution to the element of the 2RDM derivative
                    rdm2_deriv = rdm2_deriv + FOUR*rov*cpr*coef
                 end
              end
           end
           !!! debug
!           stdout.show("derivative =", rdm2_deriv)
           !!!
           ! compute the contribution to the energy gradient element
           ! (using the appropriate integral)
           i1 = indices(1)
           j1 = indices(2)
           i2 = indices(3)
           j2 = indices(4)
           select case (i_rdm2)
           case(1)
              ! 2RDM alpha/beta
              ene_deriv = ene_deriv + rdm2_deriv*integrals(i1,j1,i2,j2)
           case(2,3)
              ! 2RDM alpha/alpha or beta/beta
              ene_deriv = ene_deriv + rdm2_deriv*(integrals(i1,j1,i2,j2)-integrals(i1,j1,j2,i2))
           case default
              stdout.text("Error in routine calc_energy_grad_elt:")
              stdout.text("unknown integer to select the 2RDM part.")
              stop
           end
        end
     end

     ! compute the derivative of the square norm 
     ! of the wavefunction (i.e. of .overlap)
     rov = ONE
     if (.n_geminals > 1) then
        if (b <= .n_1D_blocks) then 
           ! "b" is a 1D block:
           ! compute the reduced overlap, 
           ! excluding geminal "g"
           gg(1) = g
           .prep_red_pbg_gg(red_pbg, gg, 1)
           red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg.calc_overlap_integral(rov,FALSE)
           ove_deriv = TWO*coef*rov
        else
           ! "b" is a 2D block:
           ! compute the reduced overlap, 
           ! excluding geminal "g" and block "b"
           gg(1) = g
           bb(1) = b
           .prep_red_pbg_gg_bb(red_pbg, gg, 1, bb, 1, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
              red_pbg.calc_overlap_integral(rov,FALSE)
           else
              rov = ZERO
           end
           ove_deriv = FOUR*coef*rov
        end
     else
        if (b <= .n_1D_blocks) then 
           ! "b" is a 1D block
           ove_deriv = TWO*coef 
        else
           ! "b" is a 2D block
           ove_deriv = FOUR*coef 
        end
     end

     !!! debug
!     stdout.text(" ")
!     stdout.show("geminal",g)
!     stdout.show("block",b)
!     stdout.show("Numerator derivative =",ene_deriv)
!     stdout.show("Electronic energy =",.electronic_energy)
!     stdout.show("Coefficient =",coef)
!     stdout.show("Reduced overlap =",rov)
!     stdout.show("Overlap derivative =", ove_deriv)
     !!!
     !
     ! compute the final value of the energy derivative
     ! (including the contribution from the wfu norm) 
     ene_deriv = (ene_deriv - .electronic_energy*ove_deriv)/.overlap
     !
     !!! debug
!     stdout.show("Energy gradient element =",ene_deriv)
     !!!

     ! store the value of the energy derivative
     .energy_gradient(i).elt = ene_deriv
     ! store the indices of the gradient element
     .energy_gradient(i).indices(1) = g
     .energy_gradient(i).indices(2) = b

   end

   calc_energy_grad_elt_gd2(b, i, integrals)
   ! compute the derivative of the energy with 
   ! respect to the GD2 angle of 3-type block "b"
   ! (i.e. element "i" of the energy gradient)
     b, i :: INT, IN
     integrals :: MAT4{REAL}, IN
     j, k, l, m :: INT
     nt, nt_gd2 :: INT
     blk1, blk2 :: INT
     cas1, cas2 :: INT
     i_rdm2 :: INT
     nonzero_elt :: VEC{INT}(3)
     rdm2_type :: VEC{STR}(3)
     indices :: VEC{INT}(4)
     i1, j1, i2, j2 :: INT
     ene_deriv, rdm2_deriv :: REAL 
     fact1, fact2, cpr, rov :: REAL
     siz :: VEC{INT}(18)

     ! create object to store temporary information for the
     ! calculation of the energy gradient with respect to 
     ! the GD2 angles (if not created yet)
     if (NOT .grad_info_tmp.coef_prod.created) then
        nt = 18
        !nt = 10
        .create_2rdm_grad_info_tmp(nt)
     end
     !
     ! build array of 2RDM types
     ! (i.e. alpha/beta, alpha/alpha, beta/beta)
     ! and of numbers of nonzero 2RDM elements
     !
     rdm2_type(1) = "ab"
     rdm2_type(2) = "aa"
     rdm2_type(3) = "bb"
     nonzero_elt(1) = .nonzero_terms_ab
     nonzero_elt(2) = .nonzero_terms_aa
     nonzero_elt(3) = .nonzero_terms_bb
     !
     ! start the calculation of the energy derivative
     !
     ene_deriv = ZERO
     do i_rdm2=1,3 
        !
        ! compute contribution (to the energy derivative) from the 2RDM
        ! "rdm2_type"
        !
        do j=1,nonzero_elt(i_rdm2)
           !
           ! compute the derivative of one element of the 2RDM
           !
           rdm2_deriv = ZERO
           ! copy info. about the 2RDM element "j" to ".grad_info_tmp"
           ! and the indices of the 2RDM element "j" to "indices"
           .copy_2rdm_grad_info(irdm=j, rdm2_type=rdm2_type(i_rdm2), rdm2_ind=indices, gd2_info_arg=TRUE, gd2_siz=siz)
           ! set number of terms
           ! which depend on GD2 angles
           nt_gd2 = .grad_info_tmp.nb_GD2_terms
           do k=1,nt_gd2
              cpr = .grad_info_tmp.GD2_cpr(k)
              m = .grad_info_tmp.GD2_terms(k)
              rov = .grad_info_tmp.red_ov(m)
              select case (siz(k))
                 case (1)
                    blk1 = .grad_info_tmp.GD2_blk(k).element(1)
                    if (b == blk1) then
                       cas1 = .grad_info_tmp.GD2_cas(k).element(1)
                       ! multiplication factor needed to
                       ! compute the derivative
                       fact1 = .gd2_deri_factor(blk1, cas1)
                       !
                       rdm2_deriv = rdm2_deriv + cpr*rov*fact1
                    end
                 case (2)
                    blk1 = .grad_info_tmp.GD2_blk(k).element(1)
                    blk2 = .grad_info_tmp.GD2_blk(k).element(2)
                    if (b == blk1) then
                       cas1 = .grad_info_tmp.GD2_cas(k).element(1)
                       cas2 = .grad_info_tmp.GD2_cas(k).element(2)
                       ! multiplication factors needed to
                       ! compute the derivative
                       fact1 = .gd2_deri_factor(blk1, cas1)
                       fact2 = .gd2_mult_factor(blk2, cas2)
                       !
                       rdm2_deriv = rdm2_deriv + cpr*rov*fact1*fact2
                    else if (b == blk2) then
                       cas1 = .grad_info_tmp.GD2_cas(k).element(1)
                       cas2 = .grad_info_tmp.GD2_cas(k).element(2)
                       ! multiplication factors needed to
                       ! compute the derivative
                       fact1 = .gd2_deri_factor(blk2, cas2)
                       fact2 = .gd2_mult_factor(blk1, cas1)
                       !
                       rdm2_deriv = rdm2_deriv + cpr*rov*fact1*fact2
                    end
                 case default
                    stdout.text("Error in routine calc_energy_grad_elt_gd2:")
                    stdout.text("unknown integer to select case.")
                    stop
              end !select
           end
           ! compute the contribution to the energy gradient element
           ! (using the appropriate integral)
           i1 = indices(1)
           j1 = indices(2)
           i2 = indices(3)
           j2 = indices(4)
           select case (i_rdm2)
           case(1)
              ! 2RDM alpha/beta
              ene_deriv = ene_deriv + rdm2_deriv*integrals(i1,j1,i2,j2)
           case(2,3)
              ! 2RDM alpha/alpha or beta/beta
              ene_deriv = ene_deriv + rdm2_deriv*(integrals(i1,j1,i2,j2)-integrals(i1,j1,j2,i2))
           case default
              stdout.text("Error in routine calc_energy_grad_elt_gd2:")
              stdout.text("unknown integer to select the 2RDM part.")
              stop
           end
        end
     end
     ! divide the derivative of <Hel> 
     ! by the wfu square norm
     ene_deriv = ene_deriv/.overlap

     ! store the value of the energy derivative
     .energy_gradient(i).elt = ene_deriv
     ! store the indices of the gradient element
     .energy_gradient(i).indices(1) = 0
     .energy_gradient(i).indices(2) = b
      
   end

   gd2_deri_factor(blk, cas) result(factor)
   ! compute multiplicative factor (derivative of one 
   ! of 5 possible combinations of GD2 elements) 
   ! to calculate the derivative of a term in a given 
   ! 2RDM element w.r.t. a GD2 angle
     blk, cas :: INT, IN
     factor :: REAL
     elt1, elt2 :: REAL
     
     elt1 = .first_GD2_elt(blk)
     elt2 = .second_GD2_elt(blk)

     factor = ZERO
     select case (cas)
     case(1)
        factor = elt2
     case(2)
        factor = -elt1
     case(3)
        factor = TWO*elt1*elt2
     case(4)
        factor = -TWO*elt1*elt2
     case(5)
        factor = (elt2**2 - elt1**2)
     case default
        stdout.text("Error in function gd2_deri_factor:")
        stdout.text("unknown integer to select case.")
        stop
     end

   end

   gd2_mult_factor(blk, cas) result(factor)
   ! compute multiplicative factor (one of 5 possible 
   ! combinations of GD2 elements) to calculate the 
   ! derivative of a term in a given 2RDM element 
   ! w.r.t. a GD2 angle
     blk, cas :: INT, IN
     factor :: REAL
     elt1, elt2 :: REAL
     
     elt1 = .first_GD2_elt(blk)
     elt2 = .second_GD2_elt(blk)

     factor = ZERO
     select case (cas)
     case(1)
        factor = elt1
     case(2)
        factor = elt2
     case(3)
        factor = elt1**2
     case(4)
        factor = elt2**2
     case(5)
        factor = elt1*elt2
     case default
        stdout.text("Error in function gd2_mult_factor:")
        stdout.text("unknown integer to select case.")
        stop
     end

   end
! de

! davide - 11/03/2020
   copy_2rdm_grad_info(irdm, rdm2_type, rdm2_ind, gd2_info_arg, gd2_siz)
   ! copy gradient information of the 2RDM element "irdm", 
   ! type "rdm2_type" to the temporary ".grad_info_tmp";
   ! copy indices of the 2RDM element "irdm" to "rdm2_ind"
     irdm :: INT, IN
     rdm2_type :: STR, IN
     rdm2_ind :: VEC{INT}(4), INOUT
     gd2_info_arg :: BIN, IN, optional
     gd2_siz :: VEC{INT}, optional
     gd2_info :: BIN
     nt, j :: INT
     siz :: INT
     !!!
     nt_gd2 :: INT
     !!!
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine copy_2rdm_grad_info")
!     stdout.text(" ")
     !!!

     if (present(gd2_info_arg)) then
        gd2_info = gd2_info_arg
     else
        gd2_info = FALSE
     end

     select case (rdm2_type)
     case("ab")
        ! set number of terms
        nt = .rdm_2_ab_grad_info(irdm).nb_terms
        .grad_info_tmp.nb_terms = nt
        do j=1,nt
           ! product of coefficients
           .grad_info_tmp.coef_prod(j) = .rdm_2_ab_grad_info(irdm).coef_prod(j)
           ! reduced overlap
           .grad_info_tmp.red_ov(j) = .rdm_2_ab_grad_info(irdm).red_ov(j)
           ! indices of excluded geminals
           siz = size(.rdm_2_ab_grad_info(irdm).ex_gem(j).element)
           .grad_info_tmp.ex_gem(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).ex_gem(j).element(1:siz)
           ! indices of excluded blocks
           siz = size(.rdm_2_ab_grad_info(irdm).ex_blk(j).element)
           .grad_info_tmp.ex_blk(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).ex_blk(j).element(1:siz)
           ! multiplication factors
           siz = size(.rdm_2_ab_grad_info(irdm).factor(j).element)
           .grad_info_tmp.factor(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).factor(j).element(1:siz)
        end
        ! indices of the 2RMD element (i1,j1,i2,j2)
        rdm2_ind = .rdm_2_ab(irdm).indices
        ! additional info. about the product of coefficients
        if (.rdm_2_ab_grad_info(irdm).all_pairs.created) then
           do j=1,nt
              .grad_info_tmp.all_pairs(j) = .rdm_2_ab_grad_info(irdm).all_pairs(j)
           end
        else
           .grad_info_tmp.all_pairs = FALSE
        end
        ! info. for calculation of gradient w.r.t. GD2 angles
        if (gd2_info) then
           nt_gd2 = .rdm_2_ab_grad_info(irdm).nb_GD2_terms
           .grad_info_tmp.nb_GD2_terms = nt_gd2
           if (nt_gd2 > 0) then
              .grad_info_tmp.GD2_terms(1:nt_gd2) = .rdm_2_ab_grad_info(irdm).GD2_terms(1:nt_gd2)
              .grad_info_tmp.GD2_cpr(1:nt_gd2) = .rdm_2_ab_grad_info(irdm).GD2_cpr(1:nt_gd2)
              do j=1,nt_gd2
                 siz = size(.rdm_2_ab_grad_info(irdm).GD2_blk(j).element)
                 gd2_siz(j) = siz
                 .grad_info_tmp.GD2_blk(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).GD2_blk(j).element
                 .grad_info_tmp.GD2_cas(j).element(1:siz) = .rdm_2_ab_grad_info(irdm).GD2_cas(j).element
              end
           end
        end
     case("aa")
        ! set number of terms
        nt = .rdm_2_aa_grad_info(irdm).nb_terms
        .grad_info_tmp.nb_terms = nt
        do j=1,nt
           ! product of coefficients
           .grad_info_tmp.coef_prod(j) = .rdm_2_aa_grad_info(irdm).coef_prod(j)
           ! reduced overlap
           .grad_info_tmp.red_ov(j) = .rdm_2_aa_grad_info(irdm).red_ov(j)
           ! indices of excluded geminals
           siz = size(.rdm_2_aa_grad_info(irdm).ex_gem(j).element)
           .grad_info_tmp.ex_gem(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).ex_gem(j).element(1:siz)
           ! indices of excluded blocks
           siz = size(.rdm_2_aa_grad_info(irdm).ex_blk(j).element)
           .grad_info_tmp.ex_blk(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).ex_blk(j).element(1:siz)
           ! multiplication factors
           siz = size(.rdm_2_aa_grad_info(irdm).factor(j).element)
           .grad_info_tmp.factor(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).factor(j).element(1:siz)
        end
        ! indices of the 2RMD element (i1,j1,i2,j2)
        rdm2_ind = .rdm_2_aa(irdm).indices
        ! additional info. about the product of coefficients
        if (.rdm_2_aa_grad_info(irdm).all_pairs.created) then
           do j=1,nt
              .grad_info_tmp.all_pairs(j) = .rdm_2_aa_grad_info(irdm).all_pairs(j)
           end
        else
           .grad_info_tmp.all_pairs = FALSE
        end
        ! info. for calculation of gradient w.r.t. GD2 angles
        if (gd2_info) then
           nt_gd2 = .rdm_2_aa_grad_info(irdm).nb_GD2_terms
           .grad_info_tmp.nb_GD2_terms = nt_gd2
           if (nt_gd2 > 0) then
              .grad_info_tmp.GD2_terms(1:nt_gd2) = .rdm_2_aa_grad_info(irdm).GD2_terms(1:nt_gd2)
              .grad_info_tmp.GD2_cpr(1:nt_gd2) = .rdm_2_aa_grad_info(irdm).GD2_cpr(1:nt_gd2)
              do j=1,nt_gd2
                 siz = size(.rdm_2_aa_grad_info(irdm).GD2_blk(j).element)
                 gd2_siz(j) = siz
                 .grad_info_tmp.GD2_blk(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).GD2_blk(j).element
                 .grad_info_tmp.GD2_cas(j).element(1:siz) = .rdm_2_aa_grad_info(irdm).GD2_cas(j).element
              end
           end
        end
     case("bb")
        ! set number of terms
        nt = .rdm_2_bb_grad_info(irdm).nb_terms
        .grad_info_tmp.nb_terms = nt
        do j=1,nt
           ! product of coefficients
           .grad_info_tmp.coef_prod(j) = .rdm_2_bb_grad_info(irdm).coef_prod(j)
           ! reduced overlap
           .grad_info_tmp.red_ov(j) = .rdm_2_bb_grad_info(irdm).red_ov(j)
           ! indices of excluded geminals
           siz = size(.rdm_2_bb_grad_info(irdm).ex_gem(j).element)
           .grad_info_tmp.ex_gem(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).ex_gem(j).element(1:siz)
           ! indices of excluded blocks
           siz = size(.rdm_2_bb_grad_info(irdm).ex_blk(j).element)
           .grad_info_tmp.ex_blk(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).ex_blk(j).element(1:siz)
           ! multiplication factors
           siz = size(.rdm_2_bb_grad_info(irdm).factor(j).element)
           .grad_info_tmp.factor(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).factor(j).element(1:siz)
        end
        ! indices of the 2RMD element (i1,j1,i2,j2)
        rdm2_ind = .rdm_2_bb(irdm).indices
        ! additional info. about the product of coefficients
        if (.rdm_2_bb_grad_info(irdm).all_pairs.created) then
           do j=1,nt
              .grad_info_tmp.all_pairs(j) = .rdm_2_bb_grad_info(irdm).all_pairs(j)
           end
        else
           .grad_info_tmp.all_pairs = FALSE
        end
        ! info. for calculation of gradient w.r.t. GD2 angles
        if (gd2_info) then
           nt_gd2 = .rdm_2_bb_grad_info(irdm).nb_GD2_terms
           .grad_info_tmp.nb_GD2_terms = nt_gd2
           if (nt_gd2 > 0) then
              .grad_info_tmp.GD2_terms(1:nt_gd2) = .rdm_2_bb_grad_info(irdm).GD2_terms(1:nt_gd2)
              .grad_info_tmp.GD2_cpr(1:nt_gd2) = .rdm_2_bb_grad_info(irdm).GD2_cpr(1:nt_gd2)
              do j=1,nt_gd2
                 siz = size(.rdm_2_bb_grad_info(irdm).GD2_blk(j).element)
                 gd2_siz(j) = siz
                 .grad_info_tmp.GD2_blk(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).GD2_blk(j).element
                 .grad_info_tmp.GD2_cas(j).element(1:siz) = .rdm_2_bb_grad_info(irdm).GD2_cas(j).element
              end
           end
        end
     case default
        stdout.text("Error in routine copy_2rdm_grad_info:")
        stdout.text("unknown string to select the 2RDM part.")
       stop
     end !select

   end

!   calc_new_red_overlap(iterm, gem, blk, red_overlap)
!   ! compute a new reduced overlap, where geminal "gem" and 2D
!   ! block "blk" (if "blk" is present) are excluded, in addition to 
!   ! the geminals and 2D blocks already excluded in the calculation 
!   ! of term "iterm" of element the 2RDM whose gradient information
!   ! is stored in ".grad_info_tmp"
!     iterm, gem :: INT, IN
!     blk :: INT, IN, optional
!     red_overlap :: REAL, INOUT
!     n_ex_gem, n_ex_blk :: INT
!     ng, nb :: INT
!     gg, bb :: VEC{INT}(3)
!     check_nb_gem, problem :: BIN
!     red_pbg :: PAULI_BLOCK_GEMINALS
!     !!!
!     i_gem, j_gem, k, blk_add :: INT
!     ww :: VEC{INT}(2)
!     !!!
!     !!! debug
!!     stdout.text(" ")
!!     stdout.text("Entering subroutine calc_new_red_overlap(new)")
!!     stdout.text(" ")
!     !!!
!
!     ! prepare geminal indices to be excluded
!     i_gem = .grad_info_tmp.ex_gem(iterm).element(1)
!     j_gem = .grad_info_tmp.ex_gem(iterm).element(2)
!     if (i_gem /= j_gem) then
!        n_ex_gem = 2
!     else
!        n_ex_gem = 1
!     end
!!     gg(1:n_ex_gem) = .grad_info_tmp.ex_gem(iterm).element
!     gg(1:n_ex_gem) = .grad_info_tmp.ex_gem(iterm).element(1:n_ex_gem)
!     n_ex_gem = n_ex_gem+1
!     gg(n_ex_gem) = gem
!     ! n_ex_gem = number of geminals to be excluded
!     ! ng = number of geminals in the reduced PBG
!     ng = .n_geminals-n_ex_gem
!     if (ng < 0) then
!        stdout.text("Error in calc_new_red_overlap:")
!        stdout.text("the number of geminals to be excluded") 
!        stdout.text("is larger than the size of the PBT set.")
!        stop
!     end
!     check_nb_gem = (ng /= 0)
!     ! prepare block indices to be excluded
!     n_ex_blk = 0
!     ww = .grad_info_tmp.ex_blk(iterm).element
!     do k=1,2 
!        ww(k) = ww(k)-.n_1D_blocks
!        if (ww(k) > 0) then
!           n_ex_blk = n_ex_blk+1
!           bb(n_ex_blk) = ww(k)
!        end
!     end
!     if (present(blk) AND blk>.n_1D_blocks) then
!        blk_add = blk-.n_1D_blocks
!        n_ex_blk = n_ex_blk+1
!        bb(n_ex_blk) = blk_add
!     end
!     ! n_ex_blk = number of 2D blocks to be excluded
!     ! nb = number of 2D blocks in the reduced PBG
!     nb = .n_blocks-n_ex_blk
!     !!! debug
!     stdout.show("number of geminals in the reduced PBG (ng)  =", ng)
!     stdout.show("excluded geminals (gg)  =", gg(1:n_ex_gem))
!     stdout.show("number of 2D blocks in the reduced PBG (nb) =", nb)
!     stdout.show("excluded 2D blocks (bb) =", bb(1:n_ex_blk))
!     !!!
!     ! compute the reduced overlap
!     if (check_nb_gem AND n_ex_blk > 0) then
!        ! prepare the reduced PBG and compute the reduced overlap
!        !!! debug
!!        stdout.show("excluded geminals", gg(1:n_ex_gem))
!!        stdout.show("excluded blocks", bb(1:n_ex_blk))
!        !!!
!        .prep_red_pbg_gg_bb(red_pbg, gg, n_ex_gem, bb, n_ex_blk, problem)
!        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!!        if ((NOT problem) AND ((.first_block == 0) OR (nb >= ng))) then
!           red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
!           red_pbg.calc_overlap_integral(red_overlap,FALSE)
!        else
!           red_overlap = ZERO
!        end
!     else if (check_nb_gem) then
!        ! prepare the reduced PBG and compute the reduced overlap
!        !!!
!!        stdout.show("excluded geminals", gg(1:n_ex_gem))
!        !!!
!        .prep_red_pbg_gg(red_pbg, gg, n_ex_gem)
!        red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
!        red_pbg.calc_overlap_integral(red_overlap,FALSE)
!     else
!        red_overlap = ONE
!     end
!     
!   end

   calc_new_red_overlap(iterm, gem, blk, red_overlap)
   ! compute a new reduced overlap, where geminal "gem" and 2D
   ! block "blk" (if "blk" is present) are excluded, in addition to 
   ! the geminals and 2D blocks already excluded in the calculation 
   ! of term "iterm" of element the 2RDM whose gradient information
   ! is stored in ".grad_info_tmp"
     iterm, gem :: INT, IN
     blk :: INT, IN, optional
     red_overlap :: REAL, INOUT
     n_ex_gem, n_ex_blk :: INT
     ng, nb :: INT
     gg, bb :: VEC{INT}(3)
     check_nb_gem, problem :: BIN
     red_pbg :: PAULI_BLOCK_GEMINALS
     !!!
     i_gem, j_gem, k, blk_add :: INT
     ww :: VEC{INT}(2)
     idum :: INT
     !!!
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine calc_new_red_overlap(new)")
!     stdout.text(" ")
     !!!

     ! prepare geminal indices to be excluded
     i_gem = .grad_info_tmp.ex_gem(iterm).element(1)
     j_gem = .grad_info_tmp.ex_gem(iterm).element(2)
     !!! debug
!     stdout.show("i_gem  =", i_gem)
!     stdout.show("j_gem  =", j_gem)
     !!!
     if (i_gem /= j_gem) then
        n_ex_gem = 2
     else
        n_ex_gem = 1
     end
     gg(1:n_ex_gem) = .grad_info_tmp.ex_gem(iterm).element(1:n_ex_gem)
     n_ex_gem = n_ex_gem+1
     gg(n_ex_gem) = gem
     ! n_ex_gem = number of geminals to be excluded
     ! ng = number of geminals in the reduced PBG
     ng = .n_geminals - n_ex_gem
     if (ng < 0) then
        stdout.text("Error in calc_new_red_overlap:")
        stdout.text("the number of geminals to be excluded") 
        stdout.text("is larger than the size of the PBT set.")
        stop
     end
     check_nb_gem = (ng /= 0)
     ! prepare block indices to be excluded
     ww(1:2) = .grad_info_tmp.ex_blk(iterm).element(1:2)
     idum = 0
     n_ex_blk = 0
     do k=1,2
        ww(k) = ww(k) - .n_1D_blocks
        if (ww(k) > 0 AND ww(k) /= idum) then
           idum = ww(k)
           n_ex_blk = n_ex_blk + 1
           bb(n_ex_blk) = ww(k)
        end
     end
!     n_ex_blk = 0
!     ww = .grad_info_tmp.ex_blk(iterm).element
!     do k=1,2
!        ww(k) = ww(k)-.n_1D_blocks
!        if (ww(k) > 0) then
!           n_ex_blk = n_ex_blk+1
!           bb(n_ex_blk) = ww(k)
!        end
!     end
     if (present(blk)  AND  blk > .n_1D_blocks) then
        blk_add = blk - .n_1D_blocks
        n_ex_blk = n_ex_blk + 1
        bb(n_ex_blk) = blk_add
     end
     ! n_ex_blk = number of 2D blocks to be excluded
     ! nb = number of 2D blocks in the reduced PBG
     nb = .n_blocks - n_ex_blk
     !!! debug
!     stdout.show("number of geminals in the reduced PBG (ng)  =", ng)
!     stdout.show("excluded geminals (gg)  =", gg(1:n_ex_gem))
!     stdout.show("number of 2D blocks in the reduced PBG (nb) =", nb)
!     stdout.show("excluded 2D blocks (bb) =", bb(1:n_ex_blk))
     !!!
     ! compute the reduced overlap
     if (check_nb_gem AND n_ex_blk > 0) then
        ! prepare the reduced PBG and compute the reduced overlap
        .prep_red_pbg_gg_bb(red_pbg, gg, n_ex_gem, bb, n_ex_blk, problem)
        if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!        if ((NOT problem) AND ((.first_block == 0) OR (nb >= ng))) then
           red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
           red_pbg.calc_overlap_integral(red_overlap,FALSE)
        else
           red_overlap = ZERO
        end
     else if (check_nb_gem) then
        ! prepare the reduced PBG and compute the reduced overlap
        !!! debug
!        stdout.show("excluded geminals", gg(1:n_ex_gem))
        !!!
        .prep_red_pbg_gg(red_pbg, gg, n_ex_gem)
        red_pbg.make_int_term_list(FALSE,FALSE,FALSE)
        red_pbg.calc_overlap_integral(red_overlap,FALSE)
     else
        red_overlap = ONE
     end
     
   end
! de

   create_2rdm_grad_info_tmp(nb_terms) ::: leaky
   ! create temporary object employed to save the information, about
   ! the 2RDM elements, required to compute the energy gradient with
   ! respect to the block coefficients
     nb_terms :: INT, IN
     n_gb, i :: INT
     !!!
     n_gd2_ang :: INT
     !!!
     !!! DEBUG
!     stdout.text(" ")
!     stdout.text("Enter subroutine create_2rdm_grad_info_tmp")
     !!!

     ! maximum number of geminals and blocks 
     ! excluded in the calculation of the reduced overlap 
     ! for a given term of a 2RDM element
     n_gb = 2

     ! set number of terms
     .grad_info_tmp.nb_terms = nb_terms
     ! create vectors of products of coefficients,
     ! of reduced overlaps and of binary variables
     ! with additional info. about the product of 
     ! coefficients
     .grad_info_tmp.coef_prod.create(nb_terms)
     .grad_info_tmp.red_ov.create(nb_terms)
     .grad_info_tmp.all_pairs.create(nb_terms)
     ! create vectors of vectors of indices
     ! of excluded geminals, excluded blocks
     ! and multiplication factors
     .grad_info_tmp.ex_gem.create(nb_terms,n_gb)
     .grad_info_tmp.ex_blk.create(nb_terms,n_gb)
     .grad_info_tmp.factor.create(nb_terms,n_gb)

     !!!
     if (.n_2D_3typ_blocks > 0) then
        ! maximum number of GD2 angles present
        ! in a given term of a 2RDM element
        n_gd2_ang = 2

        ! maximum number of terms depending on GD2 angles
        .grad_info_tmp.nb_GD2_terms = nb_terms

!        ! create vectors of term indices and number of GD2 angles
!        .grad_info_tmp.GD2_terms.create(nb_terms)
!        .grad_info_tmp.nb_GD2_ang.create(nb_terms)

        ! create vectors of GD2 term indices and 
        ! products of coefficients 
        .grad_info_tmp.GD2_terms.create(nb_terms)
        .grad_info_tmp.GD2_cpr.create(nb_terms)

        ! create vectors of vectors of GD2 block indices 
        ! and case numbers
        .grad_info_tmp.GD2_blk.create(nb_terms,n_gd2_ang)
        .grad_info_tmp.GD2_cas.create(nb_terms,n_gd2_ang)
     else
        .grad_info_tmp.nb_GD2_terms = 0
     end
     !!!

   end

! davide - 10/03/2020
   save_2rdm_grad_info(rdm2_type, irdm, nt, terms, allpairs_arg, nt_gd2, gd2_terms) ::: leaky
   ! save information about the 2rdm element "irdm"
   ! (this info. will be used in the calculation 
   ! of the energy gradient)
     rdm2_type :: STR, IN
     irdm, nt :: INT, IN
     terms :: VEC{INT}, IN
     allpairs_arg :: BIN, IN, optional
     nt_gd2 :: INT, IN, optional
     gd2_terms ::  VEC{INT}, IN, optional
     allpairs :: BIN
     ngbf :: INT
     j, k :: INT
     !!!
!     n_gd2_ang :: INT
     blk1, blk2 :: INT
     !!!
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine save_2rdm_grad_info")
!     stdout.text("Argument variables:")
!     stdout.show("rdm2_type =", rdm2_type)
!     stdout.show("irdm      =", irdm)
!     stdout.show("nt        =", nt)
!     stdout.show("terms     =", terms(1:nt))
     !!!

     ! this is for the possible creation of array "all_pairs"
     allpairs = FALSE
     if (present(allpairs_arg)) then
        allpairs = allpairs_arg
     end

     ! dimension of vectors "ex_gem(:).element",
     ! "ex_blk(:).element" and "factor(:).element"
     ngbf = 2

     select case (rdm2_type)
     case("ab")
        ! set number of terms
        .rdm_2_ab_grad_info(irdm).nb_terms = nt
        ! destroy vectors (if already created)
        .rdm_2_ab_grad_info(irdm).coef_prod.destroy
        .rdm_2_ab_grad_info(irdm).red_ov.destroy
        .rdm_2_ab_grad_info(irdm).ex_gem.destroy
        .rdm_2_ab_grad_info(irdm).ex_blk.destroy
        .rdm_2_ab_grad_info(irdm).factor.destroy
        ! create vectors and save information
        .rdm_2_ab_grad_info(irdm).coef_prod.create(nt)
        .rdm_2_ab_grad_info(irdm).red_ov.create(nt)
        .rdm_2_ab_grad_info(irdm).ex_gem.create(nt,ngbf)
        .rdm_2_ab_grad_info(irdm).ex_blk.create(nt,ngbf)
        .rdm_2_ab_grad_info(irdm).factor.create(nt,ngbf)
        do j=1,nt
           k = terms(j)
           ! product of coefficients
           .rdm_2_ab_grad_info(irdm).coef_prod(j) = .grad_info_tmp.coef_prod(k)
           ! reduced overlap
           .rdm_2_ab_grad_info(irdm).red_ov(j) = .grad_info_tmp.red_ov(k)
           ! indices of excluded geminals
           .rdm_2_ab_grad_info(irdm).ex_gem(j).element(1:ngbf) = .grad_info_tmp.ex_gem(k).element(1:ngbf)
           ! indices of excluded blocks
           .rdm_2_ab_grad_info(irdm).ex_blk(j).element(1:ngbf) = .grad_info_tmp.ex_blk(k).element(1:ngbf)
           ! multiplication factors
           .rdm_2_ab_grad_info(irdm).factor(j).element(1:ngbf) = .grad_info_tmp.factor(k).element(1:ngbf)
        end
        ! binaries with additional info. about the product of coefficients
        ! (creation and storing)
        .rdm_2_ab_grad_info(irdm).all_pairs.destroy
        if (allpairs) then
           .rdm_2_ab_grad_info(irdm).all_pairs.create(nt)
           do j=1,nt
              k = terms(j)
              .rdm_2_ab_grad_info(irdm).all_pairs(j) = .grad_info_tmp.all_pairs(k)
           end
        end
        !!!
        ! this is for energy gradient calculation w.r.t. GD2 angles
        if (present(gd2_terms)) then
           ! set number of GD2 terms
           .rdm_2_ab_grad_info(irdm).nb_GD2_terms = nt_gd2
           ! destroy vectors (if already created)
           .rdm_2_ab_grad_info(irdm).GD2_terms.destroy
           .rdm_2_ab_grad_info(irdm).GD2_cpr.destroy
           .rdm_2_ab_grad_info(irdm).GD2_blk.destroy
           .rdm_2_ab_grad_info(irdm).GD2_cas.destroy
           ! create vectors and save information
           .rdm_2_ab_grad_info(irdm).GD2_terms.create(nt_gd2)
           .rdm_2_ab_grad_info(irdm).GD2_cpr.create(nt_gd2)
           .rdm_2_ab_grad_info(irdm).GD2_blk.create(nt_gd2)
           .rdm_2_ab_grad_info(irdm).GD2_cas.create(nt_gd2)
           ! indices of GD2 terms
           k = 0
           do j=1,nt
              if ( any(gd2_terms(1:nt_gd2) == terms(j)) ) then
                 k = k+1
                 .rdm_2_ab_grad_info(irdm).GD2_terms(k) = j
              end
           end
           ! products of coefficients, GD2 block indices and case numbers
           do j=1,nt_gd2
              k = gd2_terms(j)
              .rdm_2_ab_grad_info(irdm).GD2_cpr(j) = .grad_info_tmp.GD2_cpr(k)
              !
              blk1 = .grad_info_tmp.GD2_blk(k).element(1)
              blk2 = .grad_info_tmp.GD2_blk(k).element(2)
              if (blk1 == blk2) then
                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element.create(1)
                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element.create(1)
                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element(1) = blk1
                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
              else
                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element.create(2)
                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element.create(2)
                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element(1) = blk1
                 .rdm_2_ab_grad_info(irdm).GD2_blk(j).element(2) = blk2
                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
                 .rdm_2_ab_grad_info(irdm).GD2_cas(j).element(2) = .grad_info_tmp.GD2_cas(k).element(2)
              end
           end
        else
           .rdm_2_ab_grad_info(irdm).nb_GD2_terms = 0
        end
        !!!
        !!! DEBUG
!        stdout.text("2RDM alpha/beta")
!        stdout.show("element",irdm)
!        stdout.show("indices",.rdm_2_ab(irdm).indices)
!        stdout.show("number of terms =",nt)
!        stdout.show("coef_prod",.rdm_2_ab(irdm).grad_info.coef_prod)
!        stdout.show("red_overlap",.rdm_2_ab(irdm).grad_info.red_ov)
!        stdout.text("excluded geminals")
!        do j=1,nt
!           stdout.show("geminals",.rdm_2_ab(irdm).grad_info.ex_gem(j).element)
!        end
!        stdout.text("excluded blocks")
!        do j=1,nt
!           stdout.show("blocks",.rdm_2_ab(irdm).grad_info.ex_blk(j).element)
!        end
!        stdout.text("multiplication factors")
!        do j=1,nt
!           stdout.show("factors",.rdm_2_ab(irdm).grad_info.factor(j).element)
!        end
!        stdout.text(" ")
        !!!
     case("aa")
        ! set number of terms
        .rdm_2_aa_grad_info(irdm).nb_terms = nt
        ! destroy vectors (if already created)
        .rdm_2_aa_grad_info(irdm).coef_prod.destroy
        .rdm_2_aa_grad_info(irdm).red_ov.destroy
        .rdm_2_aa_grad_info(irdm).ex_gem.destroy
        .rdm_2_aa_grad_info(irdm).ex_blk.destroy
        .rdm_2_aa_grad_info(irdm).factor.destroy
        ! create vectors and save information
        .rdm_2_aa_grad_info(irdm).coef_prod.create(nt)
        .rdm_2_aa_grad_info(irdm).red_ov.create(nt)
        .rdm_2_aa_grad_info(irdm).ex_gem.create(nt,ngbf)
        .rdm_2_aa_grad_info(irdm).ex_blk.create(nt,ngbf)
        .rdm_2_aa_grad_info(irdm).factor.create(nt,ngbf)
        do j=1,nt
           k = terms(j)
           ! product of coefficients
           .rdm_2_aa_grad_info(irdm).coef_prod(j) = .grad_info_tmp.coef_prod(k)
           ! reduced overlap
           .rdm_2_aa_grad_info(irdm).red_ov(j) = .grad_info_tmp.red_ov(k)
           ! indices of excluded geminals
           .rdm_2_aa_grad_info(irdm).ex_gem(j).element(1:ngbf) = .grad_info_tmp.ex_gem(k).element(1:ngbf)
           ! indices of excluded blocks
           .rdm_2_aa_grad_info(irdm).ex_blk(j).element(1:ngbf) = .grad_info_tmp.ex_blk(k).element(1:ngbf)
           ! multiplication factors
           .rdm_2_aa_grad_info(irdm).factor(j).element(1:ngbf) = .grad_info_tmp.factor(k).element(1:ngbf)
        end
        ! binaries with additional info. about the product of coefficients
        ! (creation and storing)
        .rdm_2_aa_grad_info(irdm).all_pairs.destroy
        if (allpairs) then
           .rdm_2_aa_grad_info(irdm).all_pairs.create(nt)
           do j=1,nt
              k = terms(j)
              .rdm_2_aa_grad_info(irdm).all_pairs(j) = .grad_info_tmp.all_pairs(k)
           end
        end
        !!!
        ! this is for energy gradient calculation w.r.t. GD2 angles
        if (present(gd2_terms)) then
           ! set number of GD2 terms
           .rdm_2_aa_grad_info(irdm).nb_GD2_terms = nt_gd2
           ! destroy vectors (if already created)
           .rdm_2_aa_grad_info(irdm).GD2_terms.destroy
           .rdm_2_aa_grad_info(irdm).GD2_cpr.destroy
           .rdm_2_aa_grad_info(irdm).GD2_blk.destroy
           .rdm_2_aa_grad_info(irdm).GD2_cas.destroy
           ! create vectors and save information
           .rdm_2_aa_grad_info(irdm).GD2_terms.create(nt_gd2)
           .rdm_2_aa_grad_info(irdm).GD2_cpr.create(nt_gd2)
           .rdm_2_aa_grad_info(irdm).GD2_blk.create(nt_gd2)
           .rdm_2_aa_grad_info(irdm).GD2_cas.create(nt_gd2)
           ! indices of GD2 terms
           k = 0
           do j=1,nt
              if ( any(gd2_terms(1:nt_gd2) == terms(j)) ) then
                 k = k+1
                 .rdm_2_aa_grad_info(irdm).GD2_terms(k) = j
              end
           end
           ! GD2 block indices and case numbers
           do j=1,nt_gd2
              k = gd2_terms(j)
              .rdm_2_aa_grad_info(irdm).GD2_cpr(j) = .grad_info_tmp.GD2_cpr(k)
              !
              blk1 = .grad_info_tmp.GD2_blk(k).element(1)
              blk2 = .grad_info_tmp.GD2_blk(k).element(2)
              if (blk1 == blk2) then
                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element.create(1)
                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element.create(1)
                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element(1) = blk1
                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
              else
                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element.create(2)
                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element.create(2)
                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element(1) = blk1
                 .rdm_2_aa_grad_info(irdm).GD2_blk(j).element(2) = blk2
                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
                 .rdm_2_aa_grad_info(irdm).GD2_cas(j).element(2) = .grad_info_tmp.GD2_cas(k).element(2)
              end
           end
        else
           .rdm_2_aa_grad_info(irdm).nb_GD2_terms = 0
        end
        !!!
        !!! DEBUG
!        stdout.text("2RDM alpha/alpha")
!        stdout.show("element",irdm)
!        stdout.show("indices",.rdm_2_aa(irdm).indices)
!        stdout.show("number of terms =",nt)
!        stdout.show("coef_prod",.rdm_2_aa(irdm).grad_info.coef_prod)
!        stdout.show("red_overlap",.rdm_2_aa(irdm).grad_info.red_ov)
!        stdout.text("excluded geminals")
!        do j=1,nt
!           stdout.show("geminals",.rdm_2_aa(irdm).grad_info.ex_gem(j).element)
!        end
!        stdout.text("excluded blocks")
!        do j=1,nt
!           stdout.show("blocks",.rdm_2_aa(irdm).grad_info.ex_blk(j).element)
!        end
!        stdout.text("multiplication factors")
!        do j=1,nt
!           stdout.show("factors",.rdm_2_aa(irdm).grad_info.factor(j).element)
!        end
!        stdout.text(" ")
        !!!
     case("bb")
        ! set number of terms
        .rdm_2_bb_grad_info(irdm).nb_terms = nt
        ! destroy vectors (if already created)
        .rdm_2_bb_grad_info(irdm).coef_prod.destroy
        .rdm_2_bb_grad_info(irdm).red_ov.destroy
        .rdm_2_bb_grad_info(irdm).ex_gem.destroy
        .rdm_2_bb_grad_info(irdm).ex_blk.destroy
        .rdm_2_bb_grad_info(irdm).factor.destroy
        ! create vectors and save information
        .rdm_2_bb_grad_info(irdm).coef_prod.create(nt)
        .rdm_2_bb_grad_info(irdm).red_ov.create(nt)
        .rdm_2_bb_grad_info(irdm).ex_gem.create(nt,ngbf)
        .rdm_2_bb_grad_info(irdm).ex_blk.create(nt,ngbf)
        .rdm_2_bb_grad_info(irdm).factor.create(nt,ngbf)
        do j=1,nt
           k = terms(j)
           ! product of coefficients
           .rdm_2_bb_grad_info(irdm).coef_prod(j) = .grad_info_tmp.coef_prod(k)
           ! reduced overlap
           .rdm_2_bb_grad_info(irdm).red_ov(j) = .grad_info_tmp.red_ov(k)
           ! indices of excluded geminals
           .rdm_2_bb_grad_info(irdm).ex_gem(j).element(1:ngbf) = .grad_info_tmp.ex_gem(k).element(1:ngbf)
           ! indices of excluded blocks
           .rdm_2_bb_grad_info(irdm).ex_blk(j).element(1:ngbf) = .grad_info_tmp.ex_blk(k).element(1:ngbf)
           ! multiplication factors
           .rdm_2_bb_grad_info(irdm).factor(j).element(1:ngbf) = .grad_info_tmp.factor(k).element(1:ngbf)
        end
        ! binaries with additional info. about the product of coefficients
        ! (creation and storing)
        .rdm_2_bb_grad_info(irdm).all_pairs.destroy
        if (allpairs) then
           .rdm_2_bb_grad_info(irdm).all_pairs.create(nt)
           do j=1,nt
              k = terms(j)
              .rdm_2_bb_grad_info(irdm).all_pairs(j) = .grad_info_tmp.all_pairs(k)
           end
        end
        !!!
        ! this is for energy gradient calculation w.r.t. GD2 angles
        if (present(gd2_terms)) then
           ! set number of GD2 terms
           .rdm_2_bb_grad_info(irdm).nb_GD2_terms = nt_gd2
           ! destroy vectors (if already created)
           .rdm_2_bb_grad_info(irdm).GD2_terms.destroy
           .rdm_2_bb_grad_info(irdm).GD2_cpr.destroy
           .rdm_2_bb_grad_info(irdm).GD2_blk.destroy
           .rdm_2_bb_grad_info(irdm).GD2_cas.destroy
           ! create vectors and save information
           .rdm_2_bb_grad_info(irdm).GD2_terms.create(nt_gd2)
           .rdm_2_bb_grad_info(irdm).GD2_cpr.create(nt_gd2)
           .rdm_2_bb_grad_info(irdm).GD2_blk.create(nt_gd2)
           .rdm_2_bb_grad_info(irdm).GD2_cas.create(nt_gd2)
           ! indices of GD2 terms
           k = 0
           do j=1,nt
              if ( any(gd2_terms(1:nt_gd2) == terms(j)) ) then
                 k = k+1
                 .rdm_2_bb_grad_info(irdm).GD2_terms(k) = j
              end
           end
           ! GD2 block indices and case numbers
           do j=1,nt_gd2
              k = gd2_terms(j)
              .rdm_2_bb_grad_info(irdm).GD2_cpr(j) = .grad_info_tmp.GD2_cpr(k)
              !
              blk1 = .grad_info_tmp.GD2_blk(k).element(1)
              blk2 = .grad_info_tmp.GD2_blk(k).element(2)
              if (blk1 == blk2) then
                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element.create(1)
                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element.create(1)
                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element(1) = blk1
                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
              else
                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element.create(2)
                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element.create(2)
                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element(1) = blk1
                 .rdm_2_bb_grad_info(irdm).GD2_blk(j).element(2) = blk2
                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element(1) = .grad_info_tmp.GD2_cas(k).element(1)
                 .rdm_2_bb_grad_info(irdm).GD2_cas(j).element(2) = .grad_info_tmp.GD2_cas(k).element(2)
              end
           end
        else
           .rdm_2_bb_grad_info(irdm).nb_GD2_terms = 0
        end
        !!!
        !!! DEBUG
!        stdout.text("2RDM beta/beta")
!        stdout.show("element",irdm)
!        stdout.show("indices",.rdm_2_bb(irdm).indices)
!        stdout.show("number of terms =",nt)
!        stdout.show("coef_prod",.rdm_2_bb(irdm).grad_info.coef_prod)
!        stdout.show("red_overlap",.rdm_2_bb(irdm).grad_info.red_ov)
!        stdout.text("excluded geminals")
!        do j=1,nt
!           stdout.show("geminals",.rdm_2_bb(irdm).grad_info.ex_gem(j).element)
!        end
!        stdout.text("excluded blocks")
!        do j=1,nt
!           stdout.show("blocks",.rdm_2_bb(irdm).grad_info.ex_blk(j).element)
!        end
!        stdout.text("multiplication factors")
!        do j=1,nt
!           stdout.show("factors",.rdm_2_bb(irdm).grad_info.factor(j).element)
!        end
!        stdout.text(" ")
        !!!
     case default
        stdout.text("Error in routine save_2rdm_grad_info:") 
        stdout.text("unknown string to select the 2RDM part.")
        stop
     end select

   end
! de

! davide: 28-11-2018
   calc_1rdm ::: leaky
   ! compute the 1-reduced density matrix
   ! for a set of PBT
     i, j :: INT
     trace :: REAL

     allocate(.rdm_1(.mat_size,.mat_size))
     .rdm_1 = ZERO

     .prep_orbital_block_mapping
     .prep_block_types

   !debug stdout.text(" ")
   !debug stdout.text("Calculation of the 1-reduced density matrix")

     ! 1-orthogonal blocks space
     do i=1,.n_1D_blocks
        .calc_1rdm_element(i,i)
     end

     ! Pauli blocks space
     do i=.n_1D_blocks+1,.mat_size-1,2
        .calc_1rdm_element(i,i)
        j = i+1
        .rdm_1(j,j) = .rdm_1(i,i)
     end

     ! write 1-RDM
   !debug stdout.text(" ")
   !debug stdout.text("1-reduced density alpha-(or beta-)matrix:")
   !debug stdout.text(" ")
   !debug stdout.put(.rdm_1)

   !debug  ! compute 1-RDM trace
   !debug  trace = ZERO
   !debug  do i=1,.mat_size
   !debug     trace = trace + .rdm_1(i,i)
   !debug  end
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the 1-RDM alpha-(or beta-)matrix", trace)
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the total 1-RDM matrix", trace+trace)
     
   end

   calc_1rdm_element(row,col) 
   ! compute element (row,col) of the 1-reduced 
   ! density matrix (1-RDM) for a set of PBT
     row, col :: INT, IN
     red_pbg :: PAULI_BLOCK_GEMINALS 
     ng :: INT
     overlap :: REAL
     coef_prod, coef1, coef2 :: REAL
     block :: INT
     geminal :: INT
     term :: VEC{REAL}(4)
     j :: INT
     problem :: BIN

     ng = .n_geminals-1
     if (ng /= 0) then
        red_pbg.n_geminals = ng
        red_pbg.first_block = .first_block
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
     end

     if (row == col AND row <= .n_1D_blocks) then  ! 1-orthogonal blocks space - diagonal element
        ! index of the geminal to be skipped
        ! (in the calculation of the reduced overlap)
        geminal = .nonzero_1ortho_ind(row)
        if (geminal /= 0) then
!        if (.nonzero_1ortho_ind(row) /= 0) then
         !debug stdout.show("geminal to be skipped", geminal)
!         !debug stdout.show("geminal to be skipped", .nonzero_1ortho_ind(row))
         !debug stdout.show("nonzero 1-ortho. block", row)
           ! compute product of coefficients of the bra and ket
           ! geminals ".nonzero_1ortho_ind(row)" (1-ortho. block "row")
           coef1 = .bra_set.vec(geminal).coef(row)
!           coef1 = .bra_set.vec(.nonzero_1ortho_ind(row)).coef(row)
           if (.bra_is_ket) then
              coef_prod = coef1*coef1
           else
              coef2 = .ket_set.vec(geminal).coef(row)
!              coef2 = .ket_set.vec(.nonzero_1ortho_ind(row)).coef(row)
              coef_prod = coef1*coef2
           end
           if (ng /= 0) then
              .prep_red_pbg(red_pbg,geminal)
!              .prep_red_pbg(red_pbg,.nonzero_1ortho_ind(row))
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              .rdm_1(row,col) = coef_prod*overlap
           else
              .rdm_1(row,col) = coef_prod
           end
         !debug stdout.text(" ")
         !debug stdout.show("Calculation of 1-RDM diagonal element", row)
         !debug stdout.show("product of coef.", coef_prod)
         !debug stdout.show("overlap", overlap)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
        end
     else if (row == col AND row > .n_1D_blocks) then ! Pauli blocks space - diagonal element
      !debug stdout.text(" ")
      !debug stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
         !debug stdout.show("term", j)
           geminal = .block_types(block).element(j) 
         !debug stdout.show("geminal to be skipped", geminal)
         !debug stdout.show("Pauli block to be skipped", block)
           if (geminal /= 0) then
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              if (ng /= 0) then
                 .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                  !debug stdout.show("product of coef.", coef_prod)
                  !debug stdout.show("overlap", overlap)
                 else
                    term(j) = ZERO
                 end
              else
                 term(j) = coef_prod
               !debug stdout.show("product of coef.", coef_prod)
               !debug stdout.show("overlap", overlap)
              end
           else
              term(j) = ZERO
           end
         !debug stdout.show("term", term(j))
        end
        .rdm_1(row,col) = sum(term)
      !debug stdout.show("matrix element", .rdm_1(row,col))
        .rdm_1(row,col) = .rdm_1(row,col)/.overlap
      !debug stdout.show("normalized matrix element", .rdm_1(row,col))
     else
        .rdm_1(row,col) = ZERO
      !debug stdout.text(" ")
      !debug stdout.text("Calculation of 1-RDM off-diagonal element")
      !debug stdout.show(" ", row)
      !debug stdout.show(" ", col)
      !debug stdout.show("matrix element", .rdm_1(row,col))
     end
     if (ng /= 0) then
        red_pbg.destroy_ptr_part
     end

   end
  
   calc_2rdm_elt_i_jj(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IZ_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IZ_DD_aa(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_XY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_DD_bb(two_rdm_elt,k)
     end
     
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
!   calc_2rdm_elt_i_jj_grd(red_pbg,two_rdm_elt,i,n)
!   !
!     red_pbg :: PAULI_BLOCK_GEMINALS
!     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
!     i, n :: INT
!     block_1, block_2 :: INT
!     b1, b2 :: INT
!     geminal_1, geminal_2 :: INT
!     k, t :: INT
!     coef_1, coef_2 :: REAL
!     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
!     term :: VEC{REAL}(2)
!     overlap :: REAL
!     problem :: BIN
!     !!!
!     tt :: VEC{INT}(2)
!     chk_gem :: BIN
!     !prod_gd2 :: REAL
!     nb_terms :: INT
!     !!!
!!     stdout.text(" ")
!!     stdout.text("Enter subroutine calc_2rdm_elt_i_jj_grd")
!!     stdout.show("i =",i)
!!     stdout.text(" ")
!     !!!
!
!     block_1 = two_rdm_elt.block_numbers(3)
!     b1 = block_1 + .n_1D_blocks
!     block_2 = two_rdm_elt.block_numbers(4)
!     b2 = block_2 + .n_1D_blocks
!     term = (/ ZERO,ZERO /)
!     k = 0
!     t = k
!     if (n == 1 OR n == 3) then
!        .sum_set_info_IZ_DD_ab_bb(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_IZ_DD_aa(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!!     stdout.show("k =",k)
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     nb_terms = 0
!     if (chk_gem) then
!        tt(1) = 1
!        nb_terms = 1
!        .grad_info_tmp.red_ov(1) = overlap
!        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(1).element(1) = b1
!        .grad_info_tmp.ex_blk(1).element(2) = b2
!        !.grad_info_tmp.ex_blk(1).element(1) = block_1
!        !.grad_info_tmp.ex_blk(1).element(2) = block_2
!        .grad_info_tmp.factor(1).element = 1
!        .grad_info_tmp.all_pairs(1) = TRUE
!        !
!        .grad_info_tmp.coef_prod(1) = coef_1+coef_2
!     end
!     !!!
!
!     t = k
!     if (n == 1) then
!        .sum_set_info_XY_DD_ab(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_XY_DD_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_XY_DD_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!!     stdout.show("k =",k)
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     if (chk_gem) then
!        nb_terms = nb_terms+1
!        tt(nb_terms) = nb_terms
!        .grad_info_tmp.red_ov(nb_terms) = overlap
!        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!        .grad_info_tmp.factor(nb_terms).element = 1
!        .grad_info_tmp.all_pairs(nb_terms) = TRUE
!        !
!        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!     end
!     !!!
!
!!     if (abs(sum(term)) > TOL(15)) then
!!        two_rdm_elt.coefficient = sum(term)/.overlap
!!        if (n == 1) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!!        else if (n == 2) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!!        else if (n == 3) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!!        end
!!        i = i+1
!!     end
!     !!!
!     if (nb_terms > 0) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        !!! save gradient information
!        select case (n)
!        case(1)
!           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(2)
!           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(3)
!           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case default
!           stdout.text("Error in routine calc_2rdm_elt_i_jj_grd:")
!           stdout.text("unknown integer value to select the 2RDM part.")
!           stop
!        end
!        i = i+1
!     end
!     !!!
!
!   end

   calc_2rdm_elt_i_jj_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(2)
     chk :: BIN
     nb_terms :: INT
     cc, jj :: INT
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_i_jj_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
!     term = (/ ZERO,ZERO /)
     term = ZERO
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IZ_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IZ_DD_aa(two_rdm_elt,k)
     end
     !!!
     nb_terms = 0
     chk = TRUE
     !!!
!     stdout.show("k =",k)
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms + 1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     t = k
     if (n == 1) then
        .sum_set_info_XY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_DD_bb(two_rdm_elt,k)
     end
     !!!
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

!     if (abs(sum(term)) > TOL(15)) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
!        i = i+1
!     end
     !!!
     !!! debug (new)
!     if (.debug) then
!        cc = 0
!        do jj=1,k 
!           if (abs(term(jj)) > TOL(15)) then
!              cc = cc + 1
!           end
!        end
!        if (cc /= nb_terms) then
!           stdout.text("Mismatch in calc_2rdm_elt_i_jj_grd")
!           stdout.show("cc =",cc)
!           stdout.show("nb_terms =",cc)
!           stdout.show("terms =",term(1:k))
!           stdout.show("2RDM element",i)
!           stop
!        end
!     end
     !!! end debug (new)
     !!!
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_i_jj_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        i = i+1
     end
     !!!

   end
! de

   calc_2rdm_elt_ii_j(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_DD_IZ_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_IZ_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_IZ_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_DD_XY_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_XY_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_XY_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
!   calc_2rdm_elt_ii_j_grd(red_pbg,two_rdm_elt,i,n)
!   !
!     red_pbg :: PAULI_BLOCK_GEMINALS
!     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
!     i, n :: INT
!     block_1, block_2 :: INT
!     b1, b2 :: INT
!     geminal_1, geminal_2 :: INT
!     k, t :: INT
!     coef_1, coef_2 :: REAL
!     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
!     term :: VEC{REAL}(2)
!     overlap :: REAL
!     problem :: BIN
!     !!!
!     tt :: VEC{INT}(2)
!     chk_gem :: BIN
!     !prod_gd2 :: REAL
!     nb_terms :: INT
!     !!!
!!     stdout.text(" ")
!!     stdout.text("Enter subroutine calc_2rdm_elt_ii_j_grd")
!!     stdout.show("i =",i)
!!     stdout.text(" ")
!     !!!
!
!     block_1 = two_rdm_elt.block_numbers(3)
!     b1 = block_1 + .n_1D_blocks
!     block_2 = two_rdm_elt.block_numbers(4)
!     b2 = block_2 + .n_1D_blocks
!     term = (/ ZERO,ZERO /)
!     k = 0
!     t = k
!     if (n == 1) then
!        .sum_set_info_DD_IZ_ab(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_DD_IZ_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_DD_IZ_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     nb_terms = 0
!     if (chk_gem) then
!        tt(1) = 1
!        nb_terms = 1
!        .grad_info_tmp.red_ov(1) = overlap
!        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(1).element(1) = b1
!        .grad_info_tmp.ex_blk(1).element(2) = b2
!        !.grad_info_tmp.ex_blk(1).element(1) = block_1
!        !.grad_info_tmp.ex_blk(1).element(2) = block_2
!        .grad_info_tmp.factor(1).element = 1
!        .grad_info_tmp.all_pairs(1) = TRUE
!        !
!        .grad_info_tmp.coef_prod(1) = coef_1+coef_2
!     end
!     !!!
!
!     t = k
!     if (n == 1) then
!        .sum_set_info_DD_XY_ab(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_DD_XY_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_DD_XY_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     if (chk_gem) then
!        nb_terms = nb_terms+1
!        tt(nb_terms) = nb_terms
!        .grad_info_tmp.red_ov(nb_terms) = overlap
!        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!        .grad_info_tmp.factor(nb_terms).element = 1
!        .grad_info_tmp.all_pairs(nb_terms) = TRUE
!        !
!        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!     end
!
!     !!!
!     if (nb_terms > 0) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        !!! save gradient information
!        select case (n)
!        case(1)
!           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(2)
!           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(3)
!           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case default
!           stdout.text("Error in routine calc_2rdm_elt_ii_j_grd:")
!           stdout.text("unknown integer value to select the 2RDM part.")
!           stop
!        end
!        i = i+1
!     end
!     !!!
!
!!     if (abs(sum(term)) > TOL(15)) then
!!        two_rdm_elt.coefficient = sum(term)/.overlap
!!        if (n == 1) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!!        else if (n == 2) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!!        else if (n == 3) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!!        end
!!        i = i+1
!!     end
!
!   end

   calc_2rdm_elt_ii_j_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(2)
     chk :: BIN
     nb_terms :: INT
     cc, jj :: INT
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_ii_j_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = ZERO
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_DD_IZ_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_IZ_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_IZ_bb(two_rdm_elt,k)
     end
     !!!
     nb_terms = 0
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms + 1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     t = k
     if (n == 1) then
        .sum_set_info_DD_XY_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_XY_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_XY_bb(two_rdm_elt,k)
     end
     !!!
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     !!! debug (new)
!     if (.debug) then
!        cc = 0
!        do jj=1,k 
!           if (abs(term(jj)) > TOL(15)) then
!              cc = cc + 1
!           end
!        end
!        if (cc /= nb_terms) then
!           stdout.text("Mismatch in calc_2rdm_elt_ii_j_grd")
!           stdout.show("cc =",cc)
!           stdout.show("nb_terms =",cc)
!           stdout.show("terms =",term(1:k))
!           stdout.show("2RDM element",i)
!           stop
!        end
!     end
     !!! end debug (new)

     !!!
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_ii_j_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        i = i+1
     end
     !!!

!     if (abs(sum(term)) > TOL(15)) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
!        i = i+1
!     end

   end
! de

   calc_2rdm_elt_ii_jj(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = (/ ZERO,ZERO,ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IX_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IX_DD_aa(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IY_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IY_DD_aa(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_ZX_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_ZX_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_ZX_DD_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_ZY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_ZY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_ZY_DD_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
!   calc_2rdm_elt_ii_jj_grd(red_pbg,two_rdm_elt,i,n)
!   !
!     red_pbg :: PAULI_BLOCK_GEMINALS
!     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
!     i, n :: INT
!     block_1, block_2 :: INT
!     b1, b2 :: INT
!     geminal_1, geminal_2 :: INT
!     k, t :: INT
!     coef_1, coef_2 :: REAL
!     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
!     term :: VEC{REAL}(4)
!     overlap :: REAL
!     problem :: BIN
!     !!!
!     tt :: VEC{INT}(4)
!     chk_gem :: BIN
!     !prod_gd2 :: REAL
!     nb_terms :: INT
!     !!!
!!     stdout.text(" ")
!!     stdout.text("Enter subroutine calc_2rdm_elt_ii_jj_grd")
!!     stdout.show("i =",i)
!!     stdout.text(" ")
!     !!!
!
!     block_1 = two_rdm_elt.block_numbers(3)
!     b1 = block_1 + .n_1D_blocks
!     block_2 = two_rdm_elt.block_numbers(4)
!     b2 = block_2 + .n_1D_blocks
!     term = (/ ZERO,ZERO,ZERO,ZERO /)
!     k = 0
!     t = k
!     if (n == 1 OR n == 3) then
!        .sum_set_info_IX_DD_ab_bb(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_IX_DD_aa(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     nb_terms = 0
!     if (chk_gem) then
!        tt(1) = 1
!        nb_terms = 1
!        .grad_info_tmp.red_ov(1) = overlap
!        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(1).element(1) = b1
!        .grad_info_tmp.ex_blk(1).element(2) = b2
!        !.grad_info_tmp.ex_blk(1).element(1) = block_1
!        !.grad_info_tmp.ex_blk(1).element(2) = block_2
!        .grad_info_tmp.factor(1).element = 1
!        .grad_info_tmp.all_pairs(1) = TRUE
!        !
!        .grad_info_tmp.coef_prod(1) = coef_1+coef_2
!     end
!     !!!
!
!     t = k
!     if (n == 1 OR n == 3) then
!        .sum_set_info_IY_DD_ab_bb(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_IY_DD_aa(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     if (chk_gem) then
!        nb_terms = nb_terms+1
!        tt(nb_terms) = nb_terms
!        .grad_info_tmp.red_ov(nb_terms) = overlap
!        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!        .grad_info_tmp.factor(nb_terms).element = 1
!        .grad_info_tmp.all_pairs(nb_terms) = TRUE
!        !
!        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!     end
!     !!!
!
!     t = k
!     if (n == 1) then
!        .sum_set_info_ZX_DD_ab(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_ZX_DD_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_ZX_DD_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     if (chk_gem) then
!        nb_terms = nb_terms+1
!        tt(nb_terms) = nb_terms
!        .grad_info_tmp.red_ov(nb_terms) = overlap
!        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!        .grad_info_tmp.factor(nb_terms).element = 1
!        .grad_info_tmp.all_pairs(nb_terms) = TRUE
!        !
!        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!     end
!     !!!
!
!     t = k
!     if (n == 1) then
!        .sum_set_info_ZY_DD_ab(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_ZY_DD_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_ZY_DD_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     if (chk_gem) then
!        nb_terms = nb_terms+1
!        tt(nb_terms) = nb_terms
!        .grad_info_tmp.red_ov(nb_terms) = overlap
!        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!        .grad_info_tmp.factor(nb_terms).element = 1
!        .grad_info_tmp.all_pairs(nb_terms) = TRUE
!        !
!        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!     end
!
!     !!!
!     if (nb_terms > 0) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        !!! save gradient information
!        select case (n)
!        case(1)
!           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(2)
!           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(3)
!           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case default
!           stdout.text("Error in routine calc_2rdm_elt_ii_jj_grd:")
!           stdout.text("unknown integer value to select the 2RDM part.")
!           stop
!        end
!        i = i+1
!     end
!     !!!
!
!!     if (abs(sum(term)) > TOL(15)) then
!!        two_rdm_elt.coefficient = sum(term)/.overlap
!!        if (n == 1) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!!        else if (n == 2) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!!        else if (n == 3) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!!        end
!!        i = i+1
!!     end
!
!   end

   calc_2rdm_elt_ii_jj_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(4)
     chk :: BIN
     nb_terms :: INT
     cc, jj :: INT
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_ii_jj_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = ZERO
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IX_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IX_DD_aa(two_rdm_elt,k)
     end
     !!!
     nb_terms = 0
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms + 1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_IY_DD_ab_bb(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IY_DD_aa(two_rdm_elt,k)
     end
     !!!
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     t = k
     if (n == 1) then
        .sum_set_info_ZX_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_ZX_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_ZX_DD_bb(two_rdm_elt,k)
     end
     !!!
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     t = k
     if (n == 1) then
        .sum_set_info_ZY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_ZY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_ZY_DD_bb(two_rdm_elt,k)
     end
     !!!
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     !!! debug (new)
!     if (.debug) then
!        cc = 0
!        do jj=1,k 
!           if (abs(term(jj)) > TOL(15)) then
!              cc = cc + 1
!           end
!        end
!        if (cc /= nb_terms) then
!           stdout.text("Mismatch in calc_2rdm_elt_ii_jj_grd")
!           stdout.show("cc =",cc)
!           stdout.show("nb_terms =",cc)
!           stdout.show("terms =",term(1:k))
!           stdout.show("2RDM element",i)
!           stop
!        end
!     end
     !!! end debug (new)

     !!!
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_ii_jj_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        i = i+1
     end
     !!!

!     if (abs(sum(term)) > TOL(15)) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
!        i = i+1
!     end

   end
! de

   calc_2rdm_elt_i_j(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(18)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     k = 0
     t = k
     term = ZERO
     if (n == 1 OR n == 2) then
        .sum_set_info_IZXY_IZ_ab_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_IZXY_IZ_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1) then
        .sum_set_info_IZXY_XY_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IZXY_XY_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_IZXY_XY_bb(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end

     k = 2
     do j=1,4
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           do s=1,4
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 if (.n_geminals > 2) then
                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                       else
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                       end
                       k = k+1
                       term(k) = coef_prod_1*coef_prod_2*overlap
                    end
                 else
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2                    
                 end
              end
           end
        end
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
!   calc_2rdm_elt_i_j_grd(red_pbg,two_rdm_elt,i,n)
!   !
!     red_pbg :: PAULI_BLOCK_GEMINALS
!     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
!     i, n :: INT
!     block_1, block_2 :: INT
!     b1, b2 :: INT
!     geminal_1, geminal_2 :: INT
!     k, t :: INT
!     j, s :: INT
!     coef_1, coef_2 :: REAL
!     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
!     term :: VEC{REAL}(18)
!     overlap :: REAL
!     problem :: BIN
!     !!!
!     tt :: VEC{INT}(18)
!     chk_gem :: BIN
!     !prod_gd2 :: REAL
!     nb_terms :: INT
!     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_i_j_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
!     !!!
!
!     block_1 = two_rdm_elt.block_numbers(3)
!     b1 = block_1 + .n_1D_blocks
!     block_2 = two_rdm_elt.block_numbers(4)
!     b2 = block_2 + .n_1D_blocks
!     k = 0
!     t = k
!     term = ZERO
!     if (n == 1 OR n == 2) then
!        .sum_set_info_IZXY_IZ_ab_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_IZXY_IZ_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     nb_terms = 0
!     if (chk_gem) then
!        tt(1) = 1
!        nb_terms = 1
!        .grad_info_tmp.red_ov(1) = overlap
!        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(1).element(1) = b1
!        .grad_info_tmp.ex_blk(1).element(2) = b2
!        !.grad_info_tmp.ex_blk(1).element(1) = block_1
!        !.grad_info_tmp.ex_blk(1).element(2) = block_2
!        .grad_info_tmp.factor(1).element = 1
!        .grad_info_tmp.all_pairs(1) = TRUE
!        !
!        .grad_info_tmp.coef_prod(1) = coef_1+coef_2
!     end
!     !!!
!
!     t = k
!     if (n == 1) then
!        .sum_set_info_IZXY_XY_ab(two_rdm_elt,k)
!     else if (n == 2) then
!        .sum_set_info_IZXY_XY_aa(two_rdm_elt,k)
!     else if (n == 3) then
!        .sum_set_info_IZXY_XY_bb(two_rdm_elt,k)
!     end
!     !!!
!     chk_gem = TRUE
!     !!!
!     if (k /= t) then
!        geminal_1 = two_rdm_elt.sum_info(k,1)
!        geminal_2 = two_rdm_elt.sum_info(k,2)
!        if (.n_geminals > 2) then
!           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!              red_pbg.calc_overlap_integral(overlap,FALSE)
!              if (.bra_is_ket) then
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!              else
!                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!              end
!              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!              term(k) = (coef_1+coef_2)*overlap
!           else
!              !!!
!              !overlap = ZERO
!              chk_gem = FALSE
!              !!!
!              term(k) = ZERO
!           end
!        else
!           !!!
!           overlap = ONE
!           !!!
!           if (.bra_is_ket) then
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
!           else
!              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
!              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
!              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
!              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
!           end
!           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
!           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
!           term(k) = (coef_1+coef_2)
!        end
!     !!!
!     else
!        chk_gem = FALSE
!     !!!
!     end
!     !!!
!!     stdout.show("chk_gem =",chk_gem)
!     if (chk_gem) then
!        nb_terms = nb_terms+1
!        tt(nb_terms) = nb_terms
!        .grad_info_tmp.red_ov(nb_terms) = overlap
!        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!        .grad_info_tmp.factor(nb_terms).element = 1
!        .grad_info_tmp.all_pairs(nb_terms) = TRUE
!        !
!        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!     end
!     !!!
!
!     k = 2
!     do j=1,4
!        if (.block_types(block_1).element(j) /= 0) then
!           geminal_1 = .block_types(block_1).element(j)
!           do s=1,4
!              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
!                 geminal_2 = .block_types(block_2).element(s)
!                 if (.n_geminals > 2) then
!                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
!                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
!                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
!                       red_pbg.calc_overlap_integral(overlap,FALSE)
!                       if (.bra_is_ket) then
!                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
!                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
!                       else
!                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
!                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
!                       end
!                       k = k+1
!                       term(k) = coef_prod_1*coef_prod_2*overlap
!                    end
!                 else
!                    !!!
!                    overlap = ONE
!                    !!!
!                    if (.bra_is_ket) then
!                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
!                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
!                    else
!                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
!                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
!                    end
!                    k = k+1
!                    term(k) = coef_prod_1*coef_prod_2                    
!                 end
!              end
!              !!!
!              if (abs(term(k)) > TOL(15)) then
!                 nb_terms = nb_terms+1
!                 tt(nb_terms) = nb_terms
!                 .grad_info_tmp.red_ov(nb_terms) = overlap
!                 .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
!                 .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
!                 .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
!                 .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
!                 !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
!                 !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
!                 .grad_info_tmp.factor(nb_terms).element = 2
!                 .grad_info_tmp.all_pairs(nb_terms) = FALSE
!                 !
!                 .grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
!              end if
!              !!!
!           end
!        end
!     end
!
!     !!!
!     if (nb_terms > 0) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        !!! save gradient information
!        select case (n)
!        case(1)
!           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(2)
!           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case(3)
!           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
!           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
!        case default
!           stdout.text("Error in routine calc_2rdm_elt_i_j_grd:")
!           stdout.text("unknown integer value to select the 2RDM part.")
!           stop
!        end
!        !!! debug (new)
!        if (i == 41) then
!           stdout.show("nb_terms =",nb_terms) 
!           stdout.show("k =",k) 
!           stdout.show("terms =",term(1:k)) 
!           stdout.show("two_rdm_elt.coefficient =",two_rdm_elt.coefficient) 
!           stop
!        end
!        !!! end debug (new)
!        i = i+1
!     end
!     !!!
!
!!     if (abs(sum(term)) > TOL(15)) then
!!        two_rdm_elt.coefficient = sum(term)/.overlap
!!        if (n == 1) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!!        else if (n == 2) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!!        else if (n == 3) then
!!         !debug stdout.text(" ")
!!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!!        end
!!        i = i+1
!!     end
!
!   end

   calc_2rdm_elt_i_j_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(18)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(18)
     chk :: BIN
     nb_terms :: INT
     cc, jj :: INT
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_i_j_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     k = 0
     t = k
     term = ZERO
     if (n == 1 OR n == 2) then
        .sum_set_info_IZXY_IZ_ab_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_IZXY_IZ_bb(two_rdm_elt,k)
     end
     !!!
     nb_terms = 0
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms + 1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     t = k
     if (n == 1) then
        .sum_set_info_IZXY_XY_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_IZXY_XY_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_IZXY_XY_bb(two_rdm_elt,k)
     end
     !!!
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
        end
        !!!
     end

     k = 2
     do j=1,4
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           do s=1,4
              !!!
              chk = TRUE
              !!!
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 if (.n_geminals > 2) then
                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                       else
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                       end
                       k = k+1
                       term(k) = coef_prod_1*coef_prod_2*overlap
                    !!!
                    else
                       !term(k) = ZERO
                       chk = FALSE
                    !!!
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2                    
                 end
                 !!!
!                 if (abs(term(k)) > TOL(15)) then
                 if (chk) then
                    nb_terms = nb_terms+1
                    tt(nb_terms) = nb_terms
                    .grad_info_tmp.red_ov(nb_terms) = overlap
                    .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
                    .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
                    .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
                    .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
                    .grad_info_tmp.factor(nb_terms).element = 2
                    .grad_info_tmp.all_pairs(nb_terms) = FALSE
                    !
                    .grad_info_tmp.coef_prod(nb_terms) = coef_prod_1*coef_prod_2
                    !.grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
                 end
                 !!!
              end
           end
        end
     end

     !!! debug (new)
!     if (.debug) then
!        cc = 0
!        do jj=1,k 
!           if (abs(term(jj)) > TOL(15)) then
!              cc = cc + 1
!           end
!        end
!        if (cc /= nb_terms) then
!           stdout.text("Mismatch in calc_2rdm_elt_i_j_grd")
!           stdout.show("cc =",cc)
!           stdout.show("nb_terms =",cc)
!           stdout.show("terms =",term(1:k))
!           stdout.show("2RDM element",i)
!           stop
!        end
!     end
     !!! end debug (new)

     !!!
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_i_j_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!! debug (new)
!        if (i == 41) then
!           stdout.show("nb_terms =",nb_terms) 
!           stdout.show("k =",k) 
!           stdout.show("terms =",term(1:k)) 
!           stdout.show("two_rdm_elt.coefficient =",two_rdm_elt.coefficient) 
!!           stop
!        end
        !!! end debug (new)
        i = i+1
     end
     !!!

!     if (abs(sum(term)) > TOL(15)) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
!        i = i+1
!     end

   end
! de

   prep_red_pbg(red_pbg,g) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g :: INT, IN
     i, j, siz :: INT
     siz_prod :: INT


     ! prepare information to compute the overlap, excluding geminal g
     do i=1,.n_geminals
        if (i < g) then
           ! create vector of nonzero block indices
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(i).element.destroy
           red_pbg.nonzero_coef_ind(i).element.create(siz)
           red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(i).element.destroy
           red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
        else if (i > g) then
           j = i-1
           ! create vector of nonzero block indices
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.destroy
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.destroy
           red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
        end
     end
   end

   prep_red_pbg_g(red_pbg,g,gg) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg :: INT, IN
     i, j, k, l, siz :: INT
     t, tt :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end     
!     ! alternative:
!     t = min(g,gg)
!     tt = max(g,gg)

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        if (i < t) then
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(i).element.destroy
           red_pbg.nonzero_coef_ind(i).element.create(siz)
           red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(i).element.destroy
           red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(j).element.destroy
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.destroy
           red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           ! create vector of nonzero block indices
           red_pbg.nonzero_coef_ind(k).element.destroy
           red_pbg.nonzero_coef_ind(k).element.create(siz)
           red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
           ! create vector of nonzero products of coefficients
           siz_prod = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(k).element.destroy
           red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
           red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
        end
     end
   end

   prep_red_pbg(red_pbg,g,b,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g and block b;
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, b :: INT, IN
     problem :: BIN
     i, j, k, siz :: INT
     presence :: BIN
     ind :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     ! and block b

     problem = FALSE

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence = FALSE
        do k=1,siz
           if (.nonzero_coef_ind(i).element(k) == b) then
              presence = TRUE
              ind = k
              exit
           end
        end
        if (i < g) then
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(i).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
        else if (i > g) then  ! to skip geminal g and shift the geminals with i > g by -1
           j = i-1
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vectors of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(j).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create list of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (NOT presence) then
              ! create vectors of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create list of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg,g,b,bb,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminal g;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, b, bb :: INT, IN
     problem :: BIN
     i, j, l, siz :: INT
     b1, b2 :: INT
     presence1, presence2 :: BIN
     ind1, ind2 :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminal g
     ! and blocks b and bb

     problem = FALSE

     if (b < bb) then
        b1=b
        b2=bb
     else if (b > bb) then
        b1=bb
        b2=b
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence1 = FALSE
        presence2 = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b1) then
              presence1 = TRUE
              ind1 = l
              exit
           end
        end
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b2) then
              presence2 = TRUE
              ind2 = l
              exit
           end
        end
        if (i < g) then
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-2)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > g) then ! to skip geminal g and shift the following geminals by -1
           j = i-1
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-2)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg_g(red_pbg,g,gg,b,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg, b :: INT, IN
     problem :: BIN
     i, j, k, l, siz :: INT
     t, tt :: INT
     presence :: BIN
     ind :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     ! and block b

     problem = FALSE

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b) then
              presence = TRUE
              ind = l
              exit
           end
        end

        if (i < t) then
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(i).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(j).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           if (presence AND (siz>1)) then ! to skip block b, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind-1) = .nonzero_coef_ind(i).element(1:ind-1)
              red_pbg.nonzero_coef_ind(k).element(ind:siz-1) = .nonzero_coef_ind(i).element(ind+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if (NOT presence) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz)
              red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end

   prep_red_pbg(red_pbg,g,gg,b,bb,problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals g and gg;
   ! this new PBG will be used to compute an element of the 2RDM,
   ! belonging to the 1-orthogonal blocks space
     red_pbg :: PAULI_BLOCK_GEMINALS
     g, gg, b, bb :: INT, IN
     problem :: BIN
     i, j, k, l, siz :: INT
     t, tt, b1, b2 :: INT
     presence1, presence2 :: BIN
     ind1, ind2 :: INT
     siz_prod :: INT

     ! prepare information to compute the overlap, excluding geminals g and gg
     ! and blocks b and bb

     problem = FALSE

     if (g < gg) then
        t=g
        tt=gg
     else if (g > gg) then
        t=gg
        tt=g
     end
     if (b < bb) then
        b1=b
        b2=bb
     else if (b > bb) then
        b1=bb
        b2=b
     end     

     do i=1,.n_geminals
        siz = size(.nonzero_coef_ind(i).element)
        presence1 = FALSE
        presence2 = FALSE
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b1) then
              presence1 = TRUE
              ind1 = l
              exit
           end
        end
        do l=1,siz
           if (.nonzero_coef_ind(i).element(l) == b2) then
              presence2 = TRUE
              ind2 = l
              exit
           end
        end
        if (i < t) then
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-1)
              red_pbg.nonzero_coef_ind(i).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz-2)
              red_pbg.nonzero_coef_ind(i).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(i).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(i).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(i).element.destroy
              red_pbg.nonzero_coef_ind(i).element.create(siz)
              red_pbg.nonzero_coef_ind(i).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(i).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(i).element.destroy
              red_pbg.nonzero_coef_prod(i).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(i).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(i).element)
           else
              problem = TRUE
              exit
           end
         else if (i > t AND i < tt) then ! to skip geminal t and shift the following geminals i<tt by -1
           j = i-1
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-1)
              red_pbg.nonzero_coef_ind(j).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz-2)
              red_pbg.nonzero_coef_ind(j).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(j).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(j).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(j).element.destroy
              red_pbg.nonzero_coef_ind(j).element.create(siz)
              red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(j).element.destroy
              red_pbg.nonzero_coef_prod(j).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
           else
              problem = TRUE
              exit
           end
        else if (i > tt) then  ! to skip the two geminals and shift the following ones by -2
           k = i-2
           if (presence1 AND (NOT presence2) AND (siz>1)) then ! to skip block b1, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(k).element(ind1:siz-1) = .nonzero_coef_ind(i).element(ind1+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if ((NOT presence1) AND presence2 AND (siz>1)) then ! to skip block b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-1)
              red_pbg.nonzero_coef_ind(k).element(1:ind2-1) = .nonzero_coef_ind(i).element(1:ind2-1)
              red_pbg.nonzero_coef_ind(k).element(ind2:siz-1) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if (presence1 AND presence2 AND (siz>2)) then ! to skip blocks b1 and b2, if present
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz-2)
              red_pbg.nonzero_coef_ind(k).element(1:ind1-1) = .nonzero_coef_ind(i).element(1:ind1-1)
              red_pbg.nonzero_coef_ind(k).element(ind1:ind2-2) = .nonzero_coef_ind(i).element(ind1+1:ind2-1)
              red_pbg.nonzero_coef_ind(k).element(ind2-1:siz-2) = .nonzero_coef_ind(i).element(ind2+1:siz)
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else if ((NOT presence1) AND (NOT presence2)) then
              ! create vector of nonzero block indices
              red_pbg.nonzero_coef_ind(k).element.destroy
              red_pbg.nonzero_coef_ind(k).element.create(siz)
              red_pbg.nonzero_coef_ind(k).element = .nonzero_coef_ind(i).element
            !debug stdout.show("block indices, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_ind(k).element)
              ! create vector of nonzero products of coefficients
              siz_prod = size(.nonzero_coef_prod(i).element)
              red_pbg.nonzero_coef_prod(k).element.destroy
              red_pbg.nonzero_coef_prod(k).element.create(siz_prod)
              red_pbg.nonzero_coef_prod(k).element = .nonzero_coef_prod(i).element
            !debug stdout.show("coefficient products, geminal", i)
            !debug stdout.put(red_pbg.nonzero_coef_prod(k).element)
           else
              problem = TRUE
              exit
           end
        end
     end
   end


! davide: 18-10-2019
   prep_red_pbg_gg(red_pbg, gg, n_ex_gem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals "gg";
   ! this new PBG will be used to compute an element of the 1RDM or 2RDM,
   ! or an element of the derivative of the 2RDM with respect to a given 
   ! block coefficient
   ! --------------------------------------------------------------------
   ! red_pbg = new PBG
   ! gg = indices of the geminals to be excluded
   ! n_ex_gem = total number of geminals to be excluded
     red_pbg :: PAULI_BLOCK_GEMINALS
     gg :: VEC{INT}, IN
     n_ex_gem :: INT, IN
     pbg_created, exclude_gem :: BIN
     i, j, siz, count_ex_gem, ng :: INT

     ! set and check the number of geminals in the PBG 
     ! to be prepared
     ng = .n_geminals-n_ex_gem
     if (ng <= 0) then
        stdout.text("Error in prep_red_pbg_gg:")
        stdout.text("the number of geminals to be excluded is equal to") 
        stdout.text("or exceeds the total number of geminals.")
        stop
     end

     ! check if PBG has been already created and, 
     ! if already created, check its size
     ! (actually, here we check only if the vector of vectors
     ! ".nonzero_coef_ind" has been already created)
     pbg_created = red_pbg.nonzero_coef_ind.created
     if (pbg_created) then
        if (ng /= red_pbg.n_geminals) then
           red_pbg.nonzero_coef_ind.destroy
           red_pbg.nonzero_coef_prod.destroy
           red_pbg.n_geminals = ng
           red_pbg.nonzero_coef_ind.create(ng)
           red_pbg.nonzero_coef_prod.create(ng)
           red_pbg.first_block=.first_block
        end
     else
        red_pbg.n_geminals = ng
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
        red_pbg.first_block=.first_block
     end

     ! prepare information to compute the reduced 
     ! overlap, excluding geminals "gg"
     count_ex_gem = 0
     do i=1,.n_geminals
        exclude_gem = any(gg(1:n_ex_gem) == i)
        if (exclude_gem) then
           count_ex_gem = count_ex_gem+1
           cycle
        else
           j = i-count_ex_gem
           ! create a new vector of nonzero block indices
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_ind(j).element.destroy
           siz = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.create(siz)
           red_pbg.nonzero_coef_ind(j).element = .nonzero_coef_ind(i).element
         !debug stdout.show("block indices, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_ind(j).element)
           ! create a new vector of nonzero products of coefficients
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_prod(j).element.destroy
           siz = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.create(siz)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
         !debug stdout.show("coefficient products, geminal", i)
         !debug stdout.put(red_pbg.nonzero_coef_prod(j).element)
        end
     end

   end

   prep_red_pbg_gg_bb(red_pbg, gg, n_ex_gem, bb, n_ex_blk, problem) ::: leaky
   ! prepare a new pauli_block_geminal (PBG), excluding geminals "gg"
   ! and 2D blocks "bb"; this new PBG will be used to compute an element 
   ! of the 1RDM or 2RDM, or an element of the derivative of the 2RDM
   ! with respect to a given block coefficient
   ! --------------------------------------------------------------------
   ! red_pbg = new PBG
   ! gg = indices of the geminals to be excluded
   ! n_ex_gem = total number of geminals to be excluded
   ! bb = indices of the 2D blocks to be excluded
   ! n_ex_blk = total number of 2D blocks to be excluded
     red_pbg :: PAULI_BLOCK_GEMINALS
     gg, bb :: VEC{INT}, IN
     n_ex_gem, n_ex_blk :: INT, IN
     problem :: BIN, INOUT
     pbg_created, exclude_gem, exclude_blk :: BIN
     i, j, k, l :: INT
     siz, count_ex_gem, ng :: INT
     count_ex_blk, nb, ib, nz_blk :: INT
     !!! debug
!     stdout.text("Entering routine prep_red_pbg_gg_bb")
     !!!

     ! check if PBG has been created before and, 
     ! if already created, check its size
     ! (actually, here we check only if the vector of vectors
     ! ".nonzero_coef_ind" has been already created)
     pbg_created = red_pbg.nonzero_coef_ind.created
     ng = .n_geminals-n_ex_gem
     if (pbg_created) then
        if (ng /= red_pbg.n_geminals) then
           red_pbg.nonzero_coef_ind.destroy
           red_pbg.nonzero_coef_prod.destroy
           red_pbg.n_geminals = ng
           red_pbg.nonzero_coef_ind.create(ng)
           red_pbg.nonzero_coef_prod.create(ng)
           red_pbg.first_block=.first_block
        end
     else
        red_pbg.n_geminals = ng
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
        red_pbg.first_block=.first_block
     end

     ! prepare information to compute the reduced overlap, 
     ! excluding geminals "gg" and blocks "bb"
     problem = FALSE
     count_ex_gem = 0
     do i=1,.n_geminals
        exclude_gem = any(gg(1:n_ex_gem) == i)
        if (exclude_gem) then
           count_ex_gem = count_ex_gem+1
           cycle
        else
           j = i-count_ex_gem
           ! create a new vector of nonzero block indices
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_ind(j).element.destroy
           nz_blk = size(.nonzero_coef_ind(i).element)
           red_pbg.nonzero_coef_ind(j).element.create(nz_blk)
           ! construct "nonzero_coef_ind" excluding blocks "bb" 
           ! (if present among the nonzero blocks)
           count_ex_blk = 0
           do k=1,nz_blk
              ib = .nonzero_coef_ind(i).element(k)
              exclude_blk = any(bb(1:n_ex_blk) == ib)
              if (exclude_blk) then
                 count_ex_blk = count_ex_blk+1
                 cycle
              else
                 l = k-count_ex_blk
                 red_pbg.nonzero_coef_ind(j).element(l) = .nonzero_coef_ind(i).element(k)
              end
           end
           !!!
           !!! debug
!           stdout.show("geminal", i)
!           stdout.show("nz_blk       =", nz_blk)
!           stdout.show("count_ex_blk =", count_ex_blk)
           ! old
           !!!
!           if (nz_blk <= 1 AND count_ex_blk /= 0) then
!              problem = TRUE
!              return
!           end
!           !!!
!           nb = nz_blk-count_ex_blk
!           red_pbg.nonzero_coef_ind(j).element.shrink(nb)
           !!!
           ! new
           nb = nz_blk-count_ex_blk
           !!! debug
!           stdout.show("nb =", nb)
           !!!
           if (nb == 0) then
              ! all nonzero block in geminal "i" has to be excluded;
              ! hence, the reduced overalp will be ZERO
              problem = TRUE
              !!! debug
!              stdout.text("PROBLEM = TRUE")
              !!!
              return
           end
           red_pbg.nonzero_coef_ind(j).element.shrink(nb)
           !!!
           !!! debug
!           stdout.show("block indices, geminal", i)
!           stdout.put(red_pbg.nonzero_coef_ind(j).element)
           !!!
           ! create a new vector of nonzero products of coefficients
           ! (after destroying the one already created)
           red_pbg.nonzero_coef_prod(j).element.destroy
           siz = size(.nonzero_coef_prod(i).element)
           red_pbg.nonzero_coef_prod(j).element.create(siz)
           red_pbg.nonzero_coef_prod(j).element = .nonzero_coef_prod(i).element
           !!! debug
!           stdout.show("coefficient products, geminal", i)
!           stdout.put(red_pbg.nonzero_coef_prod(j).element)
           !!!
        end
     end

   end
! de

! davide: 27-11-2018
   prep_orbital_block_mapping
   ! prepare the vector containing the orbital 
   ! to block correspondence 
     i, d :: INT

     .orbital_block_mapping.create(.mat_size)

     ! 1-orthogonal blocks
     do i=1,.n_1D_blocks 
        .orbital_block_mapping(i) = 0
     end

     ! Pauli blocks
     do i=.n_1D_blocks+1,.mat_size 
         d = i-.n_1D_blocks+1
        .orbital_block_mapping(i) = int(d/2)
     end

   !debug stdout.text(" ")
   !debug stdout.text("Orbitals to blocks mapping:")
   !debug stdout.put(.orbital_block_mapping)

   end

   prep_block_types
   ! prepare the vector of vectors containing the indices of geminal
   ! for the 5 block types ID2, SZ, SX, ISY, GD2
     i :: INT
     n_pauli_blocks :: INT
     
     ! create vector of vectors "block_types"
     n_pauli_blocks = .n_blocks-.n_1D_blocks 
     .block_types.create(n_pauli_blocks)
     do i=1,n_pauli_blocks
        .block_types(i).element.create(5)
        .block_types(i).element = 0
     end

     ! prepare "block_types"
     do i=1,.n_geminals
        .prep_block_types(.bra_set.vec(i),i)
     end

     ! write "block_types"
   !debug stdout.text(" ")
   !debug stdout.text("Block types vectors:")
!     do i=1,n_pauli_blocks
!      !debug stdout.text(" ")
!      !debug stdout.show("2D block", i)
!      !debug stdout.put(.block_types(i).element)
!     end

   end

   prep_block_types(pbt,g)
   ! prepare "block types", checking each geminal
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT, IN
     i, j, n :: INT

     do i=.n_1D_blocks+1,.n_blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           n = .select_block_type(pbt.block_type(i))
           j = i - .n_1D_blocks
           .block_types(j).element(n) = g
        end
     end

   end

   select_block_type(bty) result(n)
   ! select the block type and provide an integer
   ! for the preparation of "block types"
     bty :: STR, IN
     n :: INT

     select case (bty)
        case("ID2") 
           n = 1
        case("SZ") 
           n = 2
        case("SX") 
           n = 3
        case("ISY") 
           n = 4
        case("GD2") 
           n = 5
        case default   
         !debug stdout.text("unrecognized block type")
           stop
     end

   end
! de

   prep_block_1orthos
   ! prepare the vector containing the indices of geminal
   ! for the 1-orthogonal part
     i :: INT
     
     ! create vector "block_1orthos"
     .block_1orthos.create(.n_1D_blocks)
     do i=1,.n_1D_blocks
        .block_1orthos(i) = 0
     end

     ! prepare "block_1orthos"
     do i=1,.n_geminals
        .prep_block_1orthos(.bra_set.vec(i),i)
     end

     ! write "block_1orthos"
   !debug stdout.text(" ")
   !debug stdout.text("1-orthogonal block vector:")
     do i=1,.n_1D_blocks
      !debug stdout.text(" ")
      !debug stdout.show("1-orthogonal block", i)
      !debug stdout.show("geminal", .block_1orthos(i))
     end

   end

   prep_block_1orthos(pbt,g)
   ! prepare "block 1orthos", checking each geminal
     pbt :: PAULI_BLOCK_TENSOR
     g :: INT, IN
     i :: INT

     do i=1,.n_1D_blocks
        if (abs(pbt.coef(i)) > TOL(15)) then
           .block_1orthos(i) = g
        end
     end

   end

   sum_set_info_IZ_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(2) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(2)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZ_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(2) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(2)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == x) OR (u == y AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == x) OR (u == y AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IX_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IX_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IY_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZY_DD_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end

   sum_set_info_ZY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZY_DD_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_IZ_ab_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w) OR (u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_IZ_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_XY_ab(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w) OR (u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_XY_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w) OR (u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZXY_XY_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combinations "ID2 and SZ" or "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(1)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)
     z = .block_types(b_i).element(2)

     if ((u == w AND v == z) OR (u == z AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


! davide: 26-11-2018
   destroy_nonzero_coef
   ! destroy memory created for vectors of vectors
   ! "nonzero_coef_ind" and "nonzero_coef_prod" 
     i, ng :: INT

     ng = .n_geminals
     do i=1,ng
        .nonzero_coef_ind(i).element.destroy
        .nonzero_coef_prod(i).element.destroy
     end

     .nonzero_coef_ind.destroy
     .nonzero_coef_prod.destroy

   end
! de

! RANDOM GENARATOR OF SET OF GEMINALS

! davide: 20-11-2018 / 01-10-2019
   random_geminals_generator ::: leaky
   ! generate random geminals which satisfy 
   ! the constraints of the model
     bra_not_created, ket_not_created :: BIN
     !bra_not_alloc, ket_not_alloc :: BIN

     ! if guess_type is "hf-random", set block partition;
     ! else the block partition defined in routine "set_defaults"
     ! or in the input (keyword "block_partition=") will be employed
     if (.guess_type == "hf-random") then
       .set_block_partition_hf
     end

     ! check if the bra and ket sets are already created;
     ! if not, create them
     bra_not_created = NOT .bra_set.vec(1).coef.created
!     ket_not_created = NOT .ket_set.vec(1).coef.created
!     stdout.show("bra_not_created =",bra_not_created)
!     stdout.text(" ")
     if (bra_not_created) then 
        .create_pbt_set(.bra_set)
     else
        .destroy_pbt_set(.bra_set)
        .create_pbt_set(.bra_set)
     end
     !
     if (NOT .bra_is_ket) then
        ket_not_created = NOT .ket_set.vec(1).coef.created
!        stdout.show("ket_not_created =",ket_not_created)
!        stdout.text(" ")
        if (ket_not_created) then 
           .create_pbt_set(.ket_set)
        else
           .destroy_pbt_set(.ket_set)
           .create_pbt_set(.ket_set)
        end
     end
!
!     if (.bra_is_ket) then
!        ! if bra and ket sets are the same
!        if (bra_not_created) then 
!           .create_pbt_set(.bra_set)
!        else
!           .destroy_pbt_set(.bra_set)
!           .create_pbt_set(.bra_set)
!        end
!     else
!        ! if bra and ket sets are different
!        if (bra_not_created AND ket_not_created) then 
!           .create_pbt_set(.bra_set)
!           .create_pbt_set(.ket_set)
!        else if (bra_not_created) then 
!           .create_pbt_set(.bra_set)
!        else if (ket_not_created) then 
!           .create_pbt_set(.ket_set)
!        end
!     end
!
!     ! check if the bra and ket sets are already created;
!     ! if not, create them
!     bra_not_alloc = NOT allocated(.bra_set.vec)
!     ket_not_alloc = NOT allocated(.ket_set.vec)
!     if (.bra_is_ket AND bra_not_alloc) then 
!        .create_pbt_set(.bra_set)
!     else if (bra_not_alloc AND ket_not_alloc) then 
!        .create_pbt_set(.bra_set)
!        .create_pbt_set(.ket_set)
!     else if (bra_not_alloc) then 
!        .create_pbt_set(.bra_set)
!     else if (ket_not_alloc) then 
!        .create_pbt_set(.ket_set)
!     end

     !!!!!!!!
     ! debug
     stdout.show("spin_restricted =",.spin_restricted)
     !!!!!!!!

     if (.spin_restricted) then
        .guess_geminals_restricted
     else
        .guess_geminals_unrestricted
     end

   end

   create_pbt_set(pbt_set) ::: leaky
   ! create a set of geminals (i.e. Pauli Block Tensors) 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, n_1D_blocks_plus_1 :: INT

!     stdout.text(" ")
!     stdout.text("creation of a set of geminals")

     ! allocate a set of Pauli Block Tensors (PBT) 
     allocate(pbt_set.vec(.n_geminals))

     ! set the number of geminals, 
     ! the number of blocks and
     ! the spin restrictions
     pbt_set.set_size=.n_geminals
     pbt_set.set_size_sing=.n_gem_singlet
     pbt_set.n_blocks=.n_blocks
     pbt_set.n_1D_blocks=.n_1D_blocks
     pbt_set.n_2D_blocks=.n_2D_blocks
     pbt_set.n_2D_3typ_blocks=.n_2D_3typ_blocks
     pbt_set.n_2D_4typ_blocks=.n_2D_4typ_blocks
     pbt_set.spin_restricted=.spin_restricted

     n_1D_blocks_plus_1 = .n_1D_blocks+1
     do i=1,.n_geminals 
        ! create the vectors of block types,
        ! block dimensions and coefficients
        pbt_set.vec(i).block_type.create(.n_blocks)
        pbt_set.vec(i).block_dim.create(.n_blocks)
        pbt_set.vec(i).coef.create(.n_blocks)
        ! set the block dimensions
        pbt_set.vec(i).block_dim(1:.n_1D_blocks) = 1
        pbt_set.vec(i).block_dim(n_1D_blocks_plus_1:.n_blocks) = 2
        ! set the number of 1D and 2D blocks
        ! in each PBT
        pbt_set.vec(i).n_1D_blocks=.n_1D_blocks
        pbt_set.vec(i).n_2D_blocks=.n_2D_blocks
     end

     ! make the vector of numbers of block types
     ! for each block
     .make_type_numbers(pbt_set)

   end

   destroy_pbt_set(pbt_set) ::: leaky
   ! destroy a set of geminals (i.e. Pauli Block Tensors) 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, set_size, n_blocks :: INT

!     stdout.text(" ")
!     stdout.text("destruction of a set of geminals")

     ! destroy the set of geminals
     set_size = pbt_set.set_size
     do i=1,set_size
        ! create the vectors of block types,
        ! block dimensions and coefficients
        pbt_set.vec(i).block_type.destroy
        pbt_set.vec(i).block_dim.destroy
        pbt_set.vec(i).coef.destroy
     end
     ! deallocate a set of Pauli Block Tensors (PBT) 
     deallocate(pbt_set.vec)

     ! destroy the vector of numbers of block types
     ! for each block
     if(pbt_set.type_nb.created) then
        n_blocks = pbt_set.type_nb.dim
        do i=1,n_blocks
          pbt_set.type_nb(i).element.destroy
        end
        pbt_set.type_nb.destroy
     end

   end

   set_block_partition_hf
   ! set block partition in case of HF or 
   ! HF-random set of geminals
     ms, dif, nn :: INT

     ! set number of geminals
     .n_geminals = (.n_el+1)/2
     !
     ! set number of spin singlet geminals
     ms = .spin_multi
     .n_gem_singlet = (.n_el-ms+1)/2 
     !
     ! set number of blocks
     .n_blocks = .n_geminals+(.n_bf-.n_geminals+1)/2
     !
     ! set number of blocks of size 1 in each PBT
     dif = .mat_size-.n_gem_singlet
     nn = (dif/2)*2
     if (nn /= dif) then
       .n_1D_blocks = .n_gem_singlet+1
     else
       .n_1D_blocks = .n_gem_singlet
     end
     ! set first_block
     if (.n_1D_blocks > 0) then
       .first_block = 0
     else
       .first_block = 1
     end
     !
     ! set number of blocks of size 2 in each PBT
     .n_2D_blocks = .n_blocks-.n_1D_blocks
     .n_2D_3typ_blocks = 0
     .gen_block=FALSE
     .n_2D_4typ_blocks = .n_blocks-.n_1D_blocks
     !
     if (.GD2_info.created) then 
       .GD2_info.destroy
     end

   end

! spin restricted

! davide: 20-11-2018 / 01-10-2019
   guess_geminals_restricted ::: leaky
   ! generate guess set of geminals in the 
   ! spin restricted case
     i :: INT

   !debug 
     stdout.text(" ")
   !debug 
     if (.guess_type == "hf-random") then
        !stdout.text("Mixed HF-random guess set:")
        stdout.text(" ")
        stdout.show("random_scaling =",.random_scaling)
!     else
!        stdout.text("Random guess set:")
     end
     stdout.text(" ")
     stdout.text("Bra set:")
     !
     ! make 1D block structure
     .make_1D_blocks(.bra_set)
     ! make 2D block structure
     .make_2D_blocks_restricted(.bra_set)
     !
     !!!!!!!!!!
     ! debug
     stdout.text(" ")
     stdout.show("# 1D blocks =",.bra_set.n_1D_blocks)
     stdout.show("# 2D blocks =",.bra_set.n_2D_blocks)
     stdout.show("# 2D 3type blocks =",.bra_set.n_2D_3typ_blocks)
     stdout.show("# 2D 4type blocks =",.bra_set.n_2D_4typ_blocks)
     stdout.text(" ")
     !
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end
     if (.bra_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end
     !!!!!!!!!!

     if (.bra_is_ket) then
        ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
       ! stdout.text(" ")
       ! stdout.text("Randomly generated ket set:")
       ! 
       ! do i=1,.n_geminals
       !  !debug stdout.text(" ")
       !  !debug stdout.show("geminal",i)
       !  !debug stdout.text("block structure:")
       !  !debug stdout.put(.ket_set.vec(i).block_type)
       !  !debug stdout.text("coefficients:")
       !  !debug stdout.put(.ket_set.vec(i).coef)
       ! end
     else
        stdout.text(" ")
        stdout.text("Ket set:")
        !
        ! make 1D block structure
        .make_1D_blocks(.ket_set)
        ! make 2D block structure
        .make_2D_blocks_restricted(.ket_set)
        !
        !!!!!!!!!!
        ! debug
        stdout.text(" ")
        stdout.show("# 1D blocks =",.ket_set.n_1D_blocks)
        stdout.show("# 2D blocks =",.ket_set.n_2D_blocks)
        stdout.show("# 2D 3type blocks =",.ket_set.n_2D_3typ_blocks)
        stdout.show("# 2D 4type blocks =",.ket_set.n_2D_4typ_blocks)
        stdout.text(" ")
        do i=1,.n_geminals
           stdout.text(" ")
           stdout.show("geminal",i)
           stdout.text("block structure:")
           stdout.put(.ket_set.vec(i).block_type)
           stdout.text("coefficients:")
           stdout.put(.ket_set.vec(i).coef)
        end
        if (.ket_set.n_2D_3typ_blocks > 0) then
           stdout.text(" ")
           stdout.text("Angles defining GD2 matrices:")
           !stdout.text("GD2 info vector:")
           stdout.put(.GD2_info)
        end
        !!!!!!!!!!
     end

   end

   make_1D_blocks(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the blocks of size 1 (of each geminal)
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, set_size, n_1D_blocks :: INT
     num :: REAL
     mixed_hf_random :: BIN

     set_size = pbt_set.set_size  ! number of geminals
     n_1D_blocks = pbt_set.n_1D_blocks  ! number of blocks of size 1 (1D)
     !
     ! in case of spin restricted, if a doublet or triplet state
     ! is selected, build the 1D block structure for the last geminal
     ! (zero coefficient for each 1D block), and decrement "set_size" by 1
     if (.spin_restricted AND .spin_multi>1) then
        pbt_set.vec(set_size).block_type(1:n_1D_blocks) = "ID1"
        pbt_set.vec(set_size).coef(1:n_1D_blocks) = ZERO
        set_size = set_size-1
     end
     !
     ! check if the random set has to be: (i) mixed HF-random,
     ! or (ii) random
     mixed_hf_random = FALSE
     if (.guess_type == "hf-random")  mixed_hf_random = TRUE
     !
     if (mixed_hf_random) then
        do i=1,set_size
           ! assign block type ID1 to each 1D block
           pbt_set.vec(i).block_type(1:n_1D_blocks) = "ID1"
           ! set coefficients for the the first "set_size" 1D blocks (HF part)
           pbt_set.vec(i).coef(1:n_1D_blocks) = ZERO
           pbt_set.vec(i).coef(i) = ONE
        end
     else
        do i=1,set_size
           ! assign block type ID1 to each 1D block
           pbt_set.vec(i).block_type(1:n_1D_blocks) = "ID1"
           ! generate coefficients for the first "set_size" 1D blocks
           pbt_set.vec(i).coef(1:n_1D_blocks) = ZERO
           call random_number(num)
           pbt_set.vec(i).coef(i) = (num - HALF)*TWO
        end
     end
     ! generate coefficients for the last 
     ! (n_1D_blocks-set_size) 1D blocks
     ! (if n_1D_blocks > set_size)
     do i=set_size+1,n_1D_blocks
        call random_number(num)
        j = int(num*set_size)+1  ! selection of the j-th geminal
        call random_number(num)                    ! generation of the coefficient for
        pbt_set.vec(j).coef(i) = (num - HALF)*TWO  ! the i-th 1D block of geminal j
        ! in case of a mixed HF-random set of geminals,
        ! the coefficient is scaled
        if (mixed_hf_random) then
           num = pbt_set.vec(j).coef(i)
           pbt_set.vec(j).coef(i) = num*.random_scaling
        end
     end

   end

   make_2D_blocks_restricted(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the blocks of size 2 (2D) of each geminal 
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, k, set_size, n_1D_blocks, n_blocks :: INT
     set_size_minus_1, set_size_minus_2 :: INT
     gem :: VEC{INT}(3)
     num :: REAL
     n_2D_3typ_blocks :: INT
     n_2D_4typ_blocks :: INT
     b_3typ :: VEC{STR}(2)
     b_4typ :: VEC{STR}(3)
     n_2D_blocks :: INT
!     n_2D_blocks_plus_1 :: INT
     mixed_hf_random :: BIN

     set_size = pbt_set.set_size ! number of geminals
     n_blocks = pbt_set.n_blocks ! number of blocks
     n_1D_blocks = pbt_set.n_1D_blocks ! number of blocks of size 1 (1D)
     n_2D_blocks = pbt_set.n_2D_blocks ! number of blocks of size 2 (2D)

     ! check if the random set has to be: (i) mixed HF-random,
     ! or (ii) random
     mixed_hf_random = FALSE
     if (.guess_type == "hf-random")  mixed_hf_random = TRUE

!     !!!!
!     ! check if only 4-type blocks have to be included in the 2D part 
!     !!!!

     ! if a doublet or a triplet state is selected,
     ! build the 2D block structure for the last geminal
     ! (and decrement "set_size" by 1)
     if (.spin_multi == 2) then
        ! doublet state:
        ! nonzero coefficient only for the last 2D block,
        ! the one with one orbital at infinity
        pbt_set.vec(set_size).block_type(n_1D_blocks+1:n_blocks-1) = "ID2"
        pbt_set.vec(set_size).block_type(n_blocks) = "SX"
        pbt_set.vec(set_size).coef(n_1D_blocks+1:n_blocks-1) = ZERO
        call random_number(num)
        pbt_set.vec(set_size).coef(n_blocks) = (num - HALF)*TWO
        set_size = set_size-1
     else if (.spin_multi == 3) then
        ! triplet state:
        ! all 2D blocks of type "ISY", each with a nonzero coefficient
        if (mixed_hf_random) then
           i = n_1D_blocks+1
           pbt_set.vec(set_size).block_type(i) = "ISY"
           pbt_set.vec(set_size).coef(i) = ONE/SQRT_2
           do i=n_1D_blocks+2,n_blocks
              pbt_set.vec(set_size).block_type(i) = "ISY"
              call random_number(num)
              pbt_set.vec(set_size).coef(i) = (num - HALF)*TWO*.random_scaling
           end
        else
           do i=n_1D_blocks+1,n_blocks
              pbt_set.vec(set_size).block_type(i) = "ISY"
              call random_number(num)
              pbt_set.vec(set_size).coef(i) = (num - HALF)*TWO
           end
        end
        set_size = set_size-1
     end

     ! inizialize the 2D block structure and coefficients
     do i=1,set_size
        pbt_set.vec(i).coef(n_1D_blocks+1:n_blocks) = ZERO
        pbt_set.vec(i).block_type(n_1D_blocks+1:n_blocks) = "ID2"
     end
     ! decide the number of 2D blocks with at most 3 types (3typ)
     ! and the one with at most 4 types (4typ)
     !!!!
     if (.only_3typ) then
        n_2D_3typ_blocks = n_2D_blocks
        n_2D_4typ_blocks = 0
     else if (.only_4typ) then
        n_2D_3typ_blocks = 0
        n_2D_4typ_blocks = n_2D_blocks
     else
        call random_number(num)
        n_2D_3typ_blocks = int(num*(n_2D_blocks+1))
        n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     end if
!     n_2D_blocks_plus_1 = n_2D_blocks+1
!     call random_number(num)
!     n_2D_3typ_blocks = int(num*n_2D_blocks_plus_1)
!     n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     !!!!
     ! total number of 2D 3typ blocks
     pbt_set.n_2D_3typ_blocks = n_2D_3typ_blocks
     .n_2D_3typ_blocks = n_2D_3typ_blocks
!     stdout.show("# 2D 3typ blocks =", n_2D_3typ_blocks)
     ! set binary variable "gen_block"
     if (n_2D_3typ_blocks > 0) then
        .gen_block = TRUE
        ! prepare vector of angles for 3typ blocks
        if (.GD2_info.created) then
           .GD2_info.destroy
           .GD2_info.create(n_2D_3typ_blocks)
        else
           .GD2_info.create(n_2D_3typ_blocks)
        end
     else
        .gen_block = FALSE
     end
     ! total number of 2D 4typ blocks
     pbt_set.n_2D_4typ_blocks = n_2D_4typ_blocks
     .n_2D_4typ_blocks = n_2D_4typ_blocks
!     stdout.show("# 2D 4typ blocks =", n_2D_4typ_blocks)
     !
     set_size_minus_1 = set_size-1
     set_size_minus_2 = set_size-2
     !
     ! loop over the 2D 3TYP BLOCKS
     !
     do i=n_1D_blocks+1,n_1D_blocks+n_2D_3typ_blocks
        ! select 2 singlet geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
        end
        ! assign a type of Pauli block (type3) and a coefficient
        ! to each of the 2 selected geminals
        call random_number(num)
        j = int(num*2)
        b_3typ = .select_block_2D_3typ_res(j)
        do k=1,min(2,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_3typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
        ! assign an angle (between 0 and Pi, Pi excluded)
        call random_number(num)
        j = i-n_1D_blocks
        .GD2_info(j) = num*PI 
     end
     !
     ! loop over the 2D 4TYP BLOCKS
     !
     do i=n_1D_blocks+n_2D_3typ_blocks+1,n_blocks
        ! select 3 spin singlet geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
           end
        end
        ! assign a type of Pauli block (type4) and a coefficient
        ! to each of the 3 selected geminals
        call random_number(num)
        j = int(num*6)
        b_4typ = .select_block_2D_4typ_res(j)
        do k=1,min(3,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_4typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
     end

     ! in case of a mixed HF-random set of geminals,
     ! all the coefficients of the 2D blocks (of the
     ! spin singlet geminals) are scaled
     if (mixed_hf_random) then
        j = n_1D_blocks+1
        k = n_blocks
        do i=1,set_size
           pbt_set.vec(i).coef(j:k) = pbt_set.vec(i).coef(j:k)*.random_scaling
        end
     end

   end

   select_block_2D_3typ_res(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the block types (GD2, SX)
     integ :: INT, IN
     b_types :: VEC{STR}(2)

     select case (integ)
        case(0)
           b_types(1) = "GD2"
           b_types(2) = "SX"
        case(1)
           b_types(1) = "SX"
           b_types(2) = "GD2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
     end

   end

   select_block_2D_4typ_res(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the pauli block types (ID2, SX, SZ)
     integ :: INT, IN
     b_types :: VEC{STR}(3)

     select case (integ)
        case(0)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "SZ"
        case(1)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "SX"
        case(2)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
        case(3)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
        case(4)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "SX"
        case(5)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ID2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
      end

   end
! de

! spin unrestricted

! davide 01-10-2019
   guess_geminals_unrestricted ::: leaky
   ! generate guess set of geminals in the 
   ! spin unrestricted case
     i :: INT

   !debug 
     stdout.text(" ")
   !debug 
     if (.guess_type == "hf-random") then
!        stdout.text("Mixed HF-random guess bra set:")
        stdout.text(" ")
        stdout.show("random_scaling =",.random_scaling)
!     else
!        stdout.text("Random guess bra set:")
     end
     stdout.text(" ")
     stdout.text("Bra set:")
     !
     ! make 1D block structure
     .make_1D_blocks(.bra_set)
     ! make 2D block structure
     .make_2D_blocks_unrestricted(.bra_set)
     !
     !!!!!!!!!!
     ! debug
     stdout.text(" ")
     stdout.show("n_1D_blocks =",.bra_set.n_1D_blocks)
     stdout.show("n_2D_blocks =",.bra_set.n_2D_blocks)
     stdout.show("n_2D_3typ_blocks =",.bra_set.n_2D_3typ_blocks)
     stdout.show("n_2D_4typ_blocks =",.bra_set.n_2D_4typ_blocks)
     stdout.text(" ")
     do i=1,.n_geminals
       stdout.text(" ")
       stdout.show("geminal",i)
       stdout.text("block structure:")
       stdout.put(.bra_set.vec(i).block_type)
       stdout.text("coefficients:")
       stdout.put(.bra_set.vec(i).coef)
     end
     if (.bra_set.n_2D_3typ_blocks > 0) then
        stdout.text(" ")
        stdout.text("Angles defining GD2 matrices:")
        !stdout.text("GD2 info vector:")
        stdout.put(.GD2_info)
     end
     !!!!!!!!!!

     if (.bra_is_ket) then
        ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
       ! stdout.text(" ")
       ! stdout.text("Randomly generated ket set:")
       ! 
       ! do i=1,.n_geminals
       !  !debug stdout.text(" ")
       !  !debug stdout.show("geminal",i)
       !  !debug stdout.text("block structure:")
       !  !debug stdout.put(.ket_set.vec(i).block_type)
       !  !debug stdout.text("coefficients:")
       !  !debug stdout.put(.ket_set.vec(i).coef)
       ! end
     else
        stdout.text(" ")
        stdout.text("Ket set:")
        !
        ! make 1D block structure
        .make_1D_blocks(.ket_set)
        ! make 2D block structure
        .make_2D_blocks_unrestricted(.ket_set)
        !
        !!!!!!!!!!!!!
        !!!! debug
        stdout.text(" ")
        stdout.show("n_1D_blocks =",.ket_set.n_1D_blocks)
        stdout.show("n_2D_blocks =",.ket_set.n_2D_blocks)
        stdout.show("n_2D_3typ_blocks =",.ket_set.n_2D_3typ_blocks)
        stdout.show("n_2D_4typ_blocks =",.ket_set.n_2D_4typ_blocks)
        stdout.text(" ")
        do i=1,.n_geminals
          stdout.text(" ")
          stdout.show("geminal",i)
          stdout.text("block structure:")
          stdout.put(.ket_set.vec(i).block_type)
          stdout.text("coefficients:")
          stdout.put(.ket_set.vec(i).coef)
        end
        if (.ket_set.n_2D_3typ_blocks > 0) then
           stdout.text(" ")
           stdout.text("Angles defining GD2 matrices:")
           !stdout.text("GD2 info vector:")
           stdout.put(.GD2_info)
        end
        !!!!!!!!!!!!!
     end

   end

   make_2D_blocks_unrestricted(pbt_set)
   ! make the block structure and generate the coefficients 
   ! for the blocks of size 2 (2D) of each geminal 
   ! in the spin unrestricted case
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     i, j, k, set_size, n_1D_blocks, n_blocks :: INT
     set_size_minus_1, set_size_minus_2 :: INT
     set_size_minus_3 :: INT
     gem :: VEC{INT}(4)
     num :: REAL
     n_2D_3typ_blocks :: INT
     n_2D_4typ_blocks :: INT
     b_3typ :: VEC{STR}(3)
     b_4typ :: VEC{STR}(4)
     n_2D_blocks :: INT
     n_2D_blocks_plus_1 :: INT
     !
     l, n, dum :: INT
     w :: VEC{INT}(3)
     !

     set_size = pbt_set.set_size ! set_size = n_geminals
     n_blocks = pbt_set.n_blocks ! n_blocks = total number of blocks
     n_1D_blocks = pbt_set.n_1D_blocks ! n_1D_blocks = number of blocks of size 1
     n_2D_blocks = pbt_set.n_2D_blocks ! n_2D_blocks = number of blocks of size 2

     ! inizialize the 2D block structure and coefficients
     do i=1,set_size
        pbt_set.vec(i).coef(n_1D_blocks+1:n_blocks) = ZERO
        pbt_set.vec(i).block_type(n_1D_blocks+1:n_blocks) = "ID2"
     end

     ! decide the number of 2D blocks with at most 3 types (3typ)
     ! and the one with at most 4 types (4typ)
     !!!
     if (.only_3typ) then
        n_2D_3typ_blocks = n_2D_blocks
        n_2D_4typ_blocks = 0
     else if (.only_4typ) then
        n_2D_3typ_blocks = 0
        n_2D_4typ_blocks = n_2D_blocks
     else
        call random_number(num)
        n_2D_3typ_blocks = int(num*(n_2D_blocks+1))
        n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     end if
!     n_2D_blocks_plus_1 = n_2D_blocks+1
!     call random_number(num)
!     n_2D_3typ_blocks = int(num*n_2D_blocks_plus_1)
!     n_2D_4typ_blocks = n_2D_blocks-n_2D_3typ_blocks
     !!!

     ! total number of 2D 3typ blocks 
     pbt_set.n_2D_3typ_blocks = n_2D_3typ_blocks
     .n_2D_3typ_blocks = n_2D_3typ_blocks
!     stdout.show("# 2D 3typ blocks =", n_2D_3typ_blocks)
     ! set binary variable "gen_block"
     if (n_2D_3typ_blocks > 0) then
        .gen_block = TRUE
        ! prepare vector of angles for 3typ blocks
        if (.GD2_info.created) then
           .GD2_info.destroy
           .GD2_info.create(n_2D_3typ_blocks)
        else
           .GD2_info.create(n_2D_3typ_blocks)
        end
     else
        .gen_block = FALSE
     end
!     ! prepare vector of angles for 3typ blocks
!     if (.GD2_info.created) then
!        .GD2_info.destroy
!        .GD2_info.create(n_2D_3typ_blocks)
!     else
!        .GD2_info.create(n_2D_3typ_blocks)
!     end
     ! total number of 2D 4typ blocks 
     pbt_set.n_2D_4typ_blocks = n_2D_4typ_blocks
     .n_2D_4typ_blocks = n_2D_4typ_blocks
!     stdout.show("# 2D 4typ blocks =", n_2D_4typ_blocks)

     set_size_minus_1 = set_size-1
     set_size_minus_2 = set_size-2
     set_size_minus_3 = set_size-3
     !
     ! loop over the 2D 3TYP BLOCKS
     !
     do i=n_1D_blocks+1,n_1D_blocks+n_2D_3typ_blocks
        ! select 3 geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
           end
        end
        ! assign a type of Pauli block (type3) and a coefficient
        ! to each of the 2 selected geminals
        call random_number(num)
        j = int(num*6)
        b_3typ = .select_block_2D_3typ_unres(j)
        do k=1,min(3,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_3typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
        ! assign an angle (between 0 and Pi, Pi excluded)
        call random_number(num)
        j = i-n_1D_blocks
        .GD2_info(j) = num*PI 
     end
     !
     ! loop over the 2D 4TYP BLOCKS
     !
     do i=n_1D_blocks+n_2D_3typ_blocks+1,n_blocks
        ! select 4 geminals with a nonzero coefficient
          ! 1st geminal
        call random_number(num)
        gem(1) = int(num*set_size)+1
        if (set_size > 1) then
             ! 2nd geminal
           call random_number(num)
           j = int(num*set_size_minus_1)+1
           if (j >= gem(1)) then
              gem(2) = j+1
           else
              gem(2) = j
           end
           if (set_size > 2) then
                ! 3rd geminal
              call random_number(num)
              j = int(num*set_size_minus_2)+1
              if ( j < min(gem(1),gem(2)) ) then
                 gem(3) = j
              else if ( j >= (max(gem(1),gem(2))-1) ) then
                 gem(3) = j+2
              else
                 gem(3) = j+1
              end
              if (set_size > 3) then
                   ! 4th geminal
                 call random_number(num)
                 j = int(num*set_size_minus_3)+1
                 !!!!!!!!!!
                 ! sort indices of the 3 previously selected 
                 ! geminals in increasing order (and store 
                 ! them in working array "w")
                 n = 3
                 do k=1,n
                    w(k) = gem(k)
                 end
                 do k=1,n-1
                    do l=k+1,n
                       if (w(k) > w(l)) then
                          ! swap w(k) and w(l)
                          dum = w(l)
                          w(l) = w(k)
                          w(k) = dum
                       end
                    end
                 end
                 !!!!!!!!!!
                 ! select the 4th geminal
                 if ( j < w(1) ) then
                    gem(4) = j
                 else if ( j >= w(3)-2 ) then
                    gem(4) = j+3
                 else if ( j >= w(1) AND j < w(2)-1 ) then 
                    gem(4) = j+1
                 else
                    ! if ( j >= w(2)-1 AND j < w(3)-2 )
                    gem(4) = j+2
                 end
              end
           end
        end
        ! assign a type of Pauli block (type4) and a coefficient
        ! to each of the 4 selected geminals
        call random_number(num)
        j = int(num*24)
        b_4typ = .select_block_2D_4typ_unres(j)
        do k=1,min(4,set_size)
           pbt_set.vec(gem(k)).block_type(i) = b_4typ(k)
           call random_number(num)
           pbt_set.vec(gem(k)).coef(i) = (num - HALF)*TWO
        end
     end

     ! in case of a mixed HF-random set of geminals,
     ! all the coefficients of the 2D blocks are scaled
     if (.guess_type == "hf-random") then
        j = n_1D_blocks+1
        k = n_blocks
        do i=1,set_size
           pbt_set.vec(i).coef(j:k) = pbt_set.vec(i).coef(j:k)*.random_scaling
        end
     end

   end

   select_block_2D_3typ_unres(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the block types (GD2, SX, ISY)
     integ :: INT, IN
     b_types :: VEC{STR}(3)

     select case (integ)
        case(0)
           b_types(1) = "GD2"
           b_types(2) = "SX"
           b_types(3) = "ISY"
        case(1)
           b_types(1) = "GD2"
           b_types(2) = "ISY"
           b_types(3) = "SX"
        case(2)
           b_types(1) = "SX"
           b_types(2) = "GD2"
           b_types(3) = "ISY"
        case(3)
           b_types(1) = "SX"
           b_types(2) = "ISY"
           b_types(3) = "GD2"
        case(4)
           b_types(1) = "ISY"
           b_types(2) = "GD2"
           b_types(3) = "SX"
        case(5)
           b_types(1) = "ISY"
           b_types(2) = "SX"
           b_types(3) = "GD2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
      end

   end

   select_block_2D_4typ_unres(integ) result (b_types)
   ! assign to the integer "integ" a permutation
   ! of the 4 pauli block types (ID2, SX, SZ, ISY)
     integ :: INT, IN
     b_types :: VEC{STR}(4)

     select case (integ)
        case(0)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "SZ"
           b_types(4) = "ISY"
        case(1)
           b_types(1) = "ID2"
           b_types(2) = "SX"
           b_types(3) = "ISY"
           b_types(4) = "SZ"
        case(2)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "SX"
           b_types(4) = "ISY"
        case(3)
           b_types(1) = "ID2"
           b_types(2) = "SZ"
           b_types(3) = "ISY"
           b_types(4) = "SX"
        case(4)
           b_types(1) = "ID2"
           b_types(2) = "ISY"
           b_types(3) = "SX"
           b_types(4) = "SZ"
        case(5)
           b_types(1) = "ID2"
           b_types(2) = "ISY"
           b_types(3) = "SZ"
           b_types(4) = "SX"
        !
        case(6)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
           b_types(4) = "ISY"
        case(7)
           b_types(1) = "SX"
           b_types(2) = "ID2"
           b_types(3) = "ISY"
           b_types(4) = "SZ"
        case(8)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
           b_types(4) = "ISY"
        case(9)
           b_types(1) = "SX"
           b_types(2) = "SZ"
           b_types(3) = "ISY"
           b_types(4) = "ID2"
        case(10)
           b_types(1) = "SX"
           b_types(2) = "ISY"
           b_types(3) = "ID2"
           b_types(4) = "SZ"
        case(11)
           b_types(1) = "SX"
           b_types(2) = "ISY"
           b_types(3) = "SZ"
           b_types(4) = "ID2"
        !
        case(12)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "SX"
           b_types(4) = "ISY"
        case(13)
           b_types(1) = "SZ"
           b_types(2) = "ID2"
           b_types(3) = "ISY"
           b_types(4) = "SX"
        case(14)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ID2"
           b_types(4) = "ISY"
        case(15)
           b_types(1) = "SZ"
           b_types(2) = "SX"
           b_types(3) = "ISY"
           b_types(4) = "ID2"
        case(16)
           b_types(1) = "SZ"
           b_types(2) = "ISY"
           b_types(3) = "ID2"
           b_types(4) = "SX"
        case(17)
           b_types(1) = "SZ"
           b_types(2) = "ISY"
           b_types(3) = "SX"
           b_types(4) = "ID2"
        !
        case(18)
           b_types(1) = "ISY"
           b_types(2) = "ID2"
           b_types(3) = "SX"
           b_types(4) = "SZ"
        case(19)
           b_types(1) = "ISY"
           b_types(2) = "ID2"
           b_types(3) = "SZ"
           b_types(4) = "SX"
        case(20)
           b_types(1) = "ISY"
           b_types(2) = "SX"
           b_types(3) = "ID2"
           b_types(4) = "SZ"
        case(21)
           b_types(1) = "ISY"
           b_types(2) = "SX"
           b_types(3) = "SZ"
           b_types(4) = "ID2"
        case(22)
           b_types(1) = "ISY"
           b_types(2) = "SZ"
           b_types(3) = "ID2"
           b_types(4) = "SX"
        case(23)
           b_types(1) = "ISY"
           b_types(2) = "SZ"
           b_types(3) = "SX"
           b_types(4) = "ID2"
        case default   
         !debug stdout.text("unrecognized block type code")
           stop
      end

   end
! de

! davide 07-10-2019
   guess_geminals_hf ::: leaky
   ! generate Hartree-Fock (HF) set of geminals
     i :: INT
     bra_not_created, ket_not_created :: BIN

     ! set block partition;
     .set_block_partition_hf

     ! check if the bra and ket sets are already created;
     ! if not, create them
     bra_not_created = NOT .bra_set.vec(1).coef.created
!     ket_not_created = NOT .ket_set.vec(1).coef.created
!     stdout.show("bra_not_created =",bra_not_created)
!     stdout.text(" ")
     if (bra_not_created) then 
        .create_pbt_set(.bra_set)
     else
        .destroy_pbt_set(.bra_set)
        .create_pbt_set(.bra_set)
     end
     !
     if (NOT .bra_is_ket) then
        ket_not_created = NOT .ket_set.vec(1).coef.created
!        stdout.show("ket_not_created =",ket_not_created)
!        stdout.text(" ")
        if (ket_not_created) then 
           .create_pbt_set(.ket_set)
        else
           .destroy_pbt_set(.ket_set)
           .create_pbt_set(.ket_set)
        end
     end

!     ! check if the bra and ket sets are already created;
!     ! if not, create them
!     bra_not_created = NOT .bra_set.vec(1).coef.created
!     ket_not_created = NOT .ket_set.vec(1).coef.created
!!     stdout.show("bra_not_created =",bra_not_created)
!!     stdout.show("ket_not_created =",ket_not_created)
!!     stdout.text(" ")
!     if (.bra_is_ket) then
!        ! if bra and ket sets are the same
!        if (bra_not_created) then 
!           .create_pbt_set(.bra_set)
!        end
!     else
!        ! if bra and ket sets are different
!        if (bra_not_created AND ket_not_created) then 
!           .create_pbt_set(.bra_set)
!           .create_pbt_set(.ket_set)
!        else if (bra_not_created) then 
!           .create_pbt_set(.bra_set)
!        else if (ket_not_created) then 
!           .create_pbt_set(.ket_set)
!        end
!     end
     
     stdout.text("Hartree-Fock guess bra set:")
     ! make the block structure of the set
     .make_blocks_hf(.bra_set)
     !!!!!!!!!!
     ! debug
     stdout.text(" ")
     stdout.show("# 1D blocks =",.bra_set.n_1D_blocks)
     stdout.show("# 2D blocks =",.bra_set.n_2D_blocks)
     stdout.show("# 2D 3type blocks =",.bra_set.n_2D_3typ_blocks)
     stdout.show("# 2D 4type blocks =",.bra_set.n_2D_4typ_blocks)
     stdout.text(" ")
     !
     do i=1,.n_geminals
        stdout.text(" ")
        stdout.show("geminal",i)
        stdout.text("block structure:")
        stdout.put(.bra_set.vec(i).block_type)
        stdout.text("coefficients:")
        stdout.put(.bra_set.vec(i).coef)
     end
     !
     if (.bra_is_ket) then
        ! we should make sure that no memory is lost
        .ket_set.set_size=.n_geminals
        .ket_set.vec=>.bra_set.vec
     else
        stdout.text(" ")
        stdout.text("Hartree-Fock guess ket set:")
        ! make the block structure of the set
        .make_blocks_hf(.ket_set)
        !
        do i=1,.n_geminals
           stdout.text(" ")
           stdout.show("geminal",i)
           stdout.text("block structure:")
           stdout.put(.ket_set.vec(i).block_type)
           stdout.text("coefficients:")
           stdout.put(.ket_set.vec(i).coef)
        end
     end

   end

   make_blocks_hf(pbt_set)
   ! make the block structure of the Hartree-Fock (HF) set of geminals
     pbt_set :: PAULI_BLOCK_TENSOR_SET
     set_size, n_blocks, n_1D_blocks :: INT
     i :: INT
     !
     set_size = pbt_set.set_size  ! number of geminals
     n_blocks = pbt_set.n_blocks ! number of blocks
     n_1D_blocks = pbt_set.n_1D_blocks  ! number of blocks of size 1 (1D)
     !
!     ! in case of a spin restricted calculation,
!     ! if a doublet or a triplet state is selected,
!     ! build the 2D block structure for the last geminal
!     ! (and decrement "set_size" by 1)
!     if (.spin_restricted) then
!        if (.spin_multi == 2) then
!           ! doublet state:
!           ! nonzero coefficient only for the last (2D) block,
!           ! the one with one orbital at infinity
!           pbt_set.vec(set_size).block_type(1:n_1D_blocks) = "ID1"
!           pbt_set.vec(set_size).block_type(n_1D_blocks+1:n_blocks-1) = "ID2"
!           pbt_set.vec(set_size).block_type(n_blocks) = "SX"
!           pbt_set.vec(set_size).coef(1:n_blocks-1) = ZERO
!           pbt_set.vec(set_size).coef(n_blocks) = ONE/SQRT_2
!           set_size = set_size-1
!        else if (.spin_multi == 3) then
!           ! triplet state:
!           ! nonzero coefficient only for the first 2D block,
!           pbt_set.vec(set_size).block_type(1:n_1D_blocks) = "ID1"
!           pbt_set.vec(set_size).block_type(n_1D_blocks+1:n_blocks) = "ISY"
!           pbt_set.vec(set_size).coef(1:n_blocks) = ZERO
!           pbt_set.vec(set_size).coef(n_1D_blocks+1) = ONE/SQRT_2
!           set_size = set_size-1
!        end
!     end
     !
     ! make the block structure
     do i=1,set_size
        ! assign block type ID1 to each 1D block
        pbt_set.vec(i).block_type(1:n_1D_blocks) = "ID1"
        ! assign block type ID2 to each 2D block
        pbt_set.vec(i).block_type(n_1D_blocks+1:n_blocks) = "ID2"
        ! set block coefficients
        pbt_set.vec(i).coef(1:n_blocks) = ZERO
        pbt_set.vec(i).coef(i) = ONE
     end

   end
! de


!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end


!  ==============
!  Output methods
!  ==============

   put
   ! Print out the object
      n_geminals :: INT
      i :: INT
      bra_is_ket :: BIN

      n_geminals=.n_geminals
    !debug stdout.text(" ")
    !debug stdout.text(" ")
    !debug stdout.text("PBG info:")
    !debug stdout.text(" ")
    !debug stdout.show("number of geminals :",.n_geminals)
    !debug stdout.text(" ")
    !debug stdout.show("number of blocks in each geminal :",.n_blocks)
    !debug stdout.text(" ")
    !debug stdout.show("bra=ket :",.bra_is_ket)
    !debug stdout.text(" ")
    !debug stdout.text(" ")
      do i=1,n_geminals
      !debug stdout.show("block type of bra :",i)
      !debug stdout.put(.bra_set.vec(i).block_type)
      !debug stdout.text(" ")
      !debug stdout.show("block coef. of bra :",i)
      !debug stdout.put(.bra_set.vec(i).coef)
      !debug stdout.text(" ")
      !debug stdout.show("block sizes of bra :",i)
      !debug stdout.put(.bra_set.vec(i).block_dim)
      !debug stdout.text(" ")
      !debug stdout.show("block numbers of bra :",i)
      !debug stdout.put(.bra_set.vec(i).n_blocks)
      !debug stdout.text(" ")
      !debug stdout.show("matrix form of bra :",i)
      !debug stdout.put(.bra_set.vec(i).matrix_form)
      !debug stdout.text(" ")
      !debug stdout.text(" ")
      end
      if(NOT .bra_is_ket) then
        do i=1,n_geminals
        !debug stdout.show("block type of ket :",i)
        !debug stdout.put(.ket_set.vec(i).block_type)
        !debug stdout.text(" ")
        !debug stdout.show("block coef. of ket :",i)
        !debug stdout.put(.ket_set.vec(i).coef)
        !debug stdout.text(" ")
        !debug stdout.show("block sizes of ket :",i)
        !debug stdout.put(.ket_set.vec(i).block_dim)
        !debug stdout.text(" ")
        !debug stdout.show("block numbers of ket :",i)
        !debug stdout.put(.ket_set.vec(i).n_blocks)
        !debug stdout.text(" ")
        !debug stdout.show("matrix form of ket :",i)
        !debug stdout.put(.ket_set.vec(i).matrix_form)
        !debug stdout.text(" ")
        !debug stdout.text(" ")
        end
        .put_type_numbers(.bra_set,.ket_set)
        .make_pauli_trace(.bra_set,.ket_set)
      else
        .put_type_numbers(.bra_set,.bra_set)
        .make_pauli_trace(.bra_set,.bra_set)
      end     
   end


!  ================
!  Integral methods
!  ================

!   make_theorem
!   ! make the formula of our general theorem
!   
!   end


   make_pauli_trace(bra_subset,ket_subset)
   ! make trace of a product of blocks
     bra_subset,ket_subset :: PAULI_BLOCK_TENSOR_SET
     ENSURE(bra_subset.vec.dim==ket_subset.vec.dim,"Bra and ket have different sizes!")
     n_gem :: INT
     n_blocks, n_block1, j :: INT
     pauli_trace :: REAL
     n_gem=bra_subset.vec.dim
     n_blocks=bra_subset.vec(1).block_type.dim
     n_block1=bra_subset.vec(1).n_1D_blocks
     pauli_trace = ZERO
     .make_type_numbers(bra_subset)
     .make_type_numbers(ket_subset)
     select case (n_gem)
       case(1);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
           end
         end
         pauli_trace = 2*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)
         end
       case(2);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
           end
         end
         pauli_trace = 8*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)
         end
       case(3);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
           end
         end
         pauli_trace = 48*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)
         end
       case(4);
         do j=n_block1+1,n_blocks
           if( all(bra_subset.type_nb(j).element==ket_subset.type_nb(j).element)) then 
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
           end
         end
         pauli_trace = 384*pauli_trace
         do j=1,n_block1
             pauli_trace = pauli_trace + bra_subset.vec(1).coef(j)*ket_subset.vec(1).coef(j)*bra_subset.vec(2).coef(j)*ket_subset.vec(2).coef(j)*bra_subset.vec(3).coef(j)*ket_subset.vec(3).coef(j)*bra_subset.vec(4).coef(j)*ket_subset.vec(4).coef(j)
         end
       case default ;
     end
   !debug stdout.show("trace of product of bra and ket geminals :",pauli_trace)
   end

!   make_hamiltonian(ham)
!   ! make hamiltonian 
!     ham :: REAL
!     v :: MAT4{REAL}*
!     r,i_1,j_1,i_2,j_2 :: INT
!     eri_archive :: ARCHIVE
!
!     eri_archive.set(.name,"h_integrals")
!     v.create(.mat_size,.mat_size,.mat_size,.mat_size)
!     eri_archive.read(v)
!
!     ham = ZERO
!
!     do r=1,.nonzero_terms_ab
!        i_1 = .rdm_2_ab(r).indices(1)
!        j_1 = .rdm_2_ab(r).indices(2)
!        i_2 = .rdm_2_ab(r).indices(3)
!        j_2 = .rdm_2_ab(r).indices(4)
!        ham = ham + .rdm_2_ab(r).coefficient*v(i_1,j_1,i_2,j_2)
!     end
!
!     do r=1,.nonzero_terms_aa
!        i_1 = .rdm_2_aa(r).indices(1)
!        j_1 = .rdm_2_aa(r).indices(2)
!        i_2 = .rdm_2_aa(r).indices(3)
!        j_2 = .rdm_2_aa(r).indices(4)
!        ham = ham + .rdm_2_aa(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
!     end
!
!     do r=1,.nonzero_terms_bb
!        i_1 = .rdm_2_bb(r).indices(1)
!        j_1 = .rdm_2_bb(r).indices(2)
!        i_2 = .rdm_2_bb(r).indices(3)
!        j_2 = .rdm_2_bb(r).indices(4)
!        ham = ham + .rdm_2_bb(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
!     end
!
!     ! save the electronic energy
!     .electronic_energy = ham
!
!     v.destroy
!
!     stdout.text(" ")
!     !
!   !debug 
!     stdout.show("Electronic energy",ham)
!   !debug 
!     stdout.show("Nuclear repulsion energy",.nuclear_repulsion_energy)
!   !debug 
!     stdout.show("Total energy",ham+.nuclear_repulsion_energy)
!     !
!     stdout.text(" ")
!
!   end
   
   make_hamiltonian(ham, wrt_arg)
   ! make hamiltonian 
     ham :: REAL, INOUT
     wrt_arg :: BIN, IN, optional
     wrt :: BIN
     v :: MAT4{REAL}*
     r,i_1,j_1,i_2,j_2 :: INT
     eri_archive :: ARCHIVE

     wrt = TRUE
     if (present(wrt_arg)) then
        wrt = wrt_arg
     end

     eri_archive.set(.name,"h_integrals")
     v.create(.mat_size,.mat_size,.mat_size,.mat_size)
     eri_archive.read(v)

     ham = ZERO

     do r=1,.nonzero_terms_ab
        i_1 = .rdm_2_ab(r).indices(1)
        j_1 = .rdm_2_ab(r).indices(2)
        i_2 = .rdm_2_ab(r).indices(3)
        j_2 = .rdm_2_ab(r).indices(4)
        ham = ham + .rdm_2_ab(r).coefficient*v(i_1,j_1,i_2,j_2)
     end

     do r=1,.nonzero_terms_aa
        i_1 = .rdm_2_aa(r).indices(1)
        j_1 = .rdm_2_aa(r).indices(2)
        i_2 = .rdm_2_aa(r).indices(3)
        j_2 = .rdm_2_aa(r).indices(4)
        ham = ham + .rdm_2_aa(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
     end

     do r=1,.nonzero_terms_bb
        i_1 = .rdm_2_bb(r).indices(1)
        j_1 = .rdm_2_bb(r).indices(2)
        i_2 = .rdm_2_bb(r).indices(3)
        j_2 = .rdm_2_bb(r).indices(4)
        ham = ham + .rdm_2_bb(r).coefficient*(v(i_1,j_1,i_2,j_2)-v(i_1,j_1,j_2,i_2))
     end

     ! save the electronic energy
     .electronic_energy = ham

     v.destroy

     if (wrt) then
        stdout.text(" ")
        stdout.show("Electronic energy",ham)
        stdout.show("Nuclear repulsion energy",.nuclear_repulsion_energy)
        stdout.show("Total energy",ham+.nuclear_repulsion_energy)
        stdout.text(" ")
     end

   end

!  ======================
!  "Generalized" routines
!  ======================

   calc_1rdm_gen
   ! compute the 1-reduced density matrix
   ! for a set of PBT
     i, j, m :: INT
     trace :: REAL

     allocate(.rdm_1(.mat_size,.mat_size))
     .rdm_1 = ZERO

     .prep_orbital_block_mapping
     .prep_block_types

   !debug stdout.text(" ")
   !debug stdout.text("Calculation of the 1-reduced density matrix")

     ! 1D blocks space

     do i=1,.n_1D_blocks
        .calc_1rdm_element_gen(i,i)
     end

     ! 2D blocks space

     m = .n_1D_blocks+2*.n_2D_3typ_blocks

     if (.n_2D_3typ_blocks /= 0) then
        do i=.n_1D_blocks+1,m-1,2
           .calc_1rdm_element_gen(i,i)
        end
     end

     if (.n_2D_4typ_blocks /= 0) then
        do i=m+1,.mat_size-1,2
           .calc_1rdm_element(i,i)
        end
     end

     ! write 1-RDM
   !debug stdout.text(" ")
   !debug stdout.text("1-reduced density alpha-(or beta-)matrix:")
   !debug stdout.text(" ")
   !debug stdout.put(.rdm_1)

   !debug  ! compute 1-RDM trace
   !debug  trace = ZERO
   !debug  do i=1,.mat_size
   !debug     trace = trace + .rdm_1(i,i)
   !debug  end
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the 1-RDM alpha-(or beta-)matrix", trace)
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the total 1-RDM matrix", trace+trace)
     
   end

   calc_1rdm_element_gen(row,col)
   ! compute element (row,col) of the 1-reduced 
   ! density matrix (1-RDM) for a set of PBT
     row, col :: INT, IN
     red_pbg :: PAULI_BLOCK_GEMINALS 
     ng :: INT
     overlap :: REAL
     coef_prod, coef1, coef2 :: REAL
     block :: INT
     geminal :: INT
     term :: VEC{REAL}(5)
     j, r :: INT
     problem :: BIN
     t_1, t_2 :: REAL

     ng = .n_geminals-1
     if (ng /= 0) then
        red_pbg.n_geminals = ng
        red_pbg.nonzero_coef_ind.create(ng)
        red_pbg.nonzero_coef_prod.create(ng)
        red_pbg.first_block=.first_block
     end

     term = ZERO

     if (row == col AND row <= .n_1D_blocks) then  ! 1D blocks space - diagonal element
        if (.nonzero_1ortho_ind(row) /= 0) then
         !debug stdout.show("geminal to be skipped", .nonzero_1ortho_ind(row))
         !debug stdout.show("nonzero 1-ortho. block", row)
           ! compute product of coefficients of the bra and ket
           ! geminals ".nonzero_1ortho_ind(row)" (1-ortho. block "row")
           coef1 = .bra_set.vec(.nonzero_1ortho_ind(row)).coef(row)
           if (.bra_is_ket) then
              coef_prod = coef1*coef1
           else
              coef2 = .ket_set.vec(.nonzero_1ortho_ind(row)).coef(row)
              coef_prod = coef1*coef2
           end
           if (ng /= 0) then
              .prep_red_pbg(red_pbg,.nonzero_1ortho_ind(row))
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              .rdm_1(row,col) = coef_prod*overlap
           else
              .rdm_1(row,col) = coef_prod
           end
         !debug stdout.text(" ")
         !debug stdout.show("Calculation of 1-RDM diagonal element", row)
         !debug stdout.show("product of coef.", coef_prod)
         !debug stdout.show("overlap", overlap)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
        end
     else if (row == col AND row > .n_1D_blocks) then ! 2D blocks space - diagonal element
      !debug stdout.text(" ")
      !debug stdout.show("Calculation of 1-RDM diagonal element", row)
        block = .orbital_block_mapping(row)
        do j=3,5 ! geminal with SX, SY or GD2 in block "block" are skipped
         !debug stdout.show("term", j)
           geminal = .block_types(block).element(j) 
         !debug stdout.show("geminal to be skipped", geminal)
         !debug stdout.show("2D block to be skipped", block)
           if (geminal /= 0) then
              ! product of coefficients from the bra and the ket 
              ! for geminal "geminal" and block "block"
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              if (ng /= 0) then
                 .prep_red_pbg(red_pbg, geminal, block, problem) ! geminal "geminal" and block "block" are skipped
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                    !stdout.show("product of coef.", coef_prod)
                    !stdout.show("overlap", overlap)
                 end
              else
                 term(j) = coef_prod
                 !stdout.show("product of coef.", coef_prod)
                 !stdout.show("overlap", overlap)
              end
           end
         !debug stdout.show("term", term(j))
        end
        if (abs(term(5)) > TOL(15)) then
           t_1 = term(5)*.first_GD2_elt(block)*.first_GD2_elt(block)
           t_2 = term(5)*.second_GD2_elt(block)*.second_GD2_elt(block)
           .rdm_1(row,col) = t_1+term(3)+term(4)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
           r = row+1
           .rdm_1(r,r) = t_2+term(3)+term(4)
         !debug stdout.show("matrix element", .rdm_1(r,r))
           .rdm_1(r,r) = .rdm_1(r,r)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(r,r))
        else
           .rdm_1(row,col) = term(3)+term(4)
         !debug stdout.show("matrix element", .rdm_1(row,col))
           .rdm_1(row,col) = .rdm_1(row,col)/.overlap
         !debug stdout.show("normalized matrix element", .rdm_1(row,col))
           r = row+1
           .rdm_1(r,r) = .rdm_1(row,col)
        end
     else
        .rdm_1(row,col) = ZERO
      !debug stdout.text(" ")
      !debug stdout.text("Calculation of 1-RDM off-diagonal element")
      !debug stdout.show(" ", row)
      !debug stdout.show(" ", col)
      !debug stdout.show("matrix element", .rdm_1(row,col))
     end
     if (ng /= 0) then
        red_pbg.destroy_ptr_part
     end

   end


   calc_2rdm_gen
   ! compute the 2-reduced density matrix
   ! for a set of PBT   
     ng_1, ng_2 :: INT
     size_ab, size_aa :: INT
     i, i_a, i_b :: INT
     r, s :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     trace :: REAL
     mat_ab, mat_aa, mat_bb :: MAT{REAL}*
     eigenval_ab, eigenval_aa, eigenval_bb :: VEC{REAL}*
     nonzero_eigenval_ab, nonzero_eigenval_aa, nonzero_eigenval_bb :: VEC{REAL}*
     s_ab, s_aa, s_bb :: INT
     eigenvec_ab, eigenvec_aa, eigenvec_bb :: MAT{REAL}*
!!     j_1, j_2 :: INT
     j, j1, j2, j3, j4 :: INT
     c, k1, k2, k3, k4 :: INT
     !
     timer :: TIME
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine calc_2rdm_gen")
!     stdout.text(" ")
     !!!

   !debug stdout.text(" ")
   !debug stdout.text("Calculation of the 2-reduced density matrix")

     .prep_orbital_block_mapping
     .prep_block_types
     
     size_ab = 4*.mat_size*.mat_size
     size_aa = .mat_size*(.mat_size-1)*2
     
!     .create(.rdm_2_ab,size_ab)
!     .create(.rdm_2_aa,size_aa)
!     .create(.rdm_2_bb,size_aa)     

     !!!
     if (NOT .rdm_2_ab.created) then
!        stdout.text("create .rdm_2_ab")
!        stdout.show("size(.rdm_2_ab) =",size_ab)
        .create(.rdm_2_ab,size_ab)
     end if
!     if (.rdm_2_ab(1).grad_info.coef_prod.created) then
!        stdout.text(".rdm_2_ab(1).grad_info.coef_prod already created")
!     end if
!     if (.rdm_2_ab(1).grad_info.ex_gem.created) then
!        stdout.text(".rdm_2_ab(1).grad_info.ex_gem already created")
!     end if
     !
     if (NOT .rdm_2_aa.created) then
!        stdout.text("create .rdm_2_aa")
!        stdout.show("size(.rdm_2_aa) =",size_aa)
        .create(.rdm_2_aa,size_aa)
     end if
!     if (.rdm_2_aa(1).grad_info.coef_prod.created) then
!        stdout.text(".rdm_2_aa(1).grad_info.coef_prod already created")
!     end if
!     if (.rdm_2_aa(1).grad_info.ex_gem.created) then
!        stdout.text(".rdm_2_aa(1).grad_info.ex_gem already created")
!     end if
     !
     if (NOT .rdm_2_bb.created) then
!        stdout.text("create .rdm_2_bb")
!        stdout.show("size(.rdm_2_bb) =",size_aa)
        .create(.rdm_2_bb,size_aa)
     end if
!     if (.rdm_2_bb(1).grad_info.coef_prod.created) then
!        stdout.text(".rdm_2_bb(1).grad_info.coef_prod already created")
!     end if
!     if (.rdm_2_bb(1).grad_info.ex_gem.created) then
!        stdout.text(".rdm_2_bb(1).grad_info.ex_gem already created")
!     end if
     !!!
!     stop

     ng_1 = .n_geminals-1
     if (ng_1 /= 0) then
        red_pbg_1.n_geminals = ng_1
        red_pbg_1.nonzero_coef_ind.create(ng_1)
        red_pbg_1.nonzero_coef_prod.create(ng_1)
        red_pbg_1.first_block=.first_block
     end

     ng_2 = .n_geminals-2
     if (ng_2 > 0) then
        red_pbg_2.n_geminals = ng_2
        red_pbg_2.nonzero_coef_ind.create(ng_2)
        red_pbg_2.nonzero_coef_prod.create(ng_2)
        red_pbg_2.first_block=.first_block
     end

     ! same_block = TRUE

     i = 0

!     timer.start_timing
!     !
     .calc_2rdm_same_block_gen(i, ng_1, red_pbg_1)
!     !
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) 2rdm_same_block_gen: ",timer.elapsed_time_s,14)

     ! same_block = FALSE

     ! cases where we "skip" at least one 1-orthogonal block 

     i = i+1
     i_a = 1
     i_b = 1

!     timer.start_timing
!     !
     .calc_2rdm_one_1_ortho_gen(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
!     !
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) 2rdm_one_1_ortho_gen: ",timer.elapsed_time_s,14)
    
     ! cases where we have at least one Pauli Block

!     timer.start_timing
!     !
     .calc_2rdm_one_pauli_gen(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
!     !
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) 2rdm_one_pauli_gen: ",timer.elapsed_time_s,14)

     .nonzero_terms_ab = i-1
     .nonzero_terms_aa = i_a-1
     .nonzero_terms_bb = i_b-1
     
     !!!!!!!!!!!!!!!!!!!!
     ! debug
!     trace = ZERO
!     mat_ab.create(.mat_size*.mat_size,.mat_size*.mat_size)
!     eigenval_ab.create(.mat_size*.mat_size)
!     nonzero_eigenval_ab.create(.mat_size*.mat_size)
!     eigenvec_ab.create(.mat_size*.mat_size,.mat_size*.mat_size)
!     mat_aa.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     eigenval_aa.create(.mat_size*(.mat_size-1)*2)
!     nonzero_eigenval_aa.create(.mat_size*(.mat_size-1)*2)
!     eigenvec_aa.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     mat_bb.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     eigenval_bb.create(.mat_size*(.mat_size-1)*2)
!     nonzero_eigenval_bb.create(.mat_size*(.mat_size-1)*2)
!     eigenvec_bb.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     mat_ab = ZERO
!     mat_aa = ZERO
!     mat_bb = ZERO
!
!     do r=1,.nonzero_terms_ab
!        j_1 = (.rdm_2_ab(r).indices(1)-1)*.mat_size+.rdm_2_ab(r).indices(2)
!        j_2 = (.rdm_2_ab(r).indices(3)-1)*.mat_size+.rdm_2_ab(r).indices(4)
!        mat_ab(j_1,j_2) = .rdm_2_ab(r).coefficient
!        if (.rdm_2_ab(r).indices(1) == .rdm_2_ab(r).indices(3) AND .rdm_2_ab(r).indices(2) == .rdm_2_ab(r).indices(4)) then
!           trace = trace + .rdm_2_ab(r).coefficient
!        end
!     end
!     mat_ab.solve_symmetric_eigenproblem(eigenval_ab,eigenvec_ab) 
!     s = 0
!     do r=1,.mat_size*.mat_size
!        if (abs(eigenval_ab(r)) > TOL(15)) then
!           s = s+1
!           nonzero_eigenval_ab(s) = eigenval_ab(r)
!        end
!     end
!     s_ab = s
!
!     do r=1,.nonzero_terms_aa
!        j_1 = (.rdm_2_aa(r).indices(1)-1)*.mat_size+.rdm_2_aa(r).indices(2)
!        j_2 = (.rdm_2_aa(r).indices(3)-1)*.mat_size+.rdm_2_aa(r).indices(4)
!        mat_aa(j_1,j_2) = .rdm_2_aa(r).coefficient
!        if (.rdm_2_aa(r).indices(1) == .rdm_2_aa(r).indices(3) AND .rdm_2_aa(r).indices(2) == .rdm_2_aa(r).indices(4)) then
!           trace = trace + .rdm_2_aa(r).coefficient
!        end
!     end
!     mat_aa.solve_symmetric_eigenproblem(eigenval_aa,eigenvec_aa) 
!     s = 0
!     do r=1,.mat_size*(.mat_size-1)*2
!        if (abs(eigenval_aa(r)) > TOL(15)) then
!           s = s+1
!           nonzero_eigenval_aa(s) = eigenval_aa(r)
!        end
!     end
!     s_aa = s
!
!     do r=1,.nonzero_terms_bb
!        j_1 = (.rdm_2_bb(r).indices(1)-1)*.mat_size+.rdm_2_bb(r).indices(2)
!        j_2 = (.rdm_2_bb(r).indices(3)-1)*.mat_size+.rdm_2_bb(r).indices(4)
!        mat_bb(j_1,j_2) = .rdm_2_bb(r).coefficient
!        if (.rdm_2_bb(r).indices(1) == .rdm_2_bb(r).indices(3) AND .rdm_2_bb(r).indices(2) == .rdm_2_bb(r).indices(4)) then
!           trace = trace + .rdm_2_bb(r).coefficient
!        end
!     end
!     mat_bb.solve_symmetric_eigenproblem(eigenval_bb,eigenvec_bb) 
!     s = 0
!     do r=1,.mat_size*(.mat_size-1)*2
!        if (abs(eigenval_bb(r))> TOL(15)) then
!           s = s+1
!           nonzero_eigenval_bb(s) = eigenval_aa(r)
!        end
!     end
!     s_bb = s
     !!!!!!!!!!!!!!!!!!!!

   !debug stdout.text(" ")
   !debug stdout.show("Number of nonzero coefficients of the 2-RDM alpha-beta matrix", .nonzero_terms_ab)
   !debug stdout.show("Number of nonzero eigenvalues of the 2-RDM alpha-beta matrix", s_ab)
   !debug stdout.text("Nonzero eigenvalues of the 2-RDM alpha-beta matrix")
   !debug stdout.put(nonzero_eigenval_ab(1:s_ab))
   !debug stdout.text(" ")
   !debug stdout.show("Number of nonzero coefficients of the 2-RDM alpha-alpha matrix", .nonzero_terms_aa)
   !debug stdout.show("Number of nonzero eigenvalues of the 2-RDM alpha-alpha matrix", s_aa)
   !debug stdout.text("Nonzero eigenvalues of the 2-RDM alpha-alpha matrix")
   !debug stdout.put(nonzero_eigenval_aa(1:s_aa))
   !debug stdout.text(" ")
   !debug stdout.show("Number of nonzero coefficients of the 2-RDM beta-beta matrix", .nonzero_terms_bb)
   !debug stdout.show("Number of nonzero eigenvalues of the 2-RDM beta-beta matrix", s_bb)
   !debug stdout.text("Nonzero eigenvalues of the 2-RDM beta-beta matrix")
   !debug stdout.put(nonzero_eigenval_bb(1:s_bb))
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the total 2-RDM matrix", trace)  
   !debug stdout.show("Sum of eigenvalues", sum(nonzero_eigenval_ab(1:s_ab))+sum(nonzero_eigenval_aa(1:s_aa))+sum(nonzero_eigenval_bb(1:s_bb)))   

     !!! debug (new)
  if (.debug) then
     stdout.text(" ")
     stdout.show("Overlap =",.overlap)
     if (.n_2D_3typ_blocks > 0) then
        stdout.show("first_GD2_elt =",.first_GD2_elt)
        stdout.show("second_GD2_elt =",.second_GD2_elt)
     end
!!!
!     stdout.text(" ")
!     stdout.text("2RDM alpha/beta nonzero elements:")
!     stdout.show("Number of nonzero elements =",.nonzero_terms_ab)
!     c = 0
!     do j1=1,.mat_size
!        do j2=1,.mat_size
!           do j3=1,.mat_size
!              do j4=1,.mat_size
!                 do j=1,.nonzero_terms_ab
!                    k1 = .rdm_2_ab(j).indices(1)
!                    k2 = .rdm_2_ab(j).indices(2)
!                    k3 = .rdm_2_ab(j).indices(3)
!                    k4 = .rdm_2_ab(j).indices(4)
!                    if (j1==k1 AND j2==k2 AND j3==k3 AND j4==k4) then
!                       c = c + 1
!                       stdout.text(" ")
!                       stdout.show("counter",c)
!                       stdout.show("element",j)
!                       stdout.show("indices",.rdm_2_ab(j).indices)
!                       stdout.show("coefficient",.rdm_2_ab(j).coefficient)
!                       exit
!                    end
!                 end
!              end
!           end
!        end
!     end
!!!
     stdout.text(" ")
     stdout.text("2RDM alpha/beta nonzero elements:")
     stdout.show("Number of nonzero elements =",.nonzero_terms_ab)
     do j=1,.nonzero_terms_ab
        stdout.text(" ")
        stdout.show("element",j)
        stdout.show("indices",.rdm_2_ab(j).indices)
        stdout.show("coefficient",.rdm_2_ab(j).coefficient)
     end
     stdout.text(" ")
     stdout.text("2RDM alpha/alpha nonzero elements:")
     stdout.show("Number of nonzero elements =",.nonzero_terms_aa)
     do j=1,.nonzero_terms_aa
        stdout.text(" ")
        stdout.show("element",j)
        stdout.show("indices",.rdm_2_aa(j).indices)
        stdout.show("coefficient",.rdm_2_aa(j).coefficient)
     end
     stdout.text(" ")
     stdout.text("2RDM beta/beta nonzero elements:")
     stdout.show("Number of nonzero elements =",.nonzero_terms_bb)
     do j=1,.nonzero_terms_bb
        stdout.text(" ")
        stdout.show("element",j)
        stdout.show("indices",.rdm_2_bb(j).indices)
        stdout.show("coefficient",.rdm_2_bb(j).coefficient)
     end
  end !!! debug
     !!!

     if (ng_1 /= 0) then
        red_pbg_1.destroy_ptr_part
     end
     if (ng_2 > 0) then
        red_pbg_2.destroy_ptr_part
     end
   
   end

   calc_2rdm_gen_grd
   ! compute the 2-reduced density matrix
   ! for a set of PBT, in case of optimization of the block
   ! coefficients (information for energy gradient 
   ! calculation is stored as well)
     ng_1, ng_2 :: INT
     size_ab, size_aa :: INT
     i, i_a, i_b :: INT
     r, s :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     trace :: REAL
     mat_ab, mat_aa, mat_bb :: MAT{REAL}*
     eigenval_ab, eigenval_aa, eigenval_bb :: VEC{REAL}*
     nonzero_eigenval_ab, nonzero_eigenval_aa, nonzero_eigenval_bb :: VEC{REAL}*
     s_ab, s_aa, s_bb :: INT
     eigenvec_ab, eigenvec_aa, eigenvec_bb :: MAT{REAL}*
!     j_1, j_2 :: INT
     j, j1, j2, j3, j4 :: INT
     c, k1, k2, k3, k4 :: INT
!     i_first :: INT, save = 1
     !
     timer :: TIME
     !!!
     nb_terms :: INT
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine calc_2rdm_gen_grd")
!     stdout.text(" ")
!     stdout.flush
     !!!

   !debug stdout.text(" ")
   !debug stdout.text("Calculation of the 2-reduced density matrix")

     .prep_orbital_block_mapping
     .prep_block_types
     
     size_ab = 4*.mat_size*.mat_size
     size_aa = .mat_size*(.mat_size-1)*2
     
     ! allocate vectors of 2RDM elements
     ! (if not created yet)
     if (NOT .rdm_2_ab.created) then
!        stdout.text("create .rdm_2_ab")
!        stdout.show("size(.rdm_2_ab) =",size_ab)
        .create(.rdm_2_ab,size_ab)
     end !if
     !
     if (NOT .rdm_2_aa.created) then
!        stdout.text("create .rdm_2_aa")
!        stdout.show("size(.rdm_2_aa) =",size_aa)
        .create(.rdm_2_aa,size_aa)
     end !if
     !
     if (NOT .rdm_2_bb.created) then
!        stdout.text("create .rdm_2_bb")
!        stdout.show("size(.rdm_2_bb) =",size_aa)
        .create(.rdm_2_bb,size_aa)     
     end !if

     ! allocate vectors of objects containing information 
     ! needed to compute the energy gradient
     ! (if not created yet)
     if (NOT .rdm_2_ab_grad_info.created) then
!        stdout.text("create .rdm_2_ab_grad_info")
!        stdout.show("size(.rdm_2_ab_grad_info) =",size_ab)
        .create(.rdm_2_ab_grad_info,size_ab)
     end !if
     !
     if (NOT .rdm_2_aa_grad_info.created) then
!        stdout.text("create .rdm_2_aa_grad_info")
!        stdout.show("size(.rdm_2_aa_grad_info) =",size_aa)
        .create(.rdm_2_aa_grad_info,size_aa)
     end !if
     !
     if (NOT .rdm_2_bb_grad_info.created) then
!        stdout.text("create .rdm_2_bb_grad_info")
!        stdout.show("size(.rdm_2_bb_grad_info) =",size_aa)
        .create(.rdm_2_bb_grad_info,size_aa)     
     end !if
     

     !!!
     ! number of terms in ".grad_info_tmp"
     ! the maximum number of terms needed is 18
     ! (see subroutine
     ! "calc_2rdm_elt_i_j_grd(red_pbg,two_rdm_elt,i,n)")
     nb_terms = 18
!     nb_terms = 10
!     nb_terms = 5
     !
     ! create object to store temporary information for the
     ! calculation of the energy gradient with respect to 
     ! the block coefficients
     if (NOT .grad_info_tmp.coef_prod.created) then
        .create_2rdm_grad_info_tmp(nb_terms)
     end
     !!!

     ng_1 = .n_geminals-1
     if (ng_1 /= 0) then
        red_pbg_1.n_geminals = ng_1
        red_pbg_1.nonzero_coef_ind.create(ng_1)
        red_pbg_1.nonzero_coef_prod.create(ng_1)
        red_pbg_1.first_block=.first_block
     end

     ng_2 = .n_geminals-2
     if (ng_2 > 0) then
        red_pbg_2.n_geminals = ng_2
        red_pbg_2.nonzero_coef_ind.create(ng_2)
        red_pbg_2.nonzero_coef_prod.create(ng_2)
        red_pbg_2.first_block=.first_block
     end

     ! same_block = TRUE

     i = 0

!     timer.start_timing
!     !
     !!! debug
!     stdout.text(" ")
!     stdout.text("call calc_2rdm_same_block_gen_grd")
!     stdout.text(" ")
!     stdout.flush
     !!!
     .calc_2rdm_same_block_gen_grd(i, ng_1, red_pbg_1)
     !!!
     !.calc_2rdm_same_block_gen(i, ng_1, red_pbg_1)
!     !
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) 2rdm_same_block_gen: ",timer.elapsed_time_s,14)

     ! same_block = FALSE

     ! cases where we "skip" at least one 1-orthogonal block 

     i = i+1
     i_a = 1
     i_b = 1

!     timer.start_timing
!     !
     !!! debug
!     stdout.text(" ")
!     stdout.text("call calc_2rdm_one_1_ortho_gen_grd")
!     stdout.text(" ")
!     stdout.flush
     !!!
     !!!
     .calc_2rdm_one_1_ortho_gen_grd(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
     !!!
     !.calc_2rdm_one_1_ortho_gen(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
!     !
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) 2rdm_one_1_ortho_gen: ",timer.elapsed_time_s,14)
    
     ! cases where we have at least one Pauli Block

!     timer.start_timing
!     !
     !!! debug
!     stdout.text(" ")
!     stdout.text("call calc_2rdm_one_pauli_gen_grd")
!     stdout.text(" ")
!     stdout.flush
     !!!
     !!!
     .calc_2rdm_one_pauli_gen_grd(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
     !!!
     !.calc_2rdm_one_pauli_gen(i, i_a, i_b, ng_1, red_pbg_1, ng_2, red_pbg_2)
!     !
!     timer.stop_timing
!     stdout.show("-) Time taken (in sec) 2rdm_one_pauli_gen: ",timer.elapsed_time_s,14)

     .nonzero_terms_ab = i-1
     .nonzero_terms_aa = i_a-1
     .nonzero_terms_bb = i_b-1
     
!     stdout.text("stop execution after calculation of 2RDM")
!     stop
     !!!!!!!!!!!!!!!!!!!!
     ! debug
!     trace = ZERO
!     mat_ab.create(.mat_size*.mat_size,.mat_size*.mat_size)
!     eigenval_ab.create(.mat_size*.mat_size)
!     nonzero_eigenval_ab.create(.mat_size*.mat_size)
!     eigenvec_ab.create(.mat_size*.mat_size,.mat_size*.mat_size)
!     mat_aa.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     eigenval_aa.create(.mat_size*(.mat_size-1)*2)
!     nonzero_eigenval_aa.create(.mat_size*(.mat_size-1)*2)
!     eigenvec_aa.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     mat_bb.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     eigenval_bb.create(.mat_size*(.mat_size-1)*2)
!     nonzero_eigenval_bb.create(.mat_size*(.mat_size-1)*2)
!     eigenvec_bb.create(.mat_size*(.mat_size-1)*2,.mat_size*(.mat_size-1)*2)
!     mat_ab = ZERO
!     mat_aa = ZERO
!     mat_bb = ZERO
!
!     do r=1,.nonzero_terms_ab
!        j_1 = (.rdm_2_ab(r).indices(1)-1)*.mat_size+.rdm_2_ab(r).indices(2)
!        j_2 = (.rdm_2_ab(r).indices(3)-1)*.mat_size+.rdm_2_ab(r).indices(4)
!        mat_ab(j_1,j_2) = .rdm_2_ab(r).coefficient
!        if (.rdm_2_ab(r).indices(1) == .rdm_2_ab(r).indices(3) AND .rdm_2_ab(r).indices(2) == .rdm_2_ab(r).indices(4)) then
!           trace = trace + .rdm_2_ab(r).coefficient
!        end
!     end
!     mat_ab.solve_symmetric_eigenproblem(eigenval_ab,eigenvec_ab) 
!     s = 0
!     do r=1,.mat_size*.mat_size
!        if (abs(eigenval_ab(r)) > TOL(15)) then
!           s = s+1
!           nonzero_eigenval_ab(s) = eigenval_ab(r)
!        end
!     end
!     s_ab = s
!
!     do r=1,.nonzero_terms_aa
!        j_1 = (.rdm_2_aa(r).indices(1)-1)*.mat_size+.rdm_2_aa(r).indices(2)
!        j_2 = (.rdm_2_aa(r).indices(3)-1)*.mat_size+.rdm_2_aa(r).indices(4)
!        mat_aa(j_1,j_2) = .rdm_2_aa(r).coefficient
!        if (.rdm_2_aa(r).indices(1) == .rdm_2_aa(r).indices(3) AND .rdm_2_aa(r).indices(2) == .rdm_2_aa(r).indices(4)) then
!           trace = trace + .rdm_2_aa(r).coefficient
!        end
!     end
!     mat_aa.solve_symmetric_eigenproblem(eigenval_aa,eigenvec_aa) 
!     s = 0
!     do r=1,.mat_size*(.mat_size-1)*2
!        if (abs(eigenval_aa(r)) > TOL(15)) then
!           s = s+1
!           nonzero_eigenval_aa(s) = eigenval_aa(r)
!        end
!     end
!     s_aa = s
!
!     do r=1,.nonzero_terms_bb
!        j_1 = (.rdm_2_bb(r).indices(1)-1)*.mat_size+.rdm_2_bb(r).indices(2)
!        j_2 = (.rdm_2_bb(r).indices(3)-1)*.mat_size+.rdm_2_bb(r).indices(4)
!        mat_bb(j_1,j_2) = .rdm_2_bb(r).coefficient
!        if (.rdm_2_bb(r).indices(1) == .rdm_2_bb(r).indices(3) AND .rdm_2_bb(r).indices(2) == .rdm_2_bb(r).indices(4)) then
!           trace = trace + .rdm_2_bb(r).coefficient
!        end
!     end
!     mat_bb.solve_symmetric_eigenproblem(eigenval_bb,eigenvec_bb) 
!     s = 0
!     do r=1,.mat_size*(.mat_size-1)*2
!        if (abs(eigenval_bb(r))> TOL(15)) then
!           s = s+1
!           nonzero_eigenval_bb(s) = eigenval_aa(r)
!        end
!     end
!     s_bb = s
     !!!!!!!!!!!!!!!!!!!!

   !debug stdout.text(" ")
   !debug stdout.show("Number of nonzero coefficients of the 2-RDM alpha-beta matrix", .nonzero_terms_ab)
   !debug stdout.show("Number of nonzero eigenvalues of the 2-RDM alpha-beta matrix", s_ab)
   !debug stdout.text("Nonzero eigenvalues of the 2-RDM alpha-beta matrix")
   !debug stdout.put(nonzero_eigenval_ab(1:s_ab))
   !debug stdout.text(" ")
   !debug stdout.show("Number of nonzero coefficients of the 2-RDM alpha-alpha matrix", .nonzero_terms_aa)
   !debug stdout.show("Number of nonzero eigenvalues of the 2-RDM alpha-alpha matrix", s_aa)
   !debug stdout.text("Nonzero eigenvalues of the 2-RDM alpha-alpha matrix")
   !debug stdout.put(nonzero_eigenval_aa(1:s_aa))
   !debug stdout.text(" ")
   !debug stdout.show("Number of nonzero coefficients of the 2-RDM beta-beta matrix", .nonzero_terms_bb)
   !debug stdout.show("Number of nonzero eigenvalues of the 2-RDM beta-beta matrix", s_bb)
   !debug stdout.text("Nonzero eigenvalues of the 2-RDM beta-beta matrix")
   !debug stdout.put(nonzero_eigenval_bb(1:s_bb))
   !debug stdout.text(" ")
   !debug stdout.show("Trace of the total 2-RDM matrix", trace)  
   !debug stdout.show("Sum of eigenvalues", sum(nonzero_eigenval_ab(1:s_ab))+sum(nonzero_eigenval_aa(1:s_aa))+sum(nonzero_eigenval_bb(1:s_bb)))   

     !!! debug (new)
     if (.debug) then
        stdout.text(" ")
        stdout.show("Overlap =",.overlap)
        if (.n_2D_3typ_blocks > 0) then
           stdout.show("first_GD2_elt =",.first_GD2_elt)
           stdout.show("second_GD2_elt =",.second_GD2_elt)
        end
        stdout.text(" ")
        stdout.text("2RDM alpha/beta nonzero elements:")
        stdout.show("Number of nonzero elements =",.nonzero_terms_ab)
        c = 0
        do j1=1,.mat_size
           do j2=1,.mat_size
              do j3=1,.mat_size
                 do j4=1,.mat_size
                    do j=1,.nonzero_terms_ab
                       k1 = .rdm_2_ab(j).indices(1)
                       k2 = .rdm_2_ab(j).indices(2)
                       k3 = .rdm_2_ab(j).indices(3)
                       k4 = .rdm_2_ab(j).indices(4)
                       if (j1==k1 AND j2==k2 AND j3==k3 AND j4==k4) then
                          c = c + 1
                          stdout.show("counter",c)
                          stdout.show("indices",.rdm_2_ab(j).indices)
                          stdout.show("coefficient",.rdm_2_ab(j).coefficient)
                          exit
                       end
                    end
                 end
              end
           end
        end
        stdout.text(" ")
        stdout.text("2RDM alpha/alpha nonzero elements:")
        stdout.show("Number of nonzero elements =",.nonzero_terms_aa)
        do j=1,.nonzero_terms_aa
           stdout.text(" ")
           stdout.show("indices",.rdm_2_aa(j).indices)
           stdout.show("coefficient",.rdm_2_aa(j).coefficient)
        end
        stdout.text(" ")
        stdout.text("2RDM beta/beta nonzero elements:")
        stdout.show("Number of nonzero elements =",.nonzero_terms_bb)
        do j=1,.nonzero_terms_bb
           stdout.text(" ")
           stdout.show("indices",.rdm_2_bb(j).indices)
           stdout.show("coefficient",.rdm_2_bb(j).coefficient)
        end
     end !!! debug
     !!!

     !!! debug new
     if (.debug) then
        .check_2rdm_grad_info
     end
     !!!

     if (ng_1 /= 0) then
        red_pbg_1.destroy_ptr_part
     end
     if (ng_2 > 0) then
        red_pbg_2.destroy_ptr_part
     end
   
   end

!!! debug new
   check_2rdm_grad_info
   ! check information about the 2RDM
   ! that will be used to compute the
   ! energy gradient
     i, j, nt :: INT
     elt, cpr, rov, diff :: REAL

     stdout.text(" ")
     stdout.show("wfu overlap =", .overlap)

     stdout.text(" ")
     stdout.text("Checking 2RDM alpha/beta grad. info.:")
     ! 2rdm alpha/beta
     do i=1,.nonzero_terms_ab
        stdout.text(" ")
        stdout.show("element", i)
        stdout.show("indices", .rdm_2_ab(i).indices)
        elt = ZERO
        nt = .rdm_2_ab_grad_info(i).nb_terms
        do j=1,nt
           cpr = .rdm_2_ab_grad_info(i).coef_prod(j)
           rov = .rdm_2_ab_grad_info(i).red_ov(j)
           elt = elt + cpr*rov
        end
        elt = elt/.overlap
        stdout.show("recomputed value =", elt)
        stdout.show("reference value  =", .rdm_2_ab(i).coefficient)
        diff = elt-.rdm_2_ab(i).coefficient
        if (abs(diff) > TOL(15)) then
           stdout.text("Detected unconsistency in rdm_2_ab_grad_info")
           stdout.text("Error termination")
           stop
        end
     end

     stdout.text(" ")
     stdout.text("Checking 2RDM alpha/alpha grad. info.:")
     ! 2rdm alpha/alpha
     do i=1,.nonzero_terms_aa
        stdout.text(" ")
        stdout.show("element", i)
        stdout.show("indices", .rdm_2_aa(i).indices)
        elt = ZERO
        nt = .rdm_2_aa_grad_info(i).nb_terms
        do j=1,nt
           cpr = .rdm_2_aa_grad_info(i).coef_prod(j)
           rov = .rdm_2_aa_grad_info(i).red_ov(j)
           elt = elt + cpr*rov
        end
        elt = elt/.overlap
        stdout.show("recomputed value =", elt)
        stdout.show("reference value  =", .rdm_2_aa(i).coefficient)
        diff = elt-.rdm_2_aa(i).coefficient
        if (abs(diff) > TOL(15)) then
           stdout.text("Detected unconsistency in rdm_2_aa_grad_info")
           stdout.text("Error termination")
           stop
        end
     end

     stdout.text(" ")
     stdout.text("Checking 2RDM beta/beta grad. info.:")
     ! 2rdm beta/beta
     do i=1,.nonzero_terms_bb
        stdout.text(" ")
        stdout.show("element", i)
        stdout.show("indices", .rdm_2_bb(i).indices)
        elt = ZERO
        nt = .rdm_2_bb_grad_info(i).nb_terms
        do j=1,nt
           cpr = .rdm_2_bb_grad_info(i).coef_prod(j)
           rov = .rdm_2_bb_grad_info(i).red_ov(j)
           elt = elt + cpr*rov
        end
        elt = elt/.overlap
        stdout.show("recomputed value =", elt)
        stdout.show("reference value  =", .rdm_2_bb(i).coefficient)
        diff = elt-.rdm_2_bb(i).coefficient
        if (abs(diff) > TOL(15)) then
           stdout.text("Detected unconsistency in rdm_2_bb_grad_info")
           stdout.text("Error termination")
           stop
        end
     end

   end
!!!

   calc_2rdm_same_block_gen(i,ng_1,red_pbg_1)
   !
     i :: INT
     ng_1 :: INT
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     j, m :: INT
     g, b :: INT
     block, geminal, siz :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN

     do b=1,.n_1D_blocks
        g = .nonzero_1ortho_ind(b)
        if (g == 0) cycle
        coef_1 = .bra_set.vec(g).coef(b)
        if (.bra_is_ket) then
           coef_prod = coef_1*coef_1
        else
           coef_2 = .ket_set.vec(g).coef(b)
           coef_prod = coef_1*coef_2
        end
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1,g)
           red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg_1.calc_overlap_integral(overlap,FALSE)
        else
           overlap = ONE
        end
        i = i+1
        .rdm_2_ab(i).same_block = TRUE
        .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
        .rdm_2_ab(i).indices = (/ b,b,b,b /)
        .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
        .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
      !debug stdout.text(" ")
      !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
      !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
     end

     m = .n_1D_blocks+.n_2D_3typ_blocks     

     if (.n_2D_3typ_blocks /= 0) then
     do b=.n_1D_blocks+1,m
        block = b - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block-1)+1
        ind_2 = .n_1D_blocks+2*(block-1)+2
        do j=3,5 ! geminal with SX, ISY or GD2 in block "block" are skipped
           geminal = .block_types(block).element(j) 
           if (geminal /= 0) then
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              if (ng_1 /= 0) then
                 .prep_red_pbg(red_pbg_1, geminal, block, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg_1.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                 else
                    term(j) = ZERO
                 end
              else
                 term(j) = coef_prod
              end
           else
              term(j) = ZERO
           end
        end
        if (abs(term(5)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_1,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_ab(i).coefficient = term(5)*.first_GD2_elt(block)*.first_GD2_elt(block)/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_2,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_ab(i).coefficient = term(5)*.second_GD2_elt(block)*.second_GD2_elt(block)/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_2,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_ab(i).coefficient = term(5)*.first_GD2_elt(block)*.second_GD2_elt(block)/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_1,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (abs(term(3)+term(4)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_1,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_ab(i).coefficient = (term(3)+term(4))/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_2,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (abs(term(3)-term(4)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_2,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_ab(i).coefficient = (term(3)-term(4))/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_1,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
     end
     end

     if (.n_2D_4typ_blocks /= 0) then
     do b=m+1,.n_blocks
        block = b - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block-1)+1
        ind_2 = .n_1D_blocks+2*(block-1)+2
        do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
           geminal = .block_types(block).element(j) 
           if (geminal /= 0) then
              coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
              if (ng_1 /= 0) then
                 .prep_red_pbg(red_pbg_1, geminal, block, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg_1.calc_overlap_integral(overlap,FALSE)
                    term(j) = coef_prod*overlap
                 else
                    term(j) = ZERO
                 end
              else
                 term(j) = coef_prod
              end
           else
              term(j) = ZERO
           end
        end
        if (abs(term(1)+term(2)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_1,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_ab(i).coefficient = (term(1)+term(2))/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_2,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (abs(term(3)+term(4)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_1,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_ab(i).coefficient = (term(3)+term(4))/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_2,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (abs(term(1)-term(2)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_2,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_ab(i).coefficient = (term(1)-term(2))/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_1,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
        if (abs(term(3)-term(4)) > TOL(15)) then

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_2,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_ab(i).coefficient = (term(3)-term(4))/.overlap
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)

           i = i+1
           .rdm_2_ab(i).same_block = TRUE
           .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_1,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
         !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        end
     end
     end

   end
! already mod.*
   calc_2rdm_same_block_gen_grd(i,ng_1,red_pbg_1)
   !
     i :: INT
     ng_1 :: INT
     red_pbg_1 :: PAULI_BLOCK_GEMINALS
     j, m :: INT
     g, b :: INT
     block, geminal, siz :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(2)
     cpr_saved :: REAL
     nonzero_gem :: VEC{BIN}(5)
     nb_terms :: INT
     !!!
     tt_gd2 :: VEC{INT}(1)
     !!!
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine calc_2rdm_same_block_gen_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!
!     stdout.text(" ")
!     backspace(stdout.unit)

     ! start 1D blocks !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     do b=1,.n_1D_blocks
        g = .nonzero_1ortho_ind(b)
        if (g == 0) cycle
        coef_1 = .bra_set.vec(g).coef(b)
        !!! debug
!        stdout.show("coef_1 =", coef_1)
        !!!
        if (.bra_is_ket) then
           coef_prod = coef_1*coef_1
        else
           coef_2 = .ket_set.vec(g).coef(b)
           coef_prod = coef_1*coef_2
        end
        if (ng_1 /= 0) then
           .prep_red_pbg(red_pbg_1,g)
           red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
           red_pbg_1.calc_overlap_integral(overlap,FALSE)
        else
           overlap = ONE
        end
        !!! debug
!        stdout.show("overlap =", overlap)
        !!!
        i = i+1
        .rdm_2_ab(i).same_block = TRUE
        .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
        .rdm_2_ab(i).indices = (/ b,b,b,b /)
        .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
        .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
        !!! save gradient information
        !.grad_info_tmp.nb_terms = 1
        .grad_info_tmp.coef_prod(1) = coef_prod
        .grad_info_tmp.red_ov(1) = overlap
        !.grad_info_tmp.ex_gem(1).element(1) = g
        .grad_info_tmp.ex_gem(1).element = g
        .grad_info_tmp.ex_blk(1).element = b
        .grad_info_tmp.factor(1).element = 2
        tt(1) = 1
        .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
        !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=0, nt=1, terms=tt)
        !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=0)
        !!!
      !debug stdout.text(" ")
      !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
      !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
     end
     ! end 1D blocks !!!!!!!!!!!!!!!!!!!!!!!!

     ! 2D blocks !!!!!!!!!!!!!!!!!!!!!!!!
     m = .n_1D_blocks+.n_2D_3typ_blocks     

     ! 2D-3typ blocks !!!!!!!!!!!!!!!!!!!
     if (.n_2D_3typ_blocks /= 0) then
        do b=.n_1D_blocks+1,m
           block = b - .n_1D_blocks
           ind_1 = .n_1D_blocks+2*(block-1)+1
           ind_2 = .n_1D_blocks+2*(block-1)+2
           !!!
           nonzero_gem = TRUE
           !!!
           do j=3,5 ! geminal with SX, ISY or GD2 in block "block" are skipped
              geminal = .block_types(block).element(j) 
              if (geminal /= 0) then
                 coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
                 if (ng_1 /= 0) then
                    .prep_red_pbg(red_pbg_1, geminal, block, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_1.calc_overlap_integral(overlap,FALSE)
                       term(j) = coef_prod*overlap
                    else
                       !!!
                       overlap = ZERO
                       nonzero_gem(j) = FALSE
                       !!!
                       term(j) = ZERO
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    term(j) = coef_prod
                 end
              else
                 !!!
                 coef_prod = ZERO
                 overlap = ZERO
                 nonzero_gem(j) = FALSE
                 !!!
                 term(j) = ZERO
              end
              !!!
              .grad_info_tmp.coef_prod(j) = coef_prod
              .grad_info_tmp.red_ov(j) = overlap
              !.grad_info_tmp.ex_gem(j).element(1) = geminal
              !.grad_info_tmp.ex_blk(j).element(1) = block
              .grad_info_tmp.ex_gem(j).element = geminal
              .grad_info_tmp.ex_blk(j).element = b
              .grad_info_tmp.factor(j).element = 2
!              nonzero_gem(j) = (geminal /= 0)
              !!!
           end
!           if (abs(term(5)) > TOL(15)) then
           if (nonzero_gem(5)) then
              !!!
              tt(1) = 5
              cpr_saved = .grad_info_tmp.coef_prod(5) 
              !!!
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_1,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = term(5)*.first_GD2_elt(block)*.first_GD2_elt(block)/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(5) = cpr_saved*(.first_GD2_elt(block)**2)
              !!!
              tt_gd2(1) = 5
              .grad_info_tmp.GD2_cpr(5) = cpr_saved
              .grad_info_tmp.GD2_blk(5).element = block
              .grad_info_tmp.GD2_cas(5).element = 3
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
              .rdm_2_ab(i).coefficient = term(5)*.second_GD2_elt(block)*.second_GD2_elt(block)/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(5) = cpr_saved*(.second_GD2_elt(block)**2)
              !!!
              .grad_info_tmp.GD2_cas(5).element = 4
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
              .rdm_2_ab(i).coefficient = term(5)*.first_GD2_elt(block)*.second_GD2_elt(block)/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(5) = cpr_saved*.first_GD2_elt(block)*.second_GD2_elt(block)
              !!!
              .grad_info_tmp.GD2_cas(5).element = 5
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_1,ind_1 /)
              .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              !!!
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
              !!!
              .grad_info_tmp.coef_prod(5) = cpr_saved
              !!!
           end
!           end
!           if (abs(term(3)+term(4)) > TOL(15)) then
           if (nonzero_gem(3) OR nonzero_gem(4)) then
              if (nonzero_gem(3) AND nonzero_gem(4)) then
                 tt(1) = 3
                 tt(2) = 4
                 nb_terms = 2
              else if (nonzero_gem(3)) then
                 tt(1) = 3
                 nb_terms = 1
              else
                 tt(1) = 4
                 nb_terms = 1
              end
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_1,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = (term(3)+term(4))/.overlap
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
!           end
!           if (abs(term(3)-term(4)) > TOL(15)) then
              !!!
              !tt(1) = 3
              !tt(2) = 4
              cpr_saved = .grad_info_tmp.coef_prod(4) 
              !!!
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = (term(3)-term(4))/.overlap
              !!!
              .grad_info_tmp.coef_prod(4) = -cpr_saved
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_1,ind_2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!!
              !.grad_info_tmp.coef_prod(4) = -cpr_saved
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
              !!!
              .grad_info_tmp.coef_prod(4) = cpr_saved 
              !!!
           end
!           end
        end
     end
     ! end 2D-3typ blocks !!!!!!!!!!!!!!!!!!!

     ! 2D-4typ blocks !!!!!!!!!!!!!!!!!!!
     if (.n_2D_4typ_blocks /= 0) then
        do b=m+1,.n_blocks
           block = b - .n_1D_blocks
           ind_1 = .n_1D_blocks+2*(block-1)+1
           ind_2 = .n_1D_blocks+2*(block-1)+2
           !!!
           nonzero_gem = TRUE
           !!!
           do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block" are skipped
              geminal = .block_types(block).element(j) 
              if (geminal /= 0) then
                 coef_prod = .nonzero_coef_prod(geminal).element(block-.first_block+1)/TWO
                 if (ng_1 /= 0) then
                    .prep_red_pbg(red_pbg_1, geminal, block, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_1.calc_overlap_integral(overlap,FALSE)
                       term(j) = coef_prod*overlap
                    else
                       !!!
                       overlap = ZERO
                       nonzero_gem(j) = FALSE
                       !!!
                       term(j) = ZERO
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    term(j) = coef_prod
                 end
              else
                 !!!
                 coef_prod = ZERO
                 overlap = ONE
                 nonzero_gem(j) = FALSE
                 !!!
                 term(j) = ZERO
              end
              !!!
              .grad_info_tmp.coef_prod(j) = coef_prod
              .grad_info_tmp.red_ov(j) = overlap
              !.grad_info_tmp.ex_gem(j).element(1) = geminal
              !.grad_info_tmp.ex_blk(j).element(1) = block
              .grad_info_tmp.ex_gem(j).element = geminal
              .grad_info_tmp.ex_blk(j).element = b
              .grad_info_tmp.factor(j).element = 2
!              nonzero_gem(j) = (geminal /= 0)
              !!!
           end
!           if (abs(term(1)+term(2)) > TOL(15)) then
           !!!
           if (nonzero_gem(1) OR nonzero_gem(2)) then
              if (nonzero_gem(1) AND nonzero_gem(2)) then
                 tt(1) = 1
                 tt(2) = 2
                 nb_terms = 2
              else if (nonzero_gem(1)) then
                 tt(1) = 1
                 nb_terms = 1
              else
                 tt(1) = 2
                 nb_terms = 1
              end
           !!!
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_1,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = (term(1)+term(2))/.overlap
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
           end
!           end
!           if (abs(term(3)+term(4)) > TOL(15)) then
           if (nonzero_gem(3) OR nonzero_gem(4)) then
              if (nonzero_gem(3) AND nonzero_gem(4)) then
                 tt(1) = 3
                 tt(2) = 4
                 nb_terms = 2
              else if (nonzero_gem(3)) then
                 tt(1) = 3
                 nb_terms = 1
              else
                 tt(1) = 4
                 nb_terms = 1
              end
              !!!
              !tt(1) = 3
              !tt(2) = 4
              !!!
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_1,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = (term(3)+term(4))/.overlap
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
           end
!           end
!           if (abs(term(1)-term(2)) > TOL(15)) then
           !!!
           if (nonzero_gem(1) OR nonzero_gem(2)) then
              if (nonzero_gem(1) AND nonzero_gem(2)) then
                 tt(1) = 1
                 tt(2) = 2
                 nb_terms = 2
              else if (nonzero_gem(1)) then
                 tt(1) = 1
                 nb_terms = 1
              else
                 tt(1) = 2
                 nb_terms = 1
              end
           !!!
              !!!
              !tt(1) = 1
              !tt(2) = 2
              cpr_saved = .grad_info_tmp.coef_prod(2) 
              !!!
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
              .rdm_2_ab(i).coefficient = (term(1)-term(2))/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(2) = -cpr_saved 
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_1,ind_1 /)
              .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              !.grad_info_tmp.coef_prod(2) = -cpr_saved 
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
              !!!
              .grad_info_tmp.coef_prod(2) = cpr_saved 
              !!!
           end   
!           end
!           if (abs(term(3)-term(4)) > TOL(15)) then
           if (nonzero_gem(3) OR nonzero_gem(4)) then
              if (nonzero_gem(3) AND nonzero_gem(4)) then
                 tt(1) = 3
                 tt(2) = 4
                 nb_terms = 2
              else if (nonzero_gem(3)) then
                 tt(1) = 3
                 nb_terms = 1
              else
                 tt(1) = 4
                 nb_terms = 1
              end
              !!!
              !tt(1) = 3
              !tt(2) = 4
              cpr_saved = .grad_info_tmp.coef_prod(4)
              !!!
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = (term(3)-term(4))/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(4) = -cpr_saved 
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
        
              i = i+1
              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ block,block,block,block /)
              .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_1,ind_2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              !.grad_info_tmp.coef_prod(4) = -cpr_saved 
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=2, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
              !!!
              .grad_info_tmp.coef_prod(4) = cpr_saved 
              !!!
           end   
!           end
        end
     end
     ! end 2D-4typ blocks !!!!!!!!!!!!!!!!!!!

     ! end 2D blocks !!!!!!!!!!!!!!!!!!!

   end
! de

   calc_2rdm_one_1_ortho_gen(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     j :: INT
     r, s :: INT
     g, b :: INT
     block, geminal, siz :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     do r=1,.n_1D_blocks-1
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)
        if (NOT .bra_is_ket) then
           coef_2 = .ket_set.vec(geminal).coef(r)
        end 
        do b=r+1,.n_1D_blocks
           g = .nonzero_1ortho_ind(b)
           if (g == 0) cycle
           if (g == geminal) then
              coef_3 = .bra_set.vec(g).coef(b)
              if (NOT .bra_is_ket) then
                 coef_4 = .ket_set.vec(g).coef(b)
              end
              if (ng_1 /= 0) then
                 .prep_red_pbg(red_pbg_1,g)
                 red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_1.calc_overlap_integral(overlap,FALSE)
              else
                 overlap = ONE
              end

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ r,r,b,b /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              if (.bra_is_ket) then
                 .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
              else
                 .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
              end            
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ b,b,r,r /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              if (.bra_is_ket) then
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              else
                 .rdm_2_ab(i).coefficient = coef_2*coef_3*overlap/.overlap
              end  
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           else if (g /= geminal) then
              coef_3 = .bra_set.vec(g).coef(b)
              if (.bra_is_ket) then
                 coef_prod = coef_1*coef_1*coef_3*coef_3
              else
                 coef_4 = .ket_set.vec(g).coef(b)
                 coef_prod = coef_1*coef_2*coef_3*coef_4
              end
              if (ng_2 > 0) then
                 .prep_red_pbg_g(red_pbg_2,geminal,g)
                 red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 overlap = ONE
              end

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ r,b,r,b /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ b,r,b,r /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           end
        end
     end

     do r=1,.n_1D_blocks
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)
        if (NOT .bra_is_ket) then
           coef_2 = .ket_set.vec(geminal).coef(r)
        end  
        siz = size(.nonzero_coef_ind(geminal).element)
        do s=2,siz
           block = .nonzero_coef_ind(geminal).element(s)
           b = block + .n_1D_blocks
           ind_1 = .n_1D_blocks+2*(block-1)+1
           ind_2 = .n_1D_blocks+2*(block-1)+2
           if (ng_1 /= 0) then
              .prep_red_pbg(red_pbg_1, geminal, block, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_1.calc_overlap_integral(overlap,FALSE)
                 coef_3 = .bra_set.vec(geminal).coef(b)
                 if (NOT .bra_is_ket) then
                    coef_4 = .ket_set.vec(geminal).coef(b)
                 end
              end
           else
              overlap = ONE
              coef_3 = .bra_set.vec(geminal).coef(b)
              if (NOT .bra_is_ket) then
                 coef_4 = .ket_set.vec(geminal).coef(b)
              end
           end

           if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) OR (ng_1 == 0)) then

              if (geminal == .block_types(block).element(1)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end

              if (geminal == .block_types(block).element(2)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end

              if (geminal == .block_types(block).element(3)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

              end

              if (geminal == .block_types(block).element(4)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

              end

              if (geminal == .block_types(block).element(5)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*.first_GD2_elt(block)*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*.first_GD2_elt(block)*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_1*coef_3*.second_GD2_elt(block)*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_1*coef_4*.second_GD2_elt(block)*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*.first_GD2_elt(block)*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*.first_GD2_elt(block)*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*.second_GD2_elt(block)*overlap/.overlap
                 else
                    .rdm_2_ab(i).coefficient = coef_3*coef_2*.second_GD2_elt(block)*overlap/.overlap
                 end
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end
           end
        end
     end

   end
! already mod.*
   calc_2rdm_one_1_ortho_gen_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     j :: INT
     r, s :: INT
     g, b :: INT
     block, geminal, siz :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2, coef_3, coef_4 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN
     tt :: VEC{INT}(2)
     !!!
     tt_gd2 :: VEC{INT}(1)
     GD2_cpr :: REAL
     !!!
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine calc_2rdm_one_1_ortho_gen_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
!!     stdout.flush
     !!!

     !!! debug
!     stdout.text(" ")
!     stdout.text("Routine calc_2rdm_one_1_ortho_gen_grd")
!     stdout.text("1D block - 1D block")
!     stdout.flush
     !!!
     ! 1D block - 1D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     do r=1,.n_1D_blocks-1
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)
        if (NOT .bra_is_ket) then
           coef_2 = .ket_set.vec(geminal).coef(r)
        end 
        do b=r+1,.n_1D_blocks
           g = .nonzero_1ortho_ind(b)
           if (g == 0) cycle
           if (g == geminal) then
              coef_3 = .bra_set.vec(g).coef(b)
              if (NOT .bra_is_ket) then
                 coef_4 = .ket_set.vec(g).coef(b)
              end
              if (ng_1 /= 0) then
                 .prep_red_pbg(red_pbg_1,g)
                 red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_1.calc_overlap_integral(overlap,FALSE)
              else
                 overlap = ONE
              end

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ r,r,b,b /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              if (.bra_is_ket) then
                 coef_prod = coef_1*coef_3
                 .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                 !.rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
              else
                 coef_prod = coef_1*coef_4
                 .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                 !.rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
              end            
              !!! save gradient information
              .grad_info_tmp.coef_prod(1) = coef_prod
              .grad_info_tmp.red_ov(1) = overlap
              !.grad_info_tmp.ex_gem(1).element(1) = g
              .grad_info_tmp.ex_gem(1).element = g
              .grad_info_tmp.ex_blk(1).element(1) = r
              .grad_info_tmp.ex_blk(1).element(2) = b
              .grad_info_tmp.factor(1).element = 1
              tt(1) = 1
              !!! debug
!              stdout.text("save_2rdm_grad_info   1 ab")
!              stdout.flush
              !!!
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=0, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ b,b,r,r /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              if (.bra_is_ket) then
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              else
                 coef_prod = coef_2*coef_3
                 .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                 !.rdm_2_ab(i).coefficient = coef_2*coef_3*overlap/.overlap
              end  
              !!! save gradient information
              .grad_info_tmp.coef_prod(1) = coef_prod
              !!! debug
!              stdout.text("save_2rdm_grad_info   2 ab")
!              stdout.flush
              !!!
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=0, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           else if (g /= geminal) then
              coef_3 = .bra_set.vec(g).coef(b)
              if (.bra_is_ket) then
                 coef_prod = coef_1*coef_1*coef_3*coef_3
              else
                 coef_4 = .ket_set.vec(g).coef(b)
                 coef_prod = coef_1*coef_2*coef_3*coef_4
              end
              if (ng_2 > 0) then
                 .prep_red_pbg_g(red_pbg_2,geminal,g)
                 red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_2.calc_overlap_integral(overlap,FALSE)
              else
                 overlap = ONE
              end

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ r,b,r,b /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(1) = coef_prod
              .grad_info_tmp.red_ov(1) = overlap
              .grad_info_tmp.ex_gem(1).element(1) = geminal
              .grad_info_tmp.ex_gem(1).element(2) = g
              .grad_info_tmp.ex_blk(1).element(1) = r
              .grad_info_tmp.ex_blk(1).element(2) = b
              .grad_info_tmp.factor(1).element = 2
              tt(1) = 1
              !!! debug
!              stdout.text("save_2rdm_grad_info   3 ab")
!              stdout.flush
              !!!
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=0, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              !!! save gradient information
              !!! debug
!              stdout.text("save_2rdm_grad_info   1 aa")
!              stdout.flush
              !!!
              .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=1, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, ng=2, nb=0, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              !!! save gradient information
              !!! debug
!              stdout.text("save_2rdm_grad_info   1 bb")
!              stdout.flush
              !!!
              .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=1, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, ng=2, nb=0, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = TRUE
              .rdm_2_ab(i).block_numbers = (/ 0,0,0,0 /)
              .rdm_2_ab(i).indices = (/ b,r,b,r /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              !!! debug
!              stdout.text("save_2rdm_grad_info   4 ab")
!              stdout.flush
              !!!
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=0, nt=1, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           end
        end
     end
     ! end 1D block - 1D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     !!! debug
!     stdout.text("1D block - 2D block")
!     stdout.flush
     !!!
     ! 1D block - 2D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     do r=1,.n_1D_blocks
        geminal = .nonzero_1ortho_ind(r)
        if (geminal == 0) cycle
        coef_1 = .bra_set.vec(geminal).coef(r)
        if (NOT .bra_is_ket) then
           coef_2 = .ket_set.vec(geminal).coef(r)
        end  
        siz = size(.nonzero_coef_ind(geminal).element)
        do s=2,siz
           block = .nonzero_coef_ind(geminal).element(s)
           b = block + .n_1D_blocks
           ind_1 = .n_1D_blocks+2*(block-1)+1
           ind_2 = .n_1D_blocks+2*(block-1)+2
           if (ng_1 /= 0) then
              .prep_red_pbg(red_pbg_1, geminal, block, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg_1.calc_overlap_integral(overlap,FALSE)
                 coef_3 = .bra_set.vec(geminal).coef(b)
                 if (NOT .bra_is_ket) then
                    coef_4 = .ket_set.vec(geminal).coef(b)
                 end
              end
           else
              overlap = ONE
              coef_3 = .bra_set.vec(geminal).coef(b)
              if (NOT .bra_is_ket) then
                 coef_4 = .ket_set.vec(geminal).coef(b)
              end
           end

           if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) OR (ng_1 == 0)) then
              !!! save gradient information
              .grad_info_tmp.red_ov(1) = overlap
              !.grad_info_tmp.ex_gem(1).element(1) = geminal
              !.grad_info_tmp.ex_blk(1).element(1) = block
              .grad_info_tmp.ex_gem(1).element = geminal
              .grad_info_tmp.ex_blk(1).element(1) = r
              .grad_info_tmp.ex_blk(1).element(2) = b
              .grad_info_tmp.factor(1).element = 1
              tt(1) = 1
              !!!

              if (geminal == .block_types(block).element(1)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_3
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    coef_prod = coef_1*coef_4
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 !.grad_info_tmp.red_ov(1) = overlap
                 !.grad_info_tmp.ex_gem(1).element(1) = geminal
                 !.grad_info_tmp.ex_blk(1).element(1) = block
                 !tt(1) = 1
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    coef_prod = coef_3*coef_2
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end

              if (geminal == .block_types(block).element(2)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_3
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    coef_prod = coef_1*coef_4
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = -coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    coef_prod = coef_3*coef_2
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = -coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end

              if (geminal == .block_types(block).element(3)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_3
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    coef_prod = coef_1*coef_4
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    coef_prod = coef_3*coef_2
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

              end

              if (geminal == .block_types(block).element(4)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_3
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_3*overlap/.overlap
                 else
                    coef_prod = coef_1*coef_4
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_4*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = -coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_1*overlap/.overlap
                 else
                    coef_prod = coef_3*coef_2
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_2*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                 .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = -coef_prod
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=1, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

              end

              if (geminal == .block_types(block).element(5)) then 
          
                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_1,ind_1 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    GD2_cpr = coef_1*coef_3
                    coef_prod = GD2_cpr*.first_GD2_elt(block)
                    !coef_prod = coef_1*coef_3*.first_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_3*.first_GD2_elt(block)*overlap/.overlap
                 else
                    GD2_cpr = coef_1*coef_4
                    coef_prod = GD2_cpr*.first_GD2_elt(block)
                    !coef_prod = coef_1*coef_4*.first_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_4*.first_GD2_elt(block)*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 !!!
                 ! new
                 tt_gd2(1) = 1
                 .grad_info_tmp.GD2_cpr(1) = GD2_cpr
                 .grad_info_tmp.GD2_blk(1).element = block
                 .grad_info_tmp.GD2_cas(1).element = 1
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                 !!!
                 ! old
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ 0,0,block,block /)
                 .rdm_2_ab(i).indices = (/ r,r,ind_2,ind_2 /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                 if (.bra_is_ket) then
                    GD2_cpr = coef_1*coef_3
                    coef_prod = GD2_cpr*.second_GD2_elt(block)
                    !coef_prod = coef_1*coef_3*.second_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_3*.second_GD2_elt(block)*overlap/.overlap
                 else
                    GD2_cpr = coef_1*coef_4
                    coef_prod = GD2_cpr*.second_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*coef_4*.second_GD2_elt(block)*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 !!!
                 ! new
                 .grad_info_tmp.GD2_cpr(1) = GD2_cpr
                 .grad_info_tmp.GD2_cas(1).element = 2
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                 !!!
                 ! old
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_1,ind_1,r,r /)
                 .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    GD2_cpr = coef_3*coef_1
                    coef_prod = GD2_cpr*.first_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_1*.first_GD2_elt(block)*overlap/.overlap
                 else
                    GD2_cpr = coef_3*coef_2
                    coef_prod = GD2_cpr*.first_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_2*.first_GD2_elt(block)*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 !!!
                 ! new
                 .grad_info_tmp.GD2_cpr(1) = GD2_cpr
                 .grad_info_tmp.GD2_cas(1).element = 1
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                 !!!
                 ! old
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1

                 .rdm_2_ab(i).same_block = FALSE
                 .rdm_2_ab(i).block_numbers = (/ block,block,0,0 /)
                 .rdm_2_ab(i).indices = (/ ind_2,ind_2,r,r /)
                 .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                 if (.bra_is_ket) then
                    GD2_cpr = coef_3*coef_1
                    coef_prod = GD2_cpr*.second_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_1*.second_GD2_elt(block)*overlap/.overlap
                 else
                    GD2_cpr = coef_3*coef_2
                    coef_prod = GD2_cpr*.second_GD2_elt(block)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_3*coef_2*.second_GD2_elt(block)*overlap/.overlap
                 end
                 !!! save gradient information
                 .grad_info_tmp.coef_prod(1) = coef_prod
                 !!!
                 ! new
                 .grad_info_tmp.GD2_cpr(1) = GD2_cpr
                 .grad_info_tmp.GD2_cas(1).element = 2
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                 !!!
                 ! old
                 !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                 !!!
               !debug stdout.text(" ")
               !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
               !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                 i = i+1
              end
           end
        end
     end
     ! end 1D block - 2D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     !!! debug
!     stdout.text(" ")
!     stdout.text("Exit routine calc_2rdm_one_1_ortho_gen_grd")
!     stdout.text(" ")
!     stdout.flush
     !!!

   end
! de

   calc_2rdm_one_pauli_gen(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     j, m :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal_1, geminal_2 :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN
     t_1, t_2 :: REAL

     term = ZERO
     m = .n_1D_blocks+.n_2D_3typ_blocks

     if (.n_2D_3typ_blocks /= 0) then
     do b1=.n_1D_blocks+1,m
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2
        do b2=1,.n_1D_blocks
           geminal_2 = .nonzero_1ortho_ind(b2)
           if (geminal_2 == 0) cycle
           coef_1 = .bra_set.vec(geminal_2).coef(b2)
           if (NOT .bra_is_ket) then
              coef_2 = .ket_set.vec(geminal_2).coef(b2)
           end
           !!! davide
           term = ZERO
           !!!
           do j=3,5 ! geminal with SX, ISY or GD2 in block "block_1" are skipped
              geminal_1 = .block_types(block_1).element(j) 
              if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_1*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 else
                    coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 end
                 if (ng_2 > 0) then
                    .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_1))) then
                       red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_2.calc_overlap_integral(overlap,FALSE)
                       term(j) = coef_prod*overlap
                    end
                 else
                    term(j) = coef_prod
                 end
              end
           end

           t_1 = ZERO
           t_2 = ZERO
           if (abs(term(5)) > TOL(15)) then
              t_1 = term(5)*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)
              t_2 = term(5)*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)
           end

           if (abs(t_1+term(3)+term(4)) > TOL(15)) then
              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_1,b2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = (t_1+term(3)+term(4))/.overlap
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_1,b2,ind_1,b2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           end
           if (abs(t_2+term(3)+term(4)) > TOL(15)) then
              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_2,b2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = (t_2+term(3)+term(4))/.overlap
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_2,b2,ind_2,b2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           end
        end
     end
     end

     if (.n_2D_4typ_blocks /= 0) then
     do b1=m+1,.n_blocks
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2
        do b2=1,.n_1D_blocks
           geminal_2 = .nonzero_1ortho_ind(b2)
           if (geminal_2 == 0) cycle
           coef_1 = .bra_set.vec(geminal_2).coef(b2)
           if (NOT .bra_is_ket) then
              coef_2 = .ket_set.vec(geminal_2).coef(b2)
           end
           do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block_1" are skipped
              geminal_1 = .block_types(block_1).element(j) 
              if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_1*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 else
                    coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 end
                 if (ng_2 > 0) then
                    .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_1))) then
                       red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_2.calc_overlap_integral(overlap,FALSE)
                       term(j) = coef_prod*overlap
                    else
                       term(j) = ZERO
                    end
                 else
                    term(j) = coef_prod  
                 end  
              else
                 term(j) = ZERO
              end
           end
           if (abs(sum(term)) > TOL(15)) then

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_1,b2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = sum(term)/.overlap
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_2,b2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_1,b2,ind_1,b2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_2,b2,ind_2,b2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

           end
        end
     end
     end

     if (.n_2D_3typ_blocks >= 2) then
        .cas_3typ_3typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
     end
     if (.n_2D_3typ_blocks >= 1 AND .n_2D_4typ_blocks >= 1) then
        .cas_3typ_4typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
     end
     if (.n_2D_4typ_blocks >= 2) then
        .cas_4typ_4typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
     end

   end
! already mod.*
   calc_2rdm_one_pauli_gen_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     j, m :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal_1, geminal_2 :: INT
     ind_1, ind_2 :: INT
     coef_1, coef_2 :: REAL
     coef_prod :: REAL
     term :: VEC{REAL}(5)
     overlap :: REAL
     problem :: BIN
     t_1, t_2 :: REAL
     !!!
     tt :: VEC{INT}(5)
     cpr_saved :: REAL
     chk_gem :: VEC{BIN}(5)
     nb_terms :: INT
     !!!
     tt_gd2 :: VEC{INT}(1)
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_one_pauli_gen_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     term = ZERO
     m = .n_1D_blocks+.n_2D_3typ_blocks

     ! 2D (3typ) block - 1D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     if (.n_2D_3typ_blocks /= 0) then
     do b1=.n_1D_blocks+1,m
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2
        do b2=1,.n_1D_blocks
           geminal_2 = .nonzero_1ortho_ind(b2)
           if (geminal_2 == 0) cycle
           coef_1 = .bra_set.vec(geminal_2).coef(b2)
           if (NOT .bra_is_ket) then
              coef_2 = .ket_set.vec(geminal_2).coef(b2)
           end
           !!!
           nb_terms = 0
           !!!
           do j=3,5 ! geminal with SX, ISY or GD2 in block "block_1" are skipped
              geminal_1 = .block_types(block_1).element(j) 
              if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                 !!!
                 chk_gem(j) = TRUE
                 !!!
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_1*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 else
                    coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 end
                 if (ng_2 > 0) then
                    .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_1))) then
                       red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_2.calc_overlap_integral(overlap,FALSE)
                       term(j) = coef_prod*overlap
                    !!!
                    else
                       overlap = ZERO
                       term(j) = ZERO
                    !!!
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    term(j) = coef_prod
                 end
              !!!
              else
                 chk_gem(j) = FALSE
                 coef_prod = ZERO
                 overlap = ZERO
                 term(j) = ZERO
              end
              !!!
              .grad_info_tmp.coef_prod(j) = coef_prod
              .grad_info_tmp.red_ov(j) = overlap
              .grad_info_tmp.ex_gem(j).element(1) = geminal_1
              .grad_info_tmp.ex_gem(j).element(2) = geminal_2
              .grad_info_tmp.ex_blk(j).element(1) = b1
              .grad_info_tmp.ex_blk(j).element(2) = b2
              .grad_info_tmp.factor(j).element(1) = 2
              .grad_info_tmp.factor(j).element(2) = 2
              !!! this is to set "tt" and "nb_terms" that will be used
              !!! to save gradient information 
              if (chk_gem(j)) then
                 nb_terms = nb_terms + 1
                 tt(nb_terms) = j
              end
              !!!
           end

!           t_1 = ZERO
!           t_2 = ZERO
!           if (abs(term(5)) > TOL(15)) then
              t_1 = term(5)*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)
              t_2 = term(5)*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)
!           end

!!           if (abs(t_1+term(3)+term(4)) > TOL(15)) then
!           if (chk_gem(3) OR chk_gem(4) OR chk_gem(5)) then
!              !!! set "tt" and "nb_terms" that will be used to save gradient information
!              nb_terms = 0
!              if (chk_gem(3) AND chk_gem(4)) then
!                 tt(1) = 3
!                 tt(2) = 4
!                 nb_terms = 2
!              else if (chk_gem(3)) then
!                 tt(1) = 3
!                 nb_terms = 1
!              else if (chk_gem(4)) then
!                 tt(1) = 4
!                 nb_terms = 1
!              end
!              if (chk_gem(5)) then
!                 tt(nb_terms+1) = 5
!                 nb_terms = nb_terms + 1
!              end
!              cpr_saved = .grad_info_tmp.coef_prod(5) 
              !!!
           !!!
           if (nb_terms > 0) then
              cpr_saved = .grad_info_tmp.coef_prod(5) 
           !!!

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_1,b2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = (t_1+term(3)+term(4))/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(5) = cpr_saved*(.first_GD2_elt(block_1))**2
              !!!
              ! new
              if (chk_gem(5)) then
                 tt_gd2(1) = 5
                 .grad_info_tmp.GD2_cpr(5) = cpr_saved
                 .grad_info_tmp.GD2_blk(5).element = block_1
                 .grad_info_tmp.GD2_cas(5).element = 3
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              !!! save gradient information
              !!!
              ! new
              if (chk_gem(5)) then
                 .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              !!! save gradient information
              !!!
              ! new
              if (chk_gem(5)) then
                 .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_1,b2,ind_1,b2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              !!!
              ! new
              if (chk_gem(5)) then
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
!           end
!           if (abs(t_2+term(3)+term(4)) > TOL(15)) then
              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_2,b2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = (t_2+term(3)+term(4))/.overlap
              !!! save gradient information
              .grad_info_tmp.coef_prod(5) = cpr_saved*(.second_GD2_elt(block_1))**2
              !!!
              ! new
              if (chk_gem(5)) then
                 .grad_info_tmp.GD2_cas(5).element = 4
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              !!! save gradient information
              !!!
              ! new
              if (chk_gem(5)) then
                 .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              !!! save gradient information
              !!!
              ! new
              if (chk_gem(5)) then
                 .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_2,b2,ind_2,b2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              !!!
              ! new
              if (chk_gem(5)) then
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
              else
                 .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              end
              !!!
              ! old
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1
           end
!           end
        end
     end
     end
     ! end 2D (3typ) block - 1D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     ! 2D (4typ) block - 1D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     if (.n_2D_4typ_blocks /= 0) then
     do b1=m+1,.n_blocks
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2
        do b2=1,.n_1D_blocks
           geminal_2 = .nonzero_1ortho_ind(b2)
           if (geminal_2 == 0) cycle
           coef_1 = .bra_set.vec(geminal_2).coef(b2)
           if (NOT .bra_is_ket) then
              coef_2 = .ket_set.vec(geminal_2).coef(b2)
           end
           !!!
           nb_terms = 0
           !!!
           do j=1,4 ! geminal with ID2, SZ, SX or ISY in block "block_1" are skipped
              geminal_1 = .block_types(block_1).element(j) 
              if (geminal_1 /= 0 AND geminal_1 /= geminal_2) then
                 !!!
                 chk_gem(j) = TRUE
                 !!!
                 if (.bra_is_ket) then
                    coef_prod = coef_1*coef_1*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 else
                    coef_prod = coef_1*coef_2*.nonzero_coef_prod(geminal_1).element(block_1-.first_block+1)/TWO
                 end
                 if (ng_2 > 0) then
                    .prep_red_pbg_g(red_pbg_2, geminal_1, geminal_2, block_1, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= ng_1))) then
                       red_pbg_2.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_2.calc_overlap_integral(overlap,FALSE)
                       term(j) = coef_prod*overlap
                    else
                       !!!
                       overlap = ZERO
                       !!!
                       term(j) = ZERO
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    term(j) = coef_prod  
                 end  
              else
                 !!!
                 chk_gem(j) = FALSE
                 coef_prod = ZERO
                 overlap = ZERO
                 !!!
                 term(j) = ZERO
              end
              !!!
              .grad_info_tmp.coef_prod(j) = coef_prod
              .grad_info_tmp.red_ov(j) = overlap
              .grad_info_tmp.ex_gem(j).element(1) = geminal_1
              .grad_info_tmp.ex_gem(j).element(2) = geminal_2
              !.grad_info_tmp.ex_blk(j).element(1) = block_1
              .grad_info_tmp.ex_blk(j).element(1) = b1
              .grad_info_tmp.ex_blk(j).element(2) = b2
              .grad_info_tmp.factor(j).element(1) = 2
              .grad_info_tmp.factor(j).element(2) = 2
              !!! this is to set "tt" and "nb_terms" that will be used
              !!! to save gradient information 
              if (chk_gem(j)) then
                 nb_terms = nb_terms + 1
                 tt(nb_terms) = j
              end
              !!!
           end
!           if (abs(sum(term)) > TOL(15)) then
           !!!
           if (nb_terms > 0) then
           !!!

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_1,b2,ind_1 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = sum(term)/.overlap
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ 0,block_1,0,block_1 /)
              .rdm_2_ab(i).indices = (/ b2,ind_2,b2,ind_2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              .rdm_2_aa(i_a)=.rdm_2_ab(i)
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="aa", irdm=i_a, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", .rdm_2_aa(i_a).indices)
            !debug stdout.show("2-RDM alpha-alpha element value", .rdm_2_aa(i_a).coefficient) 
              .rdm_2_bb(i_b)=.rdm_2_ab(i)
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="bb", irdm=i_b, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", .rdm_2_bb(i_b).indices)
            !debug stdout.show("2-RDM beta-beta element value", .rdm_2_bb(i_b).coefficient) 
              i = i+1
              i_a = i_a+1
              i_b = i_b+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_1,b2,ind_1,b2 /)
              .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

              .rdm_2_ab(i).same_block = FALSE
              .rdm_2_ab(i).block_numbers = (/ block_1,0,block_1,0 /)
              .rdm_2_ab(i).indices = (/ ind_2,b2,ind_2,b2 /)
              .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
              .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
              !!! save gradient information
              .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt)
              !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=1, nt=nb_terms, terms=tt)
              !!!
            !debug stdout.text(" ")
            !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
            !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient) 
              i = i+1

           end
        end
     end
     end
     ! end 2D (4typ) block - 1D block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

     if (.n_2D_3typ_blocks >= 2) then
        !!!
        .cas_3typ_3typ_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
        !!!
        !.cas_3typ_3typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
     end
     if (.n_2D_3typ_blocks >= 1 AND .n_2D_4typ_blocks >= 1) then
        !!!
        .cas_3typ_4typ_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
        !!!
        !.cas_3typ_4typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
     end
     if (.n_2D_4typ_blocks >= 2) then
        !!!
        .cas_4typ_4typ_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
        !!!
        !.cas_4typ_4typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
     end

   end
! de

   cas_3typ_3typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     m :: INT
     j, r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2 :: REAL
     overlap :: REAL
     problem :: BIN

     do b1=.n_1D_blocks+1,m-1
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2

        do b2=b1+1,m
           block_2 = b2 - .n_1D_blocks
           ind_3 = .n_1D_blocks+2*(block_2-1)+1
           ind_4 = .n_1D_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2"          
           r=5
           if (.block_types(block_1).element(r) /= 0) then
              s=5
              if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                 geminal = .block_types(block_1).element(r)
                 if (.n_blocks > 2) then
                    .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                       red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_1.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                          coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                       else
                          coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                          coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                       end
                    end
                 end

                 if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                    .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_2)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                    .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*.second_GD2_elt(block_2)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                    .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*.first_GD2_elt(block_2)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                    .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_2)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                    .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_1)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                    .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_2)*.second_GD2_elt(block_1)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                    .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_2)*.first_GD2_elt(block_1)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                    .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_1)*overlap/.overlap
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1
                 end
              end
           end          

           ! case "i1 /= j1 and i2 /= j2"
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                      end

                      if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2"

           r=5
           if (.block_types(block_1).element(r) /= 0) then
              do s=3,4
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                       .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end 

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 s=5
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                       .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_2)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_2)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_2)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_2)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 = i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

        end
     end
   end
! already mod.*
   cas_3typ_3typ_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     m :: INT
     j, r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2 :: REAL
     overlap :: REAL
     problem :: BIN
     !!!
     coef_prod, cpr_saved :: REAL
     tt :: VEC{INT}(2)
     !!!
     tt_gd2 :: VEC{INT}(1)
     !!!
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine cas_3typ_3typ_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     ! 2D (3typ) block - 2D (3typ) block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     do b1=.n_1D_blocks+1,m-1
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2

        do b2=b1+1,m
           block_2 = b2 - .n_1D_blocks
           ind_3 = .n_1D_blocks+2*(block_2-1)+1
           ind_4 = .n_1D_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2"          
           r=5
           if (.block_types(block_1).element(r) /= 0) then
              s=5
              if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                 geminal = .block_types(block_1).element(r)
                 if (.n_blocks > 2) then
                    .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                       red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg_1.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                          coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                       else
                          coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                          coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                       end
                    end
                 end

                 if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                    !!!
                    .grad_info_tmp.red_ov(1) = overlap
                    .grad_info_tmp.ex_gem(1).element = geminal
                    .grad_info_tmp.ex_blk(1).element(1) = b1
                    .grad_info_tmp.ex_blk(1).element(2) = b2
                    !.grad_info_tmp.ex_blk(1).element(1) = block_1
                    !.grad_info_tmp.ex_blk(1).element(2) = block_2
                    .grad_info_tmp.factor(1).element = 1
                    tt(1) = 1
                    !!!

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                    !!!
                    coef_prod = coef_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_2)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_2)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    tt_gd2(1) = 1
                    .grad_info_tmp.GD2_cpr(1) = coef_1
                    .grad_info_tmp.GD2_blk(1).element(1) = block_1
                    .grad_info_tmp.GD2_blk(1).element(2) = block_2
                    .grad_info_tmp.GD2_cas(1).element = 1
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                    !!!
                    coef_prod = coef_1*.first_GD2_elt(block_1)*.second_GD2_elt(block_2)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*.second_GD2_elt(block_2)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cas(1).element(1) = 1
                    .grad_info_tmp.GD2_cas(1).element(2) = 2
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                    !!!
                    coef_prod = coef_1*.second_GD2_elt(block_1)*.first_GD2_elt(block_2)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*.first_GD2_elt(block_2)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cas(1).element(1) = 2
                    .grad_info_tmp.GD2_cas(1).element(2) = 1
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                    .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                    !!!
                    coef_prod = coef_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_2)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_2)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cas(1).element = 2
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                    !!!
                    coef_prod = coef_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_1)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_1)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cpr(1) = coef_2
                    .grad_info_tmp.GD2_cas(1).element = 1
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                    .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                    !!!
                    coef_prod = coef_2*.first_GD2_elt(block_2)*.second_GD2_elt(block_1)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_2)*.second_GD2_elt(block_1)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cas(1).element(1) = 2
                    .grad_info_tmp.GD2_cas(1).element(2) = 1
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                    !!!
                    coef_prod = coef_2*.second_GD2_elt(block_2)*.first_GD2_elt(block_1)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_2)*.first_GD2_elt(block_1)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cas(1).element(1) = 1
                    .grad_info_tmp.GD2_cas(1).element(2) = 2
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1

                    .rdm_2_ab(i).same_block = FALSE
                    .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                    .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                    .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                    !!!
                    coef_prod = coef_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_1)
                    .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                    !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_1)*overlap/.overlap
                    !!! save gradient information
                    .grad_info_tmp.coef_prod(1) = coef_prod
                    !!!
                    ! new
                    .grad_info_tmp.GD2_cas(1).element = 2
                    .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                    !!!
                    ! old
                    !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                    !!!
                  !debug stdout.text(" ")
                  !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                  !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                    i = i+1
                 end
              end
           end          

           ! case "i1 /= j1 and i2 /= j2"
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          !.grad_info_tmp.ex_gem(1).element(1) = geminal
                          !.grad_info_tmp.ex_gem(1).element(2) = geminal
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          !.grad_info_tmp.factor(1).element(1) = 1
                          !.grad_info_tmp.factor(1).element(2) = 1
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_1
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=1, nb=2, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2"

           r=5
           if (.block_types(block_1).element(r) /= 0) then
              do s=3,4
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                       !!!
                       .grad_info_tmp.red_ov(1) = overlap
                       .grad_info_tmp.ex_gem(1).element = geminal
                       !.grad_info_tmp.ex_blk(1).element(1) = block_1
                       !.grad_info_tmp.ex_blk(1).element(2) = block_2
                       .grad_info_tmp.ex_blk(1).element(1) = b1
                       .grad_info_tmp.ex_blk(1).element(2) = b2
                       .grad_info_tmp.factor(1).element = 1
                       tt(1) = 1
                       !!!

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                       !!!
                       coef_prod = coef_1*.first_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       tt_gd2(1) = 1
                       .grad_info_tmp.GD2_cpr(1) = coef_1
                       .grad_info_tmp.GD2_blk(1).element = block_1
                       .grad_info_tmp.GD2_cas(1).element = 1
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod 
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                       !!!
                       coef_prod = coef_1*.second_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_1
                       .grad_info_tmp.GD2_cas(1).element = 2
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod 
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_2*.first_GD2_elt(block_1)
                       cpr_saved = coef_prod
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       .grad_info_tmp.GD2_cpr(1) = coef_2
                       .grad_info_tmp.GD2_blk(1).element = block_1
                       .grad_info_tmp.GD2_cas(1).element = 1
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                       !!!
                       coef_prod = coef_2*.second_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_1
                       .grad_info_tmp.GD2_cas(1).element = 2
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -cpr_saved
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = cpr_saved
                          !!!
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_1
                       .grad_info_tmp.GD2_cas(1).element = 1
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod 
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = coef_prod 
                          !!!
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_1
                       .grad_info_tmp.GD2_cas(1).element = 2
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end 

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 s=5
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                       !!!
                       .grad_info_tmp.red_ov(1) = overlap
                       .grad_info_tmp.ex_gem(1).element = geminal
                       .grad_info_tmp.ex_blk(1).element(1) = b1
                       .grad_info_tmp.ex_blk(1).element(2) = b2
                       .grad_info_tmp.factor(1).element = 1
                       tt(1) = 1
                       !!!

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_1*.first_GD2_elt(block_2)
                       cpr_saved = coef_prod
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_2)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       tt_gd2(1) = 1
                       .grad_info_tmp.GD2_cpr(1) = coef_1
                       .grad_info_tmp.GD2_blk(1).element = block_2
                       .grad_info_tmp.GD2_cas(1).element = 1
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                       !!!
                       coef_prod = coef_1*.second_GD2_elt(block_2)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_2)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_2
                       .grad_info_tmp.GD2_cas(1).element = 2
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -cpr_saved
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = cpr_saved
                          !!!
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_2
                       .grad_info_tmp.GD2_cas(1).element = 1
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = coef_prod
                          !!!
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_2
                       .grad_info_tmp.GD2_cas(1).element = 2
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                       !!!
                       coef_prod = coef_2*.first_GD2_elt(block_2)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_2)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       .grad_info_tmp.GD2_cpr(1) = coef_2
                       .grad_info_tmp.GD2_blk(1).element = block_2
                       .grad_info_tmp.GD2_cas(1).element = 1
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                       !!!
                       coef_prod = coef_2*.second_GD2_elt(block_2)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_2)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod 
                       !!!
                       ! new
                       .grad_info_tmp.GD2_blk(1).element = block_2
                       .grad_info_tmp.GD2_cas(1).element = 2
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                       if (r == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod 
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                       !!! save gradient information
                       !!!
                       ! new
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, nt_gd2=1, gd2_terms=tt_gd2)
                       !!!
                       ! old
                       !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           !!!
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           !!!
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 /= j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 = i2 and j1 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1)

        end
     end
   end
! de

   cas_3typ_4typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     m :: INT
     j, r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2 :: REAL
     overlap :: REAL
     problem :: BIN

     do b1=.n_1D_blocks+1,m
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2

        do b2=m+1,.n_blocks
           block_2 = b2 - .n_1D_blocks
           ind_3 = .n_1D_blocks+2*(block_2-1)+1
           ind_4 = .n_1D_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2"          
           r=5
           if (.block_types(block_1).element(r) /= 0) then
              do s=1,2
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                       .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                       else
                          .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                       .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                       else
                          .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                       .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       else
                          .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       else
                          .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end         

           ! case "i1 /= j1 and i2 /= j2"
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2"

           r=5
           if (.block_types(block_1).element(r) /= 0) then
              do s=3,4
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                       .rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                       .rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                       end
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -coef_1*overlap/.overlap
                          else
                             .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -coef_2*overlap/.overlap
                          else
                             .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           ! case "i1 /= i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           ! case "i1 /= i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           ! case "i1 = i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

        end
     end
   end
! already mod.*
   cas_3typ_4typ_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     m :: INT
     j, r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2 :: REAL
     overlap :: REAL
     problem :: BIN
     !!!
     coef_prod, cpr_saved :: REAL
     tt :: VEC{INT}(2)
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine cas_3typ_4typ_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     ! 2D (3typ) block - 2D (4typ) block !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     do b1=.n_1D_blocks+1,m
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2

        do b2=m+1,.n_blocks
           block_2 = b2 - .n_1D_blocks
           ind_3 = .n_1D_blocks+2*(block_2-1)+1
           ind_4 = .n_1D_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
           r=5
           if (.block_types(block_1).element(r) /= 0) then
              do s=1,2
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                       !!!
                       .grad_info_tmp.red_ov(1) = overlap
                       .grad_info_tmp.ex_gem(1).element = geminal
                       .grad_info_tmp.ex_blk(1).element(1) = b1
                       .grad_info_tmp.ex_blk(1).element(2) = b2
                       .grad_info_tmp.factor(1).element = 1
                       tt(1) = 1
                       !!!

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_1*.first_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                       end
                       !!! save gradient information
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_1*.second_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                       end
                       !!! save gradient information
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_2*.first_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                       !!!
                       coef_prod = coef_2*.second_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_2*.first_GD2_elt(block_1)
                       !!!
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_prod*overlap/.overlap
                          !.rdm_2_ab(i).coefficient = -coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       else
                          .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                          !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       end
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                       !!!
                       coef_prod = coef_2*.second_GD2_elt(block_1)
                       !!!
                       if (s == 2) then
                          .rdm_2_ab(i).coefficient = -coef_prod*overlap/.overlap
                          !.rdm_2_ab(i).coefficient = -coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       else
                          .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                          !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       end
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end         

           ! case "i1 /= j1 and i2 /= j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_1
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2"

           r=5
           if (.block_types(block_1).element(r) /= 0) then
              do s=3,4
                 if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                    geminal = .block_types(block_1).element(r)
                    if (.n_blocks > 2) then
                       .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                       if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                          red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                          red_pbg_1.calc_overlap_integral(overlap,FALSE)
                          if (.bra_is_ket) then
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                          else
                             coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                             coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                          end
                       end
                    end

                    if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                       !!!
                       .grad_info_tmp.red_ov(1) = overlap
                       .grad_info_tmp.ex_gem(1).element = geminal
                       .grad_info_tmp.ex_blk(1).element(1) = b1
                       .grad_info_tmp.ex_blk(1).element(2) = b2
                       .grad_info_tmp.factor(1).element = 1
                       tt(1) = 1
                       !!!

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                       !!!
                       coef_prod = coef_1*.first_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.first_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                       !!! save gradient information
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                       !!!
                       coef_prod = coef_1*.second_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_1*.second_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                       .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                       end
                       !!! save gradient information
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                       !!!
                       coef_prod = coef_2*.first_GD2_elt(block_1)
                       cpr_saved = coef_prod
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.first_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                       !!!
                       coef_prod = coef_2*.second_GD2_elt(block_1)
                       .rdm_2_ab(i).coefficient = coef_prod*overlap/.overlap
                       !.rdm_2_ab(i).coefficient = coef_2*.second_GD2_elt(block_1)*overlap/.overlap
                       !!! save gradient information
                       .grad_info_tmp.coef_prod(1) = coef_prod
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -cpr_saved
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = cpr_saved
                          !!!
                       end
                       !!! save gradient information
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1

                       .rdm_2_ab(i).same_block = FALSE
                       .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                       .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                       .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                       if (s == 4) then
                          .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = -coef_prod
                          !!!
                       else
                          .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          !!!
                          .grad_info_tmp.coef_prod(1) = coef_prod
                          !!!
                       end
                       !!! save gradient information
                       .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                       !!!
                     !debug stdout.text(" ")
                     !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                     !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                       i = i+1
                    end
                 end
              end
           end

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          coef_prod = coef_1
                          .grad_info_tmp.coef_prod(1) = coef_prod
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -coef_1*overlap/.overlap
                             !!!
                             cpr_saved = -coef_1
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                             !!!
                             cpr_saved = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -cpr_saved
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = cpr_saved
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -coef_2*overlap/.overlap
                             !!!
                             coef_prod = -coef_2
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                             !!!
                             coef_prod = coef_2
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_i_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           ! case "i1 /= i2 and j1 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           ! case "i1 /= i2 and j1 /= j2" !!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_ii_jj_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           ! case "i1 = i2 and j1 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_aa(i_a),i_a,2,FALSE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_bb(i_b),i_b,3,FALSE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j_gen_grd(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)
           !.calc_2rdm_elt_i_j_gen(red_pbg_2,.rdm_2_ab(i),i,1,TRUE)

        end
     end
   end
! de

   cas_4typ_4typ(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     m :: INT
     j, r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2 :: REAL
     overlap :: REAL
     problem :: BIN

     do b1=m+1,.n_blocks-1
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2

        do b2=b1+1,.n_blocks
           block_2 = b2 - .n_1D_blocks
           ind_3 = .n_1D_blocks+2*(block_2-1)+1
           ind_4 = .n_1D_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2"          
           do r=1,2
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end          

           ! case "i1 /= j1 and i2 /= j2"
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2"

           do r=1,2
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end 

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 /= j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 = i2 and j1 = j2"

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

        end
     end
   end
! already mod.*
   cas_4typ_4typ_grd(i,i_a,i_b,ng_1,red_pbg_1,ng_2,red_pbg_2,m)
   !
     i, i_a, i_b :: INT
     ng_1, ng_2 :: INT
     red_pbg_1, red_pbg_2 :: PAULI_BLOCK_GEMINALS
     m :: INT
     j, r, s :: INT
     b1, b2 :: INT
     block_1, block_2 :: INT
     geminal :: INT
     ind_1, ind_2 :: INT
     ind_3, ind_4 :: INT
     coef_1, coef_2 :: REAL
     overlap :: REAL
     problem :: BIN
     !!!
     coef_prod, cpr_saved :: REAL
     tt :: VEC{INT}(2)
     !!! debug
!     stdout.text(" ")
!     stdout.text("Entering subroutine cas_4typ_4typ_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     do b1=m+1,.n_blocks-1
        block_1 = b1 - .n_1D_blocks
        ind_1 = .n_1D_blocks+2*(block_1-1)+1
        ind_2 = .n_1D_blocks+2*(block_1-1)+2

        do b2=b1+1,.n_blocks
           block_2 = b2 - .n_1D_blocks
           ind_3 = .n_1D_blocks+2*(block_2-1)+1
           ind_4 = .n_1D_blocks+2*(block_2-1)+2

           ! case "i1 = j1 and i2 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!
           do r=1,2
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_1
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end          

           ! case "i1 /= j1 and i2 /= j2" !!!!!!!!!!!!!!!!!!!!!!!!!!
         
           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_1
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
                          if (r /= s) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-3).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_2
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end     

           ! cases "i1 = j1 and i2 /= j2" + "i1 /= j1 and i2 = j2" !!!!!!!!!!!!!!!!!!!!!

           do r=1,2
              if (.block_types(block_1).element(r) /= 0) then
                 do s=3,4
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_1
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_1,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_3,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             coef_prod = -coef_1
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             coef_prod = coef_1
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_2,ind_4,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_4,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (r == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_1,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             coef_prod = -coef_2
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             coef_prod = coef_2
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_3,ind_2,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (s == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end 

           do r=3,4
              if (.block_types(block_1).element(r) /= 0) then
                 do s=1,2
                    if (.block_types(block_1).element(r) == .block_types(block_2).element(s)) then
                       geminal = .block_types(block_1).element(r)
                       if (.n_blocks > 2) then
                          .prep_red_pbg(red_pbg_1, geminal, block_1, block_2, problem)
                          if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals))) then
                             red_pbg_1.make_int_term_list(FALSE,FALSE,TRUE)
                             red_pbg_1.calc_overlap_integral(overlap,FALSE)
                             if (.bra_is_ket) then
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.bra_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.bra_set.vec(geminal).coef(b1)
                             else
                                coef_1 = .bra_set.vec(geminal).coef(b1)*.ket_set.vec(geminal).coef(b2)
                                coef_2 = .bra_set.vec(geminal).coef(b2)*.ket_set.vec(geminal).coef(b1)
                             end
                          end
                       end

                       if (((NOT problem) AND ((.first_block == 0) OR (.n_blocks-1 >= .n_geminals)))) then
                          !!!
                          .grad_info_tmp.red_ov(1) = overlap
                          .grad_info_tmp.ex_gem(1).element = geminal
                          .grad_info_tmp.ex_blk(1).element(1) = b1
                          .grad_info_tmp.ex_blk(1).element(2) = b2
                          .grad_info_tmp.factor(1).element = 1
                          tt(1) = 1
                          !!!

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
                          .rdm_2_ab(i).coefficient = coef_1*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_1
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_1,ind_2,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             coef_prod = -coef_1
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                             !!!
                             coef_prod = coef_1
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_3,ind_3 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_1
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_1
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_1,block_1,block_2,block_2 /)
                          .rdm_2_ab(i).indices = (/ ind_2,ind_1,ind_4,ind_4 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
                          .rdm_2_ab(i).coefficient = coef_2*overlap/.overlap
                          !!! save gradient information
                          .grad_info_tmp.coef_prod(1) = coef_2
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_3,ind_3,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_2
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_1,ind_2 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
                          if (s == 2) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-2).coefficient
                             !!!
                             coef_prod = -coef_2
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-2).coefficient
                             !!!
                             coef_prod = coef_2
                             .grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM alpha-beta element value", .rdm_2_ab(i).coefficient)
                          i = i+1

                          .rdm_2_ab(i).same_block = FALSE
                          .rdm_2_ab(i).block_numbers = (/ block_2,block_2,block_1,block_1 /)
                          .rdm_2_ab(i).indices = (/ ind_4,ind_4,ind_2,ind_1 /)
                          .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
                          if (r == 4) then
                             .rdm_2_ab(i).coefficient = -.rdm_2_ab(i-1).coefficient
                             !!!
                             .grad_info_tmp.coef_prod(1) = -coef_prod
                             !!!
                          else
                             .rdm_2_ab(i).coefficient = .rdm_2_ab(i-1).coefficient
                             !!!
                             !.grad_info_tmp.coef_prod(1) = coef_prod
                             !!!
                          end
                          !!! save gradient information
                          .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt)
                          !!!
                        !debug stdout.text(" ")
                        !debug stdout.show("2-RDM element indices (i1, j1, i2, j2)", .rdm_2_ab(i).indices)
                        !debug stdout.show("2-RDM element value", .rdm_2_ab(i).coefficient)
                          i = i+1
                       end
                    end
                 end
              end
           end

           ! case "i1 = i2 and j1 /= j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_i_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 = j2" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)
           
           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_j(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 /= i2 and j1 /= j2" !!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,FALSE,FALSE /)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,FALSE,TRUE /)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,TRUE,FALSE /)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,TRUE,TRUE /)
           .calc_2rdm_elt_ii_jj_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_ii_jj(red_pbg_2,.rdm_2_ab(i),i,1)

           ! case "i1 = i2 and j1 = j2" !!!!!!!!!!!!!!!!!!!!!

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_3,ind_1,ind_3 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_1,ind_4,ind_1,ind_4 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_3,ind_2,ind_3 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_1,block_2,block_1,block_2 /)
           .rdm_2_ab(i).indices = (/ ind_2,ind_4,ind_2,ind_4 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .rdm_2_aa(i_a)=.rdm_2_ab(i)
           .rdm_2_bb(i_b)=.rdm_2_ab(i)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_bb(i_b),i_b,3)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_aa(i_a),i_a,2)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_bb(i_b),i_b,3)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_1,ind_3,ind_1 /)
           .rdm_2_ab(i).subindices = (/ TRUE,TRUE,TRUE,TRUE /)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_3,ind_2,ind_3,ind_2 /)
           .rdm_2_ab(i).subindices = (/ TRUE,FALSE,TRUE,FALSE /)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_1,ind_4,ind_1 /)
           .rdm_2_ab(i).subindices = (/ FALSE,TRUE,FALSE,TRUE /)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

           .rdm_2_ab(i).same_block = FALSE
           .rdm_2_ab(i).block_numbers = (/ block_2,block_1,block_2,block_1 /)
           .rdm_2_ab(i).indices = (/ ind_4,ind_2,ind_4,ind_2 /)
           .rdm_2_ab(i).subindices = (/ FALSE,FALSE,FALSE,FALSE /)
           .calc_2rdm_elt_i_j_grd(red_pbg_2,.rdm_2_ab(i),i,1)
           !.calc_2rdm_elt_i_j(red_pbg_2,.rdm_2_ab(i),i,1)

        end
     end
   end
! de

   calc_2rdm_elt_i_jj_gen(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: REAL
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = ZERO
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_XY_DD_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_DD_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_DD_bb_gen(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term = (coef_1+coef_2)*overlap
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term = (coef_1+coef_2)
        end
     end

     if (abs(term) > TOL(15)) then
        if (two_rdm_elt.subindices(4)) then
           two_rdm_elt.coefficient = term*.first_GD2_elt(block_2)/.overlap
        else
           two_rdm_elt.coefficient = term*.second_GD2_elt(block_2)/.overlap
        end
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_i_jj_gen_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i :: INT
     n :: INT, IN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: REAL
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(1)
     !tt :: VEC{INT}(2)
     chk_gem :: BIN
     !!!
     !!!
     tt_gd2 :: VEC{INT}(1)
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_i_jj_gen_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = ZERO
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_XY_DD_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_DD_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_DD_bb_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
!     !!!
!     stdout.show("k =",k)
!     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end

!     if (abs(term) > TOL(15)) then
!     stdout.show("chk_gem =",chk_gem)
     if (chk_gem) then
        !!!
        .grad_info_tmp.red_ov(1) = overlap
        !.grad_info_tmp.red_ov(2) = overlap
        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
        !.grad_info_tmp.ex_gem(2).element = .grad_info_tmp.ex_gem(1).element
        .grad_info_tmp.ex_blk(1).element(1) = b1
        .grad_info_tmp.ex_blk(1).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        !.grad_info_tmp.ex_blk(2).element = .grad_info_tmp.ex_blk(1).element
        .grad_info_tmp.factor(1).element = 1
        .grad_info_tmp.all_pairs(1) = TRUE
        tt(1) = 1
        !tt(2) = 2
        !!!
        tt_gd2(1) = 1
        .grad_info_tmp.GD2_cpr(1) = coef_1+coef_2
        !!!
        if (two_rdm_elt.subindices(4)) then
           two_rdm_elt.coefficient = term*.first_GD2_elt(block_2)/.overlap
           !!!
           .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*.first_GD2_elt(block_2)
           !.grad_info_tmp.coef_prod(1) = coef_1*.first_GD2_elt(block_2)
           !.grad_info_tmp.coef_prod(2) = coef_2*.first_GD2_elt(block_2)
           !!!
           .grad_info_tmp.GD2_blk(1).element = block_2
           .grad_info_tmp.GD2_cas(1).element = 1
           !!!
        else
           two_rdm_elt.coefficient = term*.second_GD2_elt(block_2)/.overlap
           !!!
           .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*.second_GD2_elt(block_2)
           !.grad_info_tmp.coef_prod(1) = coef_1*.second_GD2_elt(block_2)
           !.grad_info_tmp.coef_prod(2) = coef_2*.second_GD2_elt(block_2)
           !!!
           .grad_info_tmp.GD2_blk(1).element = block_2
           .grad_info_tmp.GD2_cas(1).element = 2
           !!!
        end
        !!! save gradient information
        select case (n)
        case(1)
           ! new
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE, nt_gd2=1, gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
        case(2)
           ! new
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE, nt_gd2=1, gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
        case(3)
           ! new
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE, nt_gd2=1, gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
        case default
           stdout.text("Error in routine calc_2rdm_elt_i_jj_gen_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
        ! debug
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
        !
        i = i+1
     end

   end
! de

   calc_2rdm_elt_ii_j_gen(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: REAL
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = ZERO
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_DD_XY_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_XY_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_XY_bb_gen(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term = (coef_1+coef_2)*overlap
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term = (coef_1+coef_2)
        end
     end

     if (abs(term) > TOL(15)) then
        if (two_rdm_elt.subindices(3)) then
           two_rdm_elt.coefficient = term*.first_GD2_elt(block_1)/.overlap
        else
           two_rdm_elt.coefficient = term*.second_GD2_elt(block_1)/.overlap
        end
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_ii_j_gen_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i :: INT
     n :: INT, IN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: REAL
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(1)
     chk_gem :: BIN
     !!!
     !!!
     tt_gd2 :: VEC{INT}(1)
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_ii_j_gen_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = ZERO
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_DD_XY_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_XY_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_XY_bb_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
!     stdout.show("k =",k)
!     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end

!     if (abs(term) > TOL(15)) then
!     stdout.show("chk_gem =",chk_gem)
     if (chk_gem) then
        !!!
        .grad_info_tmp.red_ov(1) = overlap
        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
        .grad_info_tmp.ex_blk(1).element(1) = b1
        .grad_info_tmp.ex_blk(1).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(1).element = 1
        .grad_info_tmp.all_pairs(1) = TRUE
        tt(1) = 1
        !!!
        !!!
        tt_gd2(1) = 1
        .grad_info_tmp.GD2_cpr(1) = coef_1+coef_2
        !!!
        if (two_rdm_elt.subindices(3)) then
           two_rdm_elt.coefficient = term*.first_GD2_elt(block_1)/.overlap
           !!!
           .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*.first_GD2_elt(block_1)
           !!!
           !!!
           .grad_info_tmp.GD2_blk(1).element = block_1
           .grad_info_tmp.GD2_cas(1).element = 1
           !!!
        else
           two_rdm_elt.coefficient = term*.second_GD2_elt(block_1)/.overlap
           !!!
           .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*.second_GD2_elt(block_1)
           !!!
           !!!
           .grad_info_tmp.GD2_blk(1).element = block_1
           .grad_info_tmp.GD2_cas(1).element = 2
           !!!
        end
        !!! save gradient information
        select case (n)
        case(1)
           ! new
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE, nt_gd2=1, gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
        case(2)
           ! new
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE, nt_gd2=1, gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
        case(3)
           ! new
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE, nt_gd2=1, gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
        case default
           stdout.text("Error in routine calc_2rdm_elt_ii_j_gen_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
        ! debug
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
        i = i+1
     end

   end
! de

   calc_2rdm_elt_ii_jj_gen(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_GX_DD_ab_bb_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_GX_DD_aa_gen(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_GY_DD_ab_bb_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_GY_DD_aa_gen(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end


     if (abs(sum(term)) > TOL(15)) then
        if (two_rdm_elt.subindices(3)) then
           if (two_rdm_elt.subindices(4)) then
              two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)*.first_GD2_elt(block_2)/.overlap
           else
              two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)*.second_GD2_elt(block_2)/.overlap
           end
        else
           if (two_rdm_elt.subindices(4)) then
              two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)*.first_GD2_elt(block_2)/.overlap
           else
              two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)*.second_GD2_elt(block_2)/.overlap
           end
        end

        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_ii_jj_gen_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i :: INT
     n :: INT, IN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(2)
     chk_gem :: BIN
     prod_gd2 :: REAL
     nb_terms :: INT
     !!!
     !!!
     tt_gd2 :: VEC{INT}(2)
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_ii_jj_gen_grd")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_GX_DD_ab_bb_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_GX_DD_aa_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
!     stdout.show("k =",k)
!     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk_gem = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end
     !!!
!     stdout.show("chk_gem =",chk_gem)
     nb_terms = 0
     if (chk_gem) then
        tt(1) = 1
        nb_terms = 1
        !!!
        tt_gd2(1) = 1
        !!!
        .grad_info_tmp.red_ov(1) = overlap
        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
        .grad_info_tmp.ex_blk(1).element(1) = b1
        .grad_info_tmp.ex_blk(1).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(1).element = 1
        .grad_info_tmp.all_pairs(1) = TRUE
        !
        if (two_rdm_elt.subindices(3)) then
           if (two_rdm_elt.subindices(4)) then
              prod_gd2 = .first_GD2_elt(block_1)*.first_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)*.first_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(1).element(1) = block_1
              .grad_info_tmp.GD2_blk(1).element(2) = block_2
              .grad_info_tmp.GD2_cas(1).element = 1
              !!!
           else
              prod_gd2 = .first_GD2_elt(block_1)*.second_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)*.second_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(1).element(1) = block_1
              .grad_info_tmp.GD2_blk(1).element(2) = block_2
              .grad_info_tmp.GD2_cas(1).element(1) = 1
              .grad_info_tmp.GD2_cas(1).element(2) = 2
              !!!
           end
        else
           if (two_rdm_elt.subindices(4)) then
              prod_gd2 = .second_GD2_elt(block_1)*.first_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)*.first_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(1).element(1) = block_1
              .grad_info_tmp.GD2_blk(1).element(2) = block_2
              .grad_info_tmp.GD2_cas(1).element(1) = 2
              .grad_info_tmp.GD2_cas(1).element(2) = 1
              !!!
           else
              prod_gd2 = .second_GD2_elt(block_1)*.second_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)*.second_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(1).element(1) = block_1
              .grad_info_tmp.GD2_blk(1).element(2) = block_2
              .grad_info_tmp.GD2_cas(1).element = 2
              !!!
           end
        end
        .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*prod_gd2
        !!!
        .grad_info_tmp.GD2_cpr(1) = coef_1+coef_2
        !!!
     end
     !!!
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_GY_DD_ab_bb_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_GY_DD_aa_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
!     stdout.show("k =",k)
!     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              !!!
              !overlap = ZERO
              chk_gem = FALSE
              !!!
              term(k) = ZERO
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end


!     if (abs(sum(term)) > TOL(15)) then
     !!!
!     stdout.show("chk_gem =",chk_gem)
     if (chk_gem) then
        nb_terms = nb_terms+1
        tt(nb_terms) = nb_terms
        !!!
        tt_gd2(nb_terms) = nb_terms
        !!!
        .grad_info_tmp.red_ov(nb_terms) = overlap
        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
        !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
        !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
        .grad_info_tmp.factor(nb_terms).element = 1
        .grad_info_tmp.all_pairs(nb_terms) = TRUE
        !
        if (two_rdm_elt.subindices(3)) then
           if (two_rdm_elt.subindices(4)) then
              prod_gd2 = .first_GD2_elt(block_1)*.first_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)*.first_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(nb_terms).element(1) = block_1
              .grad_info_tmp.GD2_blk(nb_terms).element(2) = block_2
              .grad_info_tmp.GD2_cas(nb_terms).element = 1
              !!!
           else
              prod_gd2 = .first_GD2_elt(block_1)*.second_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)*.second_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(nb_terms).element(1) = block_1
              .grad_info_tmp.GD2_blk(nb_terms).element(2) = block_2
              .grad_info_tmp.GD2_cas(nb_terms).element(1) = 1
              .grad_info_tmp.GD2_cas(nb_terms).element(2) = 2
              !!!
           end
        else
           if (two_rdm_elt.subindices(4)) then
              prod_gd2 = .second_GD2_elt(block_1)*.first_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)*.first_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(nb_terms).element(1) = block_1
              .grad_info_tmp.GD2_blk(nb_terms).element(2) = block_2
              .grad_info_tmp.GD2_cas(nb_terms).element(1) = 2
              .grad_info_tmp.GD2_cas(nb_terms).element(2) = 1
              !!!
           else
              prod_gd2 = .second_GD2_elt(block_1)*.second_GD2_elt(block_2)
              !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)*.second_GD2_elt(block_2)/.overlap
              !!!
              .grad_info_tmp.GD2_blk(nb_terms).element(1) = block_1
              .grad_info_tmp.GD2_blk(nb_terms).element(2) = block_2
              .grad_info_tmp.GD2_cas(nb_terms).element = 2
              !!!
           end
        end
        .grad_info_tmp.coef_prod(nb_terms) = (coef_1+coef_2)*prod_gd2
        !!!
        .grad_info_tmp.GD2_cpr(nb_terms) = coef_1+coef_2
        !!!
     end
        ! debug
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
        !
!        i = i+1
!     end
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)*prod_gd2/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           ! new
           .save_2rdm_grad_info(rdm2_type="ab",irdm=i,nt=nb_terms,terms=tt,allpairs_arg=TRUE,nt_gd2=nb_terms,gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
        case(2)
           ! new
           .save_2rdm_grad_info(rdm2_type="aa",irdm=i,nt=nb_terms,terms=tt,allpairs_arg=TRUE,nt_gd2=nb_terms,gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
        case(3)
           ! new
           .save_2rdm_grad_info(rdm2_type="bb",irdm=i,nt=nb_terms,terms=tt,allpairs_arg=TRUE,nt_gd2=nb_terms,gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
        case default
           stdout.text("Error in routine calc_2rdm_elt_ii_jj_gen_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
        i = i+1
     end

   end
! de

   calc_2rdm_elt_i_j_gen(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(10)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     k = 0
     t = k
     term = ZERO
     if (n == 1) then
        .sum_set_info_XY_XY_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_XY_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_XY_bb_gen(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
           end
        else
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
     end

     k = 1
     j=5
     if (.block_types(block_1).element(j) /= 0) then
        geminal_1 = .block_types(block_1).element(j)
        s=5
        if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
           geminal_2 = .block_types(block_2).element(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(3)) then
                   if (two_rdm_elt.subindices(4)) then
                     term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)*overlap
                   else
                     term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)*overlap
                   end
                 else
                   if (two_rdm_elt.subindices(4)) then
                     term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)*overlap
                   else
                     term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)*overlap
                   end
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
              end
              k = k+1
              if (two_rdm_elt.subindices(3)) then
                if (two_rdm_elt.subindices(4)) then
                  term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)
                else
                  term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)
                end
              else
                if (two_rdm_elt.subindices(4)) then
                  term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)
                else
                  term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)
                end
              end
           end
        end
        do s=3,4
           if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
              geminal_2 = .block_types(block_2).element(s)
              if (.n_geminals > 2) then
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    if (two_rdm_elt.subindices(3)) then
                       term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*overlap
                    else
                       term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*overlap
                    end
                 end
              else
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2
                 else
                    term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2
                 end
              end
           end
        end
     end
     do j=3,4
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           s=5
           if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
              geminal_2 = .block_types(block_2).element(s)
              if (.n_geminals > 2) then
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    if (two_rdm_elt.subindices(4)) then
                       term(k) = coef_prod_1*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)*overlap
                    else
                       term(k) = coef_prod_1*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)*overlap
                    end
                 end
              else
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = coef_prod_1*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)
                 else
                    term(k) = coef_prod_1*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)
                 end
              end
           end
           do s=3,4
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 if (.n_geminals > 2) then
                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                       else
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                       end
                       k = k+1
                       term(k) = coef_prod_1*coef_prod_2*overlap
                    end
                 else
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2
                    !term(k) = coef_prod_1*coef_prod_2*overlap
                 end
              end
           end
        end
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_i_j_gen_grd(red_pbg,two_rdm_elt,i,n)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i :: INT
     n :: INT, IN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(10)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(10)
     nb_terms :: INT
     chk :: BIN
     !!!
     !!!
     tt_gd2 :: VEC{INT}(10)
     nb_terms_gd2 :: INT
     blk, cas :: VEC{INT}(2)
     cpr, cpr_tot :: REAL
     !!!
     if (.debug) then
        stdout.text(" ")
        stdout.text("Enter subroutine calc_2rdm_elt_i_j_gen_grd")
        stdout.show("irdm2 =",i)
        stdout.text(" ")
     end
     !!!

     block_1 = two_rdm_elt.block_numbers(3)
     b1 = block_1 + .n_1D_blocks
     block_2 = two_rdm_elt.block_numbers(4)
     b2 = block_2 + .n_1D_blocks
     k = 0
     t = k
     term = ZERO
     if (n == 1) then
        .sum_set_info_XY_XY_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_XY_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_XY_bb_gen(two_rdm_elt,k)
     end
     !!!
     nb_terms = 0
     chk = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)*overlap
           else
              term(k) = ZERO
              !!!
              chk = FALSE
              !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term(k) = (coef_1+coef_2)
        end
        !!!
!        if (abs(term(k)) > TOL(15)) then 
        if (chk) then
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
           !.grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
        end
        !!!
     end

     !!!
     chk = TRUE
     !!!
     !!!
     nb_terms_gd2 = 0
     !!!
     k = 1
     j=5
     if (.block_types(block_1).element(j) /= 0) then
        geminal_1 = .block_types(block_1).element(j)
        s=5
        if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
           geminal_2 = .block_types(block_2).element(s)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(3)) then
                   if (two_rdm_elt.subindices(4)) then
                     cpr_tot = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)
                     term(k) = cpr_tot*overlap
                     !term(k) = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)*overlap
                     !!!
                     cas = 3
                     !!!
                   else
                     cpr_tot = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)
                     term(k) = cpr_tot*overlap
                     !term(k) = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)*overlap
                     !!!
                     cas(1) = 3
                     cas(2) = 4
                     !!!
                   end
                 else
                   if (two_rdm_elt.subindices(4)) then
                     cpr_tot = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)
                     term(k) = cpr_tot*overlap
                     !term(k) = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)*overlap
                     !!!
                     cas(1) = 4
                     cas(2) = 3
                     !!!
                   else
                     cpr_tot = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)
                     term(k) = cpr_tot*overlap
                     !term(k) = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)*overlap
                     !!!
                     cas = 4
                     !!!
                   end
                 end
              !!!
              else
                 !term(k) = ZERO
                 chk = FALSE
              !!!
              end
           else
              !!!
              overlap = ONE
              !!!
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
              end
              k = k+1
              if (two_rdm_elt.subindices(3)) then
                if (two_rdm_elt.subindices(4)) then
                   cpr_tot = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)
                   term(k) = cpr_tot
                   !term(k) = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)
                   !!!
                   cas = 3 
                   !!!
                else
                   cpr_tot = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)
                   term(k) = cpr_tot
                   !term(k) = coef_prod_1*(.first_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)
                   !!!
                   cas(1) = 3
                   cas(2) = 4
                   !!!
                end
              else
                if (two_rdm_elt.subindices(4)) then
                   cpr_tot = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)
                   term(k) = cpr_tot
                   !term(k) = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.first_GD2_elt(block_2)**2)
                   !!!
                   cas(1) = 4
                   cas(2) = 3
                   !!!
                else
                   cpr_tot = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)
                   term(k) = cpr_tot
                   !term(k) = coef_prod_1*(.second_GD2_elt(block_1)**2)*coef_prod_2*(.second_GD2_elt(block_2)**2)
                   !!!
                   cas = 4
                   !!!
                end
              end
           end
           !!!
           blk(1) = block_1
           blk(2) = block_2
           cpr = coef_prod_1*coef_prod_2
           !!!
!           if (abs(term(k)) > TOL(15)) then 
           if (chk) then
              nb_terms = nb_terms+1
              tt(nb_terms) = nb_terms
              !!!
              nb_terms_gd2 = nb_terms_gd2+1
              tt_gd2(nb_terms_gd2) = nb_terms
              !!!
              .grad_info_tmp.red_ov(nb_terms) = overlap
              .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
              .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
              .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
              .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
              .grad_info_tmp.factor(nb_terms).element = 2
              .grad_info_tmp.all_pairs(nb_terms) = FALSE
              !
              .grad_info_tmp.coef_prod(nb_terms) = cpr_tot
              !.grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
              !!!
              .grad_info_tmp.GD2_cpr(nb_terms_gd2) = cpr
              .grad_info_tmp.GD2_blk(nb_terms_gd2).element = blk
              .grad_info_tmp.GD2_cas(nb_terms_gd2).element = cas
              !!!
           end
           !!!
        end
        do s=3,4
           !!!
           chk = TRUE
           !!!
           if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
              geminal_2 = .block_types(block_2).element(s)
              if (.n_geminals > 2) then
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    if (two_rdm_elt.subindices(3)) then
                       cpr_tot = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2
                       term(k) = cpr_tot*overlap
                       !term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*overlap
                       !!!
                       cas = 3
                       !!!
                    else
                       cpr_tot = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2
                       term(k) = cpr_tot*overlap
                       !term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*overlap
                       !!!
                       cas = 4
                       !!!
                    end
                 !!!
                 else
                    !term(k) = ZERO
                    chk = FALSE
                 !!!
                 end
              else
                 !!!
                 overlap = ONE
                 !!!
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(3)) then
                    cpr_tot = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2
                    term(k) = cpr_tot
                    !term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2
                    !!!
                    cas = 3
                    !!!
                 else
                    cpr_tot = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2
                    term(k) = cpr_tot
                    !term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2
                    !!!
                    cas = 4
                    !!!
                 end
              end
              !!!
              blk = block_1
              cpr = coef_prod_1*coef_prod_2
              !!!
              !!!
!              if (abs(term(k)) > TOL(15)) then 
              if (chk) then
                 nb_terms = nb_terms+1
                 tt(nb_terms) = nb_terms
                 !!!
                 nb_terms_gd2 = nb_terms_gd2+1
                 tt_gd2(nb_terms_gd2) = nb_terms
                 !!!
                 .grad_info_tmp.red_ov(nb_terms) = overlap
                 .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
                 .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
                 .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
                 .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
                 .grad_info_tmp.factor(nb_terms).element = 2
                 .grad_info_tmp.all_pairs(nb_terms) = FALSE
                 !
                 .grad_info_tmp.coef_prod(nb_terms) = cpr_tot
                 !.grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
                 !!!
                 .grad_info_tmp.GD2_cpr(nb_terms_gd2) = cpr
                 .grad_info_tmp.GD2_blk(nb_terms_gd2).element = blk
                 .grad_info_tmp.GD2_cas(nb_terms_gd2).element = cas
                 !!!
              end
              !!!
           end
        end
     end
     do j=3,4
        !!!
        chk = TRUE
        !!!
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           s=5
           if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
              geminal_2 = .block_types(block_2).element(s)
              if (.n_geminals > 2) then
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    if (two_rdm_elt.subindices(4)) then
                       cpr_tot = coef_prod_1*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)
                       term(k) = cpr_tot*overlap
                       !term(k) = coef_prod_1*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)*overlap
                       !!!
                       cas = 3
                       !!!
                    else
                       cpr_tot = coef_prod_1*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)
                       term(k) = cpr_tot*overlap
                       !term(k) = coef_prod_1*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)*overlap
                       !!!
                       cas = 4
                       !!!
                    end
                 !!!
                 else
                    !term(k) = ZERO
                    chk = FALSE
                 !!!
                 end
              else
                 !!!
                 overlap = ONE
                 !!!
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(4)) then
                    cpr_tot = coef_prod_1*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)
                    term(k) = cpr_tot
                    !term(k) = coef_prod_1*coef_prod_2*.first_GD2_elt(block_2)*.first_GD2_elt(block_2)
                    !!!
                    cas = 3
                    !!!
                 else
                    cpr_tot = coef_prod_1*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)
                    term(k) = cpr_tot
                    !term(k) = coef_prod_1*coef_prod_2*.second_GD2_elt(block_2)*.second_GD2_elt(block_2)
                    !!!
                    cas = 4
                    !!!
                 end
              end
              !!!
              blk = block_2
              cpr = coef_prod_1*coef_prod_2
              !!!
              !!!
!              if (abs(term(k)) > TOL(15)) then 
              if (chk) then
                 nb_terms = nb_terms+1
                 tt(nb_terms) = nb_terms
                 !!!
                 nb_terms_gd2 = nb_terms_gd2+1
                 tt_gd2(nb_terms_gd2) = nb_terms
                 !!!
                 .grad_info_tmp.red_ov(nb_terms) = overlap
                 .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
                 .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
                 .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
                 .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
                 .grad_info_tmp.factor(nb_terms).element = 2
                 .grad_info_tmp.all_pairs(nb_terms) = FALSE
                 !
                 .grad_info_tmp.coef_prod(nb_terms) = cpr_tot
                 !.grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
                 !!!
                 .grad_info_tmp.GD2_cpr(nb_terms_gd2) = cpr
                 .grad_info_tmp.GD2_blk(nb_terms_gd2).element = blk
                 .grad_info_tmp.GD2_cas(nb_terms_gd2).element = cas
                 !!!
              end
              !!!
           end
           do s=3,4
              !!!
              chk = TRUE
              !!!
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 if (.n_geminals > 2) then
                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                       else
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                       end
                       k = k+1
                       term(k) = coef_prod_1*coef_prod_2*overlap
                    !!!
                    else
                       !term(k) = ZERO
                       chk = FALSE
                    !!!
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2
                    !term(k) = coef_prod_1*coef_prod_2*overlap
                 end
                 !!!
!                 if (abs(term(k)) > TOL(15)) then 
                 if (chk) then
                    nb_terms = nb_terms+1
                    tt(nb_terms) = nb_terms
                    .grad_info_tmp.red_ov(nb_terms) = overlap
                    .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
                    .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
                    .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
                    .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
                    .grad_info_tmp.factor(nb_terms).element = 2
                    .grad_info_tmp.all_pairs(nb_terms) = FALSE
                    !
                    .grad_info_tmp.coef_prod(nb_terms) = coef_prod_1*coef_prod_2
                    !.grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
                 end
                 !!!
              end
           end
        end
     end

     !!!
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           ! new
           .save_2rdm_grad_info(rdm2_type="ab",irdm=i,nt=nb_terms,terms=tt,allpairs_arg=TRUE,nt_gd2=nb_terms_gd2,gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
        case(2)
           ! new
           .save_2rdm_grad_info(rdm2_type="aa",irdm=i,nt=nb_terms,terms=tt,allpairs_arg=TRUE,nt_gd2=nb_terms_gd2,gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
        case(3)
           ! new
           .save_2rdm_grad_info(rdm2_type="bb",irdm=i,nt=nb_terms,terms=tt,allpairs_arg=TRUE,nt_gd2=nb_terms_gd2,gd2_terms=tt_gd2)
           ! old
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
        case default
           stdout.text("Error in routine calc_2rdm_elt_i_j_gen_grd:")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
        !!! debug (new)
!        if (i == 41) then
!           stdout.show("nb_terms =",nb_terms) 
!           stdout.show("k =",k) 
!           stdout.show("terms =",term(1:k)) 
!           stdout.show("two_rdm_elt.coefficient =",two_rdm_elt.coefficient) 
!!           stop
!        end
        !!! end debug (new)
        !!!
        i = i+1
     end

!     if (abs(sum(term)) > TOL(15)) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
!        i = i+1
!     end

   end
! de

   sum_set_info_XY_DD_ab_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_DD_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(3) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(3)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_ab_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "GD2 and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(5)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "GD2 and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(5)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_XY_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and "ID2/SZ and SX/ISY" for the block of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     w = .block_types(b_i).element(5)
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GX_DD_ab_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and SX" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GX_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and SX" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GY_DD_ab_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GY_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_XY_ab_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combination "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_XY_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combination "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_XY_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combination "SX and ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(3) /= 0 AND .block_types(b_j).element(4) /= 0) then
        u = .block_types(b_j).element(3)
        v = .block_types(b_j).element(4)
     else
        return
     end
     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   calc_2rdm_elt_i_jj_gen(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     block_2 = two_rdm_elt.block_numbers(4)
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = (/ ZERO,ZERO /)

     k = 0

     if (typ3_after_typ4) then

        t = k
        if (n == 1 OR n == 3) then
           .sum_set_info_IZ_DD_ab_bb_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_IZ_DD_aa_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(4)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)
              end
           end
        end
       
        t = k
        if (n == 1) then
           .sum_set_info_XY_DD_ab_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_XY_DD_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_XY_DD_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(4)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)
              end
           end
        end

     else

        t = k
        if (n == 1) then
           .sum_set_info_XY_DD_ab(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_XY_DD_aa(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_XY_DD_bb(two_rdm_elt,k)
        end
        
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 term(k) = (coef_1+coef_2)*overlap
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)
           end
        end

     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_i_jj_gen_grd(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     subindices :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: REAL
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(1)
     chk_gem :: BIN
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_i_jj_gen_grd(rev_blk)")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     if (NOT typ3_after_typ4) then
        block_1 = two_rdm_elt.block_numbers(3)
        block_2 = two_rdm_elt.block_numbers(4)
     else
        block_1 = two_rdm_elt.block_numbers(4)
        block_2 = two_rdm_elt.block_numbers(3)
        two_rdm_elt.block_numbers(3) = block_1
        two_rdm_elt.block_numbers(4) = block_2
        subindices = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = two_rdm_elt.subindices(4)
        two_rdm_elt.subindices(4) = subindices
     end
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = ZERO
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_XY_DD_ab(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_DD_aa(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_DD_bb(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
!     stdout.show("k =",k)
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end

     if (typ3_after_typ4) then
        two_rdm_elt.block_numbers(3) = block_2
        two_rdm_elt.block_numbers(4) = block_1
        two_rdm_elt.subindices(4) = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = subindices 
     end

!     if (abs(term) > TOL(15)) then
!     stdout.show("chk_gem =",chk_gem)
     if (chk_gem) then
        !!!
        .grad_info_tmp.red_ov(1) = overlap
        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
        .grad_info_tmp.ex_blk(1).element(1) = b1
        .grad_info_tmp.ex_blk(1).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(1).element = 1
        .grad_info_tmp.all_pairs(1) = TRUE
        !
        tt(1) = 1
        !!!
        two_rdm_elt.coefficient = term/.overlap
        !!!
        .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=1, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_i_jj_gen_grd(rev_blk):")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
        i = i+1
     end

   end
! de

   calc_2rdm_elt_ii_j_gen(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     block_2 = two_rdm_elt.block_numbers(4)
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = (/ ZERO,ZERO /)

     k = 0

     if (typ3_after_typ4) then

        t = k
        if (n == 1) then
           .sum_set_info_DD_XY_ab(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_DD_XY_aa(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_DD_XY_bb(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 term(k) = (coef_1+coef_2)*overlap
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)
           end
        end

     else

        t = k
        if (n == 1) then
           .sum_set_info_DD_IZ_ab_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_DD_IZ_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_DD_IZ_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(3)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)
              end
           end
        end
     
        t = k
        if (n == 1) then
           .sum_set_info_DD_XY_ab_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_DD_XY_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_DD_XY_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(3)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)
              end
           end
        end

     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_ii_j_gen_grd(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     subindices :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(2)
     chk_gem :: BIN
     nb_terms :: INT
     prod_gd2 :: REAL
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_ii_j_gen_grd(rev_blk)")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     if (NOT typ3_after_typ4) then
        block_1 = two_rdm_elt.block_numbers(3)
        block_2 = two_rdm_elt.block_numbers(4)
     else
        block_1 = two_rdm_elt.block_numbers(4)
        block_2 = two_rdm_elt.block_numbers(3)
        two_rdm_elt.block_numbers(3) = block_1
        two_rdm_elt.block_numbers(4) = block_2
        subindices = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = two_rdm_elt.subindices(4)
        two_rdm_elt.subindices(4) = subindices
     end
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1) then
        .sum_set_info_DD_IZ_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_IZ_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_IZ_bb_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              !!!
              term(k) = (coef_1+coef_2)*overlap
              !!!
              !term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           !!!
           term(k) = (coef_1+coef_2)
           !!!
           !term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end
     !!!
!     stdout.show("chk_gem =",chk_gem)
     nb_terms = 0
     if (chk_gem) then
        tt(1) = 1
        nb_terms = 1
        .grad_info_tmp.red_ov(1) = overlap
        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
        .grad_info_tmp.ex_blk(1).element(1) = b1
        .grad_info_tmp.ex_blk(1).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(1).element = 1
        .grad_info_tmp.all_pairs(1) = TRUE
        !
        .grad_info_tmp.coef_prod(1) = coef_1+coef_2
!        if (two_rdm_elt.subindices(3)) then
!           prod_gd2 = .first_GD2_elt(block_1)
!           !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)/.overlap
!        else
!           prod_gd2 = .second_GD2_elt(block_1)
!           !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)/.overlap
!        end
!        .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*prod_gd2
     end
     !!!

     t = k
     if (n == 1) then
        .sum_set_info_DD_XY_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_DD_XY_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_DD_XY_bb_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              !!!
              term(k) = (coef_1+coef_2)*overlap
              !!!
              !term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           !!!
           term(k) = (coef_1+coef_2)
           !!!
           !term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end
     !!!
     if (chk_gem) then
        nb_terms = nb_terms+1
        tt(1) = nb_terms 
        .grad_info_tmp.red_ov(nb_terms) = overlap
        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(nb_terms).element = 1
        .grad_info_tmp.all_pairs(nb_terms) = TRUE
        !
        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
!        if (two_rdm_elt.subindices(3)) then
!           prod_gd2 = .first_GD2_elt(block_1)
!           !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)/.overlap
!        else
!           prod_gd2 = .second_GD2_elt(block_1)
!           !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)/.overlap
!        end
!        .grad_info_tmp.coef_prod(1) = (coef_1+coef_2)*prod_gd2
     end
     !!!

     if (typ3_after_typ4) then
        two_rdm_elt.block_numbers(3) = block_2
        two_rdm_elt.block_numbers(4) = block_1
        two_rdm_elt.subindices(4) = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = subindices 
     end

!     if (abs(sum(term)) > TOL(15)) then
     if (nb_terms > 0) then
        if (two_rdm_elt.subindices(3)) then
           prod_gd2 = .first_GD2_elt(block_1)
           !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)/.overlap
        else
           prod_gd2 = .second_GD2_elt(block_1)
           !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)/.overlap
        end
        two_rdm_elt.coefficient = sum(term)*prod_gd2/.overlap
        !!!
        .grad_info_tmp.coef_prod(1:nb_terms) = .grad_info_tmp.coef_prod(1:nb_terms)*prod_gd2
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_ii_j_gen_grd(rev_blk):")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
        i = i+1
     end

   end
! de

   calc_2rdm_elt_ii_jj_gen(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(4)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     block_2 = two_rdm_elt.block_numbers(4)
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = (/ ZERO,ZERO,ZERO,ZERO /)

     k = 0

     if (typ3_after_typ4) then

        t = k
        if (n == 1 OR n == 3) then
           .sum_set_info_IX_DD_ab_bb_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_IX_DD_aa_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(4)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)
              end
           end
        end
     
        t = k
        if (n == 1 OR n == 3) then
           .sum_set_info_IY_DD_ab_bb_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_IY_DD_aa_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(4)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)
              end
           end
        end
     
        t = k
        if (n == 1) then
           .sum_set_info_ZX_DD_ab_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_ZX_DD_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_ZX_DD_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(4)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)
              end
           end
        end
     
        t = k
        if (n == 1) then
           .sum_set_info_ZY_DD_ab_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_ZY_DD_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_ZY_DD_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(4)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(4)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_2)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_2)
              end
           end
        end

     else

        t = k
        if (n == 1 OR n == 3) then
           .sum_set_info_GX_DD_ab_bb(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_GX_DD_aa(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(3)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)
              end
           end
        end

        t = k
        if (n == 1 OR n == 3) then
           .sum_set_info_GY_DD_ab_bb(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_GY_DD_aa(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)*overlap
                 else
                    term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)*overlap
                 end
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              if (two_rdm_elt.subindices(3)) then
                 term(k) = (coef_1+coef_2)*.first_GD2_elt(block_1)
              else
                 term(k) = (coef_1+coef_2)*.second_GD2_elt(block_1)
              end
           end
        end
 
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_ii_jj_gen_grd(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     subindices :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(2)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(2)
     chk_gem :: BIN
     nb_terms :: INT
     prod_gd2 :: REAL
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_ii_jj_gen_grd(rev_blk)")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     if (NOT typ3_after_typ4) then
        block_1 = two_rdm_elt.block_numbers(3)
        block_2 = two_rdm_elt.block_numbers(4)
     else
        block_1 = two_rdm_elt.block_numbers(4)
        block_2 = two_rdm_elt.block_numbers(3)
        two_rdm_elt.block_numbers(3) = block_1
        two_rdm_elt.block_numbers(4) = block_2
        subindices = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = two_rdm_elt.subindices(4)
        two_rdm_elt.subindices(4) = subindices
     end
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = (/ ZERO,ZERO /)
     k = 0
     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_GX_DD_ab_bb_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_GX_DD_aa_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              !!!
              term(k) = (coef_1+coef_2)*overlap
              !!!
              !term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           !!!
           term(k) = (coef_1+coef_2)
           !!!
           !term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end
     !!!
!     stdout.show("chk_gem =",chk_gem)
     nb_terms = 0
     if (chk_gem) then
        tt(1) = 1
        nb_terms = 1
        .grad_info_tmp.red_ov(1) = overlap
        .grad_info_tmp.ex_gem(1).element(1) = geminal_1
        .grad_info_tmp.ex_gem(1).element(2) = geminal_2
        .grad_info_tmp.ex_blk(1).element(1) = b1
        .grad_info_tmp.ex_blk(1).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(1).element = 1
        .grad_info_tmp.all_pairs(1) = TRUE
        !
        .grad_info_tmp.coef_prod(1) = coef_1+coef_2
     end
     !!!

     t = k
     if (n == 1 OR n == 3) then
        .sum_set_info_GY_DD_ab_bb_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_GY_DD_aa_gen(two_rdm_elt,k)
     end
     !!!
     chk_gem = TRUE
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              !!!
              term(k) = (coef_1+coef_2)*overlap
              !!!
              !term = (coef_1+coef_2)*overlap
           !!!
           else
              !overlap = ZERO
              chk_gem = FALSE
           !!!
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           !!!
           term(k) = (coef_1+coef_2)
           !!!
           !term = (coef_1+coef_2)
        end
     !!!
     else
        chk_gem = FALSE
     !!!
     end
     !!!
     if (chk_gem) then
        nb_terms = nb_terms+1
        tt(1) = nb_terms 
        .grad_info_tmp.red_ov(nb_terms) = overlap
        .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
        .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
        .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
        .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
        !.grad_info_tmp.ex_blk(1).element(1) = block_1
        !.grad_info_tmp.ex_blk(1).element(2) = block_2
        .grad_info_tmp.factor(nb_terms).element = 1
        .grad_info_tmp.all_pairs(nb_terms) = TRUE
        !
        .grad_info_tmp.coef_prod(nb_terms) = coef_1+coef_2
     end

     if (typ3_after_typ4) then
        two_rdm_elt.block_numbers(3) = block_2
        two_rdm_elt.block_numbers(4) = block_1
        two_rdm_elt.subindices(4) = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = subindices 
     end

!     if (abs(sum(term)) > TOL(15)) then
     if (nb_terms > 0) then
        if (two_rdm_elt.subindices(3)) then
           prod_gd2 = .first_GD2_elt(block_1)
           !two_rdm_elt.coefficient = sum(term)*.first_GD2_elt(block_1)/.overlap
        else
           prod_gd2 = .second_GD2_elt(block_1)
           !two_rdm_elt.coefficient = sum(term)*.second_GD2_elt(block_1)/.overlap
        end
        !!!
        .grad_info_tmp.coef_prod(1:nb_terms) = .grad_info_tmp.coef_prod(1:nb_terms)*prod_gd2
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=1, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_ii_jj_gen_grd(rev_blk):")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!

!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
        i = i+1
     end

   end
! de

   calc_2rdm_elt_i_j_gen(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     subindices :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(14)
     overlap :: REAL
     problem :: BIN

     block_1 = two_rdm_elt.block_numbers(3)
     block_2 = two_rdm_elt.block_numbers(4)
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     term = ZERO

     k = 0

     if (typ3_after_typ4) then

        t = k
        if (n == 1) then
           .sum_set_info_IZXY_XY_ab(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_IZXY_XY_aa(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_IZXY_XY_bb(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 term(k) = (coef_1+coef_2)*overlap
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)
           end
        end


     else

        t = k
        if (n == 1 OR n == 2) then
           .sum_set_info_XY_IZ_ab_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_XY_IZ_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 term(k) = (coef_1+coef_2)*overlap
                 !term = (coef_1+coef_2)*overlap
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)
           end
        end
     
        t = k
        if (n == 1) then
           .sum_set_info_XY_XY_ab_gen(two_rdm_elt,k)
        else if (n == 2) then
           .sum_set_info_XY_XY_aa_gen(two_rdm_elt,k)
        else if (n == 3) then
           .sum_set_info_XY_XY_bb_gen(two_rdm_elt,k)
        end
        if (k /= t) then
           geminal_1 = two_rdm_elt.sum_info(k,1)
           geminal_2 = two_rdm_elt.sum_info(k,2)
           if (.n_geminals > 2) then
              .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
              if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                 red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                 red_pbg.calc_overlap_integral(overlap,FALSE)
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                    coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                    coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
                 end
                 coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
                 coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
                 term(k) = (coef_1+coef_2)*overlap
              end
           else
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              term(k) = (coef_1+coef_2)
           end
        end

     end

     if (typ3_after_typ4) then
        block_1 = two_rdm_elt.block_numbers(4)
        block_2 = two_rdm_elt.block_numbers(3)
        two_rdm_elt.block_numbers(3) = block_1
        two_rdm_elt.block_numbers(4) = block_2
        subindices = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = two_rdm_elt.subindices(4)
        two_rdm_elt.subindices(4) = subindices
        b1 = block_1 + .n_1D_blocks
        b2 = block_2 + .n_1D_blocks
     end

     k = 2
     j=5
     if (.block_types(block_1).element(j) /= 0) then
        geminal_1 = .block_types(block_1).element(j)
        do s=1,4
           if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
              geminal_2 = .block_types(block_2).element(s)
              if (.n_geminals > 2) then
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    if (two_rdm_elt.subindices(3)) then
                       term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*overlap
                    else
                       term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*overlap
                    end
                 end
              else
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2
                 else
                    term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2
                 end
              end
           end
        end
     end
     do j=3,4
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           do s=1,4
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 if (.n_geminals > 2) then
                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                       else
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                       end
                       k = k+1
                       term(k) = coef_prod_1*coef_prod_2*overlap
                    end
                 else
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2
                 end
              end
           end
        end
     end

     if (typ3_after_typ4) then
        two_rdm_elt.block_numbers(3) = block_2
        two_rdm_elt.block_numbers(4) = block_1
        two_rdm_elt.subindices(4) = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = subindices 
     end

     if (abs(sum(term)) > TOL(15)) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        if (n == 1) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
        else if (n == 2) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
        else if (n == 3) then
         !debug stdout.text(" ")
         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
        end
        i = i+1
     end

   end
! already mod.*
   calc_2rdm_elt_i_j_gen_grd(red_pbg,two_rdm_elt,i,n,typ3_after_typ4)
   !
     red_pbg :: PAULI_BLOCK_GEMINALS
     two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
     i, n :: INT
     typ3_after_typ4 :: BIN
     subindices :: BIN
     block_1, block_2 :: INT
     b1, b2 :: INT
     geminal_1, geminal_2 :: INT
     k, t :: INT
     j, s :: INT
     coef_1, coef_2 :: REAL
     coef_prod_1, coef_prod_2, coef_prod_3, coef_prod_4 :: REAL
     term :: VEC{REAL}(14)
     overlap :: REAL
     problem :: BIN
     !!!
     tt :: VEC{INT}(14)
     nb_terms :: INT
     !!!
!     stdout.text(" ")
!     stdout.text("Enter subroutine calc_2rdm_elt_i_j_gen_grd(rev_blk)")
!     stdout.show("i =",i)
!     stdout.text(" ")
     !!!

     if (NOT typ3_after_typ4) then
        block_1 = two_rdm_elt.block_numbers(3)
        block_2 = two_rdm_elt.block_numbers(4)
     else
        block_1 = two_rdm_elt.block_numbers(4)
        block_2 = two_rdm_elt.block_numbers(3)
        two_rdm_elt.block_numbers(3) = block_1
        two_rdm_elt.block_numbers(4) = block_2
        subindices = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = two_rdm_elt.subindices(4)
        two_rdm_elt.subindices(4) = subindices
     end
     b1 = block_1 + .n_1D_blocks
     b2 = block_2 + .n_1D_blocks

     k = 0
     t = k
     term = ZERO
     if (n == 1 OR n == 2) then
        .sum_set_info_XY_IZ_ab_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_IZ_bb_gen(two_rdm_elt,k)
     end
     !!!
     nb_terms = 0
     !!!
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              !!!
              term(k) = (coef_1+coef_2)*overlap
              !!!
              !term = (coef_1+coef_2)*overlap
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           !!!
           term(k) = (coef_1+coef_2)
           !!!
           !term = (coef_1+coef_2)
        end
        !!!
        if (abs(term(k)) > TOL(15)) then 
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
        end
        !!!
     end

     t = k
     if (n == 1) then
        .sum_set_info_XY_XY_ab_gen(two_rdm_elt,k)
     else if (n == 2) then
        .sum_set_info_XY_XY_aa_gen(two_rdm_elt,k)
     else if (n == 3) then
        .sum_set_info_XY_XY_bb_gen(two_rdm_elt,k)
     end
     if (k /= t) then
        geminal_1 = two_rdm_elt.sum_info(k,1)
        geminal_2 = two_rdm_elt.sum_info(k,2)
        if (.n_geminals > 2) then
           .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
           if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
              red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
              red_pbg.calc_overlap_integral(overlap,FALSE)
              if (.bra_is_ket) then
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
              else
                 coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
                 coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
                 coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
                 coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
              end
              coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
              coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
              !!!
              term(k) = (coef_1+coef_2)*overlap
              !!!
              !term = (coef_1+coef_2)*overlap
           end
        else
           !!!
           overlap = ONE
           !!!
           if (.bra_is_ket) then
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.bra_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.bra_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b2)
           else
              coef_prod_1 = .bra_set.vec(geminal_1).coef(b2)*.ket_set.vec(geminal_1).coef(b1)
              coef_prod_2 = .bra_set.vec(geminal_2).coef(b1)*.ket_set.vec(geminal_2).coef(b2)
              coef_prod_3 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b1)
              coef_prod_4 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b2)                
           end
           coef_1 = coef_prod_1*coef_prod_2*two_rdm_elt.sum_info(k,3)
           coef_2 = coef_prod_3*coef_prod_4*two_rdm_elt.sum_info(k,4)
           !!!
           term(k) = (coef_1+coef_2)
           !!!
           !term = (coef_1+coef_2)
        end
        !!!
        if (abs(term(k)) > TOL(15)) then 
           nb_terms = nb_terms+1
           tt(nb_terms) = nb_terms
           .grad_info_tmp.red_ov(nb_terms) = overlap
           .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
           .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
           .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
           .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
           .grad_info_tmp.factor(nb_terms).element = 1
           .grad_info_tmp.all_pairs(nb_terms) = TRUE
           !
           .grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
        end
        !!!
     end

     k = 2
     !k = 1
     j=5
     if (.block_types(block_1).element(j) /= 0) then
        geminal_1 = .block_types(block_1).element(j)
        do s=1,4
           if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
              geminal_2 = .block_types(block_2).element(s)
              if (.n_geminals > 2) then
                 .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                 if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                    red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                    red_pbg.calc_overlap_integral(overlap,FALSE)
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    if (two_rdm_elt.subindices(3)) then
                       term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2*overlap
                    else
                       term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2*overlap
                    end
                 end
              else
                 !!!
                 overlap = ONE
                 !!!
                 if (.bra_is_ket) then
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                 else
                    coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                    coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                 end
                 k = k+1
                 if (two_rdm_elt.subindices(3)) then
                    term(k) = coef_prod_1*.first_GD2_elt(block_1)*.first_GD2_elt(block_1)*coef_prod_2
                 else
                    term(k) = coef_prod_1*.second_GD2_elt(block_1)*.second_GD2_elt(block_1)*coef_prod_2
                 end
              end
           end
           !!!
           if (abs(term(k)) > TOL(15)) then 
              nb_terms = nb_terms+1
              tt(nb_terms) = nb_terms
              .grad_info_tmp.red_ov(nb_terms) = overlap
              .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
              .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
              .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
              .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
              !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
              !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
              .grad_info_tmp.factor(nb_terms).element = 2
              .grad_info_tmp.all_pairs(nb_terms) = FALSE
              !
              .grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
           end
           !!!
        end
     end
     do j=3,4
        if (.block_types(block_1).element(j) /= 0) then
           geminal_1 = .block_types(block_1).element(j)
           do s=1,4
              if (.block_types(block_2).element(s) /= 0 AND .block_types(block_2).element(s) /= geminal_1) then
                 geminal_2 = .block_types(block_2).element(s)
                 if (.n_geminals > 2) then
                    .prep_red_pbg(red_pbg, geminal_1, geminal_2, block_1, block_2, problem)
                    if ((NOT problem) AND ((.first_block == 0) OR (.n_blocks >= .n_geminals))) then
                       red_pbg.make_int_term_list(FALSE,FALSE,TRUE)
                       red_pbg.calc_overlap_integral(overlap,FALSE)
                       if (.bra_is_ket) then
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                       else
                          coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                          coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                       end
                       k = k+1
                       term(k) = coef_prod_1*coef_prod_2*overlap
                    end
                 else
                    !!!
                    overlap = ONE
                    !!!
                    if (.bra_is_ket) then
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.bra_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.bra_set.vec(geminal_2).coef(b2)
                    else
                       coef_prod_1 = .bra_set.vec(geminal_1).coef(b1)*.ket_set.vec(geminal_1).coef(b1)
                       coef_prod_2 = .bra_set.vec(geminal_2).coef(b2)*.ket_set.vec(geminal_2).coef(b2)
                    end
                    k = k+1
                    term(k) = coef_prod_1*coef_prod_2*overlap
                 end
              end
              !!!
              if (abs(term(k)) > TOL(15)) then 
                 nb_terms = nb_terms+1
                 tt(nb_terms) = nb_terms
                 .grad_info_tmp.red_ov(nb_terms) = overlap
                 .grad_info_tmp.ex_gem(nb_terms).element(1) = geminal_1
                 .grad_info_tmp.ex_gem(nb_terms).element(2) = geminal_2
                 .grad_info_tmp.ex_blk(nb_terms).element(1) = b1
                 .grad_info_tmp.ex_blk(nb_terms).element(2) = b2
                 !.grad_info_tmp.ex_blk(nb_terms).element(1) = block_1
                 !.grad_info_tmp.ex_blk(nb_terms).element(2) = block_2
                 .grad_info_tmp.factor(nb_terms).element = 2
                 .grad_info_tmp.all_pairs(nb_terms) = FALSE
                 !
                 .grad_info_tmp.coef_prod(nb_terms) = term(k)/overlap
              end
              !!!
           end
        end
     end

     if (typ3_after_typ4) then
        two_rdm_elt.block_numbers(3) = block_2
        two_rdm_elt.block_numbers(4) = block_1
        two_rdm_elt.subindices(4) = two_rdm_elt.subindices(3)
        two_rdm_elt.subindices(3) = subindices 
     end

     !!!
     if (nb_terms > 0) then
        two_rdm_elt.coefficient = sum(term)/.overlap
        !!! save gradient information
        select case (n)
        case(1)
           .save_2rdm_grad_info(rdm2_type="ab", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="ab", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(2)
           .save_2rdm_grad_info(rdm2_type="aa", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="aa", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case(3)
           .save_2rdm_grad_info(rdm2_type="bb", irdm=i, nt=nb_terms, terms=tt, allpairs_arg=TRUE)
           !.save_2rdm_grad_info(rdm2_type="bb", irdm=i, ng=2, nb=2, nt=nb_terms, terms=tt)
        case default
           stdout.text("Error in routine calc_2rdm_elt_i_j_gen_grd(rev_blk):")
           stdout.text("unknown integer value to select the 2RDM part.")
           stop
        end
        !!!
        i = i+1
     end

!     if (abs(sum(term)) > TOL(15)) then
!        two_rdm_elt.coefficient = sum(term)/.overlap
!        if (n == 1) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-beta element value", two_rdm_elt.coefficient)
!        else if (n == 2) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM alpha-alpha element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM alpha-alpha element value", two_rdm_elt.coefficient)
!        else if (n == 3) then
!         !debug stdout.text(" ")
!         !debug stdout.show("2-RDM beta-beta element indices (i1, j1, i2, j2)", two_rdm_elt.indices)
!         !debug stdout.show("2-RDM beta-beta element value", two_rdm_elt.coefficient)
!        end
!        i = i+1
!     end

   end
! de

   sum_set_info_DD_IZ_ab_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combination "GD2 and SX/ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end

     w = .block_types(b_i).element(5)     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)


     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combination "GD2 and SX/ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end

     w = .block_types(b_i).element(5)     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)


     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_DD_IZ_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of j2
   ! and the combination "GD2 and SX/ISY" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end

     w = .block_types(b_i).element(5)     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)


     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_IZ_ab_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combination "ID2 and SZ" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_XY_IZ_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SX and ISY" for the block of j2
   ! and the combination "ID2 and SZ" for the blocks of i2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_j).element(1) /= 0 AND .block_types(b_j).element(2) /= 0) then
        u = .block_types(b_j).element(1)
        v = .block_types(b_j).element(2)
     else
        return
     end
     
     x = .block_types(b_i).element(3)
     y = .block_types(b_i).element(4)

     if ((u == x AND v == y) OR (u == y AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZ_DD_ab_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(2) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(2)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IZ_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SZ" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(2) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(2)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IX_DD_ab_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SX" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IX_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and SX" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IY_DD_ab_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_IY_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(1) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(1)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_ab_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "ID2 and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and SX" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZX_DD_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and SX" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZY_DD_ab_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end

   sum_set_info_ZY_DD_aa_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_ZY_DD_bb_gen(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "SZ and ISY" for the block of i2
   ! and "GD2 and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(2) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(2)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(5)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if (u == w AND v == y) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if (u == y AND v == w) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GX_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GX_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and SX" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(3) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(3)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,1,1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,1,1 /)
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ u,v,-1,-1 /)
        else
           i=i+1
           two_rdm_elt.sum_info(i,:)=(/ v,u,-1,-1 /)
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GY_DD_ab_bb(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w) OR (u == y AND v == z) OR (u == z AND v == y)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end


   sum_set_info_GY_DD_aa(two_rdm_elt,i)
   ! add the informations related to an i-th couple of geminals with associated signs
   ! to the set on which we sum on a reduced overlap during the computation of the 2RDM ;
   ! here the two geminals have the combination "GD2 and ISY" for the block of i2
   ! and "ID2/SZ and SX/ISY" for the block of j2
   two_rdm_elt :: PAULI_BLOCK_2RDM_ELT
   i :: INT
   b_i, b_j :: INT
   u, v, w, x, y, z :: INT
   
     b_i =two_rdm_elt.block_numbers(3)
     b_j =two_rdm_elt.block_numbers(4)

     if (.block_types(b_i).element(5) /= 0 AND .block_types(b_i).element(4) /= 0) then
        u = .block_types(b_i).element(5)
        v = .block_types(b_i).element(4)
     else
        return
     end
     
     w = .block_types(b_j).element(1)
     x = .block_types(b_j).element(3)
     y = .block_types(b_j).element(4)
     z = .block_types(b_j).element(2)

     if ((u == w AND v == x) OR (u == x AND v == w)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == w AND v == y) OR (u == x AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else if ((u == y AND v == w) OR (u == z AND v == x)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           end
        else
           if (two_rdm_elt.subindices(3) EQV two_rdm_elt.subindices(4)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           end
        end
     else if ((u == z AND v == y) OR (u == y AND v == z)) then
        if (u < v) then
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,1,-1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ u,v,-1,1 /)
           end
        else
           if (two_rdm_elt.subindices(3)) then
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,-1,1 /)
           else
              i=i+1
              two_rdm_elt.sum_info(i,:)=(/ v,u,1,-1 /)
           end
        end
     else
        return
     end
   !debug stdout.show("two_rdm_elt.sum_info(i,:)",two_rdm_elt.sum_info(i,:))

   end

end
