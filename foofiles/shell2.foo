!-------------------------------------------------------------------------------
!
! SHELL2 : pair of SHELLs
!
! Given two shells, can calculate
!  - Fourier transform of their product, evaluated on a grid
!  - overlap integrals
!  - kinetic energy integrals
!  - nuclear attraction integrals
!
! Based on the Rys method, as described by Lindh et al,
! J. Chem. Phys 84(7) 3963-3974
!
! - overlap (non rys version) and kinetic energy integrals work at least
!   up to (q|q).
! - methods using the rys module are limited up to about (m|m) due to
!   the general rys method algorithm failing.  (As tested with atoms on the
!   same center.  Different centers can go higher, but not recommended).
!
! Copyright (C) Daniel Grimwood, 1998
! Copyright (C) Dylan Jayatilaka 1998-2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module SHELL2

   implicit none

   ! List of cartesian powers for gaussian functions in a certain angular
   ! momentum range
!  nx, ny, nz :: VEC{INT}*, private  DEFAULT_NULL
!  gaussian_indices :: MAT{GAUSSIAN_INDICES}*, private  DEFAULT_NULL

   ! These are indexing arrays used for the horizontal recursion relation.
   ! They are set using the set_hrr_indexing_arrays routine.

!  l_max_hrr :: INT, private = -1
!  first_nonzero :: VEC{INT}*, private  DEFAULT_NULL
!  index_m1 :: VEC{INT}*, private  DEFAULT_NULL
!  index_p1 :: MAT{INT}*, private  DEFAULT_NULL

   pair_cutoff :: REAL, private = SHELL2_PAIR_CUTOFF

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      .a.nullify_ptr_part
      .b.nullify_ptr_part
      nullify(.exponent_sum)
      nullify(.exponent_inv)
    ! nullify(.a_exponent_inv)
    ! nullify(.b_exponent_inv)
      nullify(.contraction_prefactor)
      nullify(.contraction_s_prefactor)
      nullify(.contraction_p_prefactor)
      nullify(.pair_center)
      nullify(.center_diff)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      if (.destroy_all) then
         .a.destroy_ptr_part
         .b.destroy_ptr_part
         .exponent_sum.destroy
         .exponent_inv.destroy
         .contraction_prefactor.destroy
         .contraction_s_prefactor.destroy
         .contraction_p_prefactor.destroy
      else
         .a.nullify_ptr_part
         .b.nullify_ptr_part
         nullify(.exponent_sum)
         nullify(.exponent_inv)
         if (.same_center) then
            nullify(.contraction_prefactor)
            nullify(.contraction_s_prefactor)
            nullify(.contraction_p_prefactor)
         else
            .contraction_prefactor.destroy
            .contraction_s_prefactor.destroy
            .contraction_p_prefactor.destroy
         end
      end
      .pair_center.destroy
      .center_diff.destroy

   end

! Try to get rid of these ...

   create(shell_a,shell_b) ::: leaky
   ! Create a copy of a shell1 objects
      self :: PTR
      shell_a,shell_b :: SHELL1, IN

      .create
      .copy(shell_a,shell_b)

   end

   create(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Create a copy of a shell1 objects with positions
      self :: PTR
      shell_a,shell_b :: SHELL1, IN
      pos_a,pos_b :: VEC{REAL}(3), IN

      .create
      .copy(shell_a,shell_b,pos_a,pos_b)

   end

   create(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Create a copy of a shell1 objects with positions
      self :: PTR
      shell_a,shell_b :: SHELL, IN
      pos_a,pos_b :: VEC{REAL}(3), IN

      .create
      .copy(shell_a,shell_b,pos_a,pos_b)

   end

!  ====
!  Copy
!  ====

   create_copy(shell) ::: leaky
   ! Create a copy from "shell"
      self :: PTR
      shell :: SHELL2, IN
      .create
      .copy(shell)
      .precalculate
   end

   copy(shell) ::: leaky
   ! Make a copy from "shell"
      shell :: SHELL2, IN

      self = shell

      .nullify_ptr_part

      if (.destroy_all) then

        .a.copy(shell.a)
        .b.copy(shell.b)
        if (shell.exponent_sum.associated) &
           .exponent_sum.create_copy(shell.exponent_sum)
        if (shell.exponent_inv.associated) &
           .exponent_inv.create_copy(shell.exponent_inv)
        if (shell.contraction_prefactor.associated)   &
           .contraction_prefactor.create_copy(shell.contraction_prefactor)
        if (shell.contraction_s_prefactor.associated) &
           .contraction_s_prefactor.create_copy(shell.contraction_s_prefactor)
        if (shell.contraction_p_prefactor.associated) &
           .contraction_p_prefactor.create_copy(shell.contraction_p_prefactor)

      else

        .a = shell.a
        .b = shell.b
        if (shell.exponent_sum.associated) &
           .exponent_sum => shell.exponent_sum
        if (shell.exponent_inv.associated) &
           .exponent_inv => shell.exponent_inv
        if (.same_center) then
           if (shell.contraction_prefactor.associated)   &
              .contraction_prefactor => shell.contraction_prefactor
           if (shell.contraction_s_prefactor.associated) &
              .contraction_s_prefactor => shell.contraction_s_prefactor
           if (shell.contraction_p_prefactor.associated) &
              .contraction_p_prefactor => shell.contraction_p_prefactor
        else
           if (shell.contraction_prefactor.associated)   &
              .contraction_prefactor.create_copy(shell.contraction_prefactor)
           if (shell.contraction_s_prefactor.associated) &
              .contraction_s_prefactor.create_copy(shell.contraction_s_prefactor)
           if (shell.contraction_p_prefactor.associated) &
              .contraction_p_prefactor.create_copy(shell.contraction_p_prefactor)
        end
      end

      if (shell.pair_center.associated)  .pair_center.create_copy(shell.pair_center)
      if (shell.center_diff.associated)  .center_diff.create_copy(shell.center_diff)

   end

   copy(shell_a,shell_b) ::: leaky
   ! Copy the shell2 using shell1 objects
      shell_a,shell_b :: SHELL1, IN
      .a.copy(shell_a)
      .b.copy(shell_b)
      .precalculate
   end

   copy(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the shell2 using shell objects and positions
      shell_a,shell_b :: SHELL1, IN
      pos_a,pos_b :: VEC{REAL}, IN
      .a.copy(shell_a,pos_a)
      .b.copy(shell_b,pos_b)
      .precalculate
   end

   copy(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the shell2 using shell objects and positions
      shell_a,shell_b :: SHELL, IN
      pos_a,pos_b :: VEC{REAL}, IN
      .a.copy(shell_a,pos_a)
      .b.copy(shell_b,pos_b)
      .precalculate
   end

!  ===========
!  Set methods
!  ===========

   set_spherical(val)
   ! Set sphericals to "val" defaults
      val :: BIN
      .is_spherical = val
   end

   set_pair_cutoff(cutoff)
   ! Set the "cutoff" for the exponential prefactor for the product of two
   ! gaussian primitives, below which that primitive pair is isgnored in the
   ! calculation of the ERI's.
      cutoff :: REAL, IN
   ENSURE(cutoff>ZERO,"cutoff must be pisitive")
      if (FALSE) self = self
      pair_cutoff = cutoff
   end

   set_and_precompute_from(shellpr,pos_a,pos_b,same_center,skip) ::: leaky
   ! Set the a and b parts from "shellpr" but override the positions.
   ! "same_center" should be set TRUE if pos_a==pos_b.
   ! "skip" can be set TRUE if NOT same_center; it skips gaussian product
   ! pairs which are too small to worry about.
   ! NOTE: this does not create many pointer parts
      self :: OUT
      shellpr :: SHELL1PAIR, target, IN
      pos_a,pos_b :: VEC{REAL}, IN
      same_center,skip :: BIN, IN

      AB,At,P,b_pos_b, av :: VEC{REAL}(3)
      a,b,r2ab,b_r2ab,ab_inv,prefac, s,cp,cc :: REAL
      i,j,bg,ag :: INT

      ! Pointer assign
      .a = shellpr.a
      .b = shellpr.b

      ! Shells must be the same, necessary?
      .is_spherical = shellpr.a.is_spherical

      ! Overwrite positions
      .a.position = pos_a
      .b.position = pos_b

      ! Set coming in to save a pos test
      .same_center = same_center

      .n_gaussian_pairs = shellpr.n_gaussian_pairs

      .l_max = shellpr.l_max
      .l_min = shellpr.l_min
      .l_sum = shellpr.l_sum

      .first_gaussian = shellpr.first_gaussian
      .last_gaussian  = shellpr.last_gaussian
      .n_gaussian     = shellpr.n_gaussian

      ! Destroy only *some* pointer parts
      .destroy_all    = FALSE ! <--------

      ! Now make the gaussian-primitive-pair info ...

      ! Pointer assign
      .exponent_sum => shellpr.exponent_sum
      .exponent_inv => shellpr.exponent_inv

      .pair_center.create(3,.n_gaussian_pairs)
      .center_diff.create(3,.n_gaussian_pairs)

      if (NOT skip) then ! do all pairs

        if (same_center) then

           ! Pointer assign
           .contraction_prefactor => shellpr.contraction_prefactor

           i = 0
           do bg = 1,.b.n_cc
             do ag = 1,.a.n_cc
               i = i + 1
             ! .contraction_prefactor(i)  = shellpr.contraction_prefactor(i)
               .pair_center(:,i) = pos_a
               .center_diff(:,i) = ZERO
             end
           end

           .av_pair_center = pos_a

        else

           ! Create
           .contraction_prefactor.create(.n_gaussian_pairs)

           AB = pos_a - pos_b

           ! Want position of shell1 with higher angular momentum.
           if (.a.l > .b.l) then; At = pos_a
           else;                  At = pos_b
           end

           s    = ZERO
           av   = ZERO
           r2ab = dot_product(AB,AB)
           i    = 0

           do bg = 1,.b.n_cc

             b       = .b.exponent(bg)
             b_pos_b = b*pos_b
             b_r2ab  = b*r2ab

             do ag = 1,.a.n_cc

               i = i + 1

               a      = .a.exponent(ag)
               ab_inv = .exponent_inv(i)
               cp     = shellpr.contraction_prefactor(i)
               prefac = exp(-a*b_r2ab*ab_inv)

               .contraction_prefactor(i) = prefac*cp

               P                 = (b_pos_b + a*pos_a) * ab_inv
               .pair_center(:,i) = P         ! This can't this be precalculated
               .center_diff(:,i) = P - At    ! it could be compressed, below

               cc = cp/(ab_inv*sqrt(ab_inv))
               s  = s + cc
               av = P * cc

             end
           end

           .av_pair_center = av/s

        end

      else ! skip small pairs

        ! Create
        .contraction_prefactor.create(.n_gaussian_pairs)

        AB = pos_a-pos_b

        ! Want position of shell1 with higher angular momentum.
        if (.a.l > .b.l) then; At = pos_a
        else;                  At = pos_b
        end

        s    = ZERO
        av   = ZERO
        r2ab = dot_product(AB,AB)
        i    = 0
        j    = 0

        do bg = 1,.b.n_cc

          b       = .b.exponent(bg)
          b_pos_b = b*pos_b
          b_r2ab  = b*r2ab

          do ag = 1,.a.n_cc

            i = i + 1

            a      = .a.exponent(ag)
            ab_inv = .exponent_inv(i)
            prefac = exp(-a*b_r2ab*ab_inv)

            if (prefac<pair_cutoff) cycle ! skip

            j = j + 1

            cp                         = shellpr.contraction_prefactor(i)
            .contraction_prefactor(i)  = prefac*cp

            P                 = (b_pos_b + a*pos_a) * ab_inv
            .pair_center(:,j) = P
            .center_diff(:,j) = P - At

            cc = cp/(ab_inv*sqrt(ab_inv))
            s  = s + cc
            av = P * cc

          end
        end

        .av_pair_center = av/s

      end

    ! .kappa_max = maxval(.contraction_prefactor/.exponent_inv**(THREE/TWO))

   end

   precalculate ::: leaky
   ! Set up some commonly used intermediates
      anorm,bnorm :: VEC{REAL}*
      AB,At,P :: VEC{REAL}(3)
      b_cc,a,b,exp_sum,exp_inv,r2ab,b_r2ab,a_exp_inv :: REAL
      ag,bg,i :: INT

      .l_max = max(.a.l,.b.l)
      .l_min = min(.a.l,.b.l)
      .l_sum = .a.l + .b.l

      .first_gaussian = GAUSSIAN_DATA:n_comp_up_to(.l_max-1) + 1
      .last_gaussian  = GAUSSIAN_DATA:n_comp_up_to(.l_sum)
      .n_gaussian = .last_gaussian - .first_gaussian + 1

      .n_gaussian_pairs = .a.n_cc*.b.n_cc

      .destroy_all = TRUE

      .exponent_sum.create(.n_gaussian_pairs)
      .exponent_inv.create(.n_gaussian_pairs)
   ! .a_exponent_inv.create(.n_gaussian_pairs)
   ! .b_exponent_inv.create(.n_gaussian_pairs)

      .contraction_prefactor.create(.n_gaussian_pairs)
      .pair_center.create(3,.n_gaussian_pairs)
      .center_diff.create(3,.n_gaussian_pairs)

      anorm.create(.a.n_comp)
      bnorm.create(.b.n_comp)

      AB = .a.position-.b.position

      ! Want position of shell1 with higher angular momentum.
      if (.a.l > .b.l) then; At = .a.position
      else;                  At = .b.position
      end

      r2ab = dot_product(AB,AB)
      i = 0

      do bg = 1,.b.n_cc

         b      = .b.exponent(bg)
         b_r2ab = b * r2ab
         b_cc   = .b.contraction(bg)

         do ag = 1,.a.n_cc

            i = i + 1

            a       = .a.exponent(ag)
            exp_sum = a + b
            exp_inv = ONE/exp_sum
            P       = (b*.b.position + a*.a.position) * exp_inv

            .exponent_sum(i)   = exp_sum
            .exponent_inv(i)   = exp_inv
            a_exp_inv          = a*exp_inv
          ! .a_exponent_inv(i) = a_exp_inv
          ! .b_exponent_inv(i) = b*exp_inv
            .contraction_prefactor(i) = b_cc*.a.contraction(ag) &
                                      * exp_inv*sqrt(exp_inv)   &
                                      * exp(-b_r2ab*a_exp_inv)
            .pair_center(:,i)  = P
            .center_diff(:,i)  = P - At

         end
      end

   ! .kappa_max = maxval(.contraction_prefactor/.exponent_inv**(THREE/TWO))

   end

!  ===========================
!  Fourier transform integrals
!  ===========================

   skip_ft(cutoff) result (res) ::: PURE
   ! Whether the ft for this shell pair is too small.
      self :: IN
      cutoff :: REAL, IN
      res :: BIN

    ! R2 :: REAL
    ! AB :: VEC{REAL}(3)
      gamma,g1,e2,ex,ey,ez,e000x,e000y,e000z :: REAL
      a,b,t_max :: INT
      e :: MAT3{REAL}*
      G :: GAUSSIAN2

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      t_max = .a.l + .b.l
      e.create([0,t_max],[0,.a.l],[0,.b.l])
      e = ZERO

    ! AB = (.a.position-.b.position)
    ! R2 = dot_product(AB,AB)

      res = TRUE
      do a = 1, .a.n_cc

         G.set(ex_a=.a.exponent(a))

         do b = 1, .b.n_cc

            G.set(ex_b=.b.exponent(b))

            G.make_e_coeff(e,1);   ex=maxval(e); e000x = e(0,0,0)
            G.make_e_coeff(e,2);   ey=maxval(e); e000y = e(0,0,0)
            G.make_e_coeff(e,3);   ez=maxval(e); e000z = e(0,0,0)

            gamma = .a.exponent(a) + .b.exponent(b)
            g1 = ONE/gamma
    !       e2 = ex*ey*ez*(g1)**(THREE/TWO)*exp(-.a.exponent(a)*.b.exponent(b)*g1*R2)
            e2 = ex*ey*ez*g1*sqrt(g1)*e000x*e000y*e000z
            if (e2>cutoff) then
               res = FALSE
               e.destroy
               return
            end

         end

      end

      e.destroy

   end

   skip_ft(Pmax,cutoff) result (res) ::: PURE
   ! Whether the ft for this shell pair is too small.
      self :: IN
      Pmax,cutoff :: REAL, IN
      res :: BIN

    ! R2 :: REAL
    ! AB :: VEC{REAL}(3)

      fac,gamma,g1,e2,ex,ey,ez,e000x,e000y,e000z :: REAL
      a,b,t_max :: INT
      e :: MAT3{REAL}*
      G :: GAUSSIAN2

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      t_max = .a.l + .b.l
      e.create([0,t_max],[0,.a.l],[0,.b.l])
      e = ZERO

    ! AB = (.a.position-.b.position)
    ! R2 = dot_product(AB,AB)

      res = TRUE
      do a = 1, .a.n_cc

         G.set(ex_a=.a.exponent(a))
         fac=.a.contraction(a)*Pmax

         do b = 1, .b.n_cc

            G.set(ex_b=.b.exponent(b))

            G.make_e_coeff(e,1);   ex=maxval(e); e000x = e(0,0,0)
            G.make_e_coeff(e,2);   ey=maxval(e); e000y = e(0,0,0)
            G.make_e_coeff(e,3);   ez=maxval(e); e000z = e(0,0,0)

            gamma = .a.exponent(a) + .b.exponent(b)
            g1 = ONE/gamma
    !       e2 = ex*ey*ez*(g1)**(THREE/TWO)*exp(-.a.exponent(a)*.b.exponent(b)*g1*R2)
            e2 = ex*ey*ez*g1*sqrt(g1)*e000x*e000y*e000z

            if (e2*.b.contraction(b)*fac>cutoff) then
               res = FALSE
               e.destroy
               return
            end

         end

      end

      e.destroy

   end

! These versions do no thermal smearing or partitioning

   make_ft_static(res,k_pts) ::: PURE
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
    self :: IN
    res :: MAT3{CPX}, OUT
    k_pts :: MAT{REAL}, IN

    W :: MAT3{CPX}*
    i,k_max :: INT

      if (NOT .is_spherical) then

         .make_ft_c(res,k_pts)

      else if (.l_max<2) then

         .make_ft_c(res,k_pts)

      else

         k_max  = size(k_pts,1)
         W.create(k_max,.a.n_comp,.b.n_comp)

         .make_ft_c(W,k_pts)

         do i =1,k_max
            .change_to_spherical(W(i,:,:),res(i,:,:))
         end do

         W.destroy

      end

   end

   make_ft_c(res,k_pts) ::: PURE
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
      self :: IN
      res :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, IN

      .make_ft_c(res,k_pts(:,1),k_pts(:,2),k_pts(:,3))

   end

   make_ft_c(res,k_x,k_y,k_z) ::: PURE
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! This version has the gaussian2 stuff inlined and special cases optimised,
   ! it's pretty messy but much faster.
      self :: IN
      res :: MAT3{CPX}, OUT
      k_x,k_y,k_z :: VEC{REAL}, IN

      G :: GAUSSIAN2
      e :: MAT3{REAL}*
      r :: VEC{REAL}(3)
      prefac :: VEC{CPX}*
      k_x2  ,k_y2  ,k_z2   :: VEC{REAL}*
      ft_x  ,ft_y  ,ft_z   :: MAT3{CPX}*
      ft_x01,ft_y01,ft_z01 :: VEC{CPX}*
      ft_x10,ft_y10,ft_z10 :: VEC{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      k,k_max :: INT
      a,xa,ya,za,aa,fa,la :: INT
      b,xb,yb,zb,bb,fb,lb :: INT
      pifac,PI_on_gamma,gamma,g1,g4,dot1,dot2 :: REAL
      e00,ca,r2,fac :: REAL
      k1,k2,k3,P1,P2,P3 :: REAL
      Ex000,Ey000,Ez000 :: REAL
      Ex001,Ey001,Ez001 :: REAL
      Ex101,Ey101,Ez101 :: REAL
      Ex010,Ey010,Ez010 :: REAL
      Ex110,Ey110,Ez110 :: REAL
      Ex111,Ey111,Ez111 :: REAL
      Ex211,Ey211,Ez211 :: REAL
      Ex011,Ey011,Ez011 :: REAL
      g1_exa,ex_a :: REAL
      g1_exb,ex_b :: REAL

      k_max  = k_x.dim

      res = ZERO

      G.a.set(.a.l,.a.position,ZERO)
      G.b.set(.b.l,.b.position,ZERO)

      select case (.a.l)

        case (0)

          select case(.b.l)

            case (0)

              ! <S|S>
              r   = .a.position - .b.position
              r2  = dot_product(r,r)
              do a = 1, .a.n_cc
                ca = .a.contraction(a)
                ex_a = .a.exponent(a)
                do b = 1, .b.n_cc
                  ex_b = .b.exponent(b)
                  g1 = ONE/(ex_a+ex_b)
                  g4 = -QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*ex_a
                  g1_exb = g1*ex_b
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  e00 = exp(-ex_a*ex_b*r2*g1)
                  fac = pifac*e00 * ca * .b.contraction(b)
                  do k = 1, k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = g4 * (k1*k1+k2*k2+k3*k3)
                    res(k,1,1) = res(k,1,1) + fac * exp(COMPLEXIFY(dot2,dot1))
                  end
                end
              end

            case (1)

              ! <S|P>
              prefac.create(k_max)
              e.create([0,1],[0,0],[0,1])
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex101 = e(1,0,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey101 = e(1,0,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez101 = e(1,0,1)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  res(:,1,1) = res(:,1,1) + COMPLEXIFY(Ex001,Ex101*k_x)*Ey000*Ez000*prefac
                  res(:,1,2) = res(:,1,2) + COMPLEXIFY(Ey001,Ey101*k_y)*Ex000*Ez000*prefac
                  res(:,1,3) = res(:,1,3) + COMPLEXIFY(Ez001,Ez101*k_z)*Ex000*Ey000*prefac
                end
              end
              e.destroy
              prefac.destroy

            case default

              ! <S|X>
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx = GAUSSIAN_DATA::px(fb:lb)
              by = GAUSSIAN_DATA::py(fb:lb)
              bz = GAUSSIAN_DATA::pz(fb:lb)
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    res(:,1,b) = res(:,1,b) + ft_x(:,0,xb)*ft_y(:,0,yb)*ft_z(:,0,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_y.destroy
              ft_z.destroy
          end

        case (1)

          select case (.b.l)

            case (0)

              ! <P|S>
              prefac.create(k_max)
              e.create([0,1],[0,1],[0,0])
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex010 = e(0,1,0)
                  Ex110 = e(1,1,0)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey010 = e(0,1,0)
                  Ey110 = e(1,1,0)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez010 = e(0,1,0)
                  Ez110 = e(1,1,0)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  res(:,1,1) = res(:,1,1) + COMPLEXIFY(Ex010,Ex110*k_x)*Ey000*Ez000*prefac
                  res(:,2,1) = res(:,2,1) + COMPLEXIFY(Ey010,Ey110*k_y)*Ex000*Ez000*prefac
                  res(:,3,1) = res(:,3,1) + COMPLEXIFY(Ez010,Ez110*k_z)*Ex000*Ey000*prefac
                end
              end
              e.destroy
              prefac.destroy

            case (1)

              ! <P|P>
              ft_x.create([1,k_max],[0,1],[0,1])
              ft_y.create([1,k_max],[0,1],[0,1])
              ft_z.create([1,k_max],[0,1],[0,1])
              prefac.create(k_max)
              e.create([0,2],[0,1],[0,1])
              ft_x01.create(k_max)
              ft_x10.create(k_max)
              ft_y01.create(k_max)
              ft_y10.create(k_max)
              ft_z01.create(k_max)
              ft_z10.create(k_max)
              k_x2.create(k_max)
              k_y2.create(k_max)
              k_z2.create(k_max)
              k_x2=k_x*k_x
              k_y2=k_y*k_y
              k_z2=k_z*k_z
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex010 = e(0,1,0)
                  Ex011 = e(0,1,1)
                  Ex101 = e(1,0,1)
                  Ex110 = e(1,1,0)
                  Ex111 = e(1,1,1)
                  Ex211 = e(2,1,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey010 = e(0,1,0)
                  Ey011 = e(0,1,1)
                  Ey101 = e(1,0,1)
                  Ey110 = e(1,1,0)
                  Ey111 = e(1,1,1)
                  Ey211 = e(2,1,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez010 = e(0,1,0)
                  Ez011 = e(0,1,1)
                  Ez101 = e(1,0,1)
                  Ez110 = e(1,1,0)
                  Ez111 = e(1,1,1)
                  Ez211 = e(2,1,1)
                  ft_x01 = COMPLEXIFY(Ex001,Ex101*k_x)
                  ft_x10 = COMPLEXIFY(Ex010,Ex110*k_x)
                  ft_y01 = COMPLEXIFY(Ey001,Ey101*k_y)
                  ft_y10 = COMPLEXIFY(Ey010,Ey110*k_y)
                  ft_z01 = COMPLEXIFY(Ez001,Ez101*k_z)
                  ft_z10 = COMPLEXIFY(Ez010,Ez110*k_z)
                  res(:,1,1) = res(:,1,1) + COMPLEXIFY(Ex011-Ex211*k_x2,Ex111*k_x)*Ey000*Ez000*prefac
                  res(:,2,1) = res(:,2,1) + ft_x01*ft_y10* Ez000*prefac
                  res(:,3,1) = res(:,3,1) + ft_x01* Ey000*ft_z10*prefac
                  res(:,1,2) = res(:,1,2) + ft_x10*ft_y01* Ez000*prefac
                  res(:,2,2) = res(:,2,2) + COMPLEXIFY(Ey011-Ey211*k_y2,Ey111*k_y)*Ex000*Ez000*prefac
                  res(:,3,2) = res(:,3,2) +  Ex000*ft_y01*ft_z10*prefac
                  res(:,1,3) = res(:,1,3) + ft_x10* Ey000*ft_z01*prefac
                  res(:,2,3) = res(:,2,3) +  Ex000*ft_y10*ft_z01*prefac
                  res(:,3,3) = res(:,3,3) + COMPLEXIFY(Ez011-Ez211*k_z2,Ez111*k_z)*Ex000*Ey000*prefac
                end
              end
              k_z2.destroy
              k_y2.destroy
              k_x2.destroy
              ft_z10.destroy
              ft_z01.destroy
              ft_y10.destroy
              ft_y01.destroy
              ft_x10.destroy
              ft_x01.destroy
              e.destroy
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy

            case default

              ! <P|X>
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fb = .b.first_gaussian
              lb = .b.last_gaussian
              bx = GAUSSIAN_DATA::px(fb:lb)
              by = GAUSSIAN_DATA::py(fb:lb)
              bz = GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do b=0,.b.l
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac
                    ft_z(:,1,b) = ft_z(:,1,b) * prefac
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    res(:,1,b) = res(:,1,b) + ft_x(:,1,xb)*ft_y(:,0,yb)*ft_z(:,0,zb)
                    res(:,2,b) = res(:,2,b) + ft_x(:,0,xb)*ft_y(:,1,yb)*ft_z(:,0,zb)
                    res(:,3,b) = res(:,3,b) + ft_x(:,0,xb)*ft_y(:,0,yb)*ft_z(:,1,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
          end

        case default

          select case (.b.l)

            case (0)

              ! <X|S>
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fa = .a.first_gaussian
              la = .a.last_gaussian
              ax = GAUSSIAN_DATA::px(fa:la)
              ay = GAUSSIAN_DATA::py(fa:la)
              az = GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do a=0,.a.l
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res(:,a,1) = res(:,a,1) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy

            case (1)

              ! <X|P>
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax = GAUSSIAN_DATA::px(fa:la)
              ay = GAUSSIAN_DATA::py(fa:la)
              az = GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do a=0,.a.l ! incorporate prefac into ft_z
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac
                    ft_z(:,a,1) = ft_z(:,a,1) * prefac
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res(:,a,1) = res(:,a,1) + ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                    res(:,a,2) = res(:,a,2) + ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                    res(:,a,3) = res(:,a,3) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy

            case default

              ! <X|Y>
              ! This is the general routine.  It includes reduced multiplication,
              ! and use of pointers to minimise array finding.
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fa = .a.first_gaussian
              la = .a.last_gaussian
              fb = .b.first_gaussian
              lb = .b.last_gaussian
              ax = GAUSSIAN_DATA::px(fa:la)
              ay = GAUSSIAN_DATA::py(fa:la)
              az = GAUSSIAN_DATA::pz(fa:la)
              bx = GAUSSIAN_DATA::px(fb:lb)
              by = GAUSSIAN_DATA::py(fb:lb) 
              bz = GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  ! Incorporate prefac into ft_z
                  do b=0,.b.l 
                  do a=0,.a.l
                    ft_z(:,a,b) = ft_z(:,a,b) * prefac
                  end
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    do a = 1,.a.n_comp
                      xa = ax(a)
                      ya = ay(a)
                      za = az(a)
                      res(:,a,b) = res(:,a,b) + ft_x(:,xa,xb)*ft_y(:,ya,yb)*ft_z(:,za,zb)
                    end
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
          end

      end

   end

! This versions does only partitioning
! It is intended for single-atom partitions

   make_FT_parted(FT,k1,k2,k3,partition) ::: PURE
   ! Calculate the "FT[k_max,.a.n_comp,.b_n_comp]" for the two shells
   ! in "self" for series of k points (k1,k2,k3) partitioned with
   ! factors "partition" of dimension [k_max,.a.n_comp,.b.n_comp].
      self :: IN
      FT :: MAT3{CPX}, OUT
      k1,k2,k3 :: VEC{REAL}, IN
      partition :: MAT{REAL}, IN

      C,S :: MAT{CPX}*
      i :: INT

      if (NOT .is_spherical) then

         .make_FT_parted_c(FT,k1,k2,k3,partition)

      else if (.l_max<2) then

         .make_FT_parted_c(FT,k1,k2,k3,partition)

      else

         .make_FT_parted_c(FT,k1,k2,k3,partition)

         C.create(.a.n_comp,.b.n_comp)
         S.create(.a.n_comp,.b.n_comp)

         do i = 1,FT.dim1
            C = FT(i,:,:)
            .change_to_spherical(C,S)
            FT(i,:,:) = S
         end do

         S.destroy
         C.destroy

      end

   end

   make_FT_parted_c(res,k_x,k_y,k_z,partition) ::: PURE
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! This version has the gaussian2 stuff inlined and special cases optimised,
   ! it's pretty messy but much faster.
      self :: IN
      res :: MAT3{CPX}, OUT
      k_x,k_y,k_z :: VEC{REAL}, IN
      partition :: MAT{REAL}, IN

      G :: GAUSSIAN2
      e :: MAT3{REAL}*
      r :: VEC{REAL}(3)
      prefac :: VEC{CPX}*
      k_x2  ,k_y2  ,k_z2   :: VEC{REAL}*
      ft_x  ,ft_y  ,ft_z   :: MAT3{CPX}*
      ft_x01,ft_y01,ft_z01 :: VEC{CPX}*
      ft_x10,ft_y10,ft_z10 :: VEC{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      k,k_max :: INT
      a,xa,ya,za,aa,fa,la :: INT
      b,xb,yb,zb,bb,fb,lb :: INT
      pifac,PI_on_gamma,gamma,g1,g4,dot1,dot2 :: REAL
      e00,ca,r2,fac :: REAL
      k1,k2,k3,P1,P2,P3 :: REAL
      Ex000,Ey000,Ez000 :: REAL
      Ex001,Ey001,Ez001 :: REAL
      Ex101,Ey101,Ez101 :: REAL
      Ex010,Ey010,Ez010 :: REAL
      Ex110,Ey110,Ez110 :: REAL
      Ex111,Ey111,Ez111 :: REAL
      Ex211,Ey211,Ez211 :: REAL
      Ex011,Ey011,Ez011 :: REAL
      g1_exa,ex_a :: REAL
      g1_exb,ex_b :: REAL

      k_max  = k_x.dim

      res = ZERO

      G.a.set(.a.l,.a.position,ZERO)
      G.b.set(.b.l,.b.position,ZERO)

      select case (.a.l)

        case (0)

          select case(.b.l)

            case (0)

              ! <S|S>
              r   = .a.position - .b.position
              r2  = dot_product(r,r)
              do a = 1, .a.n_cc
                ca = .a.contraction(a)
                ex_a = .a.exponent(a)
                do b = 1, .b.n_cc
                  ex_b = .b.exponent(b)
                  g1 = ONE/(ex_a+ex_b)
                  g4 = -QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*ex_a
                  g1_exb = g1*ex_b
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  e00 = exp(-ex_a*ex_b*r2*g1)
                  fac = pifac*e00 * ca * .b.contraction(b) * partition(a,b)
                  do k = 1, k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = g4 * (k1*k1+k2*k2+k3*k3)
                    res(k,1,1) = res(k,1,1) + fac * exp(COMPLEXIFY(dot2,dot1))
                  end
                end
              end

            case (1)

              ! <S|P>
              prefac.create(k_max)
              e.create([0,1],[0,0],[0,1])
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex101 = e(1,0,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey101 = e(1,0,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez101 = e(1,0,1)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  res(:,1,1) = res(:,1,1) + COMPLEXIFY(Ex001,Ex101*k_x)*Ey000*Ez000*prefac
                  res(:,1,2) = res(:,1,2) + COMPLEXIFY(Ey001,Ey101*k_y)*Ex000*Ez000*prefac
                  res(:,1,3) = res(:,1,3) + COMPLEXIFY(Ez001,Ez101*k_z)*Ex000*Ey000*prefac
                end
              end
              e.destroy
              prefac.destroy

            case default

              ! <S|X>
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx = GAUSSIAN_DATA::px(fb:lb)
              by = GAUSSIAN_DATA::py(fb:lb)
              bz = GAUSSIAN_DATA::pz(fb:lb)
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    res(:,1,b) = res(:,1,b) + ft_x(:,0,xb)*ft_y(:,0,yb)*ft_z(:,0,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_y.destroy
              ft_z.destroy
          end

        case (1)

          select case (.b.l)

            case (0)

              ! <P|S>
              prefac.create(k_max)
              e.create([0,1],[0,1],[0,0])
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex010 = e(0,1,0)
                  Ex110 = e(1,1,0)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey010 = e(0,1,0)
                  Ey110 = e(1,1,0)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez010 = e(0,1,0)
                  Ez110 = e(1,1,0)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  res(:,1,1) = res(:,1,1) + COMPLEXIFY(Ex010,Ex110*k_x)*Ey000*Ez000*prefac
                  res(:,2,1) = res(:,2,1) + COMPLEXIFY(Ey010,Ey110*k_y)*Ex000*Ez000*prefac
                  res(:,3,1) = res(:,3,1) + COMPLEXIFY(Ez010,Ez110*k_z)*Ex000*Ey000*prefac
                end
              end
              e.destroy
              prefac.destroy

            case (1)

              ! <P|P>
              ft_x.create([1,k_max],[0,1],[0,1])
              ft_y.create([1,k_max],[0,1],[0,1])
              ft_z.create([1,k_max],[0,1],[0,1])
              prefac.create(k_max)
              e.create([0,2],[0,1],[0,1])
              ft_x01.create(k_max)
              ft_x10.create(k_max)
              ft_y01.create(k_max)
              ft_y10.create(k_max)
              ft_z01.create(k_max)
              ft_z10.create(k_max)
              k_x2.create(k_max)
              k_y2.create(k_max)
              k_z2.create(k_max)
              k_x2=k_x*k_x
              k_y2=k_y*k_y
              k_z2=k_z*k_z
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex010 = e(0,1,0)
                  Ex011 = e(0,1,1)
                  Ex101 = e(1,0,1)
                  Ex110 = e(1,1,0)
                  Ex111 = e(1,1,1)
                  Ex211 = e(2,1,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey010 = e(0,1,0)
                  Ey011 = e(0,1,1)
                  Ey101 = e(1,0,1)
                  Ey110 = e(1,1,0)
                  Ey111 = e(1,1,1)
                  Ey211 = e(2,1,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez010 = e(0,1,0)
                  Ez011 = e(0,1,1)
                  Ez101 = e(1,0,1)
                  Ez110 = e(1,1,0)
                  Ez111 = e(1,1,1)
                  Ez211 = e(2,1,1)
                  ft_x01 = COMPLEXIFY(Ex001,Ex101*k_x)
                  ft_x10 = COMPLEXIFY(Ex010,Ex110*k_x)
                  ft_y01 = COMPLEXIFY(Ey001,Ey101*k_y)
                  ft_y10 = COMPLEXIFY(Ey010,Ey110*k_y)
                  ft_z01 = COMPLEXIFY(Ez001,Ez101*k_z)
                  ft_z10 = COMPLEXIFY(Ez010,Ez110*k_z)
                  res(:,1,1) = res(:,1,1) + COMPLEXIFY(Ex011-Ex211*k_x2,Ex111*k_x)*Ey000*Ez000*prefac
                  res(:,2,1) = res(:,2,1) + ft_x01*ft_y10* Ez000*prefac
                  res(:,3,1) = res(:,3,1) + ft_x01* Ey000*ft_z10*prefac
                  res(:,1,2) = res(:,1,2) + ft_x10*ft_y01* Ez000*prefac
                  res(:,2,2) = res(:,2,2) + COMPLEXIFY(Ey011-Ey211*k_y2,Ey111*k_y)*Ex000*Ez000*prefac
                  res(:,3,2) = res(:,3,2) +  Ex000*ft_y01*ft_z10*prefac
                  res(:,1,3) = res(:,1,3) + ft_x10* Ey000*ft_z01*prefac
                  res(:,2,3) = res(:,2,3) +  Ex000*ft_y10*ft_z01*prefac
                  res(:,3,3) = res(:,3,3) + COMPLEXIFY(Ez011-Ez211*k_z2,Ez111*k_z)*Ex000*Ey000*prefac
                end
              end
              k_z2.destroy
              k_y2.destroy
              k_x2.destroy
              ft_z10.destroy
              ft_z01.destroy
              ft_y10.destroy
              ft_y01.destroy
              ft_x10.destroy
              ft_x01.destroy
              e.destroy
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy

            case default

              ! <P|X>
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fb = .b.first_gaussian
              lb = .b.last_gaussian
              bx = GAUSSIAN_DATA::px(fb:lb)
              by = GAUSSIAN_DATA::py(fb:lb)
              bz = GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do b=0,.b.l
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac
                    ft_z(:,1,b) = ft_z(:,1,b) * prefac
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    res(:,1,b) = res(:,1,b) + ft_x(:,1,xb)*ft_y(:,0,yb)*ft_z(:,0,zb)
                    res(:,2,b) = res(:,2,b) + ft_x(:,0,xb)*ft_y(:,1,yb)*ft_z(:,0,zb)
                    res(:,3,b) = res(:,3,b) + ft_x(:,0,xb)*ft_y(:,0,yb)*ft_z(:,1,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
          end

        case default

          select case (.b.l)

            case (0)

              ! <X|S>
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fa = .a.first_gaussian
              la = .a.last_gaussian
              ax = GAUSSIAN_DATA::px(fa:la)
              ay = GAUSSIAN_DATA::py(fa:la)
              az = GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do a=0,.a.l
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res(:,a,1) = res(:,a,1) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy

            case (1)

              ! <X|P>
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax = GAUSSIAN_DATA::px(fa:la)
              ay = GAUSSIAN_DATA::py(fa:la)
              az = GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  do a=0,.a.l ! incorporate prefac into ft_z
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac
                    ft_z(:,a,1) = ft_z(:,a,1) * prefac
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res(:,a,1) = res(:,a,1) + ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                    res(:,a,2) = res(:,a,2) + ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                    res(:,a,3) = res(:,a,3) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy

            case default

              ! <X|Y>
              ! This is the general routine.  It includes reduced multiplication,
              ! and use of pointers to minimise array finding.
              ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
              ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
              prefac.create(k_max)
              fa = .a.first_gaussian
              la = .a.last_gaussian
              fb = .b.first_gaussian
              lb = .b.last_gaussian
              ax = GAUSSIAN_DATA::px(fa:la)
              ay = GAUSSIAN_DATA::py(fa:la)
              az = GAUSSIAN_DATA::pz(fa:la)
              bx = GAUSSIAN_DATA::px(fb:lb)
              by = GAUSSIAN_DATA::py(fb:lb) 
              bz = GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(COMPLEXIFY(dot2,dot1))
                  end
                  ! Incorporate prefac into ft_z
                  do b=0,.b.l 
                  do a=0,.a.l
                    ft_z(:,a,b) = ft_z(:,a,b) * prefac
                  end
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    do a = 1,.a.n_comp
                      xa = ax(a)
                      ya = ay(a)
                      za = az(a)
                      res(:,a,b) = res(:,a,b) + ft_x(:,xa,xb)*ft_y(:,ya,yb)*ft_z(:,za,zb)
                    end
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
          end

      end

   end

! This versions does thermal smearing and partitioning
! It seems to be the main routine

   make_ft(res,k_pts,thermal,partition) ::: PURE
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
      self :: IN
      res :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, IN
      thermal :: MAT3{REAL}, IN
      partition :: MAT{REAL}, IN

      W :: MAT3{CPX}*
      i :: INT

    ! read_option :: BIN = TRUE
    ! option :: STR = "?"
    ! if (read_option) then
    !    stdin.read(option)
    !    stdout.show("Using FT routine ",option)
    !    read_option = FALSE
    ! end
    ! select case (option)
    ! case ("old "); .make_ft_old(res,k_pts,thermal,partition)
    ! case ("old2"); .make_ft_old2(res,k_pts,thermal,partition)
    ! case ("v0  "); .make_ft_v0(res,k_pts,thermal,partition)
    ! case ("v1  "); .make_ft_v1(res,k_pts,thermal,partition)
    ! case ("v2  "); .make_ft_v2(res,k_pts,thermal,partition)
    ! case ("v3  "); .make_ft_v3(res,k_pts,thermal,partition)
    ! case default;  UNKNOWN(option)
    ! end
    ! .make_ft_v3(res,k_pts,thermal,partition)

      if (NOT .is_spherical) then

         .make_ft_c(res,k_pts,thermal,partition)

      else if (.l_max<2) then

         .make_ft_c(res,k_pts,thermal,partition)

      else

         W.create(res.dim1,.a.n_comp,.b.n_comp)
         .make_ft_c(W,k_pts,thermal,partition)

         do i =1,res.dim1
            .change_to_spherical(W(i,:,:),res(i,:,:))
         end do

         W.destroy

      end

   end

   make_ft_c(res,k_pts,thermal,partition) ::: PURE
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This version has the gaussian2 stuff inlined and special cases
   ! optimised, it's pretty messy but much faster.
      self :: IN
      res :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, IN
      thermal :: MAT3{REAL}, IN
      partition :: MAT{REAL}, IN

      e :: MAT3{REAL}*
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      k_x,k_y,k_z,k_x2,k_y2,k_z2 :: VEC{REAL}@
      prefac,ft_x01,ft_x10,ft_y01,ft_y10,ft_z01,ft_z10 :: VEC{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      fac,pi32,g1,g2,g4,dot1,dot2,k1,k2,k3,P1,P2,P3,ex_a,ex_b :: REAL
      a,b,i,k,xa,ya,za,xb,yb,zb,aa,bb,k_max,fa,la,fb,lb :: INT
      Ex001,Ey001,Ez001,Ex101,Ey101,Ez101 :: REAL
      Ex010,Ey010,Ez010,Ex110,Ey110,Ez110,Ex111,Ey111,Ez111 :: REAL
      Ex211,Ey211,Ez211,Ex011,Ey011,Ez011 :: REAL
      AB1,AB2,AB3,PA1,PA2,PA3,PB1,PB2,PB3 :: REAL

      pi32 = sqrt(PI) * PI

      k_max = k_pts.dim1

      k_x = k_pts(:,1)
      k_y = k_pts(:,2)
      k_z = k_pts(:,3)

      PA1 = .a.position(1); PA2 = .a.position(2); PA3 = .a.position(3)
      PB1 = .b.position(1); PB2 = .b.position(2); PB3 = .b.position(3)
      AB1 = PA1 - PB1
      AB2 = PA2 - PB2
      AB3 = PA3 - PB3

      res = ZERO

      select case (.a.l)

      case (0)

         select case(.b.l)

         case (0) ! (l_a,l_b) = (0,0)

            i = 0

            do b = 1,.b.n_cc
            do a = 1,.a.n_cc

               i = i + 1

               g1 = .exponent_inv(i)
               g4 = -QUARTER*g1
               P1 = .pair_center(1,i)
               P2 = .pair_center(2,i)
               P3 = .pair_center(3,i)
               fac = pi32 * .contraction_prefactor(i) * partition(a,b)
               
               do k = 1, k_max
                  k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                  dot1 = k1*P1+k2*P2+k3*P3
                  dot2 = g4 * (k1*k1+k2*k2+k3*k3)
                  res(k,1,1) = res(k,1,1) + thermal(k,a,b) * (fac * exp(cmplx(dot2,dot1,kind=CPX_KIND)))
               end

            end
            end

         case (1) ! (l_a,l_b) = (0,1)

            prefac.create(k_max)
            e.create([0,1],[0,0],[0,1])

            i = 0

            do b = 1,.b.n_cc

               ex_b = .b.exponent(b)
               
               do a = 1,.a.n_cc
               
                  i = i + 1

                  ex_a = .a.exponent(a)
                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                  .make_e_coeff(e,AB1,ex_a,ex_b,g1,g2)
                  
                  Ex001 = e(0,0,1)
                  Ex101 = e(1,0,1)
                  
                  .make_e_coeff(e,AB2,ex_a,ex_b,g1,g2)
                  Ey001 = e(0,0,1)
                  Ey101 = e(1,0,1)
                  
                  .make_e_coeff(e,AB3,ex_a,ex_b,g1,g2)
                  Ez001 = e(0,0,1)
                  Ez101 = e(1,0,1)
                  
                  fac = pi32 * .contraction_prefactor(i) * partition(a,b)
                  
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))*thermal(k,a,b)
                  end
                  
                  res(:,1,1) = res(:,1,1) + cmplx(Ex001,Ex101*k_x,kind=CPX_KIND)*prefac
                  res(:,1,2) = res(:,1,2) + cmplx(Ey001,Ey101*k_y,kind=CPX_KIND)*prefac
                  res(:,1,3) = res(:,1,3) + cmplx(Ez001,Ez101*k_z,kind=CPX_KIND)*prefac
               
               end
            end

            e.destroy
            prefac.destroy

         case default ! (l_a,l_b) = (0,X)

            fb = .b.first_gaussian
            lb = .b.last_gaussian

            bx = GAUSSIAN_DATA::px(fb:lb)
            by = GAUSSIAN_DATA::py(fb:lb)
            bz = GAUSSIAN_DATA::pz(fb:lb)

            ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
            prefac.create(k_max)

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
              
               do aa = 1,.a.n_cc
              
                  ex_a = .a.exponent(aa)
                 
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                 
                  .make_ft_component(ft_x,AB1,ex_a,ex_b,g1,g2,k_x,k_max)
                  .make_ft_component(ft_y,AB2,ex_a,ex_b,g1,g2,k_y,k_max)
                  .make_ft_component(ft_z,AB3,ex_a,ex_b,g1,g2,k_z,k_max)
                 
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                 
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                 
                  do b=0,.b.l ! incorporate prefac into ft_z
                     ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                  end
                 
                  do b = 1,.b.n_comp
                     xb = bx(b)
                     yb = by(b)
                     zb = bz(b)
                     res(:,1,b) = res(:,1,b) + ft_x(:,0,xb)*ft_y(:,0,yb)*ft_z(:,0,zb)
                  end
              
               end
            end

            prefac.destroy
            ft_x.destroy
            ft_y.destroy
            ft_z.destroy

         end

      case (1)

         select case (.b.l)

         case (0) ! (l_a,l_b) = (1,0)

            prefac.create(k_max)
            e.create([0,1],[0,1],[0,0])

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
              
               do aa = 1,.a.n_cc
              
                  ex_a = .a.exponent(aa)
                  
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                  
                  .make_e_coeff(e,AB1,ex_a,ex_b,g1,g2)
                  Ex010 = e(0,1,0)
                  Ex110 = e(1,1,0)
                  
                  .make_e_coeff(e,AB2,ex_a,ex_b,g1,g2)
                  Ey010 = e(0,1,0)
                  Ey110 = e(1,1,0)
                  
                  .make_e_coeff(e,AB3,ex_a,ex_b,g1,g2)
                  Ez010 = e(0,1,0)
                  Ez110 = e(1,1,0)
                  
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                  
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                  
                  res(:,1,1) = res(:,1,1) + cmplx(Ex010,Ex110*k_x,kind=CPX_KIND)*prefac
                  res(:,2,1) = res(:,2,1) + cmplx(Ey010,Ey110*k_y,kind=CPX_KIND)*prefac
                  res(:,3,1) = res(:,3,1) + cmplx(Ez010,Ez110*k_z,kind=CPX_KIND)*prefac
              
               end
            end

            e.destroy
            prefac.destroy

         case (1) ! (l_a,l_b) = (1,1)

            ft_x.create([1,k_max],[0,1],[0,1])
            ft_y.create([1,k_max],[0,1],[0,1])
            ft_z.create([1,k_max],[0,1],[0,1])

            prefac.create(k_max)
            e.create([0,2],[0,1],[0,1])

            ft_x01.create(k_max); ft_y01.create(k_max); ft_z01.create(k_max)
            ft_x10.create(k_max); ft_y10.create(k_max); ft_z10.create(k_max)

            k_x2 = k_x*k_x
            k_y2 = k_y*k_y
            k_z2 = k_z*k_z

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
              
               do aa = 1,.a.n_cc
              
                  ex_a = .a.exponent(aa)
                 
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                 
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                 
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                 
                  .make_e_coeff(e,AB1,ex_a,ex_b,g1,g2)
                  Ex001 = e(0,0,1)
                  Ex010 = e(0,1,0)
                  Ex011 = e(0,1,1)
                  Ex101 = e(1,0,1)
                  Ex110 = e(1,1,0)
                  Ex111 = e(1,1,1)
                  Ex211 = e(2,1,1)
                 
                  .make_e_coeff(e,AB2,ex_a,ex_b,g1,g2)
                  Ey001 = e(0,0,1)
                  Ey010 = e(0,1,0)
                  Ey011 = e(0,1,1)
                  Ey101 = e(1,0,1)
                  Ey110 = e(1,1,0)
                  Ey111 = e(1,1,1)
                  Ey211 = e(2,1,1)
                 
                  .make_e_coeff(e,AB3,ex_a,ex_b,g1,g2)
                  Ez001 = e(0,0,1)
                  Ez010 = e(0,1,0)
                  Ez011 = e(0,1,1)
                  Ez101 = e(1,0,1)
                  Ez110 = e(1,1,0)
                  Ez111 = e(1,1,1)
                  Ez211 = e(2,1,1)
                 
                  ft_x01 = cmplx(Ex001,Ex101*k_x,kind=CPX_KIND)
                  ft_x10 = cmplx(Ex010,Ex110*k_x,kind=CPX_KIND)
                  ft_y01 = cmplx(Ey001,Ey101*k_y,kind=CPX_KIND)
                  ft_y10 = cmplx(Ey010,Ey110*k_y,kind=CPX_KIND)
                  ft_z01 = cmplx(Ez001,Ez101*k_z,kind=CPX_KIND)
                  ft_z10 = cmplx(Ez010,Ez110*k_z,kind=CPX_KIND)
                 
                  res(:,1,1) = res(:,1,1) + cmplx(Ex011-Ex211*k_x2,Ex111*k_x,kind=CPX_KIND)*prefac
                  res(:,2,2) = res(:,2,2) + cmplx(Ey011-Ey211*k_y2,Ey111*k_y,kind=CPX_KIND)*prefac
                  res(:,3,3) = res(:,3,3) + cmplx(Ez011-Ez211*k_z2,Ez111*k_z,kind=CPX_KIND)*prefac
                  res(:,2,1) = res(:,2,1) + ft_x01*ft_y10*prefac
                  res(:,1,2) = res(:,1,2) + ft_x10*ft_y01*prefac
                  res(:,3,1) = res(:,3,1) + ft_x01*ft_z10*prefac
                  res(:,1,3) = res(:,1,3) + ft_x10*ft_z01*prefac
                  res(:,3,2) = res(:,3,2) + ft_y01*ft_z10*prefac
                  res(:,2,3) = res(:,2,3) + ft_y10*ft_z01*prefac
              
               end
            end

            ft_z10.destroy; ft_z01.destroy; ft_y10.destroy
            ft_y01.destroy; ft_x10.destroy; ft_x01.destroy
            e.destroy; prefac.destroy
            ft_x.destroy; ft_z.destroy; ft_y.destroy

         case default ! (l_a,l_b) = (1,X)

            ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

            prefac.create(k_max)

            fb = .b.first_gaussian
            lb = .b.last_gaussian
            bx = GAUSSIAN_DATA::px(fb:lb)
            by = GAUSSIAN_DATA::py(fb:lb)
            bz = GAUSSIAN_DATA::pz(fb:lb)

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
               
               do aa = 1,.a.n_cc
               
                  ex_a = .a.exponent(aa)
                  
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                  
                  .make_ft_component(ft_x,AB1,ex_a,ex_b,g1,g2,k_x,k_max)
                  .make_ft_component(ft_y,AB2,ex_a,ex_b,g1,g2,k_y,k_max)
                  .make_ft_component(ft_z,AB3,ex_a,ex_b,g1,g2,k_z,k_max)
                  
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                  
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                  
                  do b=0,.b.l
                     ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                     ft_z(:,1,b) = ft_z(:,1,b) * prefac(:)
                  end
                  
                  do b = 1,.b.n_comp
                     xb = bx(b)
                     yb = by(b)
                     zb = bz(b)
                     res(:,1,b) = res(:,1,b) + ft_x(:,1,xb)*ft_y(:,0,yb)*ft_z(:,0,zb)
                     res(:,2,b) = res(:,2,b) + ft_x(:,0,xb)*ft_y(:,1,yb)*ft_z(:,0,zb)
                     res(:,3,b) = res(:,3,b) + ft_x(:,0,xb)*ft_y(:,0,yb)*ft_z(:,1,zb)
                  end
               
               end
            end

            prefac.destroy
            ft_x.destroy; ft_z.destroy; ft_y.destroy

         end

      case default

         select case (.b.l)

         case (0) ! (l_a,l_b) = (X,0)

            ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

            prefac.create(k_max)

            fa = .a.first_gaussian
            la = .a.last_gaussian
            ax = GAUSSIAN_DATA::px(fa:la)
            ay = GAUSSIAN_DATA::py(fa:la)
            az = GAUSSIAN_DATA::pz(fa:la)

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
              
               do aa = 1,.a.n_cc
              
                  ex_a = .a.exponent(aa)
                  
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                  
                  .make_ft_component(ft_x,AB1,ex_a,ex_b,g1,g2,k_x,k_max)
                  .make_ft_component(ft_y,AB2,ex_a,ex_b,g1,g2,k_y,k_max)
                  .make_ft_component(ft_z,AB3,ex_a,ex_b,g1,g2,k_z,k_max)
                  
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                  
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                  
                  do a=0,.a.l
                     ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                  end
                  
                  do a = 1,.a.n_comp
                     xa = ax(a)
                     ya = ay(a)
                     za = az(a)
                     res(:,a,1)  = res(:,a,1) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
                  end
              
               end
            end

            prefac.destroy
            ft_x.destroy; ft_z.destroy; ft_y.destroy

         case (1) ! (l_a,l_b) = (X,1)

            ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

            prefac.create(k_max)

            fa = .a.first_gaussian
            la = .a.last_gaussian
            ax = GAUSSIAN_DATA::px(fa:la)
            ay = GAUSSIAN_DATA::py(fa:la)
            az = GAUSSIAN_DATA::pz(fa:la)

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
               
               do aa = 1,.a.n_cc
               
                  ex_a = .a.exponent(aa)
                  
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                  
                  .make_ft_component(ft_x,AB1,ex_a,ex_b,g1,g2,k_x,k_max)
                  .make_ft_component(ft_y,AB2,ex_a,ex_b,g1,g2,k_y,k_max)
                  .make_ft_component(ft_z,AB3,ex_a,ex_b,g1,g2,k_z,k_max)
                  
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                  
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                  
                  do a=0,.a.l ! incorporate prefac into ft_z
                     ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                     ft_z(:,a,1) = ft_z(:,a,1) * prefac(:)
                  end
                  
                  do a = 1,.a.n_comp
                     xa = ax(a)
                     ya = ay(a)
                     za = az(a)
                     res(:,a,1) = res(:,a,1) + ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                     res(:,a,2) = res(:,a,2) + ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                     res(:,a,3) = res(:,a,3) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
                  end
               
               end
            end

            prefac.destroy
            ft_x.destroy; ft_z.destroy; ft_y.destroy

         case default ! (l_a,l_b) = (X,X)

            ! This is the general routine.

            ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
            ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

            prefac.create(k_max)

            fa = .a.first_gaussian; la = .a.last_gaussian
            fb = .b.first_gaussian; lb = .b.last_gaussian

            ax = GAUSSIAN_DATA::px(fa:la)
            ay = GAUSSIAN_DATA::py(fa:la)
            az = GAUSSIAN_DATA::pz(fa:la)
            bx = GAUSSIAN_DATA::px(fb:lb)
            by = GAUSSIAN_DATA::py(fb:lb)
            bz = GAUSSIAN_DATA::pz(fb:lb)

            i = 0

            do bb = 1,.b.n_cc

               ex_b = .b.exponent(bb)
               
               do aa = 1,.a.n_cc
               
                  ex_a = .a.exponent(aa)
                
                  i = i + 1

                  g1 = .exponent_inv(i)
                  g2 = HALF*g1
                  g4 = QUARTER*g1
                  P1 = .pair_center(1,i)
                  P2 = .pair_center(2,i)
                  P3 = .pair_center(3,i)
                
                  .make_ft_component(ft_x,AB1,ex_a,ex_b,g1,g2,k_x,k_max)
                  .make_ft_component(ft_y,AB2,ex_a,ex_b,g1,g2,k_y,k_max)
                  .make_ft_component(ft_z,AB3,ex_a,ex_b,g1,g2,k_z,k_max)
                
                  fac = pi32 * .contraction_prefactor(i) * partition(aa,bb)
                
                  do k = 1,k_max
                     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                     dot1 = k1*P1+k2*P2+k3*P3
                     dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                     prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * thermal(k,aa,bb)
                  end
                
                  do b=0,.b.l ! incorporate prefac into ft_z
                  do a=0,.a.l
                     ft_z(:,a,b) = ft_z(:,a,b) * prefac(:)
                  end
                  end
                
                  do b = 1,.b.n_comp
                     xb = bx(b)
                     yb = by(b)
                     zb = bz(b)
                     do a = 1,.a.n_comp
                        xa = ax(a)
                        ya = ay(a)
                        za = az(a)
                        res(:,a,b) = res(:,a,b) + ft_x(:,xa,xb)*ft_y(:,ya,yb)*ft_z(:,za,zb)
                     end
                  end

               end
            end

            prefac.destroy
            ft_x.destroy; ft_z.destroy; ft_y.destroy

         end

      end

   end

   make_e_coeff(e,R,ex_a,ex_b,g1,g2) ::: private, pure
   ! Return the McMurchie-Davidson "e" coefficients for atoms
   ! separated by distance "R". Assumes starting value e000 = ONE.
   ! For optimized code.
      self :: IN
      e :: MAT3{REAL}(0:,0:,0:), OUT
      R,ex_a,ex_b,g1,g2 :: REAL, IN

      t,a,b,ap,am,bp,bm,abp,ab,abm,l_a,l_b :: INT
      a1,b1 :: REAL

      e(0,0,0) = ONE
      if (.l_sum==0) return

      l_a = .a.l
      l_b = .b.l
      a1 = ex_a*g1*R
      b1 = ex_b*g1*R
      if (l_a>=1) then
         e(1,1,0) =  g2
         e(0,1,0) = -b1
      end
      if (l_b>=1) then
         e(1,0,1) =  g2
         e(0,0,1) =  a1
      end
      if (.l_sum==1) return

      ! Consider case b=0
      do a = 1,l_a-1
         ap = a + 1
         am = a - 1
         e(ap,ap,0) =  g2*e( a,a,0)
         e( a,ap,0) =  g2*e(am,a,0) - b1*e(a,a,0)
         e( 0,ap,0) = -b1*e( 0,a,0) +    e(1,a,0)
         do t = 1,am
            e(t,ap,0) = g2*e(t-1,a,0) - b1*e(t,a,0) + (t+1)*e(t+1,a,0)
         end
      end

      ! Consider case a=0
      do b = 1,l_b-1
         bp = b + 1
         bm = b - 1
         e(bp,0,bp) =  g2*e( b,0,b)
         e( b,0,bp) =  g2*e(bm,0,b) + a1*e(b,0,b)
         e( 0,0,bp) =  a1*e( 0,0,b) +    e(1,0,b)
         do t = 1,bm
            e(t,0,bp) = g2*e(t-1,0,b) + a1*e(t,0,b) + (t+1)*e(t+1,0,b)
         end
      end

      ! Now do the rest, a/=0 & b/=0
      do b = 1,l_b
         do a = 0,l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e(abp,ap,b) =  g2*e( ab,a,b)
            e( ab,ap,b) =  g2*e(abm,a,b) - b1*e(ab,a,b)
            e(  0,ap,b) = -b1*e(  0,a,b) +    e( 1,a,b)
            do t = 1,abm
               e(t,ap,b) = g2*e(t-1,a,b) - b1*e(t,a,b) + (t+1)*e(t+1,a,b)
            end
         end
      end

   end

   make_ft_component(res,R,ex_a,ex_b,g1,g2,k_pts,k_max) ::: private, PURE
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
   ! Used only in the default case
      self :: IN
      res  :: MAT3{CPX}(1:,0:,0:), OUT
      R,ex_a,ex_b,g1,g2 :: REAL, IN
      k_pts :: VEC{REAL}, IN
      k_max :: INT, IN

      e  :: MAT3{REAL}*
      kp :: MAT{REAL}*
      vr,vi :: VEC{REAL}*
      a,b,t,t_max :: INT

      ! Make the E coefficients
      e.create([0,.l_sum],[0,.a.l],[0,.b.l])
      .make_e_coeff(e,R,ex_a,ex_b,g1,g2)

      ! Define kp array containing powers k_pts(n)^t
      nullify(kp)
      if (.l_sum>0) then
         kp.create([1,k_max],[1,.l_sum])
         kp(:,1) = k_pts
         do t = 2,.l_sum
            kp(:,t) = kp(:,t-1)*k_pts
         end
         do t = 2,.l_sum
            if (mod(t,4)<=1) cycle
            kp(:,t) = -kp(:,t)
         end
      end

      ! Real, imaginary parts of answer: (vr,vi)
      vr.create(k_max)
      vi.create(k_max)

      do a = 0,.a.l
      do b = 0,.b.l

         t_max = a + b

         ! Real part
         vr = e(0,a,b)
         do t = 2,t_max,2
            vr = vr + e(t,a,b)*kp(:,t)
         end

         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a,b)*kp(:,t)
         end

         res(:,a,b) = cmplx(vr,vi,kind=CPX_KIND)

      end
      end

      vi.destroy; vr.destroy
      kp.destroy; e.destroy

   end

! These thermal smearing & partition routines were 
! extracted from molecule.xtal but they shoulld be here.

   thermal_smearing_correction(T,model,k_pts,ADP_a,ADP_b) ::: pure
   ! Makes the thermal smearing correction term "T" over the
   ! contraction coefficients for thermal smearing "model" and for
   ! "k_pts(1:k_max,1:3)" and given the ADPs from atom_a and atomn_b,
   ! respectively "ADP_a" and ADP_b". "T" shape is [k_max,.a.n_cc,.b.n_cc].
   ! See Jayatilaka & Grimwood (2001) Acta Cryst A 57 p76-86 sec 4.2.
      self :: IN
      T :: MAT3{REAL}, OUT
      model :: STR, IN
      k_pts :: MAT{REAL}, IN
      ADP_a,ADP_b :: MAT{REAL}(3,3), IN

      S :: VEC{REAL}(3)
      Uab :: MAT{REAL}(3,3)
      k_max,k :: INT
      separation,bondlength,Ta,Tb,g :: REAL
      diff :: VEC{REAL}(3)

      k_max = k_pts.dim1

      select case (trim(model))

      case (" ","none")

         T = ONE

      case ("coppens") 
      
         ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
         do k = 1,k_max
            S = k_pts(k,:)
            Ta = -HALF*dot_product(S,matmul(ADP_a,S))
            Tb = -HALF*dot_product(S,matmul(ADP_b,S))
            T(k,:,:) = HALF*(exp(Ta)+exp(Tb))
         end

      case ("stewart") 
      
         diff = .a.position - .b.position
         separation = diff.norm
         bondlength = 2.5

         g = HALF
         if (separation > bondlength) g = QUARTER

         ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4]
         Uab = -HALF * g * (ADP_a + ADP_b)

         do k = 1,k_max
            S = k_pts(k,:)
            Ta = dot_product(S,matmul(Uab,S))
            T(k,:,:) = exp(Ta)
         end

      case ("tanaka") 
      
         ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
         .make_tanaka_thermal_smearing(T,k_pts,ADP_a,ADP_b)

      end

   end

   make_partition_factors(p,model,ra,rb,is_zero) ::: PURE
   ! Make the partitition factors "p" over the contractions in a
   ! the shell "self" with atom centers which have repetition factors
   ! "ra" and "rb" and for a particular thermal "model".
   ! The dimension of "p" is [.a.n_cc,.b_n_cc].
   ! See Jayatilaka & Grimwood (2001) Acta Cryst A 57 p76-86 sec 4.3.
      self :: IN
      model :: STR, IN
      p :: MAT{REAL}, OUT
      ra,rb :: INT, IN
      is_zero :: BIN, optional, OUT

      fa,fb :: REAL

      if (present(is_zero)) then
         if (ra<1 AND rb<1) then
            is_zero = TRUE
            p = ZERO
            return
         else
            is_zero = FALSE
         end
      end

      if (ra<1) then; fa = ZERO
      else;           fa = ONE/ra
      end

      if (rb<1) then; fb = ZERO
      else;           fb = ONE/rb
      end

      select case (trim(model))
      case (" ","none"); p = ONE
      case ("mulliken"); p = HALF * (fa + fb)
      case ("gaussian"); .make_gaussian_partition(p,fa,fb)
      case ("tanaka  "); .make_gaussian_partition(p,fa,fb)
      end

   end

! There is a lot of dead code here.
! Leave it for testing/optimization
! because these integrals are so expensive
! it is worth looking at the attempts.

   make_ft_old(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This version has the gaussian2 stuff inlined and special cases optimised,
   ! it's pretty messy but much faster.
      res :: MAT3{CPX}, target
      k_pts :: MAT{REAL}, target
      thermal :: MAT3{REAL}, target
      partition :: MAT{REAL}, IN
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      G :: GAUSSIAN2
      e :: MAT3{REAL}*
      pos :: VEC{REAL}(3)
      therm,k_x,k_y,k_z,k_x2,k_y2,k_z2 :: VEC{REAL}*
      res_ij,prefac,ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_xbx,ft_yby,ft_zbz :: MAT{CPX}*
      ft_x01,ft_x10,ft_y01,ft_y10,ft_z01,ft_z10 :: VEC{CPX}*
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      a,b,k,xa,ya,za,xb,yb,zb,bxlast,bylast,bzlast,aa,bb,k_max,fa,la,fb,lb :: INT
      fac1 :: CPX
      g1_exa,g1_exb,e00,ex_a,ex_b,ca,fac :: REAL
      Ex000,Ey000,Ez000,Ex001,Ey001,Ez001,Ex101,Ey101,Ez101 :: REAL
      Ex010,Ey010,Ez010,Ex110,Ey110,Ez110,Ex111,Ey111,Ez111 :: REAL
      Ex211,Ey211,Ez211,Ex011,Ey011,Ez011 :: REAL
      PA1,PA2,PA3,PB1,PB2,PB3,r2 :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      select case (.a.l)
        case (0)
          select case(.b.l)
            case (0)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              pos = .a.position - .b.position
              r2 = dot_product(pos,pos)
              res_ij => res(:,1,1)
              PA1 = .a.position(1); PA2 = .a.position(2); PA3 = .a.position(3)
              PB1 = .b.position(1); PB2 = .b.position(2); PB3 = .b.position(3)
              do a = 1, .a.n_cc
                ca = .a.contraction(a)
                ex_a = .a.exponent(a)
                do b = 1, .b.n_cc
                  ex_b = .b.exponent(b)
                  g1 = ONE/(ex_a+ex_b)
                  g4 = -QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*ex_a
                  g1_exb = g1*ex_b
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  e00 = exp(-ex_a*ex_b*r2*g1)
                  fac1= cmplx(pifac*e00,ZERO,kind=CPX_KIND) * ca * .b.contraction(b) * partition(a,b)
                  therm => thermal(:,a,b)
                  do k = 1, k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = g4 * (k1*k1+k2*k2+k3*k3)
                    res_ij(k) = res_ij(k) + therm(k) * (fac1 * exp(cmplx(dot2,dot1,kind=CPX_KIND)))
                  end
                end
              end
            case (1)
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              PA1 = .a.position(1); PA2 = .a.position(2); PA3 = .a.position(3)
              PB1 = .b.position(1); PB2 = .b.position(2); PB3 = .b.position(3)
              e.create((/0,1/),(/0,0/),(/0,1/))
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex101 = e(1,0,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey101 = e(1,0,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez101 = e(1,0,1)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))*therm(k)
                  end
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex001,Ex101*k_x,kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,1,2)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey001,Ey101*k_y,kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,1,3)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez001,Ez101*k_z,kind=CPX_KIND)*prefac(:)
                end
              end
              e.destroy
              prefac.destroy
            case default
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              PA1 = .a.position(1); PA2 = .a.position(2); PA3 = .a.position(3)
              PB1 = .b.position(1); PB2 = .b.position(2); PB3 = .b.position(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                  end
                  bxlast = bx(1)
                  bylast = by(1)
                  bzlast = bz(1)
                  ft_xb => ft_x(:,0,bxlast)
                  ft_yb => ft_y(:,0,bylast)
                  ft_zb => ft_z(:,0,bzlast)
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    if (bxlast/=xb) then
                      ft_xb => ft_x(:,0,xb)
                      bxlast = xb
                    end
                    if (bylast/=yb) then
                      ft_yb=> ft_y(:,0,yb)
                      bylast = yb
                    end
                    if (bzlast/=zb) then
                      ft_zb=> ft_z(:,0,zb)
                      bzlast = zb
                    end
                    res_ij => res(:,1,b)
                    res_ij(:) = res_ij(:) + ft_xb(:)*ft_yb(:)*ft_zb(:)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_y.destroy
              ft_z.destroy
          end
        case (1)
          select case (.b.l)
            case (0)
              prefac.create(k_max)
              e.create((/0,1/),(/0,1/),(/0,0/))
              PA1 = .a.position(1); PA2 = .a.position(2); PA3 = .a.position(3)
              PB1 = .b.position(1); PB2 = .b.position(2); PB3 = .b.position(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex010 = e(0,1,0)
                  Ex110 = e(1,1,0)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey010 = e(0,1,0)
                  Ey110 = e(1,1,0)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez010 = e(0,1,0)
                  Ez110 = e(1,1,0)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex010,Ex110*k_x(:),kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,2,1)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey010,Ey110*k_y(:),kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,3,1)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez010,Ez110*k_z(:),kind=CPX_KIND)*prefac(:)
                end
              end
              e.destroy
              prefac.destroy
            case (1)
              ft_x.create((/1,k_max/),(/0,1/),(/0,1/))
              ft_y.create((/1,k_max/),(/0,1/),(/0,1/))
              ft_z.create((/1,k_max/),(/0,1/),(/0,1/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              PA1 = .a.position(1); PA2 = .a.position(2); PA3 = .a.position(3)
              PB1 = .b.position(1); PB2 = .b.position(2); PB3 = .b.position(3)
              e.create((/0,2/),(/0,1/),(/0,1/))
              ft_x01.create(k_max)
              ft_x10.create(k_max)
              ft_y01.create(k_max)
              ft_y10.create(k_max)
              ft_z01.create(k_max)
              ft_z10.create(k_max)
              k_x2.create(k_max)
              k_y2.create(k_max)
              k_z2.create(k_max)
              k_x2=k_x*k_x
              k_y2=k_y*k_y
              k_z2=k_z*k_z
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex010 = e(0,1,0)
                  Ex011 = e(0,1,1)
                  Ex101 = e(1,0,1)
                  Ex110 = e(1,1,0)
                  Ex111 = e(1,1,1)
                  Ex211 = e(2,1,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey010 = e(0,1,0)
                  Ey011 = e(0,1,1)
                  Ey101 = e(1,0,1)
                  Ey110 = e(1,1,0)
                  Ey111 = e(1,1,1)
                  Ey211 = e(2,1,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez010 = e(0,1,0)
                  Ez011 = e(0,1,1)
                  Ez101 = e(1,0,1)
                  Ez110 = e(1,1,0)
                  Ez111 = e(1,1,1)
                  Ez211 = e(2,1,1)
                  ft_x01(:) = cmplx(Ex001,Ex101*k_x(:),kind=CPX_KIND)
                  ft_x10(:) = cmplx(Ex010,Ex110*k_x(:),kind=CPX_KIND)
                  ft_y01(:) = cmplx(Ey001,Ey101*k_y(:),kind=CPX_KIND)
                  ft_y10(:) = cmplx(Ey010,Ey110*k_y(:),kind=CPX_KIND)
                  ft_z01(:) = cmplx(Ez001,Ez101*k_z(:),kind=CPX_KIND)
                  ft_z10(:) = cmplx(Ez010,Ez110*k_z(:),kind=CPX_KIND)
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex011-Ex211*k_x2(:),Ex111*k_x(:),kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,2,1)
                  res_ij(:) = res_ij(:) + ft_x01(:)*ft_y10(:)*Ez000*prefac(:)
                  res_ij => res(:,3,1)
                  res_ij(:) = res_ij(:) + ft_x01(:)*Ey000*ft_z10(:)*prefac(:)
                  res_ij => res(:,1,2)
                  res_ij(:) = res_ij(:) + ft_x10(:)*ft_y01(:)*Ez000*prefac(:)
                  res_ij => res(:,2,2)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey011-Ey211*k_y2(:),Ey111*k_y(:),kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,3,2)
                  res_ij(:) = res_ij(:) + Ex000*ft_y01(:)*ft_z10(:)*prefac(:)
                  res_ij => res(:,1,3)
                  res_ij(:) = res_ij(:) + ft_x10(:)*Ey000*ft_z01(:)*prefac(:)
                  res_ij => res(:,2,3)
                  res_ij(:) = res_ij(:) + Ex000*ft_y10(:)*ft_z01(:)*prefac(:)
                  res_ij => res(:,3,3)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez011-Ez211*k_z2(:),Ez111*k_z(:),kind=CPX_KIND)*prefac(:)
                end
              end
              k_z2.destroy
              k_y2.destroy
              k_x2.destroy
              ft_z10.destroy
              ft_z01.destroy
              ft_y10.destroy
              ft_y01.destroy
              ft_x10.destroy
              ft_x01.destroy
              e.destroy
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
            case default
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do b=0,.b.l
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                    ft_z(:,1,b) = ft_z(:,1,b) * prefac(:)
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    ft_xb => ft_x(:,0,xb)
                    ft_yb => ft_y(:,0,yb)
                    ft_zb => ft_z(:,0,zb)
                    res_ij => res(:,1,b)
                    res_ij(:) = res_ij(:) + ft_x(:,1,xb)*ft_yb*ft_zb
                    res_ij => res(:,2,b)
                    res_ij(:) = res_ij(:) + ft_xb*ft_y(:,1,yb)*ft_zb
                    res_ij => res(:,3,b)
                    res_ij(:) = res_ij(:) + ft_xb*ft_yb*ft_z(:,1,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
          end
        case default
          select case (.b.l)
            case (0)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do a=0,.a.l
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res_ij => res(:,a,1)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
            case (1)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do a=0,.a.l ! incorporate prefac into ft_z
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                    ft_z(:,a,1) = ft_z(:,a,1) * prefac(:)
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res_ij => res(:,a,1)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                    res_ij => res(:,a,2)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                    res_ij => res(:,a,3)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
            case default
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              fb = .b.first_gaussian; lb = .b.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
             ! This is the general routine.  It includes reduced multiplication,
             ! and use of pointers to minimise array finding.
              do aa = 1, .a.n_cc
                ca = .a.contraction(aa)
                ex_a=.a.exponent(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.exponent(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.exponent+G.b.exponent
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.exponent
                  g1_exb = g1*G.b.exponent
                  P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
                  P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
                  P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)
                  G.make_ft_component(ft_x,1,k_x)
                  G.make_ft_component(ft_y,2,k_y)
                  G.make_ft_component(ft_z,3,k_z)
                  fac = pifac * ca * .b.contraction(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    do a=0,.a.l
                      ft_z(:,a,b) = ft_z(:,a,b) * prefac(:)
                    end
                  end
                  bxlast = bx(1)
                  bylast = by(1)
                  bzlast = bz(1)
                  ft_xbx => ft_x(:,:,bxlast)
                  ft_yby => ft_y(:,:,bylast)
                  ft_zbz => ft_z(:,:,bzlast)
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    if (bxlast/=xb) then
                      ft_xbx => ft_x(:,:,xb)
                      bxlast = xb
                    end
                    if (bylast/=yb) then
                      ft_yby=> ft_y(:,:,yb)
                      bylast = yb
                    end
                    if (bzlast/=zb) then
                      ft_zbz=> ft_z(:,:,zb)
                      bzlast = zb
                    end
                    do a = 1,.a.n_comp
                      xa = ax(a)
                      ya = ay(a)
                      za = az(a)
                      res_ij => res(:,a,b)
                      res_ij(:) = res_ij(:) + ft_xbx(:,xa+1)*ft_yby(:,ya+1)*ft_zbz(:,za+1)
                    end
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
          end
      end
   end

   make_ft_v0(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This is a basic version using gaussian pairs.
      res :: MAT3{CPX}
      k_pts :: MAT{REAL}, IN
      thermal :: MAT3{REAL}, target, IN
      partition :: MAT{REAL}, IN

      G :: GAUSSIAN2
      ft_ab :: MAT3{CPX}*
      therm :: VEC{REAL}*
      a,b,i,j,k_max :: INT
      ca,fac :: REAL

      k_max  = k_pts.dim1
      ft_ab.create(k_max,.a.n_comp,.b.n_comp)

      res = ZERO

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do a = 1,.a.n_cc
         G.set(ex_a=.a.exponent(a))
         ca = .a.contraction(a)
         do b = 1,.b.n_cc
            G.set(ex_b=.b.exponent(b))
            G.make_ft(ft_ab,k_pts)
            if (.l_sum==0) then; G.make_ft_00(ft_ab(:,1,1),k_pts)
            else;                G.make_ft_XX(ft_ab,k_pts) ! slower older version
            end
            fac = ca * .b.contraction(b) * partition(a,b)
            therm => thermal(:,a,b)
            do j = 1,.b.n_comp
            do i = 1,.a.n_comp
               res(:,i,j) = res(:,i,j) + fac*therm*ft_ab(:,i,j)
            end
            end
         end
      end

      ft_ab.destroy
   end

   make_ft_v1(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This is a basic version using gaussian pairs.
      res :: MAT3{CPX}
      k_pts :: MAT{REAL}, IN
      thermal :: MAT3{REAL}, target, IN
      partition :: MAT{REAL}, IN

      G :: GAUSSIAN2
      ft_ab :: MAT3{CPX}*
      therm :: VEC{REAL}*
      a,b,i,j,k_max :: INT
      ca,fac :: REAL

      k_max  = k_pts.dim1
      ft_ab.create(k_max,.a.n_comp,.b.n_comp)

      res = ZERO

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do a = 1,.a.n_cc
         G.set(ex_a=.a.exponent(a))
         ca = .a.contraction(a)
         do b = 1,.b.n_cc
            G.set(ex_b=.b.exponent(b))
            if (.l_sum==0) then; G.make_ft_00(ft_ab(:,1,1),k_pts)
            else;                G.make_ft_v2(ft_ab,k_pts) ! cleaner newer version
            end
            fac = ca * .b.contraction(b) * partition(a,b)
            therm => thermal(:,a,b)
            do j = 1,.b.n_comp
            do i = 1,.a.n_comp
               res(:,i,j) = res(:,i,j) + fac*therm*ft_ab(:,i,j)
            end
            end
         end
      end

      ft_ab.destroy
   end

   make_ft_v2(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This is an inlined version of v1 above.
      res :: MAT3{CPX}
      k_pts :: MAT{REAL}, target
      thermal :: MAT3{REAL}, target
      partition :: MAT{REAL}, IN

      G :: GAUSSIAN2
      prefac :: VEC{CPX}*
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      therm,k_x,k_y,k_z :: VEC{REAL}*
      pi32,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,fac,ca,cb :: REAL
      ag,bg,i,a,b,k,k_max,fa,la,fb,lb :: INT
      II :: CPX

      ! Constants
      II = cmplx(ZERO,ONE,kind=CPX_KIND)
      pi32 = sqrt(PI) * PI

      ! Reciprocal lattice K points
      k_max = k_pts.dim1
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)

      select case (.l_sum)

      case(0)

         ! Loop on primitive pairs and make the FT integrals
         i = 0
         res = ZERO

         do bg = 1,.b.n_cc

            cb = .b.contraction(bg)

            do ag = 1,.a.n_cc

               ca = .a.contraction(ag)

               i = i + 1

               ! Constants
               g1 = .exponent_inv(i)
               g4 = QUARTER*g1
               fac = pi32 * .contraction_prefactor(i) * partition(ag,bg)
               therm => thermal(:,ag,bg)

               P1 = .pair_center(1,i)
               P2 = .pair_center(2,i)
               P3 = .pair_center(3,i)

               ! Prefactor is essentially the integral
               do k = 1,k_max
                  k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                  th = k1*P1 + k2*P2 + k3*P3
                  kk = k1*k1 + k2*k2 + k3*k3
                  res(k,1,1) = res(k,1,1) + fac*(cos(th)+II*sin(th))*exp(-kk*g4)*therm(k)
               end

            end
         end

      case default

         ! Space for fourier transform of each component
         ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
         ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
         ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

         ! Prefactor part
         prefac.create(k_max)

         ! Gaussian function power arrays
         fa = .a.first_gaussian; la = .a.last_gaussian
         fb = .b.first_gaussian; lb = .b.last_gaussian
         ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
         bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)

         ! Loop on primitive pairs and make the FT integrals
         i = 0
         res = ZERO
         G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

         do bg = 1,.b.n_cc

            G.set(ex_b=.b.exponent(bg))
            cb = .b.contraction(bg)

            do ag = 1,.a.n_cc

               G.set(ex_a=.a.exponent(ag))
               ca = .a.contraction(ag)

               i = i + 1

               ! Constants
               g1 = .exponent_inv(i)
               g4 = QUARTER*g1
               fac = pi32 * sqrt(g1) * g1 * ca * cb * partition(ag,bg)
               therm => thermal(:,ag,bg)

               P1 = .pair_center(1,i)
               P2 = .pair_center(2,i)
               P3 = .pair_center(3,i)

               ! Make prefactor
               do k = 1,k_max
                  k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                  th = k1*P1 + k2*P2 + k3*P3
                  kk = k1*k1 + k2*k2 + k3*k3
                  prefac(k) = fac*(cos(th)+II*sin(th))*exp(-kk*g4)*therm(k)
               end

               ! Fourier transforms of each component.
               G.make_ft_component(ft_x,1,k_x)
               G.make_ft_component(ft_y,2,k_y)
               G.make_ft_component(ft_z,3,k_z)

               ! Incorporate prefactor into ft_z
               do b = 0,.b.l
               do a = 0,.a.l
                  ft_z(:,a,b) = prefac * ft_z(:,a,b)
               end
               end

               ! Make the FT integrals
               res = res + ft_x(:,ax,bx)*ft_y(:,ay,by)*ft_z(:,az,bz)

            end
         end

         prefac.destroy
         ft_z.destroy; ft_y.destroy; ft_x.destroy


      end


   end


   make_ft_v3(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This version uses the transfer relation.
      res :: MAT3{CPX}, target
      k_pts :: MAT{REAL}, target
      thermal :: MAT3{REAL}, target
      partition :: MAT{REAL}, IN

      prefac,res11 :: VEC{CPX}*
      therm,k_x,k_y,k_z :: VEC{REAL}*
      ft,ft_x,ft_y,ft_z :: MAT{CPX}*
      pi32,g1,g2,g4,th,kk,k1,k2,k3,P1,P2,P3,AB1,AB2,AB3,fac,ea,eb :: REAL
      ag,bg,i,k,k_max :: INT
      II :: CPX

      ! Constants
      II = cmplx(ZERO,ONE,kind=CPX_KIND)
      pi32 = sqrt(PI) * PI
      AB1 = .a.position(1) - .b.position(1)
      AB2 = .a.position(2) - .b.position(2)
      AB3 = .a.position(3) - .b.position(3)

      ! Reciprocal lattice K points
      k_max = k_pts.dim1
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)

      select case(.l_sum)

      case(0)

         ! Loop on primitive pairs and make the FT integrals
         i = 0
         res11 => res(:,1,1)
         res11 = ZERO

         do bg = 1,.b.n_cc

            eb = .b.exponent(bg)

            do ag = 1,.a.n_cc

               ea = .a.exponent(ag)

               i = i + 1

               ! Constants
               g1 = .exponent_inv(i)
               g4 = QUARTER*g1
               fac = pi32 * .contraction_prefactor(i) * partition(ag,bg)
               therm => thermal(:,ag,bg)

               P1 = .pair_center(1,i)
               P2 = .pair_center(2,i)
               P3 = .pair_center(3,i)

               ! Prefactor is essentially the integral
               do k = 1,k_max
                  k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                  th = k1*P1 + k2*P2 + k3*P3
                  kk = k1*k1 + k2*k2 + k3*k3
                ! res11(k) = res11(k) + (cos(th)+II*sin(th))*(fac*exp(-kk*g4)*therm(k))
                  res11(k) = res11(k) + fac*exp(-kk*g4+II*th)*therm(k)
               end

            end
         end

      case default

         ! Space for fourier transform of each component
         ft.create(k_max,.n_gaussian)
         ft_x.create([1,k_max],[0,.l_sum])
         ft_y.create([1,k_max],[0,.l_sum])
         ft_z.create([1,k_max],[0,.l_sum])

         ! Prefactor part
         prefac.create(k_max)

         ! Loop on primitive pairs and make the FT integrals
         i = 0
         ft = ZERO

         do bg = 1,.b.n_cc

            eb = .b.exponent(bg)

            do ag = 1,.a.n_cc

               ea = .a.exponent(ag)

               i = i + 1

               ! Constants
               g1 = .exponent_inv(i)
               g2 = HALF*g1
               g4 = QUARTER*g1
               fac = pi32 * .contraction_prefactor(i) * partition(ag,bg)
               therm => thermal(:,ag,bg)

               P1 = .pair_center(1,i)
               P2 = .pair_center(2,i)
               P3 = .pair_center(3,i)

               ! Make prefactor
               do k = 1,k_max
                  k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
                  th = k1*P1 + k2*P2 + k3*P3
                  kk = k1*k1 + k2*k2 + k3*k3
                ! prefac(k) = (cos(th)+II*sin(th))*(fac*exp(-kk*g4)*therm(k))
                  prefac(k) = fac*exp(-kk*g4+II*th)*therm(k)
               end

               ! Fourier transforms of each component.
               .make_ft_es(ft_x,AB1,ea,eb,g1,g2,k_x,k_max)
               .make_ft_es(ft_y,AB2,ea,eb,g1,g2,k_y,k_max)
               .make_ft_es(ft_z,AB3,ea,eb,g1,g2,k_z,k_max,prefac)

               ! Make the FT integrals with reduced multiplication
             ! .make_ft_rms_v1(ft,ft_x,ft_y,ft_z,prefac)
               .make_ft_rms_v2(ft,ft_x,ft_y,ft_z,prefac)

            end
         end

         prefac.destroy
         ft_z.destroy; ft_y.destroy; ft_x.destroy

         .transfer_ft(ft,res)
         ft.destroy


      end


   end

   make_ft_es(es,R,ex_a,ex_b,g1,g2,k1,k_max) ::: private, PURE
   ! Do the (e|s) type fourier transform integrals "es" for axis
   ! component with atom separation "R", with exponents "ex_a" and
   ! "ex_b", evaluated at the points "k1", *without* prefactors.
   ! WARNING: es(:,0) is not set, it assumed to be eliminated by RMS.
   !          See next routine where it is set using prefac.
      self :: IN
      es :: MAT{CPX}(1:,0:), OUT
      R,ex_a,ex_b,g1,g2 :: REAL, IN
      k1 :: VEC{REAL}, target, IN
      k_max :: INT, IN

      e,kp :: MAT{REAL}*
      vr,vi, k2,k3,k4 :: VEC{REAL}*
      a,t :: INT

      select case (.l_sum)

      case (0)

       ! es = ONE

      case (1)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

       ! es(:,0) = ONE
         es(:,1) = cmplx(e(0,1),e(1,1)*k1,kind=CPX_KIND)

         e.destroy

      case (2)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         k2.create(k_max); k2 = k1*k1

       ! es(:,0) = ONE
         es(:,1) = cmplx(e(0,1)          ,e(1,1)*k1,kind=CPX_KIND)
         es(:,2) = cmplx(e(0,2)-e(2,2)*k2,e(1,2)*k1,kind=CPX_KIND)

         k2.destroy
         e.destroy

      case (3)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         k2.create(k_max); k2 = k1*k1
         k3.create(k_max); k3 = k2*k1

       ! es(:,0) = ONE
         es(:,1) = cmplx(e(0,1)          ,e(1,1)*k1          ,kind=CPX_KIND)
         es(:,2) = cmplx(e(0,2)-e(2,2)*k2,e(1,2)*k1          ,kind=CPX_KIND)
         es(:,3) = cmplx(e(0,3)-e(2,3)*k2,e(1,3)*k1-e(3,3)*k3,kind=CPX_KIND)

         k3.destroy; k2.destroy
         e.destroy

      case (4)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         k2.create(k_max); k2 = k1*k1
         k3.create(k_max); k3 = k2*k1
         k4.create(k_max); k4 = k3*k1

       ! es(:,0) = ONE
         es(:,1) = cmplx(e(0,1)                    ,e(1,1)*k1          ,kind=CPX_KIND)
         es(:,2) = cmplx(e(0,2)-e(2,2)*k2          ,e(1,2)*k1          ,kind=CPX_KIND)
         es(:,3) = cmplx(e(0,3)-e(2,3)*k2          ,e(1,3)*k1-e(3,3)*k3,kind=CPX_KIND)
         es(:,4) = cmplx(e(0,4)-e(2,4)*k2+e(4,4)*k4,e(1,4)*k1-e(3,4)*k3,kind=CPX_KIND)

         k4.destroy; k3.destroy; k2.destroy
         e.destroy

      case default

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         ! Define kp array containing powers k(n)^t
         kp.create([1,k_max],[2,.l_sum])
         kp(:,2) = k1*k1
         do t = 3,.l_sum
            kp(:,t) = kp(:,t-1)*k1
         end
         do t = 2,.l_sum
            if (mod(t,4)<=1) cycle
            kp(:,t) = -kp(:,t)
         end

         ! Real, imaginary parts of answer: (vr,vi)
         vr.create(k_max)
         vi.create(k_max)

       ! es(:,0) = ONE
         es(:,1) = cmplx(e(0,1),e(1,1)*k1,kind=CPX_KIND)

         do a = 2,.l_sum

            vr = e(0,a)
            do t = 2,a,2
               vr = vr + e(t,a)*kp(:,t)
            end

            vi = e(1,a)*k1
            do t = 3,a,2
               vi = vi + e(t,a)*kp(:,t)
            end

            es(:,a) = cmplx(vr,vi,kind=CPX_KIND)

         end

         vi.destroy; vr.destroy
         kp.destroy; e.destroy

      end

   end

   make_ft_es(es,R,ex_a,ex_b,g1,g2,k1,k_max,prefac) ::: private, PURE
   ! Do the (e|s) type fourier transform integrals "es" for axis
   ! component with atom separation "R", with exponents "ex_a" and
   ! "ex_b", evaluated at the points "k1", *without* prefactors.
   ! "prefac" factors to apply to columns of "es".
      self :: IN
      es :: MAT{CPX}(1:,0:), OUT
      R,ex_a,ex_b,g1,g2 :: REAL, IN
      k1 :: VEC{REAL}, target, IN
      k_max :: INT, IN
      prefac :: VEC{CPX}, IN

      e,kp :: MAT{REAL}*
      vr,vi, k2,k3,k4 :: VEC{REAL}*
      a,t :: INT

      select case (.l_sum)

      case (0)

         es(:,0) = prefac

      case (1)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         es(:,0) = prefac
         es(:,1) = cmplx(e(0,1),e(1,1)*k1,kind=CPX_KIND)*prefac

         e.destroy

      case (2)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         k2.create(k_max); k2 = k1*k1

         es(:,0) = prefac
         es(:,1) = cmplx(e(0,1)          ,e(1,1)*k1,kind=CPX_KIND)*prefac
         es(:,2) = cmplx(e(0,2)-e(2,2)*k2,e(1,2)*k1,kind=CPX_KIND)*prefac

         k2.destroy
         e.destroy

      case (3)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         k2.create(k_max); k2 = k1*k1
         k3.create(k_max); k3 = k2*k1

         es(:,0) = prefac
         es(:,1) = cmplx(e(0,1)          ,e(1,1)*k1          ,kind=CPX_KIND)*prefac
         es(:,2) = cmplx(e(0,2)-e(2,2)*k2,e(1,2)*k1          ,kind=CPX_KIND)*prefac
         es(:,3) = cmplx(e(0,3)-e(2,3)*k2,e(1,3)*k1-e(3,3)*k3,kind=CPX_KIND)*prefac

         k3.destroy; k2.destroy
         e.destroy

      case (4)

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         k2.create(k_max); k2 = k1*k1
         k3.create(k_max); k3 = k2*k1
         k4.create(k_max); k4 = k3*k1

         es(:,0) = prefac
         es(:,1) = cmplx(e(0,1)                    ,e(1,1)*k1          ,kind=CPX_KIND)*prefac
         es(:,2) = cmplx(e(0,2)-e(2,2)*k2          ,e(1,2)*k1          ,kind=CPX_KIND)*prefac
         es(:,3) = cmplx(e(0,3)-e(2,3)*k2          ,e(1,3)*k1-e(3,3)*k3,kind=CPX_KIND)*prefac
         es(:,4) = cmplx(e(0,4)-e(2,4)*k2+e(4,4)*k4,e(1,4)*k1-e(3,4)*k3,kind=CPX_KIND)*prefac

         k4.destroy; k3.destroy; k2.destroy
         e.destroy

      case default

         ! Make the es type E coefficients
         e.create([0,.l_sum],[0,.l_sum])
         .make_e_coeff_es(e,R,ex_a,ex_b,g1,g2)

         ! Define kp array containing powers k(n)^t
         kp.create([1,k_max],[2,.l_sum])
         kp(:,2) = k1*k1
         do t = 3,.l_sum
            kp(:,t) = kp(:,t-1)*k1
         end
         do t = 2,.l_sum
            if (mod(t,4)<=1) cycle
            kp(:,t) = -kp(:,t)
         end

         ! Real, imaginary parts of answer: (vr,vi)
         vr.create(k_max)
         vi.create(k_max)

         es(:,0) = prefac
         es(:,1) = cmplx(e(0,1),e(1,1)*k1,kind=CPX_KIND)*prefac

         do a = 2,.l_sum

            vr = e(0,a)
            do t = 2,a,2
               vr = vr + e(t,a)*kp(:,t)
            end

            vi = e(1,a)*k1
            do t = 3,a,2
               vi = vi + e(t,a)*kp(:,t)
            end

            es(:,a) = cmplx(vr,vi,kind=CPX_KIND)*prefac

         end

         vi.destroy; vr.destroy
         kp.destroy; e.destroy

      end

   end

   make_e_coeff_es(e,R,ex_a,ex_b,g1,g2) ::: private, pure
   ! Return the McMurchie-Davidson (e|s) type "e" coefficients for
   ! component "comp" of the gaussian pair with exponents "ex_a" and
   ! "ex_b" and with flattened pair index "i".
      self :: IN
      e :: MAT{REAL}(0:,0:), OUT
      R,ex_a,ex_b,g1,g2 :: REAL, IN

      a,ap,am,t :: INT
      b1 :: REAL

      ! The normal starting e00 factor is taken out
      ! and included in cc_prefactor
      e(0,0) = ONE
      if (.l_sum==0) return

      ! The highest l center is used to generate the integrals
      ! to minimise the transfer cost.
      if (.a.l>.b.l) then; b1 =  ex_b*g1*R
      else;                b1 = -ex_a*g1*R
      end

      ! e(X,1)
      e(1,1) =  g2
      e(0,1) = -b1
      if (.l_sum==1) return

      ! Make the e(t,a), up to a = .l_sum
      do a = 1,.l_sum-1
         ap = a + 1
         am = a - 1
         e(ap,ap) =  g2*e( a,a)
         e( a,ap) =  g2*e(am,a) - b1*e(a,a)
         e( 0,ap) = -b1*e( 0,a) +    e(1,a)
         do t = 1,am
            e(t,ap) = g2*e(t-1,a) - b1*e(t,a) + (t+1)*e(t+1,a)
         end
      end

   end

!   make_ft_rms_v1(es,Ix,Iy,Iz,wt) ::: private
!   ! Multiply the Ix, Iy, Iz integrals to get the (e|s) integrals
!   ! using th reduced multiplication scheme. This version for FT
!   ! integrals. WARNING: the 0,0,0 case is eliminated, assumed
!   ! to be handled by special case code.
!      es :: MAT{CPX}
!      Ix,Iy,Iz :: MAT{CPX}(1:,0:), IN
!      wt :: VEC{CPX}, IN
!
!      Ixy :: VEC{CPX}*
!   !  exyz0 :: VEC{INT}*
!      ex,ey,ez, eyz0,exz0,exy0,ez0,ey0,ex0,en0,erms :: VEC{INT}*
!      exy_rms :: VEC{VEC_{INT}}*
!      er :: RMS_INDICES*
!      ee,em,e,x,y,z,f,l :: INT
!
!      f = .first_gaussian
!      l = .last_gaussian
!      ex => GAUSSIAN_DATA::px(f:l); ey => GAUSSIAN_DATA::py(f:l); ez => GAUSSIAN_DATA::pz(f:l)
!      er => GAUSSIAN_DATA::rms_indices(.l_max,.l_min)
!   !  exyz0 => er.xyz0
!      eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
!      ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
!      en0   => er.n0
!
!   ! do ee = 1,exyz0.dim
!   !    e = exyz0(ee)
!   !    es(:,e) = es(:,e) + wt
!   ! end
!      do ee = 1,eyz0.dim
!        e = eyz0(ee)
!        x = ex(e)
!        es(:,e) = es(:,e) + Ix(:,x)*wt
!      end
!      do ee = 1,exz0.dim
!        e = exz0(ee)
!        y = ey(e)
!        es(:,e) = es(:,e) + Iy(:,y)*wt
!      end
!      do ee = 1,exy0.dim
!        e = exy0(ee)
!        z = ez(e)
!        es(:,e) = es(:,e) + Iz(:,z)
!      end
!      do ee = 1,ez0.dim
!        e = ez0(ee)
!        x = ex(e)
!        y = ey(e)
!        es(:,e) = es(:,e) + Ix(:,x)*Iy(:,y)*wt
!      end
!      do ee = 1,ey0.dim
!        e = ey0(ee)
!        x = ex(e)
!        z = ez(e)
!        es(:,e) = es(:,e) + Ix(:,x)*Iz(:,z)
!      end
!      do ee = 1,ex0.dim
!        e = ex0(ee)
!        y = ey(e)
!        z = ez(e)
!        es(:,e) = es(:,e) + Iy(:,y)*Iz(:,z)
!      end
!      exy_rms => er.xy_rms_n
!      if (exy_rms.dim==en0.dim) then
!        do ee = 1,en0.dim
!           e = en0(ee)
!           x = ex(e); y = ey(e); z = ez(e)
!           es(:,e) = es(:,e) + Ix(:,x)*Iy(:,y)*Iz(:,z)
!        end
!      else if (exy_rms.dim>0) then
!        Ixy.create(Ix.dim1)
!        do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
!           erms => exy_rms(ee).element
!           e = en0(erms(1))
!           x = ex(e)
!           y = ey(e)
!           z = ez(e)
!           Ixy = Ix(:,x)*Iy(:,y)
!           es(:,e) = es(:,e) + Ixy*Iz(:,z)
!           do em = 2,erms.dim
!              e = en0(erms(em))
!              z = ez(e)
!              es(:,e) = es(:,e) + Ixy*Iz(:,z)
!           end
!        end
!        Ixy.destroy
!      end
!   end

   make_ft_rms_v2(es,Ix,Iy,Iz,wt) ::: private
   ! Multiply the Ix, Iy, Iz integrals to get the (e|s) integrals
   ! using th reduced multiplication scheme. This version for FT
   ! integrals. This version removes one level of indirection on the
   ! RMS arrays. WARNING: the 0,0,0 case is eliminated, assumed
   ! to be handled by special case code.
      es :: MAT{CPX}
      Ix,Iy,Iz :: MAT{CPX}(1:,0:), IN
      wt :: VEC{CPX}, IN

      Ixy :: VEC{CPX}*
    ! xyz0 :: VEC{INT}*
      yz0,yz0px,xz0,xz0py,xy0,xy0pz :: VEC{INT}*
      z0,z0px,z0py,y0,y0px,y0pz,x0,x0py,x0pz :: VEC{INT}*
      n1,n1px,n1py,n1pz :: VEC{INT}*
      n2,n2px,n2py,n2pz :: VEC{VEC_{INT}}*
      er :: RMS_INDICES*
      ee,em,e,x,y,z :: INT

      er => GAUSSIAN_DATA::rms_indices(.l_max,.l_min)
    ! xyz0 => er.xyz0
      yz0  => er.yz0; yz0px => er.yz0px
      xz0  => er.xz0; xz0py => er.xz0py
      xy0  => er.xy0; xy0pz => er.xy0pz
      z0   => er.z0;  z0px => er.z0px; z0py => er.z0py
      y0   => er.y0;  y0px => er.y0px; y0pz => er.y0pz
      x0   => er.x0;  x0py => er.x0py; x0pz => er.x0pz
      n1   => er.n1;  n1px => er.n1px; n1py => er.n1py; n1pz => er.n1pz
      n2   => er.n2;  n2px => er.n2px; n2py => er.n2py; n2pz => er.n2pz

   ! do ee = 1,xyz0.dim
   !    e = xyz0(ee)
   !    es(:,e) = es(:,e) + wt
   ! end
      do ee = 1,yz0.dim
        e = yz0(ee)
        x = yz0px(ee)
        es(:,e) = es(:,e) + Ix(:,x)*wt
      end
      do ee = 1,xz0.dim
        e = xz0(ee)
        y = xz0py(ee)
        es(:,e) = es(:,e) + Iy(:,y)*wt
      end
      do ee = 1,xy0.dim
        e = xy0(ee)
        z = xy0pz(ee)
        es(:,e) = es(:,e) + Iz(:,z)
      end
      do ee = 1,z0.dim
        e = z0(ee)
        x = z0px(ee)
        y = z0py(ee)
        es(:,e) = es(:,e) + Ix(:,x)*Iy(:,y)*wt
      end
      do ee = 1,y0.dim
        e = y0(ee)
        x = y0px(ee)
        z = y0pz(ee)
        es(:,e) = es(:,e) + Ix(:,x)*Iz(:,z)
      end
      do ee = 1,x0.dim
        e = x0(ee)
        y = x0py(ee)
        z = x0pz(ee)
        es(:,e) = es(:,e) + Iy(:,y)*Iz(:,z)
      end
      do ee = 1,n1.dim
        e = n1(ee)
        x = n1px(ee)
        y = n1py(ee)
        z = n1pz(ee)
        es(:,e) = es(:,e) + Ix(:,x)*Iy(:,y)*Iz(:,z)
      end
      if (n2.dim==0) return
      Ixy.create(Ix.dim1)
      do ee = 1,n2.dim                 ! Apply RMS here
        e = n2(ee)[1]
        x = n2px(ee)[1]
        y = n2py(ee)[1]
        z = n2pz(ee)[1]
        Ixy = Ix(:,x)*Iy(:,y)
        es(:,e) = es(:,e) + Ixy*Iz(:,z)
        do em = 2,n2(ee).element.dim
           e = n2(ee)[em]
           z = n2pz(ee)[em]
           es(:,e) = es(:,e) + Ixy*Iz(:,z)
        end
      end
      Ixy.destroy
   end

!  ==============================
!  Partition and thermal smearing
!  ==============================

   make_gaussian_partition(res,factor_a,factor_b) ::: PURE
   ! Make the factors for partitioning the density contribution from
   ! each atom. Dimensions of res are [.a.n_cc,.b.n_cc].
      self :: IN
      res  :: MAT{REAL}, OUT
      factor_a,factor_b :: REAL, IN

   ENSURE(res.dim1==.a.n_cc,"wrong dim1, res")
   ENSURE(res.dim2==.b.n_cc,"wrong dim1, res")

      a,b :: INT
      ex_a,ex_b,exb_fb :: REAL

      do b = 1, .b.n_cc
         ex_b   = .b.exponent(b)
         exb_fb = ex_b * factor_b
         do a = 1, .a.n_cc
            ex_a = .a.exponent(a)
            res(a,b) = (exb_fb + ex_a * factor_a) / (ex_a + ex_b)
         end
      end

   end

   make_tanaka_thermal_smearing(res,k_pts,Ua,Ub) ::: pure
   ! Make the thermal smearing correction according to Tanaka.
   ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
   ! "res" contains the correction for each pair of primitives.
      self :: IN
      res :: MAT3{REAL}, OUT
      k_pts,Ua,Ub :: MAT{REAL}, IN

   ENSURE(res.dim1==k_pts.dim1,"wrong dim1, res")
   ENSURE(res.dim2==.a.n_cc,"wrong dim2, res")
   ENSURE(res.dim3==.b.n_cc,"wrong dim3, res")

      Ua_ea,Ub_eb,U :: MAT{REAL}(3,3)
      ea,eb :: REAL
      U11,U22,U33,U21_12,U31_13,U32_23,S1,S2,S3 :: REAL
      a,b,k,k_max :: INT

      k_max  = size(k_pts,1)

      do a = 1, .a.n_cc

         ea = .a.exponent(a)
         Ua_ea = ea * Ua

         do b = 1, .b.n_cc

            eb = .b.exponent(b)
            Ub_eb = eb * Ub

            U = - HALF * (Ua_ea + Ub_eb) / (ea + eb)

            U11    = U(1,1)
            U22    = U(2,2)
            U33    = U(3,3)
            U21_12 = U(2,1) + U(1,2)
            U31_13 = U(3,1) + U(1,3)
            U32_23 = U(3,2) + U(2,3)

            do k = 1,k_max

               S1 = k_pts(k,1)
               S2 = k_pts(k,2)
               S3 = k_pts(k,3)

               ! S.U.S has been expanded to save multiplies and array accesses.
               res(k,a,b) = exp(S1*(S1*U11+S2*U21_12+S3*U31_13)+S2*(S2*U22+S3*U32_23)+S3*S3*U33)

            end

         end

      end

   end

   make_tanaka_partition(res) ::: PURE
   ! Make the Tanaka factors for partitioning the density contribution
   ! for atom a in the shell. Dimensions of res are [.a.n_cc,.b.n_cc].
   ! K. Tanaka (1988) Acta Cryst. A44, 10028 
      self :: IN
      res  :: MAT{REAL}, OUT

   ENSURE(res.dim1==.a.n_cc,"wrong dim1, res")
   ENSURE(res.dim2==.b.n_cc,"wrong dim2, res")

      a,b :: INT
      ex_a,ex_b :: REAL

      do b = 1,.b.n_cc

         ex_b   = .b.exponent(b)

         do a = 1, .a.n_cc

            ex_a = .a.exponent(a)

            res(a,b) = ex_a/(ex_a+ex_b)

         end

      end

   end

   make_KM_partition(res) ::: PURE
   ! Make the Koritsanzky-Michael factors for partitioning the density
   ! contribution for atom *a* in the shell. res is [.a.n_cc,.b.n_cc].
   ! J.R. Michael & T.Koritsanzky (2015) J Math Chem 53, p 250-9
      self :: IN
      res  :: MAT{REAL}, OUT

   ENSURE(res.dim1==.a.n_cc,"wrong dim1, res")
   ENSURE(res.dim2==.b.n_cc,"wrong dim2, res")

      a,b :: INT
      ea,eb,a2,b2,ab :: REAL

      do b = 1,.b.n_cc

         eb = .b.exponent(b)
         b2 = eb*eb

         do a = 1, .a.n_cc

            ea = .a.exponent(a)
            a2 = ea*ea
            ab = ea*eb

            res(a,b) = (a2+ab)/(a2+TWO*ab+b2)

         end

      end

   end

!  ===================================
!  Fourier transform current integrals
!  ===================================

   make_ft_nabla(res,k_pts)
   ! Calculates the Fourier transform for a product of the gradient of
   ! shell a minus shell b for two contracted gaussian shells, evaluated
   ! at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      res :: MAT4{CPX}
      k_pts :: MAT{REAL}, IN

      G :: GAUSSIAN2
      ft_ab :: MAT4{CPX}*
      a,b,k_max :: INT
      ca,cb,cacb :: REAL

      k_max  = size(k_pts,1)

      res = ZERO

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      do a = 1, .a.n_cc

         G.set(ex_a=.a.exponent(a))
         ca = .a.contraction(a)

         do b = 1, .b.n_cc

            G.set(ex_b=.b.exponent(b))
            cb = .b.contraction(b)

            cacb = ca*cb

            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G.make_ft_nabla(ft_ab,k_pts)

            res = res + ft_ab*cacb

            ft_ab.destroy

         end

      end

   end

   make_ft_nabla(res,k_pts,thermal,partition)
   ! Calculates "res" the Fourier transform for a product of the gradient of
   ! shell a minus shell b for two contracted gaussian shells, evaluated
   ! at a series of k points "k_pts", including "thermal" smearing corrections
   ! and "partition" factors.
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      res :: MAT4{CPX}
      k_pts,partition :: MAT{REAL}, IN
      thermal :: MAT3{REAL}, target
      therm :: VEC{REAL}*
       G :: GAUSSIAN2
      ft_ab :: MAT4{CPX}*
      a,b,k_max,i,j :: INT
      ca,cb,fac :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do a = 1, .a.n_cc
         G.set(ex_a=.a.exponent(a))
         ca = .a.contraction(a)
         do b = 1, .b.n_cc
            G.set(ex_b=.b.exponent(b))
            cb = .b.contraction(b)
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G.make_ft_nabla(ft_ab,k_pts)
            fac   =  ca*cb*partition(a,b)
            therm => thermal(:,a,b)
            do i = 1,.a.n_comp
            do j = 1,.b.n_comp
                res(:,i,j,1) = res(:,i,j,1) + ft_ab(:,i,j,1) * fac * therm(:)
                res(:,i,j,2) = res(:,i,j,2) + ft_ab(:,i,j,2) * fac * therm(:)
                res(:,i,j,3) = res(:,i,j,3) + ft_ab(:,i,j,3) * fac * therm(:)
            end
            end
            ft_ab.destroy
         end
      end
   end

   make_ft_r(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      k_pts :: MAT{REAL}, IN
      res :: MAT4{CPX}
       G :: GAUSSIAN2
      ft_ab :: MAT4{CPX}*
      a,b,k_max :: INT
      ca,cb,cacb :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do a = 1, .a.n_cc
         G.set(ex_a=.a.exponent(a))
         ca = .a.contraction(a)
         do b = 1, .b.n_cc
            G.set(ex_b=.b.exponent(b))
            cb = .b.contraction(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G.make_ft_r(ft_ab,k_pts)
            res = res + ft_ab*cacb
            ft_ab.destroy
         end
      end
   end

!  ===========================
!  Averaged fourier transforms
!  ===========================

   make_spherically_averaged_ft(res,k_values)
   ! Calculates the spherically averaged Fourier transform for a product of two
   ! contracted gaussian shells, "res", evaluated at a series of "k_values".
   ! Dimensions of res are [.a.n_comp,.b.n_comp,k_values.dim].
      res :: MAT3{CPX}
      k_values :: VEC{REAL}, IN

   ENSURE(res.dim1==.a.n_comp,"wrong 1st dimension for res")
   ENSURE(res.dim2==.b.n_comp,"wrong 2nd dimension for res")
   ENSURE(res.dim3==k_values.dim,"wrong 3rd dimension for res")

      G :: GAUSSIAN2
      k_pts :: MAT{REAL}*
      ft_ab :: MAT3{CPX}*
      wt,fac_wt :: VEC{REAL}*
      k,n,n_pts,t,p, a,b,i,j :: INT
      k_val,k_val_st,th,ph,ct,st,cp,sp,ca,fac :: REAL
      theta,phi :: QUADRATURE@

      ! First set the quadrature objects
      n = 10
      n_pts = 2*n*n
      theta.create
      theta.set_kind("gauss_legendre")
      theta.set_n_points(n)
      theta.set_quadrature_points
      theta.set_limits([ZERO,PI])

      phi.create
      phi.set_kind("gauss_legendre")
      phi.set_n_points(2*n)
      phi.set_quadrature_points
      phi.set_limits([ZERO,2*PI])

      res = ZERO

      wt.create(n_pts)
      fac_wt.create(n_pts)
      k_pts.create(n_pts,3)
      ft_ab.create(n_pts,.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      ! Loop over each k_value one by one
      do k = 1,k_values.dim

         k_val = k_values(k)
         n = 0

         ! For each k_value, define a shell of spherical k_pts
         do t = 1,theta.n_points
         do p = 1,phi.n_points
            n = n + 1
            th = theta.point(t)
            ph = phi.point(p)
            ct = cos(th); st = sin(th)
            cp = cos(ph); sp = sin(ph)
            k_val_st = k_val*st
            k_pts(n,1) = k_val_st*cp    ! the spherical shell
            k_pts(n,2) = k_val_st*sp
            k_pts(n,3) = k_val*ct
            wt(n) = st*theta.weight(t)*phi.weight(p) ! the area x weights
         end
         end

         ! Now do the Fourier transform for this shell, and average it
         do a = 1,.a.n_cc
            G.set(ex_a=.a.exponent(a))
            ca = .a.contraction(a)
            do b = 1,.b.n_cc
               G.set(ex_b=.b.exponent(b))
               G.make_ft(ft_ab,k_pts)
               fac = ca*.b.contraction(b)
               fac_wt = fac*wt
               do j = 1,.b.n_comp
               do i = 1,.a.n_comp
                   res(i,j,k) = res(i,j,k) + sum(ft_ab(:,i,j)*fac_wt)
               end
               end
            end
         end

      end

      ft_ab.destroy
      k_pts.destroy
      fac_wt.destroy
      wt.destroy
      phi.destroy; theta.destroy

      fac = ONE/(FOUR*PI)
      res = fac*res

   end

   make_z_circularly_averaged_ft(res,k_values,n_theta)
   ! Calculates the z circularly averaged Fourier transform for a product of two
   ! contracted gaussian shells, "res", evaluated at a series of "k_values" in
   ! reciprocal space, and with "n_theta" equally spaced angles from the z axis,
   ! from 0 -> 2*Pi. Size of "res" is [.a.n_comp,.b.n_comp,k_values.dim,n_theta].
      res :: MAT4{CPX}
      k_values :: VEC{REAL}, IN
      n_theta :: INT, IN

   ENSURE(res.dim1==.a.n_comp,"wrong 1st dimension for res")
   ENSURE(res.dim2==.b.n_comp,"wrong 2nd dimension for res")
   ENSURE(res.dim3==k_values.dim,"wrong 3rd dimension for res")
   ENSURE(res.dim4==n_theta+1,"wrong 4th dimension for res")

      G :: GAUSSIAN2
      k_pts :: MAT{REAL}*
      ft_ab :: MAT3{CPX}*
      wt,fac_wt :: VEC{REAL}*
      k,n,n_pts,t,p, a,b,f,l :: INT
      k_val,k_val_st,th,ph,ct,st,cp,sp,fac,angle :: REAL
      phi :: QUADRATURE@

      ! First set the quadrature objects
      angle = (PI/(2*n_theta))
      n = 10                  ! points per Pi for phi
      n_pts = 2*n*(n_theta+1) !
      phi.create
      phi.set_kind("gauss_legendre")
      phi.set_n_points(2*n)
      phi.set_quadrature_points
      phi.set_limits([ZERO,2*PI])

      res = ZERO

      wt.create(n_pts)
      fac_wt.create(n_pts)
      k_pts.create(n_pts,3)
      ft_ab.create(n_pts,.a.n_comp,.b.n_comp)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      ! Loop over each k_value one by one
      do k = 1,k_values.dim

         k_val = k_values(k)
         n = 0

         ! For each k_value, define a shell of spherical k_pts
         do t = 0,n_theta
         do p = 1,phi.n_points
            n = n + 1
            th = t*angle
            ph = phi.point(p)
            ct = cos(th); st = sin(th)
            cp = cos(ph); sp = sin(ph)
            k_val_st = k_val*st
            k_pts(n,1) = k_val_st*cp    ! the spherical shell
            k_pts(n,2) = k_val_st*sp
            k_pts(n,3) = k_val*ct
         end
         end

         ! Now do the Fourier transform for this shell, and average it
         .make_ft_static(ft_ab,k_pts)

         f = 1
         l = phi.n_points
         do t = 1,n_theta+1
            do b = 1,.b.n_comp
            do a = 1,.a.n_comp
               res(a,b,k,t) = res(a,b,k,t) + sum(ft_ab(f:l,a,b)*phi.weight)
            end
            end
            f = f + phi.n_points
            l = l + phi.n_points
         end

       ! f = 1
       ! l = phi.n_points
       ! do t = 1,n_theta+1
       !    do a = 1,.a.n_cc
       !       G.set(ex_a=.a.exponent(a))
       !       ca = .a.contraction(a)
       !       do b = 1,.b.n_cc
       !          G.set(ex_b=.b.exponent(b))
       !          G.make_ft(ft_ab,k_pts)
       !          fac = ca*.b.contraction(b)
       !          fac_wt = fac*phi.weight
       !          do j = 1,.b.n_comp
       !          do i = 1,.a.n_comp
       !              res(i,j,k,t) = res(i,j,k,t) + sum(ft_ab(f:l,i,j)*fac_wt)
       !          end
       !          end
       !       end
       !    end
       !    f = f + phi.n_points
       !    l = l + phi.n_points
       ! end

      end

      ft_ab.destroy
      k_pts.destroy
      fac_wt.destroy
      wt.destroy
      phi.destroy

      fac = ONE/(TWO*PI)
      res = fac*res

   end

!  ======================
!  CADPAC-style integrals
!  ======================

   make_generic_ints(I) ::: template
   ! Calculate "I, a generic cartesian or spherical
   ! block of integrals.
      I :: MAT{REAL}

      W :: MAT{REAL}*

      if (NOT .is_spherical) then
         .make_ints_c(I)
      else if (.l_max<2) then
         .make_ints_c(I)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_ints_c(W)
         .change_to_spherical(W,I)
         W.destroy
      end

   end

   make_overlap_ints(I) ::: get_from(SHELL2:make_generic_ints, make_ints_c=>make_overlap_ints_c)
   ! Calculate "I, a generic cartesian or spherical
   ! block of integrals.
   end

   make_overlap_ints_c(S)
   ! Calculates overlap integral matrix, using Gauss-Hermite
   ! quadrature, like in CADPAC. This is for cartesians only.
      S :: MAT{REAL}, OUT

      SS :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL

      S = ZERO

      SS.create(.a.n_comp,.b.n_comp)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      do b = 1,.b.n_cc
      do a = 1,.a.n_cc

         G.set(.a.exponent(a),.b.exponent(b))

         G.make_overlap_ints(SS)

         cacb = .a.contraction(a)*.b.contraction(b)

         S = S + SS*cacb

      end
      end

      SS.destroy

   end

   make_weighted_overlap_ints(Sa,Sb,fab) ::: PURE
   ! Calculates weighted overlap integrals "Sa" and "Sb" from a given
   ! set of primitive weights "fab" weight assign to shell a centered.
   ! NOTE: should only be called when the centers are different.
      self :: IN
      Sa,Sb :: MAT{REAL}, OUT
      fab :: MAT{REAL}, IN


      SS :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb,fa,fb :: REAL

      Sa = ZERO
      Sb = ZERO

      SS.create(.a.n_comp,.b.n_comp)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      do b = 1,.b.n_cc
      do a = 1,.a.n_cc

         G.set(.a.exponent(a),.b.exponent(b))

         SS = ZERO
         G.make_overlap_ints(SS)

         cacb = .a.contraction(a)*.b.contraction(b)

         fa = fab(a,b)
         fb = ONE - fa

         fa = fa*cacb
         fb = fb*cacb

         Sa = Sa + fa*SS
         Sb = Sb + fb*SS

      end
      end

      SS.destroy

   end

   make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz,fab) ::: PURE
   ! Make the weighted dipole moment integral matrices.
   ! Dipole origin are at the respective shell positions.
      self :: IN
      Ax,Ay,Az,Bx,By,Bz :: MAT{REAL}, OUT
      fab :: MAT{REAL}, IN
      DDx,DDy,DDz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      fa,fb,cacb :: REAL

      Ax = ZERO; Ay = ZERO; Az = ZERO
      Bx = ZERO; By = ZERO; Bz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      do b = 1,.b.n_cc
      do a = 1,.a.n_cc

         G.set(.a.exponent(a),.b.exponent(b))
         fa = fab(a,b)
         fb = ONE - fa
         cacb = .a.contraction(a)*.b.contraction(b)

         fa = fa*cacb
         fb = fb*cacb

         G.make_dipole_ints(DDx,DDy,DDz,.a.position)
         Ax = Ax + fa*DDx; Ay = Ay + fa*DDy; Az = Az + fa*DDz

         G.make_dipole_ints(DDx,DDy,DDz,.b.position)
         Bx = Bx + fb*DDx; By = By + fb*DDy; Bz = Bz + fb*DDz
      end
      end

      DDz.destroy; DDy.destroy; DDx.destroy
   end

   make_weighted_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz,Bxx,Byy,Bzz,Bxy,Bxz,Byz,fab) ::: PURE
   ! Make the quadrupole moment integral matrices "Qij" weighted by given factors
      self :: IN
      Axx,Ayy,Azz,Axy,Axz,Ayz,Bxx,Byy,Bzz,Bxy,Bxz,Byz :: MAT{REAL}, OUT
      fab :: MAT{REAL}, IN

      QQxx,QQyy,QQzz,QQxy,QQxz,QQyz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      fa,fb,cacb :: REAL
      Axx = ZERO; Ayy = ZERO; Azz = ZERO
      Axy = ZERO; Axz = ZERO; Ayz = ZERO
      Bxx = ZERO; Byy = ZERO; Bzz = ZERO
      Bxy = ZERO; Bxz = ZERO; Byz = ZERO

      n_a = .a.n_comp; n_b = .b.n_comp

      QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc

         G.set(.a.exponent(a),.b.exponent(b))
         fa = fab(a,b)
         fb = ONE - fa
         cacb = .a.contraction(a)*.b.contraction(b)

         fa = fa*cacb
         fb = fb*cacb

         G.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz,.a.position)
         Axx = Axx + QQxx*fa; Ayy = Ayy + QQyy*fa; Azz = Azz + QQzz*fa
         Axy = Axy + QQxy*fa; Axz = Axz + QQxz*fa; Ayz = Ayz + QQyz*fa

         G.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz,.b.position)
         Bxx = Bxx + QQxx*fb; Byy = Byy + QQyy*fb; Bzz = Bzz + QQzz*fb
         Bxy = Bxy + QQxy*fb; Bxz = Bxz + QQxz*fb; Byz = Byz + QQyz*fb

      end
      end
      QQyz.destroy; QQxz.destroy; QQxy.destroy
      QQzz.destroy; QQyy.destroy; QQxx.destroy
   end

   make_weighted_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz,Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz,fab) ::: PURE
   ! Make the octupole moment integral matrices "Oijk"
   ! with gauge origin "origin"
      self :: IN
      fab :: MAT{REAL}, IN
      Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz :: MAT{REAL}, OUT
      Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz :: MAT{REAL}, OUT

      OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      fa,fb,cacb :: REAL

      Axxx = ZERO; Ayyy = ZERO; Azzz = ZERO
      Axxy = ZERO; Axxz = ZERO
      Ayyx = ZERO; Ayyz = ZERO
      Azzx = ZERO; Azzy = ZERO
      Axyz = ZERO
      Bxxx = ZERO; Byyy = ZERO; Bzzz = ZERO
      Bxxy = ZERO; Bxxz = ZERO
      Byyx = ZERO; Byyz = ZERO
      Bzzx = ZERO; Bzzy = ZERO
      Bxyz = ZERO
 
      n_a = .a.n_comp; n_b = .b.n_comp
      OOxxx.create(n_a,n_b); OOyyy.create(n_a,n_b); OOzzz.create(n_a,n_b)
      OOxxy.create(n_a,n_b); OOxxz.create(n_a,n_b)
      OOyyx.create(n_a,n_b); OOyyz.create(n_a,n_b)
      OOzzx.create(n_a,n_b); OOzzy.create(n_a,n_b)
      OOxyz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))

         fa = fab(a,b)
         fb = ONE - fa
         cacb = .a.contraction(a)*.b.contraction(b)

         fa = fa*cacb
         fb = fb*cacb


         G.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,.a.position)
         Axxx = Axxx + OOxxx*fa; Ayyy = Ayyy + OOyyy*fa; Azzz = Azzz + OOzzz*fa
         Axxy = Axxy + OOxxy*fa; Axxz = Axxz + OOxxz*fa
         Ayyx = Ayyx + OOyyx*fa; Ayyz = Ayyz + OOyyz*fa
         Azzx = Azzx + OOzzx*fa; Azzy = Azzy + OOzzy*fa
         Axyz = Axyz + OOxyz*fa

         G.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,.b.position)
         Bxxx = Bxxx + OOxxx*fb; Byyy = Byyy + OOyyy*fb; Bzzz = Bzzz + OOzzz*fb
         Bxxy = Bxxy + OOxxy*fb; Bxxz = Bxxz + OOxxz*fb
         Byyx = Byyx + OOyyx*fb; Byyz = Byyz + OOyyz*fb
         Bzzx = Bzzx + OOzzx*fb; Bzzy = Bzzy + OOzzy*fb
         Bxyz = Bxyz + OOxyz*fb

      end
      end
      OOxyz.destroy
      OOzzy.destroy; OOzzx.destroy
      OOyyz.destroy; OOyyx.destroy
      OOxxz.destroy; OOxxy.destroy
      OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
   end




   make_oscillator_overlap_ints(S,c,d,lc_min,lc_max,ld_min,ld_max)
   ! Calculates oscillator overlap integral matrix, using Gauss-Hermite
   ! quadrature, like in CADPAC
      S :: MAT4{REAL}
      c,d :: VEC{REAL}(3)
      lc_min,lc_max,ld_min,ld_max :: INT
   ENSURE(S.dim1==.a.n_comp,"wrong size for S")
   ENSURE(S.dim2==.b.n_comp,"wrong size for S")
   ENSURE(S.dim3==(GAUSSIAN_DATA:n_comp_up_to(lc_max)-GAUSSIAN_DATA:n_comp_up_to(lc_min-1)),"wrong size for S")
   ENSURE(S.dim4==(GAUSSIAN_DATA:n_comp_up_to(ld_max)-GAUSSIAN_DATA:n_comp_up_to(ld_min-1)),"wrong size for S")
      SS :: MAT4{REAL}*
      G :: GAUSSIAN2
      cacb :: REAL
      a,b,nc,nd :: INT
      S = ZERO
      nc = GAUSSIAN_DATA:n_comp_up_to(lc_max) - GAUSSIAN_DATA:n_comp_up_to(lc_min-1)
      nd = GAUSSIAN_DATA:n_comp_up_to(ld_max) - GAUSSIAN_DATA:n_comp_up_to(ld_min-1)
      SS.create(.a.n_comp,.b.n_comp,nc,nd)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         cacb = .a.contraction(a)*.b.contraction(b)
         G.make_oscillator_overlap_ints(SS,c,d,lc_min,lc_max,ld_min,ld_max)
         S = S + SS*cacb
      end
      end
      SS.destroy
   end

   make_S_1st_deriv_ints(Ax,Ay,Az)
   ! Calculates the derivatives of the overlap integrals with respect to
   ! position A, in "Ax", "Ay", and "Az" using Gauss-Hermite quadrature.
      Ax,Ay,Az :: MAT{REAL}
      AAx,AAy,AAz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      AAx.create(.a.n_comp,.b.n_comp)
      AAy.create(.a.n_comp,.b.n_comp)
      AAz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_S_1st_deriv_ints(AAx,AAy,AAz)
         cacb = .a.contraction(a)*.b.contraction(b)
         Ax = Ax + AAx*cacb
         Ay = Ay + AAy*cacb
         Az = Az + AAz*cacb
      end
      end
      AAz.destroy
      AAy.destroy
      AAx.destroy
   end

   make_T_1st_deriv_ints(Ax,Ay,Az)
   ! Calculates the derivatives of the kinetic integrals with respect to
   ! position A, in "Ax", "Ay", and "Az" using Gauss-Hermite quadrature.
      Ax,Ay,Az :: MAT{REAL}
      AAx,AAy,AAz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      AAx.create(.a.n_comp,.b.n_comp)
      AAy.create(.a.n_comp,.b.n_comp)
      AAz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_T_1st_deriv_ints(AAx,AAy,AAz)
         cacb = .a.contraction(a)*.b.contraction(b)
         Ax = Ax + AAx*cacb
         Ay = Ay + AAy*cacb
         Az = Az + AAz*cacb
      end
      end
      AAz.destroy
      AAy.destroy
      AAx.destroy
   end

   make_NA_1st_deriv_ints(Ax,Ay,Az,Bx,By,Bz,c)
   ! Calculates the derivatives of the nuclear attraction integrals with respect to
   ! positions A *and* B, in "Ax", "Ay", "Az", and "Bx", "By", "Bz" for a given
   ! nuclear position "c".
      Ax,Ay,Az, Bx,By,Bz :: MAT{REAL}
       c :: VEC{REAL}(3)
      AAx,AAy,AAz, BBx,BBy,BBz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      Bx = ZERO; By = ZERO; Bz = ZERO
      AAx.create(.a.n_comp,.b.n_comp)
      AAy.create(.a.n_comp,.b.n_comp)
      AAz.create(.a.n_comp,.b.n_comp)
      BBx.create(.a.n_comp,.b.n_comp)
      BBy.create(.a.n_comp,.b.n_comp)
      BBz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_NA_1st_deriv_ints(AAx,AAy,AAz,BBx,BBy,BBz,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         Ax = Ax + AAx*cacb
         Ay = Ay + AAy*cacb
         Az = Az + AAz*cacb
         Bx = Bx + BBx*cacb
         By = By + BBy*cacb
         Bz = Bz + BBz*cacb
      end
      end
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
   end

   make_dipole_ints(Dx,Dy,Dz,origin)
   ! Make the dipole moment integral matrices "Di"
   ! with gauge origin "origin"
      Dx,Dy,Dz :: MAT{REAL}
      origin :: VEC{REAL}(3)

      DDx,DDy,DDz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL

      Dx = ZERO
      Dy = ZERO
      Dz = ZERO

      n_a = .a.n_comp
      n_b = .b.n_comp

      DDx.create(n_a,n_b)
      DDy.create(n_a,n_b)
      DDz.create(n_a,n_b)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_dipole_ints(DDx,DDy,DDz,origin)
         cacb = .a.contraction(a)*.b.contraction(b)
         Dx = Dx + DDx*cacb
         Dy = Dy + DDy*cacb
         Dz = Dz + DDz*cacb
      end
      end

      DDz.destroy
      DDy.destroy
      DDx.destroy

   end

   make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz)
   ! Make the weighted dipole moment integral matrices.
   ! Dipole origin are at the respective shell positions.
      Ax,Ay,Az,Bx,By,Bz :: MAT{REAL}
      DDx,DDy,DDz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      fa,fb,cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      Bx = ZERO; By = ZERO; Bz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         fa = .a.exponent(a)/(.a.exponent(a)+.b.exponent(b))
         fb = ONE - fa
         cacb = .a.contraction(a)*.b.contraction(b)
         fa = fa*cacb
         fb = fb*cacb
         G.make_dipole_ints(DDx,DDy,DDz,.a.position)
         Ax = Ax + fa*DDx; Ay = Ay + fa*DDy; Az = Az + fa*DDz
         G.make_dipole_ints(DDx,DDy,DDz,.b.position)
         Bx = Bx + fb*DDx; By = By + fb*DDy; Bz = Bz + fb*DDz
      end
      end
      DDz.destroy; DDy.destroy; DDx.destroy
   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)
   ! Make the quadrupole moment integral matrices "Qij"
   ! with gauge origin "origin"
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      QQxx,QQyy,QQzz,QQxy,QQxz,QQyz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
      Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz,origin)
         cacb = .a.contraction(a)*.b.contraction(b)
         Qxx = Qxx + QQxx*cacb; Qyy = Qyy + QQyy*cacb; Qzz = Qzz + QQzz*cacb
         Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb; Qyz = Qyz + QQyz*cacb
      end
      end
      QQyz.destroy; QQxz.destroy; QQxy.destroy
      QQzz.destroy; QQyy.destroy; QQxx.destroy
   end

   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)
   ! Make the octupole moment integral matrices "Oijk"
   ! with gauge origin "origin"
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Oxxx = ZERO; Oyyy = ZERO; Ozzz = ZERO
      Oxxy = ZERO; Oxxz = ZERO
      Oyyx = ZERO; Oyyz = ZERO
      Ozzx = ZERO; Ozzy = ZERO
      Oxyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      OOxxx.create(n_a,n_b); OOyyy.create(n_a,n_b); OOzzz.create(n_a,n_b)
      OOxxy.create(n_a,n_b); OOxxz.create(n_a,n_b)
      OOyyx.create(n_a,n_b); OOyyz.create(n_a,n_b)
      OOzzx.create(n_a,n_b); OOzzy.create(n_a,n_b)
      OOxyz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,origin)
         cacb = .a.contraction(a)*.b.contraction(b)
         Oxxx = Oxxx + OOxxx*cacb; Oyyy = Oyyy + OOyyy*cacb; Ozzz = Ozzz + OOzzz*cacb
         Oxxy = Oxxy + OOxxy*cacb; Oxxz = Oxxz + OOxxz*cacb
         Oyyx = Oyyx + OOyyx*cacb; Oyyz = Oyyz + OOyyz*cacb
         Ozzx = Ozzx + OOzzx*cacb; Ozzy = Ozzy + OOzzy*cacb
         Oxyz = Oxyz + OOxyz*cacb
      end
      end
      OOxyz.destroy
      OOzzy.destroy; OOzzx.destroy
      OOyyz.destroy; OOyyx.destroy
      OOxxz.destroy; OOxxy.destroy
      OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
   end

   make_nuclear_attraction_ints(N,c)
   ! Make the nuclear attraction integral matrix "N" for nucleus at position "c"
       N :: MAT{REAL}
       c :: VEC{REAL}(3)
      NN :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      N = ZERO
      NN.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_nuclear_attraction_ints(NN,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         N = N + NN*cacb
      end
      end
      NN.destroy
   end

   make_E_field_ints(Ex,Ey,Ez,p)
   ! Make the electric field integral matrices "Ei" evaluated at
   ! the position "p"
      Ex,Ey,Ez :: MAT{REAL}
       p :: VEC{REAL}(3)
      EEx,EEy,EEz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Ex = ZERO; Ey = ZERO; Ez = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      EEx.create(n_a,n_b); EEy.create(n_a,n_b); EEz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_E_field_ints(EEx,EEy,EEz,p)
         cacb = .a.contraction(a)*.b.contraction(b)
         Ex = Ex + EEx*cacb; Ey = Ey + EEy*cacb; Ez = Ez + EEz*cacb
      end
      end
      EEz.destroy; EEy.destroy; EEx.destroy
   end

   make_E_gradient_ints(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
   ! Make the electric field gradient integral matrices "Eij" evaluated
   ! at the position "c".
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}
       c :: VEC{REAL}
      EExx,EEyy,EEzz,EExy,EExz,EEyz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Exx = ZERO; Eyy = ZERO; Ezz = ZERO
      Exy = ZERO; Exz = ZERO; Eyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      EExx.create(n_a,n_b); EEyy.create(n_a,n_b); EEzz.create(n_a,n_b)
      EExy.create(n_a,n_b); EExz.create(n_a,n_b); EEyz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_E_gradient_ints(EExx,EEyy,EEzz,EExy,EExz,EEyz,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         Exx = Exx + EExx*cacb; Eyy = Eyy + EEyy*cacb; Ezz = Ezz + EEzz*cacb
         Exy = Exy + EExy*cacb; Exz = Exz + EExz*cacb; Eyz = Eyz + EEyz*cacb
      end
      end
      EEyz.destroy; EExz.destroy; EExy.destroy
      EEzz.destroy; EEyy.destroy; EExx.destroy
   end

   make_spin_orbit_ints(Lx,Ly,Lz,c)
   ! Make the spin orbit integral matrices "Lx" "Ly" and "Lz" for nucleus at
   ! position "c"
      Lx,Ly,Lz :: MAT{REAL}
       c :: VEC{REAL}(3)
      LLx,LLy,LLz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a.n_comp,.b.n_comp)
      LLy.create(.a.n_comp,.b.n_comp)
      LLz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_spin_orbit_ints(LLx,LLy,LLz,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
   end

   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make the gauge modified (B field) spin orbit integral matrices "Qij"
   ! for nucleus at position "c" and gauge origin "origin"
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}
      c,origin :: VEC{REAL}(3)
      QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      QQxx.create(n_a,n_b); QQyx.create(n_a,n_b); QQzx.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQyy.create(n_a,n_b); QQzy.create(n_a,n_b)
      QQxz.create(n_a,n_b); QQyz.create(n_a,n_b); QQzz.create(n_a,n_b)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_spin_orbit_B_ints(QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz,c,origin)
         cacb = .a.contraction(a)*.b.contraction(b)
         Qxx = Qxx + QQxx*cacb; Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb
         Qyx = Qyx + QQyx*cacb; Qyy = Qyy + QQyy*cacb; Qyz = Qyz + QQyz*cacb
         Qzx = Qzx + QQzx*cacb; Qzy = Qzy + QQzy*cacb; Qzz = Qzz + QQzz*cacb
      end
      end
      QQzz.destroy; QQyz.destroy; QQxz.destroy
      QQzy.destroy; QQyy.destroy; QQxy.destroy
      QQzx.destroy; QQyx.destroy; QQxx.destroy
   end

   make_L_ints(Lx,Ly,Lz,origin)
   ! Calculate the angular momentum integral matrices "Lx", "Ly", "Lz",
   ! with "origin" as gauge origin, using Gauss-Hermite quadrature
      Lx,Ly,Lz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      LLx,LLy,LLz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a.n_comp,.b.n_comp)
      LLy.create(.a.n_comp,.b.n_comp)
      LLz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_L_ints(LLx,LLy,LLz,origin)
         cacb = .a.contraction(a)*.b.contraction(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
   end

   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal "Ji" integral matrices evaluated at position "c"
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Ix,Iy,Iz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_solenoidal_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the irrotational "Ji" integral matrices evaluated at position "c"
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Ix,Iy,Iz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_irrotational_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
   end

   make_magnetic_jp_ints(Jx,Jy,Jz,c)
   ! Make the magnetic "Ji" integral matrices evaluated at position "c"
      Jx,Jy,Jz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Ix,Iy,Iz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL

      ! Initialize
      Jx = ZERO
      Jy = ZERO
      Jz = ZERO

      ! Allocate primitive integralsd
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)

      ! The the pair (no exponents)
      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)

      ! Get the primitive integrals
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_magnetic_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end

      ! Clean
      Iz.destroy
      Iy.destroy
      Ix.destroy

   end

   make_magnetic_S_ints(M,c)
   ! Make the magnetic "M(:,:,i,j)" integral matrices evaluated at position "c"
      M :: MAT4{REAL}
      c :: VEC{REAL}(3)

   ENSURE(M.dim3==3,"wrong shape for M")
   ENSURE(M.dim4==3,"wrong shape for M")

      I :: MAT4{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL

      ! Initialize
      M = ZERO

      ! Primitive integrals
      I.create(.a.n_comp,.b.n_comp,3,3)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_magnetic_S_ints(I,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         M = M + I*cacb
      end
      end

      ! Clean
      I.destroy

   end

   make_nabla_field_ints(M,c)
   ! Make the nabla field "M(:,:,i,j)" integral matrices evaluated at position "c"
      M :: MAT4{REAL}
      c :: VEC{REAL}(3)

   ENSURE(M.dim3==3,"wrong shape for M")
   ENSURE(M.dim4==3,"wrong shape for M")

      I :: MAT4{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL

      ! Initialize
      M = ZERO

      ! Primitive integrals
      I.create(.a.n_comp,.b.n_comp,3,3)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_nabla_field_ints(I,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         M = M + I*cacb
      end
      end

      ! Clean
      I.destroy

   end

   make_nabla_field_ints(M,N,c)
   ! Make the nabla field "M(:,:,i,j)" integral matrices evaluated at position "c"
      M,N :: MAT4{REAL}
      c :: VEC{REAL}(3)

   ENSURE(M.dim3==3,"wrong shape for M")
   ENSURE(M.dim4==3,"wrong shape for M")
   ENSURE(N.dim3==3,"wrong shape for N")
   ENSURE(N.dim4==3,"wrong shape for N")

      I,J :: MAT4{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL

      ! Initialize
      M = ZERO
      N = ZERO

      ! Primitive integrals
      I.create(.a.n_comp,.b.n_comp,3,3)

      G.set(.a.l,.a.position,ZERO,.b.l,.b.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.a.exponent(a),.b.exponent(b))
         G.make_nabla_field_ints(I,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         M = M + I*cacb
      end
      end
      ! Clean
      I.destroy

      J.create(.b.n_comp,.a.n_comp,3,3)
      G.set(.b.l,.b.position,ZERO,.a.l,.a.position,ZERO)
      do b = 1,.b.n_cc
      do a = 1,.a.n_cc
         G.set(.b.exponent(b),.a.exponent(a))
         G.make_nabla_field_ints(J,c)
         cacb = .a.contraction(a)*.b.contraction(b)
         N = N + J*cacb
      end
      end
      ! Clean
      J.destroy

   end

!  ==============================
!  Roland Lindh's style integrals
!  ==============================

   make_overlap(I) ::: get_from(SHELL2:make_generic_ints, make_ints_c=>make_overlap_c)
   ! Calculate "I, a generic cartesian or spherical
   ! block of integrals.
   end

   make_overlap_c(ab)
   ! Calculate the overlap matrix for the two shells
   ! For cartesians only.
      self :: IN
      ab :: MAT{REAL}, OUT

      es :: VEC{REAL}*
      n :: INT

      n = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l) - GAUSSIAN_DATA:n_comp_up_to(.l_max-1)

      es.create(n)

      .make_overlap_es(es)

      .transfer(es,ab)

      es.destroy

   end

   make_overlap_es(es) ::: private
   ! Make the (es) overlap integrals, summed over primitives
      self :: IN
      es :: VEC{REAL}, OUT

      temp :: VEC{REAL}*
      AB :: VEC{REAL}(3)
      a,b,templb,tempub,i :: INT
      r2ab,ea,eb :: REAL

      tempub = GAUSSIAN_DATA:n_comp_up_to(.l_sum)
      templb = GAUSSIAN_DATA:n_comp_up_to(.l_max-1) + 1

      temp.create(tempub)

      AB = .a.position - .b.position
      r2ab = dot_product(AB,AB)

      es = ZERO
      i  = 0
      do b = 1, .b.n_cc
         eb = .b.exponent(b)
         do a = 1, .a.n_cc
            i  = i + 1
            ea =.a.exponent(a)
            .form_overlap_es(temp,ea,eb,r2ab,i)
            es = es + .a.contraction(a) * .b.contraction(b) * temp(templb:tempub)
         end
      end

      temp.destroy

   end

   form_overlap_es(es,ea,eb,r2ab,i) ::: private
   ! Form the (es) overlap integrals for a pair of primitives
      self :: IN
      es :: VEC{REAL}, INOUT
      r2ab,ea,eb :: REAL, IN

      i :: INT, IN
      PE :: VEC{REAL}(3)
      half_zinv,zinv,zeta,zz,PI_zinv,PEi :: REAL
      j,ne,z,lz,a1,a2 :: INT

      zeta = .exponent_sum(i)
      zinv = .exponent_inv(i)

      zz      = ea*eb/zeta
      PI_zinv = PI/zeta

      es = ZERO

      ! s||s
      es(1) = PI_zinv*sqrt(PI_zinv) * exp(-zz*r2ab)          

      if (.l_sum > 0) then

         PE = .center_diff(:,i)

         ! p||s
         es(2) = PE(1) * es(1)                                
         es(3) = PE(2) * es(1)
         es(4) = PE(3) * es(1)
         
         if (.l_sum > 1) then

            half_zinv = HALF*zinv

            ! d||s to .l_sum||s
            ne = GAUSSIAN_DATA:n_comp_up_to(.l_sum)
            do j = 5,ne                                        

               a1 = GAUSSIAN_DATA::index_m1(j)
               z  = GAUSSIAN_DATA::first_nonzero(j)
               lz = GAUSSIAN_DATA::pp(z,j)

               PEi = PE(z)
               if (lz < 2) then
                  es(j) = PEi * es(a1)
               else
                  a2 = index_m1(a1)
                  es(j) = PEi * es(a1) + half_zinv * (lz-1) * es(a2)
               end

            end

         end

      end
   end

   get_kei(kei)
   ! Calculate the kinetic energy and overlap (optional) integrals.
   ! (More efficient than making them separate).
      self :: IN
      kei :: MAT{REAL}, INOUT

      Wt :: MAT{REAL}*

      if (NOT .is_spherical) then
         .make_kei_c(kei)
      else if (.l_max<2) then
         .make_kei_c(kei)
      else
         Wt.create(.a.n_comp,.b.n_comp)
         .make_kei_c(Wt)
         .change_to_spherical(Wt,kei)
         Wt.destroy
      end
   end

   get_kei(kei,overlap)
   ! Calculate the kinetic energy and overlap (optional) integrals.
   ! (More efficient than making them separate).
      self :: IN
      kei :: MAT{REAL}, INOUT
      overlap :: MAT{REAL}, INOUT

      Wt,Ws :: MAT{REAL}*

      if (NOT .is_spherical) then
         .make_kei_c(kei,overlap)
      else if (.l_max<2) then
         .make_kei_c(kei,overlap)
      else
         Wt.create(.a.n_comp,.b.n_comp)
         Ws.create(.a.n_comp,.b.n_comp)
         .make_kei_c(Wt,Ws)
         .change_to_spherical(Wt,kei)
         .change_to_spherical(Ws,overlap)
         Ws.destroy
         Wt.destroy
      end
   end

   make_kei_c(kei,overlap)
   ! Makes the kei and overlap matrics, summed over primitives
   ! Is called by kei, but does not do the orbital normalisation corrections
      self :: IN
      kei :: MAT{REAL}, INOUT
      overlap :: MAT{REAL}, INOUT, optional

      temp_kei,temp_overlap :: MAT{REAL}*
      P,PA,PB,ara,brb,AB :: VEC{REAL}(3)
      a,b,alb,aub,blb,bub :: INT
      ca,ea,eb,zeta,zinv2,r2ab :: REAL

      alb = GAUSSIAN_DATA:n_comp_up_to(.a.l-1) + 1; aub = alb + .a.n_comp -1
      blb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1) + 1; bub = blb + .b.n_comp -1

      temp_kei.create(aub,bub)
      temp_overlap.create(aub,bub)

      kei = ZERO
      if (present(overlap)) overlap = ZERO

      AB = .a.position - .b.position

      r2ab = dot_product(AB,AB)

      do a=1, .a.n_cc

         ca  = .a.contraction(a)
         ea  = .a.exponent(a)
         ara = ea*.a.position

         do b=1, .b.n_cc

           eb    = .b.exponent(b)
           brb   = eb * .b.position
           zeta  = ea + eb
           zinv2 = HALF / zeta
           P     = (ara + brb) / zeta
           PA    = P - .a.position
           PB    = P - .b.position

           if (.a.l > .b.l) then
             .form_overlap_mat_a(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
           else
             .form_overlap_mat_b(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
           end

           if (present(overlap)) overlap = overlap + ca * .b.contraction(b) * temp_overlap(alb:aub,blb:bub)

           kei = kei + ca * .b.contraction(b) * temp_kei(alb:aub,blb:bub)

         end

      end

      temp_kei.destroy
      temp_overlap.destroy

   end

   form_overlap_mat_a(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab) ::: private
   ! Makes the kinetic energy and overlap matrices for a primitive pair
   ! if .a.l > .b.l
      self :: IN
      overlap,kei :: MAT{REAL}, INOUT
      PA,PB :: VEC{REAL}(3), IN
      zinv2,zeta,ea,eb,r2ab :: REAL, IN
      b_momenta :: VEC{INT}(3)
      j,z,lza,lzb,a,a1,a2,b,b1,laub,na,nb,b_n_comp_sum :: INT
      la,lb,la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum :: INT
      PAi,PBi,PI_zinv,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_ea_na :: REAL

      zz       = ea * eb / zeta
      zz2      = 2 * zz
      zz_ea    = zz / ea
      zz_eb    = zz / eb
      b_n_comp_sum = GAUSSIAN_DATA:n_comp_up_to(.b.l)

      PI_zinv = PI/zeta
      overlap(1,1) = PI_zinv*sqrt(PI_zinv) * exp(-zz*r2ab)  ! s||s
      kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

      do j = 2, b_n_comp_sum                                ! s||p to s||lb
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lza = GAUSSIAN_DATA::nn(z,j)
       a1  = GAUSSIAN_DATA::index_m1(j)
       PBi = PB(z)
       PAi = PA(z)
       if (lza < 3) then
         overlap(1,j) = PBi * overlap(1,a1)
         kei(1,j)     = PBi * kei(1,a1) + zz2 * overlap(1,j)
         overlap(j,1) = PAi * overlap(a1,1)
         kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
       else
         na           = lza - 2
         zinv2_na     = zinv2 * na
         a2 = GAUSSIAN_DATA::index_m1(a1)
         overlap(1,j) = PBi * overlap(1,a1) + zinv2_na * overlap(1,a2)
         kei(1,j)     = PBi * kei(1,a1) + zinv2_na * kei(1,a2) + &
                        zz2 * overlap(1,j) - zz_eb * na * overlap(1,a2)
         overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
         kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                        zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
       end
      end

      do j = b_n_comp_sum + 1, GAUSSIAN_DATA:n_comp_up_to(.a.l-.b.l)   ! lb||s to la-lb||s
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lza = GAUSSIAN_DATA::nn(z,j)
       a1  = GAUSSIAN_DATA::index_m1(j)
       PAi          = PA(z)
       if (lza < 3) then
         overlap(j,1) = PAi * overlap(a1,1)
         kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
       else
         na           = lza - 2
         zinv2_na     = zinv2 * na
         a2 = GAUSSIAN_DATA::index_m1(a1)
         overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
         kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                        zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
       end
      end

      laub = .a.l - .b.l
      do lb = 1, .b.l
       lb1_n_comp_sum = GAUSSIAN_DATA:n_comp_up_to(lb-1) + 1
       lb_n_comp_sum  = GAUSSIAN_DATA:n_comp_up_to(lb)
       laub           = laub + 1
       do la = 1, laub
         la1_n_comp_sum = GAUSSIAN_DATA:n_comp_up_to(la-1) + 1
         la_n_comp_sum  = GAUSSIAN_DATA:n_comp_up_to(la)
         do a = la1_n_comp_sum, la_n_comp_sum
           z   = GAUSSIAN_DATA::first_nonzero(a)
           lza = GAUSSIAN_DATA::nn(z,a)
           a1  = GAUSSIAN_DATA::index_m1(a)
           PAi          = PA(z)
           if (lza==2) then
             do b = lb1_n_comp_sum,lb_n_comp_sum
               lzb = GAUSSIAN_DATA::nn(z,b)
               if (lzb==1) then
                 overlap(a,b) = PAi * overlap(a1,b)
                 kei(a,b)     = PAi * kei(a1,b) + zz2 * overlap(a,b)
               else
                 b_momenta    = GAUSSIAN_DATA::nn(:,b)
                 b_momenta(z) = b_momenta(z) - 1
                 b1  = GAUSSIAN_DATA::index_of(b_momenta(1),b_momenta(2),b_momenta(3))
                 nb           = lzb - 1
                 zinv2_nb     = zinv2 * nb
                 overlap(a,b) = PAi * overlap(a1,b) + zinv2_nb * overlap(a1,b1)
                 kei(a,b)     = PAi * kei(a1,b) + zinv2_nb * kei(a1,b1) + &
                                zz2 * overlap(a,b)
               end
             end
           else
             na           = lza - 2
             zinv2_na     = zinv2 * na
             zz_ea_na    = zz_ea * na
             a2 = GAUSSIAN_DATA::index_m1(a1)
             do b = lb1_n_comp_sum, lb_n_comp_sum
               lzb = GAUSSIAN_DATA::nn(z,b)
               if (lzb==1) then
                 overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b)
                 kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                                zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
               else
                 b_momenta    = GAUSSIAN_DATA::nn(:,b)
                 b_momenta(z) = b_momenta(z) - 1
                 b1  = GAUSSIAN_DATA::index_of(b_momenta(1),b_momenta(2),b_momenta(3))
                 nb           = lzb - 1
                 zinv2_nb     = zinv2 * nb
                 overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b) +&
                                zinv2_nb * overlap(a1,b1)
                 kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                                zinv2_nb * kei(a1,b1) + &
                                zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
               end
             end
           end
         end
       end
      end
   end

   form_overlap_mat_b(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab) ::: private
   ! Makes the kinetic energy and overlap matrices for a primitive pair
   ! if .b.l > .a.l
      self :: IN
      overlap,kei :: MAT{REAL}, INOUT
      PA,PB :: VEC{REAL}(3), IN
      zinv2,zeta,ea,eb,r2ab :: REAL, IN
      a_momenta :: VEC{INT}(3)
      j,z,lza,lzb,a,a1,b,b1,b2,lbub,la,lb,nb,na,a_n_comp_sum :: INT
      la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum :: INT
      PAi,PBi,PI_zinv,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_eb_nb :: REAL

      zz      = ea * eb / zeta
      zz2     = 2 * zz
      zz_ea    = zz / ea
      zz_eb    = zz / eb
      a_n_comp_sum  = GAUSSIAN_DATA:n_comp_up_to(.a.l)

      PI_zinv = PI/zeta
      overlap(1,1) = PI_zinv*sqrt(PI_zinv) * exp(-zz*r2ab) ! s||s
      kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

      do j = 2, a_n_comp_sum                               ! p||s to la||s
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lzb = GAUSSIAN_DATA::nn(z,j)
       b1  = GAUSSIAN_DATA::index_m1(j)
       PBi          = PB(z)
       PAi          = PA(z)
       if (lzb < 3) then
         overlap(j,1) = PAi * overlap(b1,1)
         kei(j,1)     = PAi * kei(b1,1) + zz2 * overlap(j,1)
         overlap(1,j) = PBi * overlap(1,b1)
         kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
       else
         nb           = lzb - 2
         zinv2_nb     = zinv2 * nb
         b2 = GAUSSIAN_DATA::index_m1(b1)
         overlap(j,1) = PAi * overlap(b1,1) + zinv2_nb * overlap(b2,1)
         kei(j,1)     = PAi * kei(b1,1) + zinv2_nb * kei(b2,1) + &
                        zz2 * overlap(j,1) - zz_ea * nb * overlap(b2,1)
         overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
         kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                        zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
       end
      end

      do j= a_n_comp_sum + 1, GAUSSIAN_DATA:n_comp_up_to(.b.l-.a.l)      ! s||lb to s||lb-la
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lzb = GAUSSIAN_DATA::nn(z,j)
       b1  = GAUSSIAN_DATA::index_m1(j)
       PBi          = PB(z)
       if (lzb < 3) then
         overlap(1,j) = PBi * overlap(1,b1)
         kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
       else
         nb           = lzb - 2
         zinv2_nb     = zinv2 * nb
         b2 = GAUSSIAN_DATA::index_m1(b1)
         overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
         kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                        zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
       end
      end

      lbub = .b.l - .a.l
      do la = 1, .a.l
       la1_n_comp_sum = GAUSSIAN_DATA:n_comp_up_to(la-1) + 1
       la_n_comp_sum  = GAUSSIAN_DATA:n_comp_up_to(la)
       lbub           = lbub + 1
       do lb = 1, lbub
         lb1_n_comp_sum = GAUSSIAN_DATA:n_comp_up_to(lb-1)+1
         lb_n_comp_sum  = GAUSSIAN_DATA:n_comp_up_to(lb)
         do b = lb1_n_comp_sum, lb_n_comp_sum
           z   = GAUSSIAN_DATA::first_nonzero(b)
           lzb = GAUSSIAN_DATA::nn(z,b)
           b1  = GAUSSIAN_DATA::index_m1(b)
           PBi          = PB(z)
           if (lzb == 2) then
             do a = la1_n_comp_sum, la_n_comp_sum
               lza = GAUSSIAN_DATA::nn(z,a)
               if (lza == 1) then
                 overlap(a,b) = PBi * overlap(a,b1)
                 kei(a,b)     = PBi * kei(a,b1) + zz2 * overlap(a,b)
               else
                 a_momenta    = GAUSSIAN_DATA::nn(:,a)
                 a_momenta(z) = a_momenta(z) - 1
                 a1  = GAUSSIAN_DATA::index_of(a_momenta(1),a_momenta(2),a_momenta(3))
                 na           = lza - 1
                 zinv2_na     = zinv2 * na
                 overlap(a,b) = PBi * overlap(a,b1) + zinv2_na * overlap(a1,b1)
                 kei(a,b)     = PBi * kei(a,b1) + zinv2_na * kei(a1,b1) + &
                                zz2 * overlap(a,b)
               end
             end
           else
             nb           = lzb - 2
             zinv2_nb     = zinv2 * nb
             zz_eb_nb     = zz_eb * nb
             b2 = GAUSSIAN_DATA::index_m1(b1)
             do a = la1_n_comp_sum, la_n_comp_sum
               lza = GAUSSIAN_DATA::nn(z,a)
               if (lza==1) then
                 overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2)
                 kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2)+ &
                                zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
               else
                 a_momenta    = GAUSSIAN_DATA::nn(:,a)
                 a_momenta(z) = a_momenta(z) - 1
                 a1  = GAUSSIAN_DATA::index_of(a_momenta(1),a_momenta(2),a_momenta(3))
                 na           = lza - 1
                 zinv2_na     = zinv2 * na
                 overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2) +&
                                zinv2_na * overlap(a1,b1)
                 kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2) + &
                                zinv2_na * kei(a1,b1) + &
                                zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
               end
             end
           end
         end
       end
      end
   end

   get_nuc(ab,mass_c,pos_c)
   ! Calculate ab, which is either  a cartesian or a spherical
   ! block of integrals.
      self :: IN
      ab :: MAT{REAL}, INOUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN

      W :: MAT{REAL}*

      if (NOT .is_spherical) then
         .get_nuc_c(ab,mass_c,pos_c)
      else if (.l_max<2) then
         .get_nuc_c(ab,mass_c,pos_c)
      else
         W.create(.a.n_comp,.b.n_comp)
         .get_nuc_c(W,mass_c,pos_c)
         .change_to_spherical(W,ab)
         W.destroy
      end

   end

   get_nuc_c(ab,mass_c,pos_c)
   ! Calculate the nuclear attraction matrix for the two shells with the
   ! nucleus at c.
      ab :: MAT{REAL}, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN
      es :: VEC{REAL}*
      ss :: REAL
      n :: INT

      if (.l_sum==0) then  
      
         ! ss
         .make_nuc_ss(ss,mass_c,pos_c)
         ab(1,1)=ss

      else if (.l_sum==1) then 
      
         ! ps or sp
         .make_nuc_ps(ab,mass_c,pos_c)

      else if (.l_max==1) then

         ! pp
         .make_nuc_pp(ab,mass_c,pos_c)

      else if (.l_sum==2 AND .l_max==2) then 
      
         ! ds or sd
         .make_nuc_ds(ab,mass_c,pos_c)

      else if (.l_sum==3 AND .l_max==1) then 
      
         ! dp or pd
         .make_nuc_dp(ab,mass_c,pos_c)

      else

         ! General case
         n = GAUSSIAN_DATA:n_comp_up_to(.l_sum) &
           - GAUSSIAN_DATA:n_comp_up_to(.l_max-1)
         es.create(n)
         .make_nuc_es(es,mass_c,pos_c)
         .transfer(es,ab)
         es.destroy

      end

   end

   make_nuc_es(es,mass_c,pos_c) ::: private
   ! Make the (es) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
      self :: IN
      es :: VEC{REAL}, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN

      Ixa,Iya,Iza :: MAT{REAL}*
      Ix,Iy,Iz :: VEC{REAL}*
      rys :: RYS@
      rzt,ce,e1_ce,rho_zinv,half_zinv,Ix2,Iy2,Iz2,wt :: REAL
      QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
      Ixe,Iye,Ize,Ixe1,Iye1,Ize1,Ixep1,Iyep1,Izep1 :: REAL
      ag,bg,e,ep1,n_roots,i,j,n,n_sum :: INT

      if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
      else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRD))
      end
      eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

      n_roots=(.l_sum+2)/2
      n_sum = n_roots * .a.n_cc * .b.n_cc
      rys.create(n_roots)
      Ixa.create(n_sum,.l_sum+1)
      Iya.create(n_sum,.l_sum+1)
      Iza.create(n_sum,.l_sum+1)

      two_pi=TWO*PI
      i = 0
      j = 0
      do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .contraction_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv

         do n = 1, n_roots
           j = j + 1
           Ix => Ixa(j,:)
           Iy => Iya(j,:)
           Iz => Iza(j,:)
           wt = rys.weight(n)
           Ix(1) = ONE
           Iy(1) = ONE
           Iz(1) = wt
           if (.l_sum>0) then
              rzt   = rys.root(n)*rho_zinv
              Ix2 = PAx+rzt*QPx
              Iy2 = PAy+rzt*QPy
              Iz2 = PAz+rzt*QPz
              Ix(2) = Ix2;    Iy(2) = Iy2;    Iz(2) = Iz2 * wt
              if (.l_sum>1) then
                ce    = (ONE-rzt)*half_zinv
                Ixep1 = Ix2*Ix2+ce
                Iyep1 = Iy2*Iy2+ce
                Izep1 = Iz2*Iz2+ce
                Ix(3) = Ixep1
                Iy(3) = Iyep1
                Iz(3) = Izep1 * wt
                if (.l_sum>2) then
                  Ixe1 = Ix2;      Iye1 = Iy2;      Ize1 = Iz2
                  Ixe = Ixep1;     Iye = Iyep1;     Ize = Izep1
                  e1_ce = ce
                  do e = 3,.l_sum
                    ep1   = e+1
                  ! e1_ce = (e-1)*ce
                    e1_ce = e1_ce+ce
                    Ixep1 = Ix2*Ixe+e1_ce*Ixe1
                    Iyep1 = Iy2*Iye+e1_ce*Iye1
                    Izep1 = Iz2*Ize+e1_ce*Ize1
                    Ix(ep1) = Ixep1; Iy(ep1) = Iyep1; Iz(ep1) = Izep1 * wt
                    Ixe1 = Ixe;      Iye1 = Iye;      Ize1 = Ize
                    Ixe = Ixep1;     Iye = Iyep1;     Ize = Izep1
                  end
                end
              end
           end
         end
       end
      end

      .combine_nuc_2d_ints(es,Ixa,Iya,Iza,Iza(:,1))

      Iza.destroy
      Iya.destroy
      Ixa.destroy
      rys.destroy
   end

   combine_nuc_2d_ints(es,Ix,Iy,Iz,wt) ::: private
   ! Sum the Ix, Iy, and Iz 2d-integrals to get the (e|s) integrals.
      es :: VEC{REAL}
      Ix,Iy,Iz :: MAT{REAL}, IN
      wt :: VEC{REAL}, IN
      Ixy :: VEC{REAL}*
      ex,ey,ez, exyz0,eyz0,exz0,exy0,ez0,ey0,ex0,en0,erms :: VEC{INT}*
      exy_rms :: VEC{VEC_{INT}}*
      er :: RMS_INDICES*
      ee,em,e,xe,ye,ze,f,l :: INT

      f = .first_gaussian
      l = .last_gaussian
      ex => GAUSSIAN_DATA::nx(f:l); ey => GAUSSIAN_DATA::ny(f:l); ez => GAUSSIAN_DATA::nz(f:l)
      er => GAUSSIAN_DATA::rms_indices(.l_max,.l_min)
      exyz0 => er.xyz0
      eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
      ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
      en0   => er.n0
      do ee = 1,exyz0.dim
        e  = exyz0(ee)
        es(e) = sum(wt)
      end
      do ee = 1,eyz0.dim
        e  = eyz0(ee)
        xe = ex(e)
        es(e) = sum(Ix(:,xe)*wt)
      end
      do ee = 1,exz0.dim
        e  = exz0(ee)
        ye = ey(e)
        es(e) = sum(Iy(:,ye)*wt)
      end
      do ee = 1,exy0.dim
        e  = exy0(ee)
        ze = ez(e)
        es(e) = sum(Iz(:,ze)   )
      end
      do ee = 1,ez0.dim
        e  = ez0(ee)
        xe = ex(e)
        ye = ey(e)
        es(e) = sum(Ix(:,xe)*Iy(:,ye)*wt      )
      end
      do ee = 1,ey0.dim
        e  = ey0(ee)
        xe = ex(e)
        ze = ez(e)
        es(e) = sum(Ix(:,xe)         *Iz(:,ze))
      end
      do ee = 1,ex0.dim
        e  = ex0(ee)
        ye = ey(e)
        ze = ez(e)
        es(e) = sum(         Iy(:,ye)*Iz(:,ze))
      end
      exy_rms => er.xy_rms_n
      if (exy_rms.dim==en0.dim) then
        do ee = 1,en0.dim
           e  = en0(ee)
           xe = ex(e); ye = ey(e); ze = ez(e)
           es(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
        end
      else if (exy_rms.dim>0) then
        Ixy.create(Ix.dim1)
        do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
           erms => exy_rms(ee).element
           e  = en0(erms(1))
           xe = ex(e)
           ye = ey(e)
           ze = ez(e)
           Ixy = Ix(:,xe)*Iy(:,ye)
           es(e) = sum(Ixy*Iz(:,ze))
           do em = 2,erms.dim
              e = en0(erms(em))
              ze = ez(e)
              es(e) = sum(Ixy*Iz(:,ze))
           end
        end
        Ixy.destroy
      end
   end

   make_nuc_dp(dp,mass_c,pos_c) ::: private
   ! Make the (dp) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
      self :: IN
      dp :: MAT{REAL}, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN

      rys :: RYS@
      rzt,ce,rho_zinv,half_zinv,wt :: REAL
      QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
      Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,two_ce,ABx,ABy,ABz :: REAL
      dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s,fxxx_s,fyyy_s,fzzz_s :: REAL
      fxxy_s,fxxz_s,fxyy_s,fyyz_s,fxzz_s,fyzz_s,fxyz_s :: REAL
      ag,bg,i,j,n :: INT

      if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
      else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRD))
      end
      eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

      rys.create(2)

      two_pi=TWO*PI
      i = 0
      j = 0
      dxx_s = ZERO;  dyy_s = ZERO;  dzz_s = ZERO
      dxy_s = ZERO;  dxz_s = ZERO;  dyz_s = ZERO
      fxxx_s = ZERO; fyyy_s = ZERO; fzzz_s = ZERO
      fxxy_s = ZERO; fxxz_s = ZERO; fxyy_s = ZERO
      fyyz_s = ZERO; fxzz_s = ZERO; fyzz_s = ZERO
      fxyz_s = ZERO
      do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .contraction_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv

         do n = 1, 2
           j = j + 1
           wt = rys.weight(n)
           rzt   = rys.root(n)*rho_zinv
           ce    = (ONE-rzt)*half_zinv
           Ix2 = PAx+rzt*QPx
           Iy2 = PAy+rzt*QPy
           Iz2 = PAz+rzt*QPz
           Ix3 = Ix2*Ix2+ce
           Iy3 = Iy2*Iy2+ce
           Iz3 = (Iz2*Iz2+ce)*wt
           Iz2 = Iz2 * wt
           two_ce = ce+ce
           dxx_s  = dxx_s  + Ix3 * wt
           dyy_s  = dyy_s  + Iy3 * wt
           dzz_s  = dzz_s  + Iz3
           dxy_s  = dxy_s  + Ix2 * Iy2 * wt
           dxz_s  = dxz_s  + Ix2 * Iz2
           dyz_s  = dyz_s  + Iy2 * Iz2
           fxxx_s = fxxx_s + Ix2*(Ix3+two_ce) * wt
           fyyy_s = fyyy_s + Iy2*(Iy3+two_ce) * wt
           fzzz_s = fzzz_s + Iz2*(Iz3+two_ce) * wt
           fxxy_s = fxxy_s + Ix3 * Iy2 * wt
           fxxz_s = fxxz_s + Ix3 * Iz2
           fxyy_s = fxyy_s + Ix2 * Iy3 * wt
           fyyz_s = fyyz_s + Iy3 * Iz2
           fxzz_s = fxzz_s + Ix3 * Iz3
           fyzz_s = fyzz_s + Iy2 * Iz3
           fxyz_s = fxyz_s + Ix2 * Iy2 * Iz2
         end
       end
      end

      if (.same_center) then
       if (.a.l==2) then
         dp(1,1) = fxxx_s
         dp(2,1) = fxyy_s
         dp(3,1) = fxzz_s
         dp(4,1) = fxxy_s
         dp(5,1) = fxxz_s
         dp(6,1) = fxyz_s
         dp(1,2) = fxxy_s
         dp(2,2) = fyyy_s
         dp(3,2) = fyzz_s
         dp(4,2) = fxyy_s
         dp(5,2) = fxyz_s
         dp(6,2) = fyyz_s
         dp(1,3) = fxxz_s
         dp(2,3) = fyyz_s
         dp(3,3) = fzzz_s
         dp(4,3) = fxyz_s
         dp(5,3) = fxzz_s
         dp(6,3) = fyzz_s
       else
         dp(1,1) = fxxx_s
         dp(1,2) = fxyy_s
         dp(1,3) = fxzz_s
         dp(1,4) = fxxy_s
         dp(1,5) = fxxz_s
         dp(1,6) = fxyz_s
         dp(2,1) = fxxy_s
         dp(2,2) = fyyy_s
         dp(2,3) = fyzz_s
         dp(2,4) = fxyy_s
         dp(2,5) = fxyz_s
         dp(2,6) = fyyz_s
         dp(3,1) = fxxz_s
         dp(3,2) = fyyz_s
         dp(3,3) = fzzz_s
         dp(3,4) = fxyz_s
         dp(3,5) = fxzz_s
         dp(3,6) = fyzz_s
       end
      else
       if (.a.l==2) then
         ABx = .a.position(1) - .b.position(1)
         ABy = .a.position(2) - .b.position(2)
         ABz = .a.position(3) - .b.position(3)
         dp(1,1) = fxxx_s + ABx * dxx_s
         dp(2,1) = fxyy_s + ABx * dyy_s
         dp(3,1) = fxzz_s + ABx * dzz_s
         dp(4,1) = fxxy_s + ABx * dxy_s
         dp(5,1) = fxxz_s + ABx * dxz_s
         dp(6,1) = fxyz_s + ABx * dyz_s
         dp(1,2) = fxxy_s + ABy * dxx_s
         dp(2,2) = fyyy_s + ABy * dyy_s
         dp(3,2) = fyzz_s + ABy * dzz_s
         dp(4,2) = fxyy_s + ABy * dxy_s
         dp(5,2) = fxyz_s + ABy * dxz_s
         dp(6,2) = fyyz_s + ABy * dyz_s
         dp(1,3) = fxxz_s + ABz * dxx_s
         dp(2,3) = fyyz_s + ABz * dyy_s
         dp(3,3) = fzzz_s + ABz * dzz_s
         dp(4,3) = fxyz_s + ABz * dxy_s
         dp(5,3) = fxzz_s + ABz * dxz_s
         dp(6,3) = fyzz_s + ABz * dyz_s
       else
         ABx = .b.position(1) - .a.position(1)
         ABy = .b.position(2) - .a.position(2)
         ABz = .b.position(3) - .a.position(3)
         dp(1,1) = fxxx_s + ABx * dxx_s
         dp(1,2) = fxyy_s + ABx * dyy_s
         dp(1,3) = fxzz_s + ABx * dzz_s
         dp(1,4) = fxxy_s + ABx * dxy_s
         dp(1,5) = fxxz_s + ABx * dxz_s
         dp(1,6) = fxyz_s + ABx * dyz_s
         dp(2,1) = fxxy_s + ABy * dxx_s
         dp(2,2) = fyyy_s + ABy * dyy_s
         dp(2,3) = fyzz_s + ABy * dzz_s
         dp(2,4) = fxyy_s + ABy * dxy_s
         dp(2,5) = fxyz_s + ABy * dxz_s
         dp(2,6) = fyyz_s + ABy * dyz_s
         dp(3,1) = fxxz_s + ABz * dxx_s
         dp(3,2) = fyyz_s + ABz * dyy_s
         dp(3,3) = fzzz_s + ABz * dzz_s
         dp(3,4) = fxyz_s + ABz * dxy_s
         dp(3,5) = fxzz_s + ABz * dxz_s
         dp(3,6) = fyzz_s + ABz * dyz_s
       end
      end

      rys.destroy
   end

   make_nuc_ds(ds,mass_c,pos_c) ::: private
   ! Make the (ds) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
      self :: IN
      ds :: MAT{REAL}, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN
      rys :: RYS@

      rzt,ce,rho_zinv,half_zinv,Ix2,Iy2,Iz2,wt,Iz2_wt :: REAL
      QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
      dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
      ag,bg,i,n :: INT

      if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
      else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRD))
      end
      eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

      rys.create(2)
      two_pi=TWO*PI
      dxx_s = ZERO;    dyy_s = ZERO;    dzz_s = ZERO
      dxy_s = ZERO;    dxz_s = ZERO;    dyz_s = ZERO
      i = 0
      do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .contraction_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv
         do n = 1,2
           wt = rys.weight(n)
           rzt   = rys.root(n)*rho_zinv
           Ix2 = PAx+rzt*QPx
           Iy2 = PAy+rzt*QPy
           Iz2 = PAz+rzt*QPz
           ce  = (ONE-rzt)*half_zinv
           Iz2_wt = Iz2 * wt
           dxx_s = dxx_s + (Ix2*Ix2+ce) * wt
           dyy_s = dyy_s + (Iy2*Iy2+ce) * wt
           dzz_s = dzz_s + (Iz2*Iz2+ce) * wt
           dxy_s = dxy_s + Ix2 * Iy2    * wt
           dxz_s = dxz_s + Ix2 *      Iz2_wt
           dyz_s = dyz_s +      Iy2 * Iz2_wt
         end
       end
      end
      rys.destroy
      if (.a.l==2) then
       ds(1,1) = dxx_s
       ds(2,1) = dyy_s
       ds(3,1) = dzz_s
       ds(4,1) = dxy_s
       ds(5,1) = dxz_s
       ds(6,1) = dyz_s
      else
       ds(1,1) = dxx_s
       ds(1,2) = dyy_s
       ds(1,3) = dzz_s
       ds(1,4) = dxy_s
       ds(1,5) = dxz_s
       ds(1,6) = dyz_s
      end
   end

   make_nuc_pp(pp,mass_c,pos_c) ::: private
   ! Make the (es) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
      self :: IN
      pp :: MAT{REAL}, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN

      rys :: RYS@
      rzt,ce,rho_zinv,half_zinv,Ix2,Iy2,Iz2,wt,Iy2_wt,Iz2_wt :: REAL
      QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
      BAx,BAy,BAz,px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
      ag,bg,i,n :: INT

      if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
      else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRD))
      end
      eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

      rys.create(2)

      two_pi=TWO*PI
      i = 0
      px_s = ZERO;   py_s = ZERO;   pz_s = ZERO
      dxx_s = ZERO;   dyy_s = ZERO;   dzz_s = ZERO
      dxy_s = ZERO;   dxz_s = ZERO;   dyz_s = ZERO
      do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .contraction_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv

         do n = 1,2
           wt = rys.weight(n)
           rzt = rys.root(n)*rho_zinv
           Ix2 = PAx+rzt*QPx
           Iy2 = PAy+rzt*QPy
           Iz2 = PAz+rzt*QPz
           ce  = (ONE-rzt)*half_zinv
           Iz2_wt = Iz2 * wt
           Iy2_wt = Iy2 * wt
           px_s = px_s + Ix2 * wt
           py_s = py_s + Iy2_wt
           pz_s = pz_s + Iz2_wt
           dxx_s = dxx_s + (Ix2*Ix2+ce) * wt
           dyy_s = dyy_s + (Iy2*Iy2+ce) * wt
           dzz_s = dzz_s + (Iz2*Iz2+ce) * wt
           dxy_s = dxy_s + Ix2 * Iy2_wt
           dxz_s = dxz_s + Ix2 * Iz2_wt
           dyz_s = dyz_s + Iy2 * Iz2_wt
         end
       end
      end
      rys.destroy

      if (.same_center) then
       pp(1,1) = dxx_s
       pp(1,2) = dxy_s
       pp(1,3) = dxz_s
       pp(2,1) = dxy_s
       pp(2,2) = dyy_s
       pp(2,3) = dyz_s
       pp(3,1) = dxz_s
       pp(3,2) = dyz_s
       pp(3,3) = dzz_s
      else
       BAx = .b.position(1) - .a.position(1)
       BAy = .b.position(2) - .a.position(2)
       BAz = .b.position(3) - .a.position(3)
       pp(1,1) = dxx_s + BAx * px_s
       pp(1,2) = dxy_s + BAx * py_s
       pp(1,3) = dxz_s + BAx * pz_s
       pp(2,1) = dxy_s + BAy * px_s
       pp(2,2) = dyy_s + BAy * py_s
       pp(2,3) = dyz_s + BAy * pz_s
       pp(3,1) = dxz_s + BAz * px_s
       pp(3,2) = dyz_s + BAz * py_s
       pp(3,3) = dzz_s + BAz * pz_s
      end
   end

   make_nuc_ps(ps,mass_c,pos_c) ::: private
   ! Make the (ps) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
      self :: IN
      ps :: MAT{REAL}, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN

      rys :: RYS@
      rzt,wt :: REAL
      QPx,QPy,QPz,PAx,PAy,PAz,zeta,rho,xx,eta_c,two_pi,ps_x,ps_y,ps_z :: REAL
      ag,bg,i :: INT

      if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
      else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRD))
      end
      eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

      rys.create(1)

      two_pi=TWO*PI
      i = 0
      ps_x = ZERO;   ps_y = ZERO;   ps_z = ZERO
      do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         wt = rys.weight(1) * (two_pi * .contraction_prefactor(i) * sqrt(rho))
         rzt   = rys.root(1) * rho * .exponent_inv(i)
         ps_x = ps_x + (PAx+rzt*QPx) * wt
         ps_y = ps_y + (PAy+rzt*QPy) * wt
         ps_z = ps_z + (PAz+rzt*QPz) * wt
       end
      end
      if (.a.l==1) then
       ps(1,1) = ps_x
       ps(2,1) = ps_y
       ps(3,1) = ps_z
      else
       ps(1,1) = ps_x
       ps(1,2) = ps_y
       ps(1,3) = ps_z
      end
      rys.destroy
   end

   make_nuc_ss(es,mass_c,pos_c) ::: private
   ! Make the (ss) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
      self :: IN
      es :: REAL, OUT
      mass_c :: REAL, IN
      pos_c :: VEC{REAL}(3), IN

      rys :: RYS@
      QPx,QPy,QPz,zeta,rho,xx,eta_c,two_pi :: REAL
      ag,bg,i :: INT

      if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
      else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRD))
      end
      eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

      rys.create(1)
      two_pi=TWO*PI
      es = ZERO
      i = 0
      do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         es    = es + (two_pi * .contraction_prefactor(i) * sqrt(rho)) * rys.weight(1)
       end
      end
      rys.destroy
   end

   transfer(es,ab)
   ! Applies the transfer equation to (e|s) to give (a|b)
      self :: IN
      es :: VEC{REAL}, IN
      ab :: MAT{REAL}, OUT

      if (.same_center) then
         if (.a.l > .b.l) then; .transfer_l_a_same(es,ab)
         else;                  .transfer_l_b_same(es,ab)
         end
      else
         if (.a.l > .b.l) then; .transfer_l_a_high(es,ab)
         else;                  .transfer_l_b_high(es,ab)
         end
      end

   end

   transfer_l_a_same(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell a has the higher
   ! angular momentum. This version when a and b have the same center.
      self :: IN
      es :: VEC{REAL}, IN
      ab :: MAT{REAL}, OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
   ENSURE(es.dim ==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT{REAL}*
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,t :: INT
      select case (.b.l)
        case (0)                               ! (a|s) case
           ab(:,1) = es
        case (1)
           if (.a.l==1) then                   ! (p|p) case
              ab(1,1) = es(4)
              ab(1,2) = es(7)
              ab(1,3) = es(8)
              ab(2,1) = es(7)
              ab(2,2) = es(5)
              ab(2,3) = es(9)
              ab(3,1) = es(8)
              ab(3,2) = es(9)
              ab(3,3) = es(6)
           else                                ! (a|p) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)        ! Offset into the index array
              do a = 1,na                      ! Put es straight to ab
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 ab(a,1) = es(a1)
                 ab(a,2) = es(a2)
                 ab(a,3) = es(a3)
              end
           end
        case default                           ! general (a|b) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
           na = es.dim - GAUSSIAN_DATA:n_comp(.l_sum)        ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na                      ! Start with p shell on a
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 int_new(a,1) = es(a1)
                 int_new(a,2) = es(a2)
                 int_new(a,3) = es(a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                          ! Previous offset for b, in int_old
              fb = fb + nb                     ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)       ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    int_new(a,b) = int_old(a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                   ! Final transfer into (a|b)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    ab(a,b) = int_old(a1,b1)
                 end
               end
               int_old.destroy
        end ! case statement
   end

   transfer_l_b_same(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell b has the higher
   ! angular momentum. This version when a and b have the same center.
      self :: IN
      es :: VEC{REAL}, IN
      ab :: MAT{REAL}, OUT
   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
   ENSURE(es.dim ==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT{REAL}*
      a,b,a1,b1,b2,b3,bb,l,na,fa,pa,nb,fb,t :: INT
      select case (.a.l)
        case (0)                               ! (s|b) case
           ab(1,:) = es
        case (1)
           if (.b.l==1) then                   ! (p|p) case
              ab(1,1) = es(4)
              ab(2,1) = es(7)
              ab(3,1) = es(8)
              ab(1,2) = es(7)
              ab(2,2) = es(5)
              ab(3,2) = es(9)
              ab(1,3) = es(8)
              ab(2,3) = es(9)
              ab(3,3) = es(6)
           else                                ! (p|b) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)        ! Offset into the index array
              do b = 1,nb                      ! Put es straight to ab
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 ab(1,b) = es(b1)
                 ab(2,b) = es(b2)
                 ab(3,b) = es(b3)
              end
           end
       case default
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
           nb = es.dim - GAUSSIAN_DATA:n_comp(.l_sum)        ! No. of b's in int_new goes down
           int_new.create(nb,3)                ! NOTE: int_new ia transposed
              do b = 1,nb                      ! Start with p shell on a
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 int_new(b,1) = es(b1)
                 int_new(b,2) = es(b2)
                 int_new(b,3) = es(b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                          ! Previous offset for a, in int_old
              fa = fa + na                     ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)            ! TRANSPOSED!
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)       ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    int_new(b,a) = int_old(b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                   ! Final transfer into (a|b)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    ab(a,b) = int_old(b1,a1)
                 end
              end
              int_old.destroy
        end ! case statement
   end

   transfer_l_a_high(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell a has the higher
   ! angular momentum. NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      es :: VEC{REAL}, IN
      ab :: MAT{REAL}, OUT

   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
   ENSURE(es.dim ==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.associated,"no indexing arrays")

      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,es_a :: REAL
      a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,t :: INT

      select case (.b.l)
        case (0)                               ! (a|s) case
           ab(:,1) = es
        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                   ! (p|p) case
              es_a = es(1)
              ab(1,1) = es(4) + R1*es_a
              ab(1,2) = es(7) + R2*es_a
              ab(1,3) = es(8) + R3*es_a
              es_a = es(2)
              ab(2,1) = es(7) + R1*es_a
              ab(2,2) = es(5) + R2*es_a
              ab(2,3) = es(9) + R3*es_a
              es_a = es(3)
              ab(3,1) = es(8) + R1*es_a
              ab(3,2) = es(9) + R2*es_a
              ab(3,3) = es(6) + R3*es_a
           else                                ! (a|p) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)        ! Offset into the index array
              do a = 1,na                      ! Put es straight to ab
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 es_a = es(a)
                 ab(a,1) = es(a1) + R1*es_a
                 ab(a,2) = es(a2) + R2*es_a
                 ab(a,3) = es(a3) + R3*es_a
              end
           end
        case default                           ! general (a|b) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
           na = es.dim - GAUSSIAN_DATA:n_comp(.l_sum)        ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na                      ! Start with p shell on a
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 es_a = es(a)
                 int_new(a,1) = es(a1) + R1*es_a
                 int_new(a,2) = es(a2) + R2*es_a
                 int_new(a,3) = es(a3) + R3*es_a
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                          ! Previous offset for b, in int_old
              fb = fb + nb                     ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)       ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    int_new(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                   ! Final transfer into (a|b)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    ab(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
               end
               int_old.destroy
        end ! case statement

   end

   transfer_l_b_high(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell b has the higher
   ! angular momentum. NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      es :: VEC{REAL}, IN
      ab :: MAT{REAL}, OUT
   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
   ENSURE(es.dim ==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT{REAL}*
      R :: VEC{REAL}(3)
      Rt,R1,R2,R3,es_b :: REAL
      a,b,a1,b1,b2,b3,bb,l,na,fa,pa,nb,fb,t :: INT
      select case (.a.l)
        case (0)                               ! (s|b) case
           ab(1,:) = es
        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                   ! (p|p) case
              es_b = es(1)
              ab(1,1) = es(4) + R1*es_b
              ab(2,1) = es(7) + R2*es_b
              ab(3,1) = es(8) + R3*es_b
              es_b = es(2)
              ab(1,2) = es(7) + R1*es_b
              ab(2,2) = es(5) + R2*es_b
              ab(3,2) = es(9) + R3*es_b
              es_b = es(3)
              ab(1,3) = es(8) + R1*es_b
              ab(2,3) = es(9) + R2*es_b
              ab(3,3) = es(6) + R3*es_b
           else                                ! (p|b) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)        ! Offset into the index array
              do b = 1,nb                      ! Put es straight to ab
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 es_b = es(b)
                 ab(1,b) = es(b1) + R1*es_b
                 ab(2,b) = es(b2) + R2*es_b
                 ab(3,b) = es(b3) + R3*es_b
              end
           end
       case default
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
           nb = es.dim - GAUSSIAN_DATA:n_comp(.l_sum)        ! No. of b's in int_new goes down
           int_new.create(nb,3)                ! NOTE: int_new ia transposed
              do b = 1,nb                      ! Start with p shell on a
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 es_b = es(b)
                 int_new(b,1) = es(b1) + R1*es_b
                 int_new(b,2) = es(b2) + R2*es_b
                 int_new(b,3) = es(b3) + R3*es_b
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                          ! Previous offset for a, in int_old
              fa = fa + na                     ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)            ! TRANSPOSED!
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)       ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    int_new(b,a) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                   ! Final transfer into (a|b)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    ab(a,b) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
        end ! case statement
   end

   transfer_ft(es,ab)
   ! Applies the transfer equation to (e|s) to give (a|b)
      self :: IN
      es :: MAT{CPX}, IN
      ab :: MAT3{CPX}, OUT
      if (.same_center) then
        if (.a.l > .b.l) then; .transfer_l_a_same_ft(es,ab)
        else;                  .transfer_l_b_same_ft(es,ab)
        end
      else
        if (.a.l > .b.l) then; .transfer_l_a_high_ft(es,ab)
        else;                  .transfer_l_b_high_ft(es,ab)
        end
      end
   end

   transfer_l_a_same_ft(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell a has the higher
   ! angular momentum. This version when a and b have the same center.
      self :: IN
      es :: MAT{CPX}, IN
      ab :: MAT3{CPX}, OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
   ENSURE(es.dim2==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim2==.a.n_comp,"wrong 2nd dimension, ab")
   ENSURE(ab.dim3==.b.n_comp,"wrong 3rd dimension, ab")
   ENSURE(ab.dim1==es.dim1,"incompatible ab and es")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT3{CPX}*
      nk,a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,t :: INT
      nk = es.dim1
      select case (.b.l)
        case (0)                               ! (a|s) case
           ab(:,:,1) = es
        case (1)
           if (.a.l==1) then                   ! (p|p) case
              ab(:,1,1) = es(:,4)
              ab(:,1,2) = es(:,7)
              ab(:,1,3) = es(:,8)
              ab(:,2,1) = es(:,7)
              ab(:,2,2) = es(:,5)
              ab(:,2,3) = es(:,9)
              ab(:,3,1) = es(:,8)
              ab(:,3,2) = es(:,9)
              ab(:,3,3) = es(:,6)
           else                                ! (a|p) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)        ! Offset into the index array
              do a = 1,na                      ! Put es straight to ab
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 ab(:,a,1) = es(:,a1)
                 ab(:,a,2) = es(:,a2)
                 ab(:,a,3) = es(:,a3)
              end
           end
        case default                           ! general (a|b) case
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
           na = es.dim2 - GAUSSIAN_DATA:n_comp(.l_sum)       ! No. of a's in int_new goes down
           int_new.create(nk,na,3)
              do a = 1,na                      ! Start with p shell on a
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 int_new(:,a,1) = es(:,a1)
                 int_new(:,a,2) = es(:,a2)
                 int_new(:,a,3) = es(:,a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                          ! Previous offset for b, in int_old
              fb = fb + nb                     ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed b's
              int_old => int_new
              int_new.create(nk,na,nb)
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)       ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    int_new(:,a,b) = int_old(:,a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                   ! Final transfer into (a|b)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    ab(:,a,b) = int_old(:,a1,b1)
                 end
               end
               int_old.destroy
        end ! case statement
   end

   transfer_l_b_same_ft(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell b has the higher
   ! angular momentum. This version when a and b have the same center.
      self :: IN
      es :: MAT{CPX}, IN
      ab :: MAT3{CPX}, OUT
   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
   ENSURE(es.dim2==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim2==.a.n_comp,"wrong 2nd dimension, ab")
   ENSURE(ab.dim3==.b.n_comp,"wrong 3rd dimension, ab")
   ENSURE(ab.dim1==es.dim1,"incompatible ab and es")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT3{CPX}*
      nk,a,b,a1,b1,b2,b3,bb,l,na,fa,pa,nb,fb,t :: INT
      nk = es.dim1
      select case (.a.l)
        case (0)                               ! (s|b) case
           ab(:,1,:) = es
        case (1)
           if (.b.l==1) then                   ! (p|p) case
              ab(:,1,1) = es(:,4)
              ab(:,2,1) = es(:,7)
              ab(:,3,1) = es(:,8)
              ab(:,1,2) = es(:,7)
              ab(:,2,2) = es(:,5)
              ab(:,3,2) = es(:,9)
              ab(:,1,3) = es(:,8)
              ab(:,2,3) = es(:,9)
              ab(:,3,3) = es(:,6)
           else                                ! (p|b) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)        ! Offset into the index array
              do b = 1,nb                      ! Put es straight to ab
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 ab(:,1,b) = es(:,b1)
                 ab(:,2,b) = es(:,b2)
                 ab(:,3,b) = es(:,b3)
              end
           end
       case default
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)           ! Offset into the index array
           nb = es.dim2 - GAUSSIAN_DATA:n_comp(.l_sum)        ! No. of b's in int_new goes down
           int_new.create(nk,nb,3)                ! NOTE: int_new ia transposed
              do b = 1,nb                      ! Start with p shell on a
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 int_new(:,b,1) = es(:,b1)
                 int_new(:,b,2) = es(:,b2)
                 int_new(:,b,3) = es(:,b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                          ! Previous offset for a, in int_old
              fa = fa + na                     ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed a's
              int_old => int_new
              int_new.create(nk,nb,na)            ! TRANSPOSED!
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)       ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    int_new(:,b,a) = int_old(:,b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                   ! Final transfer into (a|b)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    ab(:,a,b) = int_old(:,b1,a1)
                 end
              end
              int_old.destroy
        end ! case statement
   end

   transfer_l_a_high_ft(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell a has the higher
   ! angular momentum. NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      es :: MAT{CPX}, target, IN
      ab :: MAT3{CPX}, OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
   ENSURE(es.dim2==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim2==.a.n_comp,"wrong 2nd dimension, ab")
   ENSURE(ab.dim3==.b.n_comp,"wrong 3rd dimension, ab")
   ENSURE(ab.dim1==es.dim1,"incompatible ab and es")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT3{CPX}*
      R :: VEC{REAL}(3)
      es_a :: VEC{CPX}*
      Rt,R1,R2,R3 :: REAL
      nk,a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,t :: INT
      nk = es.dim1
      select case (.b.l)
        case (0)                               ! (a|s) case
           ab(:,:,1) = es
        case (1)
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                   ! (p|p) case
              es_a => es(:,1)
              ab(:,1,1) = es(:,4) + R1*es_a
              ab(:,1,2) = es(:,7) + R2*es_a
              ab(:,1,3) = es(:,8) + R3*es_a
              es_a => es(:,2)
              ab(:,2,1) = es(:,7) + R1*es_a
              ab(:,2,2) = es(:,5) + R2*es_a
              ab(:,2,3) = es(:,9) + R3*es_a
              es_a => es(:,3)
              ab(:,3,1) = es(:,8) + R1*es_a
              ab(:,3,2) = es(:,9) + R2*es_a
              ab(:,3,3) = es(:,6) + R3*es_a
           else                                ! (a|p) case
              na = .a.n_comp
              fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)        ! Offset into the index array
              do a = 1,na                      ! Put es straight to ab
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 es_a => es(:,a)
                 ab(:,a,1) = es(:,a1) + R1*es_a
                 ab(:,a,2) = es(:,a2) + R2*es_a
                 ab(:,a,3) = es(:,a3) + R3*es_a
              end
           end
        case default                           ! general (a|b) case
           R  = .a.position - .b.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fa = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)           ! Offset into the index array
           na = es.dim2 - GAUSSIAN_DATA:n_comp(.l_sum)        ! No. of a's in int_new goes down
           int_new.create(nk,na,3)
              do a = 1,na                      ! Start with p shell on a
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa
                 es_a => es(:,a)
                 int_new(:,a,1) = es(:,a1) + R1*es_a
                 int_new(:,a,2) = es(:,a2) + R2*es_a
                 int_new(:,a,3) = es(:,a3) + R3*es_a
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - GAUSSIAN_DATA:n_comp(.l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                          ! Previous offset for b, in int_old
              fb = fb + nb                     ! Offset into index arrays
              nb = GAUSSIAN_DATA:n_comp(l)                   ! Make only the needed b's
              int_old => int_new
              int_new.create(nk,na,nb)
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)       ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    int_new(:,a,b) = int_old(:,a1,b1) + Rt*int_old(:,a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                   ! Final transfer into (a|b)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    ab(:,a,b) = int_old(:,a1,b1) + Rt*int_old(:,a,b1)
                 end
               end
               int_old.destroy
        end ! case statement
   end

   transfer_l_b_high_ft(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell b has the higher
   ! angular momentum. NOTE: .set_hrr_indexing_arrays must be called beforehand.
      self :: IN
      es :: MAT{CPX}, target, IN
      ab :: MAT3{CPX}, OUT
   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
   ENSURE(es.dim2==(GAUSSIAN_DATA:n_comp_up_to(.l_sum)-GAUSSIAN_DATA:n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim2==.a.n_comp,"wrong 2nd dimension, ab")
   ENSURE(ab.dim3==.b.n_comp,"wrong 3rd dimension, ab")
   ENSURE(ab.dim1==es.dim1,"incompatible ab and es")
   ENSURE(first_nonzero.associated,"no indexing arrays")
      int_new,int_old :: MAT3{CPX}*
      R :: VEC{REAL}(3)
      es_b :: VEC{CPX}*
      Rt,R1,R2,R3 :: REAL
      nk,a,b,a1,b1,b2,b3,bb,l,na,fa,pa,nb,fb,t :: INT
      nk = es.dim1
      select case (.a.l)
        case (0)                                ! (s|b) case
           ab(:,1,:) = es
        case (1)
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                    ! (p|p) case
              es_b => es(:,1)
              ab(:,1,1) = es(:,4) + R1*es_b
              ab(:,2,1) = es(:,7) + R2*es_b
              ab(:,3,1) = es(:,8) + R3*es_b
              es_b => es(:,2)
              ab(:,1,2) = es(:,7) + R1*es_b
              ab(:,2,2) = es(:,5) + R2*es_b
              ab(:,3,2) = es(:,9) + R3*es_b
              es_b => es(:,3)
              ab(:,1,3) = es(:,8) + R1*es_b
              ab(:,2,3) = es(:,9) + R2*es_b
              ab(:,3,3) = es(:,6) + R3*es_b
           else                                 ! (p|b) case
              nb = .b.n_comp
              fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1) ! Offset into the index array
              do b = 1,nb                       ! Put es straight to ab
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 es_b => es(:,b)
                 ab(:,1,b) = es(:,b1) + R1*es_b
                 ab(:,2,b) = es(:,b2) + R2*es_b
                 ab(:,3,b) = es(:,b3) + R3*es_b
              end
           end
       case default
           R  = .b.position - .a.position
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)    ! Offset into the index array
           nb = es.dim2 - GAUSSIAN_DATA:n_comp(.l_sum)  ! No. of b's in int_new goes down
           int_new.create(nk,nb,3)              ! NOTE: int_new ia transposed
              do b = 1,nb                       ! Start with p shell on a
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb
                 es_b => es(:,b)
                 int_new(:,b,1) = es(:,b1) + R1*es_b
                 int_new(:,b,2) = es(:,b2) + R2*es_b
                 int_new(:,b,3) = es(:,b3) + R3*es_b
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - GAUSSIAN_DATA:n_comp(.l_sum-l+1) ! No. of b's in int_new goes down
              pa = fa                             ! Previous offset for a, in int_old
              fa = fa + na                        ! Offset into index arrays
              na = GAUSSIAN_DATA:n_comp(l)               ! Make only the needed a's
              int_old => int_new
              int_new.create(nk,nb,na)            ! TRANSPOSED!
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)       ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    int_new(:,b,a) = int_old(:,b1,a1) + Rt*int_old(:,b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                   ! Final transfer into (a|b)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    ab(:,a,b) = int_old(:,b1,a1) + Rt*int_old(:,b,a1)
                 end
              end
              int_old.destroy
        end ! case statement
   end

! ====================================
! Normalization routines and functions
! ====================================

   change_to_spherical(C,S) ::: PURE
   ! Change a cartesian integral block "C" to a spherical integral
   ! block "S"
      self :: IN
      C :: MAT{REAL}, IN
      S :: MAT{REAL}, OUT

      W :: MAT{REAL}*
      U :: MAT{REAL}@

      if (.l_max<2) then

         S = C             ! don't use this case

      else if (.l_min>=2) then

         W.create(.a.n_comp,.b.n_sph)
         U = GAUSSIAN_DATA::spherical_harmonics_for(.b.l).element
         W.to_product_of(C,U)

         U = GAUSSIAN_DATA::spherical_harmonics_for(.a.l).element
         S.to_product_of(U,W,transpose_a=TRUE)
         W.destroy

      else if (.a.l<2 AND .b.l>=2) then

         U = GAUSSIAN_DATA::spherical_harmonics_for(.b.l).element
         S.to_product_of(C,U)

      else if (.b.l<2 AND .a.l>=2) then

         U = GAUSSIAN_DATA::spherical_harmonics_for(.a.l).element
         S.to_product_of(U,C,transpose_a=TRUE)

      end

   end

   change_to_spherical(C,S) ::: PURE
   ! Change a cartesian integral block "C" to a spherical integral
   ! block "S"
      self :: IN
      C :: MAT{CPX}, IN
      S :: MAT{CPX}, OUT

      U :: MAT{REAL}@
      W ::  MAT{CPX}*

      if (.l_max<2) then

         S = C             ! don't use this case

      else if (.l_min>=2) then

         W.create(.a.n_comp,.b.n_sph)
         U = GAUSSIAN_DATA::spherical_harmonics_for(.b.l).element
         W.to_product_of(C,U)

         U = GAUSSIAN_DATA::spherical_harmonics_for(.a.l).element
         S.to_product_of(U,W,transpose_a=TRUE)
         W.destroy

      else if (.a.l<2 AND .b.l>=2) then

         U = GAUSSIAN_DATA::spherical_harmonics_for(.b.l).element
         S.to_product_of(C,U)

      else if (.b.l<2 AND .a.l>=2) then

         U = GAUSSIAN_DATA::spherical_harmonics_for(.a.l).element
         S.to_product_of(U,C,transpose_a=TRUE)

      end

   end

   change_to_spherical(C,S) ::: PURE
   ! Change a cartesian integral block "C" to a spherical integral
   ! block "S"
      self :: IN
      C :: MAT3{CPX}, IN
      S :: MAT3{CPX}, OUT

      U :: MAT{REAL}@
      W ::  MAT3{CPX}*
      i :: INT

      do i = 1,C.dim3

         if (.l_max<2) then
        
            S = C             ! don't use this case
        
         else if (.l_min>=2) then
        
            W.create(.a.n_comp,.b.n_sph,C.dim3)
            U = GAUSSIAN_DATA::spherical_harmonics_for(.b.l).element
            W(:,:,i).to_product_of(C(:,:,i),U)
        
            U = GAUSSIAN_DATA::spherical_harmonics_for(.a.l).element
            S(:,:,i).to_product_of(U,W(:,:,i),transpose_a=TRUE)
            W.destroy
        
         else if (.a.l<2 AND .b.l>=2) then
        
            U = GAUSSIAN_DATA::spherical_harmonics_for(.b.l).element
            S(:,:,i).to_product_of(C(:,:,i),U)
        
         else if (.b.l<2 AND .a.l>=2) then
        
            U = GAUSSIAN_DATA::spherical_harmonics_for(.a.l).element
            S(:,:,i).to_product_of(U,C(:,:,i),transpose_a=TRUE)
        
         end

      end

   end


   put
   ! Put the shell2 information on file "out"
      self :: IN

      stdout.flush
      stdout.text("Shell a:")
      .a.put

      stdout.flush
      stdout.text("Shell b:")
      .b.put

      stdout.flush
      stdout.show("n_gaussian_pairs =",.n_gaussian_pairs)
      stdout.show("l_max            =",.l_max)
      stdout.show("l_min            =",.l_min)
      stdout.show("l_sum            =",.l_sum)
      stdout.show("first_gaussian   =",.first_gaussian)
      stdout.show("last_gaussian    =",.last_gaussian)
      stdout.show("n_gaussian       =",.n_gaussian)
      stdout.show("destroy_all      =",.destroy_all)
      stdout.show("same_center      =",.same_center)

      if (.exponent_sum.associated) then
      stdout.text("exponent_sum:")
      stdout.put(.exponent_sum)
      end

      if (.exponent_inv.associated) then
      stdout.text("exponent_inv:")
      stdout.put(.exponent_inv)
      end

      if (.contraction_prefactor.associated) then
      stdout.text("cc_prefactor:")
      stdout.put(.contraction_prefactor)
      end

      if (.contraction_s_prefactor.associated) then
      stdout.text("cc_s_prefactor:")
      stdout.put(.contraction_s_prefactor)
      end

      if (.contraction_p_prefactor.associated) then
      stdout.text("cc_p_prefactor:")
      stdout.put(.contraction_p_prefactor)
      end

      if (.pair_center.associated) then
      stdout.text("pair_center:")
      stdout.put(.pair_center)
      end

      if (.center_diff.associated) then
      stdout.text("center_diff:")
      stdout.put(.center_diff)
      end

   end

end
