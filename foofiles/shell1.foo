!-------------------------------------------------------------------------------
!
! SHELL1 
!
! For describing contracted cartesian gaussian shells with a position
! coordinate. Largely inherited from SHELL.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module SHELL1

   implicit none

contains

!  ==================
!  Allocation methods
!  ==================

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: get_from(SHELL), pure
   ! Nullify the pointer part of a shell object
   end

   destroy_ptr_part ::: get_from(SHELL), leaky, PURE
   ! Destroy pointer part of a shell object
   end

!  ====
!  Copy
!  ====

   create_copy(object) ::: get_from(OBJECT), leaky, PURE
   ! Create a copy of object
   end

   create_copy(shell,pos) ::: leaky, PURE
   ! Create a shell object from another copy
      self :: PTR
      shell :: SHELL1, IN
      pos :: VEC{REAL}, IN

      .create
      .copy(shell,pos)

   end

   create_copy(shell,pos) ::: leaky, PURE
   ! Create a shell object from another copy
      self :: PTR
      shell :: SHELL, IN
      pos :: VEC{REAL}, IN

      .create
      .copy(shell,pos)

   end

   copy(shell) ::: get_from(SHELL, SHELL=>SHELL1), leaky, PURE
   ! Copy a shell object. Make sure pointer parts are nullified or
   ! destroyed, as you like, before using this.
   end

   copy(shell,pos) ::: leaky, PURE
   ! Make a shell1 object from a shell1 object.
   ! The position "pos" overides "shell.position".
   ! NOTE : ensure the ptr parts have been destroyed or nullified beforehand.
      self :: OUT
      shell :: SHELL1, IN
      pos :: VEC{REAL}, IN

      .copy(shell)
      .position = pos

   end

   copy(shell) ::: leaky, PURE
   ! Make a shell1 object from the shell. The position is *not* set.
   ! NOTE : ensure the ptr parts have been destroyed beforehand.
      self :: OUT
      shell :: SHELL, IN

   ENSURE(.exponent.disassociated,"ex not destroyed")
   ENSURE(.contraction.disassociated,"cc not destroyed")
   ENSURE(.contraction_s.disassociated,"cc_s not destroyed")
   ENSURE(.contraction_p.disassociated,"cc_p not destroyed")

      .set_l(shell.l)

      .is_spherical = shell.is_spherical
      .n_cc         = shell.n_cc

      if (shell.exponent.associated)      .exponent.create_copy(shell.exponent)
      if (shell.contraction.associated)   .contraction.create_copy(shell.contraction)
      if (shell.contraction_s.associated) .contraction_s.create_copy(shell.contraction_s)
      if (shell.contraction_p.associated) .contraction_p.create_copy(shell.contraction_p)

   end

   copy(shell,pos) ::: leaky, PURE
   ! Make a SHELL1 object from the SHELL "shell" and its position "pos".
   ! NOTE : ensure the ptr parts have been destroyed beforehand.
      self :: INOUT
      shell :: SHELL, IN
      pos :: VEC{REAL}, IN

      .copy(shell)

      .position = pos

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: pure
   ! Set defaults
      self :: INOUT

      .l              = 0
      .l_chr          = " "
      .is_spherical   = SHELL_IS_SPHERICAL
      .n_cc           = 0
      .n_comp         = 0
      .n_sph          = 0
      .first_gaussian = 0
      .last_gaussian  = 0

      .position       = ZERO

   end

   set(object) ::: get_from(OBJECT)
   ! Set the object. Pointer parts are assigned not copied.
   end

   set(shell,pos)
   ! Set a shell1 object. Pointer parts are assigned not copied.
      self :: INOUT
      shell :: SHELL, optional, IN
      pos :: VEC{REAL}, optional, IN

      if (present(shell)) then
         .l              = shell.l
         .l_chr          = shell.l_chr
         .is_spherical   = shell.is_spherical
         .n_comp         = shell.n_comp
         .n_sph          = shell.n_sph
         .first_gaussian = shell.first_gaussian
         .last_gaussian  = shell.last_gaussian
         .n_cc           = shell.n_cc
         .exponent      => shell.exponent
         .contraction   => shell.contraction
         .contraction_s => shell.contraction_s
         .contraction_p => shell.contraction_p
      end

      if (present(pos)) .position = pos

   end

   set_l(l) ::: get_from(SHELL, SHELL=>SHELL1), PURE
   ! Set the l value
   end

   set_n_comp ::: get_from(SHELL, SHELL=>SHELL1), pure
   ! Set the number of components. "L" shells are a special case.
   end

   set_spherical(val) ::: get_from(SHELL), pure
   ! Set sphericals to "val"
   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the
   ! "keyword" is inputted from "stdin".
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}            "); ! exit surrounding loop
         case ("contractions="); .read_contractions
         case ("exponents=   "); .read_exponents
         case ("ex,cc=       "); .read_ex_cc
         case ("junk,ex,cc=  "); .read_junk_ex_cc
         case ("l=           "); .read_l
         case ("l_chr=       "); .read_l_chr
         case ("n_cc=        "); .read_n_cc
         case ("position=    "); .read_position
         case ("put          "); .put
         case ("spherical=   "); .read_spherical
         case ("units=       "); .read_units
         case default;         UNKNOWN(word)
      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_l ::: get_from(SHELL)
   ! Read in the l symbol
   end

   read_l_int ::: get_from(SHELL)
   ! Read in the l integer. No way to get "L" shells in this input mode.
   end

   read_l_chr ::: get_from(SHELL)
   ! Read in the l symbol
   end

   read_spherical ::: get_from(SHELL)
   ! Read in if this is a spherical shell
   end

   read_n_cc ::: get_from(SHELL)
   ! Read in the number of contraction coefficients
   end

   read_exponents ::: get_from(SHELL), leaky
   ! Read in the exponents
   end

   read_contractions ::: get_from(SHELL), leaky
   ! Read in the contraction coefficients
   end

   read_ex_cc ::: get_from(SHELL), leaky
   ! Read in the exponents and contractions
   end

   read_junk_ex_cc ::: get_from(SHELL), leaky
   ! Read in the exponents and contractions preceded by a junk string
   end

   read_position
   ! Read in the position
      stdin.read_quantity(.position)
   end

!  =====================
!  Miscellaneous methods
!  =====================

   l_chr(l) result (res) ::: get_from(SHELL), selfless, private, PURE
   ! Return a character representation for angular mtm "l"
   ! Of course, "L" shells are never returned: they have mixed mtm.
   end

   same_as(sh) result(same)
   ! Return TRUE if the shell "self" is the same as "sh".
      sh :: SHELL1
      same :: BIN

      ! Check if basic arrays are created identically
      same = .l_chr==sh.l_chr &
         AND (.is_spherical EQV sh.is_spherical) &
         AND (.exponent.associated EQV sh.exponent.associated) &
         AND (.contraction.associated EQV sh.contraction.associated) &
         AND (.contraction_s.associated EQV sh.contraction_s.associated) &
         AND (.contraction_p.associated EQV sh.contraction_p.associated) 

      ! If not, we are done
      if (NOT same) return

      ! Check position ...
      same = .position.same_as(sh.position)
      if (NOT same) return

      ! Check exponents ..
      if (.exponent.associated AND sh.exponent.associated) same = .exponent.same_as(sh.exponent) 
      if (NOT same) return

      ! Check contractions ...
      if (.l_chr/="L") then
         if (.contraction.associated   AND sh.contraction.associated)   same = .contraction.same_as(sh.contraction) 
      else
         if (.contraction_s.associated AND sh.contraction_s.associated) same = .contraction_s.same_as(sh.contraction_s) 
         if (NOT same) return
         if (.contraction_p.associated AND sh.contraction_p.associated) same = .contraction_p.same_as(sh.contraction_p) 
      end

   end

   make_contraction_matrix(ccm,ccp) ::: get_from(SHELL)
   ! Return the contraction coefficient matrix "ccm" which converts
   ! primitives to basis functions. It is with respect to uniform
   ! normalisation i.e. all components are normalised to the first
   ! component, x^l. If this is an "L" shell, "ccp" may also be
   ! returned, the contraction matrix for the "p" shell. size "ccm" is
   ! normally (.n_prim,.n_comp).
   end

   norm result (res) ::: get_from(SHELL), pure
   ! Return the norm of the shell, assuming that the existing contraction
   ! coefficients are with respect to NORMALISED primitive gaussians.
   end

   unnormalise ::: get_from(SHELL), pure
   ! Assuming the existing contraction coefficients are initially with respect
   ! to NORMALISED primitive gaussians, take out this normalisation factor of
   ! each primitive and put it in the contraction coefficient. The normalisation
   end

   renormalise ::: get_from(SHELL), PURE
   ! Assuming the existing contraction coefficients are with respect to raw
   ! UNNORMALISED primitive gaussians, put back this normalisation factor for
   end

   n_prim result (res) ::: get_from(SHELL), pure
   ! Return the number of primitive gaussians in the shell
   end

!  ============
!  Grid methods
!  ============

   r_max(cutoff) result (res) ::: get_from(SHELL), pure
   ! Return the radius where all basis functions becomes smaller than "cutoff".
   end

   r2_max(cutoff) result (res) ::: get_from(SHELL), pure
   ! Return the radius where all basis functions becomes smaller than "cutoff".
   end


   make_skip_list(skip,n_keep,r2,preskip,n_pt,cutoff) ::: pure
   ! From a list of squared distances "r2" and preskipped points
   ! "preskip" return those distances where the basis function has a
   ! significant value above "cutoff".
      self :: IN
      n_pt :: INT, IN
      skip :: VEC{BIN}(n_pt), OUT
      n_keep  :: INT, OUT
      r2      :: VEC{REAL}(n_pt), IN
      preskip :: VEC{BIN}(n_pt), IN
      cutoff  :: REAL, IN

      r2_max :: REAL
      s :: BIN
      n :: INT

      r2_max = .r2_max(cutoff)

      n_keep = 0

      do n = 1,n_pt

         s = preskip(n)
         skip(n) = s
         if (s) cycle

         s = r2(n)>r2_max
         skip(n) = s

         if (s) cycle

         n_keep = n_keep + 1

      end

   end

   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky, PURE
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      self :: IN
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN

      xx,yy,zz,rr, x0,y0,z0, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      ! Square cutoff distance
      r2_max = .r2_max(cutoff)

      ! Origin
      x0 = .position(1) 
      y0 = .position(2) 
      z0 = .position(3) 

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - x0 
         yy = pt(n,2) - y0
         zz = pt(n,3) - z0 
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy
         y.destroy
         z.destroy
         r2.destroy
      else
         x.shrink(k)
         y.shrink(k)
         z.shrink(k)
         r2.shrink(k)
      end

   end


   make_grid(F,pt) ::: PURE
   ! Return "F(i,n)", the value of the basis function "n" on grid
   ! point "i" given a set of grid points "pt(i,1:3)"
      self :: IN
      F :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

      .make_grid(F,pt(:,1),pt(:,2),pt(:,3))

   end

   make_grid(F,x,y,z) ::: PURE
   ! Return "F(i,n)", the value of the basis function "n" on grid
   ! point "i" given a set of grid points "pt(i,1:3)"
      self :: IN
      F :: MAT{REAL}, OUT
      x,y,z :: VEC{REAL}, IN

      Fc :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_grid_c(F,x,y,z)

      else if (.l<2) then

         .make_grid_c(F,x,y,z)

      else


         n_pt = x.dim
         Fc.create(n_pt,.n_comp)

         .make_grid_c(Fc,x,y,z)
         F.to_product_of(Fc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Fc.destroy

      end

   end

   make_grid_c(f,x,y,z) ::: private, PURE
   ! Return "f(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "(x(i),y(i),z(i))"
   ! Note: it is assumed that the shell is normalised to the component x^2; the
   ! appropriate double factorial normalising factors are introduced for each
   ! component (if required) so that each component is properly normalised.
      self :: IN
      f :: MAT{REAL}, OUT
      x,y,z :: VEC{REAL}, IN

   ENSURE(f.dim1==x.dim,"inconsistent f and x")
   ENSURE(f.dim1==y.dim,"inconsistent f and x")
   ENSURE(f.dim1==z.dim,"inconsistent f and x")

      bx,by,bz :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b, ff,lf :: INT
      rr,xx,yy,zz,x0,y0,z0,f0,bxb,byb,bzb :: REAL
      xx2,yy2,zz2,xx3,yy3,zz3,zz_f0 :: REAL

      n_pt = x.dim

      ! Origin
      x0 = .position(1)
      y0 = .position(2)
      z0 = .position(3)

      select case (.l)

        case (0) ! S function ...........
          do n = 1,n_pt
             xx = x(n) - x0
             yy = y(n) - y0
             zz = z(n) - z0
             rr = xx*xx + yy*yy + zz*zz
             f(n,1) = sum(.contraction * exp( -rr * .exponent ))
          end

        case (1) ! P function ...........
          do n = 1,n_pt
             xx = x(n) - x0
             yy = y(n) - y0
             zz = z(n) - z0
             rr = xx*xx + yy*yy + zz*zz
             f0 = sum(.contraction * exp( -rr * .exponent ))
             f(n,1) = xx*f0
             f(n,2) = yy*f0
             f(n,3) = zz*f0
          end

        case (2) ! D function ...........
          do n = 1,n_pt
             xx = x(n) - x0
             yy = y(n) - y0
             zz = z(n) - z0
             rr = xx*xx + yy*yy + zz*zz
             f0 = sum(.contraction * exp( -rr * .exponent ))
             zz_f0 = zz*f0
             f(n,1) = xx*xx*f0
             f(n,2) = yy*yy*f0
             f(n,3) = zz*zz*f0
             f(n,4) = xx*yy*f0
             f(n,5) = xx*zz_f0
             f(n,6) = yy*zz_f0
          end

        case (3) ! F function ...........

          ff = .first_gaussian
          lf = .last_gaussian

          do n = 1,n_pt
             xx = x(n) - x0
             yy = y(n) - y0
             zz = z(n) - z0
             xx2 = xx*xx
             yy2 = yy*yy
             zz2 = zz*zz
             xx3 = xx2*xx
             yy3 = yy2*yy
             zz3 = zz2*zz
             rr = xx2 + yy2 + zz2
             f0 = sum(.contraction * exp( -rr * .exponent ))
             f(n,1)  = f0*xx3
             f(n,2)  = f0*yy3
             f(n,3)  = f0*zz3
             f(n,4)  = f0*xx2*yy
             f(n,5)  = f0*xx2*zz
             f(n,6)  = f0*xx*yy2
             f(n,7)  = f0*yy2*zz
             f(n,8)  = f0*xx*zz2
             f(n,9)  = f0*yy*zz2
             f(n,10) = f0*xx*yy*zz
          end

        case default ! General l function ...........

          ff = .first_gaussian
          lf = .last_gaussian
          lx = GAUSSIAN_DATA::px(ff:lf)
          ly = GAUSSIAN_DATA::py(ff:lf)
          lz = GAUSSIAN_DATA::pz(ff:lf)

          bx.create(0,.l)
          by.create(0,.l)
          bz.create(0,.l)

          do n = 1,n_pt

             xx = x(n) - x0
             yy = y(n) - y0
             zz = z(n) - z0
             rr = xx*xx + yy*yy + zz*zz
             f0 = sum( .contraction * exp( -rr * .exponent ))

             ! Cartesian orbital part
             ! x**b,y**b,z**b for b=0,.l
             bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
             bx(1) = xx;    by(1) = yy;    bz(1) = zz
             bxb = xx;      byb = yy;      bzb = zz
             do b=2,.l
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end

             ! Combine cartesian orbital powers with the exponential part
             f(n,:) = f0*bx(lx(:))*by(ly(:))*bz(lz(:))

          end

          bz.destroy
          by.destroy
          bx.destroy

      end

   end


   make_grid(F,x,y,z,r2,cutoff) ::: PURE
   ! Return "F(i,n)", the value of the basis function "n" on grid
   ! point "i" given a set of grid points "pt(i,1:3)"
      self :: IN
      F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      Fc :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_grid_c(F,x,y,z,r2,cutoff)

      else if (.l<2) then

         .make_grid_c(F,x,y,z,r2,cutoff)

      else

         n_pt = x.dim1
         Fc.create(n_pt,.n_comp)

         .make_grid_c(Fc,x,y,z,r2,cutoff)
         F.to_product_of(Fc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Fc.destroy

      end

   end

   make_grid_c(F,x,y,z,r2,cutoff) ::: private, PURE
   ! Return "F(i,n)", the value of the shell component "n" on grid point "i".
   ! "x", "y", "z" are the differences between the points "pt" and the shell
   ! center, "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated under some
   ! circumstances, when shell belonging to a whole atom are being calculated.
      self :: IN
      F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(f.dim1==x.dim,"inconsistent f and x")
   ENSURE(f.dim1==y.dim,"inconsistent f and x")
   ENSURE(f.dim1==z.dim,"inconsistent f and x")

      bx,by,bz :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b, ff,lf :: INT
      rr,xx,yy,zz,f0,bxb,byb,bzb :: REAL
      r2_max,xx2,yy2,zz2,xx3,yy3,zz3,zz_f0 :: REAL

      n_pt = x.dim
      F = ZERO

      r2_max = .r2_max(cutoff)

      select case (.l)

      case (0) ! S function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            F(n,1) = sum(.contraction * exp( -rr * .exponent ))
         end

      case (1) ! P function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(n,1) = xx*f0
            F(n,2) = yy*f0
            F(n,3) = zz*f0
         end

      case (2) ! D function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            f0 = sum(.contraction * exp( -rr * .exponent ))
            zz_f0 = zz*f0
            F(n,1) = xx*xx*f0
            F(n,2) = yy*yy*f0
            F(n,3) = zz*zz*f0
            F(n,4) = xx*yy*f0
            F(n,5) = xx*zz_f0
            F(n,6) = yy*zz_f0
         end

      case (3) ! F function ...........
         ff = .first_gaussian
         lf = .last_gaussian
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            xx2 = xx*xx
            yy2 = yy*yy
            zz2 = zz*zz
            xx3 = xx2*xx
            yy3 = yy2*yy
            zz3 = zz2*zz
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(n,1)  = f0*xx3
            F(n,2)  = f0*yy3
            F(n,3)  = f0*zz3
            F(n,4)  = f0*xx2*yy
            F(n,5)  = f0*xx2*zz
            F(n,6)  = f0*xx*yy2
            F(n,7)  = f0*yy2*zz
            F(n,8)  = f0*xx*zz2
            F(n,9)  = f0*yy*zz2
            F(n,10) = f0*xx*yy*zz
         end

      case default ! General l function ...........

         ff = .first_gaussian
         lf = .last_gaussian
         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l)
         by.create(0,.l)
         bz.create(0,.l)

         do n = 1,n_pt

            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle

            f0 = sum( .contraction * exp( -rr * .exponent ))

            ! Cartesian orbital part
            ! x**b,y**b,z**b for b=0,.l
            bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
            bx(1) = xx;    by(1) = yy;    bz(1) = zz
            bxb = xx;      byb = yy;      bzb = zz

            do b=2,.l
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            F(n,:) = f0*bx(lx(:))*by(ly(:))*bz(lz(:))

         end

         bz.destroy
         by.destroy
         bx.destroy

      end

   end


   make_grid(F,n_pt,x,y,z,r2,lg) ::: PURE
   ! Return "F(i,n)", the value of the shell component "n" on grid
   ! point "i".  "x", "y", "z" are precomputed differences between the
   ! points "pt" and the shell center, "r2" is a precomputed array for
   ! the square of the distance from the points "pt" to ".position".
   ! "lg" is the log of the maximum value for this shell, used to
   ! skip elements too small ...  see make_skip_list.
      self :: IN
      n_pt     :: INT, IN
      F        :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      lg       :: VEC{INT}, OUT

      Fc :: MAT{REAL}*

      if (NOT .is_spherical) then

         .make_grid_c(F,n_pt,x,y,z,r2,lg)

      else if (.l<2) then

         .make_grid_c(F,n_pt,x,y,z,r2,lg)

      else

         Fc.create(n_pt,.n_comp)

         .make_grid_c(Fc,n_pt,x,y,z,r2,lg)
         F.to_product_of(Fc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Fc.destroy

      end

   end

   make_grid_c(F,n_pt,x,y,z,r2,lg) ::: private, PURE
   ! Return "F(i,n)", the value of the shell component "n" on grid
   ! point "i".  "x", "y", "z" are precomputed differences between the
   ! points "pt" and the shell center, "r2" is a precomputed array for
   ! the square of the distance from the points "pt" to "position".
   ! "lg" is the log of the maximum value for this shell, used to
   ! skip elements too small ...  see make_skip_list.
      self :: IN
      n_pt     :: INT, IN
      F        :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      lg       :: VEC{INT}, OUT

      bx,by,bz :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n,b, ff,lf :: INT
      rr,xx,yy,zz,f0,bxb,byb,bzb :: REAL
      xx2,yy2,zz2,xx3,yy3,zz3,zz_f0 :: REAL

      select case (.l)

      case (0) ! S function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(n,1) = f0
            lg(n)  = ceiling(log10(f0))
         end

      case (1) ! P function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(n,1) = xx*f0
            F(n,2) = yy*f0
            F(n,3) = zz*f0
            lg(n)  = ceiling(log10(maxval(F(n,:))))
         end

      case (2) ! D function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum(.contraction * exp( -rr * .exponent ))
            zz_f0 = zz*f0
            F(n,1) = xx*xx*f0
            F(n,2) = yy*yy*f0
            F(n,3) = zz*zz*f0
            F(n,4) = xx*yy*f0
            F(n,5) = xx*zz_f0
            F(n,6) = yy*zz_f0
            lg(n)  = ceiling(log10(maxval(F(n,:))))
         end

      case (3) ! F function ...........
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            xx2 = xx*xx
            yy2 = yy*yy
            zz2 = zz*zz
            xx3 = xx2*xx
            yy3 = yy2*yy
            zz3 = zz2*zz
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(n,1)  = f0*xx3
            F(n,2)  = f0*yy3
            F(n,3)  = f0*zz3
            F(n,4)  = f0*xx2*yy
            F(n,5)  = f0*xx2*zz
            F(n,6)  = f0*xx*yy2
            F(n,7)  = f0*yy2*zz
            F(n,8)  = f0*xx*zz2
            F(n,9)  = f0*yy*zz2
            F(n,10) = f0*xx*yy*zz
            lg(n)  = ceiling(log10(maxval(F(n,:))))
         end

      case default ! General l function ...........

         ff = .first_gaussian
         lf = .last_gaussian
         
         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)
         
         bx.create(0,.l)
         by.create(0,.l)
         bz.create(0,.l)
         
         do n = 1,n_pt
         
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum( .contraction * exp( -rr * .exponent ))
         
            ! Cartesian orbital part
            ! x**b,y**b,z**b for b=0,.l
            bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
            bx(1) = xx;    by(1) = yy;    bz(1) = zz
            bxb   = xx;    byb   = yy;    bzb   = zz
            do b = 2,.l
               bxb   = bxb*xx; byb   = byb*yy; bzb   = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end
         
            ! Combine cartesian orbital powers with the exponential part
            F(n,:) = f0*bx(lx(:))*by(ly(:))*bz(lz(:))
            lg(n)  = ceiling(log10(maxval(F(n,:))))
         
         end
         
         bz.destroy
         by.destroy
         bx.destroy

      end

   end


   make_skip_grid(F,n_keep,x,y,z,r2,skip,n_pt) ::: PURE
   ! Return "F(i,n)", the value of the shell component "n" on grid
   ! point "i".  "x", "y", "z" are precomputed differences between the
   ! points "pt" and the shell center, "r2" is a precomputed array for
   ! the square of the distance from the points "pt" to ".position". "skip"
   ! is an array to skip elements too small ...  see make_skip_list.
      self :: IN
      n_keep,n_pt :: INT, IN
      F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      skip :: VEC{BIN}, IN

      Fc :: MAT{REAL}@

      if (NOT .is_spherical) then

         .make_skip_grid_c(F,x,y,z,r2,skip,n_pt)

      else if (.l<2) then

         .make_skip_grid_c(F,x,y,z,r2,skip,n_pt)

      else

         Fc.create(n_keep,.n_comp)

         .make_skip_grid_c(Fc,x,y,z,r2,skip,n_pt)
         F = matmul(Fc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Fc.destroy

      end

   end

   make_skip_grid_c(F,x,y,z,r2,skip,n_pt) ::: private, PURE
   ! Return "F(i,n)", the value of the shell component "n" on grid
   ! point "i".  "x", "y", "z" are precomputed differences between the
   ! points "pt" and the shell center, "r2" is a precomputed array for
   ! the square of the distance from the points "pt" to "position". "skip"
   ! is an array to skip elements too small ...  see make_skip_list.
      self :: IN
      n_pt :: INT, IN
      F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      skip :: VEC{BIN}, IN

 ! ENSURE(f.dim1==x.dim,"inconsistent f and x")
 ! ENSURE(f.dim1==y.dim,"inconsistent f and x")
 ! ENSURE(f.dim1==z.dim,"inconsistent f and x")

      bx,by,bz :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n,i,b, ff,lf :: INT
      rr,xx,yy,zz,f0,bxb,byb,bzb :: REAL
      xx2,yy2,zz2,xx3,yy3,zz3,zz_f0 :: REAL

      select case (.l)

      case (0) ! S function ...........
         i = 0
         do n = 1,n_pt
            if (skip(n)) cycle
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            F(i,1) = sum(.contraction * exp( -rr * .exponent ))
         end

      case (1) ! P function ...........
         i = 0
         do n = 1,n_pt
            if (skip(n)) cycle
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(i,1) = xx*f0
            F(i,2) = yy*f0
            F(i,3) = zz*f0
         end

      case (2) ! D function ...........
         i = 0
         do n = 1,n_pt
            if (skip(n)) cycle
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum(.contraction * exp( -rr * .exponent ))
            zz_f0 = zz*f0
            F(i,1) = xx*xx*f0
            F(i,2) = yy*yy*f0
            F(i,3) = zz*zz*f0
            F(i,4) = xx*yy*f0
            F(i,5) = xx*zz_f0
            F(i,6) = yy*zz_f0
         end

      case (3) ! F function ...........
         ff = .first_gaussian
         lf = .last_gaussian
         i = 0
         do n = 1,n_pt
            if (skip(n)) cycle
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            xx2 = xx*xx
            yy2 = yy*yy
            zz2 = zz*zz
            xx3 = xx2*xx
            yy3 = yy2*yy
            zz3 = zz2*zz
            f0 = sum(.contraction * exp( -rr * .exponent ))
            F(i,1)  = f0*xx3
            F(i,2)  = f0*yy3
            F(i,3)  = f0*zz3
            F(i,4)  = f0*xx2*yy
            F(i,5)  = f0*xx2*zz
            F(i,6)  = f0*xx*yy2
            F(i,7)  = f0*yy2*zz
            F(i,8)  = f0*xx*zz2
            F(i,9)  = f0*yy*zz2
            F(i,10) = f0*xx*yy*zz
         end

      case default ! General l function ...........

         ff = .first_gaussian
         lf = .last_gaussian
         
         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)
         
         bx.create(0,.l)
         by.create(0,.l)
         bz.create(0,.l)
         
         i = 0
         do n = 1,n_pt
         
            if (skip(n)) cycle
         
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            f0 = sum( .contraction * exp( -rr * .exponent ))
         
            ! Cartesian orbital part
            ! x**b,y**b,z**b for b=0,.l
            bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
            bx(1) = xx;    by(1) = yy;    bz(1) = zz
            bxb = xx;      byb = yy;      bzb = zz
            do b=2,.l
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end
         
            ! Combine cartesian orbital powers with the exponential part
            F(i,:) = f0*bx(lx(:))*by(ly(:))*bz(lz(:))
         
         end
         
         bz.destroy
         by.destroy
         bx.destroy

      end

   end


   make_skip_nabla_grid(Gx,Gy,Gz,F0,n_keep,x,y,z,r2,skip,n_pt) ::: PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F0(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      n_keep,n_pt :: INT, IN
      Gx,Gy,Gz,F0 :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      skip :: VEC{BIN}, IN

      Gxc,Gyc,Gzc,Fc :: MAT{REAL}@

      if (NOT .is_spherical) then

         .make_skip_nabla_grid_c(Gx,Gy,Gz,F0,x,y,z,r2,skip,n_pt)

      else if (.l<2) then

         .make_skip_nabla_grid_c(Gx,Gy,Gz,F0,x,y,z,r2,skip,n_pt)

      else

          Fc.create(n_keep,.n_comp)
         Gxc.create(n_keep,.n_comp)
         Gyc.create(n_keep,.n_comp)
         Gzc.create(n_keep,.n_comp)

         .make_skip_nabla_grid_c(Gxc,Gyc,Gzc,Fc,x,y,z,r2,skip,n_pt)

         F0.to_product_of(Fc ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gx.to_product_of(Gxc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gy.to_product_of(Gyc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gz.to_product_of(Gzc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gzc.destroy
         Gyc.destroy
         Gxc.destroy
         Fc.destroy

      end

   end

   make_skip_nabla_grid_c(Gx,Gy,Gz,F0,x,y,z,r2,skip,n_pt) ::: private, PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F0(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      n_pt :: INT, IN
      Gx,Gy,Gz,F0 :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      skip :: VEC{BIN}, IN

 ! ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
 ! ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
 ! ENSURE(Gx.is_same_shape_as(F0),"Gx and F0 incompatible")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n,i,b, nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz :: REAL

      F0 = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0) ! S function ....
         i = 0
         do n = 1,n_pt
            if (skip(n)) cycle
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            F0(i,1) = g0
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            Gx(i,1) = g1*xx
            Gy(i,1) = g1*yy
            Gz(i,1) = g1*zz
         end

      case (1) ! P function ....
         i = 0
         do n = 1,n_pt
            if (skip(n)) cycle
            i = i + 1
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1x = xx*g0
            g1y = yy*g0
            g1z = zz*g0
            F0(i,1) = g1x
            F0(i,2) = g1y
            F0(i,3) = g1z
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            Gx(i,1) = g0+xx*g1x
            Gy(i,1) = xx*g1y
            Gz(i,1) = xx*g1z
            Gx(i,2) = yy*g1x
            Gy(i,2) = g0+yy*g1y
            Gz(i,2) = yy*g1z
            Gx(i,3) = zz*g1x
            Gy(i,3) = zz*g1y
            Gz(i,3) = g0+zz*g1z
         end

      case default ! General case

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         i = 0
         do n = 1,n_pt

            if (skip(n)) cycle
            i = i + 1

            xx = x(n)
            yy = y(n)
            zz = z(n)

            ! Radial part, summed over primitives
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z
            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            bxb = xx;            byb = yy;            bzb = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               g1      = bxb * by_bz * g0
               F0(i,b) = g1
               Gx(i,b) =       gxb(nxb) * by_bz
               Gy(i,b) = bxb * gyb(nyb) * bzb
               Gz(i,b) = bxb * byb      * gzb(nzb)
            end
         end

         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy

      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(G,pt) ::: PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)".
      self :: IN
      G :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN

      Gc :: MAT3{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(G,pt)

      else if (.l<2) then

         .make_nabla_grid_c(G,pt)

      else

         n_pt = pt.dim1
         Gc.create(n_pt,.n_comp,3)

         .make_nabla_grid_c(Gc,pt)
         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gc.destroy

      end

   end

   make_nabla_grid_c(G,pt) ::: private, PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)".
      self :: IN
      G :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,"pt matrix incorrectly dimensioned")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr :: REAL
      g0,g1,g1x,g1y,g1z,x,y,z,bxb,byb,bzb :: REAL

      n_pt = pt.dim1

      x = .position(1)
      y = .position(2)
      z = .position(3)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            g1 = -TWO*sum(.exponent*.contraction*exp(-.exponent*rr))
            G(n,1,1) = g1*xx
            G(n,1,2) = g1*yy
            G(n,1,3) = g1*zz
         end

      case (1)
         cc_exp_rr.create(.n_cc)
         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            G(n,1,1) = g0+xx*g1x
            G(n,1,2) = xx*g1y
            G(n,1,3) = xx*g1z
            G(n,2,1) = yy*g1x
            G(n,2,2) = g0+yy*g1y
            G(n,2,3) = yy*g1z
            G(n,3,1) = zz*g1x
            G(n,3,2) = zz*g1y
            G(n,3,3) = g0+zz*g1z
         end
         cc_exp_rr.destroy

      case default

         cc_exp_rr.create(.n_cc)

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz

            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            bxb = xx;            byb = yy;            bzb = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx*g1x;  gyb(1) = g0+yy*g1y;  gzb(1) = g0+zz*g1z

            do b=2,.l
               gxb(b) = (b*g0+xx*g1x) * bxb           ! (n-1)th power
               gyb(b) = (b*g0+yy*g1y) * byb           ! of the xyz part
               gzb(b) = (b*g0+zz*g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Loop over basis functions
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               G(n,b,1) = gxb(nxb) *  by(nyb) *  bz(nzb)
               G(n,b,2) = bx(nxb) * gyb(nyb) *  bz(nzb)
               G(n,b,3) = bx(nxb) *  by(nyb) * gzb(nzb)
            end

         end
         
         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy
         cc_exp_rr.destroy

      end

   end


   make_nabla_grid(G,x,y,z,r2,cutoff) ::: PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      self :: IN
      G :: MAT3{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      Gc :: MAT3{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(G,x,y,z,r2,cutoff)

      else if (.l<2) then

         .make_nabla_grid_c(G,x,y,z,r2,cutoff)

      else

         n_pt = x.dim1

         Gc.create(n_pt,.n_comp,3)

         .make_nabla_grid_c(Gc,x,y,z,r2,cutoff)

         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gc.destroy

      end

   end

   make_nabla_grid_c(G,x,y,z,r2,cutoff) ::: private, PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      self :: IN
      G :: MAT3{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb :: REAL
      r2_max,xx,yy,zz,rr :: REAL

      n_pt = x.dim
      G = ZERO

      r2_max = .r2_max(cutoff)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            g1 = -TWO*sum(.exponent*.contraction*exp(-.exponent*rr))
            G(n,1,1) = g1*xx
            G(n,1,2) = g1*yy
            G(n,1,3) = g1*zz
         end

      case (1)
         cc_exp_rr.create(.n_cc)
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            G(n,1,1) = g0+xx*g1x
            G(n,1,2) = xx*g1y
            G(n,1,3) = xx*g1z
            G(n,2,1) = yy*g1x
            G(n,2,2) = g0+yy*g1y
            G(n,2,3) = yy*g1z
            G(n,3,1) = zz*g1x
            G(n,3,2) = zz*g1y
            G(n,3,3) = g0+zz*g1z
         end
         cc_exp_rr.destroy

      case default

        cc_exp_rr.create(.n_cc)

        ff = .first_gaussian
        lf = .last_gaussian

        lx = GAUSSIAN_DATA::px(ff:lf)
        ly = GAUSSIAN_DATA::py(ff:lf)
        lz = GAUSSIAN_DATA::pz(ff:lf)

        bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
        gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

        do n = 1,n_pt
           xx = x(n)
           yy = y(n)
           zz = z(n)
           rr = r2(n)
           if (rr>r2_max) cycle
           cc_exp_rr = .contraction*exp(-.exponent*rr)
           g0 = sum(cc_exp_rr)
           g1 = -TWO*sum(.exponent*cc_exp_rr)
           g1x = g1*xx
           g1y = g1*yy
           g1z = g1*zz

           ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
           bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
           bx(1) = xx;          by(1) = yy;          bz(1) = zz
           bxb = xx;            byb = yy;            bzb = zz
           gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
           gxb(1) = g0+xx*g1x;  gyb(1) = g0+yy*g1y;  gzb(1) = g0+zz*g1z

           do b=2,.l
              gxb(b) = (b*g0+xx*g1x) * bxb           ! (n-1)th power
              gyb(b) = (b*g0+yy*g1y) * byb           ! of the xyz part
              gzb(b) = (b*g0+zz*g1z) * bzb
              bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
              bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
           end

           ! Loop over basis functions
           do b = 1,.n_comp
              nxb = lx(b)
              nyb = ly(b)
              nzb = lz(b)
              G(n,b,1) = gxb(nxb) *  by(nyb) *  bz(nzb)
              G(n,b,2) = bx(nxb) * gyb(nyb) *  bz(nzb)
              G(n,b,3) = bx(nxb) *  by(nyb) * gzb(nzb)
           end

        end

        gzb.destroy;  gyb.destroy;  gxb.destroy
        bz.destroy;   by.destroy;   bx.destroy
        cc_exp_rr.destroy

      end

   end


   make_nabla_grid(G,F,pt) ::: PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.
      self :: IN
      G :: MAT3{REAL}, OUT
      F :: MAT{REAL},  OUT
      pt :: MAT{REAL}, IN

      Fc :: MAT{REAL}*
      Gc :: MAT3{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(G,F,pt)

      else if (.l<2) then

         .make_nabla_grid_c(G,F,pt)

      else

         n_pt = pt.dim1
         Fc.create(n_pt,.n_comp)
         Gc.create(n_pt,.n_comp,3)

         .make_nabla_grid_c(Gc,Fc,pt)

                F.to_product_of(Fc       ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gc.destroy
         Fc.destroy

      end

   end

   make_nabla_grid_c(G,F,pt) ::: private, PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.
      self :: IN
      G :: MAT3{REAL}, OUT
      F :: MAT{REAL},  OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,"pt matrix incorrectly dimensioned")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,x,y,z,bxb,byb,bzb,by_bz :: REAL

      n_pt = pt.dim1

      x = .position(1)
      y = .position(2)
      z = .position(3)

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            F(n,1)   = sum(cc_exp_rr)
            G(n,1,1) = g1*xx
            G(n,1,2) = g1*yy
            G(n,1,3) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            F(n,1) = xx*g0
            F(n,2) = yy*g0
            F(n,3) = zz*g0
            G(n,1,1) = g0+xx*g1x
            G(n,1,2) = xx*g1y
            G(n,1,3) = xx*g1z
            G(n,2,1) = yy*g1x
            G(n,2,2) = g0+yy*g1y
            G(n,2,3) = yy*g1z
            G(n,3,1) = zz*g1x
            G(n,3,2) = zz*g1y
            G(n,3,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z

            ! Radial part, summed over primitives
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bxb = xx;            byb = yy;            bzb = zz
            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               F(n,b)   = bxb * by_bz * g0
               G(n,b,1) =       gxb(nxb) * by_bz
               G(n,b,2) = bxb * gyb(nyb) * bzb
               G(n,b,3) = bxb * byb      * gzb(nzb)
            end
         
         end

         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy

      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(G,F,x,y,z,r2) ::: PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.  "x", "y", "z" are the differences between the
   ! points "pt" and the shell center, "r2" is an array for the square
   ! of the distance from the points "pt" to ".position". These arrays can
   ! be efficiently precalculated under some circumstances, when shell
   ! belonging to a whole atom are being calculated.
      self :: IN
      G :: MAT3{REAL}, OUT
      F :: MAT{REAL},  OUT
      x,y,z,r2 :: VEC{REAL}, IN

      Fc :: MAT{REAL}*
      Gc :: MAT3{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(G,F,x,y,z,r2)

      else if (.l<2) then

         .make_nabla_grid_c(G,F,x,y,z,r2)

      else

         n_pt = x.dim1
         Fc.create(n_pt,.n_comp)
         Gc.create(n_pt,.n_comp,3)

         .make_nabla_grid_c(Gc,Fc,x,y,z,r2)

                F.to_product_of(Fc       ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gc.destroy
         Fc.destroy

      end

   end

   make_nabla_grid_c(G,F,x,y,z,r2) ::: private, PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.  "x", "y", "z" are the differences between the
   ! points "pt" and the shell center, "r2" is an array for the square
   ! of the distance from the points "pt" to ".position". These arrays can
   ! be efficiently precalculated under some circumstances, when shell
   ! belonging to a whole atom are being calculated.
      self :: IN
      G :: MAT3{REAL}, OUT
      F :: MAT{REAL},  OUT
      x,y,z,r2 :: VEC{REAL}, IN

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz :: REAL

      n_pt = x.dim

      G = ZERO
      F = ZERO

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            F(n,1)   = sum(cc_exp_rr)
            G(n,1,1) = g1*xx
            G(n,1,2) = g1*yy
            G(n,1,3) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            F(n,1) = xx*g0
            F(n,2) = yy*g0
            F(n,3) = zz*g0
            G(n,1,1) = g0+xx*g1x
            G(n,1,2) = xx*g1y
            G(n,1,3) = xx*g1z
            G(n,2,1) = yy*g1x
            G(n,2,2) = g0+yy*g1y
            G(n,2,3) = yy*g1z
            G(n,3,1) = zz*g1x
            G(n,3,2) = zz*g1y
            G(n,3,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bxb = xx;            byb = yy;            bzb = zz
            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               F(n,b)   = bxb * by_bz * g0
               G(n,b,1) =       gxb(nxb) * by_bz
               G(n,b,2) = bxb * gyb(nyb) * bzb
               G(n,b,3) = bxb * byb      * gzb(nzb)
            end

         end
         
         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy

      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(G,F,x,y,z,r2,cutoff) ::: PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.  "x", "y", "z" are the differences between the
   ! points "pt" and the shell center, "r2" is an array for the square
   ! of the distance from the points "pt" to ".position". These arrays can
   ! be efficiently precalculated under some circumstances, when shell
   ! belonging to a whole atom are being calculated.
      self :: IN
      G :: MAT3{REAL}, OUT
      F :: MAT{REAL},  OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      Fc :: MAT{REAL}*
      Gc :: MAT3{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(G,F,x,y,z,r2,cutoff)

      else if (.l<2) then

         .make_nabla_grid_c(G,F,x,y,z,r2,cutoff)

      else

         n_pt = x.dim1

         Fc.create(n_pt,.n_comp)
         Gc.create(n_pt,.n_comp,3)

         .make_nabla_grid_c(Gc,Fc,x,y,z,r2,cutoff)

                F.to_product_of(Fc       ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gc.destroy
         Fc.destroy

      end

   end

   make_nabla_grid_c(G,F,x,y,z,r2,cutoff) ::: private, PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.  "x", "y", "z" are the differences between the
   ! points "pt" and the shell center, "r2" is an array for the square
   ! of the distance from the points "pt" to ".position". These arrays can
   ! be efficiently precalculated under some circumstances, when shell
   ! belonging to a whole atom are being calculated.
      self :: IN
      G :: MAT3{REAL}, OUT
      F :: MAT{REAL},  OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz :: REAL

      n_pt = x.dim

      G = ZERO
      F = ZERO

      r2_max = .r2_max(cutoff)

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            F(n,1)   = sum(cc_exp_rr)
            G(n,1,1) = g1*xx
            G(n,1,2) = g1*yy
            G(n,1,3) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            F(n,1) = xx*g0
            F(n,2) = yy*g0
            F(n,3) = zz*g0
            G(n,1,1) = g0+xx*g1x
            G(n,1,2) = xx*g1y
            G(n,1,3) = xx*g1z
            G(n,2,1) = yy*g1x
            G(n,2,2) = g0+yy*g1y
            G(n,2,3) = yy*g1z
            G(n,3,1) = zz*g1x
            G(n,3,2) = zz*g1y
            G(n,3,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         allocate(lx(lf-ff))
         allocate(ly(lf-ff))
         allocate(lz(lf-ff))

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = x(n)
            yy = y(n)
            zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bxb = xx;            byb = yy;            bzb = zz
            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               F(n,b)   = bxb * by_bz * g0
               G(n,b,1) =       gxb(nxb) * by_bz
               G(n,b,2) = bxb * gyb(nyb) * bzb
               G(n,b,3) = bxb * byb      * gzb(nzb)
            end

         end
         
         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy
         deallocate(lx)
         deallocate(ly)
         deallocate(lz)
 

      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(Gx,Gy,Gz,F,pt) ::: PURE
   ! Return "G(i,n,1:3)", the value of the gradient of the shell
   ! component "n" on grid point "i" given a set of grid points
   ! "pt(i,1:3)". Also return the "F(i,n)" the value of the shell
   ! component "n" on grid point "i". It is more efficient to compute
   ! both at once.  "x", "y", "z" are the differences between the
   ! points "pt" and the shell center, "r2" is an array for the square
   ! of the distance from the points "pt" to ".position". These arrays can
   ! be efficiently precalculated under some circumstances, when shell
   ! belonging to a whole atom are being calculated.
      self :: IN
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

      Gxc,Gyc,Gzc,Fc :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(Gx,Gy,Gz,F,pt)

      else if (.l<2) then

         .make_nabla_grid_c(Gx,Gy,Gz,F,pt)

      else

         n_pt = pt.dim1

          Fc.create(n_pt,.n_comp)
         Gxc.create(n_pt,.n_comp)
         Gyc.create(n_pt,.n_comp)
         Gzc.create(n_pt,.n_comp)

         .make_nabla_grid_c(Gxc,Gyc,Gzc,Fc,pt)

          F.to_product_of(Fc ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gx.to_product_of(Gxc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gy.to_product_of(Gyc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gz.to_product_of(Gzc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gzc.destroy
         Gyc.destroy
         Gxc.destroy
          Fc.destroy

      end

   end

   make_nabla_grid_c(Gx,Gy,Gz,F,pt) ::: private, PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  
      self :: IN
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")
   ENSURE(pt.dim2==3,"pt matrix incorrectly dimensioned")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,x,y,z,bxb,byb,bzb,by_bz :: REAL

      n_pt = pt.dim1

      x = .position(1)
      y = .position(2)
      z = .position(3)

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            F(n,1)   = sum(cc_exp_rr)
            Gx(n,1) = g1*xx
            Gy(n,1) = g1*yy
            Gz(n,1) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            F(n,1) = xx*g0
            F(n,2) = yy*g0
            F(n,3) = zz*g0
            Gx(n,1) = g0+xx*g1x
            Gy(n,1) = xx*g1y
            Gz(n,1) = xx*g1z
            Gx(n,2) = yy*g1x
            Gy(n,2) = g0+yy*g1y
            Gz(n,2) = yy*g1z
            Gx(n,3) = zz*g1x
            Gy(n,3) = zz*g1y
            Gz(n,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         allocate(lx(lf-ff))
         allocate(ly(lf-ff))
         allocate(lz(lf-ff))

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = pt(n,1) - x
            yy = pt(n,2) - y
            zz = pt(n,3) - z

            ! Radial part, summed over primitives
            rr = xx*xx + yy*yy + zz*zz
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            bxb = xx;            byb = yy;            bzb = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               F(n,b)  = bxb * by_bz * g0
               Gx(n,b) =       gxb(nxb) * by_bz
               Gy(n,b) = bxb * gyb(nyb) * bzb
               Gz(n,b) = bxb * byb      * gzb(nzb)
            end

         end

        gzb.destroy;  gyb.destroy;  gxb.destroy
        bz.destroy;   by.destroy;   bx.destroy
        deallocate(lx)
        deallocate(ly)
        deallocate(lz)


      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2) ::: PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN

      Gxc,Gyc,Gzc,Fc :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2)

      else if (.l<2) then

         .make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2)

      else

         n_pt = x.dim1

         Fc.create(n_pt,.n_comp)
         Gxc.create(n_pt,.n_comp)
         Gyc.create(n_pt,.n_comp)
         Gzc.create(n_pt,.n_comp)

         .make_nabla_grid_c(Gxc,Gyc,Gzc,Fc,x,y,z,r2)

          F.to_product_of(Fc ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gx.to_product_of(Gxc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gy.to_product_of(Gyc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gz.to_product_of(Gzc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gzc.destroy
         Gyc.destroy
         Gxc.destroy
         Fc.destroy

      end

   end

   make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2) ::: private, PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN

   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz :: REAL

      n_pt = x.dim

      F  = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = x(n); yy = y(n); zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            F(n,1)  = sum(cc_exp_rr)
            Gx(n,1) = g1*xx
            Gy(n,1) = g1*yy
            Gz(n,1) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            xx = x(n); yy = y(n); zz = z(n)
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            F(n,1) = xx*g0
            F(n,2) = yy*g0
            F(n,3) = zz*g0
            Gx(n,1) = g0+xx*g1x
            Gy(n,1) = xx*g1y
            Gz(n,1) = xx*g1z
            Gx(n,2) = yy*g1x
            Gy(n,2) = g0+yy*g1y
            Gz(n,2) = yy*g1z
            Gx(n,3) = zz*g1x
            Gy(n,3) = zz*g1y
            Gz(n,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = x(n); yy = y(n); zz = z(n)

            ! Radial part, summed over primitives
            rr = r2(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            bxb = xx;            byb = yy;            bzb = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               F(n,b)  = bxb * by_bz * g0
               Gx(n,b) =       gxb(nxb) * by_bz
               Gy(n,b) = bxb * gyb(nyb) * bzb
               Gz(n,b) = bxb * byb      * gzb(nzb)
            end

         end

         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy

      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff) ::: PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F0(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      Gx,Gy,Gz,F0 :: MAT{REAL}, OUT
      skip_all :: VEC{BIN}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      Gxc,Gyc,Gzc,Fc :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff)

      else if (.l<2) then

         .make_nabla_grid_c(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff)

      else

         n_pt = x.dim

          Fc.create(n_pt,.n_comp)
         Gxc.create(n_pt,.n_comp)
         Gyc.create(n_pt,.n_comp)
         Gzc.create(n_pt,.n_comp)

         .make_nabla_grid_c(Gxc,Gyc,Gzc,Fc,skip_all,x,y,z,r2,cutoff)

         F0.to_product_of(Fc ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gx.to_product_of(Gxc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gy.to_product_of(Gyc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gz.to_product_of(Gzc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gzc.destroy
         Gyc.destroy
         Gxc.destroy
         Fc.destroy

      end

   end

   make_nabla_grid_c(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff) ::: private, PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F0(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      Gx,Gy,Gz,F0 :: MAT{REAL}, OUT
      skip_all :: VEC{BIN}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F0),"Gx and F0 incompatible")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz :: REAL

      n_pt = x.dim

      r2_max = .r2_max(cutoff)

      F0 = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO
      skip_all = TRUE

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            xx = x(n); yy = y(n); zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            skip_all(1) = FALSE
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            F0(n,1) = g0
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            Gx(n,1) = g1*xx
            Gy(n,1) = g1*yy
            Gz(n,1) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            xx = x(n); yy = y(n); zz = z(n)
            rr = r2(n)
            if (rr>r2_max) cycle
            skip_all(1:3) = FALSE
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1x = xx*g0
            g1y = yy*g0
            g1z = zz*g0
            F0(n,1) = g1x
            F0(n,2) = g1y
            F0(n,3) = g1z
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            Gx(n,1) = g0+xx*g1x
            Gy(n,1) = xx*g1y
            Gz(n,1) = xx*g1z
            Gx(n,2) = yy*g1x
            Gy(n,2) = g0+yy*g1y
            Gz(n,2) = yy*g1z
            Gx(n,3) = zz*g1x
            Gy(n,3) = zz*g1y
            Gz(n,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            xx = x(n); yy = y(n); zz = z(n)

            ! Radial part, summed over primitives
            rr = r2(n)
            if (rr>r2_max) cycle
            skip_all(1:.n_comp) = FALSE
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            bxb = xx;            byb = yy;            bzb = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               g1      = bxb * by_bz * g0
               F0(n,b) = g1
               Gx(n,b) =       gxb(nxb) * by_bz
               Gy(n,b) = bxb * gyb(nyb) * bzb
               Gz(n,b) = bxb * byb      * gzb(nzb)
            end

         end

         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy

      end

      cc_exp_rr.destroy

   end


   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2,cutoff) ::: PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

      Gxc,Gyc,Gzc,Fc :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2,cutoff)

      else if (.l<2) then

         .make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2,cutoff)

      else

         n_pt = x.dim

         Fc.create(n_pt,.n_comp)
         Gxc.create(n_pt,.n_comp)
         Gyc.create(n_pt,.n_comp)
         Gzc.create(n_pt,.n_comp)

         .make_nabla_grid_c(Gxc,Gyc,Gzc,Fc,x,y,z,r2,cutoff)

          F.to_product_of(Fc ,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gx.to_product_of(Gxc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gy.to_product_of(Gyc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         Gz.to_product_of(Gzc,GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gzc.destroy
         Gyc.destroy
         Gxc.destroy
         Fc.destroy

      end

   end

   make_nabla_grid_c(Gx,Gy,Gz,F,x,y,z,r2,cutoff) ::: private, PURE
   ! Return "Gj(i,n)", the value of the gradient with respect to
   ! coordinate "j" of the shell component "n", evaluated at grid
   ! point "i", given a set of grid points "pt(i,1:3)". Likewise,
   ! "F(i,n)" is the value of the shell component "n" evaluated at
   ! grid point "i". It is more eficient to compute both "Gn" and "F"
   ! at once. The "Gn" are presented as separate components to allow
   ! contiguous memory access for the calling routine.  "x", "y", "z"
   ! are the differences between the points "pt" and the shell center,
   ! "r2" is an array for the square of the distance from the points
   ! "pt" to ".position". These arrays can be efficiently precalculated
   ! under some circumstances, when shell belonging to a whole atom
   ! are being calculated.
      self :: IN
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")

      cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz :: REAL

      n_pt = x.dim

      r2_max = .r2_max(cutoff)

      F  = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO

      cc_exp_rr.create(.n_cc)

      select case (.l)

      case (0)
         do n = 1,n_pt
            rr = r2(n)
            if (rr>r2_max) cycle
            xx = x(n); yy = y(n); zz = z(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            F(n,1)  = sum(cc_exp_rr)
            Gx(n,1) = g1*xx
            Gy(n,1) = g1*yy
            Gz(n,1) = g1*zz
         end

      case (1)
         do n = 1,n_pt
            rr = r2(n)
            if (rr>r2_max) cycle
            xx = x(n); yy = y(n); zz = z(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            F(n,1) = xx*g0
            F(n,2) = yy*g0
            F(n,3) = zz*g0
            Gx(n,1) = g0+xx*g1x
            Gy(n,1) = xx*g1y
            Gz(n,1) = xx*g1z
            Gx(n,2) = yy*g1x
            Gy(n,2) = g0+yy*g1y
            Gz(n,2) = yy*g1z
            Gx(n,3) = zz*g1x
            Gy(n,3) = zz*g1y
            Gz(n,3) = g0+zz*g1z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
         gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)

         do n = 1,n_pt
            rr = r2(n)
            if (rr>r2_max) cycle
            xx = x(n); yy = y(n); zz = z(n)
            cc_exp_rr = .contraction*exp(-.exponent*rr)
            g0 = sum(cc_exp_rr)
            g1 = -TWO*sum(.exponent*cc_exp_rr)

            ! Cartesian orbital part
            ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
            g1x = g1*xx
            g1y = g1*yy
            g1z = g1*zz
            xx_g1x = xx*g1x
            yy_g1y = yy*g1y
            zz_g1z = zz*g1z

            bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
            bx(1) = xx;          by(1) = yy;          bz(1) = zz
            bxb = xx;            byb = yy;            bzb = zz
            gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
            gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z

            do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
            end

            ! Combine cartesian orbital powers with the exponential part
            do b = 1,.n_comp
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               F(n,b)  = bxb * by_bz * g0
               Gx(n,b) =       gxb(nxb) * by_bz
               Gy(n,b) = bxb * gyb(nyb) * bzb
               Gz(n,b) = bxb * byb      * gzb(nzb)
            end

         end

         gzb.destroy;  gyb.destroy;  gxb.destroy
         bz.destroy;   by.destroy;   bx.destroy

      end

      cc_exp_rr.destroy

   end


   make_laplacian_grid(G,pt) ::: PURE
   ! Return "G(i,n,1:3)", the value of the second derivatives
   ! (d/dx2,d/dy2,d/dz2) of the shell component "n" on grid point "i"
   ! given a set of grid points "pt(i,1:3)".
      self :: IN
      G :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN

      Gc :: MAT3{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_nabla_grid_c(G,pt)

      else if (.l<2) then

         .make_nabla_grid_c(G,pt)

      else

         n_pt = pt.dim1

         Gc.create(n_pt,.n_comp,3)

         .make_nabla_grid_c(Gc,pt)

         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Gc.destroy

      end

   end


   make_laplacian_grid(G,H,I,pt) ::: PURE
   ! Return "G(j,n,1:3)", the value of the second derivatives
   ! (d/dx2,d/dy2,d/dz2) of the shell component n on grid point j
   ! given a set of grid points "pt(j,1:3)". Also return "H(j,n,1:3)",
   ! the value of the first derivative, and return "I(n)", the value
   ! of the gaussian
      self :: IN
      G  :: MAT3{REAL}, OUT
      H  :: MAT3{REAL}, OUT
      I  :: MAT{REAL},  OUT
      pt :: MAT{REAL},  IN

      Gc,Hc :: MAT3{REAL}*
      Ic :: MAT{REAL}*
      n_pt :: INT

      if (NOT .is_spherical) then

         .make_laplacian_grid_c(G,H,I,pt)

      else if (.l<2) then

         .make_laplacian_grid_c(G,H,I,pt)

      else

         n_pt = pt.dim1

         Gc.create(n_pt,.n_comp,3)
         Hc.create(n_pt,.n_comp,3)
         Ic.create(n_pt,.n_comp)

         .make_laplacian_grid_c(Gc,Hc,Ic,pt)

         G(:,:,1).to_product_of(Gc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,2).to_product_of(Gc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         G(:,:,3).to_product_of(Gc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         H(:,:,1).to_product_of(Hc(:,:,1),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         H(:,:,2).to_product_of(Hc(:,:,2),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)
         H(:,:,3).to_product_of(Hc(:,:,3),GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

                I.to_product_of(Ic,       GAUSSIAN_DATA::spherical_harmonics_for(.l)%element)

         Ic.destroy
         Hc.destroy
         Gc.destroy

      end

   end

   make_laplacian_grid_c(G,H,I,pt) ::: private, PURE
   ! Return "G(j,n,1:3)", the value of the second derivatives
   ! (d/dx2,d/dy2,d/dz2) of the shell component n on grid point j
   ! given a set of grid points "pt(j,1:3)". Also return "H(j,n,1:3)",
   ! the value of the first derivative, and return "I(n)", the value
   ! of the gaussian
      self :: IN
      G,H :: MAT3{REAL}, OUT
      I :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")

      lx,ly,lz :: VEC{INT}@
      n_pt,n,b,p,j,nxb,nyb,nzb, ff,lf :: INT
      aa,x,y,z,x0,y0,z0,rr,val :: REAL
      g0,g1,g2,g2x,g2y,g2z :: REAL
      gnbx,gnby,gnbz,x2,y2,z2 :: REAL
      gx0,gx1,gy0,gy1,gz0,gz1,inb :: REAL
      hnbx,hnby,hnbz,hx1,hy1,hz1,h1x,h1y,h1z :: REAL
      tn,tn1,tn2,twog0 :: REAL

      n_pt = size(pt,1)

      ! Origin
      x0 = .position(1)
      y0 = .position(2)
      z0 = .position(3)

      select case (.l)

      case (0)
         do n = 1,n_pt
           x = pt(n,1) - x0
           y = pt(n,2) - y0
           z = pt(n,3) - z0
           x2 = x*x;   y2 = y*y;   z2 = z*z
           rr = x2 + y2 + z2
           g0 = ZERO
           g1 = ZERO
           g2 = ZERO
           do p = 1,.n_cc          ! Loop over primitives
             aa = .exponent(p)
             val = .contraction(p)*exp(-aa*rr)
             g0 = g0 + val
             g1 = g1 - aa*val
             g2 = g2 + aa*aa*val
           end
           g1 = g1 * TWO
           g2 = g2 * FOUR
           G(n,1,1) = g1 + g2*x2
           G(n,1,2) = g1 + g2*y2
           G(n,1,3) = g1 + g2*z2
           H(n,1,1) = g1*x
           H(n,1,2) = g1*y
           H(n,1,3) = g1*z
           I(n,1)   = g0
         end

      case (1)
         do n = 1,n_pt
           x = pt(n,1) - x0
           y = pt(n,2) - y0
           z = pt(n,3) - z0
           x2 = x*x;   y2 = y*y;   z2 = z*z
           rr = x2 + y2 + z2
           g0 = ZERO
           g1 = ZERO
           g2 = ZERO
           do p = 1,.n_cc          ! Loop over primitives
             aa = .exponent(p)
             val = .contraction(p)*exp(-aa*rr)
             g0 = g0 + val
             g1 = g1 - aa*val
             g2 = g2 + aa*aa*val
           end
           g1 = g1 * TWO
           g2 = g2 * FOUR
           g2x = g2 * x2
           g2y = g2 * y2
           g2z = g2 * z2
           G(n,1,1) = x * (3 * g1 + g2x)
           G(n,1,2) = x * (g1 + g2y)
           G(n,1,3) = x * (g1 + g2z)
           G(n,2,1) = y * (g1 + g2x)
           G(n,2,2) = y * (3 * g1 + g2y)
           G(n,2,3) = y * (g1 + g2z)
           G(n,3,1) = z * (g1 + g2x)
           G(n,3,2) = z * (g1 + g2y)
           G(n,3,3) = z * (3 * g1 + g2z)
           h1x = g1*x
           h1y = g1*y
           h1z = g1*z
           H(n,1,1) = g0+x2*g1
           H(n,1,2) = x*h1y
           H(n,1,3) = x*h1z
           H(n,2,1) = y*h1x
           H(n,2,2) = g0+y2*g1
           H(n,2,3) = y*h1z
           H(n,3,1) = z*h1x
           H(n,3,2) = z*h1y
           H(n,3,3) = g0+z2*g1
           I(n,1)   = g0*x
           I(n,2)   = g0*y
           I(n,3)   = g0*z
         end

      case default

         ff = .first_gaussian
         lf = .last_gaussian

         lx = GAUSSIAN_DATA::px(ff:lf)
         ly = GAUSSIAN_DATA::py(ff:lf)
         lz = GAUSSIAN_DATA::pz(ff:lf)

         do n = 1,n_pt
            x = pt(n,1) - x0
            y = pt(n,2) - y0
            z = pt(n,3) - z0
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
               aa = .exponent(p)
               val = .contraction(p)*exp(-aa*rr)
               g0 = g0 + val
               g1 = g1 - aa*val
               g2 = g2 + aa*aa*val
            end

            g1 = g1 * TWO
            g2 = g2 * FOUR
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2

            ! Some that are used multiple times.
            ! Taken out of loop over n_comp.
            gx0 = g1 + g2x
            gy0 = g1 + g2y
            gz0 = g1 + g2z
            gx1 = (THREE * g1 + g2x)*x  ! *x^1
            gy1 = (THREE * g1 + g2y)*y  ! *y^1
            gz1 = (THREE * g1 + g2z)*z  ! *z^1

            h1x = g1*x
            h1y = g1*y
            h1z = g1*z
            hx1 = g0 + x2*g1
            hy1 = g0 + y2*g1
            hz1 = g0 + z2*g1

            ! Loop over basis functions
            do b = 1,.n_comp

               inb = g0
               nxb = lx(b)
               nyb = ly(b)
               nzb = lz(b)

               select case (nxb)
               case (0);     gnbx = gx0
                             hnbx = h1x
               case (1);     gnbx = gx1
                             hnbx = hx1
               case (2)
                  tn = x*x
                  twog0 = g0+g0
                  gnbx = twog0 + (5*g1 + g2x)*tn
                  hnbx = twog0*x + h1x*tn
               case default
                  tn2 = x**(nxb-2)
                  tn1 = tn2*x
                  tn = tn2*x*x
                  gnbx = nxb*(nxb-1)*g0*tn2 + ((2*nxb+1) * g1 + g2x)*tn
                  hnbx = nxb*g0*tn1 + h1x*tn
               end

               select case (nyb)
               case (0);     gnby = gy0
                             hnby = h1y
               case (1);     gnby = gy1
                             hnby = hy1
               case (2)
                  tn = y*y
                  twog0 = g0+g0
                  gnby = twog0 + (5*g1 + g2y)*tn
                  hnby = twog0*y + h1y*tn
               case default
                  tn2 = y**(nyb-2)
                  tn1 = tn2*y
                  tn = tn2*y*y
                  gnby = nyb*(nyb-1)*g0*tn2 + ((2*nyb+1) * g1 + g2y)*tn
                  hnby = nyb*g0*tn1 + h1y*tn
               end

               select case (nzb)
               case (0);     gnbz = gz0
                             hnbz = h1z
               case (1);     gnbz = gz1
                             hnbz = hz1
               case (2)
                  tn = z*z
                  twog0 = g0+g0
                  gnbz = twog0 + (5*g1 + g2z)*tn
                  hnbz = twog0*z + h1z*tn
               case default
                  tn2 = z**(nzb-2)
                  tn1 = tn2*z
                  tn = tn2*z*z
                  gnbz = nzb*(nzb-1)*g0*tn2 + ((2*nzb+1) * g1 + g2z)*tn
                  hnbz = nzb*g0*tn1 + h1z*tn
               end

               do j = 1,nxb
                  gnby = x*gnby    ! Do the cartesian (x_i)^j, i/=k part of
                  gnbz = x*gnbz    ! gaussian power of the xyz part not equal
                  hnby = x*hnby
                  hnbz = x*hnbz
                  inb  = x*inb
               end                 ! to deriv. component k

               do j = 1,nyb
                  gnbx = y*gnbx
                  gnbz = y*gnbz
                  hnbx = y*hnbx
                  hnbz = y*hnbz
                  inb  = y*inb
               end

               do j = 1,nzb
                  gnbx = z*gnbx
                  gnby = z*gnby
                  hnbx = z*hnbx
                  hnby = z*hnby
                  inb  = z*inb
               end

               G(n,b,1) = gnbx
               G(n,b,2) = gnby
               G(n,b,3) = gnbz
               H(n,b,1) = hnbx
               H(n,b,2) = hnby
               H(n,b,3) = hnbz
               I(n,b)   = inb 

            end
         end
      end

   end


   make_oscillator_orbital_mask(f,c,l,n,pt)
   ! Return "f(i)", the value of the cartesian part of an oscillator function
   ! centered at "c", of angular momentum "l" and component "n", evaluated on
   ! grid point "i", which is "pt(i,1:3)". 
      f  :: VEC{REAL}
      pt :: MAT{REAL}
      c :: VEC{REAL}(3)
      l,n :: INT

   ENSURE(n.is_in_range([1,GAUSSIAN_DATA:n_comp(l)]),"inconsistent l, n value")

      lx,ly,lz :: VEC{INT}@
      nxn,nyn,nzn, ff,lf :: INT

      select case (l)

      case (0)
         f = ONE

      case (1)
         f = pt(:,n)-c(n)

    ! case (2)
    !    if      (n<=3) then; f = pt(:,n)-c(n)*c(n)
    !    else if (n==4) then; f = pt(:,n)-c(1)*c(2)
    !    else if (n==5) then; f = pt(:,n)-c(1)*c(3)
    !    else if (n==6) then; f = pt(:,n)-c(2)*c(3)
    !    end

    ! case (3)
    !    if      (n<=3)  then; f = pt(:,n)-c(n)*c(n)*c(n)
    !    else if (n==4)  then; f = pt(:,n)-c(1)*c(1)*c(2)
    !    else if (n==5)  then; f = pt(:,n)-c(1)*c(1)*c(3)
    !    else if (n==6)  then; f = pt(:,n)-c(2)*c(2)*c(1)
    !    else if (n==7)  then; f = pt(:,n)-c(2)*c(2)*c(3)
    !    else if (n==8)  then; f = pt(:,n)-c(3)*c(3)*c(1)
    !    else if (n==9)  then; f = pt(:,n)-c(3)*c(3)*c(2)
    !    else if (n==10) then; f = pt(:,n)-c(1)*c(2)*c(3)
    !    end

      case default
         GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
         ff  = GAUSSIAN_DATA:n_comp_up_to(l-1) + 1
         lf  = GAUSSIAN_DATA:n_comp_up_to(l) 
         lx  = GAUSSIAN_DATA::px(ff:lf)
         ly  = GAUSSIAN_DATA::py(ff:lf)
         lz  = GAUSSIAN_DATA::pz(ff:lf)
         nxn = lx(n); nyn = ly(n); nzn = lz(n)
         f = (pt(:,1)-c(1))**nxn * (pt(:,2)-c(2))**nyn * (pt(:,3)-c(3))**nzn
      end

   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("l",.l)
      stdout.dump("l_chr",.l_chr)
      stdout.dump("is_spherical",.is_spherical)
      stdout.dump("n_comp",.n_comp)
      stdout.dump("n_sph",.n_sph)
      stdout.dump("n_bf",.n_bf)
      stdout.dump("first_gaussian",.first_gaussian)
      stdout.dump("last_gaussian",.last_gaussian)
      stdout.dump("n_cc",.n_cc)
      stdout.dump("position",.position)

      stdout.dmpp("exponent",.exponent)
      stdout.dmpp("contraction",.contraction)
      stdout.dmpp("contraction_s",.contraction_s)
      stdout.dmpp("contraction_p",.contraction_p)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, SHELL1?=>TYPE)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, SHELL1?=>TYPE)
   ! Dump pointer object data as text
   end

!  ======
!  Output
!  ======

   put
   ! Put the shell information to "stdout" 
      self :: IN

      table :: VEC{TABLE_COLUMN}@

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian type shell")
      stdout.text("===================")
      stdout.flush
      stdout.show("Shell type                  =",.l_chr)
      stdout.show("L quatum no.                =",.l)
      stdout.show("is_spherical                =",.is_spherical)
      stdout.show("No. of cartesian components =",.n_comp)
      stdout.show("No. of spherical components =",.n_sph)
      stdout.show("Lexical starting index      =",.first_gaussian)
      stdout.show("Lexical end index           =",.last_gaussian)
      stdout.show("No. of contractions         =",.n_cc)
      stdout.show("Position                    =",.position(1),.position(2),.position(3))
      stdout.flush

      if (.exponent.disassociated) return
      if (.contraction.disassociated) return

      ! Table headings
      table.create(2)
      table(2).set_heading("Contraction")
      table(2).set_subhead("coeff.")
      table(2).set_heading("Exponent")
      table(2).set_subhead("/au")

      ! Set table column data
      table(1).set_values(.contraction)
      table(2).set_values(.exponent)

      ! Make the table
      table.put

      ! Clean
      table.destroy

   end

end
