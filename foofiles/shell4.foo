!
! Copyright (C) Daniel Grimwood, March 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!===============================================================================

module SHELL4

  implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      .a.nullify_ptr_part
      .b.nullify_ptr_part
      .c.nullify_ptr_part
      .d.nullify_ptr_part

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .destroy_ab
      .destroy_cd

   end

   destroy_ab ::: leaky, PURE
   ! Destroy the shella and shellb pointer parts of self
      self :: INOUT

      .a.destroy_ptr_part
      .b.destroy_ptr_part

   end

   destroy_cd ::: leaky, PURE
   ! Destroy the shellc and shelld pointer parts of self
      self :: INOUT

      .c.destroy_ptr_part
      .d.destroy_ptr_part

   end

! Try to get rid of these

   create(shell_a,shell_b,shell_c,shell_d) ::: leaky
   ! Create a shell4 object from copies of shell1s.
      self :: PTR
      shell_a,shell_b,shell_c,shell_d :: SHELL1, IN
      .create
      .copy(shell_a,shell_b,shell_c,shell_d)
   end

   create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky
   ! Create a shell4 object from copies of shells and their positions.
      self :: PTR
      shell_a,shell_b,shell_c,shell_d :: SHELL, IN
      pos_a,pos_b,pos_c,pos_d :: VEC{REAL}(3), IN
      .create
      .copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
   end

!  ====================================================
!  Setting parts of self from other shells and shell1's
!  ====================================================

   create_copy(shell) ::: leaky
   ! Create a copy of "shell"
      self :: PTR
      shell :: SHELL4, IN
      .create
      .copy(shell)
   end

   copy(shell) ::: leaky
   ! Make a copy of "shell"
      shell :: SHELL4, IN
      .a.copy(shell.a)
      .b.copy(shell.b)
      .c.copy(shell.c)
      .d.copy(shell.d)
   end

   copy(shell_a,shell_b,shell_c,shell_d) ::: leaky
   ! Copy the shell4 using from shell1 objects
      shell_a,shell_b,shell_c,shell_d :: SHELL1, IN
      .a.copy(shell_a)
      .b.copy(shell_b)
      .c.copy(shell_c)
      .d.copy(shell_d)
   end

   copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky
   ! Set the shell4 using shell objects and positions
      shell_a,shell_b,shell_c,shell_d :: SHELL, IN
      pos_a,pos_b,pos_c,pos_d :: VEC{REAL}, IN
      .a.copy(shell_a,pos_a)
      .b.copy(shell_b,pos_b)
      .c.copy(shell_c,pos_c)
      .d.copy(shell_d,pos_d)
   end

   copy_ab(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the a and b parts of the shell4 using from shell1 objects
      shell_a,shell_b :: SHELL, IN
      pos_a,pos_b :: VEC{REAL}, IN
      .a.copy(shell_a,pos_a)
      .b.copy(shell_b,pos_b)
   end

   copy_cd(shell_c,shell_d,pos_c,pos_d) ::: leaky
   ! Copy the c and d parts of the shell4 using from shell1 objects
      shell_c,shell_d :: SHELL, IN
      pos_c,pos_d :: VEC{REAL}, IN
      .c.copy(shell_c,pos_c)
      .d.copy(shell_d,pos_d)
   end


!  ===========
!  Set methods
!  ===========

   set_spherical(val) ::: pure
   ! Set sphericals to "val" defaults
      self :: INOUT
      val :: BIN, IN

      .is_spherical = val

   end

!  ======================
!  Miscellaneous Routines
!  ======================

   unnormalise ::: pure
   ! Unnormalise each shell in this shell quartet
      self :: INOUT

      .a.unnormalise
      .b.unnormalise
      .c.unnormalise
      .d.unnormalise

   end

!  ===========
!  ERI cutoffs
!  ===========

   ab_kappa_max result (res) ::: pure
   ! Return the largest kappa_ab used in the Lindh integrals.
      self :: IN
      res :: REAL

      AB :: VEC{REAL}(3)
      b,b_cc,a,ab_inv,prefac,r2_ab :: REAL
      bg,ag :: INT

      AB = .b.position - .a.position
      r2_ab = dot_product(AB,AB)

      res = ZERO

      do bg = 1,.b.n_cc
         b    = .b.exponent(bg)
         b_cc = .b.contraction(bg)
         do ag = 1,.a.n_cc
            a = .a.exponent(ag)
            ab_inv = ONE/(a+b)
            prefac = b_cc*.a.contraction(ag) * ab_inv * sqrt(ab_inv) * exp(-a*b*r2_ab*ab_inv)
            res = max(res,prefac/(sqrt(ab_inv)*ab_inv))
         end
      end

   end

   cd_kappa_max result (res) ::: pure
   ! Return the largest kappa_cd used in the Lindh integrals.
      self :: IN
      res :: REAL

      CD :: VEC{REAL}(3)
      d,d_cc,c,cd_inv,prefac,r2_cd :: REAL
      dg,cg :: INT

      CD = .d.position - .c.position

      r2_cd = dot_product(CD,CD)

      res = ZERO

      do dg = 1,.d.n_cc
         d     = .d.exponent(dg)
         d_cc  = .d.contraction(dg)
         do cg = 1,.c.n_cc
            c = .c.exponent(cg)
            cd_inv = ONE/(c+d)
            prefac = d_cc*.c.contraction(cg) * cd_inv * sqrt(cd_inv) * exp(-c*d*r2_cd*cd_inv)
            res = max(res,prefac/(sqrt(cd_inv)*cd_inv))
         end
      end

   end

   skip_ERI result (res) ::: pure
   ! Whether the ERI block will be less than a cutoff value.
      self :: IN
      res :: BIN
      res = (.ab_kappa_max*.cd_kappa_max < SHELL4_ERI_CUTOFF)
   end

   skip_ERI(cutoff) result (res) ::: pure
   ! Whether the ERI block will be less than a cutoff value.
      self :: IN
      cutoff :: REAL, IN
      res :: BIN
      res = (.ab_kappa_max*.cd_kappa_max < cutoff)
   end

!  ======================
!  CADPAC-style integrals
!  ======================

   make_ERI_ints(I)
   ! Make the ERI integral matrix, using Gauss-Hermite quadrature, like in
   ! CADPAC. This is not expected to be as efficient as Daniel's code, below!
   ! But probably much easier to understand.
      I :: MAT4{REAL}

      II :: MAT4{REAL}*
      G :: GAUSSIAN4
      a,b,c,d :: INT

      I = ZERO

      II.create(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp)

      G.a.set_l(.a.l)
      G.b.set_l(.b.l)
      G.c.set_l(.c.l)
      G.d.set_l(.d.l)

      G.a.position = .a.position
      G.b.position = .b.position
      G.c.position = .c.position
      G.d.position = .d.position

      do a = 1,.a.n_cc
       do b = 1,.b.n_cc
         do c = 1,.c.n_cc
           do d = 1,.d.n_cc
             G.a.exponent = .a.exponent(a)
             G.b.exponent = .b.exponent(b)
             G.c.exponent = .c.exponent(c)
             G.d.exponent = .d.exponent(d)
             G.make_ERI_ints(II)
             I = I + II*.a.contraction(a)*.b.contraction(b)*.c.contraction(c)*.d.contraction(d)
           end
         end
       end
      end

      II.destroy

   end

   make_spin_orbit_ints(S,O)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      S,O :: MAT5{REAL}
      .make_spin_orbit_ints(S(:,:,:,:,1),S(:,:,:,:,2),S(:,:,:,:,3), &
                            O(:,:,:,:,1),O(:,:,:,:,2),O(:,:,:,:,3))
   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      Sx,Sy,Sz,Ox,Oy,Oz :: MAT4{REAL}

      SSx,SSy,SSz,OOx,OOy,OOz :: MAT4{REAL}*
      G :: GAUSSIAN4
      a,b,c,d,na,nb,nc,nd :: INT
      cc :: REAL

      Sx = ZERO; Sy = ZERO; Sz = ZERO
      Ox = ZERO; Oy = ZERO; Oz = ZERO

      na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp

      SSx.create(na,nb,nc,nd); SSy.create(na,nb,nc,nd); SSz.create(na,nb,nc,nd)
      OOx.create(na,nb,nc,nd); OOy.create(na,nb,nc,nd); OOz.create(na,nb,nc,nd)

      G.a.set_l(.a.l); G.b.set_l(.b.l)
      G.c.set_l(.c.l); G.d.set_l(.d.l)
      G.a.position = .a.position; G.b.position = .b.position
      G.c.position = .c.position; G.d.position = .d.position

      do a = 1,.a.n_cc
       do b = 1,.b.n_cc
         do c = 1,.c.n_cc
           do d = 1,.d.n_cc
             G.a.exponent = .a.exponent(a)
             G.b.exponent = .b.exponent(b)
             G.c.exponent = .c.exponent(c)
             G.d.exponent = .d.exponent(d)
             G.make_spin_orbit_ints(SSx,SSy,SSz,OOx,OOy,OOz)
             cc = .a.contraction(a)*.b.contraction(b)*.c.contraction(c)*.d.contraction(d)
             Sx = Sx + SSx*cc; Sy = Sy + SSy*cc; Sz = Sz + SSz*cc
             Ox = Ox + OOx*cc; Oy = Oy + OOy*cc; Oz = Oz + OOz*cc
           end
         end
       end
      end

      OOz.destroy; OOy.destroy; OOx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy

   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole integrals, "Dij"
   ! using Gauss-Hermite quadrature. For sure, not the
   ! best implementation, but where else will you get em', eh?
      Dxx,Dyy,Dzz,Dxy,Dxz,Dyz :: MAT4{REAL}

      Mxx,Myy,Mzz,Mxy,Mxz,Myz :: MAT4{REAL}*
      G :: GAUSSIAN4
      a,b,c,d,na,nb,nc,nd :: INT
      cc :: REAL

      Dxx = ZERO; Dyy = ZERO; Dzz = ZERO
      Dxy = ZERO; Dxz = ZERO; Dyz = ZERO

      na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp
      Mxx.create(na,nb,nc,nd); Myy.create(na,nb,nc,nd); Mzz.create(na,nb,nc,nd)
      Mxy.create(na,nb,nc,nd); Mxz.create(na,nb,nc,nd); Myz.create(na,nb,nc,nd)

      G.a.set_l(.a.l); G.b.set_l(.b.l)
      G.c.set_l(.c.l); G.d.set_l(.d.l)
      G.a.position = .a.position; G.b.position = .b.position
      G.c.position = .c.position; G.d.position = .d.position

      do a = 1,.a.n_cc
       do b = 1,.b.n_cc
         do c = 1,.c.n_cc
           do d = 1,.d.n_cc
             G.a.exponent = .a.exponent(a)
             G.b.exponent = .b.exponent(b)
             G.c.exponent = .c.exponent(c)
             G.d.exponent = .d.exponent(d)
             G.make_spin_spin_dipole_ints(Mxx,Myy,Mzz,Mxy,Mxz,Myz)
             cc = .a.contraction(a)*.b.contraction(b)*.c.contraction(c)*.d.contraction(d)
             Dxx = Dxx + Mxx*cc; Dyy = Dyy + Myy*cc; Dzz = Dzz + Mzz*cc
             Dxy = Dxy + Mxy*cc; Dxz = Dxz + Mxz*cc; Dyz = Dyz + Myz*cc
           end
         end
       end
      end

      Myz.destroy; Mxz.destroy; Mxy.destroy
      Mzz.destroy; Myy.destroy; Mxx.destroy

   end

   make_ERI_derivatives(AA,BB,CC,DD)
   !
      AA,BB,CC,DD :: MAT5{REAL}, optional

      AX,BX,CX,DX :: MAT5{REAL}*
      G :: GAUSSIAN4
      a,b,c,d, na,nb,nc,nd :: INT
      fac :: REAL

      G.a.set_l(.a.l); G.b.set_l(.b.l)
      G.c.set_l(.c.l); G.d.set_l(.d.l)
      G.a.position = .a.position; G.b.position = .b.position
      G.c.position = .c.position; G.d.position = .d.position

      na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp

      if (present(AA)) then
       AA = ZERO; AX.create(na,nb,nc,nd,3)
      end

      if (present(BB)) then
       BB = ZERO; BX.create(na,nb,nc,nd,3)
      end

      if (present(CC)) then
       CC = ZERO; CX.create(na,nb,nc,nd,3)
      end

      if (present(DD)) then
       DD = ZERO; DX.create(na,nb,nc,nd,3)
      end

      do a = 1,.a.n_cc
       do b = 1,.b.n_cc
         do c = 1,.c.n_cc
           do d = 1,.d.n_cc
             G.a.exponent = .a.exponent(a)
             G.b.exponent = .b.exponent(b)
             G.c.exponent = .c.exponent(c)
             G.d.exponent = .d.exponent(d)
             G.make_ERI_derivatives(AA=AX,BB=BX,CC=CX,DD=DX)
             fac = .a.contraction(a)*.b.contraction(b)*.c.contraction(c)*.d.contraction(d)
             if (present(AA)) AA = AA + AX*fac
             if (present(BB)) BB = BB + BX*fac
             if (present(CC)) CC = CC + CX*fac
             if (present(DD)) DD = DD + DX*fac
           end
         end
       end
      end

   end

!===============================================================================
!                   Roland Lindh-style integrals
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 1991, 5889-5897.
!
! See also:
! Obara and Saika, J. Chem. Phys. 84(7), 1986, 3963-3974.
! Head-Gordon and Pople, J. Chem. Phys. 89(9), 1988, 5777-5786.
!
!===============================================================================

   get_ERI(abcd)
   ! Makes the (ab|cd) integrals, summed over the primitives
   ! (uses the transfer equation to make (ab|cd) from (es|fs))
      self :: IN

      abcd :: MAT4{REAL}, OUT
      escd :: MAT3{REAL}*
      esfs :: MAT{REAL}*
      eub,fub,ab_l_max,cd_l_max :: INT

      nullify(esfs)
      nullify(escd)

      ab_l_max = max(.a.l,.b.l)-1
      cd_l_max = max(.c.l,.d.l)-1

      eub = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l) - GAUSSIAN_DATA:n_comp_up_to(ab_l_max)
      fub = GAUSSIAN_DATA:n_comp_up_to(.c.l+.d.l) - GAUSSIAN_DATA:n_comp_up_to(cd_l_max)

      esfs.create(eub,fub)
      .make_esfs(esfs)

      escd.create(eub, .c.n_comp, .d.n_comp)
      .transfer_cd(esfs,escd)
      .transfer_ab(escd,abcd)

      escd.destroy
      esfs.destroy

   end

   make_esfs(esfs) ::: private
   ! Makes the initial (es|fs) integrals, summed over the primitives
      self :: IN
      esfs :: MAT{REAL}, OUT

      Ixa,Iya,Iza :: MAT3{REAL}*
      rys :: RYS@
      Ix,Iy,Iz :: MAT{REAL}*
      At,Ct,P,Q,PA,QC,QP,AB,CD :: VEC{REAL}(3)
      zeta,eta,xx,zinv,rho,einv,rho_zinv,rho_einv :: REAL
      ce,cf,bb,ce1,kappa_ab,kappa_cd,normab,norm,r2ab,r2cd :: REAL
      a_cc,b_cc,c_cc,d_cc,a_ex,b_ex,c_ex,d_ex :: REAL
      t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb,f1_cf :: REAL
      ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
      e,f,e1,f1,fp1,ep1,n,i,n_sum,ab_l_sum,cd_l_sum,ab_l_max,cd_l_max :: INT

      ab_l_sum = .a.l + .b.l
      cd_l_sum = .c.l + .d.l
      ab_l_max = max(.a.l,.b.l)-1
      cd_l_max = max(.c.l,.d.l)-1

      eub = GAUSSIAN_DATA:n_comp_up_to(ab_l_sum) - GAUSSIAN_DATA:n_comp_up_to(ab_l_max)
      fub = GAUSSIAN_DATA:n_comp_up_to(cd_l_sum) - GAUSSIAN_DATA:n_comp_up_to(cd_l_max)

      dim1 = ab_l_sum + 1
      dim2 = cd_l_sum + 1
      nroots = (dim1+dim2)/2

      ! number of elements to sum over
      n_sum = nroots*.a.n_cc*.b.n_cc*.c.n_cc*.d.n_cc
      Ixa.create(n_sum,dim1,dim2)
      Iya.create(n_sum,dim1,dim2)
      Iza.create(n_sum,dim1,dim2)

      AB = .a.position-.b.position
      CD = .c.position-.d.position
      r2ab = dot_product(AB,AB)
      r2cd = dot_product(CD,CD)

      ! Want position of shell1 with higher angular momentum.
      if (.a.l > .b.l) then; At = .a.position
      else;                  At = .b.position
      end

      if (.c.l > .d.l) then; Ct = .c.position
      else;                  Ct = .d.position
      end

      rys.create(nroots)

      i = 0
      do ag = 1, .a.n_cc
       a_cc = .a.contraction(ag)
       a_ex = .a.exponent(ag)
       do bg = 1, .b.n_cc
         b_cc = .b.contraction(bg)
         b_ex = .b.exponent(bg)
         zeta = a_ex + b_ex
         zinv = ONE/zeta
         half_zinv = HALF * zinv
         kappa_ab = exp(-a_ex*b_ex*r2ab*zinv)
         normab = TWOPI5ON2 * b_cc*a_cc * zinv * sqrt(zinv) * kappa_ab
         P = (b_ex*.b.position + a_ex*.a.position) * zinv
         PA = P - At
         do cg = 1, .c.n_cc
           c_cc = .c.contraction(cg)
           c_ex = .c.exponent(cg)
           do dg = 1, .d.n_cc
             d_cc = .d.contraction(dg)
             d_ex = .d.exponent(dg)
             eta = c_ex + d_ex
             einv = ONE/eta
             half_einv = HALF * einv
             kappa_cd = exp(-c_ex*d_ex*r2cd*einv)
             norm = normab * d_cc*c_cc * einv * sqrt(einv) * kappa_cd
             Q = (d_ex*.d.position + c_ex*.c.position) * einv
             QC = Q - Ct
             rho  = zeta * eta / (zeta + eta)
             rho_zinv = rho * zinv
             rho_einv = rho * einv
             half_einv = HALF * einv
             QP = Q - P
             xx   = rho * dot_product(QP,QP)
             rys.get_weights(xx)
             rys.weight = rys.weight * (norm * sqrt(rho))

             ! Now make the 2 dimensional integrals.
             do n=1,nroots

               i = i + 1
               Ix => Ixa(i,:,:)
               Iy => Iya(i,:,:)
               Iz => Iza(i,:,:)
               t2      = rys.root(n)
               t2_rz   = t2 * rho_zinv
               t2_re   = t2 * rho_einv
               cf      = (ONE - t2_re) * half_einv
               ce      = (ONE - t2_rz) * half_zinv
               bb      = t2_rz * half_einv
               Ix(1,1) = ONE
               Iy(1,1) = ONE
               Iz(1,1) = ONE

               if (ab_l_sum>0) then
                 Ix(2,1) = PA(1) + t2_rz * QP(1)
                 Iy(2,1) = PA(2) + t2_rz * QP(2)
                 Iz(2,1) = PA(3) + t2_rz * QP(3)
                 do e = 2, ab_l_sum
                   e1 = e - 1
                   ep1 = e + 1
                   ce1 = (e-1) * ce
                   Ix(ep1,1) = Ix(2,1) * Ix(e,1) + ce1 * Ix(e1,1)
                   Iy(ep1,1) = Iy(2,1) * Iy(e,1) + ce1 * Iy(e1,1)
                   Iz(ep1,1) = Iz(2,1) * Iz(e,1) + ce1 * Iz(e1,1)
                 end
               end

               if (cd_l_sum>0) then

                 Ix(1,2) = QC(1) - t2_re * QP(1)
                 Iy(1,2) = QC(2) - t2_re * QP(2)
                 Iz(1,2) = QC(3) - t2_re * QP(3)
                 do f = 2,cd_l_sum
                   f1 = f - 1
                   fp1   = f + 1
                   f1_cf = (f-1)*cf
                   Ix(1,fp1) = Ix(1,2) * Ix(1,f) + f1_cf * Ix(1,f1)
                   Iy(1,fp1) = Iy(1,2) * Iy(1,f) + f1_cf * Iy(1,f1)
                   Iz(1,fp1) = Iz(1,2) * Iz(1,f) + f1_cf * Iz(1,f1)
                 end

                 if (ab_l_sum>0) then
                   Ix(2,2) = Ix(1,2) * Ix(2,1) + bb
                   Iy(2,2) = Iy(1,2) * Iy(2,1) + bb
                   Iz(2,2) = Iz(1,2) * Iz(2,1) + bb
                   do f = 2,cd_l_sum
                     f1 = f - 1
                     fp1   = f + 1
                     f1_cf = (f-1)*cf
                     Ix(2,fp1) = Ix(1,2) * Ix(2,f) + f1_cf * Ix(2,f1) + bb * Ix(1,f)
                     Iy(2,fp1) = Iy(1,2) * Iy(2,f) + f1_cf * Iy(2,f1) + bb * Iy(1,f)
                     Iz(2,fp1) = Iz(1,2) * Iz(2,f) + f1_cf * Iz(2,f1) + bb * Iz(1,f)
                   end
                 end

               end

               do e = 2, ab_l_sum
                 e1  = e - 1
                 ep1 = e + 1
                 ce1 = (e-1) * ce
                 do f=2, cd_l_sum+1
                   f1 = f - 1
                   f1_bb = (f-1)*bb
                   Ix(ep1,f) = Ix(2,1)*Ix(e,f) + ce1*Ix(e1,f) + f1_bb*Ix(e,f1)
                   Iy(ep1,f) = Iy(2,1)*Iy(e,f) + ce1*Iy(e1,f) + f1_bb*Iy(e,f1)
                   Iz(ep1,f) = Iz(2,1)*Iz(e,f) + ce1*Iz(e1,f) + f1_bb*Iz(e,f1)
                 end
               end
               Iz = Iz * rys.weight(n)

             end
           end
         end
       end
      end

      rys.destroy

      .form_3d_ints(Ixa,Iya,Iza,esfs,eub,fub,n_sum)

      Iza.destroy
      Iya.destroy
      Ixa.destroy

   end

   form_3d_ints(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private
   ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
   ! This is the main routine, all the others are specialised and may break if
   ! given the wrong shell4.
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, IN
      esfs :: MAT{REAL}, OUT
      eub,fub,n_sum :: INT, IN

      if (min(.a.l,.b.l) < 3 AND min(.c.l,.d.l) < 3) then !s or p or d
       .form_3d_ints_no_rm(Ix,Iy,Iz,esfs,eub,fub)
      else
       .form_3d_ints_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum)
      end

   end

   form_3d_ints_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private
   ! Forms the three dimensional integrals from the two dimensional integrals,
   ! summed over primitives.
   ! This version uses the reduced multiplication scheme.
   ! WARNING: this routine has a bug for l>3
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, IN
      esfs :: MAT{REAL}, OUT
      eub,fub,n_sum :: INT, IN

      e_x,e_y,e_z,f_x,f_y,f_z,ii_e_ivec,ii_f_ivec :: VEC{INT}@
      Ief :: MAT3{REAL}*
      e,f,zf,yf,ze,ye,iie,iif,fe,le,ff,lf :: INT
      dime,dimf,dime1,dimf1,dime2,dimf2 :: INT

      dime  = .a.l+.b.l+1
      dime1 = dime+1
      dime2 = 2*dime1+1
      dimf  = .c.l+.d.l+1
      dimf1 = dimf+1
      dimf2 = 2*dimf1+1

      fe = GAUSSIAN_DATA:n_comp_up_to(max(.a.l,.b.l)-1) + 1
      ff = GAUSSIAN_DATA:n_comp_up_to(max(.c.l,.d.l)-1) + 1
      le = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l)
      lf = GAUSSIAN_DATA:n_comp_up_to(.c.l+.d.l)

      e_x = GAUSSIAN_DATA::nx(fe:le)
      e_y = GAUSSIAN_DATA::ny(fe:le)
      e_z = GAUSSIAN_DATA::nz(fe:le)

      f_x = GAUSSIAN_DATA::nx(ff:lf)
      f_y = GAUSSIAN_DATA::ny(ff:lf)
      f_z = GAUSSIAN_DATA::nz(ff:lf)

      ii_e_ivec.create(eub)
      do e=1,eub
       ze = e_z(e)
       ii_e_ivec(e) = -dime1 + ze*(dime2-ze)/2 + e_y(e)
      end
      ii_f_ivec.create(fub)
      do f=1,fub
       zf = f_z(f)
       ii_f_ivec(f) = -dimf1 + zf*(dimf2-zf)/2 + f_y(f)
      end

      ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
      Ief.create(n_sum,dime*dime1/2,dimf*dimf1/2)
      iif = 0
      do zf=1,dimf
       do yf=1,dimf1-zf
         iif = iif + 1
         iie = 0
         do ze=1,dime
           do ye=1,dime1-ze
             iie = iie + 1
             Ief(:,iie,iif) = Iy(:,ye,yf) * Iz(:,ze,zf)
           end
         end
       end
      end

      ! Now add in the Ix 2d integrals and sum over contractions and roots
      esfs = sum(Ix(:,e_x,f_x) * Ief(:,ii_e_ivec,ii_f_ivec),dim=1)
      Ief.destroy

      ii_f_ivec.destroy
      ii_e_ivec.destroy

   end

   form_3d_ints_no_rm(Ix,Iy,Iz,esfs,eub,fub) ::: private
   ! Forms the three dimensional integrals from the two dimensional integrals,
   ! summed over primitives.
   ! This version does not use the reduced multiplication scheme.
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, IN
      esfs :: MAT{REAL}, OUT
      eub,fub :: INT, IN

      e,f,fe,le,ff,lf :: INT
      e_x,e_y,e_z,f_x,f_y,f_z :: VEC{INT}@

      fe = GAUSSIAN_DATA:n_comp_up_to(max(.a.l,.b.l)-1) + 1
      ff = GAUSSIAN_DATA:n_comp_up_to(max(.c.l,.d.l)-1) + 1
      le = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l)
      lf = GAUSSIAN_DATA:n_comp_up_to(.c.l+.d.l)

      e_x = GAUSSIAN_DATA::nx(fe:le)
      e_y = GAUSSIAN_DATA::ny(fe:le)
      e_z = GAUSSIAN_DATA::nz(fe:le)

      f_x = GAUSSIAN_DATA::nx(ff:lf)
      f_y = GAUSSIAN_DATA::ny(ff:lf)
      f_z = GAUSSIAN_DATA::nz(ff:lf)

      !esfs = sum(Ix(:,e_x,f_x) * Iy(:,e_y,f_y) * Iz(:,e_z,f_z),dim=1)
      do e = 1,eub
      do f = 1,fub
         esfs(e,f) = sum(Ix(:,e_x(e),f_x(f)) * Iy(:,e_y(e),f_y(f)) * Iz(:,e_z(e),f_z(f)))
      end
      end

   end

   transfer_cd(esfs,escd)
   ! Applies the transfer equation to (es|fs) to give (es|cd)
      self :: IN
      esfs :: MAT{REAL}, IN
      escd :: MAT3{REAL}, OUT

      if (.c.l > .d.l) then
       .transfer_l_c_highest(esfs,escd)
      else
       .transfer_l_d_highest(esfs,escd)
      end

   end

   transfer_ab(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT3{REAL}, IN
      abcd :: MAT4{REAL}, OUT

      if (.a.l > .b.l) then
       .transfer_l_a_highest(escd,abcd)
      else
       .transfer_l_b_highest(escd,abcd)
      end

   end

   transfer_ab(escd,abcd)
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT{REAL}, IN
      abcd :: MAT3{REAL}, OUT

      if (.a.l > .b.l) then
       .transfer_l_a_highest(escd,abcd)
      else
       .transfer_l_b_highest(escd,abcd)
      end

   end

   transfer_l_c_highest(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd)
      self :: IN
      esfs :: MAT{REAL}, IN
      escd :: MAT3{REAL}, OUT

      int_new,int_old :: MAT3{REAL}*
      components,components_c,components_d :: MAT{INT}@
      index_c,index_d :: MAT3{INT}*
      comp_to_use,component_to_use :: VEC{INT}*
      CD :: VEC{REAL}(3)
      c,d,c1,c2,c3,d1,ld,cub,dub,ab_l_max :: INT
      cx,cy,cz,dx,dy,dz,j,clb,dlb,dob,e,eub :: INT
      CDi,CDx,CDy,CDz,esfs_ec :: REAL

      select case (.d.l)

       case (0)
         escd(:,:,1)=esfs

       case (1)
         ab_l_max = max(.a.l,.b.l)-1
         clb = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)
         cub  = .c.n_comp
         eub = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l) - GAUSSIAN_DATA:n_comp_up_to(ab_l_max)
         CD   = .c.position - .d.position

         components =  GAUSSIAN_DATA::nn(:,clb+1:clb+cub)
         index_c    => GAUSSIAN_DATA::index_of

         CDx = CD(1); CDy = CD(2); CDz = CD(3)
         do c = 1, cub
           cx = components(1,c)
           cy = components(2,c)
           cz = components(3,c)
           c1 = index_c(cx+1,cy,cz) - clb
           c2 = index_c(cx,cy+1,cz) - clb
           c3 = index_c(cx,cy,cz+1) - clb
           do e = 1, eub
             esfs_ec = esfs(e,c)
             escd(e,c,1) = esfs(e,c1) + CDx * esfs_ec
             escd(e,c,2) = esfs(e,c2) + CDy * esfs_ec
             escd(e,c,3) = esfs(e,c3) + CDz * esfs_ec
           end
         end

       case default
         ab_l_max = max(.a.l,.b.l)-1
         clb  = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)
         eub  = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l) - GAUSSIAN_DATA:n_comp_up_to(ab_l_max)
         CD   = .c.position - .d.position
         cub  = GAUSSIAN_DATA:n_comp_up_to((.c.l+.d.l)-1) - clb

         comp_to_use  => GAUSSIAN_DATA::first_nonzero
         components   =  GAUSSIAN_DATA::nn
         components_c =  GAUSSIAN_DATA::nn(:,clb+1:clb+cub)
         index_c      => GAUSSIAN_DATA::index_of
         index_d      => GAUSSIAN_DATA::index_of

         nullify(int_new)
         int_new.create(eub,cub,3)

         CDx = CD(1); CDy = CD(2); CDz = CD(3)
         do c = 1, cub
           cx = components_c(1,c)
           cy = components_c(2,c)
           cz = components_c(3,c)
           c1 = index_c(cx+1,cy,cz) - clb
           c2 = index_c(cx,cy+1,cz) - clb
           c3 = index_c(cx,cy,cz+1) - clb
           do e = 1, eub
             esfs_ec = esfs(e,c)
             int_new(e,c,1) = esfs(e,c1) + CDx * esfs_ec
             int_new(e,c,2) = esfs(e,c2) + CDy * esfs_ec
             int_new(e,c,3) = esfs(e,c3) + CDz * esfs_ec
           end
         end

           dlb              = 1
         do ld=2, .d.l - 1
           dob              = dlb
           dlb              = GAUSSIAN_DATA:n_comp_up_to(ld-1)
           dub              = GAUSSIAN_DATA:n_comp(ld)
           cub              = GAUSSIAN_DATA:n_comp_up_to((.c.l+.d.l)-ld) - clb
           component_to_use => comp_to_use(dlb+1:dlb+dub)
           components_d     =  components(:,dlb+1:dlb+dub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(eub,cub,dub)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             j=component_to_use(d)
             SHELL4::subtract_from_component(dx,dy,dz,j)
             d1 = index_d(dx,dy,dz) - dob
             CDi=CD(j)
             do c=1,cub
               cx = components_c(1,c)
               cy = components_c(2,c)
               cz = components_c(3,c)
               SHELL4::add_to_component(cx,cy,cz,j)
               c1 = index_c(cx,cy,cz) - clb
               int_new(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
             end
           end
           int_old.destroy
         end

         dob              = dlb
         dlb              = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)
         dub              = .d.n_comp
         cub              = .c.n_comp
         component_to_use => comp_to_use(dlb+1:dlb+dub)
         components_d     =  components(:,dlb+1:dlb+dub)
         int_old          => int_new
         do d=1,dub
           dx = components_d(1,d)
           dy = components_d(2,d)
           dz = components_d(3,d)
           j=component_to_use(d)
           SHELL4::subtract_from_component(dx,dy,dz,j)
           d1 = index_d(dx,dy,dz) - dob
           CDi=CD(j)
           do c=1,cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             SHELL4::add_to_component(cx,cy,cz,j)
             c1 = index_c(cx,cy,cz) - clb
             escd(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
           end
         end
         int_old.destroy
      end

   end

   transfer_l_d_highest(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd)
      self :: IN
      esfs :: MAT{REAL}, IN
      escd :: MAT3{REAL}, OUT

      int_new,int_old :: MAT3{REAL}*
      components,components_c,components_d :: MAT{INT}@
      index_c,index_d :: MAT3{INT}*
      comp_to_use,component_to_use :: VEC{INT}*
      DC :: VEC{REAL}(3)
      c,d,c1,d1,d2,d3,lc,cub,dub,ab_l_max :: INT
      cx,cy,cz,dx,dy,dz,j,clb,dlb,cob,e,eub :: INT
      DCi,DCx,DCy,DCz,esfs_ed :: REAL

      select case (.c.l)

       case (0)
         escd(:,1,:)=esfs

       case (1)
         ab_l_max = max(.a.l,.b.l)-1
         dlb = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)
         dub  = .d.n_comp
         eub = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l) - GAUSSIAN_DATA:n_comp_up_to(ab_l_max)
         DC   = .d.position - .c.position

         components =  GAUSSIAN_DATA::nn(:,dlb+1:dlb+dub)
         index_d    => GAUSSIAN_DATA::index_of

         DCx=DC(1); DCy=DC(2); DCz=DC(3)
         do d=1,dub
           dx = components(1,d)
           dy = components(2,d)
           dz = components(3,d)
           d1 = index_d(dx+1,dy,dz) - dlb
           d2 = index_d(dx,dy+1,dz) - dlb
           d3 = index_d(dx,dy,dz+1) - dlb
           do e = 1,eub
             esfs_ed = esfs(e,d)
             escd(e,1,d)=esfs(e,d1)+DCx*esfs_ed
             escd(e,2,d)=esfs(e,d2)+DCy*esfs_ed
             escd(e,3,d)=esfs(e,d3)+DCz*esfs_ed
           end
         end

       case default
         ab_l_max = max(.a.l,.b.l)-1
         dlb = GAUSSIAN_DATA:n_comp_up_to(.d.l-1)
         eub = GAUSSIAN_DATA:n_comp_up_to(.a.l+.b.l) - GAUSSIAN_DATA:n_comp_up_to(ab_l_max)
         DC   = .d.position - .c.position
         dub  = GAUSSIAN_DATA:n_comp_up_to(.c.l+.d.l-1) - dlb

         comp_to_use  => GAUSSIAN_DATA::first_nonzero
         components   =  GAUSSIAN_DATA::nn
         components_d =  GAUSSIAN_DATA::nn(:,dlb+1:dlb+dub)
         index_c      => GAUSSIAN_DATA::index_of
         index_d      => GAUSSIAN_DATA::index_of

         nullify(int_new)
         int_new.create(eub,dub,3)

         DCx=DC(1); DCy=DC(2); DCz=DC(3)
         do d=1,dub
           dx = components_d(1,d)
           dy = components_d(2,d)
           dz = components_d(3,d)
           d1 = index_d(dx+1,dy,dz) - dlb
           d2 = index_d(dx,dy+1,dz) - dlb
           d3 = index_d(dx,dy,dz+1) - dlb
           do e = 1,eub
             esfs_ed = esfs(e,d)
             int_new(e,d,1)=esfs(e,d1)+DCx*esfs_ed
             int_new(e,d,2)=esfs(e,d2)+DCy*esfs_ed
             int_new(e,d,3)=esfs(e,d3)+DCz*esfs_ed
           end
         end
        
           clb              = 1
         do lc=2, .c.l - 1
           cob              = clb
           clb              = GAUSSIAN_DATA:n_comp_up_to(lc-1)
           cub              = GAUSSIAN_DATA:n_comp(lc)
           dub              = GAUSSIAN_DATA:n_comp_up_to((.c.l+.d.l)-lc) - dlb
           component_to_use => comp_to_use(clb+1:clb+cub)
           components_c     =  components(:,clb+1:clb+cub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(eub,dub,cub)
           do c=1,cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             j=component_to_use(c)
             SHELL4::subtract_from_component(cx,cy,cz,j)
             c1 = index_c(cx,cy,cz) - cob
             DCi=DC(j)
             do d=1,dub
               dx = components_d(1,d)
               dy = components_d(2,d)
               dz = components_d(3,d)
               SHELL4::add_to_component(dx,dy,dz,j)
               d1 = index_d(dx,dy,dz) - dlb
               int_new(:,d,c)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
             end
           end
           int_old.destroy
         end

         cob              = clb
         clb              = GAUSSIAN_DATA:n_comp_up_to(.c.l-1)
         cub              = .c.n_comp
         dub              = .d.n_comp
         component_to_use => comp_to_use(clb+1:clb+cub)
         components_c     =  components(:,clb+1:clb+cub)
         int_old          => int_new
         do c=1,cub
           cx = components_c(1,c)
           cy = components_c(2,c)
           cz = components_c(3,c)
           j=component_to_use(c)
           SHELL4::subtract_from_component(cx,cy,cz,j)
           c1 = index_c(cx,cy,cz) - cob
           DCi=DC(j)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             SHELL4::add_to_component(dx,dy,dz,j)
             d1 = index_d(dx,dy,dz) - dlb
             escd(:,c,d)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
           end
         end
         int_old.destroy
      end

   end

   transfer_l_a_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT3{REAL}, IN
      abcd :: MAT4{REAL}, OUT

      int_new,int_old :: MAT4{REAL}*
      components,components_a,components_b :: MAT{INT}@
      index_a,index_b :: MAT3{INT}*
      comp_to_use,component_to_use :: VEC{INT}*
      AB :: VEC{REAL}(3)
      a,b,c,d,a1,a2,a3,b1,lb,aub,bub,cub,dub :: INT
      ax,ay,az,bx,by,bz,j,alb,blb,bob :: INT
      ABi,ABx,ABy,ABz,escd_acd :: REAL

      select case (.b.l)
       case (0)
         abcd(:,1,:,:)=escd

       case (1)
         alb = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)
         aub  = .a.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp
         AB   = .a.position - .b.position

         components =  GAUSSIAN_DATA::nn(:,alb+1:alb+aub)
         index_a    => GAUSSIAN_DATA::index_of

         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components(1,a)
           ay = components(2,a)
           az = components(3,a)
           a1 = index_a(ax+1,ay,az) - alb
           a2 = index_a(ax,ay+1,az) - alb
           a3 = index_a(ax,ay,az+1) - alb
           do d=1,dub
             do c=1,cub
               escd_acd = escd(a,c,d)
               abcd(a,1,c,d)=escd(a1,c,d) + ABx * escd_acd
               abcd(a,2,c,d)=escd(a2,c,d) + ABy * escd_acd
               abcd(a,3,c,d)=escd(a3,c,d) + ABz * escd_acd
             end
           end
         end

       case default
         alb = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)
         AB   = .a.position - .b.position
         aub  = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-1) - alb
         bub  = .b.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         comp_to_use  => GAUSSIAN_DATA::first_nonzero
         components   =  GAUSSIAN_DATA::nn
         components_a =  GAUSSIAN_DATA::nn(:,alb+1:alb+aub)
         index_a      => GAUSSIAN_DATA::index_of
         index_b      => GAUSSIAN_DATA::index_of

         nullify(int_new)
         int_new.create(cub,dub,bub,aub)

         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           a1 = index_a(ax+1,ay,az) - alb
           a2 = index_a(ax,ay+1,az) - alb
           a3 = index_a(ax,ay,az+1) - alb
           do d=1,dub
             do c=1,cub
               escd_acd = escd(a,c,d)
               int_new(c,d,1,a)=escd(a1,c,d) + ABx * escd_acd
               int_new(c,d,2,a)=escd(a2,c,d) + ABy * escd_acd
               int_new(c,d,3,a)=escd(a3,c,d) + ABz * escd_acd
             end
           end
         end

           blb              = 1
         do lb=2, .b.l - 1
           bob              = blb
           blb              = GAUSSIAN_DATA:n_comp_up_to(lb-1)
           bub              = GAUSSIAN_DATA:n_comp(lb)
           aub              = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-lb) - alb
           component_to_use => comp_to_use(blb+1:blb+bub)
           components_b     =  components(:,blb+1:blb+bub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(cub,dub,bub,aub)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             j = component_to_use(b)
             SHELL4::subtract_from_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz) - bob
             ABi=AB(j)
             do a=1,aub
               ax = components_a(1,a)
               ay = components_a(2,a)
               az = components_a(3,a)
               SHELL4::add_to_component(ax,ay,az,j)
               a1 = index_a(ax,ay,az) - alb
               int_new(:,:,b,a)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
             end
           end
           int_old.destroy
         end

         bob              = blb
         blb              = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)
         bub              = .b.n_comp
         aub              = .a.n_comp
         component_to_use => comp_to_use(blb+1:blb+bub)
         components_b     =  components(:,blb+1:blb+bub)
         int_old          => int_new
         do b=1,bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           j = component_to_use(b)
           SHELL4::subtract_from_component(bx,by,bz,j)
           b1 = index_b(bx,by,bz) - bob
           ABi=AB(j)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             SHELL4::add_to_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az) - alb
             abcd(a,b,:,:)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
           end
         end
         int_old.destroy
      end

   end

   transfer_l_b_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT3{REAL}, IN
      abcd :: MAT4{REAL}, OUT

      int_new,int_old :: MAT4{REAL}*
      components,components_a,components_b :: MAT{INT}@
      index_a,index_b :: MAT3{INT}*
      comp_to_use,component_to_use :: VEC{INT}*
      BA :: VEC{REAL}(3)
      a,b,c,d,a1,b1,b2,b3,la,aub,bub,cub,dub :: INT
      ax,ay,az,bx,by,bz,j,alb,blb,aob :: INT
      BAi,BAx,BAy,BAz,escd_bcd :: REAL

      select case (.a.l)

      case (0)
        abcd(1,:,:,:)=escd

      case (1)
        blb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)
        bub  = .b.n_comp
        cub  = .c.n_comp
        dub  = .d.n_comp
        BA   = .b.position - .a.position

        components =  GAUSSIAN_DATA::nn(:,blb+1:blb+bub)
        index_b    => GAUSSIAN_DATA::index_of

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components(1,b)
          by = components(2,b)
          bz = components(3,b)
          b1 = index_b(bx+1,by,bz) - blb
          b2 = index_b(bx,by+1,bz) - blb
          b3 = index_b(bx,by,bz+1) - blb
          do d = 1, dub
            do c = 1, cub
              escd_bcd = escd(b,c,d)
              abcd(1,b,c,d) = escd(b1,c,d) + BAx * escd_bcd
              abcd(2,b,c,d) = escd(b2,c,d) + BAy * escd_bcd
              abcd(3,b,c,d) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

      case default
        blb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)
        BA   = .b.position - .a.position
        bub  = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-1) - blb
        aub  = .a.n_comp
        cub  = .c.n_comp
        dub  = .d.n_comp

        comp_to_use  => GAUSSIAN_DATA::first_nonzero
        components   =  GAUSSIAN_DATA::nn
        components_b =  GAUSSIAN_DATA::nn(:,blb+1:blb+bub)
        index_b      => GAUSSIAN_DATA::index_of
        index_a      => GAUSSIAN_DATA::index_of

        nullify(int_new)
        int_new.create(cub,dub,bub,aub)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          b1 = index_b(bx+1,by,bz) - blb
          b2 = index_b(bx,by+1,bz) - blb
          b3 = index_b(bx,by,bz+1) - blb
          do c = 1, cub
            do d = 1, dub
              escd_bcd = escd(b,c,d)
              int_new(c,d,b,1) = escd(b1,c,d) + BAx * escd_bcd
              int_new(c,d,b,2) = escd(b2,c,d) + BAy * escd_bcd
              int_new(c,d,b,3) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

          alb              = 1
        do la=2, .a.l - 1
          aob              = alb
          alb              = GAUSSIAN_DATA:n_comp_up_to(la-1)
          aub              = GAUSSIAN_DATA:n_comp(la)
          bub              = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-la) - blb
          component_to_use => comp_to_use(alb+1:alb+aub)
          components_a     =  components(:,alb+1:alb+aub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(cub,dub,bub,aub)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            j=component_to_use(a)
            SHELL4::subtract_from_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az) - aob
            BAi=BA(j)
            do b=1,bub
              bx = components_b(1,b)
              by = components_b(2,b)
              bz = components_b(3,b)
              SHELL4::add_to_component(bx,by,bz,j)
              b1 = index_b(bx,by,bz) - blb
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
            end
          end
          int_old.destroy
        end

        aob              = alb
        alb              = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)
        aub              = .a.n_comp
        bub              = .b.n_comp
        component_to_use => comp_to_use(alb+1:alb+aub)
        components_a     =  components(:,alb+1:alb+aub)
        int_old          => int_new
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          j = component_to_use(a)
          SHELL4::subtract_from_component(ax,ay,az,j)
          a1 = index_a(ax,ay,az) - aob
          BAi=BA(j)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            SHELL4::add_to_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz) - blb
            abcd(a,b,:,:)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
          end
        end
        int_old.destroy

      end

   end

   transfer_l_a_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT{REAL}, IN
      abcd :: MAT3{REAL}, OUT

      int_new,int_old :: MAT3{REAL}*
      components,components_a,components_b :: MAT{INT}@
      index_a,index_b :: MAT3{INT}*
      comp_to_use,component_to_use :: VEC{INT}*
      AB :: VEC{REAL}(3)
      a,b,f,a1,a2,a3,b1,lb,aub,bub,fub :: INT
      ax,ay,az,bx,by,bz,j,alb,blb,bob :: INT
      ABi,ABx,ABy,ABz,escd_acd :: REAL

      select case (.b.l)

      case (0)
        abcd(:,1,:)=escd

      case (1)
        alb = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)
        aub  = .a.n_comp
        fub  = size(escd,2)
        AB   = .a.position - .b.position

        components =  GAUSSIAN_DATA::nn(:,alb+1:alb+aub)
        index_a    => GAUSSIAN_DATA::index_of

        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components(1,a)
          ay = components(2,a)
          az = components(3,a)
          a1 = index_a(ax+1,ay,az) - alb
          a2 = index_a(ax,ay+1,az) - alb
          a3 = index_a(ax,ay,az+1) - alb
          do f=1,fub
            escd_acd = escd(a,f)
            abcd(a,1,f)=escd(a1,f) + ABx * escd_acd
            abcd(a,2,f)=escd(a2,f) + ABy * escd_acd
            abcd(a,3,f)=escd(a3,f) + ABz * escd_acd
          end
        end

      case default
        alb = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)
        AB   = .a.position - .b.position
        aub  = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-1) - alb
        bub  = .b.n_comp
        fub  = size(escd,2)

        comp_to_use  => GAUSSIAN_DATA::first_nonzero
        components   =  GAUSSIAN_DATA::nn
        components_a =  GAUSSIAN_DATA::nn(:,alb+1:alb+aub)
        index_a      => GAUSSIAN_DATA::index_of
        index_b      => GAUSSIAN_DATA::index_of

        nullify(int_new)
        int_new.create(fub,bub,aub)

        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          a1 = index_a(ax+1,ay,az) - alb
          a2 = index_a(ax,ay+1,az) - alb
          a3 = index_a(ax,ay,az+1) - alb
          do f=1,fub
            escd_acd = escd(a,f)
            int_new(f,1,a)=escd(a1,f) + ABx * escd_acd
            int_new(f,2,a)=escd(a2,f) + ABy * escd_acd
            int_new(f,3,a)=escd(a3,f) + ABz * escd_acd
          end
        end

          blb              = 1
        do lb=2, .b.l - 1
          bob              = blb
          blb              = GAUSSIAN_DATA:n_comp_up_to(lb-1)
          bub              = GAUSSIAN_DATA:n_comp(lb)
          aub              = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-lb) - alb
          component_to_use => comp_to_use(blb+1:blb+bub)
          components_b     =  components(:,blb+1:blb+bub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(fub,bub,aub)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            j = component_to_use(b)
            SHELL4::subtract_from_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz) - bob
            ABi=AB(j)
            do a=1,aub
              ax = components_a(1,a)
              ay = components_a(2,a)
              az = components_a(3,a)
              SHELL4::add_to_component(ax,ay,az,j)
              a1 = index_a(ax,ay,az) - alb
              int_new(:,b,a)=int_old(:,b1,a1) + ABi * int_old(:,b1,a)
            end
          end
          int_old.destroy
        end

        bob              = blb
        blb              = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)
        bub              = .b.n_comp
        aub              = .a.n_comp
        component_to_use => comp_to_use(blb+1:blb+bub)
        components_b     =  components(:,blb+1:blb+bub)
        int_old          => int_new
        do b=1,bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          j = component_to_use(b)
          SHELL4::subtract_from_component(bx,by,bz,j)
          b1 = index_b(bx,by,bz) - bob
          ABi=AB(j)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            SHELL4::add_to_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az) - alb
            do f=1,fub
              abcd(a,b,f)=int_old(f,b1,a1) + ABi * int_old(f,b1,a)
            end
          end
        end
        int_old.destroy

      end

   end

   transfer_l_b_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
      self :: IN
      escd :: MAT{REAL}, IN
      abcd :: MAT3{REAL}, OUT

      int_new,int_old :: MAT3{REAL}*
      components,components_a,components_b :: MAT{INT}@
      comp_to_use,component_to_use :: VEC{INT}*
      index_a,index_b :: MAT3{INT}*
      BA :: VEC{REAL}(3)
      a,b,f,a1,b1,b2,b3,la,aub,bub,fub :: INT
      ax,ay,az,bx,by,bz,j,alb,blb,aob :: INT
      BAi,BAx,BAy,BAz,escd_bcd :: REAL

      select case (.a.l)

       case (0)
         abcd(1,:,:)=escd

       case (1)
         blb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)
         bub  = .b.n_comp
         fub  = size(escd,2)
         BA   = .b.position - .a.position

         components =  GAUSSIAN_DATA::nn(:,blb+1:blb+bub)
         index_b    => GAUSSIAN_DATA::index_of

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components(1,b)
           by = components(2,b)
           bz = components(3,b)
           b1 = index_b(bx+1,by,bz) - blb
           b2 = index_b(bx,by+1,bz) - blb
           b3 = index_b(bx,by,bz+1) - blb
           do f = 1, fub
             escd_bcd = escd(b,f)
             abcd(1,b,f) = escd(b1,f) + BAx * escd_bcd
             abcd(2,b,f) = escd(b2,f) + BAy * escd_bcd
             abcd(3,b,f) = escd(b3,f) + BAz * escd_bcd
           end
         end

       case default
         blb = GAUSSIAN_DATA:n_comp_up_to(.b.l-1)
         BA   = .b.position - .a.position
         bub  = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-1) - blb
         aub  = .a.n_comp
         fub  = size(escd,2)

         comp_to_use  => GAUSSIAN_DATA::first_nonzero
         components   =  GAUSSIAN_DATA::nn
         components_b =  GAUSSIAN_DATA::nn(:,blb+1:blb+bub)
         index_b      => GAUSSIAN_DATA::index_of
         index_a      => GAUSSIAN_DATA::index_of

         nullify(int_new)
         int_new.create(fub,bub,aub)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           b1 = index_b(bx+1,by,bz) - blb
           b2 = index_b(bx,by+1,bz) - blb
           b3 = index_b(bx,by,bz+1) - blb
           do f = 1, fub
             escd_bcd = escd(b,f)
             int_new(f,b,1) = escd(b1,f) + BAx * escd_bcd
             int_new(f,b,2) = escd(b2,f) + BAy * escd_bcd
             int_new(f,b,3) = escd(b3,f) + BAz * escd_bcd
           end
         end

           alb              = 1
         do la=2, .a.l - 1
           aob              = alb
           alb              = GAUSSIAN_DATA:n_comp_up_to(la-1)
           aub              = GAUSSIAN_DATA:n_comp(la)
           bub              = GAUSSIAN_DATA:n_comp_up_to((.a.l+.b.l)-la) - blb
           component_to_use => comp_to_use(alb+1:alb+aub)
           components_a     =  components(:,alb+1:alb+aub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(fub,bub,aub)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             j=component_to_use(a)
             SHELL4::subtract_from_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az) - aob
             BAi=BA(j)
             do b=1,bub
               bx = components_b(1,b)
               by = components_b(2,b)
               bz = components_b(3,b)
               SHELL4::add_to_component(bx,by,bz,j)
               b1 = index_b(bx,by,bz) - blb
               int_new(:,b,a)=int_old(:,b1,a1) + BAi * int_old(:,b,a1)
             end
           end
           int_old.destroy
         end

         aob              = alb
         alb              = GAUSSIAN_DATA:n_comp_up_to(.a.l-1)
         aub              = .a.n_comp
         bub              = .b.n_comp
         component_to_use => comp_to_use(alb+1:alb+aub)
         components_a     =  components(:,alb+1:alb+aub)
         int_old          => int_new
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           j = component_to_use(a)
           SHELL4::subtract_from_component(ax,ay,az,j)
           a1 = index_a(ax,ay,az) - aob
           BAi=BA(j)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             SHELL4::add_to_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz) - blb
             do f=1,fub
               abcd(a,b,f)=int_old(f,b1,a1) + BAi * int_old(f,b,a1)
             end
           end
         end
         int_old.destroy
      end

   end

   add_to_component(x,y,z,j) ::: selfless, private, pure
   ! Adds one to the component specified by j.  Used by transfer equation.
   ! j=1 => x=x+1, j=2 => y=y+1, j=3 => z=z+1.
      x,y,z :: INT, INOUT
      j :: INT, IN

      select case(j)
       case (1); x = x + 1
       case (2); y = y + 1
       case (3); z = z + 1
      end

   end

   subtract_from_component(x,y,z,j) ::: selfless, private, pure
   ! Subtracts one from the component specified by j.  Used by transfer
   ! equation.  j=1 => x=x-1, j=2 => y=y-1, j=3 => z=z-1.
      x,y,z :: INT, INOUT
      j :: INT, IN

      select case(j)
         case (1); x = x - 1
         case (2); y = y - 1
         case (3); z = z - 1
      end

   end

!  ==============================
!  Make the J and K contributions
!  ==============================

   make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Make the J and K contribution due to self and P and add it in.
   ! For any shell4!
      self :: IN
      J :: MAT{REAL}
      K :: MAT{REAL}, target
      P :: MAT{REAL}, IN
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

      I4 :: MAT4{REAL}*
      Kc,Kd :: VEC{REAL}*
      P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
      a,b,c,d :: INT

      I4.create(fa,la,fb,lb,fc,lc,fd,ld)
      .get_ERI(I4)

      if (factor > 0.9) then

       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + Kbc
             Kd(b) = Kd(b) + Kbd
           end
           J(c,d) = J(c,d) + Jcd
         end
       end

      else

       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = factor*P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = factor*P(d,b)
             P_cb = factor*P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + factor*Kbc
             Kd(b) = Kd(b) + factor*Kbd
           end
           J(c,d) = J(c,d) + factor*Jcd
         end
       end

      end

      I4.destroy

   end

!  =============================
!  Make only the J contributions
!  =============================

   make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Make the J contribution due to self and P and add it in.
   ! For any shell4!
      self :: IN
      J :: MAT{REAL}
      P :: MAT{REAL}, IN
      factor :: REAL, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, IN

      I4 :: MAT4{REAL}*
      P_dc,Jcd,I_abcd :: REAL
      a,b,c,d :: INT

      I4.create(fa,la,fb,lb,fc,lc,fd,ld)
      .get_ERI(I4)

      if (factor > 0.9) then

       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           Jcd = ZERO
           do b = fb,lb
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + Jcd
         end
       end

      else

       do d = fd,ld
         do c = fc,lc
           P_dc = factor*P(d,c)
           Jcd = ZERO
           do b = fb,lb
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + factor*Jcd
         end
       end

      end

      I4.destroy

   end

!  ===============
!  Output Routines
!  ===============

   put
   ! Put the shell4 information to file "out"

      n_cc,i :: INT

      stdout.flush
      stdout.show("A shell l quantum number =",.a.l)
      stdout.show("B shell l quantum number =",.b.l)
      stdout.show("C shell l quantum number =",.c.l)
      stdout.show("D shell l quantum number =",.d.l)
      stdout.show("A position               =",.a.position)
      stdout.show("B position               =",.b.position)
      stdout.show("C position               =",.c.position)
      stdout.show("D position               =",.d.position)

      stdout.flush
      stdout.dash(int_fields=1,real_fields=8)
      stdout.put("N", int_width=TRUE)
      stdout.put("ex_a")
      stdout.put("cc_a")
      stdout.put("ex_b")
      stdout.put("cc_b")
      stdout.put("ex_c")
      stdout.put("cc_c")
      stdout.put("ex_d")
      stdout.put("cc_d")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=8)
      n_cc = max(.a.n_cc,.b.n_cc,.c.n_cc,.d.n_cc)
      do i = 1,n_cc
        stdout.put(i)
        if (i<=.a.n_cc) then
        stdout.put( .a.exponent(i))
        stdout.put( .a.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.b.n_cc) then
        stdout.put( .b.exponent(i))
        stdout.put( .b.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.c.n_cc) then
        stdout.put( .c.exponent(i))
        stdout.put( .c.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.d.n_cc) then
        stdout.put( .d.exponent(i))
        stdout.put( .d.contraction(i))
        else
        stdout.tab(real_fields=2)
        end
        stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=8)

   end

end
