!---------------------------------------------------------------------------
!
!  ROBY:
!
!  Read and evaluate Roby atom data for population and bond analysis.
!  This module has been completely rewritten from Chris Taylor's version,
!  based on Steve Wolff's checked version.
!
! Copyright (C) Chris Taylor, UWA, 1999.
! Copyright (C) Stephen Wolff, UWA, 2000-2001.
! Copyright (C) Dylan Jayatilaka, 2001
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module ROBY

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   create(mol) ::: leaky
   ! Create space for the object
      self :: PTR
      mol :: MOLECULE

      .create
      .set_defaults(mol)

   end

   destroy ::: leaky, PURE
   ! Destroy space for an SCF type
      self :: PTR

      if (.disassociated) return

      .nullify_ptr_data

      .destroy_ptr_part

      deallocate(self)

   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      nullify(.n1)
      nullify(.n2)

      nullify(.bond_index)
      nullify(.cov_index)
      nullify(.ion_index)
      nullify(.percent_covalency)

      nullify(.gould_charge)
      nullify(.cruickshank_charge)

      nullify(.summed_n2)
      nullify(.summed_n3)
      nullify(.subgroup_pop)

      nullify(.atom_list)
      nullify(.atom_group)
      nullify(.atom_a)
      nullify(.atom_b)
      nullify(.atom_ab)

      nullify(.theta_C)
      nullify(.eigen_C)
      nullify(.theta_I)
      nullify(.eigen_I)
      nullify(.theta_pop_C)
      nullify(.theta_pop_C_A)
      nullify(.theta_pop_C_B)
      nullify(.theta_pop_I)
      nullify(.theta_pop_I_A)
      nullify(.theta_pop_I_B)

      nullify(.theta_cov_index)
      nullify(.theta_ion_index)
      nullify(.proportion_a)
      nullify(.pair)

      nullify(.rho)
      nullify(.overlap_matrix)
      nullify(.atom)

   end

   nullify_ptr_data ::: pure
   ! Nullify the pointer data that is supposed to come from outside
   ! this module, so that this data is *not* accidentally destroyed
      self :: INOUT

      nullify(.rho)
      nullify(.atom)
      nullify(.overlap_matrix)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .n1.destroy
      .n2.destroy

      .bond_index.destroy
      .cov_index.destroy
      .ion_index.destroy
      .percent_covalency.destroy

      .gould_charge.destroy
      .cruickshank_charge.destroy

      .summed_n2.destroy
      .summed_n3.destroy
      .subgroup_pop.destroy

      .atom_list.destroy
      .atom_group.destroy
      .atom_a.destroy
      .atom_b.destroy
      .atom_ab.destroy

      .theta_C.destroy
      .eigen_C.destroy
      .theta_I.destroy
      .eigen_I.destroy
      .theta_pop_C.destroy
      .theta_pop_C_A.destroy
      .theta_pop_C_B.destroy
      .theta_pop_I.destroy
      .theta_pop_I_A.destroy
      .theta_pop_I_B.destroy

      .theta_cov_index.destroy
      .theta_ion_index.destroy

      .proportion_a.destroy
      .pair.destroy

      ! Never destroy these.
      nullify(.rho)
      nullify(.atom)
      nullify(.overlap_matrix)

   end

   destroy_theta_info ::: leaky, private, PURE
   ! Delete all the temporary theta subspace information created by
   ! various bond index routines
      self :: INOUT

      ! Theta population indices
      .theta_ion_index.destroy
      .theta_cov_index.destroy
      .theta_pop_I_B.destroy
      .theta_pop_I_A.destroy
      .theta_pop_I.destroy
      .theta_pop_C_B.destroy
      .theta_pop_C_A.destroy
      .theta_pop_C.destroy

      ! Theta energy indiced
      .theta_E_ion_index.destroy
      .theta_E_cov_index.destroy
      .theta_E_B.destroy
      .theta_E_A.destroy
      .theta_E_I.destroy
      .theta_E_C.destroy

      ! Theta eigenstates
      .eigen_I.destroy
      .theta_I.destroy
      .pair.destroy
      .theta_angle.destroy
      .eigen_C.destroy
      .theta_C.destroy

   end

   destroy_bond_info ::: leaky, private, PURE
   ! Delete all the bond index info
   ! index routines
      self :: INOUT

      .percent_covalency.destroy
      .ion_index.destroy
      .cov_index.destroy
      .bond_index.destroy

   end


!  ===========
!  Set methods
!  ===========

   set_defaults ::: PURE
   ! Set default SCF data values
      self :: INOUT

      .roby_kind = "bond_and_charge_analysis"

      .zero_angle_cutoff      = ROBY_ZERO_ANGLE_CUTOFF*RADIAN_PER_DEGREE
      .occupied_ANO_cutoff    = ROBY_OCCUPIED_ANO_CUTOFF

      .output_theta_info      = ROBY_OUTPUT_THETA_INFO
      .use_NAOs               = FALSE
      .analyze_all_atom_pairs = ROBY_ANALYZE_ALL_ATOM_PAIRS
      .analyze_vdw_atom_pairs = FALSE
      .bond_range_factor      = ROBY_BOND_RANGE_FACTOR

   end

   set_defaults(mol)
   ! Set default SCF data values
      self :: INOUT
      mol :: MOLECULE, target, IN

   ENSURE(mol.atom.associated,"no atom list") 
   ENSURE(mol.density_matrix.associated,"no density matrix") 
   ENSURE(mol.overlap_matrix.associated,"no overlap matrix") 

      .set_defaults

      .charge            =  mol.charge
      .spin_multiplicity =  mol.spin_multiplicity

      .atom              => mol.atom
      .rho               => mol.density_matrix
      .overlap_matrix    => mol.overlap_matrix
      .core_matrix       => mol.core_matrix
      .fock_matrix       => mol.fock_matrix

   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         case ("}                      ")  ! exit case

         case ("analyze_all_atom_pairs="); .read_analyze_all_atom_pairs
         case ("analyze_vdw_atom_pairs="); .read_analyze_vdw_atom_pairs
         case ("atom_groups=           "); .read_atom_groups
         case ("atom_list=             "); .read_atom_list

         case ("bond_scale_factors=    "); .read_bond_scale_factor

         case ("kind=                  "); .read_kind

         case ("occupied_ano_cutoff=   "); .read_occupied_ano_cutoff
         case ("output_theta_info=     "); .read_output_theta_info

         case ("put_core_matrix        "); stdout.put(.core_matrix)
         case ("put_density_matrix     "); stdout.put(.rho)
         case ("put_fock_matrix        "); stdout.put(.fock_matrix)
         case ("put_overlap_matrix     "); stdout.put(.overlap_matrix)
         
         case ("use_naos=              "); .read_use_naos
         
         case ("zero_angle_cutoff=     "); .read_zero_angle_cutoff

         case default;           UNKNOWN(word)

      end

   end

   finalize ::: leaky
   ! Make sure the input satisfies sanity checks and generate any other
   ! missing data
      self :: INOUT

   ENSURE(.roby_kind/=" ","no calculation kind specified")
   ENSURE(.atom.associated,"no atom data supplied")
 ! ENSURE(.atom_list.associated NEQV .atom_group.associated,"atom_list and atom_group both used!")

      if (FALSE) self = self

   end

   read_kind
   ! Read the SCF type
      self :: INOUT

      stdin.read(.roby_kind)

      select case (.roby_kind)
      case("atom_bond_analysis       ")
      case("atom_energy_bond_analysis")
      case("atom_hyper_analysis      ")
      case("group_bond_analysis      ")
      case("group_hyper_analysis     ")
      case default;  UNKNOWN(.roby_kind)
      end

   end

   read_atom_list ::: leaky
   ! Read the list of atoms indices defining a Roby group
      self :: INOUT

      stdin.read_ptr(.atom_list)

   end

   read_atom_groups ::: leaky
   ! Read the list of atoms indices defining a Roby group
      self :: INOUT

      stdin.read_ptr(.atom_group)

   end

   read_occupied_ANO_cutoff
   ! Read the cutoff to decide occupied ANOs or NAOs
      self :: INOUT

      stdin.read_quantity(.occupied_ANO_cutoff)

   end

   read_zero_angle_cutoff
   ! Angles (in radians) *less* than this one inputted are regareded as zero
      self :: INOUT

      stdin.read_quantity(.zero_angle_cutoff)

   end

   read_output_theta_info
   ! Read in a switch which tells whether to output detailed
   ! theta-subspace bond information
      self :: INOUT

      stdin.read(.output_theta_info)

   end

   read_analyze_all_atom_pairs
   ! Read in a switch which tells whether to bond-analyze all atoms
   ! pairs or not - actually this just changes the bond_range_factor
   ! by an order of magnitude
      self :: INOUT

      stdin.read(.analyze_all_atom_pairs)

      if (.analyze_all_atom_pairs) then
         .bond_range_factor = FIVE*BOHR_PER_ANGSTROM
      end

   end

   read_analyze_vdw_atom_pairs
   ! Read in a switch which tells whether to bond-analyze all atoms
   ! pairs or not - actually this just changes the bond_range_factor
   ! by an order of magnitude
      self :: INOUT

      stdin.read(.analyze_vdw_atom_pairs)

   end

   read_use_NAOs
   ! Read whether to use NAOs as atomic projectors instead
   ! of ANOs as in the original 2008 paper.
      self :: INOUT

      stdin.read(.use_NAOs)

   end

   read_bond_scale_factor
   ! Read in a bond scale factor used to multiply the sum of the
   ! Bragg-Slater radii for two atoms, to determine a distance cutoff
   ! within which atoms are regarded to be bonded
      self :: INOUT

      stdin.read(.bond_range_factor)

   end

!  ===================
!  Information methods
!  ===================

   is_homoleptic result (res) ::: pure
   ! Returns TRUE if the calculation data is "homoleptic" or not
   ! i.e. involving groups of atoms
      self :: IN
      res :: BIN

      res = .atom_list.disassociated

   end

   skip_pair(a,b) result (res) ::: private, pure
   ! Returns TRUE if the bond index calculation should skip the pair of groups
   ! (a,b). For calculations which are homoleptic, this always returns FALSE, but
   ! for calculations which are defined by an atom_list, this returns TRUE only if
   ! .analyze_all_atom_pairs is set to FALSE and the atoms are regarded as bonded
   ! according to the .bond_range_factor distance cutoff.
      self :: IN
      a,b :: INT, IN
      res :: BIN

      if (.is_homoleptic) then;
      
         ! Do all 
         res = FALSE

      else if (.analyze_all_atom_pairs) then
      
         ! Do all
         res = FALSE

      else if (.analyze_vdw_atom_pairs) then

         ! Do only vdw pairs
         res = NOT .atom.vdw_bonded(a,b,.bond_range_factor)

      else

         ! Do bonded pairs
         res = NOT .atom.bonded(a,b,.bond_range_factor)

         ! Do vdw pairs too
         res = res AND NOT .atom.vdw_bonded(a,b)

      end

   end

   n_bf(group) result (res) ::: private, PURE
   ! Return the number of basis functions in the atom group
   ! whose indices are given in "group"; but if "group" is
   ! not present return the dimension of the full overlap matrix.
      self :: IN
      group :: VEC{INT}, optional, IN
      res :: INT

   ENSURE(.atom.associated,"No atom information")
   ENSURE(.overlap_matrix.associated,"No overlap matrix")

      if (present(group)) then; res = .atom(group).no_of_basis_functions
      else;                     res = .overlap_matrix.dim1
      end

   end

   n_bf_a result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_a group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_a.associated,"No atom A group")

      res = .n_bf(.atom_a)

   end

   n_bf_b result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_b group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_b.associated,"No atom B group")

      res = .n_bf(.atom_b)

   end

   n_bf_ab result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_b group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_ab.associated,"No atom AB group")

      res = .n_bf(.atom_ab)

   end

   n_group result (res) ::: private, PURE
   ! Return the number of roby atom groups
      self :: IN
      res :: INT

   ENSURE(.atom_group.associated,"no atom groups!")

      res = .atom_group.dim

   end

   no_of_occupied_NAOs(group,tol) result (res) ::: private, PURE
   ! Return the number of occupied NAOs for the group of atoms whose
   ! indices are in "group"
      self :: IN
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.atom.associated,"no atom information")

      eps :: REAL

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      res = .atom(group).no_of_occupied_NAOs(tol=eps)

   end

   no_of_occupied_ANOs(group,tol) result (res) ::: private, PURE
   ! Return the number of occupied atomic natural orbitals for
   ! the group of atoms whose indices are in "group"
      self :: IN
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.atom.associated,"no atom information")

      eps :: REAL

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      res = .atom(group).no_of_occupied_ANOs(tol=eps)

   end

   unique_tags result (res) ::: leaky
   ! Return a list of unique tags for the atom groups
      self :: IN
      res :: VEC{STR}*

      symbols :: VEC{STR}*
      g :: INT

      if (.is_homoleptic) then
         res.create(.atom_group.dim)
         do g = 1,.atom_group.dim
            symbols => .atom(.atom_group(g).element).unique_tags
            res(g)  = VEC{STR}:to_concatenated_str(symbols)
            symbols.destroy
         end
      else
         res => .atom(.atom_list).unique_tags
      end

   end

! ============
! Main methods
! ============

   atom_bond_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")

      i,n_atom :: INT

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Bond orders
      .is_hyper_analysis = FALSE
      .bond_analysis
    ! .charge_analysis

      .put_basics
      .put_populations
      .put_bond_indices

   end

   atom_hyper_analysis ::: leaky
   ! Do a Roby-Gould ionic/hypervalent bond analysis
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")

      i,n_atom :: INT

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Bond orders
      .is_hyper_analysis = TRUE
      .hyper_analysis

      ! Put
      .put_basics
      .put_populations
      .put_bond_indices

   end


   group_bond_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

      .bond_analysis
    ! .charge_analysis

      .put_basics
      .put_populations
      .put_bond_indices

   end

   group_hyper_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

      .hyper_analysis
    ! .charge_analysis

      .put_basics
      .put_populations
      .put_bond_indices_hyper

   end


   bond_analysis ::: leaky, private
   ! Do a Roby-Gould bond and charge analysis for the atom groups
   ! given in .atom_groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group defined")

      n_group,a,b :: INT
      ind,pcc,cov,ion :: REAL

      n_group = .n_group

      ! Populations
      .make_populations
      .make_pair_populations

      ! Clean
      .destroy_bond_info
      .bond_index.create(n_group,n_group)
      .cov_index.create(n_group,n_group)
      .ion_index.create(n_group,n_group)
      .percent_covalency.create(n_group,n_group)

      ! Make bonds for pairs of group
      do a = 1,n_group
      do b = 1,a-1

         if (.skip_pair(a,b)) cycle
        
         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element
        
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        
         !!!!!!!!!!!!!!!!!!!
         .destroy_theta_info
         .make_theta_info
         !!!!!!!!!!!!!!!!!!!
        
         ind = .gould_bond_index(cov,ion,pcc)
        
         .bond_index(a,b)        =  ind
         .cov_index(a,b)         =  cov
         .ion_index(a,b)         =  ion
         .percent_covalency(a,b) =  pcc
        
         .bond_index(b,a)        =  ind
         .cov_index(b,a)         =  cov
         .ion_index(b,a)         = -ion
         .percent_covalency(b,a) =  pcc
        
         if (.output_theta_info) then
            .put_theta_info
            .put_theta_BI_info
            .put_theta_AB_pops
         end
        
      end
      end

   end

   hyper_analysis ::: leaky, private
   ! Do a Roby-Gould hypervalent bond analysis for the atom groups
   ! given in .atom_groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group defined")

      n_group,a :: INT
      ind,pcc,cov,ion :: REAL

      n_group = .n_group

      ! Populations
      .make_populations

      .put_populations

      ! This is actually M, not ~M
      .atom_b.to_sequence(1,.atom.dim)
      .atom_ab.to_sequence(1,.atom.dim)

      ! Clean
      .destroy_bond_info
      .bond_index.create(n_group,n_group)
      .cov_index.create(n_group,n_group)
      .ion_index.create(n_group,n_group)
      .percent_covalency.create(n_group,n_group)

      ! Make bonds for A to ~M
      do a = 1,n_group
        
         ! A group
         .atom_a => .atom_group(a).element
        
         !!!!!!!!!!!!!!!!!!!
         .destroy_theta_info
         .make_hyper_info
         !!!!!!!!!!!!!!!!!!!
        
         ind = .gould_bond_index(cov,ion,pcc)
        
         .bond_index(a,a)        =  ind
         .cov_index(a,a)         =  cov
         .ion_index(a,a)         =  ion
         .percent_covalency(a,a) =  pcc
        
         if (.output_theta_info) then
            .put_theta_info
            .put_theta_BI_info
            .put_theta_AB_pops
         end
        
      end

   end

! =================================
! Roby population analysis routines
! =================================

   make_single_atom_groups ::: leaky, private
   ! Make each Roby atom to be equal to a single atom formed from
   ! each element in the ".atom_list".

   ENSURE(.atom_list.associated,"no atom list")

      n_atom,a :: INT

      n_atom = size(.atom_list)

      .atom_group.destroy
      .atom_group.create(n_atom)

      do a = 1,n_atom
         .atom_group(a).element.create(1)
         .atom_group(a).element(1) = .atom_list(a)
      end

   end

   make_populations ::: leaky, private
   ! Make the Roby populations for the defined atom groups, for a
   ! given density matrix "rho"
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.rho.associated,"no rho matrix")

      a :: INT

      ! Clean
      .n1.destroy
      .n1.create(.n_group)

      ! Population of all atoms
      .atom_ab.to_sequence(1,.atom.dim)
      .n_all = .population(.atom_ab)
      .atom_ab.destroy

      ! Make populations
      do a = 1,.n_group

         .atom_a => .atom_group(a).element

         .n1(a)  =  .population(.atom_a)

         nullify(.atom_a)

      end


   end

   make_pair_populations ::: leaky, private
   ! Make the pair Roby populations
      self :: INOUT

      n_group,a,b :: INT
      pop :: REAL

      n_group = .n_group

      ! Clean
      .n2.destroy
      .n2.create(n_group,n_group)
      .n2 = ZERO

      ! Make pair populations
      do a = 1,n_group
      do b = 1,a-1

         if (.skip_pair(a,b)) cycle
         
         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element
         
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         
         pop = .population(.atom_ab)

         .n2(a,b) = pop
         .n2(b,a) = pop
         
         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

   end

   population(group,ANO,reverse) result (res) ::: private
   ! Return the total population for the projector P associated with
   ! the group of atoms whose indices are in "group", i.e 
   !   res = Tr (P_{group;ANO} rho) 
   ! where "rho" is the density matrix for a molecule. If present, the
   ! columns of the "ANO" matrix are used to define the Roby projector
   ! instead of the atomic natural orbitals.
      self :: INOUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN
      reverse :: BIN, optional, IN
      res :: REAL

   ENSURE(.rho.associated,"no rho matrix")
   ENSURE(.overlap_matrix.associated,"no overlap matrix")

      P :: MAT{REAL}*
      gr :: VEC{INT}*
      n_gr :: INT
      rev :: BIN

      ! Reverse
      rev = FALSE
      if (present(reverse)) rev = reverse

      ! Group atom indices
      if (rev) then
         gr.to_sequence(1,.atom.dim)
         gr.prune(group)
      else
         gr.create_copy(group)
      end

      ! No. of groups
      n_gr = .n_bf(gr)

      ! Make small P matrix
      P.create(n_gr,n_gr)
      .make_projection_matrix(P,gr,ANO)

      ! Evaluate
      res = .expectation(P,gr)

      ! Clean
      P.destroy
      gr.destroy

   end

   subpopulation(subgroup,group,ANO) result (res) ::: private
   ! Return the Roby subpopulation for the subgroup of atoms whose
   ! indices are given in "subgroup", in the whole group of atoms
   ! whose indices are are given in "group", i.e
   !    res = Tr ( P_{subgroup} P_{group;ANO} P_{subgroup} rho )
   ! If present, the columns of the "ANO" matrix are used to define
   ! the middle Roby projector instead of the atomic natural orbitals.
   ! Note that the real atomic natural orbitals are always used for
   ! the P_{subgroup} projector.  This routine is useful for getting
   ! theta orbital populations.
      self :: INOUT
      subgroup :: VEC{INT}, IN
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN
      res :: REAL

   ENSURE(.rho.associated,"no rho matrix")
   ENSURE(.overlap_matrix.associated,"no overlap matrix")

      P,X,P_sub :: MAT{REAL}*
      n_gr,n_sub :: INT

      n_gr  = .n_bf(group)
      n_sub = .n_bf(subgroup)

      X.create(n_sub,n_sub)
      P.create(n_gr,n_gr)
      P_sub.create(n_sub,n_sub)

      .make_projection_matrix(P,group,ANO)
      .make_projection_matrix(P_sub,subgroup)
      .project(P,P_sub,X,group,subgroup)

      P_sub.destroy
      P.destroy

      res = .expectation(X,subgroup)

      X.destroy

   end

! ================================
! Roby multiple shared populations
! ================================

!   make_shared_population ::: leaky, private
!   ! Evaluate the Roby shared population
!
!   ENSURE(.atom_group.associated,"no atom group supplied")
!
!      n_group,i :: INT
!
!      n_group = .n_group
!
!      .subgroup_pop.destroy
!      .subgroup_pop.create(n_group)
!
!      i = 0
!      .n_shared = .shared_population([(i,i=1,n_group)], .subgroup_pop)
!
!   end

!   shared_population(group_list,pop_groups) result (res) ::: private
!   ! Returns the Roby shared population of the group of .atom_groups whose
!   ! indices are in "group". If "pop_groups" is present, the total
!   ! sub-group populations of every size from 1 to size(group) is returned
!      group_list :: VEC{INT}
!      pop_groups :: VEC{REAL}, optional
!      res :: REAL
!
!   ENSURE(.atom_group.associated,"no atom groups")
!
!      pop_k :: REAL
!      m, k, n_k, n :: INT
!      comb_mat :: MAT{INT}*
!      pop_group :: VEC{REAL}*
!
!      n = size(group_list)
!
!      pop_group.create(n)
!
!      res = ZERO
!      do k = 1,n
!
!         n_k = int(n.choose(k))
!
!         ! Make "comb_mat", the matrix of all combinations of the groups
!         ! of size k, where the groups are taken from .atom_group
!         comb_mat.create(k,n_k)
!         group_list.make_combinations_of_length(k,comb_mat)
!
!         pop_k = 0
!         do m = 1,n_k
!            .atom_group.append_listed_to(.atom_ab,list=comb_mat(:,m))
!            pop_k = pop_k + .population(.atom_ab)
!            .atom_ab.destroy
!         end
!         pop_group(k) = pop_k
!
!         comb_mat.destroy
!
!         res = res - ((-1)**k)*pop_k
!
!      end
!
!      if (present(pop_groups)) pop_groups = pop_group
!
!      pop_group.destroy
!
!   end

!   make_summed_pair_pops ::: leaky, private
!   ! Evaluate the SUMMED Roby shared populations for groups of 2 atoms.
!   ! On return, .summed_n2(a) = \sum_{b} s_{ab}, where s_{ab} is the pairwise
!   ! shared population for atoms a, b.
!
!   ENSURE(.n1.associated,"no group populations")
!   ENSURE(.n2.associated,"no group pair populations")
!
!      shared_population :: REAL
!      n_group,a,b :: INT
!
!      n_group = .n_group
!      .summed_n2.create(n_group)
!
!      .summed_n2 = ZERO
!
!      do a = 1,n_group
!      do b = a+1,n_group
!         shared_population = .n1(a) + .n1(b) - .n2(a,b)
!         .summed_n2(a)     = .summed_n2(a) + shared_population
!         .summed_n2(b)     = .summed_n2(b) + shared_population
!      end
!      end
!
!   end

!   make_summed_triple_pops ::: leaky, private
!   ! Evaluate the SUMMED Roby shared populations for groups of 3 atoms.
!   ! On return, .summed_n3(a) = \sum_{bc} s_{abc}, where s_{abc} is the triple
!   ! shared population for atoms a, b, and c.
!
!      shared_population :: REAL
!      n_group,a,b,c :: INT
!
!      n_group = .n_group
!      .summed_n3.create(n_group)
!
!      .summed_n3 = ZERO
!
!      do a = 1  ,n_group
!      do b = a+1,n_group
!      do c = b+1,n_group
!         shared_population = .shared_population([a,b,c])
!         .summed_n3(a)     = .summed_n3(a) + shared_population
!         .summed_n3(b)     = .summed_n3(b) + shared_population
!         .summed_n3(c)     = .summed_n3(c) + shared_population
!      end
!      end
!      end
!
!   end

! ==========
! Bond index
! ==========

   gould_bond_index(c_ab,i_ab,pcc) result (bond_index) ::: leaky, private
   ! Calculates the Roby-Gould "bond_index", percentage covalent character
   ! "pcc", for atom groups ".atom_a" and ".atom_b".
      self :: INOUT
      c_ab,i_ab,pcc :: REAL, OUT
      bond_index :: REAL

   ENSURE(.theta_pop_C.associated,"no covalent theta populations")
   ENSURE(.theta_pop_I.associated,"no ionic theta populations")
   ENSURE(.pair.associated,"no pair array")

      n0,i :: INT

      n0 = .eigen_I.dim

      .theta_cov_index.create(n0)
      .theta_ion_index.create(n0)

      .theta_cov_index = ZERO
      .theta_ion_index = ZERO

      pcc  = ZERO
      c_ab = ZERO
      i_ab = ZERO
      bond_index = ZERO

      do i = 1,n0

        if (.eigen_I(i)>.eigen_I(.pair(i))) then
        
        if (.pair(i)/=i) then
           .theta_cov_index(i) = HALF*(.theta_pop_C(i) - .theta_pop_C(.pair(i)))
           .theta_ion_index(i) = HALF*(.theta_pop_I(i) - .theta_pop_I(.pair(i)))
           c_ab = c_ab + .theta_cov_index(i)
           i_ab = i_ab + .theta_ion_index(i)
        else if (.eigen_I(i)>ZERO) then
           ! Store bond index, do not add into i_ab
           .theta_ion_index(i) =  HALF*(.theta_pop_I(i))
        else if (.eigen_I(i)<ZERO) then
           ! Store bond index, do not add into i_ab
           .theta_ion_index(i) = -HALF*(.theta_pop_I(i))
        end

        end

      end

      bond_index = c_ab**2 + i_ab**2
      pcc        = 100 * (c_ab**2/bond_index)
      bond_index = sqrt(bond_index)

   end

! ====================
! Angle-space analysis
! ====================

   make_theta_info ::: leaky, private
   ! Calculates the Roby-Gould theta subspace information for atom groups
   ! ".atom_a" and ".atom_b", including theta subspace populations
      self :: INOUT

   ENSURE(.atom_a.associated,"no atom A group")
   ENSURE(.atom_b.associated,"no atom B group")
   ENSURE(.atom_ab.associated,"no atom AB group")

      I :: MAT{REAL}*
      theta_I :: MAT{REAL}*
      eigen_I :: VEC{REAL}*
      ind :: VEC{INT}*
      n_a,n_b,n_ab, n0 :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = n_a + n_b

      ! Make the ionic operator & ionic states
      theta_I.create(n_ab,n_ab)
      eigen_I.create(n_ab)

      I.create(n_ab,n_ab)                      

      .make_ionic_operator(I)
      .diagonalize_V_AB_operator(I,theta_I,eigen_I)

      I.destroy

      stdout.text("eigen_I")
      stdout.put(eigen_I)

      ! Prune zero eigenvalues
      n0 = eigen_I.no_of_abs_vals_larger_than(.zero_angle_cutoff) 

      stdout.show("n0 = ",n0)

      ind.create(n0)
      ind = eigen_I.indices_of_abs_vals_larger_than(.zero_angle_cutoff) 

      stdout.text("ind")
      stdout.put(ind)

      .theta_I.create(n_ab,n0)
      .eigen_I.create(n0)

      .theta_I = theta_I(:,ind)
      .eigen_I = eigen_I(ind)

      ind.destroy
      eigen_I.destroy
      theta_I.destroy

      stdout.text(".theta_I")
      stdout.put(.theta_I)

      stdout.text(".eigen_I")
      stdout.put(.eigen_I)

    ! stdout.text(".theta_I")
    ! stdout.put(.theta_I)

      ! Find +/- ionic pairs
      .pair.create(n0)
      .eigen_I.find_non_unit_pairs(.pair,ROBY::match_pair,tol=TOL(8))

      stdout.text("pair")
      stdout.put(.pair)

      ! Make theta angles
      .theta_angle.create(n0)
      .make_theta_angles

      stdout.text("theta_angle")
      stdout.put(.theta_angle)

      ! Clean up |ion> states
      .make_gould_ionic_orbitals

      ! Make |cov> pairs from |ion> pairs
      .theta_C.create(n_ab,n0)
      .eigen_C.create(n0)
      .make_cov_from_ion_orbitals

      stdout.text(".theta_I")
      stdout.put(.theta_C)
      stdout.text(".eigen_C")
      stdout.put(.eigen_C)

      ! Covalent theta populations
      .theta_pop_C.create(n0)
      .theta_pop_C_A.create(n0)
      .theta_pop_C_B.create(n0)
      .make_theta_populations(.theta_pop_C,.theta_pop_C_A,.theta_pop_C_B,.theta_C) 

      ! Ionic theta populations
      .theta_pop_I.create(n0)
      .theta_pop_I_A.create(n0)
      .theta_pop_I_B.create(n0)
      .make_theta_populations(.theta_pop_I,.theta_pop_I_A,.theta_pop_I_B,.theta_I)

   end

   make_hyper_info ::: leaky, private
   ! Calculates the Roby-Gould theta subspace information for atom
   ! groups ".atom_a" and everything not in ".atom".
      self :: INOUT

   ENSURE(.atom_a.associated,"no atom A group")
   ENSURE(.atom_b.associated,"no atom B group")
   ENSURE(.atom_ab.associated,"no atom AB group")

      I :: MAT{REAL}*
      theta_I :: MAT{REAL}*
      eigen_I :: VEC{REAL}*
      ind :: VEC{INT}*
      n_bf, n0 :: INT

      n_bf = .n_bf

      ! Make the ionic operator & ionic states
      theta_I.create(n_bf,n_bf)
      eigen_I.create(n_bf)

      I.create(n_bf,n_bf)                      

      .make_hyper_operator(I)
      .diagonalize_full_operator(I,theta_I,eigen_I)

      stdout.text("I")
      stdout.put(I)

      I.destroy

      stdout.text("eigen_I")
      stdout.put(eigen_I)

      ! Prune zero eigenvalues
      n0 = eigen_I.no_of_abs_vals_larger_than(TOL(8)) 

      stdout.show("n0 = ",n0)

      ind.create(n0)
      ind = eigen_I.indices_of_abs_vals_larger_than(TOL(8)) 

      .theta_I.create(n_bf,n0)
      .eigen_I.create(n0)

      .theta_I = theta_I(:,ind)
      .eigen_I = eigen_I(ind)

      ind.destroy
      eigen_I.destroy
      theta_I.destroy

      stdout.text(".theta_I")
      stdout.put(.theta_I)

      stdout.text(".eigen_I")
      stdout.put(.eigen_I)

      ! Find +/- ionic pairs
      .pair.create(n0)
      .eigen_I.find_non_unit_pairs(.pair,ROBY::match_pair,tol=TOL(8))

      stdout.text("pair")
      stdout.put(.pair)

      ! Make theta angles
      .theta_angle.create(n0)
      .make_theta_angles

      stdout.text("theta_angle")
      stdout.put(.theta_angle)

      ! Clean up |ion> states
      .make_gould_ionic_orbitals

      stdout.text(".theta_I")
      stdout.put(.theta_I)
      stdout.text(".eigen_I")
      stdout.put(.eigen_I)

      ! Make |cov> pairs from |ion> pairs
      .theta_C.create(n_bf,n0)
      .eigen_C.create(n0)
      .make_cov_from_ion_orbitals

      stdout.text(".theta_C")
      stdout.put(.theta_C)
      stdout.text(".eigen_C")
      stdout.put(.eigen_C)

      ! Covalent theta populations
      .theta_pop_C.create(n0)
      .theta_pop_C_A.create(n0)
      .theta_pop_C_B.create(n0)
      .make_theta_populations(.theta_pop_C,.theta_pop_C_A,.theta_pop_C_B,.theta_C) 

      ! Ionic theta populations
      .theta_pop_I.create(n0)
      .theta_pop_I_A.create(n0)
      .theta_pop_I_B.create(n0)
      .make_theta_populations(.theta_pop_I,.theta_pop_I_A,.theta_pop_I_B,.theta_I)

   end

! Low level helper routines

   match_pair(arg1,arg2) result (res) ::: selfless, private
   ! Function which returns zero if "arg1" and "arg2" are opposite.
   ! Used for matching pairs purposes.
      arg1,arg2 :: REAL, IN
      res :: REAL

      res = abs(arg1 + arg2)

   end

   make_theta_populations(pop,pop_a,pop_b,theta) ::: private
   ! Make "pop", an array of "theta" populations for a pair of Roby
   ! atoms defined by indices in ".atom_a" and ".atom_b". "theta"
   ! itself is a matrix whose columns are coefficients on V_AB.
      self :: INOUT
      pop :: VEC{REAL}, OUT
      pop_a,pop_b :: VEC{REAL}, OUT
      theta :: MAT{REAL}, IN

   ENSURE(.atom_ab.associated,"No roby atom group AB")
   ENSURE(pop.dim==theta.dim2,"wrong size, pop")

      i :: INT

      do i = 1,theta.dim2
         pop(i)   =    .population(        .atom_ab,ANO=theta(:,i:i))
         pop_a(i) = .subpopulation(.atom_a,.atom_ab,ANO=theta(:,i:i))
         pop_b(i) = .subpopulation(.atom_b,.atom_ab,ANO=theta(:,i:i))
      end

   end

   make_theta_angles ::: private
   ! Make the ".theta_angle" array from the Roby eigenvalues
   ! ".eigen_I". Angles are in degrees.
      self :: INOUT

   ENSURE(.eigen_I.associated,"No roby eigenvalues")
   ENSURE(.theta_angle.associated,"No theta_angle array")

      i :: INT
      value :: REAL

      do i = 1,.eigen_I.dim

         value = .eigen_I(i)
         value = value.arcsin
         value = value.to_units("degree")

         .theta_angle(i) = value

      end

   end

   make_gould_ionic_orbitals ::: private
   ! Generate the gould ionic orbitals ".theta_I" in such a way that
   ! the negative eigenvector of each pair is generated explicitly
   ! from the positive eigenvector by constructing the |a> and |b>
   ! parts using projectors P_A and P_B. ".eigen_I" are the
   ! eigenvalues corresponding to ".theta_I". ".pair" is defined so
   ! that the i-th eigenvector .theta_I(:,i) with +ve value is paired
   ! with theta_I(:,pair(i)) with negative eigenvalue. The spaces V_A,
   ! V_B and V_AB are defined by ".atom_a", ".atom_b", and ".atom_ab".
   ! This routine is necessary in cases where there are degeneracies.
      self :: INOUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")
   ENSURE(.atom.associated,"No atom information")
   ENSURE(.theta_I.associated,"No theta_I array")
   ENSURE(.theta_I.dim1==.n_bf_ab,"wrong shape, theta_I")
   ENSURE(.theta_I.is_square,"wrong shape, theta_I")
   ENSURE(.eigen_I.associated,"No eval_I array")
   ENSURE(.eigen_I.dim==.n_bf_ab,"wrong size, eigen_I")
   ENSURE(.pair.associated,"No pair array")
   ENSURE(.pair.dim==.n_bf_ab,"wrong shape, pair")

      PAS,PBS,PA,PB :: MAT{REAL}*
      A,B :: VEC{REAL}*
      n_a,n_b,n_ab,i :: INT
      fp,fm,fa,fb,s,c,s2 :: REAL

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      PAS.create(n_a,n_ab)
      PBS.create(n_b,n_ab)
      A.create(n_a)
      B.create(n_b)

      PA.create(n_a,n_a)
      PB.create(n_b,n_b)

      .make_projection_matrix(PA,.atom_a)
      .make_projection_matrix(PB,.atom_b)

      .right_overlap_transform(PA,PAS,.atom_a,.atom_ab)
      .right_overlap_transform(PB,PBS,.atom_b,.atom_ab)

      PB.destroy
      PA.destroy

      do i = 1,.eigen_I.dim

         if (.pair(i)<1) cycle
         if (.pair(i)==i) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         ! Bonding state (.eigen_I +ve)
         s  = .eigen_I(i)
         s2 = s*s
         if (s2.equals(ONE,TOL(8))) then; c = ZERO
         else;                            c = sqrt(ONE - s2)
         end

         ! Find |a> and |b> from +ve bonding state
         fm = sqrt(ONE - c)/s
         fp = sqrt(ONE + c)/s
         fa = HALF*(  (fm+fp)+c*(fm-fp))
         fb = HALF*(c*(fm+fp)+  (fm-fp))
         A  = ZERO
         B  = ZERO
         if (NOT fa.equals(ONE,TOL(8))) then
         A.to_product_of(PAS,.theta_I(:,i)); A = A/fa
         end
         if (NOT fb.equals(ONE,TOL(8))) then
         B.to_product_of(PBS,.theta_I(:,i)); B = B/fb
         end

         ! Construct -ve antibonding state in .pair(i)
         fa = HALF*(fm-fp)
         fb = HALF*(fm+fp)
         .theta_I(    1:n_a ,.pair(i)) = fa*A
         .theta_I(n_a+1:n_ab,.pair(i)) = fb*B

      end

      ! Clean
      B.destroy
      A.destroy
      PBS.destroy
      PAS.destroy

   end

!   make_gould_covalent_orbitals ::: private
!   ! Generate the gould covalent orbitals ".theta_C" in such a way
!   ! that the negative eigenvector of each pair is generated
!   ! explicitly from the positive eigenvector by constructing the |a>
!   ! and |b> parts using projectors P_A and P_B. ".eigen_C" are the
!   ! eigenvalues corresponding to ".theta_C". ".pair" is defined so
!   ! that the i-th eigenvector .theta_C(:,i) is paired with
!   ! theta_C(:,pair(i)). The spaces V_A , V_B and V_AB are defined by
!   ! ".atom_a", ".atom_b", and ".atom_ab". This routine is necessary
!   ! in the case where there are degeneracies.
!      self :: INOUT
!
!   ENSURE(.atom_a.associated,"No roby atom A")
!   ENSURE(.atom_b.associated,"No roby atom B")
!   ENSURE(.atom_ab.associated,"No roby atom AB")
!   ENSURE(.atom.associated,"No atom information")
!   ENSURE(.theta_C.associated,"No theta_C array")
!   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong shape, theta_C")
!   ENSURE(.theta_C.is_square,"wrong shape, theta_C")
!   ENSURE(.eigen_C.associated,"No eval_C array")
!   ENSURE(.eigen_C.dim==.n_bf_ab,"wrong shape, eval_I")
!   ENSURE(.pair.associated,"No pair array")
!   ENSURE(.pair.dim==.n_bf_ab,"wrong shape, pair")
!
!      PAS,PBS,PA,PB :: MAT{REAL}*
!      A,B :: VEC{REAL}*
!      n_a,n_b,n_ab,i :: INT
!      fac,costheta :: REAL
!
!      n_a  = .n_bf_a
!      n_b  = .n_bf_b
!      n_ab = .n_bf_ab
!
!      PAS.create(n_a,n_a)
!      PBS.create(n_b,n_b)
!      A.create(n_a)
!      B.create(n_b)
!
!      PA.create(n_a,n_ab)
!      PB.create(n_b,n_ab)
!
!      .make_projection_matrix(PA,.atom_a)
!      .make_projection_matrix(PB,.atom_b)
!
!      .right_overlap_transform(PA,PAS,.atom_a,.atom_ab)
!      .right_overlap_transform(PB,PBS,.atom_b,.atom_ab)
!
!      PB.destroy
!      PA.destroy
!
!      do i = 1,n_ab
!
!         if (.pair(i)<1) cycle
!         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle
!
!         ! Bonding state (.eigen_C +ve)
!         costheta = .eigen_C(i)
!
!         ! Find |a> and |b>
!       ! fac = sqrt(TWO+TWO*costheta)/(ONE+costheta)
!       ! fac = sqrt(TWO)*sqrt(ONE+costheta)/(ONE+costheta)
!         fac = sqrt(TWO)/sqrt(ONE+costheta)
!         A.to_product_of(PAS,.theta_C(:,i)); A = fac*A
!         B.to_product_of(PBS,.theta_C(:,i)); B = fac*B
!
!         ! Construct bonding state
!         fac = ONE/(sqrt(TWO)*sqrt(ONE-costheta))
!         .theta_C(    1:n_a ,.pair(i)) =  fac*A
!         .theta_C(n_a+1:n_ab,.pair(i)) = -fac*B
!
!      end
!
!      ! Clean
!      B.destroy
!      A.destroy
!      PBS.destroy
!      PAS.destroy
!
!   end

   make_cov_from_ion_orbitals ::: private
   ! Make ".theta_C" and ".eigen_C" from ".theta_I" and ".eigen_I".
      self :: INOUT

   ENSURE(.theta_I.associated,"no theta_I array")
   ENSURE(.theta_I.dim1==.n_bf_ab,"wrong dim1, theta_I")
   ENSURE(.theta_I.is_square,"wrong shape, theta_I")
   ENSURE(.eigen_I.associated,"no eval_I array")
   ENSURE(.eigen_I.dim==.n_bf_ab,"wrong dim, eval_I")
   ENSURE(.theta_C.associated,"no theta_C array")
   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong dim1, theta_C")
   ENSURE(.theta_C.is_square,"wrong shape, theta_C")
   ENSURE(.eigen_C.associated,"no eval_C array")
   ENSURE(.eigen_C.dim==.n_bf_ab,"wrong dim, eval_C")
   ENSURE(.pair.associated,"no pair array")
   ENSURE(.pair.dim==.n_bf_ab,"wrong shape, pair")

      fac,c,s :: REAL
      i,j :: INT
   !  eval :: MAT{REAL}(1,1)
   !  RR,SS :: MAT{REAL}*

   !  n_ab = .n_bf_ab

   !  RR.create(n_ab,n_ab)
   !  SS.create(n_ab,n_ab)

   !  stdout.text("1")
   !  .make_shared_operator(SS)
   !  stdout.text("2")
   !  .overlap_transform(SS,RR,.atom_ab,.atom_ab)
   !  stdout.text("3")

   !  SS.destroy

      .theta_C = ZERO
      .eigen_C = ZERO

      do i = 1,.eigen_I.dim

         if (.pair(i)<1) cycle
         if (.pair(i)==i) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         ! Index j of -ve antibonding orbital
         j = .pair(i)
        
         ! pi/4 rotation: eqn (64) in Gould et al (2008)
         fac = ONE/sqrt(TWO)
         .theta_C(:,i) = fac*(.theta_I(:,i)+.theta_I(:,j)) ! C+
         .theta_C(:,j) = fac*(.theta_I(:,i)-.theta_I(:,j)) ! C-
        
         ! Diagonalize I
       ! RR.change_basis_to(eval,.theta_C(:,i:i)); .eigen_C(i) = eval(1,1)
       ! RR.change_basis_to(eval,.theta_C(:,j:j)); .eigen_C(j) = eval(1,1)

         ! Set C eigenvalues
         s = .eigen_I(i)
         c = sqrt(ONE - s*s)
         .eigen_C(i) =  c
         .eigen_C(j) = -c

      end

    ! RR.destroy

   end

!   make_ion_from_cov_orbitals ::: private
!   ! Make the gould ionic orbitals ".theta_I" and eigenvalues
!   ! ".eigen_I" from the covalent orbitals ".theta_C" and covalent
!   ! eigenvalues ".eigen_C" which have been explicitly paired up as
!   ! described by the ".pair" array. ALSO: the ".pair" array is
!   ! modified to remove all those pairs which have zero sine and
!   ! cosine eigenvalues.
!      self :: INOUT
!
!   ENSURE(.theta_C.associated,"no theta_C array")
!   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong shape, theta_C")
!   ENSURE(.theta_C.is_square,"wrong shape, theta_C")
!   ENSURE(.theta_I.associated,"no theta_I array")
!   ENSURE(.theta_I.dim1==.n_bf_ab,"wrong shape, theta_I")
!   ENSURE(.theta_I.is_square,"wrong shape, theta_I")
!   ENSURE(.eigen_I.associated,"no eval_I array")
!   ENSURE(.eigen_I.dim==.n_bf_ab,"wrong shape, eval_I")
!   ENSURE(.eigen_C.associated,"no eval_C array")
!   ENSURE(.eigen_C.dim==.n_bf_ab,"wrong shape, eval_I")
!   ENSURE(.pair.associated,"no pair array")
!   ENSURE(.pair.dim==.n_bf_ab,"wrong shape, pair")
!
!      fac :: REAL
!      n_ab,i,j :: INT
!      eval :: MAT{REAL}(1,1)
!      ZZ,II :: MAT{REAL}*
!
!      n_ab = .pair.dim
!
!      ZZ.create(n_ab,n_ab)
!      II.create(n_ab,n_ab)
!
!      .make_ionic_operator(II)
!      .overlap_transform(II,ZZ,.atom_ab,.atom_ab)
!
!      II.destroy
!
!      .theta_I = ZERO
!      .eigen_I  = ZERO
!
!      do i = 1,n_ab
!
!         if (.pair(i)<1) cycle
!         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle
!
!         ! Index of matching pair
!         j = .pair(i)
!
!         ! pi/4 rotation: eqn (64) in Gould et al (2008)
!         fac = ONE/sqrt(TWO)
!         .theta_I(:,i) = fac*(.theta_C(:,i)+.theta_C(:,j)) ! I+
!         .theta_I(:,j) = fac*(.theta_C(:,i)-.theta_C(:,j)) ! I-
!
!         ! Diagonalize I
!         ZZ.change_basis_to(eval,.theta_I(:,i:i)); .eigen_I(i) = eval(1,1)
!         ZZ.change_basis_to(eval,.theta_I(:,j:j)); .eigen_I(j) = eval(1,1)
!
!      end
!
!      ZZ.destroy
!
!   end

   group_nuclear_charges result (res) ::: pure
   ! Sum of the nuclear charges in each group.
      self :: IN
      res :: VEC{REAL}(.atom_group.dim)

      g :: INT

      do g = 1,.atom_group.dim
         res(g) = .atom(.atom_group(g).element).sum_of_nuclear_charges
      end

   end

! =================
! Energy bond index
! =================

   atom_energy_bond_analysis ::: leaky
   ! Do a Roby energy-bond and Gould charge analysis.
   ! Only works for RHF case for now.
      self :: INOUT

   ENSURE(.atom_list.associated,"no atom list")
   ENSURE(.atom_group.disassociated,"do not use atom_group=")
   ENSURE(.core_matrix.associated,"no core_matrix!")
   ENSURE(.core_matrix.restricted.associated,"no restricted core_matrix!")
   ENSURE(.fock_matrix.associated,"no fock_matrix!")
   ENSURE(.fock_matrix.restricted.associated,"no restricted fock_matrix!")

      n_bf :: INT

      ! Make E_matrix
      n_bf = .core_matrix.n_bf
      .E_matrix.create(n_bf,n_bf)
      .E_matrix = HALF*(.core_matrix.restricted + .fock_matrix.restricted)

!     !!!!!!!!!!!!!!!!!!!!!!!!
!     .E_matrix.to_unit_matrix
!     !!!!!!!!!!!!!!!!!!!!!!!!
      
!     stdout.text("E_matrix:")
!     stdout.put(.E_matrix)

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Get group energies
      .energy_bond_analysis

      ! Output
      .put_all_energy_info

   end

   energy_bond_analysis ::: leaky, private
   ! Do a Roby-Gould energy-bond analysis for the atom groups
   ! given in .atom_groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group defined")

      n_group,a,b :: INT
      ind,pcc,cov,ion :: REAL

      n_group = .n_group

      .make_atom_energies
      .make_pair_energies

      .E_bond_index.create(n_group,n_group)
      .E_cov_index.create(n_group,n_group)
      .E_ion_index.create(n_group,n_group)
      .E_percent_covalency.create(n_group,n_group)

      do a = 1,n_group
      do b = 1,a-1

         if (.skip_pair(a,b)) cycle
        
         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        
         !!!!!!!!!!!!!!!!!!!!!!!
         .destroy_theta_info
         .make_theta_energy_info
         !!!!!!!!!!!!!!!!!!!!!!!
        
         ind = .energy_bond_index(cov,ion,pcc)
        
         .E_bond_index(a,b)        = ind
         .E_cov_index(a,b)         = cov
         .E_ion_index(a,b)         = ion
         .E_percent_covalency(a,b) = pcc
        
         .E_bond_index(b,a)        =  ind
         .E_cov_index(b,a)         =  cov
         .E_ion_index(b,a)         = -ion
         .E_percent_covalency(b,a) =  pcc
        
         if (.output_theta_info) then
            .put_theta_info
            .put_theta_energy_info
         end
        
         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

   end

   energy_bond_index(c_ab,i_ab,pcc) result (bond_index) ::: leaky, private
   ! Calculates the Roby-Gould "bond_index", percentage covalent character
   ! "pcc", for atom groups ".atom_a" and ".atom_b".
      self :: INOUT
      c_ab,i_ab,pcc :: REAL, OUT
      bond_index :: REAL

   ENSURE(.theta_angle.associated,"no theta angles")
   ENSURE(.theta_E_C.associated,"no covalent theta populations")
   ENSURE(.theta_E_I.associated,"no ionic theta populations")
   ENSURE(.pair.associated,"no pair array")

      n_ab,i :: INT
      zero_cutoff,angle :: REAL

      zero_cutoff = .zero_angle_cutoff.to_units("degree")

      n_ab = .n_bf_ab

      .theta_E_cov_index.create(n_ab)
      .theta_E_ion_index.create(n_ab)

      .theta_E_cov_index = ZERO
      .theta_E_ion_index    = ZERO

      pcc  = ZERO
      c_ab = ZERO
      i_ab = ZERO
      bond_index = ZERO

      do i = 1,n_ab

        if (.pair(i)<1) cycle
        if (.pair(i)<i) cycle

        angle = .theta_angle(i)

        .theta_E_cov_index(i) = HALF*(.theta_E_C(i) - .theta_E_C(.pair(i)))
        .theta_E_ion_index(i) = HALF*(.theta_E_I(i) - .theta_E_I(.pair(i)))


        if (angle <= 90.0d0 - zero_cutoff) c_ab = c_ab + .theta_E_cov_index(i)
        if (angle >=          zero_cutoff) i_ab = i_ab + .theta_E_ion_index(i)

      end

      bond_index = c_ab**2 + i_ab**2
      pcc        = 100 * (c_ab**2/bond_index)
      bond_index = sqrt(bond_index)

   end

   make_theta_energy_info ::: leaky, private
   ! Calculates the Roby-Gould theta ubspace energyinformation for
   ! atom groups ".atom_a" and ".atom_b", including theta subspace
   ! populations
      self :: INOUT

   ENSURE(.atom_a.associated,"no atom A group")
   ENSURE(.atom_b.associated,"no atom B group")
   ENSURE(.atom_ab.associated,"no atom AB group")

      I :: MAT{REAL}*
      n_a,n_b,n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = n_a + n_b

      ! Eigenstates
      .theta_C.create(n_ab,n_ab)
      .eigen_C.create(n_ab)

      .theta_angle.create(n_ab)
      .pair.create(n_ab)

      .theta_I.create(n_ab,n_ab)
      .eigen_I.create(n_ab)

      .theta_E_C.create(n_ab)
      .theta_E_I.create(n_ab)

      ! Make the ionic  operator
      I.create(n_ab,n_ab)                      
      .make_ionic_operator(I)

      ! Get ionic states
      .diagonalize_V_AB_operator(I,.theta_I,.eigen_I)

      ! Find +/- ionic pairs
      .eigen_I.find_pairs(.pair,ROBY::match_pair,tol=.zero_angle_cutoff)

      ! Make angles & clean up |ion> states
      .make_theta_angles
      .make_gould_ionic_orbitals

      ! Make |cov> pairs from |ion> pairs
      .make_cov_from_ion_orbitals

      ! Make covalent/ionic theta populations
      .make_theta_energies(.theta_E_C,.theta_C) 
      .make_theta_energies(.theta_E_I,.theta_I)

      ! Clean
      I.destroy

   end

   make_theta_energies(E,theta) ::: private
   ! Make "E", an array of "theta" energies for a pair of Roby atoms
   ! defined by indices in ".atom_a" and ".atom_b". "theta" itself is
   ! a matrix whose columns are coefficients on V_AB.
      self :: INOUT
      E :: VEC{REAL}, OUT
      theta :: MAT{REAL}, OUT

   ENSURE(.atom_ab.associated,"No roby atom group AB")
   ENSURE(E.dim==.n_bf_ab,"wrong size, E")

      i :: INT

      do i = 1,.n_bf_ab
         E(i) = .atom_energy(.atom_ab,ANO=theta(:,i:i))
      end

   end

   make_atom_energies ::: leaky, private
   ! Make the Roby energies for the defined atom groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.rho.associated,"no rho matrix")
   ENSURE(.E_matrix.associated,"no rho matrix")

      a :: INT

      .E1.destroy
      .E1.create(.n_group)

      do a = 1,.n_group

         .atom_a => .atom_group(a).element

         .E1(a)  =  .atom_energy(.atom_a)

         if (.n_group==.atom.dim) then
         .E1(a) = .E1(a) + HALF*.atom.nuclear_repulsion_for_atom(a)
         end

         nullify(.atom_a)

      end

   end

   make_pair_energies ::: leaky, private
   ! Make the pair Roby energies
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.rho.associated,"no rho matrix")
   ENSURE(.E_matrix.associated,"no rho matrix")

      n_group,a,b :: INT
      E2 :: REAL

      n_group = .n_group

      .E2.destroy
      .E2.create(n_group,n_group)

      .E2 = ZERO

      do a = 1,n_group
      do b = 1,a-1

         if (.skip_pair(a,b)) cycle
         
         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element
         
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         E2 = .atom_energy(.atom_ab)

         .E2(a,b) = E2
         .E2(b,a) = E2
         
         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

   end

   atom_energy(group,ANO) result (res) ::: private
   ! Return the total Roby energy for the group of atoms whose
   ! indices are given in "group", i.e Tr (P_{group;ANO} (E_matrix) rho), 
   ! where "rho" is the density matrix for a molecule. If present, the
   ! columns of the "ANO" matrix are used to define the Roby projector
   ! instead of the atomic natural orbitals.
      self :: INOUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN
      res :: REAL

   ENSURE(.rho.associated,"no rho matrix")
   ENSURE(.E_matrix.associated,"no rho matrix")
   ENSURE(.overlap_matrix.associated,"no overlap matrix")

      e,P :: MAT{REAL}*
      n_gr :: INT

      n_gr = .n_bf(group)

      ! Make small e
      e.create(n_gr,n_gr)
      .AO_subspace_set(e,.E_matrix,B_row_atom=group,B_col_atom=group)

      ! Make small P matrix
      P.create(n_gr,n_gr)
      .make_projection_matrix(P,group,ANO)

      ! Change basis of e
      e.change_basis_using(P)

      ! Evaluate
      res = .expectation(e,group)

      ! Clean
      P.destroy

   end

! Charge analysis

!   charge_analysis ::: leaky, private
!   ! Do a Roby-Cruickshank-Avramedes and Roby-Gould charge analysis.
!   ! NOTE: This can only be called after a bond analysis because the atom
!   ! proportions are required.
!   ENSURE(.atom_group.associated,"no atom groups")
!   ENSURE(.n1.associated,"no atom populations")
!
!      n_group,a,b :: INT
!      rsa,rsb,charge_deficit,fac :: REAL
!
!      n_group = .n_group
!      .proportion_a.create(n_group,n_group)
!
!      .proportion_a = ZERO
!
!      do a = 1,n_group
!      do b = 1,a-1
!
!        if (.skip_pair(a,b)) cycle
!
!        .atom_a => .atom_group(a).element
!        .atom_b => .atom_group(b).element
!        .atom_ab.append(.atom_a,.atom_b)
!
!        .destroy_theta_info
!        .make_theta_info
!
!        ! Store for later charge analysis
!        .make_atom_proportions(rsa,rsb) 
!        .proportion_a(a,b) = rsa
!        .proportion_a(b,a) = rsb
!      ! if (.output_theta_info) .put_theta_atom_pops
!        .destroy_theta_info
!
!        nullify(.atom_a)
!        nullify(.atom_b)
!        .atom_ab.destroy
!
!      end
!      end
!
!      .make_populations
!
!      .make_pair_populations
!
!      .make_summed_pair_pops
!
!      .make_summed_triple_pops
!
!      ! Roby-Gould atomic charges
!      .gould_charge.create(n_group)       
!      do a = 1,n_group
!        .gould_charge(a) = .atom(.atom_group(a).element).sum_of_nuclear_charges &
!                         - .n1(a) + VEC{REAL}:sum_elements(.proportion_a(:,a)) - THIRD*.summed_n3(a)
!      end
!      fac = ONE/REALIFY(n_group)
!      charge_deficit = .charge - VEC{REAL}:sum_elements(.gould_charge)
!      charge_deficit = fac*charge_deficit
!      .gould_charge = .gould_charge + charge_deficit
!
!      ! Cruickshank atomic charges
!      .cruickshank_charge.create(n_group) 
!      do a = 1,n_group
!        .cruickshank_charge(a) = .atom(.atom_group(a).element).sum_of_nuclear_charges &
!                               - .n1(a) + HALF*.summed_n2(a) - THIRD*.summed_n3(a)
!      end
!      fac = ONE/REALIFY(n_group)
!      charge_deficit = .charge - VEC{REAL}:sum_elements(.cruickshank_charge)
!      charge_deficit = fac*charge_deficit
!      .cruickshank_charge = .cruickshank_charge + charge_deficit
!
!   end

!   make_atom_proportions(rsa,rsb) ::: leaky, private
!   ! Make Gould's probabilistic proportionalities between atoms,
!   ! ".proportion_a" and ".proportion_b" used to approtion charge
!   ! between atoms, i.e. calculate
!   ! rsa = \sum_{\theta} r^{\theta}_{A,AB} s^{\theta}_{AB}
!   ! rsb = \sum_{\theta} r^{\theta}_{B,AB} s^{\theta}_{AB}
!      rsa, rsb :: REAL
!
!   ENSURE(.theta_C.associated,"no theta_C covalent orbitals")
!   ENSURE(.eigen_C.associated,"no eval_C covalent eigenvalues")
!   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong shape, theta_C")
!
!      n_ab,i :: INT
!      pop_a, pop_b, pop_ab, s_ab, ratio_a, ratio_b :: REAL
!
!      n_ab = .n_bf_ab
!
!      .theta_pop_A.create(n_ab)
!      .theta_pop_B.create(n_ab)   
!      
!      ! Make A & B theta popualtions
!      .make_theta_atom_populations(.theta_pop_A,.theta_pop_B,.theta_C)
!
!      rsa = ZERO
!      rsb = ZERO
!
!      do i = 1,n_ab
!
!         if (.pair(i)<1 OR i<.pair(i)) cycle
!
!         pop_a   = .theta_pop_A(i) + .theta_pop_A(.pair(i))
!         pop_b   = .theta_pop_B(i) + .theta_pop_B(.pair(i))
!         pop_ab  = .theta_pop_C(i) + .theta_pop_C(.pair(i))
!         ratio_a = pop_a/(pop_a + pop_b)
!         ratio_b = pop_b/(pop_a + pop_b)
!         s_ab    = pop_a + pop_b - pop_ab
!         rsa     = rsa + ratio_a*s_ab
!         rsb     = rsb + ratio_b*s_ab
!
!      end
!
!   end

! ===================================
! Make and diagonalise Roby operators
! ===================================

   make_full_complement(Q,group,ANO) ::: private
   ! Make "Q" the matrix of the complement projection operator for the
   ! atoms whose indices are in "group" in the full AO basis of
   ! .atom's. If present, use the columns of "ANO" as atomic orbital
   ! coefficients to form the projection operator instead of the
   ! actual atomic natural orbitals.
      self :: IN
      Q :: MAT{REAL}, OUT
      group :: VEC{INT}, optional, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(Q.dim1==.n_bf,"wrong dimension, Q")
   ENSURE(Q.is_square,"Q is incorrectly dimensioned")

      SI :: MAT{REAL}*
      n_bf :: INT

      ! Make the full projection matrix
      .make_full_projection(Q,group,ANO)

      ! Make unit operator "1", just S^-1, in full basis
      n_bf = .n_bf
      SI.create(n_bf,n_bf)
      SI.to_pseudo_inverse_of(.overlap_matrix,TOL(5))

      ! Make complement
      Q = SI - Q

   end

   make_full_projection(P,group,ANO) ::: private
   ! Make "P" the matrix of the Roby projection operator for the atoms
   ! whose indices are in "group" in the full AO basis of .atom's. If
   ! present, use the columns of "ANO" as atomic orbital coefficients
   ! to form the projection operator instead of the actual atomic
   ! natural orbitals.
      self :: IN
      P :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(P.dim1==.n_bf,"wrong dimension, P")
   ENSURE(P.is_square,"P is incorrectly dimensioned")

      W :: MAT{REAL}*
      n_bf :: INT

      ! Small group
      n_bf = .n_bf(group)

      ! Make the "small" projector (reuse code)
      W.create(n_bf,n_bf)
      .make_projection_matrix(W,group,ANO)

      ! Copy into full basis
      .AO_subspace_set(P,W,A_row_atom=group,A_col_atom=group)

      ! Clean
      W.destroy

   end

   make_projection_matrix(P,group,ANO) ::: private
   ! Make "P", the matrix of the Roby projection *operator in the
   ! (nonorthgogonal) AO basis. The AO basis is the concatenated set
   ! of basis functions for each atom in "group". If present, use the
   ! columns of "ANO" as atomic orbital coefficients to form the
   ! projection operator instead of the actual atomic natural orbitals.
      self :: IN
      P :: MAT{REAL}, OUT
      group :: VEC{INT}, optional, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(P.dim1==.n_bf(group),"wrong dimension, P ")
   ENSURE(P.is_square,"P is incorrectly dimensioned")

      W,X,Y :: MAT{REAL}*
      n_occ,n_bf :: INT

      n_bf = .n_bf(group)

      ! W = columns of ANO's
      if (present(ANO)) then

         ENSURE(ANO.dim1==.n_bf(group),"wrong dimension, ANO")
         n_occ = ANO.dim2
         W.create(n_bf,n_occ)
         W = ANO

      else if (.use_NAOs) then
      
         n_occ = .no_of_occupied_NAOs(group)
         W.create(n_bf,n_occ)
         .make_NAO_matrix(W,group)

      else

         n_occ = .no_of_occupied_ANOs(group)
         W.create(n_bf,n_occ)
         .make_ANO_matrix(W,group)

      end

      ! Y = overlap matrix for group(:) basis
      Y.create(n_bf,n_bf)                   
      .make_overlap_matrix(Y,group,group)

      ! X = S in the ANO basis
      X.create(n_occ,n_occ)
      Y.change_basis_to(X,W)
      Y.destroy

      ! Y = (ANO overlap matrix)^{-1}
      Y.create(n_occ,n_occ)
      Y.to_pseudo_inverse_of(X,TOL(5))
      X.destroy

      ! P = Y in the group(:) AO basis
      Y.back_transform_to(P,W)

      ! Clean
      Y.destroy
      W.destroy

   end

   make_ANO_matrix(ANO,group,tol) ::: private, PURE
   ! Make the "ANO" matrix, comprised of columns of the occupied atomic
   ! natural orbitals, for each atom whose index appears in "group".
   ! If "tol" is present, use this cutoff to determine what is an occupied
   ! natural orbital.
      self :: IN
      ANO :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN

   ENSURE(ANO.dim1==.n_bf(group),"wrong shape, ANO")
   ENSURE(ANO.dim2==.no_of_occupied_ANOs(group,tol),"wrong shape, ANO")

      eps :: REAL
      a,aa,b,n,n_bf,n_occ :: INT

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      ANO = ZERO

      b = 0; n = 0

      do a = 1,group.dim

         aa    = group(a)
         n_bf  = .atom(aa).basis.n_bf
         n_occ = .atom(aa).no_of_occupied_NOs(tol=eps)

         ANO(b+1:b+n_bf,n+1:n+n_occ) = .atom(aa).natural_orbitals.restricted(:,1:n_occ)

         b = b + n_bf
         n = n + n_occ

      end

   end

   make_NAO_matrix(NAO,group,tol) ::: private, PURE
   ! Make the "NAO" matrix, comprised of columns of the occupied
   ! natural atomic orbitals, for each atom whose index appears in
   ! "group".  If "tol" is present, use this cutoff to determine what
   ! is an occupied natural orbital.
      self :: IN
      NAO :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN

   ENSURE(NAO.dim1==.n_bf(group),"wrong shape, NAO")
   ENSURE(NAO.dim2==.no_of_occupied_NAOs(group,tol),"wrong shape, NAO")

      eps :: REAL
      a,aa,b,n,n_bf,n_occ :: INT

      ! Same cutoff as for ANO's
      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      NAO = ZERO

      b = 0; n = 0

      do a = 1,group.dim

         aa    = group(a)
         n_bf  = .atom(aa).basis.n_bf
         n_occ = .atom(aa).no_of_occupied_NAOs(eps)

         NAO(b+1:b+n_bf,n+1:n+n_occ) = .atom(aa).NAOs(:,1:n_occ)

         b = b + n_bf
         n = n + n_occ

      end

   end

!   make_NAO_matrix(NAO,occupation,group,tol) ::: leaky
!   ! Make the natural atomic orbitals "NAO" and their "occupation"
!   ! numbers for a "group" of atoms, from the density matrix ".rho"
!   ! "tol" is used to decide when an NAO is occupied or not.
!      self :: IN
!      NAO :: MAT{REAL}*
!      occupation :: VEC{REAL}*
!      group :: VEC{INT}, IN
!      tol :: REAL, optional, IN
!
!   ENSURE(.overlap_matrix.associated,"no overlap matrix")
!   ENSURE(.rho.associated,"no rho")
!   ENSURE(.rho.restricted.associated,"no rho restricted")
!
!      S,V,X,P :: MAT{REAL}*
!      n_bf,n_occ :: INT
!      eps :: REAL
!
!      ! No. of basis functions in the group
!      n_bf = .n_bf(group)
!
!      ! Create the (full) NAO and occupation matrix
!      NAO.create(n_bf,n_bf)
!      occupation.create(n_bf)
!
!      ! S = overlap matrix for group(:) basis
!      S.create(n_bf,n_bf)                   
!      .make_overlap_matrix(S,group,group)
!
!      ! Get V = S^(1/2)
!      V.create(n_bf,n_bf)
!      V.to_sqrt_of(S)
!
!      ! Diagonal part of P matrix
!      P.create(n_bf,n_bf)
!      .AO_subspace_set(P,.rho.restricted,B_row_atom=group,B_col_atom=group)
!
!      ! Transform P -> S^(1/2) P S^(1/2)
!      X.create(n_bf,n_bf)
!      P.change_basis_to(X,V)
!
!      ! Diagonalize
!      X.solve_symmetric_eigenproblem(occupation,P)
!
!      ! Get V = S^(-1/2)
!      V.to_inverse_sqrt_of(S)
!
!      ! Back transform
!      NAO.to_product_of(V,P)
!
!      ! Clean
!      X.destroy
!      P.destroy
!      V.destroy
!      S.destroy
!
!      ! Debug
!      if (TRUE) then
!         stdout.flush
!         stdout.text("occupation:")
!         stdout.put(occupation)
!         stdout.text("NAO:")
!         stdout.put(NAO)
!      end
!
!      ! Reverse order
!      occupation = occupation(n_bf:1:-1)
!      NAO        =      NAO(:,n_bf:1:-1)
!
!      ! Cutoff
!      eps = .occupied_ANO_cutoff
!      if (present(tol)) eps = tol
!
!      ! Count
!      n_occ = count(occupation>=eps)
!
!      ! Shrink
!      occupation.shrink(n_occ)
!      NAO.shrink_columns(n_occ)
!
!      ! Debug
!      if (TRUE) then
!         stdout.flush
!         stdout.text("occupation:")
!         stdout.put(occupation)
!         stdout.text("NAO:")
!         stdout.put(NAO)
!      end
!
!   end

   make_shared_operator(R) ::: private
   ! constructs the roby_shared_operator R_AB = P_A + P_B - P_AB
   ! if spin_case is supplied then either the alpha or beta
   ! operator is constructed, depending on the value of spin_case
      self :: IN
      R :: MAT{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")

      P_A,P_B,P_AB :: MAT{REAL}*
      n_a, n_b, n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)
      P_AB.create(n_ab,n_ab)

      .make_projection_matrix(P_A ,.atom_a)
      .make_projection_matrix(P_B ,.atom_b)
      .make_projection_matrix(P_AB,.atom_ab)

      R = ZERO
      R(    1:n_a ,     1:n_a ) =  P_A
      R(n_a+1:n_ab, n_a+1:n_ab) =  P_B
      R = R - P_AB

      P_AB.destroy
      P_B.destroy
      P_A.destroy

   end

   make_ionic_operator(I) ::: private
   ! constructs the roby/gould ionic operator I_AB = P_A - P_B
       self :: IN
       I :: MAT{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")

      P_B,P_A :: MAT{REAL}*
      n_a, n_b, n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)

      .make_projection_matrix(P_A,.atom_a)
      .make_projection_matrix(P_B,.atom_b)

      I = ZERO
      I(    1:n_a ,     1:n_a ) =  P_A
      I(n_a+1:n_ab, n_a+1:n_ab) = -P_B

      P_B.destroy
      P_A.destroy

   end

   make_hyper_operator(H) ::: private
   ! constructs the Roby/Gould hyper operator H_A = P_A - Q_M
       self :: IN
       H :: MAT{REAL}, OUT

   ENSURE(H.dim1==.n_bf,"Wrong dim1, H")
   ENSURE(H.is_square,"H is noyt square")

      Q_M,P_A :: MAT{REAL}*
      n_bf :: INT

      n_bf = .n_bf

      Q_M.create(n_bf,n_bf)
      P_A.create(n_bf,n_bf)

      .make_full_complement(Q_M,.atom_ab)
      .make_full_projection(P_A,.atom_a)

      H = P_A - Q_M

      P_A.destroy
      Q_M.destroy

   end

   diagonalize_V_AB_operator(X,eigenvectors,eigenvalues) ::: private
   ! For operator "X" (for example, C = cos theta or S= sin theta) in
   ! the concatenated AO basis of the atoms in .roby.atom_group,
   !    X = \sum_{i,j} |i> X_{ij} <j|, |i>,|j> in V_{AB},
   ! diagonalise and return the "eigenvectors" and "eigenvalues".
      self :: IN
      X :: MAT{REAL}, IN
      eigenvectors :: MAT{REAL}, OUT
      eigenvalues :: VEC{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")

      XX,XV, SS,SI,SH :: MAT{REAL}*
      n_ab :: INT

      n_ab = .n_bf_ab

      XX.create(n_ab,n_ab)
      XV.create(n_ab,n_ab)

      ! Overlap matrices
      SI.create(n_ab,n_ab)
      SH.create(n_ab,n_ab)
      SS.create(n_ab,n_ab)
      .make_overlap_matrix(SS,.atom_ab,.atom_ab)

      ! Inverse overlap
      SH.to_sqrt_of(SS,TOL(5))
      SI.to_pseudo_inverse_of(SH,TOL(5))

      ! Eigenproblem
      X.back_transform_to(XX,SH)
      XX.solve_symmetric_eigenproblem(eigenvalues,XV)
      eigenvectors.to_product_of(SI,XV)

      ! Clean
      SS.destroy
      SH.destroy
      SI.destroy
      XV.destroy
      XX.destroy

   end

   diagonalize_full_operator(X,eigenvectors,eigenvalues) ::: private
   ! For operator "X" (for example, C = cos theta or S= sin theta) in
   ! the concatenated AO basis of the atoms in .roby.atom_group,
   !    X = \sum_{i,j} |i> X_{ij} <j|, |i>,|j> in V_{AB},
   ! diagonalise and return the "eigenvectors" and "eigenvalues".
      self :: IN
      X :: MAT{REAL}, IN
      eigenvectors :: MAT{REAL}, OUT
      eigenvalues :: VEC{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
 ! ENSURE(.atom_ab.associated,"No roby atom AB")

      XX,XV, SS,SI,SH :: MAT{REAL}*
      n_ab :: INT

      n_ab = .n_bf

      XX.create(n_ab,n_ab)
      XV.create(n_ab,n_ab)

      ! Overlap matrices
      SI.create(n_ab,n_ab)
      SH.create(n_ab,n_ab)
      SS.create(n_ab,n_ab)
      .make_overlap_matrix(SS,.atom_b,.atom_b)

      ! Inverse overlap
      SH.to_sqrt_of(SS,TOL(5))
      SI.to_pseudo_inverse_of(SH,TOL(5))

      ! Eigenproblem
      X.back_transform_to(XX,SH)
      XX.solve_symmetric_eigenproblem(eigenvalues,XV)
      eigenvectors.to_product_of(SI,XV)

      ! Clean
      SS.destroy
      SH.destroy
      SI.destroy
      XV.destroy
      XX.destroy

   end

! ===========================
! Make roby projected density
! ===========================

!   make_projected_density(rho,density,ANO) ::: private
!   ! Make the Roby-projected density matrix in the concatenated basis
!   ! of AO functions of the atoms in .atom_ab and copy it into "rho",
!   ! a .n_bf x .n_bf matrix where all other matrix elements not corresponding
!   ! to basis functions in .atom_ab are made zero. If present, "density" is
!   ! used instead of the restricted density matrix. If present, "ANO" are used
!   ! for the Roby projection.
!      rho,density :: MAT{REAL}
!      ANO :: MAT{REAL}, optional
!   ENSURE(rho.dim1==.n_bf,"rho has wrong shape")
!   ENSURE(rho.is_square,"rho has wrong shape")
!   ENSURE(density.dim1==.n_bf,"wrong shape, density")
!   ENSURE(density.is_square,"wrong shape, density")
!   ENSURE(.atom_ab.associated,"No atom AB group")
!      D,P,rho_P :: MAT{REAL}*
!      n_bf :: INT
!      n_bf = .n_bf_ab
!      D.create(n_bf,n_bf)
!      .overlap_transform(density,D,col_atom=.atom_ab)
!      P.create(n_bf,n_bf)
!      .make_projection_matrix(P,.atom_ab,ANO)
!      rho_P.create(n_bf,n_bf)
!      D.change_basis_to(rho_P,P) ! rho_P(small) = P_W(small) D(small) P_W(small)
!      .AO_subspace_set(rho,rho_P,A_row_atom=.atom_ab,A_col_atom=.atom_ab)
!      rho_P.destroy
!      P.destroy
!      D.destroy
!   end

! ===============================================
! Low level Roby routines used all over the place
! ===============================================

   expectation(P,group,rho) result (res) ::: private
   ! Get the expectation value of the projection operator matrix "P"
   ! over a certain "group" of atoms, i.e:
   !    res = Trace ( S(:,group) P S(group,:) rho )
   ! Note that "group" are the indices of the atoms whose basis functions
   ! are used to define the matrix "P".
      self :: IN
      P :: MAT{REAL}, IN
      group :: VEC{INT}, IN
      rho :: OPMATRIX*, optional, IN
      res :: REAL

   ENSURE(P.dim1==.n_bf(group),"wrong P dimension")
   ENSURE(P.is_square,"P is not square")

      density :: OPMATRIX*
      W :: MAT{REAL}*
      n_bf :: INT

      density => .rho
      if (present(rho)) density => rho

      n_bf = .n_bf

      ! Make W = S P S
      W.create(n_bf,n_bf)
      .overlap_transform(P,W,group)

      ! Make Tr ( S P S rho)
      if (.spin_multiplicity/=1) then
         res = density.alpha.trace_product_with(W) &
             + density.beta.trace_product_with(W)
      else
         res = density.restricted.trace_product_with(W)
      end

      W.destroy

   end

   project(X,P,Y,row_atom,col_atom) ::: private
   ! Do: Y = P^T S(col_atom,row_atom) X S(row_atom,col_atom) P where
   ! S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom
   ! indices in "row_atom" and "col_atom", and "P" is a matrix
      X,P,Y :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}

   ENSURE(X.dim1==.n_bf(row_atom),"wrong X dimension")
   ENSURE(Y.dim1==.n_bf(col_atom),"wrong Y dimension")
   ENSURE(Y.dim1==P.dim1,"wrong P dimension")
   ENSURE(X.is_square,"X is not square")
   ENSURE(Y.is_square,"Y is not square")
   ENSURE(P.is_square,"P is not square")

      W :: MAT{REAL}*

      W.create(Y.dim1,Y.dim2)
      .overlap_transform(X,W,row_atom,col_atom)
      W.change_basis_to(Y,P)
      W.destroy

   end

   overlap_transform(X,Y,row_atom,col_atom) ::: private
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the section of the full overlap
   ! matrix specified by the basis functions on the atom indices in
   ! "row_atom" and "col_atom".
      self :: IN
      X :: MAT{REAL}, IN
      Y :: MAT{REAL}, OUT
      row_atom, col_atom :: VEC{INT}, optional, IN

      SS :: MAT{REAL}*
      n_row,n_col :: INT

      n_row = .n_bf(row_atom)
      n_col = .n_bf(col_atom)

      ! SS = small S
      SS.create(n_row,n_col)

      .make_overlap_matrix(SS,row_atom,col_atom)

      X.change_basis_to(Y,SS)

      SS.destroy

   end

   right_overlap_transform(X,Y,row_atom,col_atom) ::: private
   ! Do: Y = X S(row_atom,col_atom), where S(row_atom,col_atom) is the
   ! AO subspace section of the full overlap matrix specified by the
   ! basis functions on the atom indices in "row_atom" and "col_atom".
      self :: IN
      X :: MAT{REAL}, IN
      Y :: MAT{REAL}, OUT
      row_atom, col_atom :: VEC{INT}, optional, IN

      SS :: MAT{REAL}*
      n_row,n_col :: INT

      n_row = .n_bf(row_atom)
      n_col = .n_bf(col_atom)

      SS.create(n_row,n_col)

      .make_overlap_matrix(SS,row_atom,col_atom)

      Y.to_product_of(X,SS)

      SS.destroy

   end

   make_overlap_matrix(SS,row_atom,col_atom) ::: private, PURE
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      self :: IN
      SS :: MAT{REAL}, OUT
      row_atom,col_atom :: VEC{INT}, optional, IN

   ENSURE(.overlap_matrix.associated,"no overlap matrix")
   ENSURE(SS.dim1==.n_bf(row_atom),"wrong shape, SS")
   ENSURE(SS.dim2==.n_bf(col_atom),"wrong shape, SS")

      .AO_subspace_set(SS,.overlap_matrix,B_row_atom=row_atom,B_col_atom=col_atom)

   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom) ::: private, PURE
   ! If either "B_row_atom" or "B_col_atom" is present, then set "A" equal to
   ! the AO subspace blocks of "B" specified by the atom indices in "B_row_atom"
   ! and "B_col_atom". If either is missing, then copy the entire row or col, i.e.
   !    A(small) = B(B_row_atom,B_col_atom)
   ! If either "A_row_atom" or "A_col_atom" is present, then set the AO
   ! subspace blocks of "A" specified by the atom indices in "A_row_atom" and
   ! "A_col_atom" equal to "B". If either is missing then copy the entire row or
   ! column. Uncopied blocks are set to zero, i.e.
   !    A(A_row_atom,A_col_atom) = B(small)
      self :: IN
      A :: MAT{REAL}, OUT
      B :: MAT{REAL}, IN
      A_row_atom,A_col_atom :: VEC{INT}, optional, IN
      B_row_atom,B_col_atom :: VEC{INT}, optional, IN

      n_row_atoms,n_col_atoms :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      first_basis_fn_for,last_basis_fn_for :: VEC{INT}*
      Achk,Bchk :: BIN

    Achk = present(A_row_atom) OR present(A_col_atom) 
    Bchk = present(B_row_atom) OR present(B_col_atom)
    ENSURE(Achk NEQV Bchk,"missing A/B row or col atoms")

      .atom.make_atom_basis_fn_limits(first_basis_fn_for,last_basis_fn_for)

      if (present(B_row_atom) OR present(B_col_atom)) then

         ENSURE(B.dim1==.n_bf,"B has wrong shape")
         ENSURE(B.dim2==.n_bf,"B has wrong shape")

         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            ENSURE(A.dim1==.atom(B_row_atom).no_of_basis_functions,"A has wrong shape")
            ENSURE(A.dim2==.atom(B_col_atom).no_of_basis_functions,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(B_row_atom(i))
               l_i = last_basis_fn_for( B_row_atom(i))
               n_i = l_i - f_i + 1
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = first_basis_fn_for(B_col_atom(j))
                  l_j = last_basis_fn_for( B_col_atom(j))
                  n_j = l_j - f_j + 1
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end
               b_i = b_i + n_i
            end

         else if (present(B_row_atom)) then

            n_row_atoms = size(B_row_atom)
            ENSURE(A.dim1==.atom(B_row_atom).no_of_basis_functions,"A has wrong shape")
            ENSURE(A.dim2==.n_bf,"A has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(B_row_atom(i));
               l_i = last_basis_fn_for( B_row_atom(i))
               n_i = l_i - f_i + 1
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end

         else if (present(B_col_atom)) then

            n_col_atoms = size(B_col_atom)
            ENSURE(A.dim1==.n_bf,"A has wrong shape")
            ENSURE(A.dim2==.atom(B_col_atom).no_of_basis_functions,"A has wrong shape")

            b_j = 0
            do j = 1,n_col_atoms
               f_j = first_basis_fn_for(B_col_atom(j));
               l_j = last_basis_fn_for( B_col_atom(j))
               n_j = l_j - f_j + 1
               A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
               b_j = b_j + n_j
            end

         end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then

         ENSURE(A.dim1==.n_bf,"A has wrong shape")
         ENSURE(A.dim2==.n_bf,"A has wrong shape")

         A = ZERO

         if (present(A_row_atom) AND present(A_col_atom)) then

            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            ENSURE(B.dim1==.atom(A_row_atom).no_of_basis_functions,"B has wrong shape")
            ENSURE(B.dim2==.atom(A_col_atom).no_of_basis_functions,"B has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(A_row_atom(i))
               l_i = last_basis_fn_for( A_row_atom(i))
               n_i = l_i - f_i + 1
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = first_basis_fn_for(A_col_atom(j))
                  l_j = last_basis_fn_for( A_col_atom(j))
                  n_j = l_j - f_j + 1
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j)
                  b_j = b_j + n_j
               end
               b_i = b_i + n_i
            end

         else if (present(A_row_atom)) then

            n_row_atoms = size(A_row_atom)
            ENSURE(B.dim1==.atom(A_row_atom).no_of_basis_functions,"B has wrong shape")
            ENSURE(B.dim2==.n_bf,"B has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(A_row_atom(i));
               l_i = last_basis_fn_for( A_row_atom(i))
               n_i = l_i - f_i + 1
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end

         else if (present(A_col_atom)) then

            n_col_atoms = size(A_col_atom)
            ENSURE(B.dim1==.atom(A_col_atom).no_of_basis_functions,"B has wrong shape")
            ENSURE(B.dim2==.n_bf,"B has wrong shape")

            b_j = 0
            do j = 1,n_col_atoms
               f_j = first_basis_fn_for(A_col_atom(j));
               l_j = last_basis_fn_for( A_col_atom(j))
               n_j = l_j - f_j + 1
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end

         end

      end

      ! Clean
      last_basis_fn_for.destroy
      first_basis_fn_for.destroy

   end

! ==============
! Output methods
! ==============

   put_basics
   ! Put to stdout the Roby atom data
      self :: IN

   ENSURE(.atom.associated,"no atom data")

      i :: INT
      symbol :: VEC{STR}*

      stdout.flush
      stdout.text("==============================")
      stdout.text("Roby-Gould population analysis")
      stdout.text("==============================")
      stdout.flush
      stdout.show("Molecule charge         =",.charge)
      stdout.show("Molecule multiplicity   =",.spin_multiplicity)
      stdout.flush
      stdout.show("Kind of calculation     =",.roby_kind)
      stdout.show("Homoleptic calculation? =",.is_homoleptic)
      stdout.show("Occupied ANO cutoff     =",.occupied_ANO_cutoff)
      stdout.show("Output theta info?      =",.output_theta_info)
      stdout.flush

      if (.is_homoleptic) then
      symbol => .unique_tags
      do i = 1,.n_group
      stdout.show("Atom group "//i.to_str.trim//"            =",symbol(i))
      end
      end

      if (.atom_list.associated) then
      symbol => .atom(.atom_list).unique_tags
      stdout.show("Atom list               =",symbol)
      stdout.show("No. of atoms            =",symbol.dim)
      symbol.destroy
      stdout.show("Analyze all atom pairs? =",.analyze_all_atom_pairs)
      stdout.show("Analyze VDW atom pairs? =",.analyze_vdw_atom_pairs)
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      end

      symbol.destroy

      stdout.flush
      stdout.show("Zero angle cutoff /Deg  =",.zero_angle_cutoff.to_units("degree"))

   end

   put_populations
   ! Put to stdout the only Roby atom populations
      self :: IN

   ENSURE(.n1.associated,"no atom populations exist")
   ENSURE(.atom.associated,"no atom data")

      table :: VEC{TABLE_COLUMN}*
      symbols :: VEC{STR}*
      charge :: VEC{REAL}*
      labels :: VEC{INT}*
      n_e,f :: INT


      stdout.flush
      stdout.text("=====================")
      stdout.text("Roby atom populations")
      stdout.text("=====================")

      n_e = .atom.no_of_electrons

      stdout.flush
      stdout.show("No. of electrons in mol =",n_e)
      stdout.show("No. of electrons in P_M =",.n_all)
      stdout.show("No. of hypervalent e's  =",n_e-.n_all)
      stdout.flush

      ! Create table
      table.create(3)

      ! Set the table headings
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      if (.is_homoleptic) then
         symbols.create(.n_group)
         labels.create(.n_group)
         f = 1
         labels => f.sequence_up_to(.n_group)
         symbols = labels.to_str
         labels.destroy
      else
         symbols => .unique_tags
      end
      table(1).set_values(symbols)

      table(2).set_heading(" No. of")
      table(2).set_subhead("electrons")
      table(2).set_values(.n1)

      charge.create(.n_group)
      charge = -.n1 + .group_nuclear_charges
      table(3).set_heading(" Charge")
      table(3).set_values(charge)

      ! Put table
      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      charge.destroy
      symbols.destroy

   end

   put_bond_indices
   ! Put to stdout the Roby bond indices, including the shared populations
      self :: IN

      if (.is_homoleptic) then

         .put_bond_indices_group

      else

         .put_bond_indices_atoms
         .put_bond_indices_sortd

         ! LaTeX tables
         .put_bond_indices_all
         .put_bond_indices_all_vdw
         .put_bond_indices_non_H
         .put_bond_indices_CC

      end

   end

   put_bond_indices_group
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(.is_homoleptic,"job is not homoleptic")
   ENSURE(.n_group>1,"must be at least two groups")

      table :: VEC{TABLE_COLUMN}*
      symbol :: VEC{STR}*
      g_A,g_B :: VEC{INT}*
      n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
      n_group, n_pair,i,a,b :: INT

      n_group = .n_group

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond indices")
      stdout.text("=======================")
      stdout.flush
      stdout.text("Bond indices appear only between atom groups.")
      stdout.flush
      symbol => .unique_tags
      do i = 1,n_group
      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
      end
      symbol.destroy
      stdout.flush

      ! Create table
      table.create(10)

      ! Set the table headings
      table( 1).set_heading("Grp")
      table( 1).set_subhead("  A")
      table( 2).set_heading("Grp")
      table( 2).set_subhead("  B")
      table( 3).set_heading("n_A")
      table( 3).set_width_from(TEN)
      table( 4).set_heading("n_B")
      table( 4).set_width_from(TEN)
      table( 5).set_heading("n_AB")
      table( 5).set_width_from(TEN)
      table( 6).set_heading("s_AB")
      table( 6).set_width_from(TEN)
      table( 7).set_heading(" Cov.")
      table( 7).set_subhead("index")
      table( 7).set_width_from(-TEN)
      table( 8).set_heading("Ionic")
      table( 8).set_subhead("index")
      table( 8).set_width_from(-TEN)
      table( 9).set_heading(" Bond")
      table( 9).set_subhead("index")
      table( 9).set_width_from(ONE)
      table(10).set_heading("% Cov")
      table(10).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Populations & indices
      n_pair = n_group - 1
      n_pair = n_pair.triangle_number
      g_A.create(n_pair)
      g_B.create(n_pair)
      n_A.create(n_pair)
      n_B.create(n_pair)
      nAB.create(n_pair)
      sAB.create(n_pair)
      cAB.create(n_pair)
      iAB.create(n_pair)
      tAB.create(n_pair)
      pAB.create(n_pair)

      i = 0
      do a = 1,.n_group
      do b = 1,a-1
         i = i + 1
         g_A(i) = a
         g_B(i) = b
         n_A(i) = .n1(a)
         n_B(i) = .n1(b)
         nAB(i) = .n2(a,b)
         sAB(i) = .n1(a) + .n1(b) - .n2(a,b)
         cAB(i) =  .cov_index(a,b)
         iAB(i) =  .ion_index(a,b)
         tAB(i) = .bond_index(a,b)
         pAB(i) = .percent_covalency(a,b)
      end
      end

      ! Set table data
      table( 1).set_values(g_A)
      table( 2).set_values(g_B)
      table( 3).set_values(n_A)
      table( 4).set_values(n_B)
      table( 5).set_values(nAB)
      table( 6).set_values(sAB)
      table( 7).set_values(cAB)
      table( 8).set_values(iAB)
      table( 9).set_values(tAB)
      table(10).set_values(pAB)

      ! Put body
      stdout.flush
      table.put_body(label_rows=FALSE)

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy

      pAB.destroy
      tAB.destroy
      iAB.destroy
      cAB.destroy
      sAB.destroy
      nAB.destroy
      n_B.destroy
      n_A.destroy
      g_B.destroy
      g_A.destroy

   end

   put_bond_indices_hyper
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(.is_hyper_analysis,"must be at hypervalent analysis")
   ENSURE(.n_group>1,"must be at leat two groups")

      table :: VEC{TABLE_COLUMN}*
      symbol :: VEC{STR}*
      g_A :: VEC{INT}*
      n_A,cAB,iAB,tAB,pAB :: VEC{REAL}*
      n_group, i,a :: INT

      n_group = .n_group

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===================================")
      stdout.text("Hypervalent Roby-Gould bond indices")
      stdout.text("===================================")

      stdout.flush
      stdout.text("Bond indices appear between atom groups and everything")
      stdout.text("*not* in the space of the atoms.")
      stdout.flush
      stdout.text("There should only appear ionic transfer, no covalency.")
      stdout.flush

      symbol => .unique_tags
      do i = 1,n_group
      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
      end
      symbol.destroy
      stdout.flush

      ! Create table
      table.create(6)

      ! Set the table headings
      table(1).set_heading("Grp")
      table(1).set_subhead("  A")
      table(2).set_heading("n_A")
      table(2).set_width_from(TEN)
      table(3).set_heading(" Cov.")
      table(3).set_subhead("index")
      table(3).set_width_from(-TEN)
      table(4).set_heading("Ionic")
      table(4).set_subhead("index")
      table(4).set_width_from(-TEN)
      table(5).set_heading(" Bond")
      table(5).set_subhead("index")
      table(5).set_width_from(ONE)
      table(6).set_heading("% Cov")
      table(6).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Populations & indices
      g_A.create(n_group)
      n_A.create(n_group)
      cAB.create(n_group)
      iAB.create(n_group)
      tAB.create(n_group)
      pAB.create(n_group)

      i = 0
      do a = 1,.n_group
         i = i + 1
         g_A(i) = a
         n_A(i) = .n1(a)
         cAB(i) =  .cov_index(a,a)
         iAB(i) =  .ion_index(a,a)
         tAB(i) = .bond_index(a,a)
         pAB(i) = .percent_covalency(a,a)
      end

      ! Set table data
      table(1).set_values(g_A)
      table(2).set_values(n_A)
      table(3).set_values(cAB)
      table(4).set_values(iAB)
      table(5).set_values(tAB)
      table(6).set_values(pAB)

      ! Put body
      stdout.flush
      table.put_body(label_rows=FALSE)

      ! Clean
      table.clear_columns

      pAB.destroy
      tAB.destroy
      iAB.destroy
      cAB.destroy
      n_A.destroy
      g_A.destroy

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy

   end

   put_bond_indices_atoms
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("==============================================")
      stdout.text("Roby-Gould bond indices: VDW interactions only")
      stdout.text("==============================================")
      else
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond indices")
      stdout.text("=======================")
      end

      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Indices appear only for VDW bonded atom pairs and")
      stdout.text("NOT normally bonded by CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD)")
      stdout.text("AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_spacing(0)
      table( 2).set_heading("--")
      table( 2).set_width(2)

      table( 3).set_heading("B")
      table( 3).set_width(table(1).width)
      table( 3).set_left_justify(TRUE)

      table( 4).set_heading("A")
      table( 4).set_width_from(.atom(:).tag)

      table( 5).set_spacing(0)
      table( 5).set_heading("--")
      table( 5).set_width(2)

      table( 6).set_heading("B")
      table( 6).set_width(table(4).width)
      table( 6).set_left_justify(TRUE)

      table( 7).set_heading("R(A--B)")
      table( 7).set_subheading("/Angs.")
      table( 7).set_width_from(ONE)

      table( 8).set_heading("n_A")
      table( 8).set_width_from(TEN)
      table( 9).set_heading("n_B")
      table( 9).set_width_from(TEN)
      table(10).set_heading("n_AB")
      table(10).set_width_from(TEN)
      table(11).set_heading("s_AB")
      table(11).set_width_from(TEN)
      table(12).set_heading(" Cov.")
      table(12).set_subhead("index")
      table(12).set_width_from(-TEN)
      table(13).set_heading("Ionic")
      table(13).set_subhead("index")
      table(13).set_width_from(-TEN)
      table(14).set_heading(" Bond")
      table(14).set_subhead("index")
      table(14).set_width_from(ONE)
      table(15).set_heading("% Cov")
      table(15).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         n_A.create(n_bonds)
         n_B.create(n_bonds)
         nAB.create(n_bonds)
         sAB.create(n_bonds)
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         n_A = .n1(pair(:,1))
         n_B = .n1(pair(:,2))
         forall (i=1:n_bonds)
         nAB(i) = .n2(pair(i,1),pair(i,2))
         sAB(i) = n_A(i) + n_B(i) - nAB(i)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(labels(:,1))
         table( 5).set_values(dash)
         table( 6).set_values(labels(:,2))
         table( 7).set_values(dist)
         table( 8).set_values(n_A)
         table( 9).set_values(n_B)
         table(10).set_values(nAB)
         table(11).set_values(sAB)
         table(12).set_values(cAB)
         table(13).set_values(iAB)
         table(14).set_values(tAB)
         table(15).set_values(pAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         sAB.destroy
         nAB.destroy
         n_B.destroy
         n_A.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end

   put_bond_indices_sortd
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dash :: VEC{STR}*
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      ind :: VEC{INT}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("=====================================================")
      stdout.text("Sorted Roby-Gould bond indices: VDW interactions only")
      stdout.text("=====================================================")
      else
      stdout.flush
      stdout.text("==============================")
      stdout.text("Sorted Roby-Gould bond indices")
      stdout.text("==============================")
      end

      stdout.flush
      stdout.text(". Indices are sorted from lowest to highest")
      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Indices appear only for VDW bonded atom pairs and")
      stdout.text("NOT normally bonded by CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD)")
      stdout.text("  AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.atom(:).tag)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("R(A--B)")
      table(4).set_subheading("/Angs.")
      table(4).set_width_from(ONE)

      table(5).set_heading(" Cov.")
      table(5).set_subhead("index")
      table(5).set_width_from(-TEN)
      table(6).set_heading("Ionic")
      table(6).set_subhead("index")
      table(6).set_width_from(-TEN)
      table(7).set_heading(" Bond")
      table(7).set_subhead("index")
      table(7).set_width_from(ONE)
      table(8).set_heading("% Cov")
      table(8).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Sort & rearrange
         ind.create(n_bonds)
         tAB.quick_sort(ind,decreasing_order=TRUE)
         labels(:,1) = labels(ind,1)
         labels(:,2) = labels(ind,2)
         dist = dist(ind)
         cAB  = cAB(ind)
         iAB  = iAB(ind)
         tAB  = tAB(ind)
         pAB  = pAB(ind)

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dist)
         table(5).set_values(cAB)
         table(6).set_values(iAB)
         table(7).set_values(tAB)
         table(8).set_values(pAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         ind.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end


   put_bond_indices_all
   ! Output the all bond indices for LaTeX script in "bondtable.tex".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i,a :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dash :: VEC{STR}*
      s1,s2,val :: STR
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      stdout.redirect("bondtable.tex")

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Put latex table
         s1 = .atom(pair(1,1)).chemical_symbol
         s2 = .atom(pair(1,2)).chemical_symbol
         stdout.text("% "//trim(s1)//"--"//trim(s2)//" bonds")

         do a = 1,pair.dim1
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(pair(a,1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(pair(a,2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = REAL:to_str(tAB(a),"f10.2",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = INT:to_str(nint(pAB(a)),"i3",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush
         end

         ! Clean
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      Z_list.destroy

      stdout.revert

   end

   put_bond_indices_all_vdw
   ! Output all bond indices and shortest vdw bond for LaTeX script
   ! "bondtable-vdw.tex".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i,a :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dash :: VEC{STR}*
      vdw :: VEC{INT}(2)
      s1,s2,val :: STR
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return
      if (NOT .atom.has_vdw_bond) return

      stdout.redirect("bondtable-vdw.tex")

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Put latex table
         s1 = .atom(pair(1,1)).chemical_symbol
         s2 = .atom(pair(1,2)).chemical_symbol
         stdout.text("% "//trim(s1)//"--"//trim(s2)//" bonds")

         do a = 1,pair.dim1
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(pair(a,1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(pair(a,2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = REAL:to_str(tAB(a),"f10.2",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = INT:to_str(nint(pAB(a)),"i3",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush
         end

         ! Clean
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      Z_list.destroy

      ! Now put the shortest vdw bond
      stdout.text("% Shortest vdw bond")

      ! Get shortest vdw bond
      vdw = .atom.shortest_vdw_bond

         ! Allocate & get
         tAB.create(1)
         pAB.create(1)

         tAB(1) = .bond_index(vdw(1),vdw(2))
         pAB(1) = .percent_covalency(vdw(1),vdw(2))

            ! Print tabele
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(vdw(1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(vdw(2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = REAL:to_str(tAB(1),"f10.2",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = INT:to_str(nint(pAB(1)),"i3",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush

         ! Clean
         pAB.destroy
         tAB.destroy

      ! Revert
      stdout.revert

   end

   put_bond_indices_non_H
   ! Output the non-H bond indices for LaTex script in
   ! "non-H-bondtable.tex".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i,a :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dash :: VEC{STR}*
      s1,s2,val :: STR
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      stdout.redirect("non-H-bondtable.tex")

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         if (.atom(Z_list(k1)[1]).atomic_number==1) cycle
         if (.atom(Z_list(k2)[1]).atomic_number==1) cycle

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Put latex table
         s1 = .atom(pair(1,1)).chemical_symbol
         s2 = .atom(pair(1,2)).chemical_symbol
         stdout.text("% "//trim(s1)//"--"//trim(s2)//" bonds")

         do a = 1,pair.dim1
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(pair(a,1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(pair(a,2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = REAL:to_str(tAB(a),"f10.2",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = INT:to_str(nint(pAB(a)),"i3",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush
         end

         ! Clean
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      Z_list.destroy

      stdout.revert

   end

   put_bond_indices_CC
   ! Output the CC bond indices table in file "cc-table".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! New file
      stdout.redirect("cc-table")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(5)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.atom(:).tag)

      table(2).set_heading("B")
      table(2).set_width(table(1).width)

      table(3).set_heading(" Cov.")
      table(3).set_subhead("index")
      table(3).set_width_from(-TEN)

      table(4).set_heading("Ionic")
      table(4).set_subhead("index")
      table(4).set_width_from(-TEN)

      table(5).set_heading(" Bond")
      table(5).set_subhead("index")
      table(5).set_width_from(ONE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Skip non-C atoms
         if (.atom(Z_list(k1)[1]).atomic_number/=6) cycle
         if (.atom(Z_list(k2)[1]).atomic_number/=6) cycle

         ! Get the bonded atoms per kind
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Extract number-part only
         labels(:,1) = labels(:,1)(2:)
         labels(:,2) = labels(:,2)(2:)

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency(pair(i,1),pair(i,2))
         end

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(labels(:,2))
         table(3).set_values(cAB)
         table(4).set_values(iAB)
         table(5).set_values(tAB)

         ! Put info
         stdout.put(.atom.molecular_weight)
         stdout.flush
         stdout.put(tAB.dim)
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

      ! Revert
      stdout.revert

   end

! ===============
! Output energies
! ===============

   put_all_energy_info
   ! Put to stdout the energy bond analysis
      self :: IN

      .put_basics
      .put_energies
      .put_energy_indices

   end

   put_energies
   ! Put to stdout the only Roby atom energies
      self :: IN

   ENSURE(.atom.associated,"no atom data")
   ENSURE(.E1.associated,"no atom energies exist")

      table :: VEC{TABLE_COLUMN}*
      symbols :: VEC{STR}*
      labels :: VEC{INT}*
      f :: INT


      stdout.flush
      stdout.text("==================")
      stdout.text("Roby atom energies")
      stdout.text("==================")
      stdout.flush
      stdout.text(". Half of the nuclear-nuclear repulsion energies")
      stdout.text("  for all other atoms are included in the total")
      stdout.flush
      stdout.text(". Energies are in atomic units")
      stdout.flush

      ! Create table
      table.create(2)

      ! Set the table headings
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)

      if (.is_homoleptic) then
         symbols.create(.n_group)
         labels.create(.n_group)
         f = 1
         labels => f.sequence_up_to(.n_group)
         symbols = labels.to_str
         labels.destroy
      else
         symbols => .unique_tags
      end

      ! Datas
      table(1).set_values(symbols)
      table(2).set_heading(" Energy")
      table(2).set_subhead("    /au")
      table(2).set_values(.E1)

      ! Put table
      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      symbols.destroy

   end

   put_energy_indices
   ! Put to stdout the Roby bond indices, including the shared populations
      self :: IN

      if (.is_homoleptic) then

         .put_energy_indices_group

      else

         .put_energy_indices_atoms
         .put_energy_indices_sorted

      end

   end

   put_energy_indices_group
   ! Output the energy bond indices table for connected atoms.
      self :: IN

   ENSURE(.is_homoleptic,"job is not homoleptic")
   ENSURE(.n_group>1,"must be at leat two groups")
   ENSURE(.E1.associated,"no atom energies exist")
   ENSURE(.E2.associated,"no atom pair energies exist")

      table :: VEC{TABLE_COLUMN}*
      symbol :: VEC{STR}*
      g_A,g_B :: VEC{INT}*
      n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
      n_group, n_pair,i,a,b :: INT

      n_group = .n_group

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============================")
      stdout.text("Roby-Gould energy bond indices")
      stdout.text("==============================")
      stdout.flush
      stdout.text("Energy bond indices appear only between atom groups.")
      stdout.flush
      symbol => .unique_tags
      do i = 1,n_group
      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
      end
      symbol.destroy
      stdout.flush

      ! Create table
      table.create(10)

      ! Set the table headings
      table( 1).set_heading("Grp")
      table( 1).set_subhead("  A")
      table( 2).set_heading("Grp")
      table( 2).set_subhead("  B")
      table( 3).set_heading("E_A")
      table( 3).set_width_from(TEN)
      table( 4).set_heading("E_B")
      table( 4).set_width_from(TEN)
      table( 5).set_heading("E_AB")
      table( 5).set_width_from(TEN)
      table( 6).set_heading("E^s_AB")
      table( 6).set_width_from(TEN)
      table( 7).set_heading("E Cov")
      table( 7).set_subhead("index")
      table( 7).set_width_from(-TEN)
      table( 8).set_heading("E Ion")
      table( 8).set_subhead("index")
      table( 8).set_width_from(-TEN)
      table( 9).set_heading("E Bond")
      table( 9).set_subhead(" index")
      table( 9).set_width_from(ONE)
      table(10).set_heading("% E")
      table(10).set_subhead("Cov")
      table(10).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Populations & indices
      n_pair = n_group - 1
      n_pair = n_pair.triangle_number
      g_A.create(n_pair)
      g_B.create(n_pair)
      n_A.create(n_pair)
      n_B.create(n_pair)
      nAB.create(n_pair)
      sAB.create(n_pair)
      cAB.create(n_pair)
      iAB.create(n_pair)
      tAB.create(n_pair)
      pAB.create(n_pair)

      i = 0
      do a = 1,.n_group
      do b = 1,a-1
         i = i + 1
         g_A(i) = a
         g_B(i) = b
         n_A(i) = .E1(a)
         n_B(i) = .E1(b)
         nAB(i) = .E2(a,b)
         sAB(i) = .E1(a) + .E1(b) - .E2(a,b)
         cAB(i) =  .E_cov_index(a,b)
         iAB(i) =  .E_ion_index(a,b)
         tAB(i) = .E_bond_index(a,b)
         pAB(i) = .E_percent_covalency(a,b)
      end
      end

      ! Set table data
      table( 1).set_values(g_A)
      table( 2).set_values(g_B)
      table( 3).set_values(n_A)
      table( 4).set_values(n_B)
      table( 5).set_values(nAB)
      table( 6).set_values(sAB)
      table( 7).set_values(cAB)
      table( 8).set_values(iAB)
      table( 9).set_values(tAB)
      table(10).set_values(pAB)

      ! Put body
      stdout.flush
      table.put_body(label_rows=FALSE)

      ! Clean
      table.clear_columns

      pAB.destroy
      tAB.destroy
      iAB.destroy
      cAB.destroy
      sAB.destroy
      nAB.destroy
      n_B.destroy
      n_A.destroy

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy

   end

   put_energy_indices_atoms
   ! Output the energy bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")
   ENSURE(.E1.associated,"no atom energies exist")
   ENSURE(.E2.associated,"no atom pair energies exist")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("========================================")
      stdout.text("Roby-Gould energy bond indices: VDW only")
      stdout.text("========================================")
      else
      stdout.flush
      stdout.text("==============================")
      stdout.text("Roby-Gould energy bond indices")
      stdout.text("==============================")
      end

      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Energy bond indices appear only for VDW bonded atom")
      stdout.text("pairs NOT normally bonded by the CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text("Energy bond indices appear only for atom pairs connected")
      stdout.text("according to the Cambridge Structural Database (CSD)")
      stdout.text("AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text("Energy bond indices appear only for atom pairs connected")
      stdout.text("according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_spacing(0)
      table( 2).set_heading("--")
      table( 2).set_width(2)

      table( 3).set_heading("B")
      table( 3).set_width(table(1).width)
      table( 3).set_left_justify(TRUE)

      table( 4).set_heading("A")
      table( 4).set_width_from(.atom(:).tag)

      table( 5).set_spacing(0)
      table( 5).set_heading("--")
      table( 5).set_width(2)

      table( 6).set_heading("B")
      table( 6).set_width(table(4).width)
      table( 6).set_left_justify(TRUE)

      table( 7).set_heading("R(A--B)")
      table( 7).set_subheading("/Angs.")
      table( 7).set_width_from(ONE)

      table( 8).set_heading("E_A")
      table( 8).set_width_from(-100d0)
      table( 9).set_heading("E_B")
      table( 9).set_width_from(-100d0)
      table(10).set_heading("E_AB")
      table(10).set_width_from(-100d0)
      table(11).set_heading("E^s_AB")
      table(11).set_width_from(-100d0)
      table(12).set_heading("E Cov")
      table(12).set_subhead("index")
      table(12).set_width_from(-100d0)
      table(13).set_heading("E Ion")
      table(13).set_subhead("index")
      table(13).set_width_from(-100d0)
      table(14).set_heading("E Bond")
      table(14).set_subhead(" index")
      table(14).set_width_from(-100d0)
      table(15).set_heading("% E")
      table(15).set_subhead("Cov")
      table(15).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         n_A.create(n_bonds)
         n_B.create(n_bonds)
         nAB.create(n_bonds)
         sAB.create(n_bonds)
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         n_A = .E1(pair(:,1))
         n_B = .E1(pair(:,2))
         do i = 1,n_bonds
         nAB(i) = .E2(pair(i,1),pair(i,2))
         sAB(i) = n_A(i) + n_B(i) - nAB(i)
         cAB(i) =  .E_cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .E_ion_index(pair(i,1),pair(i,2))
         tAB(i) = .E_bond_index(pair(i,1),pair(i,2))
         pAB(i) = .E_percent_covalency(pair(i,1),pair(i,2))
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(labels(:,1))
         table( 5).set_values(dash)
         table( 6).set_values(labels(:,2))
         table( 7).set_values(dist)
         table( 8).set_values(n_A)
         table( 9).set_values(n_B)
         table(10).set_values(nAB)
         table(11).set_values(sAB)
         table(12).set_values(cAB)
         table(13).set_values(iAB)
         table(14).set_values(tAB)
         table(15).set_values(pAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         sAB.destroy
         nAB.destroy
         n_B.destroy
         n_A.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end

   put_energy_indices_sorted
   ! Output the energy bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}*
      Z_list :: VEC{VEC_{INT}}*
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}*
      labels :: MAT{STR}*
      dash :: VEC{STR}*
      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
      ind :: VEC{INT}*
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("===============================================")
      stdout.text("Sorted Roby-Gould energy bond indices: VDW only")
      stdout.text("===============================================")
      else
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Sorted Roby-Gould energy bond indices")
      stdout.text("=====================================")
      end

      stdout.flush
      stdout.text(". Energy bond indices are sorted from lowest to highest")
      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Energy bond indices appear only for VDW bonded atom pairs")
      stdout.text("and NOT normally bonded by the CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text(". Energy bond indices appear only for atom pairs which connected")
      stdout.text("  according to the Cambridge Structural Database (CSD)")
      stdout.text("  AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text(". Energy bond indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(8)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.atom(:).tag)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("R(A--B)")
      table(4).set_subheading("/Angs.")
      table(4).set_width_from(ONE)

      table(5).set_heading("E Cov")
      table(5).set_subhead("index")
      table(5).set_width_from(-TEN)
      table(6).set_heading("E Ion")
      table(6).set_subhead("index")
      table(6).set_width_from(-TEN)
      table(7).set_heading("E Bond")
      table(7).set_subhead(" index")
      table(7).set_width_from(ONE)
      table(8).set_heading("% E")
      table(8).set_subhead("Cov")
      table(8).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)

         do i  = 1,n_bonds
         cAB(i) =  .E_cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .E_ion_index(pair(i,1),pair(i,2))
         tAB(i) = .E_bond_index(pair(i,1),pair(i,2))
         pAB(i) = .E_percent_covalency(pair(i,1),pair(i,2))
         end

         ! Sort & rearrange
         ind.create(n_bonds)
         tAB.quick_sort(ind,decreasing_order=TRUE)
         labels(:,1) = labels(ind,1)
         labels(:,2) = labels(ind,2)
         dist = dist(ind)
         cAB  = cAB(ind)
         iAB  = iAB(ind)
         tAB  = tAB(ind)
         pAB  = pAB(ind)

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dist)
         table(5).set_values(cAB)
         table(6).set_values(iAB)
         table(7).set_values(tAB)
         table(8).set_values(pAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         ind.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      Z_list.destroy

   end

! ==============
! Output charges
! ==============

   put_charges
   ! Put to stdout the group charges.
      self :: IN

   ENSURE(.gould_charge.associated,"no Roby-Gould charges")
   ENSURE(.cruickshank_charge.associated,"no Cruickshank charges")
   ENSURE(.atom.associated,"no atom data")
   ENSURE(.atom_group.associated,"no atom group data")

      a :: INT
      homoleptic :: BIN
      symb :: STR
      symbol :: VEC{STR}*

      homoleptic = .is_homoleptic
      if (NOT homoleptic) symbol => .unique_tags

      stdout.flush
      stdout.text("Group charges:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Roby-Gould")
      stdout.put("Cruickshank")
      stdout.put("Sum_b  Sab/2")
      stdout.put("Sum_bc Sabc/3")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_group
         if (homoleptic) then; symb = a.to_str
         else                ; symb = symbol(a)
         end
         stdout.put(symb,int_width=TRUE)
         stdout.put(.gould_charge(a))
         stdout.put(.cruickshank_charge(a))
         stdout.put(.summed_n2(a)/TWO)
         stdout.put(.summed_n3(a)/THREE)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=4)

      if (NOT homoleptic) symbol.destroy

   end

   put_dipole_moments
   ! Dipole moments are calculated from the charges
      self :: IN

   ENSURE(.gould_charge.associated,"no Roby-Gould charges")
   ENSURE(.cruickshank_charge.associated,"no Cruickshank charges")
   ENSURE(.atom.associated,"no atom data")

      a :: INT
      gd,cd :: VEC{REAL}(3)

      gd = ZERO
      cd = ZERO

      do a = 1,.n_group
         gd(:) = gd(:) + .gould_charge(a)*.atom(a).position(:)
         cd(:) = cd(:) + .cruickshank_charge(a)*.atom(a).position(:)
      end

      ! Convert from AU to Debyes
      gd = gd * ("debye").conversion_factor
      cd = cd * ("debye").conversion_factor

      stdout.flush
      stdout.text("Dipole moments (in DEBYE):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Charge type")
      stdout.put("X")
      stdout.put("Y")
      stdout.put("Z")
      stdout.put("Magnitude")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Roby-Gould")
      stdout.put(gd(1))
      stdout.put(gd(2))
      stdout.put(gd(3))
      stdout.put(sqrt(gd(1)**2 + gd(2)**2 + gd(3)**2))
      stdout.flush
      stdout.put("Cruickshank")
      stdout.put(cd(1))
      stdout.put(cd(2))
      stdout.put(cd(3))
      stdout.put(sqrt(cd(1)**2 + cd(2)**2 + cd(3)**2))
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)

   end

   put_unique_tags(group,name)
   ! Output atom labels for the atom indices given in "group"
      self :: IN
      group :: VEC{INT}, IN
      name :: STR, optional, IN

      symbol :: STR
      label :: STR
      g :: INT

      label = " "
      if (present(name)) label = name

      stdout.put("Atom "//trim(label)//" =")
      do g = 1,group.dim
         symbol = .atom(group(g)).tag
         stdout.put(trim(symbol),width=len_trim(symbol)+1)
      end
      stdout.flush

   end

! =================
! Output theta info
! =================

   put_theta_info
   ! Output Theta-space information
      self :: IN

   ENSURE(.atom_a.associated, "No Roby atom A data")
   ENSURE(.atom_b.associated, "No Roby atom B data")
   ENSURE(.atom_ab.associated,"No Roby atom AB data")

      n,i,j :: INT
      cst,snt,ang :: VEC{REAL}*
      evn,par :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.text("============================")
      stdout.text("Roby-Gould angle eigenspaces")
      stdout.text("============================")

      stdout.flush
      if (NOT .is_hyper_analysis) then
      stdout.text(". Analysis is for atoms:")
      stdout.flush
      .put_unique_tags(.atom_a,"(A)")
      .put_unique_tags(.atom_b,"(B)")
      else
      stdout.text(". This is a hypervalent analysis")
      stdout.flush
      stdout.text(". Analysis is for transfer into atom A from everything not in M")
      stdout.flush
      .put_unique_tags(.atom_a,"(A)")
      .put_unique_tags(.atom_b,"(M)")
      end

      stdout.flush
      if (NOT .is_hyper_analysis) then
      stdout.text(". States come in bonding-antibonding pairs classified by an angle.")
      stdout.text("  Negativef high covalency have high overlap and low angle.")
      stdout.text("  States of high ionicity have low overlap and high angle.")
      else
      stdout.text(". There are no covalent states, only pure ionic")
      end

      stdout.flush
      stdout.text(". For more on this bonding analysis please cite:")
      stdout.text("  M.D. Gould et al. (2008) Theor. Chem. Acc. 119 pp. 275-290")

      n = .eigen_I.dim
      stdout.flush
      stdout.show("No. of states =",n)

      ! Columns
      evn.create(n)
      par.create(n)
      ang.create(n)
      cst.create(n)
      snt.create(n)

      ! Set column data
      j = 0
      do i = 1,n

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle


         j = j + 1
         evn(j) = i
         par(j) = .pair(i)
         ang(j) = .theta_angle(i)
         cst(j) = .eigen_C(i)
         snt(j) = .eigen_I(i)

      end

      n = j

      stdout.flush
      stdout.flush
      stdout.text("Araki angle subspaces:")
      stdout.flush

      ! Do table
      table.create(5)

      table(1).set_heading("Bond")
      table(1).set_subhead("orb.")
      table(1).set_values(evn(1:n))

      table(2).set_heading("Anti")
      table(2).set_subhead("bond")
      table(2).set_values(par(1:n))

      table(3).set_heading("theta")
      table(3).set_subhead(" /deg")
      table(3).set_values(ang(1:n))

      table(4).set_heading("  cos")
      table(4).set_subhead("theta")
      table(4).set_values(cst(1:n))

      table(5).set_heading("  sin")
      table(5).set_subhead("theta")
      table(5).set_values(snt(1:n))

      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      snt.destroy
      cst.destroy
      ang.destroy
      par.destroy
      evn.destroy

   end

   put_theta_BI_info
   ! Output theta-space bond index information
      self :: IN

      n,i,j :: INT
      ang :: VEC{REAL}*
      par :: VEC{STR}*
      c_p,c_m,cov,i_p,i_m,ion,bi :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*

      ! Columns
      n = .eigen_I.dim

      par.create(n)
      ang.create(n)
      c_p.create(n)
      c_m.create(n)
      cov.create(n)
      i_p.create(n)
      i_m.create(n)
      ion.create(n)
       bi.create(n)

      ! Set column data
      j = 0
      do i = 1,n

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle


         j = j + 1

         if (.pair(i)/=i) then
               par(j) = "("//i.to_str.trim//","//.pair(i).to_str.trim//")"
               i_p(j) = .theta_pop_I(i)
               i_m(j) = .theta_pop_I(.pair(i))
         else
               par(j) = "("//i.to_str.trim//")"
            if      (.eigen_I(i)>ZERO) then
               i_p(j) = .theta_pop_I(i)
            else if (.eigen_I(i)<ZERO) then
               i_m(j) = .theta_pop_I(i)
            end
         end

         ang(j) = .theta_angle(i)
         c_p(j) = .theta_pop_C(i)
         c_m(j) = .theta_pop_C(.pair(i))
         cov(j) = .theta_cov_index(i)
         ion(j) = .theta_ion_index(i)

          bi(j) = sqrt(cov(j)*cov(j)+ion(j)*ion(j))

      end

      n = j

      ! Change decimal places
      stdout.save
      stdout.set_real_precision(3)

      stdout.flush
      stdout.flush
      stdout.text("Araki angle subspace covalent/ionic bond indices:")
      stdout.flush

      ! Do table
      table.create(9)

      table(1).set_heading("Paired")
      table(1).set_subhead(" space")
      table(1).set_values(par(1:n))

      table(2).set_heading("theta")
      table(2).set_subhead(" /deg")
      table(2).set_values(ang(1:n))

      table(3).set_heading(" C+")
      table(3).set_subhead("pop")
      table(3).set_values(c_p(1:n))

      table(4).set_heading(" C-")
      table(4).set_subhead("pop")
      table(4).set_values(c_m(1:n))

      table(5).set_heading(" Cov.")
      table(5).set_subhead("index")
      table(5).set_values(cov(1:n))

      table(6).set_heading(" I+")
      table(6).set_subhead("pop")
      table(6).set_values(i_p(1:n))

      table(7).set_heading(" I-")
      table(7).set_subhead("pop")
      table(7).set_values(i_m(1:n))

      table(8).set_heading(" Ion.")
      table(8).set_subhead("index")
      table(8).set_values(ion(1:n))

      table(9).set_heading("Bond")
      table(9).set_subhead("index")
      table(9).set_values(bi(1:n))

      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
       bi.destroy
      ion.destroy
      i_m.destroy
      i_p.destroy
      cov.destroy
      c_m.destroy
      c_p.destroy
      ang.destroy
      par.destroy

      ! Print theta_C if only two groups e.g. for plots
    ! if (.n_group==2) then

    !    stdout.flush
    !    stdout.flush
    !    stdout.text("Roby-Gould covalent orbitals:")
    !    stdout.flush
    !    .atom(.atom_ab).put_orbitals(.theta_C(:,[1,.pair(1)]),pair=TRUE)
    !   
    !    stdout.flush
    !    stdout.flush
    !    stdout.text("Roby-Gould ionic orbitals:")
    !    stdout.flush
    !    .atom(.atom_ab).put_orbitals(.theta_I(:,[1,.pair(1)]),pair=TRUE)

    ! end

      ! Change decimal places
      stdout.unsave

   end

   put_theta_AB_pops
   ! Output theta-space A/B populations information
      self :: IN

      n,i,j :: INT
      ang :: VEC{REAL}*
      par :: VEC{STR}*
      cpa,cpb,cma,cmb :: VEC{REAL}*
      ipa,ipb,ima,imb :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*

      ! Columns
      n = .eigen_I.dim

      par.create(n)
      ang.create(n)
      cpa.create(n); cpa = ZERO
      cpb.create(n); cpb = ZERO
      cma.create(n); cma = ZERO
      cmb.create(n); cmb = ZERO
      ipa.create(n); ipa = ZERO
      ipb.create(n); ipb = ZERO
      ima.create(n); ima = ZERO
      imb.create(n); imb = ZERO

      ! Set column data
      j = 0
      do i = 1,n

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle


         j = j + 1

         if (.pair(i)/=i) then
               par(j) = "("//i.to_str.trim//","//.pair(i).to_str.trim//")"
               ipa(j) = .theta_pop_I_A(i)
               ipb(j) = .theta_pop_I_B(i)
               ima(j) = .theta_pop_I_A(.pair(i))
               imb(j) = .theta_pop_I_B(.pair(i))
         else
               par(j) = "("//i.to_str.trim//")"
            if      (.eigen_I(i)>ZERO) then
               ipa(j) = .theta_pop_I_A(i)
               ipb(j) = .theta_pop_I_B(i)
            else if (.eigen_I(i)<ZERO) then
               ima(j) = .theta_pop_I_A(i)
               imb(j) = .theta_pop_I_B(i)
            end
         end

         ang(j) = .theta_angle(i)
         cpa(j) = .theta_pop_C_A(i)
         cpb(j) = .theta_pop_C_B(i)
         cma(j) = .theta_pop_C_A(.pair(i))
         cmb(j) = .theta_pop_C_B(.pair(i))

      end

      n = j

      ! Change decimal places
      stdout.save
      stdout.set_real_precision(3)

      stdout.flush
      stdout.flush
      stdout.text("Araki angle subspace A & B populations:")
      stdout.flush

      ! Do table
      table.create(10)

      table( 1).set_heading("Paired")
      table( 1).set_subhead(" space")
      table( 1).set_values(par(1:n))

      table( 2).set_heading("theta")
      table( 2).set_subhead(" /deg")
      table( 2).set_values(ang(1:n))

      table( 3).set_heading("C+a")
      table( 3).set_subhead("pop")
      table( 3).set_values(cpa(1:n))

      table( 4).set_heading("C+b")
      table( 4).set_subhead("pop")
      table( 4).set_values(cpb(1:n))

      table( 5).set_heading("C-a")
      table( 5).set_subhead("pop")
      table( 5).set_values(cma(1:n))

      table( 6).set_heading("C-b")
      table( 6).set_subhead("pop")
      table( 6).set_values(cmb(1:n))

      table( 7).set_heading("I+a")
      table( 7).set_subhead("pop")
      table( 7).set_values(ipa(1:n))

      table( 8).set_heading("I+b")
      table( 8).set_subhead("pop")
      table( 8).set_values(ipb(1:n))

      table( 9).set_heading("I-a")
      table( 9).set_subhead("pop")
      table( 9).set_values(ima(1:n))

      table(10).set_heading("I-b")
      table(10).set_subhead("pop")
      table(10).set_values(imb(1:n))

      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      imb.destroy
      ima.destroy
      ipb.destroy
      ipa.destroy
      cmb.destroy
      cma.destroy
      cpb.destroy
      cpa.destroy
      ang.destroy
      par.destroy

      ! Change decimal places
      stdout.unsave

   end

   put_theta_energy_info
   ! Output Theta-space energy information
      self :: IN

      n,i,j :: INT
      angle :: REAL
      ang :: VEC{REAL}*
      par :: VEC{STR}*
      c_p,c_m,cov,i_p,i_m,ion :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*

      ! Columns
      n = .n_paired_angles

      par.create(n)
      ang.create(n)
      c_p.create(n)
      c_m.create(n)
      cov.create(n)
      i_p.create(n)
      i_m.create(n)
      ion.create(n)

      ! Set column data
      j = 0
      do i = 1,.n_bf_ab

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle
         if (j==n) cycle

         angle = .theta_angle(i)
         if (angle.equals(90.0d0,.zero_angle_cutoff)) cycle

         j = j + 1

         par(j) = "("//i.to_str.trim//","//.pair(i).to_str.trim//")"
         ang(j) = angle
         c_p(j) = .theta_E_C(i)
         c_m(j) = .theta_E_C(.pair(i))
         cov(j) = .theta_E_cov_index(i)
         i_p(j) = .theta_E_I(i)
         i_m(j) = .theta_E_I(.pair(i))
         ion(j) = .theta_E_ion_index(i)

      end

      ! Do table
      table.create(8)

      table(1).set_heading("Paired")
      table(1).set_subhead(" space")
      table(1).set_values(par)

      table(2).set_heading("theta")
      table(2).set_subhead(" /deg")
      table(2).set_values(ang)

      table(3).set_heading("  C+  ")
      table(3).set_subhead("energy")
      table(3).set_values(c_p)

      table(4).set_heading("  C- ")
      table(4).set_subhead("energy")
      table(4).set_values(c_m)

      table(5).set_heading("E Cov")
      table(5).set_subhead("index")
      table(5).set_values(cov)

      table(6).set_heading("  I+  ")
      table(6).set_subhead("energy")
      table(6).set_values(i_p)

      table(7).set_heading("  I-  ")
      table(7).set_subhead("energy")
      table(7).set_values(i_m)

      table(8).set_heading("E Ion")
      table(8).set_subhead("index")
      table(8).set_values(ion)

      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      ion.destroy
      i_m.destroy
      i_p.destroy
      cov.destroy
      c_m.destroy
      c_p.destroy
      ang.destroy
      par.destroy

   end

!   put_theta_atom_pops
!   ! Output Roby angles and populations
!      self :: IN
!
!   ENSURE(.atom_a.associated, "No Roby atom A data")
!   ENSURE(.atom_b.associated, "No Roby atom B data")
!   ENSURE(.atom_ab.associated,"No Roby atom AB data")
!   ENSURE(.theta_angle.associated, "No theta angles")
!
!      n,i,j :: INT
!      angle :: REAL
!      ang :: VEC{REAL}*
!      evn :: VEC{INT}*
!      n_A,n_B,nAB :: VEC{REAL}*
!      table :: VEC{TABLE_COLUMN}*
!
!      stdout.flush
!      stdout.text("======================================")
!      stdout.text("Roby-Gould pair-atom angle eigenspaces")
!      stdout.text("======================================")
!      stdout.flush
!      stdout.text(". Analysis is for:")
!      stdout.flush
!      .put_unique_tags(.atom_a,"(A)")
!      .put_unique_tags(.atom_b,"(B)")
!      stdout.flush
!
!      ! Columns
!      n = .n_theta_angles
!      evn.create(n)
!      ang.create(n)
!      n_A.create(n)
!      n_B.create(n)
!      nAB.create(n)
!
!      ! Set column data
!      j = 0
!      do i = 1,.n_bf_ab
!
!         if (.pair(i)<1) cycle
!         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle
!
!         angle = .theta_angle(i)
!         if (angle.equals(90.0d0,.zero_angle_cutoff)) cycle
!
!         j = j + 1
!         evn(j) = i
!         ang(j) = angle
!         n_A(j) = .theta_pop_A(i)
!         n_B(j) = .theta_pop_B(i)
!         nAB(j) = .theta_pop_A(i) + .theta_pop_B(i)
!
!      end
!
!      ! Do table
!      table.create(5)
!
!      table(1).set_heading("Eigvec")
!      table(1).set_subhead("   #  ")
!      table(1).set_values(evn)
!
!      table(2).set_heading(" Theta")
!      table(2).set_subhead("  /deg")
!      table(2).set_values(ang)
!
!      table(3).set_heading("n_A")
!      table(3).set_values(n_A)
!
!      table(4).set_heading("n_B")
!      table(4).set_values(n_B)
!
!      table(5).set_heading("Total")
!      table(5).set_values(nAB)
!
!      table.put
!
!      ! Clean
!      table.clear_columns
!      nAB.destroy
!      n_B.destroy
!      n_A.destroy
!      ang.destroy
!      evn.destroy
!
!   end

!   n_theta_angles result (res) ::: PURE
!   ! Output Roby angles and populations
!      self :: IN
!      res :: INT
!
!   ENSURE(.theta_angle.associated, "No theta angles")
!
!      angle :: REAL
!      i :: INT
!
!      res = 0
!
!      do i = 1,.n_bf_ab
!
!         angle = .theta_angle(i)
!         if (angle.equals(90.0d0,.zero_angle_cutoff)) cycle
!
!         res = res + 1
!
!      end
!
!   end

   n_paired_angles result (res) ::: PURE
   ! Output Roby angles and populations
      self :: IN
      res :: INT

   ENSURE(.pair.associated, "No pair info")
   ENSURE(.eigen_C.associated, "No eigenvalues")
   ENSURE(.theta_angle.associated, "No theta angles")

      i :: INT

      res = 0

      do i = 1,.n_bf_ab

         if (.pair(i)<1) cycle
         if (.pair(i)==i) cycle

         res = res + 1

      end

   end

   put_shared_population
   ! Put to stdout the multiple shared Roby atom populations
      self :: IN

   ENSURE(.subgroup_pop.associated,"no subgroup population totals exist")
   ENSURE(.atom.associated,"no atom data")
   ENSURE(.atom_group.associated,"no atom group data")

      a :: INT
      symbol :: VEC{STR}*

      stdout.flush
      stdout.text("===============================")
      stdout.text("Roby multiple shared population")
      stdout.text("===============================")
      stdout.flush
      stdout.show("Multiple shared population =",.n_shared)
      stdout.text("Contributions by subgroup size:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("Subgrp size",int_width=TRUE)
      stdout.put("Subgrp Pop.")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      do a = 1,.n_group
         stdout.put(symbol(a),int_width=TRUE)
         stdout.put(.subgroup_pop(a))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=1)

      symbol.destroy

   end

end
