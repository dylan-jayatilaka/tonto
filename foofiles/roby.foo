!---------------------------------------------------------------------------
!
!  ROBY:
!
!  Read and evaluate Roby atom data for population and bond analysis.
!  This module has been completely rewritten from Chris Taylor's version,
!  based on Steve Wolff's checked version.
!
! Copyright (C) Chris Taylor, UWA, 1999.
! Copyright (C) Stephen Wolff, UWA, 2000-2001.
! Copyright (C) Dylan Jayatilaka, 2001
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module ROBY

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   create(mol) ::: leaky
   ! Create space for the object
      self :: PTR
      mol :: MOLECULE

      .create
      .set_defaults(mol)

   end

   destroy ::: leaky, PURE
   ! Destroy space for an SCF type
      self :: PTR

      if (.disassociated) return

      .nullify_ptr_data

      .destroy_ptr_part

      deallocate(self)

   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts of self
      self :: INOUT

      nullify(.atom_list)
      nullify(.atom_group)
      nullify(.atom_a)
      nullify(.atom_b)
      nullify(.atom_ab)

      nullify(.atom)

   end

   nullify_ptr_data ::: pure
   ! Nullify the pointer data that is supposed to come from outside
   ! this module, so that this data is *not* accidentally destroyed
      self :: INOUT

      nullify(.atom)

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .n1.destroy
      .n2.destroy

      .bond_index.destroy
      .cov_index.destroy
      .ion_index.destroy
      .percent_covalency_P.destroy
      .percent_covalency_A.destroy

      .gould_charge.destroy
      .cruickshank_charge.destroy

      .summed_n2.destroy
      .summed_n3.destroy
      .subgroup_pop.destroy

      .atom_list.destroy
      .atom_group.destroy
    ! .atom_a.destroy
    ! .atom_b.destroy
    ! .atom_ab.destroy

      .theta_C.destroy
      .eigen_C.destroy
      .theta_I.destroy
      .eigen_I.destroy
      .theta_pop_C.destroy
      .theta_pop_C_A.destroy
      .theta_pop_C_B.destroy
      .theta_pop_I.destroy
      .theta_pop_I_A.destroy
      .theta_pop_I_B.destroy

      .theta_cov_index.destroy
      .theta_ion_index.destroy

      .proportion_a.destroy
      .pair.destroy

      ! Energies

      .w_DE.destroy
      .E2_DE.destroy
      .E2.destroy

      .w_NA.destroy
      .E1_DE.destroy
      .E1.destroy

      .E1_cov.destroy
      .E1_ion.destroy
      .E1_bond.destroy

      ! Never destroy these.
      nullify(.atom)

   end

   destroy_theta_info ::: leaky, private, PURE
   ! Delete all the temporary theta subspace information created by
   ! various bond index routines
      self :: INOUT

      ! Theta population indices
      .theta_ion_index.destroy
      .theta_cov_index.destroy
      .theta_pop_I_B.destroy
      .theta_pop_I_A.destroy
      .theta_pop_I.destroy
      .theta_pop_C_B.destroy
      .theta_pop_C_A.destroy
      .theta_pop_C.destroy

      ! Theta energy indiced
      .theta_E_I_B.destroy
      .theta_E_I_A.destroy
      .theta_E_I.destroy
      .theta_E_C_B.destroy
      .theta_E_C_A.destroy
      .theta_E_C.destroy

      ! Theta eigenstates
      .eigen_I.destroy
      .theta_I.destroy
      .pair.destroy
      .theta_angle.destroy
      .eigen_C.destroy
      .theta_C.destroy

   end

   destroy_bond_info ::: leaky, private, PURE
   ! Delete all the bond index/bond energy info
      self :: INOUT

      .percent_covalency_A.destroy
      .percent_covalency_P.destroy
      .ion_index.destroy
      .cov_index.destroy
      .bond_index.destroy

      .E1_cov.destroy
      .E1_ion.destroy
      .E1_bond.destroy

   end


!  ===========
!  Set methods
!  ===========

   set_defaults ::: PURE
   ! Set default SCF data values
      self :: INOUT

      ! Important
      .roby_kind = "bond_and_charge_analysis"
      .zero_angle_cutoff      = ROBY_ZERO_ANGLE_CUTOFF*RADIAN_PER_DEGREE
      .set_use_NAOs(FALSE)

      ! Other rubbish
      .output_theta_info      = ROBY_OUTPUT_THETA_INFO
      .analyze_all_atom_pairs = ROBY_ANALYZE_ALL_ATOM_PAIRS
      .analyze_vdw_atom_pairs = FALSE
      .bond_range_factor      = ROBY_BOND_RANGE_FACTOR

   end

   set_defaults(mol)
   ! Set only the defaults derivable from molecule "mol"
      self :: INOUT
      mol :: MOLECULE, target, IN

   ENSURE(mol.atom.associated,"no atom list")
   ENSURE(mol.density_matrix.allocated,"no density matrix")
   ENSURE(mol.overlap_matrix.associated,"no overlap matrix")

      .charge            =  mol.charge
      .spin_multiplicity =  mol.spin_multiplicity

      ! Note: pointer assignment
      .atom              => mol.atom

      .density_matrix =  mol.density_matrix
      .overlap_matrix =  mol.overlap_matrix
      .core_matrix    =  mol.core_matrix

      if (mol.fock_matrix.allocated) &
      .fock_matrix    =  mol.fock_matrix

   end

   set_DE_weight_method(val) ::: PURE
   ! Set the method of weighting E^def to assign to each atom in bond
   ! energy calculations.
      self :: INOUT
      val :: STR, IN

      .DE_weight_method = val

      .DE_weight_method.to_lower_case

   ENSURE(.DE_weight_method.is_one_of(["v_nn"]),"unknown method")

   end

   set_E1_method(val) ::: PURE
   ! Set the method used to generate the first-order reduced energy
   ! density matrix.
      self :: INOUT
      val :: STR, IN

      .E1_method = val

      .E1_method.to_lower_case

   ENSURE(.E1_method.is_one_of(["exact ","krogel"]),"unknown method")

   end

   set_NA_weight_method(val) ::: PURE
   ! Set the method of weighting E^NA to assign to each atom in bond
   ! energy calculations.
      self :: INOUT
      val :: STR, IN

      .NA_weight_method = val

      .NA_weight_method.to_lower_case

   ENSURE(.NA_weight_method.is_one_of(["e_a^0","z_a  "]),"unknown method")

   end

   set_roby_kind(val)
   ! Set default SCF data values
      self :: INOUT
      val :: STR, IN

      .roby_kind = val

      .roby_kind.to_lower_case

      select case (.roby_kind)
      case("atom_bond_analysis       ")
      case("atom_e1_analysis         ")
      case("atom_hyper_analysis      ")
      case("group_bond_analysis      ")
      case("group_hyper_analysis     ")
      case("shared_population        ")
      case default;  UNKNOWN(.roby_kind)
      end

   end

   set_show_calcs(val) ::: PURE
   ! Set whether to show detailed RGBI calcs.
      self :: INOUT
      val :: BIN, IN

      .show_calcs = val

   end

   set_use_spherical_averaging(val) ::: PURE
   ! Set whether to use spherical averaging for the NAOs.
   ! Spherical averaging is always used for ANOs.
      self :: INOUT
      val :: BIN, IN

      .use_spherical_averaging = val

   end

   set_use_NAOs(val) ::: PURE
   ! Set whether to use NAOs as atomic projectors instead of ANOs as
   ! in the original 2008 paper.
      self :: INOUT
      val :: BIN, IN

      .use_NAOs = val

      if (val) then
         .occupied_ANO_cutoff = ROBY_OCCUPIED_NAO_CUTOFF
      else
         .occupied_ANO_cutoff = ROBY_OCCUPIED_ANO_CUTOFF
      end


   end

   set_use_projected_NAOs(val) ::: PURE
   ! Set whether to use NAOs as atomic projectors instead of ANOs as
   ! in the original 2008 paper.
      self :: INOUT
      val :: BIN, IN

      .use_projected_NAOs = val

    ! if (val) then
    !    .use_NAOs = FALSE
    !    .occupied_ANO_cutoff = ROBY_OCCUPIED_NAO_CUTOFF
    ! else
    !    .occupied_ANO_cutoff = ROBY_OCCUPIED_ANO_CUTOFF
    ! end


   end

   set_output_ci_latex_labels(val) ::: PURE
   ! Set whether to output c & i labels above latex structure in 
   ! RGBI plots
      self :: INOUT
      val :: BIN, IN

      .output_ci_latex_labels = val

   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

      case ("}                       ")  ! exit case

      case ("analyze_all_atom_pairs= "); .read_analyze_all_atom_pairs
      case ("analyze_vdw_atom_pairs= "); .read_analyze_vdw_atom_pairs
      case ("atom_groups=            "); .read_atom_groups
      case ("atom_list=              "); .read_atom_list

      case ("bond_scale_factors=     "); .read_bond_scale_factor

      case ("de_weight_method=       "); .read_DE_weight_method

      case ("e1_method=              "); .read_E1_method
 
      case ("kind=                   "); .read_kind

      case ("na_weight_method=       "); .read_NA_weight_method

      case ("occupied_ano_cutoff=    "); .read_occupied_ANO_cutoff
      case ("output_ci_latex_labels= "); .read_output_ci_labels 
      case ("output_theta_info=      "); .read_output_theta_info

      case ("put_core_matrix         "); stdout.put(.core_matrix)
      case ("put_density_matrix      "); stdout.put(.density_matrix)
      case ("put_fock_matrix         "); stdout.put(.fock_matrix)
      case ("put_overlap_matrix      "); stdout.put(.overlap_matrix)

      case ("shared_population       "); .make_shared_population
      case ("show_calcs=             "); .read_show_calcs

      case ("use_naos=               "); .read_use_NAOs
      case ("use_pnaos=              "); .read_use_projected_NAOs
      case ("use_projected_naos=     "); .read_use_projected_NAOs
      case ("use_spherical_averaging="); .read_use_spherical_averaging

      case ("zero_angle_cutoff=      "); .read_zero_angle_cutoff

      case default;           UNKNOWN(word)

      end

   end

   finalize ::: leaky
   ! Make sure the input satisfies sanity checks and generate any other
   ! missing data
      self :: INOUT

   ENSURE(.roby_kind/=" ","no calculation kind specified")
   ENSURE(.atom.associated,"no atom data supplied")
 ! ENSURE(.atom_list.associated NEQV .atom_group.associated,"atom_list and atom_group both used!")

      if (FALSE) self = self

   end

   read_kind
   ! Read the SCF type
      self :: INOUT

      val :: STR

      stdin.read(val)

      .set_roby_kind(val)

   end

   read_atom_list ::: leaky
   ! Read the list of atoms indices defining a Roby group
      self :: INOUT

      stdin.read_ptr(.atom_list)

   end

   read_atom_groups ::: leaky
   ! Read the list of atoms indices defining a Roby group
      self :: INOUT

      stdin.read_ptr(.atom_group)

   end

   read_E1_method
   ! Read the method used to generate the first-order reduced energy
   ! density matrix.
      self :: INOUT

      method :: STR

      stdin.read(method)

      .set_E1_method(method)

   end

   read_DE_weight_method
   ! Read the method of weighting E^def to assign to each atom in bond
   ! energy calculations.
      self :: INOUT

      method :: STR

      stdin.read(method)

      .set_DE_weight_method(method)

   end

   read_NA_weight_method
   ! Read the method of weighting E^NA to assign to each atom in bond
   ! energy calculations.
      self :: INOUT

      method :: STR

      stdin.read(method)

      .set_NA_weight_method(method)

   end

   read_occupied_ANO_cutoff
   ! Read the cutoff to decide occupied ANOs or NAOs
      self :: INOUT

      stdin.read_quantity(.occupied_ANO_cutoff)

   end

   read_zero_angle_cutoff
   ! Angles (in radians) *less* than this one inputted are regareded as zero
      self :: INOUT

      stdin.read_quantity(.zero_angle_cutoff)

   end

   read_output_ci_labels
   ! Read whether to output c/i labels above/below the bond line in
   ! the latex structure figures - for use with make-rgbi-pic script.
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_output_ci_latex_labels(val)

   end

   read_output_theta_info
   ! Read in a switch which tells whether to output detailed
   ! theta-subspace bond information
      self :: INOUT

      stdin.read(.output_theta_info)

   end

   read_analyze_all_atom_pairs
   ! Read in a switch which tells whether to bond-analyze all atoms
   ! pairs or not - actually this just changes the bond_range_factor
   ! by an order of magnitude
      self :: INOUT

      stdin.read(.analyze_all_atom_pairs)

      if (.analyze_all_atom_pairs) then
         .bond_range_factor = FIVE*BOHR_PER_ANGSTROM
      end

   end

   read_analyze_vdw_atom_pairs
   ! Read in a switch which tells whether to bond-analyze all atoms
   ! pairs or not - actually this just changes the bond_range_factor
   ! by an order of magnitude
      self :: INOUT

      stdin.read(.analyze_vdw_atom_pairs)

   end

   read_show_calcs
   ! Read whether to show detailed RGBI calcs for each bond.
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_show_calcs(val)

   end

   read_use_NAOs
   ! Read whether to use NAOs as atomic projectors instead of ANOs as
   ! in the original 2008 paper.
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_use_NAOs(val)

   end

   read_use_projected_NAOs
   ! Read whether to use projected NAOs instead of NAOs
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_use_projected_NAOs(val)

   end

   read_use_spherical_averaging
   ! Read whether to use sperhically averaged NAOs.
      self :: INOUT

      val :: BIN

      stdin.read(val)

      .set_use_spherical_averaging(val)

   end

   read_bond_scale_factor
   ! Read in a bond scale factor used to multiply the sum of the
   ! Bragg-Slater radii for two atoms, to determine a distance cutoff
   ! within which atoms are regarded to be bonded
      self :: INOUT

      stdin.read(.bond_range_factor)

   end

!  ===================
!  Information methods
!  ===================

   is_homoleptic result (res) ::: pure
   ! Returns TRUE if the calculation data is "homoleptic" or not
   ! i.e. involving groups of atoms
      self :: IN
      res :: BIN

      res = .atom_list.disassociated

   end

   skip_pair(a,b) result (res) ::: private, pure
   ! Returns TRUE if the bond index calculation should skip the pair of groups
   ! (a,b). For calculations which are homoleptic, this always returns FALSE, but
   ! for calculations which are defined by an atom_list, this returns TRUE only if
   ! .analyze_all_atom_pairs is set to FALSE and the atoms are regarded as bonded
   ! according to the .bond_range_factor distance cutoff.
      self :: IN
      a,b :: INT, IN
      res :: BIN

      if (.is_homoleptic) then;

         ! Do all
         res = FALSE

      else if (.analyze_all_atom_pairs) then

         ! Do all
         res = FALSE

      else if (.analyze_vdw_atom_pairs) then

         ! Do only vdw pairs
         res = NOT .atom.vdw_bonded(a,b,.bond_range_factor)

      else

         ! Do bonded pairs
         res = NOT .atom.bonded(a,b,.bond_range_factor)

         ! Do vdw pairs too
         res = res AND NOT .atom.vdw_bonded(a,b)

      end

   end

   n_bf(group) result (res) ::: private, PURE
   ! Return the number of basis functions in the atom group
   ! whose indices are given in "group"; but if "group" is
   ! not present return the dimension of the full overlap matrix.
      self :: IN
      group :: VEC{INT}, optional, IN
      res :: INT

   ENSURE(.atom.associated,"No atom information")
   ENSURE(.overlap_matrix.allocated,"No overlap matrix")

      if (present(group)) then; res = .atom(group).no_of_basis_functions
      else;                     res = .overlap_matrix.dim1
      end

   end

   n_bf_a result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_a group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_a.associated,"No atom A group")

      res = .n_bf(.atom_a)

   end

   n_bf_b result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_b group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_b.associated,"No atom B group")

      res = .n_bf(.atom_b)

   end

   n_bf_ab result (res) ::: private, PURE
   ! Return the number of basis functions in the .atom_b group
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"No atom infpormation")
   ENSURE(.atom_ab.associated,"No atom AB group")

      res = .n_bf(.atom_ab)

   end

   n_group result (res) ::: PURE
   ! Return the number of roby atom groups
      self :: IN
      res :: INT

   ENSURE(.atom_group.associated,"no atom groups!")

      res = .atom_group.dim

   end

   no_of_occupied_NAOs(group,tol) result (res) ::: private, PURE
   ! Return the number of occupied NAOs for the group of atoms whose
   ! indices are in "group"
      self :: IN
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.atom.associated,"no atom information")

      eps :: REAL

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      res = .atom(group).no_of_occupied_NAOs(tol=eps)

   end

   no_of_occupied_ANOs(group,tol) result (res) ::: private, PURE
   ! Return the number of occupied atomic natural orbitals for
   ! the group of atoms whose indices are in "group"
      self :: IN
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.atom.associated,"no atom information")

      eps :: REAL

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      res = .atom(group).no_of_occupied_ANOs(tol=eps)

   end

   unique_tags result (res) ::: leaky, PURE
   ! Return a list of unique tags for the atom groups
      self :: IN
      res :: VEC{STR}@

      symbols :: VEC{STR}@
      g :: INT

      if (.is_homoleptic) then

         res.create(.atom_group.dim)
         do g = 1,.atom_group.dim
            symbols = .atom(.atom_group(g).element).tag
            res(g)  = VEC{STR}:to_concatenated_str(symbols)
            symbols.destroy
         end

      else

         res = .atom(.atom_list).tag

      end

   end

   numbered_tag(group) result (res) ::: PURE
   ! Output the atom labels with their numbers for the atom indices
   ! given in "group"
      self :: IN
      group :: VEC{INT}, IN
      res :: STR

      g :: INT

      ! First atom
      res =  trim(.atom(group(1)).chemical_symbol) &
          // trim(group(1).to_str)

      ! The rest, if any
      do g = 2,group.dim
         res =  trim(res) &
             // "-" &
             // trim(.atom(group(1)).chemical_symbol) &
             // trim(group(g).to_str)
      end

   end

! ============
! Main methods
! ============

   atom_bond_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")

      i,n_atom :: INT

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Bond orders
      .is_hyper_analysis = FALSE
      .bond_analysis
    ! .charge_analysis

      .put_basics
      .put_populations
      .put_bond_indices

   end

   atom_hyper_analysis ::: leaky
   ! Do a Roby-Gould ionic/hypervalent bond analysis
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")

      i,n_atom :: INT

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Bond orders
      .is_hyper_analysis = TRUE
      .hyper_analysis

      ! Put
      .put_basics
      .put_populations
      .put_bond_indices

   end


   group_bond_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

      .bond_analysis
    ! .charge_analysis

      .put_basics
      .put_populations
      .put_bond_indices

   end

   group_hyper_analysis ::: leaky
   ! Do a Roby bond and Gould charge analysis.
      self :: INOUT

      .hyper_analysis
    ! .charge_analysis

      .put_basics
      .put_populations
      .put_bond_indices_hyper

   end


   bond_analysis ::: leaky, private
   ! Do a Roby-Gould bond and charge analysis for the atom groups
   ! given in .atom_groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group defined")

      n_group,a,b,n_bond_do_H,n_bond_no_H :: INT
      ind,cov,ion,pccp,pcca :: REAL
      dial :: TEXTFILE*

      n_group = .n_group

      ! Populations
      .make_populations
      .make_pair_populations

      ! Clean
      .destroy_bond_info
      .bond_index.create(n_group,n_group)
      .cov_index.create(n_group,n_group)
      .ion_index.create(n_group,n_group)
      .percent_covalency_P.create(n_group,n_group)
      .percent_covalency_A.create(n_group,n_group)

      ! File name & redirect
      if (.output_theta_info) then
         dial.create("rgbi-dial-figures.tex")
         dial.open_for("writing")
      end

      ! Make bonds for pairs of group
      n_bond_do_H = 0
      n_bond_no_H = 0
      do a = 1,n_group
      do b = a+1,n_group

         if (.skip_pair(a,b)) cycle

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         !!!!!!!!!!!!!!!!!!!
         .destroy_theta_info
         .make_theta_info
         !!!!!!!!!!!!!!!!!!!

         ind = .gould_bond_index(cov,ion,pccp,pcca)

         .bond_index(a,b)          =  ind
         .cov_index(a,b)           =  cov
         .ion_index(a,b)           =  ion
         .percent_covalency_P(a,b) =  pccp
         .percent_covalency_A(a,b) =  pcca

         .bond_index(b,a)          =  ind
         .cov_index(b,a)           =  cov
         .ion_index(b,a)           = -ion
         .percent_covalency_P(b,a) =  pccp
         .percent_covalency_A(b,a) =  pcca

         if (.output_theta_info) then

            .put_theta_info
            .put_theta_BI_info

            n_bond_do_H = n_bond_do_H + 1
            .put_dial_BI_info_do_H(a,b,dial,n_bond_do_H)

            if (.atom(a).is_not_a_H_atom) then
            if (.atom(b).is_not_a_H_atom) then
            n_bond_no_H  = n_bond_no_H  + 1
            ! Keep original atom label
            .put_dial_BI_info_no_H(a,b,dial,n_bond_no_H)
            end
            end

         end

      end
      end

      if (.output_theta_info) then
         dial.close
         ::put_dial_table_do_H(n_bond_do_H)
         ::put_dial_table_no_H(n_bond_no_H)
      end

      .atom.put_xyz_file

   end

   hyper_analysis ::: leaky, private
   ! Do a Roby-Gould hypervalent bond analysis for the atom groups
   ! given in .atom_groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group defined")

      n_group,a :: INT
      ind,cov,ion,pccp,pcca :: REAL

      n_group = .n_group

      ! Populations
      .make_populations

      .put_populations

      ! This is actually M, not ~M
      .atom_b.to_sequence(1,.atom.dim)
      .atom_ab.to_sequence(1,.atom.dim)

      ! Clean
      .destroy_bond_info
      .bond_index.create(n_group,n_group)
      .cov_index.create(n_group,n_group)
      .ion_index.create(n_group,n_group)
      .percent_covalency_P.create(n_group,n_group)
      .percent_covalency_A.create(n_group,n_group)

      ! Make bonds for A to ~M
      do a = 1,n_group

         ! A group
         .atom_a => .atom_group(a).element

         !!!!!!!!!!!!!!!!!!!
         .destroy_theta_info
         .make_hyper_info
         !!!!!!!!!!!!!!!!!!!

         ind = .gould_bond_index(cov,ion,pccp,pcca)

         .bond_index(a,a)          =  ind
         .cov_index(a,a)           =  cov
         .ion_index(a,a)           =  ion
         .percent_covalency_P(a,a) =  pccp
         .percent_covalency_A(a,a) =  pcca

         if (.output_theta_info) then
            .put_theta_info
            .put_theta_BI_info
            .put_theta_AB_pops
         end

      end

   end

! =================================
! Roby population analysis routines
! =================================

   make_single_atom_groups ::: leaky, private
   ! Make each Roby atom to be equal to a single atom formed from
   ! each element in the ".atom_list".
      self :: INOUT

   ENSURE(.atom_list.associated,"no atom list")

      n_atom,a :: INT

      n_atom = size(.atom_list)

      .atom_group.destroy
      .atom_group.create(n_atom)

      do a = 1,n_atom
         .atom_group(a).element.create(1)
         .atom_group(a).element(1) = .atom_list(a)
      end

   end

   make_populations ::: leaky, private
   ! Make the Roby populations for the defined atom groups, for a
   ! given .density_matrix 
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.density_matrix.allocated,"no rho matrix")

      a :: INT

      ! Clean
      .n1.destroy
      .n1.create(.n_group)

      ! Population of all atoms
      .atom_ab.to_sequence(1,.atom.dim)
      .n_all = .population(.atom_ab)
      .atom_ab.destroy

      ! Make populations
      do a = 1,.n_group

         .atom_a => .atom_group(a).element

         .n1(a)  =  .population(.atom_a)

         nullify(.atom_a)

      end


   end

   make_pair_populations ::: leaky, private
   ! Make the pair Roby populations
      self :: INOUT

      n_group,a,b :: INT
      pop :: REAL

      n_group = .n_group

      ! Clean
      .n2.destroy
      .n2.create(n_group,n_group)
      .n2 = ZERO

      ! Make pair populations
      do a = 1,n_group
      do b = a+1,n_group

         if (.skip_pair(a,b)) cycle

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         pop = .population(.atom_ab)

         .n2(a,b) = pop
         .n2(b,a) = pop

         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

   end

   make_triple_populations ::: leaky, private
   ! Make the triple Roby populations
      self :: INOUT

      n_group,a,b,c :: INT
      pop :: REAL

      n_group = .n_group

      ! Clean
      .n3.destroy
      .n3.create(n_group,n_group,n_group)
      .n3 = ZERO

      ! Make pair populations
      do a = 1,n_group
      do b = a+1,n_group
      do c = b+1,n_group

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element
         .atom_c => .atom_group(c).element

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_abc.destroy
         .atom_abc.append(.atom_a)
         .atom_abc.append(.atom_b)
         .atom_abc.append(.atom_c)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         pop = .population(.atom_abc)

         .n3(a,b,c) = pop
         .n3(b,a,c) = pop
         .n3(c,a,b) = pop
         .n3(c,b,a) = pop
         .n3(a,c,b) = pop
         .n3(b,c,a) = pop

         nullify(.atom_a)
         nullify(.atom_b)
         nullify(.atom_c)

      end
      end
      end

   end

   population(group,ANO,reverse,rho) result (res) ::: private
   ! Return the total population for the projector P associated with
   ! the group of atoms whose indices are in "group", i.e
   !
   !   res = Tr (P_{group;ANO} density_matrix )
   !
   ! If present, the columns of the "ANO" matrix are used to define
   ! the Roby projector instead of the atomic natural orbitals.
   !
   ! If "reverse" is present and TRUE, the orbitals used to make the
   ! projection operator are the *unoccupied* ANOs.
   !
   ! If "rho" is present then it is used for the "density_matrix".
      self :: INOUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN
      reverse :: BIN, optional, IN
      rho :: OPMATRIX@, optional, IN
      res :: REAL

   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.overlap_matrix.allocated,"no overlap matrix")

      P :: MAT{REAL}@
      gr :: VEC{INT}@
      n_gr :: INT
      rev :: BIN

      ! Reverse
      rev = FALSE
      if (present(reverse)) rev = reverse

      ! Group atom indices
      if (rev) then
         gr.to_sequence(1,.atom.dim)
         gr.prune(group)
      else
         gr = group
      end

      ! No. of groups
      n_gr = .n_bf(gr)

      ! Make small P matrix
      P.create(n_gr,n_gr)
      .make_projection_matrix(P,gr,ANO)

      ! Evaluate
      res = .expectation(P,gr,rho)

      ! Clean
      P.destroy
      gr.destroy

   end

   subpopulation(subgroup,group,ANO,rho) result (res) ::: private
   ! Return the Roby subpopulation for the subgroup of atoms whose
   ! indices are given in "subgroup", in the whole group of atoms
   ! whose indices are are given in "group", i.e
   !    res = Tr ( P_{subgroup} P_{group;ANO} P_{subgroup} 
   !               density_matrix)
   ! If present, the columns of the "ANO" matrix are used to define
   ! the middle Roby projector instead of the atomic natural orbitals.
   ! Note that the real atomic natural orbitals are always used for
   ! the P_{subgroup} projector.  This routine is useful for getting
   ! theta orbital populations.
      self :: INOUT
      subgroup :: VEC{INT}, IN
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN
      rho :: OPMATRIX@, optional, IN
      res :: REAL

   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.overlap_matrix.allocated,"no overlap matrix")

      P,X,P_sub :: MAT{REAL}*
      n_gr,n_sub :: INT

      n_gr  = .n_bf(group)
      n_sub = .n_bf(subgroup)

      X.create(n_sub,n_sub)
      P.create(n_gr,n_gr)
      P_sub.create(n_sub,n_sub)

      .make_projection_matrix(P,group,ANO)
      .make_projection_matrix(P_sub,subgroup)
      .project(P,P_sub,X,group,subgroup)

      P_sub.destroy
      P.destroy

      res = .expectation(X,subgroup,rho)

      X.destroy

   end

! ================================
! Roby multiple shared populations
! ================================

   make_shared_population ::: leaky
   ! Evaluate the Roby shared population
      self :: INOUT

      n_atom, i,n,n_c, k,m,n_k, p,q,n_p,indx :: INT
      group_list,comb,term,perm :: VEC{INT}@
      symbols :: VEC{STR}@
      shared  :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@
      kip :: REAL

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Here, each atom is a group
      .make_single_atom_groups

      ! Make no of combinations
      n   = .n_group
      n_c = 2**n - 1

      ! Make the combinations
      group_list = [ (i, i=1,n) ]
      .combinations.create(n)
      .pop_for_combination.create(n)
      .kip_for_combination.create(n)

      do k = 1,n

         ! No. of combinations
         n_k = nint(n.choose(k))

         ! Make the combinations of length k
         .combinations(k).element.create(k,n_k)
         group_list.make_combinations_of_length(k,.combinations(k)[:,:])

         stdout.show("k = ",k)
         stdout.text("combinations(k) :")
         stdout.put(.combinations(k)[:,:])

         ! Make array to store the populations
         .pop_for_combination(k).element.create(n_k)
         .kip_for_combination(k).element.create(n_k)

         ! Make comb_mat", the matrix of all combinations of the groups
         do m = 1,n_k

            ! Make the specific combination of atoms groups
            .atom_group.append_listed_to(.atom_ab,list=.combinations(k)[:,m])

            ! Store its population
            .pop_for_combination(k)[m] = .population(.atom_ab)

            ! Clean
            .atom_ab.destroy

         end

      end

      ! Clean up
      group_list.destroy

      ! Make all kernel interaction terms
      do k = n,1,-1

         ! No. of combinations
         n_k = nint(n.choose(k))

         ! Loop over all m-tuples
         do m = 1,n_k

            ! The index combination comb of interest
            comb = .combinations(k)[:,m]

            stdout.flush
            stdout.show("k = ",k)
            stdout.text("comb:")
            stdout.put(comb)

            ! k-body term P_comb
            kip = .pop_for_combination(k)[m] 

            stdout.show("kip contr       = ",kip)

            ! Loop over all n-body terms < k
            do p = 1,n-1

               n_p = nint(n.choose(p))

               do q = 1,n_p

                  ! Get the permutation term of comb
                  term = .combinations(p)[:,q]

            stdout.flush
            stdout.show("p-body terms, p = ",p)
            stdout.show("q-th term, q    = ",q)
            stdout.text("term:")
            stdout.put(term)

                  ! Apply permutation to comb
                  perm = comb(term)
            stdout.text("perm:")
            stdout.put(perm)

                  ! Get index j of particular (term) permutation of comb
                  indx = .combinations(p)[:,:].index_for_column(perm)
            stdout.show("Index of perm   = ",indx)
            stdout.show("kip contr       = ",.kip_for_combination(p)[indx])

                  ! Subtract off Delta E_term = Delta E_j
                  if (p==1) then
                     kip  = kip - .pop_for_combination(p)[indx] 
                  else
                     kip  = kip - .kip_for_combination(p)[indx] 
                  end

               end

            end

            ! Store the value
            .kip_for_combination(k)[m] = kip

         end

      end

      stop

      stdout.flush
      stdout.text("===============================")
      stdout.text("Roby combined group populations")
      stdout.text("===============================")

      stdout.flush
      stdout.show("No. of groups             =",.n_group)

      ! Loop over combinations of length k
      do k = 1,n

         ! Get concatenated atom labels for each combination
         n_k = int(n.choose(k))
         symbols.create(n_k)
         do m = 1,n_k
            symbols(m) = .atom.concatenated_tags(.combinations(k)[:,m])
         end

         ! Create table
         if (k==1) then
            table.create(2)
         else
            table.create(3)
         end

         table(1).set_heading("Atoms")
         table(2).set_heading("Population")
         if (k>1) then
         table(3).set_heading("Shared")
         table(3).set_subhead("Population")
         end

         ! Set table values
         table(1).set_values(symbols)
         table(2).set_values(.pop_for_combination(k)[:])
         if (k>1) then
            table(3).set_values(.kip_for_combination(k)[:])
         end

         ! Print table
         stdout.flush
         stdout.flush
         stdout.text("Populations for atom groups of length "//trim(k.to_str))
         stdout.flush
         table.put

         ! Clean
         table.destroy
         symbols.destroy
         
      end

   end

   make_pairwise_shared_pop ::: leaky, private
   ! Evaluate the Roby shared populations for all pairwise atom groups.
      self :: INOUT

   ENSURE(.n1.allocated,"no group populations")
   ENSURE(.n2.allocated,"no group pair populations")

      shared_population :: REAL
      n_atom,a,b,k,n_k :: INT

      n_atom = .atom.dim
      n_k = nint(n_atom.choose(2))
      .pairwise_shared_pop.create(n_k)

      .pairwise_shared_pop = ZERO
      k = ZERO

      do a = 1,n_atom
      do b = a+1,n_atom
         k = k + 1
         shared_population = .n1(a) + .n1(b) - .n2(a,b)
         .pairwise_shared_pop(k) = shared_population
      end
      end

   end

   make_triple_shared_pops ::: leaky, private
   ! Evaluate the triple Roby shared populations s_{abc} for groups of 3 atoms.
      self :: INOUT
 
   ENSURE(.n1.allocated,"no group populations")
   ENSURE(.n2.allocated,"no group pair populations")
   ENSURE(.n3.allocated,"no group triple populations")

       shared_population :: REAL
       n_atom,a,b,c,k,n_k :: INT
       
       n_atom = .atom.dim
       n_k = int(n_atom.choose(3))
       .triple_shared_pop.create(n_k)
 
       .triple_shared_pop = ZERO

       k = 0
       do a = 1  ,n_atom
       do b = a+1,n_atom
       do c = b+1,n_atom
          k = k + 1
          shared_population = .n1(a) + .n1(b) + .n1(c) &
             - .n2(a,b) - .n2(a,c) - .n2(b,c) + .n3(a,b,c)
          .triple_shared_pop(k) = shared_population
       end
       end
       end
 
   end

   make_summed_pair_pops ::: leaky, private
   ! Evaluate the SUMMED Roby shared populations for groups of 2 atoms.
   ! On return, .summed_n2(a) = \sum_{b} s_{ab}, where s_{ab} is the pairwise
   ! shared population for atoms a, b.
      self :: INOUT

   ENSURE(.n1.allocated,"no group populations")
   ENSURE(.n2.allocated,"no group pair populations")

      shared_population :: REAL
      n_group,a,b :: INT

      n_group = .n_group
      .summed_n2.create(n_group)

      .summed_n2 = ZERO

      do a = 1,n_group
      do b = a+1,n_group
         shared_population = .n1(a) + .n1(b) - .n2(a,b)
         .summed_n2(a)     = .summed_n2(a) + shared_population
         .summed_n2(b)     = .summed_n2(b) + shared_population
      end
      end

   end

!   make_summed_triple_pops ::: leaky, private
!   ! Evaluate the SUMMED Roby shared populations for groups of 3 atoms.
!   ! On return, .summed_n3(a) = \sum_{bc} s_{abc}, where s_{abc} is the triple
!   ! shared population for atoms a, b, and c.
!      self :: INOUT
!
!      shared_population :: REAL
!      n_group,a,b,c :: INT
!      
!      n_group = .n_group
!      .summed_n3.create(n_group)
!
!      .summed_n3 = ZERO
!
!      do a = 1  ,n_group
!      do b = a+1,n_group
!      do c = b+1,n_group
!         shared_population = .shared_population([a,b,c])
!         .summed_n3(a)     = .summed_n3(a) + shared_population
!         .summed_n3(b)     = .summed_n3(b) + shared_population
!         .summed_n3(c)     = .summed_n3(c) + shared_population
!      end
!      end
!      end
!
!   end

! ==========
! Bond index
! ==========

   gould_bond_index(c_ab,i_ab,pccp,pcca) result (bond_index) ::: leaky, private
   ! Calculates the Roby-Gould "bond_index", Pythagorean percentage
   ! covalent character "pcc", Araki percentage covalency "pcca", for
   ! atom groups ".atom_a" and ".atom_b".
      self :: INOUT
      c_ab,i_ab,pccp,pcca :: REAL, OUT
      bond_index :: REAL

   ENSURE(.theta_pop_C.allocated,"no covalent theta populations")
   ENSURE(.theta_pop_I.allocated,"no ionic theta populations")
   ENSURE(.pair.allocated,"no pair array")

      n0,i :: INT
      zero_cutoff :: REAL

      zero_cutoff = .zero_angle_cutoff.to_units("degree")

      n0 = .eigen_I.dim

      .theta_cov_index.create(n0)
      .theta_ion_index.create(n0)

      .theta_cov_index = ZERO
      .theta_ion_index = ZERO

      pccp = ZERO
      pcca = ZERO
      c_ab = ZERO
      i_ab = ZERO
      bond_index = ZERO

      do i = 1,n0

        if (.theta_angle(i)<       zero_cutoff) cycle
        if (.theta_angle(i)>90.0d0-zero_cutoff) cycle

        if (.eigen_I(i)<=.eigen_I(.pair(i))) cycle

        if (.pair(i)/=i) then
           .theta_cov_index(i) = HALF*(.theta_pop_C(i) - .theta_pop_C(.pair(i)))
           .theta_ion_index(i) = HALF*(.theta_pop_I(i) - .theta_pop_I(.pair(i)))
           c_ab = c_ab + .theta_cov_index(i)
           i_ab = i_ab + .theta_ion_index(i)
        else if (.eigen_I(i)>ZERO) then
           ! Store bond index, do not add into i_ab
           .theta_ion_index(i) =  HALF*(.theta_pop_I(i))
        else if (.eigen_I(i)<ZERO) then
           ! Store bond index, do not add into i_ab
           .theta_ion_index(i) = -HALF*(.theta_pop_I(i))
        end

      end

      bond_index = c_ab**2 + i_ab**2
      pccp       = 100 * (c_ab**2/bond_index)
      bond_index = sqrt(bond_index)
      pcca       = 100 * TWO*abs(asin(c_ab/bond_index))/PI

   end

! ====================
! Angle-space analysis
! ====================

   make_theta_info ::: leaky, private
   ! Calculates the Roby-Gould theta subspace information for atom groups
   ! ".atom_a" and ".atom_b", including theta subspace populations
      self :: INOUT

   ENSURE(.atom_a.associated,"no atom A group")
   ENSURE(.atom_b.associated,"no atom B group")
   ENSURE(.atom_ab.associated,"no atom AB group")

      I :: MAT{REAL}*
      theta_I :: MAT{REAL}*
      eigen_I :: VEC{REAL}*
      ind :: VEC{INT}*
      n_a,n_b,n_ab, n0 :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = n_a + n_b

      ! Make the ionic operator & ionic states
      theta_I.create(n_ab,n_ab)
      eigen_I.create(n_ab)

      ! Make I
      I.create(n_ab,n_ab)
      .make_ionic_operator(I)

      ! Diagonalize I
      .diagonalize_V_AB_operator(I,theta_I,eigen_I)

      if (.show_calcs) then
         stdout.text("I:")
         stdout.put(I)
         stdout.text("eigen_I:")
         stdout.put(eigen_I)
         stdout.text("theta_I:")
         stdout.put(theta_I)
      end

      I.destroy

      ! Prune zero eigenvalues
      n0 = eigen_I.no_of_abs_vals_larger_than(.zero_angle_cutoff)

      if (.show_calcs) then
         stdout.show("No of non-zero eigenvalues, n0 = ",n0)
      end

      ind.create(n0)
      ind = eigen_I.indices_of_abs_vals_larger_than(.zero_angle_cutoff)

      if (.show_calcs) then
         stdout.text("ind")
         stdout.put(ind)
      end

      .theta_I.create(n_ab,n0)
      .eigen_I.create(n0)

      .theta_I = theta_I(:,ind)
      .eigen_I = eigen_I(ind)

      ind.destroy
      eigen_I.destroy
      theta_I.destroy

      ! Find +/- ionic pairs
      .pair.create(n0)
      .eigen_I.find_non_unit_pairs(.pair,ROBY::match_pair,tol=TOL(8))

      ! Make theta angles
      .theta_angle.create(n0)
      .make_theta_angles

      if (.show_calcs) then
         stdout.text("theta_angle from I:")
         stdout.put(.theta_angle)
      end

      ! Clean up |ion> states
      .make_gould_ionic_orbitals

      ! Make |cov> pairs from |ion> pairs
      .theta_C.create(n_ab,n0)
      .eigen_C.create(n0)
      .make_cov_from_ion_orbitals

      if (.show_calcs) then
         stdout.text("pair array:")
         stdout.put(.pair)
         stdout.show("n_bf_a = ",.n_bf_a)
         stdout.show("n_bf_b = ",.n_bf_b)
         stdout.text("eigen_C:")
         stdout.put(.eigen_C)
         stdout.text("eigen_I:")
         stdout.put(.eigen_I)
         stdout.text("theta_C:")
         stdout.put(.theta_C)
         stdout.text("theta_I:")
         stdout.put(.theta_I)
      end

      ! Covalent theta populations
      .theta_pop_C.create(n0)
      .theta_pop_C_A.create(n0)
      .theta_pop_C_B.create(n0)
      .make_theta_populations(.theta_pop_C,.theta_pop_C_A,.theta_pop_C_B,.theta_C)

      ! Ionic theta populations
      .theta_pop_I.create(n0)
      .theta_pop_I_A.create(n0)
      .theta_pop_I_B.create(n0)
      .make_theta_populations(.theta_pop_I,.theta_pop_I_A,.theta_pop_I_B,.theta_I)

   end

   make_hyper_info ::: leaky, private
   ! Calculates the Roby-Gould theta subspace information for atom
   ! groups ".atom_a" and everything not in ".atom".
      self :: INOUT

   ENSURE(.atom_a.associated,"no atom A group")
   ENSURE(.atom_b.associated,"no atom B group")
   ENSURE(.atom_ab.associated,"no atom AB group")

      I :: MAT{REAL}*
      theta_I :: MAT{REAL}*
      eigen_I :: VEC{REAL}*
      ind :: VEC{INT}*
      n_bf, n0 :: INT

      n_bf = .n_bf

      ! Make the ionic operator & ionic states
      theta_I.create(n_bf,n_bf)
      eigen_I.create(n_bf)

      I.create(n_bf,n_bf)

      .make_hyper_operator(I)
      .diagonalize_full_operator(I,theta_I,eigen_I)

    ! stdout.text("I")
    ! stdout.put(I)

      I.destroy

    ! stdout.text("eigen_I")
    ! stdout.put(eigen_I)

      ! Prune zero eigenvalues
      n0 = eigen_I.no_of_abs_vals_larger_than(TOL(8))

    ! stdout.show("n0 = ",n0)

      ind.create(n0)
      ind = eigen_I.indices_of_abs_vals_larger_than(TOL(8))

      .theta_I.create(n_bf,n0)
      .eigen_I.create(n0)

      .theta_I = theta_I(:,ind)
      .eigen_I = eigen_I(ind)

      ind.destroy
      eigen_I.destroy
      theta_I.destroy

    ! stdout.text(".theta_I")
    ! stdout.put(.theta_I)

    ! stdout.text(".eigen_I")
    ! stdout.put(.eigen_I)

      ! Find +/- ionic pairs
      .pair.create(n0)
      .eigen_I.find_non_unit_pairs(.pair,ROBY::match_pair,tol=TOL(8))

    ! stdout.text("pair")
    ! stdout.put(.pair)

      ! Make theta angles
      .theta_angle.create(n0)
      .make_theta_angles

    ! stdout.text("theta_angle")
    ! stdout.put(.theta_angle)

      ! Clean up |ion> states
      .make_gould_ionic_orbitals

    ! stdout.text(".theta_I")
    ! stdout.put(.theta_I)
    ! stdout.text(".eigen_I")
    ! stdout.put(.eigen_I)

      ! Make |cov> pairs from |ion> pairs
      .theta_C.create(n_bf,n0)
      .eigen_C.create(n0)
      .make_cov_from_ion_orbitals

    ! stdout.text(".theta_C")
    ! stdout.put(.theta_C)
    ! stdout.text(".eigen_C")
    ! stdout.put(.eigen_C)

      ! Covalent theta populations
      .theta_pop_C.create(n0)
      .theta_pop_C_A.create(n0)
      .theta_pop_C_B.create(n0)
      .make_theta_populations(.theta_pop_C,.theta_pop_C_A,.theta_pop_C_B,.theta_C)

      ! Ionic theta populations
      .theta_pop_I.create(n0)
      .theta_pop_I_A.create(n0)
      .theta_pop_I_B.create(n0)
      .make_theta_populations(.theta_pop_I,.theta_pop_I_A,.theta_pop_I_B,.theta_I)

   end

! Low level helper routines

   match_pair(arg1,arg2) result (res) ::: selfless, private
   ! Function which returns zero if "arg1" and "arg2" are opposite.
   ! Used for matching pairs purposes.
      arg1,arg2 :: REAL, IN
      res :: REAL

      res = abs(arg1 + arg2)

   end

   make_theta_populations(pop,pop_a,pop_b,theta) ::: private
   ! Make "pop", an array of "theta" populations for a pair of Roby
   ! atoms defined by indices in ".atom_a" and ".atom_b". "theta"
   ! itself is a matrix whose columns are coefficients on V_AB.
      self :: INOUT
      pop :: VEC{REAL}, OUT
      pop_a,pop_b :: VEC{REAL}, OUT
      theta :: MAT{REAL}, IN

   ENSURE(.atom_ab.associated,"No roby atom group AB")
   ENSURE(pop.dim==theta.dim2,"wrong size, pop")

      i :: INT

      do i = 1,theta.dim2
         pop(i)   =    .population(        .atom_ab,ANO=theta(:,i:i))
         pop_a(i) = .subpopulation(.atom_a,.atom_ab,ANO=theta(:,i:i))
         pop_b(i) = .subpopulation(.atom_b,.atom_ab,ANO=theta(:,i:i))
      end

   end

   make_theta_angles ::: private
   ! Make the ".theta_angle" array from the Roby eigenvalues
   ! ".eigen_I". Angles are in degrees.
   ! WARNING: some crazy mistake here !!!! <<<<<<
      self :: INOUT

   ENSURE(.eigen_I.allocated,"No roby eigenvalues")
   ENSURE(.theta_angle.allocated,"No theta_angle array")

      i :: INT
      value :: REAL

      do i = 1,.eigen_I.dim

         value = .eigen_I(i)
         value = value.arcsin
         value = value.to_units("degree")

         .theta_angle(i) = value

      end

   end

   make_gould_ionic_orbitals ::: private
   ! Generate the gould ionic orbitals ".theta_I" in such a way that
   ! the negative eigenvector of each pair is generated explicitly
   ! from the positive eigenvector by constructing the |a> and |b>
   ! parts using projectors P_A and P_B. ".eigen_I" are the
   ! eigenvalues corresponding to ".theta_I". ".pair" is defined so
   ! that the i-th eigenvector .theta_I(:,i) with +ve value is paired
   ! with theta_I(:,pair(i)) with negative eigenvalue. The spaces V_A,
   ! V_B and V_AB are defined by ".atom_a", ".atom_b", and ".atom_ab".
   ! This routine is necessary in cases where there are degeneracies.
      self :: INOUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")
   ENSURE(.atom.associated,"No atom information")
   ENSURE(.theta_I.allocated,"No theta_I array")
   ENSURE(.theta_I.dim1==.n_bf_ab,"wrong shape, theta_I")
   ENSURE(.eigen_I.allocated,"No eval_I array")
   ENSURE(.eigen_I.dim==.theta_I.dim2,"eigen_I & theta_I, inconsistent")
   ENSURE(.pair.allocated,"No pair array")
   ENSURE(.pair.dim==.theta_I.dim2,"pair & theta_I, inconsistent")

      PAS,PBS,PA,PB :: MAT{REAL}*
      A,B :: VEC{REAL}*
      n_a,n_b,n_ab,i :: INT
      fp,fm,fa,fb,s,c,s2 :: REAL

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      PAS.create(n_a,n_ab)
      PBS.create(n_b,n_ab)
      A.create(n_a)
      B.create(n_b)

      PA.create(n_a,n_a)
      PB.create(n_b,n_b)

      .make_projection_matrix(PA,.atom_a)
      .make_projection_matrix(PB,.atom_b)

      .right_overlap_transform(PA,PAS,.atom_a,.atom_ab)
      .right_overlap_transform(PB,PBS,.atom_b,.atom_ab)

      PB.destroy
      PA.destroy

      do i = 1,.eigen_I.dim

         if (.pair(i)<1) cycle
         if (.pair(i)==i) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         ! Bonding state (.eigen_I +ve)
         s  = .eigen_I(i)
         s2 = s*s
         if (s2.equals(ONE,TOL(8))) then; c = ZERO
         else;                            c = sqrt(ONE - s2)
         end

         ! Find |a> and |b> from +ve bonding state
         fm = sqrt(ONE - c)/s
         fp = sqrt(ONE + c)/s
         fa = HALF*(  (fm+fp)+c*(fm-fp))
         fb = HALF*(c*(fm+fp)+  (fm-fp))
         A  = ZERO
         B  = ZERO
         if (NOT fa.equals(ONE,TOL(8))) then
         A.to_product_of(PAS,.theta_I(:,i)); A = A/fa
         end
         if (NOT fb.equals(ONE,TOL(8))) then
         B.to_product_of(PBS,.theta_I(:,i)); B = B/fb
         end

         ! Construct -ve antibonding state in .pair(i)
         fa = HALF*(fm-fp)
         fb = HALF*(fm+fp)
         .theta_I(    1:n_a ,.pair(i)) = fa*A
         .theta_I(n_a+1:n_ab,.pair(i)) = fb*B

      end

      ! Clean
      B.destroy
      A.destroy
      PBS.destroy
      PAS.destroy

   end

   make_cov_from_ion_orbitals ::: private
   ! Make ".theta_C" and ".eigen_C" from ".theta_I" and ".eigen_I".
      self :: INOUT

   ENSURE(.eigen_I.allocated,"no eval_I array")
   ENSURE(.eigen_C.allocated,"no eigen_C array")
   ENSURE(.eigen_C.dim==.eigen_I.dim,"inconsistent eigen_C & eigen_I arrays")
   ENSURE(.theta_I.allocated,"no theta_I array")
   ENSURE(.theta_I.dim1==.n_bf_ab,"wrong dim1, theta_I")
   ENSURE(.theta_I.dim2==.eigen_C.dim,"wrong shape, theta_I")
   ENSURE(.theta_C.allocated,"no theta_C array")
   ENSURE(.theta_C.dim1==.n_bf_ab,"wrong dim1, theta_C")
   ENSURE(.theta_C.dim2==.eigen_C.dim,"wrong shape, theta_I")
   ENSURE(.pair.allocated,"no pair array")
   ENSURE(.pair.dim==.eigen_C.dim,"wrong shape, pair")

      fac,c,s :: REAL
      i,j :: INT
   !  eval :: MAT{REAL}(1,1)
   !  RR,SS :: MAT{REAL}*

   !  n_ab = .n_bf_ab

   !  RR.create(n_ab,n_ab)
   !  SS.create(n_ab,n_ab)

   !  stdout.text("1")
   !  .make_shared_operator(SS)
   !  stdout.text("2")
   !  .overlap_transform(SS,RR,.atom_ab,.atom_ab)
   !  stdout.text("3")

   !  SS.destroy

      .theta_C = ZERO
      .eigen_C = ZERO

      do i = 1,.eigen_I.dim

         if (.pair(i)<1) cycle
         if (.pair(i)==i) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         ! Index j of -ve antibonding orbital
         j = .pair(i)

         ! pi/4 rotation: eqn (64) in Gould et al (2008)
         fac = ONE/sqrt(TWO)
         .theta_C(:,i) = fac*(.theta_I(:,i)+.theta_I(:,j)) ! C+
         .theta_C(:,j) = fac*(.theta_I(:,i)-.theta_I(:,j)) ! C-

         ! Diagonalize I
       ! RR.change_basis_to(eval,.theta_C(:,i:i)); .eigen_C(i) = eval(1,1)
       ! RR.change_basis_to(eval,.theta_C(:,j:j)); .eigen_C(j) = eval(1,1)

         ! Set C eigenvalues
         s = .eigen_I(i)
         c = sqrt(ONE - s*s)
         .eigen_C(i) =  c
         .eigen_C(j) = -c

      end

    ! RR.destroy

   end

   group_nuclear_charges result (res) ::: pure
   ! Sum of the nuclear charges in each group.
      self :: IN
      res :: VEC{REAL}(.atom_group.dim)

      g :: INT

      do g = 1,.atom_group.dim
         res(g) = .atom(.atom_group(g).element).sum_of_nuclear_charges
      end

   end

   make_theta_E1_Krogel_info ::: leaky, private
   ! Calculates the Roby-Gould theta subspace information for atom
   ! groups ".atom_a" and ".atom_b", including theta subspace
   ! energies and subenergies via the Krogel approach.
      self :: INOUT

   ENSURE(.atom_a.associated,"no atom A group")
   ENSURE(.atom_b.associated,"no atom B group")
   ENSURE(.atom_ab.associated,"no atom AB group")

      I :: MAT{REAL}*
      theta_I :: MAT{REAL}*
      eigen_I :: VEC{REAL}*
      ind :: VEC{INT}*
      n_a,n_b,n_ab, n0 :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = n_a + n_b

      ! Make the ionic operator & ionic states
      theta_I.create(n_ab,n_ab)
      eigen_I.create(n_ab)

      ! Make I
      I.create(n_ab,n_ab)
      .make_ionic_operator(I)

      ! Diagonalize I
      .diagonalize_V_AB_operator(I,theta_I,eigen_I)

      if (.show_calcs) then
         stdout.text("I:")
         stdout.put(I)
         stdout.text("eigen_I:")
         stdout.put(eigen_I)
         stdout.text("theta_I:")
         stdout.put(theta_I)
      end

      I.destroy

      ! Prune zero eigenvalues
      n0 = eigen_I.no_of_abs_vals_larger_than(.zero_angle_cutoff)

      if (.show_calcs) then
         stdout.show("No of non-zero eigenvalues, n0 = ",n0)
      end

      ind.create(n0)
      ind = eigen_I.indices_of_abs_vals_larger_than(.zero_angle_cutoff)

      if (.show_calcs) then
         stdout.text("ind")
         stdout.put(ind)
      end

      .theta_I.create(n_ab,n0)
      .eigen_I.create(n0)

      .theta_I = theta_I(:,ind)
      .eigen_I = eigen_I(ind)

      ind.destroy
      eigen_I.destroy
      theta_I.destroy

      ! Find +/- ionic pairs
      .pair.create(n0)
      .eigen_I.find_non_unit_pairs(.pair,ROBY::match_pair,tol=TOL(8))

      ! Make theta angles
      .theta_angle.create(n0)
      .make_theta_angles

      if (.show_calcs) then
         stdout.text("theta_angle from I:")
         stdout.put(.theta_angle)
      end

      ! Clean up |ion> states
      .make_gould_ionic_orbitals

      ! Make |cov> pairs from |ion> pairs
      .theta_C.create(n_ab,n0)
      .eigen_C.create(n0)
      .make_cov_from_ion_orbitals

      if (.show_calcs) then
         stdout.text("pair array:")
         stdout.put(.pair)
         stdout.show("n_bf_a = ",.n_bf_a)
         stdout.show("n_bf_b = ",.n_bf_b)
         stdout.text("eigen_C:")
         stdout.put(.eigen_C)
         stdout.text("eigen_I:")
         stdout.put(.eigen_I)
         stdout.text("theta_C:")
         stdout.put(.theta_C)
         stdout.text("theta_I:")
         stdout.put(.theta_I)
      end

      ! Covalent theta populations
      .theta_E_C.create(n0)
      .theta_E_C_A.create(n0)
      .theta_E_C_B.create(n0)
      .make_theta_E1_Krogel_Es(.theta_E_C,.theta_E_C_A,.theta_E_C_B,.theta_C)

      ! Ionic theta populations
      .theta_E_I.create(n0)
      .theta_E_I_A.create(n0)
      .theta_E_I_B.create(n0)
      .make_theta_E1_Krogel_Es(.theta_E_I,.theta_E_I_A,.theta_E_I_B,.theta_I)

   end

   make_theta_E1_Krogel_Es(E,Ea,Eb,theta) ::: private
   ! Make "pop", an array of "theta" populations for a pair of Roby
   ! atoms defined by indices in ".atom_a" and ".atom_b". "theta"
   ! itself is a matrix whose columns are orbital coefficients on
   ! V_AB corresponding to an ionic or covalent or some other state.
      self :: INOUT
      E,Ea,Eb :: VEC{REAL}, OUT
      theta :: MAT{REAL}, IN

   ENSURE(.atom_ab.associated,"No roby atom group AB")
   ENSURE(.E_matrix.allocated,"No Krogel E matrix")
   ENSURE(E.dim==theta.dim2,"wrong size, pop")

      i :: INT

      do i = 1,theta.dim2
          E(i)  =    .population(       .atom_ab,ANO=theta(:,i:i),rho=.E_matrix)
         Ea(i) = .subpopulation(.atom_a,.atom_ab,ANO=theta(:,i:i),rho=.E_matrix)
         Eb(i) = .subpopulation(.atom_b,.atom_ab,ANO=theta(:,i:i),rho=.E_matrix)
      end

   end

! =================
! Energy bond index
! =================

   atom_E1_analysis ::: leaky
   ! Do a E^1_Krogel energy-bond analysis.
   ! Only works for RHF case for now.
      self :: INOUT

   ENSURE(.core_matrix.allocated,"no core_matrix!")
   ENSURE(.core_matrix.restricted.allocated,"no restricted core_matrix!")
   ENSURE(.fock_matrix.allocated,"no fock_matrix!")
   ENSURE(.fock_matrix.restricted.allocated,"no restricted fock_matrix!")

      i,n_atom :: INT
      n_group,a,b,n_bond_do_H,n_bond_no_H :: INT
      ind,cov,ion,pccp,pcca :: REAL
       

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Make E_matrix, E_scf, E_atomic, E_NA
      .make_E1_matrix 

      ! Make weights
      .make_E1_weights

      ! Each atom is a Roby subspace
      .make_single_atom_groups
      n_group = .n_group

      ! Get group energies
      .make_E1_A  ! ... and E1_DE
      .make_E1_AB ! ... and E2_DE

      ! Clean
      .destroy_bond_info
      .E1_cov.create(n_group,n_group)
      .E1_ion.create(n_group,n_group)
      .E1_bond.create(n_group,n_group)

      ! File name & redirect
      ! Get Roby subspace analysis
      do a = 1,.n_group
      do b = a+1,.n_group

         if (.skip_pair(a,b)) cycle

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)

         ! Make theta-subspace energies
         .destroy_theta_info
         .make_theta_E1_Krogel_info

         if (.output_theta_info) then
            .put_theta_info
            .put_theta_E_info
         end

         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

      ! Output
      .put_basics
      .put_E_As
    ! .put_E_ABs
      .put_E_ABs_Li

   end

   make_E1_matrix ::: leaky
   ! Make the E^1_matrix & E_NA
      self :: INOUT

      all_atoms :: VEC{INT}@
      a,n_bf :: INT

      select case (.E1_method)
      case ("exact "); .make_E1_exact_matrix
      case ("krogel"); .make_E1_Krogel_matrix
      end

      ! Non-atomic energy, E_{na}
      all_atoms = [ (a, a=1,.atom.dim) ]
      .E_atomic = .population(all_atoms,rho=.E_matrix)
      .E_NA     = .E_scf - .E_atomic

      ! Clean
      all_atoms.destroy

   end

   make_E1_exact_matrix ::: leaky
   ! Make the E^1_exact matrix which substitutes for the density
   ! matrix .rho in the RGBI population code.
   ! Only works for UHF/RHF cases for now.
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom_group")
   ENSURE(.core_matrix.allocated,"no core_matrix!")
   ENSURE(.core_matrix.restricted.allocated,"no restricted core_matrix!")
   ENSURE(.fock_matrix.allocated,"no fock_matrix!")
   ENSURE(.fock_matrix.restricted.allocated,"no restricted fock_matrix!")

      fac :: REAL

      ! Make Krogel E_matrix without S^-1 prefactor
      ! Just to get SCF energy
      .E_matrix = .fock_matrix
      .E_matrix.plus(.core_matrix)
      .E_matrix.scale_by(HALF)
      .E_scf = .E_matrix.expectation(.density_matrix)
       
      ! Now make exact E_matrix without S^-1 prefactor
      ! NOTE: no of electrons is for uncharghed
      fac = .E_scf/.atom.no_of_electrons
      .E_matrix = .density_matrix.times(fac)

   end

   make_E1_Krogel_matrix ::: leaky
   ! Make the E^1_Krogel matrix which substitutes for the density
   ! matrix .rho in the RGBI population code.
   ! Only works for UHF/RHF cases for now.
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom_group")
   ENSURE(.core_matrix.allocated,"no core_matrix!")
   ENSURE(.core_matrix.restricted.allocated,"no restricted core_matrix!")
   ENSURE(.fock_matrix.allocated,"no fock_matrix!")
   ENSURE(.fock_matrix.restricted.allocated,"no restricted fock_matrix!")

      tmp :: OPMATRIX@
      Sm1 :: MAT{REAL}@
      all_atoms :: VEC{INT}@
      a,n_bf :: INT
       
      ! Make E_matrix without S^-1 prefactor
      .E_matrix = .fock_matrix
      .E_matrix.plus(.core_matrix)
      .E_matrix.scale_by(HALF)

      ! SCF energy
      .E_scf = .E_matrix.expectation(.density_matrix)

      ! Make S^-1 
      n_bf = .core_matrix.n_bf
      Sm1.create(n_bf,n_bf) ! NOTE: RHF/UHF cases here only
      Sm1.to_pseudo_inverse_of(.overlap_matrix,TOL(5))

      ! Do S^-1 . 1/2 [ h + F ] . D
      tmp = .E_matrix
      tmp.to_product_of(Sm1,.E_matrix)
      .E_matrix.to_product_of(X=tmp,Y=.density_matrix)

      ! Clean
      all_atoms.destroy
      tmp.destroy
      Sm1.destroy

   end

   make_E1_weights ::: leaky
   ! Make the E^1_matrix .
      self :: INOUT

      select case (.NA_weight_method)
      case ("e_a^0"); .make_NA_EA0_weights
      case ("z_a  "); .make_NA_ZA_weights
      end

      select case (.DE_weight_method)
      case ("v_nn "); .make_DE_V_nn_weights
      end

   end

   make_NA_EA0_weights ::: leaky 
   ! Partition the E^NA term according to E_A^0 atom energies
      self :: INOUT

   ENSURE(.n_group==.atom.dim,"No. of groups is not equal to no. of atoms")

      base :: REAL

      base = sum(.atom(:).energy)
      .w_NA = .atom(:).energy/base

   end

   make_NA_ZA_weights ::: leaky 
   ! Partition the E^NA term according to Z_A^0 atom energies
      self :: INOUT

   ENSURE(.n_group==.atom.dim,"No. of groups is not equal to no. of atoms")

      base :: REAL

      base = sum(.atom(:).nuclear_charge)
      .w_NA = .atom(:).nuclear_charge/base

   end

   make_DE_V_nn_weights ::: leaky 
   ! Partition the E^de term according to V_nn(A,B) nuclear charges.
      self :: INOUT

   ENSURE(.n_group==.atom.dim,"No. of groups is not equal to no. of atoms")

      norm, V_ab :: REAL
      n,a,b :: INT

      n = .atom.dim

      .w_DE.destroy
      .w_DE.create(n,n)

      do a = 1,n
         norm = ONE/.atom(:).nuclear_repulsion_for_atom(a)
         do b = 1,n
            V_ab = .atom(:).nuclear_repulsion_for_atoms(a,b)
            .w_DE(a,b) = V_ab * norm
         end
      end

   end

   make_E1_A ::: leaky, private
   ! Make the atom energies for the defined atom groups.
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.E_matrix.allocated,"no density matrix")

      a :: INT

      .n1.destroy
      .n1.create(.n_group)

      .E1.destroy
      .E1.create(.n_group)

      .E1_DE.destroy
      .E1_DE.create(.n_group)

      do a = 1,.n_group

         .atom_a => .atom_group(a).element

         .n1(a) =  .population(.atom_a)
         .E1(a) =  .population(.atom_a,rho=.E_matrix)

         .E1_DE(a) = .E1(a) - .atom(a).energy + .w_NA(a)*.E_NA

         nullify(.atom_a)

      end

   end

   make_E1_AB ::: leaky, private
   ! Make the atom pair energies for the defined atom groups.
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.E_matrix.allocated,"no density matrix")

      n_group,a,b :: INT
      n2 :: REAL
      E2 :: REAL
      val :: REAL

      n_group = .n_group

      .n2.destroy
      .n2.create(n_group,n_group)
      .n2 = ZERO

      .E2.destroy
      .E2.create(n_group,n_group)
      .E2 = ZERO

      .E2_DE.destroy
      .E2_DE.create(n_group,n_group)
      .E2_DE = ZERO

      do a = 1,n_group
      do b = a+1,n_group

         if (.skip_pair(a,b)) cycle

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! Populations n_AB
         val = .population(.atom_ab)
         .n2(a,b) = val
         .n2(b,a) = val

          ! Raw pair energies E_AB
          val = .population(.atom_ab,rho=.E_matrix)
         .E2(a,b) = val
         .E2(b,a) = val

          ! Partitioned E1_A(B)
         .E2_DE(a,b) = .w_DE(a,b) * .E1_DE(a)
         .E2_DE(b,a) = .w_DE(b,a) * .E1_DE(b)

         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

   end


   atom_E1_exact_analysis ::: leaky
   ! Do a Roby energy-bond and Gould charge analysis.
   ! Only works for RHF case for now.
      self :: INOUT

   ENSURE(.core_matrix.allocated,"no core_matrix!")
   ENSURE(.core_matrix.restricted.allocated,"no restricted core_matrix!")
   ENSURE(.fock_matrix.allocated,"no fock_matrix!")
   ENSURE(.fock_matrix.restricted.allocated,"no restricted fock_matrix!")

      X,Y,Sm1 :: MAT{REAL}*
      n_bf :: INT
      i,n_atom :: INT
      n_group,a,b,n_bond_do_H,n_bond_no_H :: INT
      ind,cov,ion,pccp,pcca :: REAL
       

      ! Make atom list if it doesn't exist
      if (.atom_list.disassociated) then
         n_atom = .atom.dim
         .atom_list.create(n_atom)
         .atom_list = [ (i, i=1,n_atom) ]
      end

      ! Each atom is a Roby subspace
      .make_single_atom_groups

      ! Make unprojected E_matrix
      .E_matrix = .fock_matrix
      .E_matrix.plus(.core_matrix)
      .E_matrix.scale_by(HALF)

      ! Print out SCF energy
      .E_scf = .E_matrix.restricted.trace_product_with(.density_matrix.restricted)
      stdout.show("E_scf = ",.E_scf)

      ! Each atom is a Roby subspace
      .make_single_atom_groups
      n_group = .n_group

      ! Get group energies
      .make_E_exact_A
      .make_E_exact_AB

      ! Clean
      .destroy_bond_info
      .bond_index.create(n_group,n_group)
      .cov_index.create(n_group,n_group)
      .ion_index.create(n_group,n_group)
      .percent_covalency_P.create(n_group,n_group)
      .percent_covalency_A.create(n_group,n_group)

      ! File name & redirect
      ! Get Roby subspace analysis
      do a = 1,.n_group
      do b = a+1,.n_group

         if (.skip_pair(a,b)) cycle

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)

         .destroy_theta_info
       ! .make_theta_energy_info
         .make_theta_info
         
         ind = .gould_bond_index(cov,ion,pccp,pcca)

         .bond_index(a,b)          =  ind
         .cov_index(a,b)           =  cov
         .ion_index(a,b)           =  ion
         .percent_covalency_P(a,b) =  pccp
         .percent_covalency_A(a,b) =  pcca

         .bond_index(b,a)          =  ind
         .cov_index(b,a)           =  cov
         .ion_index(b,a)           = -ion
         .percent_covalency_P(b,a) =  pccp
         .percent_covalency_A(b,a) =  pcca

         if (.output_theta_info) then
            .put_theta_info
            .put_theta_BI_info
         end

         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

      ! Output
      .put_basics
      .put_E_As
      .put_E_ABs

   end

   make_E_exact_A ::: leaky, private
   ! Make the Roby energies for the defined atom groups
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.E_matrix.allocated,"no density matrix")

      a :: INT
      fac :: REAL

      fac = .E_scf/.atom.no_of_electrons

      .E1.destroy
      .E1.create(.n_group)

      .n1.destroy
      .n1.create(.n_group)

      do a = 1,.n_group

         .atom_a => .atom_group(a).element

         .n1(a) =  .population(.atom_a)
         .E1(a) =  .n1(a) * fac

         nullify(.atom_a)

      end

   end

   make_E_exact_AB ::: leaky, private
   ! Make the pair Roby energies
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom groups")
   ENSURE(.density_matrix.allocated,"no density matrix")
   ENSURE(.E_matrix.allocated,"no density matrix")

      n_group,a,b :: INT
      n2 :: REAL
      E2 :: REAL
      fac :: REAL
      pop :: REAL

      fac = .E_scf/.atom.no_of_electrons
      n_group = .n_group

      .n2.destroy
      .n2.create(n_group,n_group)
      .n2 = ZERO

      .E2.destroy
      .E2.create(n_group,n_group)
      .E2 = ZERO

      do a = 1,n_group
      do b = a+1,n_group

         if (.skip_pair(a,b)) cycle

         .atom_a => .atom_group(a).element
         .atom_b => .atom_group(b).element

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .atom_ab.destroy
         .atom_ab.append(.atom_a,.atom_b)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         pop = .population(.atom_ab)
        
         .n2(a,b) = pop
         .n2(b,a) = pop 

         .E2(a,b) = pop * fac
         .E2(b,a) = pop * fac

         nullify(.atom_a)
         nullify(.atom_b)

      end
      end

   end
   
   put_E_As
   ! Put to stdout the only Roby atom energies
      self :: IN

   ENSURE(.E1.allocated,"no atom energies exist")
   ENSURE(.atom.associated,"no atom data")

      table :: VEC{TABLE_COLUMN}@
      symbols :: VEC{STR}@
      charge :: VEC{REAL}@
      labels :: VEC{INT}@
      n_e,f :: INT

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      stdout.flush
      stdout.text("=====================")
      stdout.text("Roby atom energies")
      stdout.text("=====================")

      n_e = .atom.no_of_electrons

      stdout.flush
      stdout.show("No. of electrons in mol =",n_e)
      stdout.show("No. of electrons in P_M =",.n_all)
      stdout.show("No. of hypervalent e's  =",n_e-.n_all)
      stdout.flush

      ! Create table
      table.create(3)

      ! Set the table headings
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      if (.is_homoleptic) then
         symbols.create(.n_group)
         labels.create(.n_group)
         f = 1
         labels.to_sequence(f,.n_group)
         symbols = labels.to_str
         labels.destroy
      else
         symbols = .unique_tags
      end
      table(1).set_values(symbols)

      table(2).set_heading("Projected energies")
      table(2).set_subhead("of atoms")
      table(2).set_values(.E1)

      charge = -.n1 + .group_nuclear_charges
      table(3).set_heading("Charge")
      table(3).set_values(charge)

      ! Put table
      table.put(label_rows=FALSE)

      ! Clean
      table.clear_columns
      charge.destroy
      symbols.destroy

      ! Unsave
      stdout.unsave

   end

   put_E_ABs
   ! Output pair and shared bond exact bond energies
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,n_A,n_B,nAB,sAB,E_A,E_B,EAB :: VEC{REAL}@
      has_unique_labels :: BIN

      ! Any atoms to do?
      if (.atom.dim<2) return

      ! Any bonded atoms to do?
      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(4)

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("==============================================")
      stdout.text("Roby-Gould bond energies: VDW interactions only")
      stdout.text("==============================================")
      else
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond energies")
      stdout.text("=======================")
      end

      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Indices appear only for VDW bonded atom pairs and")
      stdout.text("NOT normally bonded by CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD)")
      stdout.text("AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds            =",no_of_bonds)
      end
      stdout.flush

      stdout.show("E_scf                   =",.E_scf)
      stdout.show("E_non_atomic            =",.E_NA)
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(11)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_column_spacing(0)
      table( 2).set_heading("--")
      table( 2).set_width(2)

      table( 3).set_heading("B")
      table( 3).set_width(table(1).width)
      table( 3).set_left_justify(TRUE)

      table( 4).set_heading("A")
      table( 4).set_width_from(.atom(:).tag)

      table( 5).set_column_spacing(0)
      table( 5).set_heading("--")
      table( 5).set_width(2)

      table( 6).set_heading("B")
      table( 6).set_width(table(4).width)
      table( 6).set_left_justify(TRUE)

      table( 7).set_heading("R(A--B)")
      table( 7).set_subheading("/Angs.")

      table( 8).set_heading("E_A")
      table( 9).set_heading("E_B")
      table(10).set_heading("E_AB")
      table(11).set_heading("   E_AB")
      table(11).set_subhead("(shared)")

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom( Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         E_A.create(n_bonds)
         E_B.create(n_bonds)
         EAB.create(n_bonds)
         sAB.create(n_bonds)

         E_A = .E1(pair(:,1))
         E_B = .E1(pair(:,2))
         forall (i=1:n_bonds)
         EAB(i) = .E2(pair(i,1),pair(i,2))
         sAB(i) = E_A(i) + E_B(i) - EAB(i)
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(labels(:,1))
         table( 5).set_values(dash)
         table( 6).set_values(labels(:,2))
         table( 7).set_values(dist)
         table( 8).set_values(E_A)
         table( 9).set_values(E_B)
         table(10).set_values(EAB)
         table(11).set_values(sAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         sAB.destroy
         E_A.destroy
         E_B.destroy
         EAB.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

      ! Unsave settings
      stdout.unsave

   end   

   put_E_ABs_Li
   ! Output pair and Li pairwise energy decopisition.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,n_A,n_B,nAB,sAB,EA,EB,EdA,EdB,EAB,V_nn,tAB :: VEC{REAL}@
      has_unique_labels :: BIN

      ! Any atoms to do?
      if (.atom.dim<2) return

      ! Any bonded atoms to do?
      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Title
      stdout.flush
      stdout.text("===========================================")
      stdout.text("Roby-Gould bond energies: W.Li v1 partition")
      stdout.text("===========================================")

      stdout.flush
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD)")
      stdout.text("AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)

      stdout.flush
      stdout.show("E_scf                   =",.E_scf)
      stdout.show("E_non_atomic            =",.E_NA)
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_column_spacing(0)
      table( 2).set_heading("--")
      table( 2).set_width(2)

      table( 3).set_heading("B")
      table( 3).set_width(table(1).width)
      table( 3).set_left_justify(TRUE)

      table( 4).set_heading("A")
      table( 4).set_width_from(.atom(:).tag)

      table( 5).set_column_spacing(0)
      table( 5).set_heading("--")
      table( 5).set_width(2)

      table( 6).set_heading("B")
      table( 6).set_width(table(4).width)
      table( 6).set_left_justify(TRUE)

      table( 7).set_heading(" R(A--B)")
      table( 7).set_subhead("  /Angs.")

      table( 8).set_heading("      E_A")
      table( 9).set_heading("E^de_A(B)")
      table(10).set_heading("      E_B")
      table(11).set_heading("E^de_B(A)")
      table(12).set_heading("     E_AB")
      table(13).set_heading("   E^s_AB")
      table(14).set_heading("  V^NN_AB")
      table(15).set_heading("     B.E.")

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .atom.get_bonded_with_v_nn(pair,dist,V_nn,Z_list,k1,k2,.bond_range_factor)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         EA.create(n_bonds)
         EB.create(n_bonds)
         EAB.create(n_bonds)
         sAB.create(n_bonds)
         EdA.create(n_bonds)
         EdB.create(n_bonds)
         tAB.create(n_bonds)
         forall (i=1:n_bonds)
         EA(i)  = .E1(pair(i,1)) 
         EB(i)  = .E1(pair(i,2)) 
         EAB(i) = .E2(pair(i,1),pair(i,2))
         sAB(i) = EA(i) + EB(i) - EAB(i)
         EdA(i) = .E2_DE(pair(i,1),pair(i,2)) 
         EdB(i) = .E2_DE(pair(i,2),pair(i,1)) 
         tAB(i) = -sAB(i) + V_nn(i) + EdA(i) + EdB(i)
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(labels(:,1))
         table( 5).set_values(dash)
         table( 6).set_values(labels(:,2))
         table( 7).set_values(dist)
         table( 8).set_values(EA)
         table( 9).set_values(EdA)
         table(10).set_values(EB)
         table(11).set_values(EdB)
         table(12).set_values(EAB)
         table(13).set_values(sAB)
         table(14).set_values(V_nn)
         table(15).set_values(tAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         tAB.destroy
         EdB.destroy
         EdA.destroy
         sAB.destroy
         EAB.destroy
         EB.destroy
         EA.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         V_nn.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

   end   

   put_theta_E_info
   ! Output theta-space bond index information
      self :: IN

      n,i,j,k,p :: INT
      par :: VEC{STR}@
      ind :: VEC{INT}@
      ect_p,ect_m :: VEC{REAL}@
      eit_p,eit_m :: VEC{REAL}@
    ! eca_p,eca_m,ecb_p,ecb_m :: VEC{REAL}@
    ! eia_p,eia_m,eib_p,eib_m :: VEC{REAL}@
      ang :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@

      ! Columns
      n = .eigen_I.dim
      par.create(n)
      ang.create(n)
      ect_p.create(n)
      ect_m.create(n)
      eit_p.create(n)
      eit_m.create(n)

      ! Sort decreasing covalent index
      ind.create(n)
      .theta_E_C.quick_sort(ind)

      ! Set column data
      j = 0
      do k = 1,n

         ! Reordered index and its pair
         i = ind(k)
         p = .pair(i)

         if (p<1) cycle
         if (.eigen_I(i)<.eigen_I(p)) cycle

         j = j + 1

         if (p/=i) then
               par(j) = "("//i.to_str.trim//","//p.to_str.trim//")"
               eit_p(j) = .theta_E_I(i)
               eit_m(j) = .theta_E_I(p)
         else
               par(j) = "("//i.to_str.trim//")"
            if      (.eigen_I(i)>ZERO) then
               eit_p(j) = .theta_E_I(i)
               eit_m(j) = ZERO
            else if (.eigen_I(i)<ZERO) then
               eit_p(j) = ZERO
               eit_m(j) = .theta_E_I(i)
            end
         end

         ect_p(j) = .theta_E_C(i)
         ect_m(j) = .theta_E_C(p)
         ang(j) = atan2(.eigen_I(i),.eigen_C(i))*DEGREE_PER_RADIAN

      end

      n = j

      ! Change decimal places
      stdout.save
      stdout.set_real_precision(3)

      stdout.flush
      stdout.flush
      stdout.text("========================================")
      stdout.text("Covalent/ionic bond indices per subspace")
      stdout.text("========================================")
      stdout.flush
      stdout.text(". The +/- represents bonding/antibonding orbitals.")
      stdout.text("  The C/I represents covalent/ionic Roby-Gould orbitals.")
      stdout.text("  Thus I- represents an ionic antibonding orbital.")
      stdout.flush
      stdout.text(". The angles here are for the individual bond vectors")
      stdout.text("  used in the dial diagram. They are *not* the Araki")
      stdout.text("  subspace angles.")
      stdout.flush

      ! Do table
      table.create(6)

      table(1).set_heading("Paired")
      table(1).set_subhead(" space")
      table(1).set_values(par(1:n))

      table(2).set_heading("Bond")
      table(2).set_subhead("angle")
      table(2).set_sb3head(" /deg")
      table(2).set_values(ang(1:n))

      table(3).set_heading("E_C+")
      table(3).set_values(ect_p(1:n))

      table(4).set_heading("E_C-")
      table(4).set_values(ect_m(1:n))

      table(5).set_heading("E_I+")
      table(5).set_values(eit_p(1:n))

      table(6).set_heading("E_I-")
      table(6).set_values(eit_m(1:n))

      ! Write it
      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      ind.destroy
      eit_m.destroy; eit_p.destroy
      ect_m.destroy; ect_p.destroy
      ang.destroy;   par.destroy

      ! Change decimal places
      stdout.unsave

   end

   ! Careful, old one below

!   put_theta_E_info
!   ! Output theta-space E bond energy information
!      self :: IN
!
!   ENSURE(.atom_a.associated, "No Roby atom A data")
!   ENSURE(.atom_b.associated, "No Roby atom B data")
!   ENSURE(.atom_ab.associated,"No Roby atom AB data")
!
!      n,i,j,p :: INT
!      cst,snt,ang :: VEC{REAL}@
!      ect,eca,ecb :: VEC{REAL}@
!      eit,eia,eib :: VEC{REAL}@
!      emt :: VEC{REAL}@
!      evn,par :: VEC{INT}@
!      table :: VEC{TABLE_COLUMN}@
!
!      stdout.flush
!      stdout.text("===========================================")
!      stdout.text("Roby-Gould theta (bond) eigenspace energies")
!      stdout.text("===========================================")
!
!      stdout.flush
!      if (NOT .is_hyper_analysis) then
!      stdout.text(". Analysis is for atoms:")
!      stdout.flush
!      .put_unique_tags(.atom_a,"(A)")
!      .put_unique_tags(.atom_b,"(B)")
!      else
!      stdout.text(". This is a hypervalent analysis")
!      stdout.flush
!      stdout.text(". Analysis is for transfer into atom A from everything not in M")
!      stdout.flush
!      .put_unique_tags(.atom_a,"(A)")
!      .put_unique_tags(.atom_b,"(M)")
!      end
!
!      stdout.flush
!      if (NOT .is_hyper_analysis) then
!      stdout.text(". States come in bonding-antibonding pairs classified by an angle.")
!      stdout.text("  Negative high covalency have high overlap and low angle.")
!      stdout.text("  States of high ionicity have low overlap and high angle.")
!      else
!      stdout.text(". There are no covalent states, only pure ionic")
!      end
!
!      stdout.flush
!      stdout.text(". For more on this bonding analysis please cite:")
!      stdout.text("  M.D. Gould et al. (2008) Theor. Chem. Acc. 119 pp. 275-290")
!
!      n = .eigen_I.dim
!      stdout.flush
!      stdout.show("No. of states =",n)
!
!      ! Columns
!      evn.create(n)
!      par.create(n)
!      ang.create(n); cst.create(n); snt.create(n)
!      ect.create(n); eca.create(n); ecb.create(n)
!      eit.create(n); eia.create(n); eib.create(n)
!      emt.create(n)
!
!      ! Set column data
!      j = 0
!      do i = 1,n
!
!         if (.pair(i)<1) cycle
!         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle
!
!         ! Index of the paired orbital
!         p = .pair(i)
!
!         j = j + 1
!         evn(j) = i
!         par(j) = p
!         cst(j) = .eigen_C(i)
!         snt(j) = .eigen_I(i)
!         ang(j) = atan2(.eigen_I(i),.eigen_C(i))*DEGREE_PER_RADIAN
!
!         eat(j) = .E_A(i)
!
!      end
!
!      n = j
!
!      stdout.flush
!      stdout.flush
!      stdout.text("=====================")
!      stdout.text("Araki angle subspaces")
!      stdout.text("=====================")
!      stdout.flush
!
!      ! Do table
!      table.create(12)
!
!      table( 1).set_heading("Bond")
!      table( 1).set_subhead("orb.")
!      table( 1).set_values(evn(1:n))
!
!      table( 2).set_heading("Anti")
!      table( 2).set_subhead("bond")
!      table( 2).set_values(par(1:n))
!
!      table( 3).set_heading("theta")
!      table( 3).set_subhead(" /deg")
!      table( 3).set_values(ang(1:n))
!
!      table( 4).set_heading("  cos")
!      table( 4).set_subhead("theta")
!      table( 4).set_values(cst(1:n))
!
!      table( 5).set_heading("  sin")
!      table( 5).set_subhead("theta")
!      table( 5).set_values(snt(1:n))
!
!      table( 6).set_heading("E_C")
!      table( 6).set_values(ect(1:n))
!
!      table( 7).set_heading("E_C")
!      table( 7).set_subhead("A")
!      table( 7).set_values(eca(1:n))
!
!      table( 8).set_heading("E_C")
!      table( 8).set_subhead("B")
!      table( 8).set_values(ecb(1:n))
!
!      table( 9).set_heading("E_I")
!      table( 9).set_values(eit(1:n))
!
!      table(10).set_heading("E_I")
!      table(10).set_subhead("A")
!      table(10).set_values(eia(1:n))
!
!      table(11).set_heading("E_I")
!      table(11).set_subhead("B")
!      table(11).set_values(eib(1:n))
!
!      table(12).set_heading("|E|")
!      table(12).set_values(emt(1:n))
!
!      ! Put table out
!      table.put(label_rows=FALSE)
!
!      ! Clean
!      table.destroy
!      emt.destroy
!      ecb.destroy; eca.destroy; ect.destroy
!      eib.destroy; eia.destroy; eit.destroy
!      snt.destroy; cst.destroy; ang.destroy
!      par.destroy; evn.destroy
!
!   end


! ===================================
! Make and diagonalise Roby operators
! ===================================

   make_full_complement(Q,group,ANO) ::: private
   ! Make "Q" the matrix of the complement projection operator for the
   ! atoms whose indices are in "group" in the full AO basis of
   ! .atom's. If present, use the columns of "ANO" as atomic orbital
   ! coefficients to form the projection operator instead of the
   ! actual atomic natural orbitals.
      self :: IN
      Q :: MAT{REAL}, OUT
      group :: VEC{INT}, optional, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(Q.dim1==.n_bf,"wrong dimension, Q")
   ENSURE(Q.is_square,"Q is incorrectly dimensioned")

      SI :: MAT{REAL}*
      n_bf :: INT

      ! Make the full projection matrix
      .make_full_projection(Q,group,ANO)

      ! Make unit operator "1", just S^-1, in full basis
      n_bf = .n_bf
      SI.create(n_bf,n_bf)
      SI.to_pseudo_inverse_of(.overlap_matrix,TOL(5))

      ! Make complement
      Q = SI - Q

   end

   make_full_projection(P,group,ANO) ::: private
   ! Make "P" the matrix of the Roby projection operator for the atoms
   ! whose indices are in "group" in the full AO basis of .atom's. If
   ! present, use the columns of "ANO" as atomic orbital coefficients
   ! to form the projection operator instead of the actual atomic
   ! natural orbitals.
      self :: IN
      P :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(P.dim1==.n_bf,"wrong dimension, P")
   ENSURE(P.is_square,"P is incorrectly dimensioned")

      W :: MAT{REAL}*
      n_bf :: INT

      ! Small group
      n_bf = .n_bf(group)

      ! Make the "small" projector (reuse code)
      W.create(n_bf,n_bf)
      .make_projection_matrix(W,group,ANO)

      ! Copy into full basis
      .AO_subspace_set(P,W,A_row_atom=group,A_col_atom=group)

      ! Clean
      W.destroy

   end

   make_projection_matrix(P,group,ANO) ::: private
   ! Make "P", the matrix of the Roby projection *operator in the
   ! (nonorthgogonal) AO basis. The AO basis is the concatenated set
   ! of basis functions for each atom in "group". If present, use the
   ! columns of "ANO" as atomic orbital coefficients to form the
   ! projection operator instead of the actual atomic natural orbitals.
      self :: IN
      P :: MAT{REAL}, OUT
      group :: VEC{INT}, optional, IN
      ANO :: MAT{REAL}, optional, IN

   ENSURE(P.dim1==.n_bf(group),"wrong dimension, P ")
   ENSURE(P.is_square,"P is incorrectly dimensioned")

      W,X,Y :: MAT{REAL}*
      n_occ,n_bf :: INT

      n_bf = .n_bf(group)

      ! W = columns of ANO's
      if (present(ANO)) then

         ENSURE(ANO.dim1==.n_bf(group),"wrong dimension, ANO")
         n_occ = ANO.dim2
         W.create(n_bf,n_occ)
         W = ANO

      else if (.use_NAOs OR .use_projected_NAOs) then

         n_occ = .no_of_occupied_NAOs(group)
         W.create(n_bf,n_occ)
         .make_NAO_matrix(W,group)
         if (.show_calcs) then
         stdout.text("NAO:")
         stdout.put(W)
         end

      else

         n_occ = .no_of_occupied_ANOs(group)
         W.create(n_bf,n_occ)
         .make_ANO_matrix(W,group)
         if (.show_calcs) then
         stdout.text("ANO:")
         stdout.put(W)
         end

      end

      ! Y = overlap matrix for group(:) basis
      Y.create(n_bf,n_bf)
      .make_overlap_matrix(Y,group,group)

      ! X = S in the ANO basis
      X.create(n_occ,n_occ)
      Y.change_basis_to(X,W)
      Y.destroy

      ! Y = (ANO overlap matrix)^{-1}
      Y.create(n_occ,n_occ)
      Y.to_pseudo_inverse_of(X,TOL(5))
      X.destroy

      ! P = Y in the group(:) AO basis
      Y.back_transform_to(P,W)

      ! Clean
      Y.destroy
      W.destroy

   end

   make_ANO_matrix(ANO,group,tol) ::: private, PURE
   ! Make the "ANO" matrix, comprised of columns of the occupied
   ! atomic natural orbitals, for each atom whose index appears in
   ! "group".  If "tol" is present, use this cutoff to determine what
   ! is an occupied natural orbital.
      self :: IN
      ANO :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN

   ENSURE(ANO.dim1==.n_bf(group),"wrong shape, ANO")
   ENSURE(ANO.dim2==.no_of_occupied_ANOs(group,tol),"wrong shape, ANO")

      eps :: REAL
      a,aa,b,n,n_bf,n_occ :: INT

      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      ANO = ZERO

      b = 0
      n = 0

      do a = 1,group.dim

         aa    = group(a)
         n_bf  = .atom(aa).basis.n_bf
         n_occ = .atom(aa).no_of_occupied_NOs(tol=eps)

         ANO(b+1:b+n_bf,n+1:n+n_occ) = .atom(aa).natural_orbitals.restricted(:,1:n_occ)

         b = b + n_bf
         n = n + n_occ

      end

   end

   make_NAO_matrix(NAO,group,tol) ::: private, PURE
   ! Make the "NAO" matrix, comprised of columns of the occupied
   ! natural atomic orbitals, for each atom whose index appears in
   ! "group".  If "tol" is present, use this cutoff to determine what
   ! is an occupied natural orbital.
      self :: IN
      NAO :: MAT{REAL}, OUT
      group :: VEC{INT}, IN
      tol :: REAL, optional, IN

   ENSURE(NAO.dim1==.n_bf(group),"wrong shape, NAO")
   ENSURE(NAO.dim2==.no_of_occupied_NAOs(group,tol),"wrong shape, NAO")

      eps :: REAL
      a,aa,b,n,n_bf,n_occ :: INT

      ! Same cutoff as for ANO's
      eps = .occupied_ANO_cutoff
      if (present(tol)) eps = tol

      NAO = ZERO

      b = 0; n = 0

      do a = 1,group.dim

         aa    = group(a)
         n_bf  = .atom(aa).basis.n_bf
         n_occ = .atom(aa).no_of_occupied_NAOs(eps)

         NAO(b+1:b+n_bf,n+1:n+n_occ) = .atom(aa).NAOs(:,1:n_occ)

         b = b + n_bf
         n = n + n_occ

      end

   end

!   make_NAO_matrix(NAO,occupation,group,tol) ::: leaky
!   ! Make the natural atomic orbitals "NAO" and their "occupation"
!   ! numbers for a "group" of atoms, from the density matrix 
!   ! ".density_matrix"; "tol" is used to decide when an NAO is
!   ! occupied or not.
!      self :: IN
!      NAO :: MAT{REAL}*
!      occupation :: VEC{REAL}*
!      group :: VEC{INT}, IN
!      tol :: REAL, optional, IN
!
!   ENSURE(.overlap_matrix.allocated,"no overlap matrix")
!   ENSURE(.density_matrix.allocated,"no density_matrix")
!   ENSURE(.density_matrix.restricted.allocated,"no density_matrix.restricted")
!
!      S,V,X,P :: MAT{REAL}*
!      n_bf,n_occ :: INT
!      eps :: REAL
!
!      ! No. of basis functions in the group
!      n_bf = .n_bf(group)
!
!      ! Create the (full) NAO and occupation matrix
!      NAO.create(n_bf,n_bf)
!      occupation.create(n_bf)
!
!      ! S = overlap matrix for group(:) basis
!      S.create(n_bf,n_bf)
!      .make_overlap_matrix(S,group,group)
!
!      ! Get V = S^(1/2)
!      V.create(n_bf,n_bf)
!      V.to_sqrt_of(S)
!
!      ! Diagonal part of P matrix
!      P.create(n_bf,n_bf)
!      .AO_subspace_set(P,.density_matrix.restricted,B_row_atom=group,B_col_atom=group)
!
!      ! Transform P -> S^(1/2) P S^(1/2)
!      X.create(n_bf,n_bf)
!      P.change_basis_to(X,V)
!
!      ! Diagonalize
!      X.solve_symmetric_eigenproblem(occupation,P)
!
!      ! Get V = S^(-1/2)
!      V.to_inverse_sqrt_of(S)
!
!      ! Back transform
!      NAO.to_product_of(V,P)
!
!      ! Clean
!      X.destroy
!      P.destroy
!      V.destroy
!      S.destroy
!
!      ! Debug
!      if (TRUE) then
!         stdout.flush
!         stdout.text("occupation:")
!         stdout.put(occupation)
!         stdout.text("NAO:")
!         stdout.put(NAO)
!      end
!
!      ! Reverse order
!      occupation = occupation(n_bf:1:-1)
!      NAO        =      NAO(:,n_bf:1:-1)
!
!      ! Cutoff
!      eps = .occupied_ANO_cutoff
!      if (present(tol)) eps = tol
!
!      ! Count
!      n_occ = count(occupation>=eps)
!
!      ! Shrink
!      occupation.shrink(n_occ)
!      NAO.shrink_columns(n_occ)
!
!      ! Debug
!      if (TRUE) then
!         stdout.flush
!         stdout.text("occupation:")
!         stdout.put(occupation)
!         stdout.text("NAO:")
!         stdout.put(NAO)
!      end
!
!   end

!   make_shared_operator(R) ::: private
!   ! constructs the roby_shared_operator R_AB = P_A + P_B - P_AB
!   ! if spin_case is supplied then either the alpha or beta
!   ! operator is constructed, depending on the value of spin_case
!      self :: IN
!      R :: MAT{REAL}, OUT
!
!   ENSURE(.atom_a.associated,"No roby atom A")
!   ENSURE(.atom_b.associated,"No roby atom B")
!   ENSURE(.atom_ab.associated,"No roby atom AB")
!
!      P_A,P_B,P_AB :: MAT{REAL}*
!      n_a, n_b, n_ab :: INT
!
!      n_a  = .n_bf_a
!      n_b  = .n_bf_b
!      n_ab = .n_bf_ab
!
!      P_A.create(n_a,n_a)
!      P_B.create(n_b,n_b)
!      P_AB.create(n_ab,n_ab)
!
!      .make_projection_matrix(P_A ,.atom_a)
!      .make_projection_matrix(P_B ,.atom_b)
!      .make_projection_matrix(P_AB,.atom_ab)
!
!      R = ZERO
!      R(    1:n_a ,     1:n_a ) =  P_A
!      R(n_a+1:n_ab, n_a+1:n_ab) =  P_B
!      R = R - P_AB
!
!      P_AB.destroy
!      P_B.destroy
!      P_A.destroy
!
!   end

   make_ionic_operator(I) ::: private
   ! constructs the roby/gould ionic operator I_AB = P_A - P_B
       self :: IN
       I :: MAT{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")

      P_B,P_A :: MAT{REAL}*
      n_a, n_b, n_ab :: INT

      n_a  = .n_bf_a
      n_b  = .n_bf_b
      n_ab = .n_bf_ab

      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)

      .make_projection_matrix(P_A,.atom_a)
      .make_projection_matrix(P_B,.atom_b)

      I = ZERO
      I(    1:n_a ,     1:n_a ) =  P_A
      I(n_a+1:n_ab, n_a+1:n_ab) = -P_B

      P_B.destroy
      P_A.destroy

   end

   make_hyper_operator(H) ::: private
   ! constructs the Roby/Gould hyper operator H_A = P_A - Q_M
       self :: IN
       H :: MAT{REAL}, OUT

   ENSURE(H.dim1==.n_bf,"Wrong dim1, H")
   ENSURE(H.is_square,"H is noyt square")

      Q_M,P_A :: MAT{REAL}*
      n_bf :: INT

      n_bf = .n_bf

      Q_M.create(n_bf,n_bf)
      P_A.create(n_bf,n_bf)

      .make_full_complement(Q_M,.atom_ab)
      .make_full_projection(P_A,.atom_a)

      H = P_A - Q_M

      P_A.destroy
      Q_M.destroy

   end

   diagonalize_V_AB_operator(X,eigenvectors,eigenvalues) ::: private
   ! For operator "X" (for example, C = cos theta or S= sin theta) in
   ! the concatenated AO basis of the atoms in .roby.atom_group,
   !    X = \sum_{i,j} |i> X_{ij} <j|, |i>,|j> in V_{AB},
   ! diagonalise and return the "eigenvectors" and "eigenvalues".
      self :: IN
      X :: MAT{REAL}, IN
      eigenvectors :: MAT{REAL}, OUT
      eigenvalues :: VEC{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
   ENSURE(.atom_ab.associated,"No roby atom AB")

      XX,XV, SS,SI,SH :: MAT{REAL}*
      n_ab :: INT

      n_ab = .n_bf_ab

      XX.create(n_ab,n_ab)
      XV.create(n_ab,n_ab)

      ! Overlap matrices
      SI.create(n_ab,n_ab)
      SH.create(n_ab,n_ab)
      SS.create(n_ab,n_ab)
      .make_overlap_matrix(SS,.atom_ab,.atom_ab)

      ! Inverse overlap
      SH.to_sqrt_of(SS,TOL(5))
      SI.to_pseudo_inverse_of(SH,TOL(5))

      ! Eigenproblem
      X.back_transform_to(XX,SH)
      XX.solve_symmetric_eigenproblem(eigenvalues,XV)
      eigenvectors.to_product_of(SI,XV)

      ! Clean
      SS.destroy
      SH.destroy
      SI.destroy
      XV.destroy
      XX.destroy

   end

   diagonalize_full_operator(X,eigenvectors,eigenvalues) ::: private
   ! For operator "X" (for example, C = cos theta or S= sin theta) in
   ! the concatenated AO basis of the atoms in .roby.atom_group,
   !    X = \sum_{i,j} |i> X_{ij} <j|, |i>,|j> in V_{AB},
   ! diagonalise and return the "eigenvectors" and "eigenvalues".
      self :: IN
      X :: MAT{REAL}, IN
      eigenvectors :: MAT{REAL}, OUT
      eigenvalues :: VEC{REAL}, OUT

   ENSURE(.atom_a.associated,"No roby atom A")
   ENSURE(.atom_b.associated,"No roby atom B")
 ! ENSURE(.atom_ab.associated,"No roby atom AB")

      XX,XV, SS,SI,SH :: MAT{REAL}*
      n_ab :: INT

      n_ab = .n_bf

      XX.create(n_ab,n_ab)
      XV.create(n_ab,n_ab)

      ! Overlap matrices
      SI.create(n_ab,n_ab)
      SH.create(n_ab,n_ab)
      SS.create(n_ab,n_ab)
      .make_overlap_matrix(SS,.atom_b,.atom_b)

      ! Inverse overlap
      SH.to_sqrt_of(SS,TOL(5))
      SI.to_pseudo_inverse_of(SH,TOL(5))

      ! Eigenproblem
      X.back_transform_to(XX,SH)
      XX.solve_symmetric_eigenproblem(eigenvalues,XV)
      eigenvectors.to_product_of(SI,XV)

      ! Clean
      SS.destroy
      SH.destroy
      SI.destroy
      XV.destroy
      XX.destroy

   end

! ===========================
! Make roby projected density
! ===========================

!   make_projected_density(rho,density,ANO) ::: private
!   ! Make the Roby-projected density matrix in the concatenated basis
!   ! of AO functions of the atoms in .atom_ab and copy it into "rho",
!   ! a .n_bf x .n_bf matrix where all other matrix elements not corresponding
!   ! to basis functions in .atom_ab are made zero. If present, "density" is
!   ! used instead of the restricted density matrix. If present, "ANO" are used
!   ! for the Roby projection.
!      rho,density :: MAT{REAL}
!      ANO :: MAT{REAL}, optional
!   ENSURE(rho.dim1==.n_bf,"rho has wrong shape")
!   ENSURE(rho.is_square,"rho has wrong shape")
!   ENSURE(density.dim1==.n_bf,"wrong shape, density")
!   ENSURE(density.is_square,"wrong shape, density")
!   ENSURE(.atom_ab.associated,"No atom AB group")
!      D,P,rho_P :: MAT{REAL}*
!      n_bf :: INT
!      n_bf = .n_bf_ab
!      D.create(n_bf,n_bf)
!      .overlap_transform(density,D,col_atom=.atom_ab)
!      P.create(n_bf,n_bf)
!      .make_projection_matrix(P,.atom_ab,ANO)
!      rho_P.create(n_bf,n_bf)
!      D.change_basis_to(rho_P,P) ! rho_P(small) = P_W(small) D(small) P_W(small)
!      .AO_subspace_set(rho,rho_P,A_row_atom=.atom_ab,A_col_atom=.atom_ab)
!      rho_P.destroy
!      P.destroy
!      D.destroy
!   end

! ===============================================
! Low level Roby routines used all over the place
! ===============================================

   E_expectation result (res) ::: private
   ! Get the expectation value of the density matrix.
      self :: IN
      res :: REAL

      E_matrix :: MAT{REAL}@

      ! Make unprojected E_matrix
      ! Warning: restricted case only
      E_matrix = HALF*(.core_matrix.restricted + .fock_matrix.restricted)

      ! Do it
      res = .density_matrix.restricted.trace_product_with(E_matrix)

   end

!   E_expectation(P,group) result (res) ::: private
!   ! Get the expectation value of the projection operator matrix "P"
!   ! over a certain "group" of atoms, i.e:
!   !    res = Trace ( S(:,group) P S(group,:) . density_matrix )
!   ! Note that "group" are the indices of the atoms whose basis functions
!   ! are used to define the matrix "P".
!      self :: IN
!      P :: MAT{REAL}, IN
!      group :: VEC{INT}, optional, IN
!      res :: REAL
!
!   ENSURE(P.dim1==.n_bf(group),"wrong P dimension")
!   ENSURE(P.is_square,"P is not square")
!
!      W :: MAT{REAL}*
!      grp :: VEC{INT}@
!      n_bf :: INT
!
!      n_bf = .n_bf
!
!      if (present(group)) then; grp = group
!      else;                     grp.to_sequence(1,n_group)
!      end
!
!      ! Make W = S P S
!      W.create(n_bf,n_bf)
!      .overlap_transform(P,W,grp)
!
!      ! Make Tr ( rho . S P S )
!      ! Warning: restricted case only so far
!      res = .density_matrix.restricted.trace_product_with(W)
!
!      ! Clean
!      W.destroy
!      grp.destroy
!
!   end

   expectation(P,group,rho) result (res) ::: private
   ! Get the expectation value of the projection operator matrix "P"
   ! over a certain "group" of atoms, i.e:
   !    res = Trace ( S(:,group) P S(group,:) rho )
   ! where "rho" is by default the .density_matrix. Note that "group"
   ! are the indices of the atoms whose basis functions are used to
   ! define the matrix "P".
      self :: IN
      P :: MAT{REAL}, IN
      group :: VEC{INT}, optional, IN
      rho :: OPMATRIX@, optional, IN
      res :: REAL

   ENSURE(P.dim1==.n_bf(group),"wrong P dimension")
   ENSURE(P.is_square,"P is not square")

      density :: OPMATRIX@
      grp :: VEC{INT}@
      W :: MAT{REAL}*
      n_bf :: INT

      n_bf = .n_bf

      density = .density_matrix
      if (present(rho)) density = rho

      ! Make all groups?
      if (present(group)) then; grp = group
      else;                     grp.to_sequence(1,.n_group)
      end

      ! Make W = S P S
      W.create(n_bf,n_bf)
      .overlap_transform(P,W,grp)

      ! Make Tr ( S P S rho)
      if (.spin_multiplicity/=1) then
         res = density.alpha.trace_product_with(W) &
             + density.beta.trace_product_with(W)
      else
         res = density.restricted.trace_product_with(W)
      end

      W.destroy
      grp.destroy

   end

   project(X,P,Y,row_atom,col_atom) ::: private
   ! Do: Y = P^T S(col_atom,row_atom) X S(row_atom,col_atom) P where
   ! S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom
   ! indices in "row_atom" and "col_atom", and "P" is a matrix
      X,P,Y :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}

   ENSURE(X.dim1==.n_bf(row_atom),"wrong X dimension")
   ENSURE(Y.dim1==.n_bf(col_atom),"wrong Y dimension")
   ENSURE(Y.dim1==P.dim1,"wrong P dimension")
   ENSURE(X.is_square,"X is not square")
   ENSURE(Y.is_square,"Y is not square")
   ENSURE(P.is_square,"P is not square")

      W :: MAT{REAL}*

      W.create(Y.dim1,Y.dim2)
      .overlap_transform(X,W,row_atom,col_atom)
      W.change_basis_to(Y,P)
      W.destroy

   end

   overlap_transform(X,Y,row_atom,col_atom) ::: private
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the section of the full overlap
   ! matrix specified by the basis functions on the atom indices in
   ! "row_atom" and "col_atom".
      self :: IN
      X :: MAT{REAL}, IN
      Y :: MAT{REAL}, OUT
      row_atom, col_atom :: VEC{INT}, optional, IN

      SS :: MAT{REAL}*
      n_row,n_col :: INT

      n_row = .n_bf(row_atom)
      n_col = .n_bf(col_atom)

      ! SS = small S
      SS.create(n_row,n_col)

      .make_overlap_matrix(SS,row_atom,col_atom)

      X.change_basis_to(Y,SS)

      SS.destroy

   end

   right_overlap_transform(X,Y,row_atom,col_atom) ::: private
   ! Do: Y = X S(row_atom,col_atom), where S(row_atom,col_atom) is the
   ! AO subspace section of the full overlap matrix specified by the
   ! basis functions on the atom indices in "row_atom" and "col_atom".
      self :: IN
      X :: MAT{REAL}, IN
      Y :: MAT{REAL}, OUT
      row_atom, col_atom :: VEC{INT}, optional, IN

      SS :: MAT{REAL}*
      n_row,n_col :: INT

      n_row = .n_bf(row_atom)
      n_col = .n_bf(col_atom)

      SS.create(n_row,n_col)

      .make_overlap_matrix(SS,row_atom,col_atom)

      Y.to_product_of(X,SS)

      SS.destroy

   end

   make_overlap_matrix(SS,row_atom,col_atom) ::: private, PURE
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      self :: IN
      SS :: MAT{REAL}, OUT
      row_atom,col_atom :: VEC{INT}, optional, IN

   ENSURE(.overlap_matrix.allocated,"no overlap matrix")
   ENSURE(SS.dim1==.n_bf(row_atom),"wrong shape, SS")
   ENSURE(SS.dim2==.n_bf(col_atom),"wrong shape, SS")

      .AO_subspace_set(SS,.overlap_matrix,B_row_atom=row_atom,B_col_atom=col_atom)

   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom) ::: private, PURE
   ! If either "B_row_atom" or "B_col_atom" is present, then set "A"
   ! equal to the AO subspace blocks of "B" specified by the atom
   ! indices in "B_row_atom" and "B_col_atom". If either is missing,
   ! then copy the entire row or col, i.e.
   !    A(small) = B(B_row_atom,B_col_atom)
   ! If either "A_row_atom" or "A_col_atom" is present, then set the
   ! AO subspace blocks of "A" specified by the atom indices in
   ! "A_row_atom" and "A_col_atom" equal to "B". If either is missing
   ! then copy the entire row or column. Uncopied blocks are set to
   ! zero, i.e.
   !    A(A_row_atom,A_col_atom) = B(small)
      self :: IN
      A :: MAT{REAL}, OUT
      B :: MAT{REAL}, IN
      A_row_atom,A_col_atom :: VEC{INT}, optional, IN
      B_row_atom,B_col_atom :: VEC{INT}, optional, IN

      n_row_atoms,n_col_atoms :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      first_basis_fn_for,last_basis_fn_for :: VEC{INT}@
      Achk,Bchk :: BIN

    Achk = present(A_row_atom) OR present(A_col_atom)
    Bchk = present(B_row_atom) OR present(B_col_atom)
    ENSURE(Achk NEQV Bchk,"missing A/B row or col atoms")

      .atom.make_atom_basis_fn_limits(first_basis_fn_for,last_basis_fn_for)

      if (present(B_row_atom) OR present(B_col_atom)) then

         ENSURE(B.dim1==.n_bf,"B has wrong shape")
         ENSURE(B.dim2==.n_bf,"B has wrong shape")

         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            ENSURE(A.dim1==.atom(B_row_atom).no_of_basis_functions,"A has wrong shape")
            ENSURE(A.dim2==.atom(B_col_atom).no_of_basis_functions,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(B_row_atom(i))
               l_i = last_basis_fn_for( B_row_atom(i))
               n_i = l_i - f_i + 1
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = first_basis_fn_for(B_col_atom(j))
                  l_j = last_basis_fn_for( B_col_atom(j))
                  n_j = l_j - f_j + 1
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end
               b_i = b_i + n_i
            end

         else if (present(B_row_atom)) then

            n_row_atoms = size(B_row_atom)
            ENSURE(A.dim1==.atom(B_row_atom).no_of_basis_functions,"A has wrong shape")
            ENSURE(A.dim2==.n_bf,"A has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(B_row_atom(i));
               l_i = last_basis_fn_for( B_row_atom(i))
               n_i = l_i - f_i + 1
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end

         else if (present(B_col_atom)) then

            n_col_atoms = size(B_col_atom)
            ENSURE(A.dim1==.n_bf,"A has wrong shape")
            ENSURE(A.dim2==.atom(B_col_atom).no_of_basis_functions,"A has wrong shape")

            b_j = 0
            do j = 1,n_col_atoms
               f_j = first_basis_fn_for(B_col_atom(j));
               l_j = last_basis_fn_for( B_col_atom(j))
               n_j = l_j - f_j + 1
               A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
               b_j = b_j + n_j
            end

         end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then

         ENSURE(A.dim1==.n_bf,"A has wrong shape")
         ENSURE(A.dim2==.n_bf,"A has wrong shape")

         A = ZERO

         if (present(A_row_atom) AND present(A_col_atom)) then

            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            ENSURE(B.dim1==.atom(A_row_atom).no_of_basis_functions,"B has wrong shape")
            ENSURE(B.dim2==.atom(A_col_atom).no_of_basis_functions,"B has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(A_row_atom(i))
               l_i = last_basis_fn_for( A_row_atom(i))
               n_i = l_i - f_i + 1
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = first_basis_fn_for(A_col_atom(j))
                  l_j = last_basis_fn_for( A_col_atom(j))
                  n_j = l_j - f_j + 1
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j)
                  b_j = b_j + n_j
               end
               b_i = b_i + n_i
            end

         else if (present(A_row_atom)) then

            n_row_atoms = size(A_row_atom)
            ENSURE(B.dim1==.atom(A_row_atom).no_of_basis_functions,"B has wrong shape")
            ENSURE(B.dim2==.n_bf,"B has wrong shape")

            b_i = 0
            do i = 1,n_row_atoms
               f_i = first_basis_fn_for(A_row_atom(i));
               l_i = last_basis_fn_for( A_row_atom(i))
               n_i = l_i - f_i + 1
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end

         else if (present(A_col_atom)) then

            n_col_atoms = size(A_col_atom)
            ENSURE(B.dim1==.atom(A_col_atom).no_of_basis_functions,"B has wrong shape")
            ENSURE(B.dim2==.n_bf,"B has wrong shape")

            b_j = 0
            do j = 1,n_col_atoms
               f_j = first_basis_fn_for(A_col_atom(j));
               l_j = last_basis_fn_for( A_col_atom(j))
               n_j = l_j - f_j + 1
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end

         end

      end

      ! Clean
      last_basis_fn_for.destroy
      first_basis_fn_for.destroy

   end

! ==============
! Output methods
! ==============

   put_basics
   ! Put to stdout the Roby atom data
      self :: IN

   ENSURE(.atom.associated,"no atom data")

      i :: INT
      symbol :: VEC{STR}@

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      stdout.flush
      stdout.text("==============================")
      stdout.text("Roby-Gould population analysis")
      stdout.text("==============================")
      stdout.flush
      stdout.show("Molecule charge          =",.charge)
      stdout.show("Molecule multiplicity    =",.spin_multiplicity)
      stdout.flush                          
      stdout.show("Kind of calculation      =",.roby_kind)
      stdout.show("Use NAOs?                =",.use_NAOs)
      stdout.show("Use projected NAOs?      =",.use_projected_NAOs)
      stdout.show("Use spherical averaging? =",.use_spherical_averaging)
      stdout.show("Homoleptic calculation?  =",.is_homoleptic)
      stdout.show("Occupied ANO cutoff      =",.occupied_ANO_cutoff)
      stdout.show("Output theta info?       =",.output_theta_info)
      stdout.flush

      if (.is_homoleptic) then
      symbol = .unique_tags
      do i = 1,.n_group
      stdout.show("Atom group "//i.to_str.trim//"            =",symbol(i))
      end
      end

      if (.atom_list.associated) then
      symbol = .atom.unique_tags(.atom_list)
      stdout.show("Atom list                =",symbol)
      stdout.show("No. of atoms             =",symbol.dim)
      symbol.destroy
      stdout.show("Analyze all atom pairs?  =",.analyze_all_atom_pairs)
      stdout.show("Analyze VDW atom pairs?  =",.analyze_vdw_atom_pairs)
      stdout.show("Bond range factor /Angs  =",.bond_range_factor.to_units("angstrom"))
      end

      symbol.destroy

      stdout.flush
      stdout.show("Zero angle cutoff /Deg   =",.zero_angle_cutoff.to_units("degree"))

      ! Unsave
      stdout.unsave

   end

   put_populations
   ! Put to stdout the only Roby atom populations
      self :: IN

   ENSURE(.n1.allocated,"no atom populations exist")
   ENSURE(.atom.associated,"no atom data")

      table :: VEC{TABLE_COLUMN}@
      symbols :: VEC{STR}@
      charge :: VEC{REAL}@
      labels :: VEC{INT}@
      n_e,f :: INT

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      stdout.flush
      stdout.text("=====================")
      stdout.text("Roby atom populations")
      stdout.text("=====================")

      n_e = .atom.no_of_electrons

      stdout.flush
      stdout.show("No. of electrons in mol =",n_e)
      stdout.show("No. of electrons in P_M =",.n_all)
      stdout.show("No. of hypervalent e's  =",n_e-.n_all)
      stdout.flush

      ! Create table
      table.create(3)

      ! Set the table headings
      table(1).set_heading("Atom")
      table(1).set_width_from(.atom.chemical_symbols)
      if (.is_homoleptic) then
         symbols.create(.n_group)
         labels.create(.n_group)
         f = 1
         labels.to_sequence(f,.n_group)
         symbols = labels.to_str
         labels.destroy
      else
         symbols = .unique_tags
      end
      table(1).set_values(symbols)

      table(2).set_heading(" No. of")
      table(2).set_subhead("electrons")
      table(2).set_values(.n1)

      charge.create(.n_group)
      charge = -.n1 + .group_nuclear_charges
      table(3).set_heading(" Charge")
      table(3).set_values(charge)

      ! Put table
      table.put(label_rows=FALSE)

      ! Clean
      charge.destroy
      symbols.destroy

      ! Unsave
      stdout.unsave

   end

   put_bond_indices
   ! Put to stdout the Roby bond indices, including the shared populations
      self :: IN

      if (.is_homoleptic) then

         .put_bond_indices_group

      else

         .put_bond_indices_atoms
         .put_bond_indices_sortd

         ! Separate data tables
         .put_file_indices_atoms

         ! LaTeX tables
         .put_bond_indices_do_H
         .put_bond_indices_do_H_vdw
         .put_bond_indices_no_H
       ! .put_bond_indices_CC

      end

   end

   put_bond_indices_group
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(.is_homoleptic,"job is not homoleptic")
   ENSURE(.n_group>1,"must be at least two groups")

      table :: VEC{TABLE_COLUMN}@
      symbol :: VEC{STR}@
      g_A,g_B :: VEC{INT}@
      n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      n_group, n_pair,i,a,b :: INT

      n_group = .n_group

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond indices")
      stdout.text("=======================")
      stdout.flush
      stdout.text("Bond indices appear only between atom groups.")
      stdout.flush
      symbol = .unique_tags
      do i = 1,n_group
      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
      end
      symbol.destroy
      stdout.flush

      ! Create table
      table.create(11)

      ! Set the table headings
      table( 1).set_heading("Grp")
      table( 1).set_subhead("  A")
      table( 2).set_heading("Grp")
      table( 2).set_subhead("  B")
      table( 3).set_heading("n_A")
      table( 3).set_width_from(TEN)
      table( 4).set_heading("n_B")
      table( 4).set_width_from(TEN)
      table( 5).set_heading("n_AB")
      table( 5).set_width_from(TEN)
      table( 6).set_heading("s_AB")
      table( 6).set_width_from(TEN)
      table( 7).set_heading(" Cov.")
      table( 7).set_subhead("index")
      table( 7).set_width_from(-TEN)
      table( 8).set_heading("Ionic")
      table( 8).set_subhead("index")
      table( 8).set_width_from(-TEN)
      table( 9).set_heading(" Bond")
      table( 9).set_subhead("index")
      table( 9).set_width_from(ONE)
      table(10).set_heading("% Cov")
      table(10).set_heading("Pythag.")
      table(10).set_width_from(100d0)
      table(11).set_heading("% Cov")
      table(11).set_heading("Araki")
      table(11).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Populations & indices
      n_pair = n_group - 1
      n_pair = n_pair.triangle_number
      g_A.create(n_pair)
      g_B.create(n_pair)
      n_A.create(n_pair)
      n_B.create(n_pair)
      nAB.create(n_pair)
      sAB.create(n_pair)
      cAB.create(n_pair)
      iAB.create(n_pair)
      tAB.create(n_pair)
      pAB.create(n_pair)
      aAB.create(n_pair)

      i = 0
      do a = 1,.n_group
      do b = a+1,.n_group
         i = i + 1
         g_A(i) = a
         g_B(i) = b
         n_A(i) = .n1(a)
         n_B(i) = .n1(b)
         nAB(i) = .n2(a,b)
         sAB(i) = .n1(a) + .n1(b) - .n2(a,b)
         cAB(i) =  .cov_index(a,b)
         iAB(i) =  .ion_index(a,b)
         tAB(i) = .bond_index(a,b)
         pAB(i) = .percent_covalency_P(a,b)
         aAB(i) = .percent_covalency_A(a,b)
      end
      end

      ! Set table data
      table( 1).set_values(g_A)
      table( 2).set_values(g_B)
      table( 3).set_values(n_A)
      table( 4).set_values(n_B)
      table( 5).set_values(nAB)
      table( 6).set_values(sAB)
      table( 7).set_values(cAB)
      table( 8).set_values(iAB)
      table( 9).set_values(tAB)
      table(10).set_values(pAB)
      table(11).set_values(aAB)

      ! Put body
      stdout.flush
      table.put_body(label_rows=FALSE)

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy

      aAB.destroy
      pAB.destroy
      tAB.destroy
      iAB.destroy
      cAB.destroy
      sAB.destroy
      nAB.destroy
      n_B.destroy
      n_A.destroy
      g_B.destroy
      g_A.destroy

      ! Unsave
      stdout.unsave

   end

   put_bond_indices_hyper
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(.is_hyper_analysis,"must be at hypervalent analysis")
   ENSURE(.n_group>1,"must be at leat two groups")

      table :: VEC{TABLE_COLUMN}@
      symbol :: VEC{STR}@
      g_A :: VEC{INT}@
      n_A,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      n_group, i,a :: INT

      n_group = .n_group

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===================================")
      stdout.text("Hypervalent Roby-Gould bond indices")
      stdout.text("===================================")

      stdout.flush
      stdout.text("Bond indices appear between atom groups and everything")
      stdout.text("*not* in the space of the atoms.")
      stdout.flush
      stdout.text("There should only appear ionic transfer, no covalency.")
      stdout.flush

      symbol = .unique_tags
      do i = 1,n_group
      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
      end
      symbol.destroy
      stdout.flush

      ! Create table
      table.create(7)

      ! Set the table headings
      table(1).set_heading("Grp")
      table(1).set_subhead("  A")
      table(2).set_heading("n_A")
      table(2).set_width_from(TEN)
      table(3).set_heading(" Cov.")
      table(3).set_subhead("index")
      table(3).set_width_from(-TEN)
      table(4).set_heading("Ionic")
      table(4).set_subhead("index")
      table(4).set_width_from(-TEN)
      table(5).set_heading(" Bond")
      table(5).set_subhead("index")
      table(5).set_width_from(ONE)
      table(6).set_heading("% Cov")
      table(6).set_subhead("Pythag.")
      table(6).set_width_from(100d0)
      table(7).set_heading("% Cov")
      table(7).set_subhead("Araki")
      table(7).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Populations & indices
      g_A.create(n_group)
      n_A.create(n_group)
      cAB.create(n_group)
      iAB.create(n_group)
      tAB.create(n_group)
      pAB.create(n_group)
      aAB.create(n_group)

      i = 0
      do a = 1,.n_group
         i = i + 1
         g_A(i) = a
         n_A(i) = .n1(a)
         cAB(i) =  .cov_index(a,a)
         iAB(i) =  .ion_index(a,a)
         tAB(i) = .bond_index(a,a)
         pAB(i) = .percent_covalency_P(a,a)
         aAB(i) = .percent_covalency_A(a,a)
      end

      ! Set table data
      table(1).set_values(g_A)
      table(2).set_values(n_A)
      table(3).set_values(cAB)
      table(4).set_values(iAB)
      table(5).set_values(tAB)
      table(6).set_values(pAB)
      table(7).set_values(aAB)

      ! Put body
      stdout.flush
      table.put_body(label_rows=FALSE)

      ! Clean
      table.clear_columns

      aAB.destroy
      pAB.destroy
      tAB.destroy
      iAB.destroy
      cAB.destroy
      n_A.destroy
      g_A.destroy

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy

      ! Unsave
      stdout.unsave

   end

   put_bond_indices_atoms
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("==============================================")
      stdout.text("Roby-Gould bond indices: VDW interactions only")
      stdout.text("==============================================")
      else
      stdout.flush
      stdout.text("=======================")
      stdout.text("Roby-Gould bond indices")
      stdout.text("=======================")
      end

      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Indices appear only for VDW bonded atom pairs and")
      stdout.text("NOT normally bonded by CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD)")
      stdout.text("AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text("Indices appear only for atom pairs which are connected")
      stdout.text("according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(16)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_column_spacing(0)
      table( 2).set_heading("--")
      table( 2).set_width(2)

      table( 3).set_heading("B")
      table( 3).set_width(table(1).width)
      table( 3).set_left_justify(TRUE)

      table( 4).set_heading("A")
      table( 4).set_width_from(.atom(:).tag)

      table( 5).set_column_spacing(0)
      table( 5).set_heading("--")
      table( 5).set_width(2)

      table( 6).set_heading("B")
      table( 6).set_width(table(4).width)
      table( 6).set_left_justify(TRUE)

      table( 7).set_heading("R(A--B)")
      table( 7).set_subheading("/Angs.")
      table( 7).set_width_from(ONE)

      table( 8).set_heading("n_A")
      table( 8).set_width_from(TEN)
      table( 9).set_heading("n_B")
      table( 9).set_width_from(TEN)
      table(10).set_heading("n_AB")
      table(10).set_width_from(TEN)
      table(11).set_heading("s_AB")
      table(11).set_width_from(TEN)
      table(12).set_heading(" Cov.")
      table(12).set_subhead("index")
      table(12).set_width_from(-TEN)
      table(13).set_heading("Ionic")
      table(13).set_subhead("index")
      table(13).set_width_from(-TEN)
      table(14).set_heading(" Bond")
      table(14).set_subhead("index")
      table(14).set_width_from(ONE)
      table(15).set_heading("% Cov")
      table(15).set_subhead("Pythag.")
      table(15).set_width_from(100d0)
      table(16).set_heading("% Cov")
      table(16).set_subhead("Araki")
      table(16).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         n_A.create(n_bonds)
         n_B.create(n_bonds)
         nAB.create(n_bonds)
         sAB.create(n_bonds)
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)
         aAB.create(n_bonds)

         n_A = .n1(pair(:,1))
         n_B = .n1(pair(:,2))
         forall (i=1:n_bonds)
         nAB(i) = .n2(pair(i,1),pair(i,2))
         sAB(i) = n_A(i) + n_B(i) - nAB(i)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency_P(pair(i,1),pair(i,2))
         aAB(i) = .percent_covalency_A(pair(i,1),pair(i,2))
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(labels(:,1))
         table( 5).set_values(dash)
         table( 6).set_values(labels(:,2))
         table( 7).set_values(dist)
         table( 8).set_values(n_A)
         table( 9).set_values(n_B)
         table(10).set_values(nAB)
         table(11).set_values(sAB)
         table(12).set_values(cAB)
         table(13).set_values(iAB)
         table(14).set_values(tAB)
         table(15).set_values(pAB)
         table(16).set_values(aAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         aAB.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         sAB.destroy
         nAB.destroy
         n_B.destroy
         n_A.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

      ! Unsave
      stdout.unsave

   end

   put_bond_indices_sortd
   ! Output the bond indices table for connected atoms.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}@
      labels :: MAT{STR}@
      dash :: VEC{STR}@
      dist,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      ind :: VEC{INT}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)
      stdout.redirect("rgbi-bondtable+H+vdw.tex")

      ! Title
      if (.analyze_vdw_atom_pairs) then
      stdout.flush
      stdout.text("=====================================================")
      stdout.text("Sorted Roby-Gould bond indices: VDW interactions only")
      stdout.text("=====================================================")
      else
      stdout.flush
      stdout.text("==============================")
      stdout.text("Sorted Roby-Gould bond indices")
      stdout.text("==============================")
      end

      stdout.flush
      stdout.text(". Indices are sorted from lowest to highest")
      stdout.flush
      if (.analyze_vdw_atom_pairs) then
      stdout.text("Indices appear only for VDW bonded atom pairs and")
      stdout.text("NOT normally bonded by CSD criterion")
      stdout.flush
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else if (.analyze_all_atom_pairs) then
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD)")
      stdout.text("  AND if they are within a minimum bond_range_factor")
      stdout.flush
      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
      stdout.show("No. of 'bonds'          =",no_of_bonds)
      else
      stdout.text(". Indices appear only for atom pairs which are connected")
      stdout.text("  according to the Cambridge Structural Database (CSD).")
      stdout.flush
      stdout.show("No. of bonds =",no_of_bonds)
      end
      stdout.flush

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(9)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.atom(:).tag)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("R(A--B)")
      table(4).set_subheading("/Angs.")
      table(4).set_width_from(ONE)

      table(5).set_heading(" Cov.")
      table(5).set_subhead("index")
      table(5).set_width_from(-TEN)
      table(6).set_heading("Ionic")
      table(6).set_subhead("index")
      table(6).set_width_from(-TEN)
      table(7).set_heading(" Bond")
      table(7).set_subhead("index")
      table(7).set_width_from(ONE)
      table(8).set_heading("% Cov")
      table(8).set_subhead("Pythag.")
      table(8).set_width_from(100d0)
      table(9).set_heading("% Cov")
      table(9).set_subhead("Araki")
      table(9).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)
         aAB.create(n_bonds)

         do i = 1,n_bonds
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency_P(pair(i,1),pair(i,2))
         aAB(i) = .percent_covalency_A(pair(i,1),pair(i,2))
         end

         ! Sort & rearrange
         ind.create(n_bonds)
         tAB.quick_sort(ind,decreasing_order=TRUE)
         labels(:,1) = labels(ind,1)
         labels(:,2) = labels(ind,2)
         dist = dist(ind)
         cAB  = cAB(ind)
         iAB  = iAB(ind)
         tAB  = tAB(ind)
         pAB  = pAB(ind)
         aAB  = aAB(ind)

         ! Set table data
         table(1).set_values(labels(:,1))
         table(2).set_values(dash)
         table(3).set_values(labels(:,2))
         table(4).set_values(dist)
         table(5).set_values(cAB)
         table(6).set_values(iAB)
         table(7).set_values(tAB)
         table(8).set_values(pAB)
         table(9).set_values(aAB)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns

         ind.destroy
         aAB.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

      ! Revert & unsave
      stdout.revert
      stdout.unsave

   end

   put_file_indices_atoms
   ! Output bond indices in separate files "rgbi-A-B" where A and B
   ! are the elemnt labels.
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      table :: VEC{TABLE_COLUMN}@
      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
      pair :: MAT{INT}@
      symbols,labels :: MAT{STR}@
      dash,dsh1 :: VEC{STR}@
      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(14)

      ! Set the table headings
      table( 1).set_heading("A")
      table( 1).set_width_from(.atom.chemical_symbols)

      table( 2).set_heading("B")
      table( 2).set_width(table(1).width)

      table( 3).set_heading("A")
      table( 3).set_width_from(.atom(:).tag)

      table( 4).set_heading("B")
      table( 4).set_width(table(3).width)

      table( 5).set_heading("R(A--B)")
      table( 5).set_subheading("/Angs.")
      table( 5).set_width_from(ONE)

      table( 6).set_heading("n_A")
      table( 6).set_width_from(TEN)

      table( 7).set_heading("n_B")
      table( 7).set_width_from(TEN)

      table( 8).set_heading("n_AB")
      table( 8).set_width_from(TEN)

      table( 9).set_heading("s_AB")
      table( 9).set_width_from(TEN)

      table(10).set_heading(" Cov.")
      table(10).set_subhead("index")
      table(10).set_width_from(-TEN)

      table(11).set_heading("Ionic")
      table(11).set_subhead("index")
      table(11).set_width_from(-TEN)

      table(12).set_heading(" Bond")
      table(12).set_subhead("index")
      table(12).set_width_from(ONE)

      table(13).set_heading("% Cov")
      table(13).set_subhead("Pythag.")
      table(13).set_width_from(100d0)

      table(14).set_heading("% Cov")
      table(14).set_subhead("Araki")
      table(14).set_width_from(100d0)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols(:,1) = .atom(Z_list(k1)[1]).chemical_symbol
         symbols(:,2) = .atom(Z_list(k2)[1]).chemical_symbol

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         n_A.create(n_bonds)
         n_B.create(n_bonds)
         nAB.create(n_bonds)
         sAB.create(n_bonds)
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)
         aAB.create(n_bonds)

         n_A = .n1(pair(:,1))
         n_B = .n1(pair(:,2))
         forall (i=1:n_bonds)
         nAB(i) = .n2(pair(i,1),pair(i,2))
         sAB(i) = n_A(i) + n_B(i) - nAB(i)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency_P(pair(i,1),pair(i,2))
         aAB(i) = .percent_covalency_A(pair(i,1),pair(i,2))
         end

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(symbols(:,2))
         table( 3).set_values(labels(:,1))
         table( 4).set_values(labels(:,2))
         table( 5).set_values(dist)
         table( 6).set_values(n_A)
         table( 7).set_values(n_B)
         table( 8).set_values(nAB)
         table( 9).set_values(sAB)
         table(10).set_values(cAB)
         table(11).set_values(iAB)
         table(12).set_values(tAB)
         table(13).set_values(pAB)
         table(14).set_values(aAB)

         ! Put body
         stdout.flush
         stdout.redirect("rgbi-data-"//trim(symbols(1,1))//"-"//trim(symbols(1,2)))
         table.put_body(label_rows=FALSE)
         stdout.revert

         ! Clean
         table.clear_columns

         aAB.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         sAB.destroy
         nAB.destroy
         n_B.destroy
         n_A.destroy
         labels.destroy
         dsh1.destroy
         dash.destroy
         symbols.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
    ! table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      Z_list.destroy

      ! Unsave
      stdout.unsave

   end


   put_bond_indices_do_H
   ! Output bond indices including H's in LaTeX "rgbi-bondtable+H.tex".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i,a,n :: INT
      pair :: MAT{INT}@
      labels :: MAT{STR}@
      dash :: VEC{STR}@
      s1,s2,val :: STR
      dist,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return


      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)
      stdout.redirect("rgbi-bondtable+H.tex")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)
         aAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency_P(pair(i,1),pair(i,2))
         aAB(i) = .percent_covalency_A(pair(i,1),pair(i,2))
         end

         ! Put latex table
         s1 = .atom(pair(1,1)).chemical_symbol
         s2 = .atom(pair(1,2)).chemical_symbol
         stdout.text("% "//trim(s1)//"--"//trim(s2)//" bonds")

         do a = 1,pair.dim1
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(pair(a,1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(pair(a,2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            if (.output_ci_latex_labels) then
               val = REAL:to_str(iAB(a),"f10.2",left_justify=TRUE)
            else
               val = REAL:to_str(tAB(a),"f10.2",left_justify=TRUE)
            end
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            if (.output_ci_latex_labels) then
               val = REAL:to_str(cAB(a),"f10.2",left_justify=TRUE)
            else
               val = INT:to_str(nint(aAB(a)),"i3",left_justify=TRUE)
            end
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush
         end

         ! Clean
         aAB.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      Z_list.destroy

      ! Revert & unsave
      stdout.revert
      stdout.unsave

      ! New atom labels    
      stdout.redirect("rgbi-atom-labels+H.tex")
      n = .atom.dim
      stdout.text("% New atom labels")
      stdout.text("\pgfkeys{%")
      do a = 1,n
         stdout.put("/atom no/"//trim(a.to_str)//"/.code="//trim(a.to_str))
         if (a<n) then
         stdout.put(",",width=1)
         else
         stdout.put("}",width=1)
         end
         stdout.flush
      end
      stdout.flush
      stdout.text("% New atom label command")
      stdout.text("\let\oldmcfatomno\mcfatomno")
      stdout.text("\renewcommand{\mcfatomno}[1]{\oldmcfatomno{\pgfkeys{/atom no/#1}}}")

      ! Revert & unsave
      stdout.revert

   end

   put_bond_indices_do_H_vdw
   ! Output bond indices including H's and shortest vdw bond in LaTeX
   ! script "rgbi-bondtable+H+vdw.tex".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i,a :: INT
      pair :: MAT{INT}@
      labels :: MAT{STR}@
      dash :: VEC{STR}@
      vdw :: VEC{INT}(2)
      s1,s2,val :: STR
      dist,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return
      if (NOT .atom.has_vdw_bond) return


      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)
      stdout.redirect("rgbi-bondtable+H+vdw.tex")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)
         aAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency_P(pair(i,1),pair(i,2))
         aAB(i) = .percent_covalency_A(pair(i,1),pair(i,2))
         end

         ! Put latex table
         s1 = .atom(pair(1,1)).chemical_symbol
         s2 = .atom(pair(1,2)).chemical_symbol
         stdout.text("% "//trim(s1)//"--"//trim(s2)//" bonds")

         do a = 1,pair.dim1
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(pair(a,1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(pair(a,2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = REAL:to_str(tAB(a),"f10.2",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = INT:to_str(nint(aAB(a)),"i3",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush
         end

         ! Clean
         aAB.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      Z_list.destroy

      ! Now put the shortest vdw bond
      stdout.text("% Shortest vdw bond")

      ! Get shortest vdw bond
      vdw = .atom.shortest_vdw_bond

         ! Allocate & get
         tAB.create(1)
         aAB.create(1)

         tAB(1) = .bond_index(vdw(1),vdw(2))
         aAB(1) = .percent_covalency_A(vdw(1),vdw(2))

            ! Print tabele
            stdout.put("\namebond{a",width=11)
            val = INT:to_str(vdw(1))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            val = INT:to_str(vdw(2))
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = REAL:to_str(tAB(1),"f10.2",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            val = INT:to_str(nint(aAB(1)),"i3",left_justify=TRUE)
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush

         ! Clean
         aAB.destroy
         tAB.destroy

      ! Revert & unsave
      stdout.revert
      stdout.unsave

   end

   put_bond_indices_no_H
   ! Output the non-H bond indices in LaTex "rgbi-bondtable-H.tex".
      self :: IN

   ENSURE(NOT .is_homoleptic,"job is homoleptic")

      Z_list :: VEC{EVEC{INT}}@
      no_of_bonds, n_kind,k1,k2,n_bonds, i,a,b,n,m :: INT
      pair :: MAT{INT}@
      labels :: MAT{STR}@
      dash :: VEC{STR}@
      s1,s2,val :: STR
      dist,cAB,iAB,tAB,pAB,aAB :: VEC{REAL}@
      non_H_atom_for_atom,non_H_atom :: VEC{INT}@
      has_unique_labels :: BIN

      ! Anything to do?
      if (.atom.dim<2) return

      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
      if (no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .atom.has_unique_labels
      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")

      ! Redo decimal places
      stdout.save
      stdout.set_real_precision(2)
      stdout.redirect("rgbi-bondtable-H.tex")

      ! Get atom Z list
      .atom.make_atom_Z_list(Z_list)

      ! Skip dummy atoms
      n_kind = Z_list.dim
      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Non-H atom indices - openbabel renumbers indices
      non_H_atom_for_atom = .atom.indices_of_non_H_atom_for_atom

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         if (.atom(Z_list(k1)[1]).atomic_number==1) cycle
         if (.atom(Z_list(k2)[1]).atomic_number==1) cycle

         ! Get the bonded atoms per kind
         if (.analyze_vdw_atom_pairs) then
         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         else
         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
         end
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Dashes
         dash.create(n_bonds)
         dash    = "--"

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = .atom(pair(:,1)).tag
         labels(:,2) = .atom(pair(:,2)).tag

         ! Populations & indices
         cAB.create(n_bonds)
         iAB.create(n_bonds)
         tAB.create(n_bonds)
         pAB.create(n_bonds)
         aAB.create(n_bonds)

         forall (i=1:n_bonds)
         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
         tAB(i) = .bond_index(pair(i,1),pair(i,2))
         pAB(i) = .percent_covalency_P(pair(i,1),pair(i,2))
         aAB(i) = .percent_covalency_A(pair(i,1),pair(i,2))
         end

         ! Put latex table
         s1 = .atom(pair(1,1)).chemical_symbol
         s2 = .atom(pair(1,2)).chemical_symbol
         stdout.text("% "//trim(s1)//"--"//trim(s2)//" bonds")

         do a = 1,pair.dim1
            stdout.put("\namebond{a",width=11)
            b   = non_H_atom_for_atom(pair(a,1))
            val = INT:to_str(b)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{a",width=3)
            b   = non_H_atom_for_atom(pair(a,2))
            val = INT:to_str(b)
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            if (.output_ci_latex_labels) then
               val = REAL:to_str(iAB(a),"f10.2",left_justify=TRUE)
            else
               val = REAL:to_str(tAB(a),"f10.2",left_justify=TRUE)
            end
            stdout.put(val,width=len_trim(val))
            stdout.put("}{",width=2)
            if (.output_ci_latex_labels) then
               val = REAL:to_str(cAB(a),"f10.2",left_justify=TRUE)
            else
               val = INT:to_str(nint(aAB(a)),"i3",left_justify=TRUE)
            end
            stdout.put(val,width=len_trim(val))
            stdout.put("}",width=1)
            stdout.flush
         end

         ! Clean
         aAB.destroy
         pAB.destroy
         tAB.destroy
         iAB.destroy
         cAB.destroy
         labels.destroy
         dash.destroy

         dist.destroy
         pair.destroy

      end
      end

      ! Clean
      Z_list.destroy

      ! Revert & unsave
      stdout.revert
      stdout.unsave

      ! New atom labels    
      non_H_atom = .atom.list_of_non_H_atoms
      stdout.redirect("rgbi-atom-labels-H.tex")
      n = .atom.dim
      m = non_H_atom.dim
      stdout.text("% New atom labels")
      stdout.text("\pgfkeys{%")
      do b = 1,m
         a = non_H_atom(b)
         stdout.put("/atom no/"//trim(b.to_str)//"/.code="//trim(a.to_str))
         if (b<m) then
         stdout.put(",",width=1)
         else
         stdout.put("}",width=1)
         end
         stdout.flush
      end
      stdout.flush
      stdout.text("% New atom label command")
      stdout.text("\let\oldmcfatomno\mcfatomno")
      stdout.text("\renewcommand{\mcfatomno}[1]{\oldmcfatomno{\pgfkeys{/atom no/#1}}}")

      ! Revert & unsave
      stdout.revert

   end

!   put_bond_indices_CC
!   ! Output the only CC bond indices table in file "bondtable-cc".
!      self :: IN
!
!   ENSURE(NOT .is_homoleptic,"job is homoleptic")
!
!      table :: VEC{TABLE_COLUMN}*
!      Z_list :: VEC{VEC_{INT}}*
!      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
!      pair :: MAT{INT}*
!      labels :: MAT{STR}*
!      dist,cAB,iAB,tAB :: VEC{REAL}*
!      has_unique_labels :: BIN
!
!      ! Anything to do?
!      if (.atom.dim<2) return
!
!      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
!      if (no_of_bonds<1) return
!
!      ! Has unique labels?
!      has_unique_labels = .atom.has_unique_labels
!      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")
!
!      ! Redo decimal places
!      stdout.save
!      stdout.set_real_precision(2)
!
!      ! Redo decimal places
!      stdout.save
!      stdout.set_real_precision(2)
!      stdout.redirect("bondtable-CC")
!
!      ! Get atom Z list
!      .atom.make_atom_Z_list(Z_list)
!
!      ! Skip dummy atoms
!      n_kind = Z_list.dim
!      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1
!
!      ! Create table
!      table.create(6)
!
!      ! Set the table headings
!      table(1).set_heading("A")
!      table(1).set_width_from(.atom(:).tag)
!
!      table(2).set_heading("B")
!      table(2).set_width(table(1).width)
!
!      table(3).set_heading(" Cov.")
!      table(3).set_subhead("index")
!      table(3).set_width_from(-TEN)
!
!      table(4).set_heading("Ionic")
!      table(4).set_subhead("index")
!      table(4).set_width_from(-TEN)
!
!      table(5).set_heading(" Bond")
!      table(5).set_subhead("index")
!      table(5).set_width_from(ONE)
!
!      ! Loop over atom kind classes
!      do k1 = 1,n_kind
!      do k2 = k1,n_kind
!
!         ! Skip non-C atoms
!         if (.atom(Z_list(k1)[1]).atomic_number/=6) cycle
!         if (.atom(Z_list(k2)[1]).atomic_number/=6) cycle
!
!         ! Get the bonded atoms per kind
!         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         dist = dist*ANGSTROM_PER_BOHR
!
!         ! No of bonds in this class
!         n_bonds = dist.dim
!         if (n_bonds==0) then
!            dist.destroy
!            pair.destroy
!            cycle
!         end
!
!         ! Labels
!         labels.create(n_bonds,2)
!         labels(:,1) = .atom(pair(:,1)).tag
!         labels(:,2) = .atom(pair(:,2)).tag
!
!         ! Extract number-part only
!         labels(:,1) = labels(:,1)(2:)
!         labels(:,2) = labels(:,2)(2:)
!
!         ! Populations & indices
!         cAB.create(n_bonds)
!         iAB.create(n_bonds)
!         tAB.create(n_bonds)
!
!         forall (i=1:n_bonds)
!         cAB(i) =  .cov_index(pair(i,1),pair(i,2))
!         iAB(i) =  .ion_index(pair(i,1),pair(i,2))
!         tAB(i) = .bond_index(pair(i,1),pair(i,2))
!         end
!
!         ! Set table data
!         table(1).create_values(labels(:,1))
!         table(2).create_values(labels(:,2))
!         table(3).create_values(cAB)
!         table(4).create_values(iAB)
!         table(5).create_values(tAB)
!
!         ! Put info
!         stdout.put(.atom.molecular_weight)
!         stdout.flush
!         stdout.put(tAB.dim)
!         stdout.flush
!         table.put_body(label_rows=FALSE)
!
!         ! Clean
!         table.clear_columns
!
!         tAB.destroy
!         iAB.destroy
!         cAB.destroy
!         labels.destroy
!
!         dist.destroy
!         pair.destroy
!
!      end
!      end
!
!      ! Clean
!      table.destroy
!      Z_list.destroy
!
!      ! Revert & unsave
!      stdout.revert
!      stdout.unsave
!
!   end

! ===============
! Output energies
! ===============

!   put_all_energy_info
!   ! Put to stdout the energy bond analysis
!      self :: IN
!
!      .put_basics
!      .put_energies
!     ! .put_ci_energies
!
!   end

!   put_energies
!   ! Put to stdout the only Roby atom energies
!      self :: IN
!
!   ENSURE(.atom.associated,"no atom data")
!   ENSURE(.E1.allocated,"no atom energies exist")
!
!      table :: VEC{TABLE_COLUMN}*
!      symbols :: VEC{STR}*
!      labels :: VEC{INT}*
!      e_scf,e_nuc,e_tot,e_prj :: REAL
!      P :: MAT{REAL}*
!      f,n_gr :: INT
!
!
!      stdout.flush
!      stdout.text("==================")
!      stdout.text("Roby atom energies")
!      stdout.text("==================")
!    ! stdout.flush
!    ! stdout.text(". Half of the nuclear-nuclear repulsion energies")
!    ! stdout.text("  for all other atoms are included in the total")
!      stdout.flush
!      stdout.text(". Energies are in atomic units")
!      stdout.flush
!
!      ! Get SCF energy from Krogel E_matrix without projection
!      ! WARNING: restricted case only so far
!      e_scf = .E_expectation
!      e_prj = .atom_energy
!      e_nuc = .atom.nuclear_repulsion_energy
!      e_tot = e_scf + e_nuc
!
!      ! Make small P matrix
!    ! f = 1
!    ! labels => f.sequence_up_to(.n_group)
!    ! n_gr = .n_bf(labels)
!    ! P.create(n_gr,n_gr)
!    ! .make_projection_matrix(P,labels)
!    ! e_prj = .E_expectation(P,labels)
!    ! labels.destroy
!    ! P.destroy
!
!    ! stdout.show("Total SCF energy          = ",e_tot)
!      stdout.show("SCF electronic energy       = ",e_scf)
!      stdout.show("Projected electronic energy = ",e_prj)
!      stdout.show("Nuclear repulsion energy    = ",e_nuc)
!      stdout.flush
!
!      ! Create table
!      table.create(2)
!
!      ! Set the table headings
!      table(1).set_heading("Atom")
!      table(1).set_width_from(.atom.chemical_symbols)
!
!      if (.is_homoleptic) then
!         symbols.create(.n_group)
!         labels.create(.n_group)
!         f = 1
!         labels => f.sequence_up_to(.n_group)
!         symbols = labels.to_str
!         labels.destroy
!      else
!         symbols => .unique_tags
!      end
!
!      ! Datas
!      table(1).set_values(symbols)
!      table(2).set_heading(" Energy")
!      table(2).set_subhead("    /au")
!      table(2).set_values(.E1)
!
!      ! Put table
!      table.put(label_rows=FALSE)
!
!      ! Clean
!      table.clear_columns
!      symbols.destroy
!
!   end

!   put_ci_energies
!   ! Output the covalent (shared) and ionic (transferred) energies.
!      self :: IN
!
!   ENSURE(NOT .is_homoleptic,"job is homoleptic")
!   ENSURE(.E1.associated,"no atom energies exist")
!   ENSURE(.E2.associated,"no atom pair energies exist")
!
!      table :: VEC{TABLE_COLUMN}*
!      Z_list :: VEC{VEC_{INT}}*
!      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
!      pair :: MAT{INT}*
!      symbols,labels :: MAT{STR}*
!      dash,dsh1 :: VEC{STR}*
!      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
!      has_unique_labels :: BIN
!
!      ! Anything to do?
!      if (.atom.dim<2) return
!
!      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
!      if (no_of_bonds<1) return
!
!      ! Has unique labels?
!      has_unique_labels = .atom.has_unique_labels
!      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")
!
!      ! Title
!      if (.analyze_vdw_atom_pairs) then
!      stdout.flush
!      stdout.text("==============================================")
!      stdout.text("Roby-Gould covalent & ionic energies: VDW only")
!      stdout.text("==============================================")
!      else
!      stdout.flush
!      stdout.text("====================================")
!      stdout.text("Roby-Gould covalent & ionic energies")
!      stdout.text("====================================")
!      end
!
!      stdout.flush
!      if (.analyze_vdw_atom_pairs) then
!      stdout.text("Energy bond indices appear only for VDW bonded atom")
!      stdout.text("pairs NOT normally bonded by the CSD criterion")
!      stdout.flush
!      stdout.show("No. of 'bonds'          =",no_of_bonds)
!      else if (.analyze_all_atom_pairs) then
!      stdout.text("Energy bond indices appear only for atom pairs connected")
!      stdout.text("according to the Cambridge Structural Database (CSD)")
!      stdout.text("AND if they are within a minimum bond_range_factor")
!      stdout.flush
!      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
!      stdout.show("No. of 'bonds'          =",no_of_bonds)
!      else
!      stdout.text("Energy bond indices appear only for atom pairs connected")
!      stdout.text("according to the Cambridge Structural Database (CSD).")
!      stdout.flush
!      stdout.show("No. of bonds =",no_of_bonds)
!      end
!      stdout.flush
!
!      ! Get atom Z list
!      .atom.make_atom_Z_list(Z_list)
!
!      ! Skip dummy atoms
!      n_kind = Z_list.dim
!      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1
!
!      ! Create table
!      table.create(11)
!
!      ! Set the table headings
!      table( 1).set_heading("A")
!      table( 1).set_width_from(.atom.chemical_symbols)
!
!      table( 2).set_spacing(0)
!      table( 2).set_heading("--")
!      table( 2).set_width(2)
!
!      table( 3).set_heading("B")
!      table( 3).set_width(table(1).width)
!      table( 3).set_left_justify(TRUE)
!
!      table( 4).set_heading("A")
!      table( 4).set_width_from(.atom(:).tag)
!
!      table( 5).set_spacing(0)
!      table( 5).set_heading("--")
!      table( 5).set_width(2)
!
!      table( 6).set_heading("B")
!      table( 6).set_width(table(4).width)
!      table( 6).set_left_justify(TRUE)
!
!      table( 7).set_heading("R(A--B)")
!      table( 7).set_subheading("/Angs.")
!      table( 7).set_width_from(ONE)
!
!      table( 8).set_heading("E_A")
!      table( 8).set_width_from(-100d0)
!      table( 9).set_heading("E_B")
!      table( 9).set_width_from(-100d0)
!      table(10).set_heading("E_AB")
!      table(10).set_width_from(-100d0)
!      table(11).set_heading("E^s_AB")
!      table(11).set_width_from(-100d0)
!
!      ! Put out the headings
!      table.put_headings(label_rows=FALSE,no_flush=TRUE)
!
!      ! Loop over atom kind classes
!      do k1 = 1,n_kind
!      do k2 = k1,n_kind
!
!         ! Get the bonded atoms per kind
!         if (.analyze_vdw_atom_pairs) then
!         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         else
!         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         end
!         dist = dist*ANGSTROM_PER_BOHR
!
!         ! No of bonds in this class
!         n_bonds = dist.dim
!         if (n_bonds==0) then
!            dist.destroy
!            pair.destroy
!            cycle
!         end
!
!         ! Element symbols
!         symbols.create(n_bonds,2)
!         symbols = " "
!         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
!         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol
!
!         ! Dashes
!         dash.create(n_bonds)
!         dsh1.create(n_bonds)
!         dash    = "--"
!         dsh1    = "  "
!         dsh1(1) = "--"
!
!         ! Labels
!         labels.create(n_bonds,2)
!         labels(:,1) = .atom(pair(:,1)).tag
!         labels(:,2) = .atom(pair(:,2)).tag
!
!         ! Populations & indices
!         n_A.create(n_bonds)
!         n_B.create(n_bonds)
!         nAB.create(n_bonds)
!         sAB.create(n_bonds)
!
!         n_A = .E1(pair(:,1))
!         n_B = .E1(pair(:,2))
!         do i = 1,n_bonds
!         nAB(i) = .E2(pair(i,1),pair(i,2))
!         sAB(i) = n_A(i) + n_B(i) - nAB(i)
!         end
!
!         ! Set table data
!         table( 1).set_values(symbols(:,1))
!         table( 2).set_values(dsh1)
!         table( 3).set_values(symbols(:,2))
!         table( 4).set_values(labels(:,1))
!         table( 5).set_values(dash)
!         table( 6).set_values(labels(:,2))
!         table( 7).set_values(dist)
!         table( 8).set_values(n_A)
!         table( 9).set_values(n_B)
!         table(10).set_values(nAB)
!         table(11).set_values(sAB)
!
!         ! Put body
!         stdout.flush
!         table.put_body(label_rows=FALSE)
!
!         ! Clean
!         table.clear_columns
!
!         sAB.destroy
!         nAB.destroy
!         n_B.destroy
!         n_A.destroy
!         labels.destroy
!         dsh1.destroy
!         dash.destroy
!         symbols.destroy
!
!         dist.destroy
!         pair.destroy
!
!      end
!      end
!
!      ! Table footer
!      table.put_footer(label_rows=FALSE)
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!      Z_list.destroy
!
!   end

!   put_energy_indices
!   ! Put to stdout the Roby bond indices, including the shared populations
!      self :: IN
!
!      if (.is_homoleptic) then
!
!         .put_energy_indices_group
!
!      else
!
!         .put_energy_indices_atoms
!         .put_energy_indices_sorted
!
!      end
!
!   end
!
!   put_energy_indices_group
!   ! Output the energy bond indices table for connected atoms.
!      self :: IN
!
!   ENSURE(.is_homoleptic,"job is not homoleptic")
!   ENSURE(.n_group>1,"must be at leat two groups")
!   ENSURE(.E1.associated,"no atom energies exist")
!   ENSURE(.E2.associated,"no atom pair energies exist")
!
!      table :: VEC{TABLE_COLUMN}*
!      symbol :: VEC{STR}*
!      g_A,g_B :: VEC{INT}*
!      n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
!      n_group, n_pair,i,a,b :: INT
!
!      n_group = .n_group
!
!      ! Title
!      stdout.flush
!      stdout.flush
!      stdout.text("==============================")
!      stdout.text("Roby-Gould energy bond indices")
!      stdout.text("==============================")
!      stdout.flush
!      stdout.text("Energy bond indices appear only between atom groups.")
!      stdout.flush
!      symbol => .unique_tags
!      do i = 1,n_group
!      stdout.show("Group "//trim(i.to_str(fmt="i2"))//" = ",symbol(i))
!      end
!      symbol.destroy
!      stdout.flush
!
!      ! Create table
!      table.create(10)
!
!      ! Set the table headings
!      table( 1).set_heading("Grp")
!      table( 1).set_subhead("  A")
!      table( 2).set_heading("Grp")
!      table( 2).set_subhead("  B")
!      table( 3).set_heading("E_A")
!      table( 3).set_width_from(TEN)
!      table( 4).set_heading("E_B")
!      table( 4).set_width_from(TEN)
!      table( 5).set_heading("E_AB")
!      table( 5).set_width_from(TEN)
!      table( 6).set_heading("E^s_AB")
!      table( 6).set_width_from(TEN)
!      table( 7).set_heading("E Cov")
!      table( 7).set_subhead("index")
!      table( 7).set_width_from(-TEN)
!      table( 8).set_heading("E Ion")
!      table( 8).set_subhead("index")
!      table( 8).set_width_from(-TEN)
!      table( 9).set_heading("E Bond")
!      table( 9).set_subhead(" index")
!      table( 9).set_width_from(ONE)
!      table(10).set_heading("% E")
!      table(10).set_subhead("Cov")
!      table(10).set_width_from(100d0)
!
!      ! Put out the headings
!      table.put_headings(label_rows=FALSE,no_flush=TRUE)
!
!      ! Populations & indices
!      n_pair = n_group - 1
!      n_pair = n_pair.triangle_number
!      g_A.create(n_pair)
!      g_B.create(n_pair)
!      n_A.create(n_pair)
!      n_B.create(n_pair)
!      nAB.create(n_pair)
!      sAB.create(n_pair)
!      cAB.create(n_pair)
!      iAB.create(n_pair)
!      tAB.create(n_pair)
!      pAB.create(n_pair)
!
!      i = 0
!      do a = 1,.n_group
!      do b = a+1,.n_group
!         i = i + 1
!         g_A(i) = a
!         g_B(i) = b
!         n_A(i) = .E1(a)
!         n_B(i) = .E1(b)
!         nAB(i) = .E2(a,b)
!         sAB(i) = .E1(a) + .E1(b) - .E2(a,b)
!         cAB(i) =  .E_cov_index(a,b)
!         iAB(i) =  .E_ion_index(a,b)
!         tAB(i) = .E_bond_index(a,b)
!         pAB(i) = .E_percent_covalency(a,b)
!      end
!      end
!
!      ! Set table data
!      table( 1).set_values(g_A)
!      table( 2).set_values(g_B)
!      table( 3).set_values(n_A)
!      table( 4).set_values(n_B)
!      table( 5).set_values(nAB)
!      table( 6).set_values(sAB)
!      table( 7).set_values(cAB)
!      table( 8).set_values(iAB)
!      table( 9).set_values(tAB)
!      table(10).set_values(pAB)
!
!      ! Put body
!      stdout.flush
!      table.put_body(label_rows=FALSE)
!
!      ! Clean
!      table.clear_columns
!
!      pAB.destroy
!      tAB.destroy
!      iAB.destroy
!      cAB.destroy
!      sAB.destroy
!      nAB.destroy
!      n_B.destroy
!      n_A.destroy
!
!      ! Table footer
!      table.put_footer(label_rows=FALSE)
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!
!   end
!
!   put_energy_indices_atoms
!   ! Output the energy bond indices table for connected atoms.
!      self :: IN
!
!   ENSURE(NOT .is_homoleptic,"job is homoleptic")
!   ENSURE(.E1.associated,"no atom energies exist")
!   ENSURE(.E2.associated,"no atom pair energies exist")
!
!      table :: VEC{TABLE_COLUMN}*
!      Z_list :: VEC{VEC_{INT}}*
!      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
!      pair :: MAT{INT}*
!      symbols,labels :: MAT{STR}*
!      dash,dsh1 :: VEC{STR}*
!      dist,n_A,n_B,nAB,sAB,cAB,iAB,tAB,pAB :: VEC{REAL}*
!      has_unique_labels :: BIN
!
!      ! Anything to do?
!      if (.atom.dim<2) return
!
!      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
!      if (no_of_bonds<1) return
!
!      ! Has unique labels?
!      has_unique_labels = .atom.has_unique_labels
!      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")
!
!      ! Title
!      if (.analyze_vdw_atom_pairs) then
!      stdout.flush
!      stdout.text("========================================")
!      stdout.text("Roby-Gould energy bond indices: VDW only")
!      stdout.text("========================================")
!      else
!      stdout.flush
!      stdout.text("==============================")
!      stdout.text("Roby-Gould energy bond indices")
!      stdout.text("==============================")
!      end
!
!      stdout.flush
!      if (.analyze_vdw_atom_pairs) then
!      stdout.text("Energy bond indices appear only for VDW bonded atom")
!      stdout.text("pairs NOT normally bonded by the CSD criterion")
!      stdout.flush
!      stdout.show("No. of 'bonds'          =",no_of_bonds)
!      else if (.analyze_all_atom_pairs) then
!      stdout.text("Energy bond indices appear only for atom pairs connected")
!      stdout.text("according to the Cambridge Structural Database (CSD)")
!      stdout.text("AND if they are within a minimum bond_range_factor")
!      stdout.flush
!      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
!      stdout.show("No. of 'bonds'          =",no_of_bonds)
!      else
!      stdout.text("Energy bond indices appear only for atom pairs connected")
!      stdout.text("according to the Cambridge Structural Database (CSD).")
!      stdout.flush
!      stdout.show("No. of bonds =",no_of_bonds)
!      end
!      stdout.flush
!
!      ! Get atom Z list
!      .atom.make_atom_Z_list(Z_list)
!
!      ! Skip dummy atoms
!      n_kind = Z_list.dim
!      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1
!
!      ! Create table
!      table.create(15)
!
!      ! Set the table headings
!      table( 1).set_heading("A")
!      table( 1).set_width_from(.atom.chemical_symbols)
!
!      table( 2).set_column_spacing(0)
!      table( 2).set_heading("--")
!      table( 2).set_width(2)
!
!      table( 3).set_heading("B")
!      table( 3).set_width(table(1).width)
!      table( 3).set_left_justify(TRUE)
!
!      table( 4).set_heading("A")
!      table( 4).set_width_from(.atom(:).tag)
!
!      table( 5).set_column_spacing(0)
!      table( 5).set_heading("--")
!      table( 5).set_width(2)
!
!      table( 6).set_heading("B")
!      table( 6).set_width(table(4).width)
!      table( 6).set_left_justify(TRUE)
!
!      table( 7).set_heading("R(A--B)")
!      table( 7).set_subheading("/Angs.")
!      table( 7).set_width_from(ONE)
!
!      table( 8).set_heading("E_A")
!      table( 8).set_width_from(-100d0)
!      table( 9).set_heading("E_B")
!      table( 9).set_width_from(-100d0)
!      table(10).set_heading("E_AB")
!      table(10).set_width_from(-100d0)
!      table(11).set_heading("E^s_AB")
!      table(11).set_width_from(-100d0)
!      table(12).set_heading("E Cov")
!      table(12).set_subhead("index")
!      table(12).set_width_from(-100d0)
!      table(13).set_heading("E Ion")
!      table(13).set_subhead("index")
!      table(13).set_width_from(-100d0)
!      table(14).set_heading("E Bond")
!      table(14).set_subhead(" index")
!      table(14).set_width_from(-100d0)
!      table(15).set_heading("% E")
!      table(15).set_subhead("Cov")
!      table(15).set_width_from(100d0)
!
!      ! Put out the headings
!      table.put_headings(label_rows=FALSE,no_flush=TRUE)
!
!      ! Loop over atom kind classes
!      do k1 = 1,n_kind
!      do k2 = k1,n_kind
!
!         ! Get the bonded atoms per kind
!         if (.analyze_vdw_atom_pairs) then
!         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         else
!         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         end
!         dist = dist*ANGSTROM_PER_BOHR
!
!         ! No of bonds in this class
!         n_bonds = dist.dim
!         if (n_bonds==0) then
!            dist.destroy
!            pair.destroy
!            cycle
!         end
!
!         ! Element symbols
!         symbols.create(n_bonds,2)
!         symbols = " "
!         symbols(1,1) = .atom(Z_list(k1)[1]).chemical_symbol
!         symbols(1,2) = .atom(Z_list(k2)[1]).chemical_symbol
!
!         ! Dashes
!         dash.create(n_bonds)
!         dsh1.create(n_bonds)
!         dash    = "--"
!         dsh1    = "  "
!         dsh1(1) = "--"
!
!         ! Labels
!         labels.create(n_bonds,2)
!         labels(:,1) = .atom(pair(:,1)).tag
!         labels(:,2) = .atom(pair(:,2)).tag
!
!         ! Populations & indices
!         n_A.create(n_bonds)
!         n_B.create(n_bonds)
!         nAB.create(n_bonds)
!         sAB.create(n_bonds)
!         cAB.create(n_bonds)
!         iAB.create(n_bonds)
!         tAB.create(n_bonds)
!         pAB.create(n_bonds)
!
!         n_A = .E1(pair(:,1))
!         n_B = .E1(pair(:,2))
!         do i = 1,n_bonds
!         nAB(i) = .E2(pair(i,1),pair(i,2))
!         sAB(i) = n_A(i) + n_B(i) - nAB(i)
!         cAB(i) =  .E_cov_index(pair(i,1),pair(i,2))
!         iAB(i) =  .E_ion_index(pair(i,1),pair(i,2))
!         tAB(i) = .E_bond_index(pair(i,1),pair(i,2))
!         pAB(i) = .E_percent_covalency(pair(i,1),pair(i,2))
!         end
!
!         ! Set table data
!         table( 1).set_values(symbols(:,1))
!         table( 2).set_values(dsh1)
!         table( 3).set_values(symbols(:,2))
!         table( 4).set_values(labels(:,1))
!         table( 5).set_values(dash)
!         table( 6).set_values(labels(:,2))
!         table( 7).set_values(dist)
!         table( 8).set_values(n_A)
!         table( 9).set_values(n_B)
!         table(10).set_values(nAB)
!         table(11).set_values(sAB)
!         table(12).set_values(cAB)
!         table(13).set_values(iAB)
!         table(14).set_values(tAB)
!         table(15).set_values(pAB)
!
!         ! Put body
!         stdout.flush
!         table.put_body(label_rows=FALSE)
!
!         ! Clean
!         table.clear_columns
!
!         pAB.destroy
!         tAB.destroy
!         iAB.destroy
!         cAB.destroy
!         sAB.destroy
!         nAB.destroy
!         n_B.destroy
!         n_A.destroy
!         labels.destroy
!         dsh1.destroy
!         dash.destroy
!         symbols.destroy
!
!         dist.destroy
!         pair.destroy
!
!      end
!      end
!
!      ! Table footer
!      table.put_footer(label_rows=FALSE)
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!      Z_list.destroy
!
!   end
!
!   put_energy_indices_sorted
!   ! Output the energy bond indices table for connected atoms.
!      self :: IN
!
!   ENSURE(NOT .is_homoleptic,"job is homoleptic")
!
!      table :: VEC{TABLE_COLUMN}*
!      Z_list :: VEC{VEC_{INT}}*
!      no_of_bonds, n_kind,k1,k2,n_bonds, i :: INT
!      pair :: MAT{INT}*
!      labels :: MAT{STR}*
!      dash :: VEC{STR}*
!      dist,cAB,iAB,tAB,pAB :: VEC{REAL}*
!      ind :: VEC{INT}*
!      has_unique_labels :: BIN
!
!      ! Anything to do?
!      if (.atom.dim<2) return
!
!      no_of_bonds = .atom.no_of_bonds(.bond_range_factor)
!      if (no_of_bonds<1) return
!
!      ! Has unique labels?
!      has_unique_labels = .atom.has_unique_labels
!      DIE_IF(NOT has_unique_labels,"atoms are not uniquely labelled!")
!
!      ! Title
!      if (.analyze_vdw_atom_pairs) then
!      stdout.flush
!      stdout.text("===============================================")
!      stdout.text("Sorted Roby-Gould energy bond indices: VDW only")
!      stdout.text("===============================================")
!      else
!      stdout.flush
!      stdout.text("=====================================")
!      stdout.text("Sorted Roby-Gould energy bond indices")
!      stdout.text("=====================================")
!      end
!
!      stdout.flush
!      stdout.text(". Energy bond indices are sorted from lowest to highest")
!      stdout.flush
!      if (.analyze_vdw_atom_pairs) then
!      stdout.text("Energy bond indices appear only for VDW bonded atom pairs")
!      stdout.text("and NOT normally bonded by the CSD criterion")
!      stdout.flush
!      stdout.show("No. of 'bonds'          =",no_of_bonds)
!      else if (.analyze_all_atom_pairs) then
!      stdout.text(". Energy bond indices appear only for atom pairs which connected")
!      stdout.text("  according to the Cambridge Structural Database (CSD)")
!      stdout.text("  AND if they are within a minimum bond_range_factor")
!      stdout.flush
!      stdout.show("Bond range factor /Angs =",.bond_range_factor.to_units("angstrom"))
!      stdout.show("No. of 'bonds'          =",no_of_bonds)
!      else
!      stdout.text(". Energy bond indices appear only for atom pairs which are connected")
!      stdout.text("  according to the Cambridge Structural Database (CSD).")
!      stdout.flush
!      stdout.show("No. of bonds =",no_of_bonds)
!      end
!      stdout.flush
!
!      ! Get atom Z list
!      .atom.make_atom_Z_list(Z_list)
!
!      ! Skip dummy atoms
!      n_kind = Z_list.dim
!      if (.atom(Z_list(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1
!
!      ! Create table
!      table.create(8)
!
!      ! Set the table headings
!      table(1).set_heading("A")
!      table(1).set_width_from(.atom(:).tag)
!
!      table(2).set_column_spacing(0)
!      table(2).set_heading("--")
!      table(2).set_width(2)
!
!      table(3).set_heading("B")
!      table(3).set_width(table(1).width)
!      table(3).set_left_justify(TRUE)
!
!      table(4).set_heading("R(A--B)")
!      table(4).set_subheading("/Angs.")
!      table(4).set_width_from(ONE)
!
!      table(5).set_heading("E Cov")
!      table(5).set_subhead("index")
!      table(5).set_width_from(-TEN)
!      table(6).set_heading("E Ion")
!      table(6).set_subhead("index")
!      table(6).set_width_from(-TEN)
!      table(7).set_heading("E Bond")
!      table(7).set_subhead(" index")
!      table(7).set_width_from(ONE)
!      table(8).set_heading("% E")
!      table(8).set_subhead("Cov")
!      table(8).set_width_from(100d0)
!
!      ! Put out the headings
!      table.put_headings(label_rows=FALSE,no_flush=TRUE)
!
!      ! Loop over atom kind classes
!      do k1 = 1,n_kind
!      do k2 = k1,n_kind
!
!         ! Get the bonded atoms per kind
!         if (.analyze_vdw_atom_pairs) then
!         .atom.get_vdw_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         else
!         .atom.get_bonded_atoms(pair,dist,Z_list,k1,k2,.bond_range_factor)
!         end
!         dist = dist*ANGSTROM_PER_BOHR
!
!         ! No of bonds in this class
!         n_bonds = dist.dim
!         if (n_bonds==0) then
!            dist.destroy
!            pair.destroy
!            cycle
!         end
!
!         ! Dashes
!         dash.create(n_bonds)
!         dash    = "--"
!
!         ! Labels
!         labels.create(n_bonds,2)
!         labels(:,1) = .atom(pair(:,1)).tag
!         labels(:,2) = .atom(pair(:,2)).tag
!
!         ! Populations & indices
!         cAB.create(n_bonds)
!         iAB.create(n_bonds)
!         tAB.create(n_bonds)
!         pAB.create(n_bonds)
!
!         do i  = 1,n_bonds
!         cAB(i) =  .E_cov_index(pair(i,1),pair(i,2))
!         iAB(i) =  .E_ion_index(pair(i,1),pair(i,2))
!         tAB(i) = .E_bond_index(pair(i,1),pair(i,2))
!         pAB(i) = .E_percent_covalency(pair(i,1),pair(i,2))
!         end
!
!         ! Sort & rearrange
!         ind.create(n_bonds)
!         tAB.quick_sort(ind,decreasing_order=TRUE)
!         labels(:,1) = labels(ind,1)
!         labels(:,2) = labels(ind,2)
!         dist = dist(ind)
!         cAB  = cAB(ind)
!         iAB  = iAB(ind)
!         tAB  = tAB(ind)
!         pAB  = pAB(ind)
!
!         ! Set table data
!         table(1).set_values(labels(:,1))
!         table(2).set_values(dash)
!         table(3).set_values(labels(:,2))
!         table(4).set_values(dist)
!         table(5).set_values(cAB)
!         table(6).set_values(iAB)
!         table(7).set_values(tAB)
!         table(8).set_values(pAB)
!
!         ! Put body
!         stdout.flush
!         table.put_body(label_rows=FALSE)
!
!         ! Clean
!         table.clear_columns
!
!         ind.destroy
!         pAB.destroy
!         tAB.destroy
!         iAB.destroy
!         cAB.destroy
!         labels.destroy
!         dash.destroy
!
!         dist.destroy
!         pair.destroy
!
!      end
!      end
!
!      ! Table footer
!      table.put_footer(label_rows=FALSE)
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!      Z_list.destroy
!
!   end

! ==============
! Output charges
! ==============

   put_charges
   ! Put to stdout the group charges.
      self :: IN

   ENSURE(.gould_charge.allocated,"no Roby-Gould charges")
   ENSURE(.cruickshank_charge.allocated,"no Cruickshank charges")
   ENSURE(.atom.associated,"no atom data")
   ENSURE(.atom_group.associated,"no atom group data")

      a :: INT
      homoleptic :: BIN
      symb :: STR
      symbol :: VEC{STR}@

      homoleptic = .is_homoleptic
      if (NOT homoleptic) symbol = .unique_tags

      stdout.flush
      stdout.text("Group charges:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Roby-Gould")
      stdout.put("Cruickshank")
      stdout.put("Sum_b  Sab/2")
      stdout.put("Sum_bc Sabc/3")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_group
         if (homoleptic) then; symb = a.to_str
         else                ; symb = symbol(a)
         end
         stdout.put(symb,int_width=TRUE)
         stdout.put(.gould_charge(a))
         stdout.put(.cruickshank_charge(a))
         stdout.put(.summed_n2(a)/TWO)
         stdout.put(.summed_n3(a)/THREE)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=4)

      if (NOT homoleptic) symbol.destroy

   end

   put_dipole_moments
   ! Dipole moments are calculated from the charges
      self :: IN

   ENSURE(.gould_charge.allocated,"no Roby-Gould charges")
   ENSURE(.cruickshank_charge.allocated,"no Cruickshank charges")
   ENSURE(.atom.associated,"no atom data")

      a :: INT
      gd,cd :: VEC{REAL}(3)

      gd = ZERO
      cd = ZERO

      do a = 1,.n_group
         gd(:) = gd(:) + .gould_charge(a)*.atom(a).position(:)
         cd(:) = cd(:) + .cruickshank_charge(a)*.atom(a).position(:)
      end

      ! Convert from AU to Debyes
      gd = gd * ("debye").conversion_factor
      cd = cd * ("debye").conversion_factor

      stdout.flush
      stdout.text("Dipole moments (in DEBYE):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Charge type")
      stdout.put("X")
      stdout.put("Y")
      stdout.put("Z")
      stdout.put("Magnitude")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.put("Roby-Gould")
      stdout.put(gd(1))
      stdout.put(gd(2))
      stdout.put(gd(3))
      stdout.put(sqrt(gd(1)**2 + gd(2)**2 + gd(3)**2))
      stdout.flush
      stdout.put("Cruickshank")
      stdout.put(cd(1))
      stdout.put(cd(2))
      stdout.put(cd(3))
      stdout.put(sqrt(cd(1)**2 + cd(2)**2 + cd(3)**2))
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)

   end

   put_unique_tags(group,name)
   ! Output atom labels for the atom indices given in "group"
      self :: IN
      group :: VEC{INT}, IN
      name :: STR, optional, IN

      symbol :: STR
      label :: STR
      g :: INT

      label = " "
      if (present(name)) label = name

      stdout.put("Atom "//trim(label)//" =")
      do g = 1,group.dim
         symbol = .atom(group(g)).tag
         stdout.put(trim(symbol),width=len_trim(symbol)+1)
      end
      stdout.flush

   end

! =================
! Output theta info
! =================

   put_theta_info
   ! Output Theta-space information
      self :: IN

   ENSURE(.atom_a.associated, "No Roby atom A data")
   ENSURE(.atom_b.associated, "No Roby atom B data")
   ENSURE(.atom_ab.associated,"No Roby atom AB data")

      n,i,j :: INT
      cst,snt,ang :: VEC{REAL}@
      evn,par :: VEC{INT}@
      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("============================")
      stdout.text("Roby-Gould angle eigenspaces")
      stdout.text("============================")

      stdout.flush
      if (NOT .is_hyper_analysis) then
      stdout.text(". Analysis is for atoms:")
      stdout.flush
      .put_unique_tags(.atom_a,"(A)")
      .put_unique_tags(.atom_b,"(B)")
      else
      stdout.text(". This is a hypervalent analysis")
      stdout.flush
      stdout.text(". Analysis is for transfer into atom A from everything not in M")
      stdout.flush
      .put_unique_tags(.atom_a,"(A)")
      .put_unique_tags(.atom_b,"(M)")
      end

      stdout.flush
      if (NOT .is_hyper_analysis) then
      stdout.text(". States come in bonding-antibonding pairs classified by an angle.")
      stdout.text("  Negativef high covalency have high overlap and low angle.")
      stdout.text("  States of high ionicity have low overlap and high angle.")
      else
      stdout.text(". There are no covalent states, only pure ionic")
      end

      stdout.flush
      stdout.text(". For more on this bonding analysis please cite:")
      stdout.text("  M.D. Gould et al. (2008) Theor. Chem. Acc. 119 pp. 275-290")

      n = .eigen_I.dim
      stdout.flush
      stdout.show("No. of states =",n)

      ! Columns
      evn.create(n)
      par.create(n)
      ang.create(n)
      cst.create(n)
      snt.create(n)

      ! Set column data
      j = 0
      do i = 1,n

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle


         j = j + 1
         evn(j) = i
         par(j) = .pair(i)
         cst(j) = .eigen_C(i)
         snt(j) = .eigen_I(i)
         ang(j) = atan2(.eigen_I(i),.eigen_C(i))*DEGREE_PER_RADIAN

      end

      n = j

      stdout.flush
      stdout.flush
      stdout.text("=====================")
      stdout.text("Araki angle subspaces")
      stdout.text("=====================")
      stdout.flush

      ! Do table
      table.create(5)

      table(1).set_heading("Bond")
      table(1).set_subhead("orb.")
      table(1).set_values(evn(1:n))

      table(2).set_heading("Anti")
      table(2).set_subhead("bond")
      table(2).set_values(par(1:n))

      table(3).set_heading("theta")
      table(3).set_subhead(" /deg")
      table(3).set_values(ang(1:n))

      table(4).set_heading("  cos")
      table(4).set_subhead("theta")
      table(4).set_values(cst(1:n))

      table(5).set_heading("  sin")
      table(5).set_subhead("theta")
      table(5).set_values(snt(1:n))

      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      snt.destroy
      cst.destroy
      ang.destroy
      par.destroy
      evn.destroy

   end

   put_theta_BI_info
   ! Output theta-space bond index information
      self :: IN

      n,i,j,k :: INT
      ang :: VEC{REAL}@
      par :: VEC{STR}@
      ind :: VEC{INT}@
      c_p,c_m,cov,i_p,i_m,ion,bi :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@

      ! Columns
      n = .eigen_I.dim

      par.create(n)
      ang.create(n)
      c_p.create(n)
      c_m.create(n)
      cov.create(n)
      i_p.create(n)
      i_m.create(n)
      ion.create(n)
       bi.create(n)

      ! Sort decreasing covalent index
      ind.create(n)
      .theta_cov_index.quick_sort(ind,decreasing_order=TRUE)

      ! Set column data
      j = 0
      do k = 1,n

         ! Reordered index
         i = ind(k)

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         j = j + 1

         if (.pair(i)/=i) then
               par(j) = "("//i.to_str.trim//","//.pair(i).to_str.trim//")"
               i_p(j) = .theta_pop_I(i)
               i_m(j) = .theta_pop_I(.pair(i))
         else
               par(j) = "("//i.to_str.trim//")"
            if      (.eigen_I(i)>ZERO) then
               i_p(j) = .theta_pop_I(i)
               i_m(j) = ZERO
            else if (.eigen_I(i)<ZERO) then
               i_p(j) = ZERO
               i_m(j) = .theta_pop_I(i)
            end
         end

         c_p(j) = .theta_pop_C(i)
         c_m(j) = .theta_pop_C(.pair(i))
         cov(j) = .theta_cov_index(i)
         ion(j) = .theta_ion_index(i)
       ! ang(j) = .theta_angle(i)
         ang(j) = atan2(.eigen_I(i),.eigen_C(i))*DEGREE_PER_RADIAN

          bi(j) = sqrt(cov(j)*cov(j)+ion(j)*ion(j))

      end

      n = j

      ! Change decimal places
      stdout.save
      stdout.set_real_precision(3)

      stdout.flush
      stdout.flush
      stdout.text("========================================")
      stdout.text("Covalent/ionic bond indices per subspace")
      stdout.text("========================================")
      stdout.flush
      stdout.text(". The +/- represents bonding/antibonding orbitals.")
      stdout.text("  The C/I represents covalent/ionic Roby-Gould orbitals.")
      stdout.text("  Thus I- represents an ionic antibonding orbital.")
      stdout.flush
      stdout.text(". The angles here are for the individual bond vectors")
      stdout.text("  used in the dial diagram. They are *not* the Araki")
      stdout.text("  subspace angles.")
      stdout.flush

      ! Do table
      table.create(9)

      table(1).set_heading("Paired")
      table(1).set_subhead(" space")
      table(1).set_values(par(1:n))

      table(2).set_heading("Bond")
      table(2).set_subhead("angle")
      table(2).set_sb3head(" /deg")
      table(2).set_values(ang(1:n))

      table(3).set_heading(" C+")
      table(3).set_subhead("pop")
      table(3).set_values(c_p(1:n))

      table(4).set_heading(" C-")
      table(4).set_subhead("pop")
      table(4).set_values(c_m(1:n))

      table(5).set_heading(" Cov.")
      table(5).set_subhead("index")
      table(5).set_values(cov(1:n))

      table(6).set_heading(" I+")
      table(6).set_subhead("pop")
      table(6).set_values(i_p(1:n))

      table(7).set_heading(" I-")
      table(7).set_subhead("pop")
      table(7).set_values(i_m(1:n))

      table(8).set_heading(" Ion.")
      table(8).set_subhead("index")
      table(8).set_values(ion(1:n))

      table(9).set_heading("Bond")
      table(9).set_subhead("index")
      table(9).set_values(bi(1:n))

      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      ind.destroy
       bi.destroy
      ion.destroy
      i_m.destroy
      i_p.destroy
      cov.destroy
      c_m.destroy
      c_p.destroy
      ang.destroy
      par.destroy

      ! Print theta_C if only two groups e.g. for plots
    ! if (.n_group==2) then

    !    stdout.flush
    !    stdout.flush
    !    stdout.text("Roby-Gould covalent orbitals:")
    !    stdout.flush
    !    .atom(.atom_ab).put_orbitals(.theta_C(:,[1,.pair(1)]),pair=TRUE)
    !
    !    stdout.flush
    !    stdout.flush
    !    stdout.text("Roby-Gould ionic orbitals:")
    !    stdout.flush
    !    .atom(.atom_ab).put_orbitals(.theta_I(:,[1,.pair(1)]),pair=TRUE)

    ! end

      ! Change decimal places
      stdout.unsave

   end

   put_dial_BI_info_do_H(a,b,file,num,reverse)
   ! Output the dial diagram tex script.
   ! "num" in the incrementing number of dial diagrams.
   ! "reverse" is set true to reverse the atom order.
   ! Note: the radius of the dial is normalized to unity.
      self :: IN
      a,b,num :: INT, IN
      file :: TEXTFILE, INOUT
      reverse :: BIN, optional, IN

      n,i,j,k :: INT
      space :: STR(len=1)
      ind :: VEC{INT}*
      filename,atom_a,atom_b,ci_list,dial :: STR
      tau,cov,ion, bc,bi, zero_cutoff :: REAL
      swap :: BIN

      ! Get indices
      tau = .bond_index(a,b)
      cov =  .cov_index(a,b)
      ion =  .ion_index(a,b)

      ! Swap?
      swap = FALSE
      if (present(reverse)) swap = reverse
      if (ion<-0.1) swap = TRUE

      if (swap) ion = -ion

      ! Columns
      n = .eigen_I.dim
      zero_cutoff = .zero_angle_cutoff.to_units("degree")

      ! Sort decreasing covalent index
      ind.create(n)
      .theta_cov_index.quick_sort(ind,decreasing_order=TRUE)

      ! Make the list part of the dial diagram
      j = 0
      space = " "
      ci_list = " "
      do k = 1,n

         i = ind(k)

         if (.theta_angle(i)<       zero_cutoff) cycle
         if (.theta_angle(i)>90.0d0-zero_cutoff) cycle
         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         j = j + 1

         ! Theta bond indices; make bi +ve
         bc = .theta_cov_index(i)/tau
         bi = .theta_ion_index(i)/tau
         if (swap) bi = -bi

         ! List part of dial diagram
         if (j>1)  then
            ci_list = trim(ci_list) // space &
                   // trim(bc.to_str("f7.3",left_justify=TRUE)) &
                   // "/" &
                   // trim(bi.to_str("f7.3",left_justify=TRUE)) &
                   // ","
         else
            ci_list = trim(ci_list) &
                   // trim(bc.to_str("f7.3",left_justify=TRUE)) &
                   // "/" &
                   // trim(bi.to_str("f7.3",left_justify=TRUE)) &
                   // ","
         end

      end
      ci_list = ci_list(1:len_trim(ci_list)-1)

      ind.destroy

      ! Atom tags
      if (NOT swap) then
         atom_a = .numbered_tag(.atom_a)
         atom_b = .numbered_tag(.atom_b)
      else
         atom_b = .numbered_tag(.atom_a)
         atom_a = .numbered_tag(.atom_b)
      end

      ! Write the dial diagram
      dial = "\dialdiagram"
      dial = trim(dial) // "{" // trim(atom_a) // "}"
      dial = trim(dial) // "{" // trim(atom_b) // "}"
      dial = trim(dial) // "{" // trim(tau.to_str("f7.2",left_justify=TRUE)) // "}"
      dial = trim(dial) // "{" // trim(cov.to_str("f7.2",left_justify=TRUE)) // "}"
      dial = trim(dial) // "{" // trim(ion.to_str("f7.2",left_justify=TRUE)) // "}"
      dial = trim(dial) // "{" // trim(ci_list) // "}"
      dial = trim(dial) // "{2}"
      file.text(trim(dial))

      ! Individual dial file ... +H case
      filename = adjustl(num.to_str) // "+H.tex"
      stdout.redirect(filename)
      stdout.text(trim(dial))
      stdout.revert

   end

   put_dial_BI_info_no_H(a,b,file,num,reverse)
   ! Output the dial diagram tex script.
   ! "num" in the incrementing number of dial diagrams.
   ! "reverse" is set true to reverse the atom order.
   ! Note: the radius of the dial is normalized to unity.
      self :: IN
      a,b,num :: INT, IN
      file :: TEXTFILE, INOUT
      reverse :: BIN, optional, IN

      n,i,j,k :: INT
      space :: STR(len=1)
      ind :: VEC{INT}*
      filename,atom_a,atom_b,ci_list,dial :: STR
      tau,cov,ion, bc,bi, zero_cutoff :: REAL
      swap :: BIN

      ! Get indices
      tau = .bond_index(a,b)
      cov =  .cov_index(a,b)
      ion =  .ion_index(a,b)

      ! Swap?
      swap = FALSE
      if (present(reverse)) swap = reverse
      if (ion<-0.1) swap = TRUE

      if (swap) ion = -ion

      ! Columns
      n = .eigen_I.dim
      zero_cutoff = .zero_angle_cutoff.to_units("degree")

      ! Sort decreasing covalent index
      ind.create(n)
      .theta_cov_index.quick_sort(ind,decreasing_order=TRUE)

      ! Make the list part of the dial diagram
      j = 0
      space = " "
      ci_list = " "
      do k = 1,n

         i = ind(k)

         if (.theta_angle(i)<       zero_cutoff) cycle
         if (.theta_angle(i)>90.0d0-zero_cutoff) cycle
         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle

         j = j + 1

         ! Theta bond indices; make bi +ve
         bc = .theta_cov_index(i)/tau
         bi = .theta_ion_index(i)/tau
         if (swap) bi = -bi

         ! List part of dial diagram
         if (j>1)  then
            ci_list = trim(ci_list) // space &
                   // trim(bc.to_str("f7.3",left_justify=TRUE)) &
                   // "/" &
                   // trim(bi.to_str("f7.3",left_justify=TRUE)) &
                   // ","
         else
            ci_list = trim(ci_list) &
                   // trim(bc.to_str("f7.3",left_justify=TRUE)) &
                   // "/" &
                   // trim(bi.to_str("f7.3",left_justify=TRUE)) &
                   // ","
         end

      end
      ci_list = ci_list(1:len_trim(ci_list)-1)

      ind.destroy

      ! Atom tags
      if (NOT swap) then
         atom_a = .numbered_tag(.atom_a)
         atom_b = .numbered_tag(.atom_b)
      else
         atom_b = .numbered_tag(.atom_a)
         atom_a = .numbered_tag(.atom_b)
      end

      ! Write the dial diagram
      dial = "\dialdiagram"
      dial = trim(dial) // "{" // trim(atom_a) // "}"
      dial = trim(dial) // "{" // trim(atom_b) // "}"
      dial = trim(dial) // "{" // trim(tau.to_str("f7.2",left_justify=TRUE)) // "}"
      dial = trim(dial) // "{" // trim(cov.to_str("f7.2",left_justify=TRUE)) // "}"
      dial = trim(dial) // "{" // trim(ion.to_str("f7.2",left_justify=TRUE)) // "}"
      dial = trim(dial) // "{" // trim(ci_list) // "}"
      dial = trim(dial) // "{2}"
      file.text(trim(dial))

      ! Individual dial file ... +H case
      filename = adjustl(num.to_str) // "-H.tex"
      stdout.redirect(filename)
      stdout.text(trim(dial))
      stdout.revert

   end

   put_dial_table_do_H(n_bonds) ::: selfless
   ! Output the latex code for tabular dial diagram, where "n_bonds"
   ! is the number of bonds.
      n_bonds :: INT, IN

      n_rows,r,c,f,l :: INT

      ! No of rows in table
      n_rows = ceiling(0.25d0*n_bonds)

      ! Redirect
      stdout.redirect("rgbi-dial-table+H.tex")

      ! Header
      stdout.text("\input{rgbi-dial-header}")
      stdout.text("\begin{document}")
      stdout.text("\begin{center}")
      stdout.text("\begin{longtable}{cccc}")

      ! Tabular part
      l = 0
      do r = 1,n_rows

         ! Col limits
         f = l + 1
         l = min(l+4,n_bonds)

         ! Write col contents
         do c = f,l
            if (c<l) then
               stdout.put("\input{"//trim(c.to_str)//"+H} &")
            else if (r<n_rows) then
               stdout.put("\input{"//trim(c.to_str)//"+H} \\")
            else
               stdout.put("\input{"//trim(c.to_str)//"+H}")
            end
         end

         ! New line
         stdout.flush

      end

      ! Footer
      stdout.text("\end{longtable}")
      stdout.text("\end{center}")
      stdout.text("\end{document}")

      ! Go back
      stdout.revert

   end

   put_dial_table_no_H(n_bonds) ::: selfless
   ! Output the latex code for tabular dial diagram, where "n_bonds"
   ! is the number of non-hydrogen bonds.
      n_bonds :: INT, IN

      n_rows,r,c,f,l :: INT

      ! No of rows in table
      n_rows = ceiling(0.25d0*n_bonds)

      ! Redirect
      stdout.redirect("rgbi-dial-table-H.tex")

      ! Header
      stdout.text("\input{rgbi-dial-header}")
      stdout.text("\begin{document}")
      stdout.text("\begin{center}")
      stdout.text("\begin{longtable}{cccc}")

      ! Tabular part
      l = 0
      do r = 1,n_rows

         ! Col limits
         f = l + 1
         l = min(l+4,n_bonds)

         ! Write col contents
         do c = f,l
            if (c<l) then
               stdout.put("\input{"//trim(c.to_str)//"-H} &")
            else if (r<n_rows) then
               stdout.put("\input{"//trim(c.to_str)//"-H} \\")
            else
               stdout.put("\input{"//trim(c.to_str)//"-H}")
            end
         end

         ! New line
         stdout.flush

      end

      ! Footer
      stdout.text("\end{longtable}")
      stdout.text("\end{center}")
      stdout.text("\end{document}")

      ! Go back
      stdout.revert

   end

   put_theta_AB_pops
   ! Output theta-space A/B populations information
      self :: IN

      n,i,j,k :: INT
      ang :: VEC{REAL}@
      par :: VEC{STR}@
      ind :: VEC{INT}@
      cpa,cpb,cma,cmb :: VEC{REAL}@
      ipa,ipb,ima,imb :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@

      ! Columns
      n = .eigen_I.dim

      par.create(n)
      ang.create(n)
      cpa.create(n); cpa = ZERO
      cpb.create(n); cpb = ZERO
      cma.create(n); cma = ZERO
      cmb.create(n); cmb = ZERO
      ipa.create(n); ipa = ZERO
      ipb.create(n); ipb = ZERO
      ima.create(n); ima = ZERO
      imb.create(n); imb = ZERO
      ind.create(n)

      ! Sort decreasing covalent index
      ind.create(n)
      .theta_cov_index.quick_sort(ind,decreasing_order=TRUE)

      ! Set column data
      j = 0
      do k = 1,n

         i = ind(k)

         if (.pair(i)<1) cycle
         if (.eigen_I(i)<.eigen_I(.pair(i))) cycle


         j = j + 1

         if (.pair(i)/=i) then
               par(j) = "("//i.to_str.trim//","//.pair(i).to_str.trim//")"
               ipa(j) = .theta_pop_I_A(i)
               ipb(j) = .theta_pop_I_B(i)
               ima(j) = .theta_pop_I_A(.pair(i))
               imb(j) = .theta_pop_I_B(.pair(i))
         else
               par(j) = "("//i.to_str.trim//")"
            if      (.eigen_I(i)>ZERO) then
               ipa(j) = .theta_pop_I_A(i)
               ipb(j) = .theta_pop_I_B(i)
            else if (.eigen_I(i)<ZERO) then
               ima(j) = .theta_pop_I_A(i)
               imb(j) = .theta_pop_I_B(i)
            end
         end

         ang(j) = .theta_angle(i)
         cpa(j) = .theta_pop_C_A(i)
         cpb(j) = .theta_pop_C_B(i)
         cma(j) = .theta_pop_C_A(.pair(i))
         cmb(j) = .theta_pop_C_B(.pair(i))
         ang(j) = atan2(.theta_ion_index(i),.theta_cov_index(i))*DEGREE_PER_RADIAN

      end

      n = j

      ! Change decimal places
      stdout.save
      stdout.set_real_precision(3)

      stdout.flush
      stdout.flush
      stdout.text("Araki angle subspace A & B populations:")
      stdout.flush

      ! Do table
      table.create(10)

      table( 1).set_heading("Paired")
      table( 1).set_subhead(" space")
      table( 1).set_values(par(1:n))

      table( 2).set_heading("theta")
      table( 2).set_subhead(" /deg")
      table( 2).set_values(ang(1:n))

      table( 3).set_heading("C+a")
      table( 3).set_subhead("pop")
      table( 3).set_values(cpa(1:n))

      table( 4).set_heading("C+b")
      table( 4).set_subhead("pop")
      table( 4).set_values(cpb(1:n))

      table( 5).set_heading("C-a")
      table( 5).set_subhead("pop")
      table( 5).set_values(cma(1:n))

      table( 6).set_heading("C-b")
      table( 6).set_subhead("pop")
      table( 6).set_values(cmb(1:n))

      table( 7).set_heading("I+a")
      table( 7).set_subhead("pop")
      table( 7).set_values(ipa(1:n))

      table( 8).set_heading("I+b")
      table( 8).set_subhead("pop")
      table( 8).set_values(ipb(1:n))

      table( 9).set_heading("I-a")
      table( 9).set_subhead("pop")
      table( 9).set_values(ima(1:n))

      table(10).set_heading("I-b")
      table(10).set_subhead("pop")
      table(10).set_values(imb(1:n))

      table.put(label_rows=FALSE)

      ! Clean
      table.destroy
      ind.destroy
      imb.destroy
      ima.destroy
      ipb.destroy
      ipa.destroy
      cmb.destroy
      cma.destroy
      cpb.destroy
      cpa.destroy
      ang.destroy
      par.destroy

      ! Change decimal places
      stdout.unsave

   end

   n_paired_angles result (res) ::: PURE
   ! Output Roby angles and populations
      self :: IN
      res :: INT

   ENSURE(.pair.allocated, "No pair info")
   ENSURE(.eigen_C.allocated, "No eigenvalues")
   ENSURE(.theta_angle.allocated, "No theta angles")

      i :: INT

      res = 0

      do i = 1,.n_bf_ab

         if (.pair(i)<1) cycle
         if (.pair(i)==i) cycle

         res = res + 1

      end

   end

   put_shared_population
   ! Put to stdout the multiple shared Roby atom populations
      self :: IN

   ENSURE(.subgroup_pop.allocated,"no subgroup population totals exist")
   ENSURE(.atom.associated,"no atom data")
   ENSURE(.atom_group.associated,"no atom group data")
   ENSURE(.atom_list.associated,"no atom_list")

      a :: INT
    ! symbol :: VEC{STR}@

      stdout.flush
      stdout.text("===============================")
      stdout.text("Roby multiple shared population")
      stdout.text("===============================")
      stdout.flush
    ! symbol = .atom.unique_tags(.atom_list)
    ! stdout.show("Atom list                 =",symbol)
    ! stdout.show("No. of atoms              =",symbol.dim)
      stdout.show("No. of groups             =",.n_group)
    ! stdout.show("Group population, n_group =",.n_group)
      stdout.flush
      stdout.text("Contributions by subgroup size:")
      stdout.flush
      stdout.dash(real_fields=2)
      stdout.put("Subgrp size")
      stdout.put("Subgrp Pop.")
      stdout.flush
      stdout.dash(real_fields=2)
      do a = 1,.subgroup_pop.dim
         stdout.put(a)
         stdout.put(.subgroup_pop(a))
         stdout.flush
      end
      stdout.dash(real_fields=2)

    ! symbol.destroy

   end

end
