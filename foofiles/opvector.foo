!====================================================================
!
! OPVECTOR: 
!
! Diagonals of operator matrices, e.g. eigenvalues an occupation
! numbers
!
! Provide a basis set (matrix) representation of the diagonal of a
! one-electron quantum mechanical operator. Can cope with polymorphic
! types of basis representations, including restricted, unrestricted,
! and general basis orbitals. Complex types aren't needed sice
! operators are hermitian.
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!====================================================================

module OPVECTOR

   implicit none

   allowed_genres :: VEC{STR}(len=1,3)
   data allowed_genres/"r","u","g"/

   ! Is this below needed?
 ! allowed_extended_kinds :: VEC{STR}(len=2,3)
 ! data allowed_extended_kinds/"r ","u ","gc"/

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, private, PURE
   ! Allocate an object
   end

   create(n_bf) ::: leaky, PURE
   ! Create an empty opvector with size "n_bf" spatial orbitals
      self :: allocatable, OUT
      n_bf :: INT, IN
      .create
      .n_bf = n_bf
   end

   create(genre) ::: leaky, PURE
   ! Create the spinorbital "genre" of right size
      self :: INOUT
      genre :: STR, IN

   ENSURE(.n_bf>0, "bad number of basis functions.")
   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      select case (genre)
      case ("r"); .r.create(.n_bf)
      case ("u"); .a.create(.n_bf)
                  .b.create(.n_bf)
      case ("g"); .g.create(2*.n_bf)
      end

   end

   create(n_bf,genre) ::: leaky, PURE
   ! Create an opvector of size "n_bf", and "genre".
      self :: allocatable, OUT
      n_bf :: INT, IN
      genre :: STR, IN
      .create(n_bf)
      .create(genre)
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy(genre) ::: leaky, PURE
   ! Destroy the appropriate spinorbital kind of the opmatrix
      self :: INOUT
      genre :: STR, IN

   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      select case (genre)
      case ("r"); .r.destroy
      case ("u"); .a.destroy; .b.destroy
      case ("g"); .g.destroy
      end

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of the opmatrix object
      self :: INOUT
      .r.destroy
      .a.destroy
      .b.destroy
      .g.destroy
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: pure
   ! Set defaults
      self :: INOUT
      .n_bf = 0
   end

!   set(n_bf) ::: private, pure
!   ! Set with "n_bf" spatial orbitals
!      self :: INOUT
!      n_bf :: INT, IN
!      .n_bf = n_bf
!   end

   set_to_zero ::: pure
   ! Set self to "v".
      self :: INOUT
      if (.r.allocated) .r = ZERO
      if (.a.allocated) .a = ZERO
      if (.b.allocated) .b = ZERO
      if (.g.allocated) .g = ZERO
   end

!  =======
!  Inquiry
!  =======

   genre result (res) ::: pure
   ! Return the kind of spinorbitals used in the representation.
   ! The simplest spinorbital kind in use is the one returned.
      self :: IN
      res  :: STR
      res = " "
      if      (.r.allocated)                  then; res = "r"
      else if (.a.allocated AND .b.allocated) then; res = "u"
      else if (.g.allocated)                  then; res = "g"
      end
   end

   has_any_genre result (res) ::: pure
   ! Returns true if any component of self has been created
      self :: IN
      res  :: BIN

      c :: VEC{BIN}(3)

      c(1) = .r.allocated
      c(2) = .a.allocated AND .b.allocated
      c(3) = .g.allocated
      res  = any(c)

   end

   is_allocated_with_genre(genre) result (res) ::: PURE
   ! Returns FALSE if self is not allocated
   ! Returns FALSE, unless "genre" of self has been created.
      self  :: allocatable, IN
      genre :: STR, IN
      res   :: BIN
      if (.deallocated) then; res = FALSE
      else;                   res = .has_genre(genre)
      end
   end

   is_deallocated_or_no_genre result (res) ::: pure
   ! Returns true if self is deallocated OR has all components of
   ! self have been deallocated.
      self :: allocatable, IN
      res :: BIN

      d :: VEC{BIN}(3)

      if (.deallocated) then
         res = TRUE
      else
         d(1) = .r.deallocated
         d(2) = .a.deallocated AND .b.deallocated
         d(3) = .g.deallocated
         res = all(d)
      end

   end

   has_genre(genre) result (res) ::: PURE
   ! Returns true if subkind "genre" of self has been created
      self  :: IN
      genre :: STR, IN
      res   :: BIN

   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      res = FALSE
      select case (genre)
      case ("r"); res = .r.allocated
      case ("u"); res = .a.allocated AND .b.allocated
      case ("g"); res = .g.allocated
      end

   end

   no_of_occupied(genre,tol) result (res) ::: PURE
   ! Returns the number of non-zero "occupied" elements, i.e. all those elements
   ! greater than TOL(7).  If "genre" is present, the number of occupied
   ! elements is returned for that kind (the default is determined by the
   ! .genre). if "tol" is present, it is used instead of TOL(7) to
   ! determine what is occupied.
      self  :: IN
      genre :: STR, optional, IN
      tol   :: REAL, optional, IN
      res   :: INT

   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      itemkind :: STR
      eps :: REAL

      itemkind = .genre
      if (present(genre)) itemkind = genre
      ENSURE(itemkind.is_one_of(allowed_genres),"unknown kind, "//trim(itemkind))

      eps = TOL(7)
      if (present(tol)) eps = tol

      res = 0

      select case (itemkind)

      case ("r")
         ENSURE(.r.allocated,"no restricted part")
         res = count(.r>=eps)

      case ("u")
         ENSURE(.a.allocated,"no alpha part")
         ENSURE(.b.allocated,"no beta part")
         res = count(.a>=eps) + count(.b>=eps)

      end

   end

!  ==========
!  Conversion
!  ==========

   convert_to(new) ::: leaky
   ! Convert "self" to a "new" genre, and destroy the old genre.
      self :: INOUT
      new  :: STR, IN

   ENSURE(new.is_one_of(allowed_genres), "unknown genre, "//trim(new))

      fail :: BIN
      old  :: STR


      ! Done?
      old  = .genre
      if (new==old) return

      .create(genre=new)

      ! Convert old -> new
      fail = FALSE
      select case (old)

      case("r")
         select case (new)
         case("u")
            .a = .r
            .b = .r
         case default
            fail = TRUE
         end

      case("u")
         select case (new)
         case("r")
            .r = .a ! take alpha part
         case default
            fail = TRUE
         end

      case("g")
         select case (new)
         case("u")
            .g.put_a_block_to(.a)
            .g.put_b_block_to(.b)
         case default
            fail = TRUE
         end

      end

      ! Clean
      .destroy(old)

      if (fail) then
         DIE("can't convert genre " // trim(old) // " to genre " // trim(new))
      end

   end

end
