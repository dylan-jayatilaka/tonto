!---------------------------------------------------------------------------
!
!  VEC{REAL}: Vector operations ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module VEC{REAL}

   implicit none

   interface to_str
      to_str_vec_real_0
      to_str_vec_real_1
      to_str_vec_real_2
   end

contains

!  =================
!  Memory allocation
!  =================

   create(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate vector
   end

   create(lb,ub) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate the vector with lower bound "lb", upper bound "ub"
   end

   create(bounds) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate the vector with lower and upper bounds in "bounds"
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

! Old

   create(dim) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Create space for object
   end

   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Create the vector with lower bound "lb", upper bound "ub"
   end

   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Create the vector with "bounds"
   end

   destroy ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Destroy space for object
   end


!  ==================
!  Size-of operations
!  ==================

   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo, PURE
   ! Return the size of the array
   end

   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
   end


!  ====
!  Copy
!  ====

   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Create a copy of vector "v".
   end

   copy(v) ::: get_from(VEC{INTRINSIC}), PURE
   ! Copy vector "v".
   end


!  =======================
!  Shrinking and expansion
!  =======================

   shrink(dim,chop_start) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Shrink allocatable "self" to dimension "dim" from the end.
   ! Contents are retained. If "chop_start" is present and TRUE,
   ! "self" is chopped from the start, and the contents from the end
   ! are retained.
   end

   expand(dim,init,grow_start) ::: get_from(VEC{OBJECT}, INIT?=>ZERO), leaky, PURE
   ! Expand allocatable "self" to dimension "dim" from the end. New
   ! slots are zeroed unless scalar "init" is set. If "grow_start" is
   ! present and TRUE, then "self" is expanded from the start, keeping
   ! the same lower bound.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Append the contents of vector "v" to allocatable "self".
   end

   append(v1,v2) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Appends vectors "v1" and "v2" to allocatable "self".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Appends the scalar "value" onto the end of allocatable "self".
   end

   prepend(v) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Prepend vector "v" to allocatable "self".
   end

   prepend(value) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Prepend a single "value" to allocatable "self".
   end

   prune_element(k) ::: get_from(VEC{OBJECT}), leaky, pure
   ! Removes the element at position "k" from allocatable "self".
   ! Elements after that position are moved downward.
   end

! Old

   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Shrink self to dimension dim.  Contents are retained.
   end

   expand(dim,init) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Expand self to dimension dim. New slots are left undefined
   ! unless "init" is supplied.
   end

   resize(dim,init) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Resize self to dimension dim. New slots are left undefined
   ! unless "init" is supplied.
   end

   append(v) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Expands self and appends the contents of vector "v".
   end

   append(v1,v2) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Expands self and appends the contents of vectors "v1" and "v2".
   end

   append(value) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Expands self by 1, and appends the single scalar "value" onto the end.
   end

   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Prepend the vector "v" to "self". "self" is expanded.
   end

   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Prepend an single "value" to "self". "self" is expanded.
   end

   prune(values) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Removes the scalar "values" from the vector, if they are there.
   ! The order of the elementsis otherwise unchanged.
   end

   prune(value) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Removes the single scalar "value" from the vector, if it is there.
   ! The order of the elementsis otherwise unchanged.
   end

   prune_element(k) ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Removes the single element at position "k" from the vector.
   ! The order of the elements is unchanged.
   end


!  ====================
!  Comparison functions
!  ====================

   equals(v,eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if "self" is the same as "v", within range "eps" if supplied
   end

   same_as(v,eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if "self" is the same as "v", within range "eps" if supplied
   end

   has_all_equal(eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return TRUE if "self" contains all the same elements, to within precision
   ! "eps", if supplied.
   end

   has_all_equal_to(val,eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return TRUE if "self" contains all the same values "val", to within
   ! precision "eps", if supplied.
   end

   has_any_equal_to(val,eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return TRUE if "self" has any values the same as "val", to within
   ! precision "eps", if supplied.
   end

   is_zero(eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if the vector is zero (within "eps", if supplied)
   end

   is_monotone result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if the vector is monotone increasing or decreasing
   end

   is_monotonically_increasing result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if the vector is monotonically increasing
   end

   is_monotonically_decreasing result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if the vector is monotonically decreasing
   end

   is_z_axis(eps) result (res)
   ! Return true if the vector is set to the z-axis
      eps :: REAL, IN, optional
      res :: BIN
   ENSURE(.dim==3,"must supply a 3 dimensional vector!")
      res = self(1).equals(ZERO,eps)
      res = self(2).equals(ZERO,eps) AND res
      res = self(3).equals(ONE,eps)  AND res
   end


!  =============================
!  Repetition related operations
!  =============================

   remove_repetitions ::: get_from(VEC{INTRINSIC}), leaky, PURE
   ! Remove repeated elements which come later in the list. 
   ! NOTE: the vector may shrink. 
   ! NOTE: this version for reals & complex
   end

   has_repetitions result (res) ::: get_from(VEC{OBJECT}), pure
   ! Return TRUE if self has at least one repeated element.
   end

   no_of_unique_elements result (res) ::: get_from(VEC{OBJECT}), pure
   ! Return the number of unique elements in the vector.
   end


!  ================
!  Sorting routines
!  ================

   sort(decreasing_order) ::: get_from(VEC{OBJECT}), PURE
   ! Sort array "self" from lowest to highest, using simple insertion sort.  If
   ! "decreasing_order" is present and TRUE sort from highest to lowest instead.
   end

   quick_sort(decreasing_order) ::: get_from(VEC{OBJECT}), PURE
   ! Sort the vector into increasing order.If "decreasing_order" is present and
   ! TRUE, the vector is sorted from largest to smallest
   end

   quick_sort_increasing ::: get_from(VEC{OBJECT}), recursive, private, PURE
   ! Sort the vector into order, smallest to largest
   end

   quick_sort_decreasing ::: get_from(VEC{OBJECT}), recursive, private, PURE
   ! Sort the vector into order, largest to smallest
   end

   quick_sort(indices,decreasing_order) ::: get_from(VEC{OBJECT}), PURE
   ! Return the "indices" which sort self from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   ! If "decreasing_order" is present and TRUE, the indices are sorted from
   ! largest to smallest
   end

   quick_sort_increasing(indices) ::: get_from(VEC{OBJECT}), recursive, private, PURE
   ! Return the indices which sort vector from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   end

   quick_sort_decreasing(indices) ::: get_from(VEC{OBJECT}), recursive, private, PURE
   ! Return the indices which sort vector from largest to smallest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   end

   reverse_order ::: get_from(VEC{INTRINSIC}), pure
   ! Reverse the order of the elements of self
   end

   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure
   ! Swap elements "e1" and "e2" in "self".
   end

   set_to_flattened_reverse_of(b) ::: get_from(VEC{INTRINSIC}), PURE
   ! Set "self" to the flattened reverse of vector "b" i.e. the standard order
   ! is of "b" reversed and placed as a vector.
   end


!  ====================
!  Numerical operations
!  ====================

   set_to(v) ::: get_from(VEC{INTRINSIC}, V?=>REAL), pure
   ! Set the vector to "v". See also the "copy" routine.
   end

   plus(v,mask) ::: get_from(VEC{INTRINSIC}, V?=>REAL), pure
   ! Add vector "v" to "self"
   end

   minus(v,mask) ::: get_from(VEC{INTRINSIC}, V?=>REAL), pure
   ! Subtract vector "v" from "self"
   end

   to_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V?=>REAL, FAC?=>REAL), pure
   ! Set the vector to "v" scaled by "fac"
   end

   plus_scaled(v,fac) ::: get_from(VEC{INTRINSIC}, V?=>REAL, FAC?=>REAL), pure
   ! Add a vector "v" scaled by "fac" to "self"
   end


   sum_elements result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the sum of the elements in "self"
   end

   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V?=>REAL, RES?=>REAL, CONJG=>), pure
   ! Return the dot product with "v"
   end

   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V?=>CPX, RES?=>CPX, CONJG=>), pure
   ! Return the dot product with "v"
   end


   cross(v) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the cross product of "self" and "v".
   end

   to_cross_product_of(u,v) ::: get_from(VEC{INTRINSIC}), pure
   ! Set the vector to the cross product of "u" and "v".
   end


   to_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A?=>REAL, V?=>REAL, VAL?=>REAL), PURE
   ! Set "self" to the product of the matrix "a" and vector "v". If present,
   ! "transpose_a" can be set to TRUE if the matrix needs to be transposed.
   end

   plus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A?=>REAL, V?=>REAL, VAL?=>REAL), PURE
   ! Add to "self" the product of the matrix "a" and vector "v". If present,
   ! "transpose_a" can be set to TRUE if the marix needs to be transposed.
   end

   minus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A?=>REAL, V?=>REAL, VAL?=>REAL), PURE
   ! Subtract from "self" the product of the matrix "a" and vector "v". If
   ! present, "transpose_a" can be set to TRUE if the marix needs to be
   ! transposed.
   end

   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A?=>REAL, V?=>REAL, VAL?=>REAL, FAC?=>REAL), PURE
   ! Set "self" to the product of the matrix "a" and vector "v" scaled by "fac".
   ! If present, "transpose_a" can be set to TRUE if the matrix needs to be
   ! transposed.
   end

   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A?=>REAL, V?=>REAL, VAL?=>REAL, FAC?=>REAL), PURE
   ! Add to self "self" the product of the matrix "a" and vector "v" scaled by
   ! "fac".  If present, "transpose_a" can be set to TRUE if the matrix needs to
   ! be transposed.
   end


   rotate_by(a) ::: get_from(VEC{INTRINSIC}), PURE
   ! Rotate self by matrix "a", treating self as a column vector
   end

   translate_by(v) ::: get_from(VEC{INTRINSIC}), PURE
   ! Translate self by vector "v".
   end

   seitz_multiply(seitz) ::: PURE
   ! Self is operated on by the seitz matrix.  Self must be in fractional
   !  coordinates.
      self :: INOUT
      seitz :: MAT{REAL}, IN

   ENSURE(seitz.dim1==4,"seitz matrix must be 4x4")
   ENSURE(seitz.dim2==4,"seitz matrix must be 4x4")
   ENSURE(.dim==3,"vector not of dimension 3")

      .rotate_by(seitz(1:3,1:3))
      .translate_by(seitz(4,1:3))

   end


   outer_product_with(v) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Returns the outer product of "self" with vector "v".
   end


   norm result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the norm of the vector
   end

   normalise ::: get_from(VEC{INTRINSIC}), pure
   ! Normalise the vector
   end

   distance_to(a) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the distance to "a" if supplied
   end

   to_distances_between(mx,pos) ::: PURE
   ! Set self to the distance between columns of "mx" and  "pos"
      self :: OUT
      mx  :: MAT{REAL}, IN
      pos :: VEC{REAL}, IN

      i :: INT
      v :: VEC{REAL}*

      v.create(.dim)

      do i = 1,mx.dim2
         v       = mx(:,i) - pos
         self(i) = v.norm
      end

      v.destroy

   end


   mean result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the mean of the vector
   end

   variance result (res) ::: pure
   ! Return the variance of the vector from its mean
      self :: IN
      res :: REAL

      v :: VEC{REAL}*
      mean :: REAL

      mean = .mean
      allocate(v(.dim))
      v = self - mean
      res = v.dot(v)/REALIFY(.dim)
      deallocate(v)

   end

   standard_deviation result (res) ::: pure
   ! Return the standard deviation of the vector from its mean
      self :: IN
      res :: REAL

      res = .variance
      if (res/=ZERO) res = sqrt(res)

   end


   arcsinh result (res) ::: pure
   ! Return the arcsinh of self, where self is a vector of any real numbers.
      self :: IN
      res :: VEC{REAL}(size(self))
      res = log(self + sqrt(ONE+self*self))
   end

!   integrate(a,b,accuracy) result (res) ::: recursive, functional
!   ! Integrate the vector valued scalar function "self" between the limits
!   ! "a" and "b" using adaptive trapezoidal rule with Simpsons approximation.
!   ! If present, "accuracy" is the required accuracy of the integral.
!      interface
!         self(x) result (res)
!             x :: REAL
!            res :: VEC{REAL}*
!         end
!      end
!      a,b :: REAL
!      accuracy :: REAL, optional
!      res :: VEC{REAL}*
!       n :: INT
!      same :: BIN
!      tol,h,m :: REAL
!      fa,fb,fm,one_trap,two_trap,left,right :: VEC{REAL},PTR
!      tol = TOL(6)
!      if (present(accuracy)) tol = accuracy
!      h  = b-a
!      m  = (a+b)/TWO
!      fa => self(a)
!      fb => self(b)
!      fm => self(m)
!      n = size(fa)
!      one_trap.create(n)
!      two_trap.create(n)
!      one_trap = h*(fa+fb)/TWO
!      two_trap = h*(fa+TWO*fm+fb)/FOUR
!      fm.destroy
!      fb.destroy
!      fa.destroy
!      res.create(n)
!      res = abs(one_trap-two_trap)
!      same = maxval(res) < THREE*tol
!      if (same) then
!         res = (FOUR*two_trap - one_trap)/THREE
!         two_trap.destroy
!         one_trap.destroy
!      else
!         two_trap.destroy
!         one_trap.destroy
!         left  => .integrate(a,m,tol/TWO)
!         right => .integrate(m,b,tol/TWO)
!         res = left + right
!         right.destroy
!         left.destroy
!      end
!   end


!  ===========
!  Contraction
!  ===========

   to_contraction_i2_of(v,mx)
   ! Set "self" to the contraction of the second index of "v" with all
   ! indices of "mx", and collect the result over the first index of "v".
      mx :: MAT{REAL}, IN
      v  :: MAT{REAL}, IN

   ENSURE(mx.dim1==v.dim2,"mx and v dim2 are inconsistent")
   ENSURE(.dim   ==v.dim1,"self and v dim1 are inconsistent")

      dim,i1,i2, n :: INT

      dim = mx.dim1

      self = ZERO

      do i2 = 1,dim
      do i1 = 1,dim
         do n = 1,.dim
            self(n) = self(n) + mx(i1,i2)*v(n,i1)*v(n,i2)
         end
      end
      end

   end

   to_contraction_i2_of(v,mx)
   ! Set "self" to the contraction of the second index of "v" with all
   ! indices of "mx", and collect the result over the first index of "v".
      v  :: MAT{REAL}, IN
      mx :: MAT3{REAL}, IN

   ENSURE(mx.dim1==v.dim2,"mx and v dim2 are inconsistent")
   ENSURE(.dim   ==v.dim1,"self and v dim1 are inconsistent")

      dim,i1,i2,i3, n :: INT

      dim = mx.dim1

      self = ZERO

      do i3 = 1,dim
      do i2 = 1,dim
      do i1 = 1,dim
         do n = 1,.dim
            self(n) = self(n) + mx(i1,i2,i3)*v(n,i1)*v(n,i2)*v(n,i3)
         end
      end
      end
      end

   end

   to_contraction_i2_of(v,mx)
   ! Set "self" to the contraction of the second index of "v" with all
   ! indices of "mx", and collect the result over the first index of "v".
      mx :: MAT4{REAL}, IN
      v  :: MAT{REAL}, IN

   ENSURE(mx.dim1==v.dim2,"mx and v dim2 are inconsistent")
   ENSURE(.dim   ==v.dim1,"self and v dim1 are inconsistent")

      dim,i1,i2,i3,i4, n :: INT

      dim = mx.dim1

      self = ZERO

      do i4 = 1,dim
      do i3 = 1,dim
      do i2 = 1,dim
      do i1 = 1,dim
         do n = 1,.dim
            self(n) = self(n) + mx(i1,i2,i3,i4)*v(n,i1)*v(n,i2)*v(n,i3)*v(n,i4)
         end
      end
      end
      end
      end

   end


!  ==================
!  Min/max operations
!  ==================

   chop_small_values(val) ::: get_from(VEC{INTRINSIC}), pure
   ! Set all values in the self whose value is smaller than "val" to "val".
   end

   chop_large_values(val) ::: get_from(VEC{INTRINSIC}), pure
   ! Set all values in the self whose value is larger than "val" to "val".
   end

   chop_small_absolute_values(val) ::: get_from(VEC{INTRINSIC}), pure
   ! Set all values in the self whose absolute value is smaller than "val" to
   ! "val" times the sign of the original value.
   end

   chop_large_absolute_values(val) ::: get_from(VEC{INTRINSIC}), pure
   ! Set all values in the self whose absolute value is larger than "val" to
   ! "val" times the sign of the original value.
   end

   zero_small_values(eps) ::: get_from(VEC{INTRINSIC}), pure
   ! Zero elements of the vector which are less than "tol" in magnitude
   end

   largest_value result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the maximum absolute value in the vector
   end

   smallest_value result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return minimum absolute value in the vector
   end

   no_of_vals_larger_than(tol) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the number of elements larger than "tol".
   end

   no_of_abs_vals_larger_than(tol) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the number of absolute-value-elements larger than "tol".
   end


!  ================
!  Range operations
!  ================

   indices_of_vals_larger_than(tol) result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Indices "ind" of elements larger than "tol".
   end

   indices_of_abs_vals_larger_than(tol) result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Indices "ind" of absolute-value-elements larger than "tol".
   end

   get_indices_in_range(range,row,val) ::: get_from(VEC{INTRINSIC}),  pure
   ! Get the "row" and "col" indices, and values "val", of the
   ! elements of "self" which are within the specified "range".
   end
   
   indices_in_range(range) result (row) ::: get_from(VEC{INTRINSIC})
   ! Get the "row" and "col" indices, and values "val", of the
   ! elements of "self" which are within the specified "range".
   end

   all_in_range(range) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return TRUE if all values of self are within the specified "range".
   end

   in_range(range) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return element i as TRUE if self(i) is within the specified "range".
   end

   is_in_range(low,high) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return TRUE if the "self" vector is in the box bounded by lower corner
   ! "low", and upper corner "high".
   end

   element_range result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the range (smallest and largest value) of self.
   end

   number_in_range(range) result (res)::: get_from(VEC{INTRINSIC}), pure
   ! Return the number of element self(i,j) within the specified "range".
   end


!  ==========================
!  Index returning operations
!  ==========================

   index_of_maximum result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index of the maximum in the vector
   end

   index_of_minimum result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index of the minimum in the vector
   end

   index_of_largest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index "ind" of the largest absolute value in the vector
   end

   index_of_smallest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index "ind" of the smallest value in the vector
   end

   index_of_first_nonzero_value(eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Returns the index of the first nonzero component of self within
   ! a tolerance "eps".
   end

   index_of_first_zero_value(eps) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Returns the index of the first zero component of self.
   end

   index_of_first_greater_than(val) result (res) ::: get_from(VEC{INTRINSIC}, VAL?=>REAL), pure
   ! Returns the index of the first element of self greater than "val".
   ! Returns 0 if no index is greater.
   end

   index_of_value(val,eps,last) result(pos) ::: pure
   ! Returns the first index in "self" which has the value "val", or 0
   ! if "val" is not present in the array. If present, "eps" is used
   ! to test equality with "val". If "last" is present, then the
   ! search is performed in reverse and the last match is returned.
      self :: IN
      val :: REAL, IN
      eps :: REAL, optional, IN
      last :: BIN, optional, IN
      pos :: INT

      i :: INT
      reverse :: BIN

      reverse = FALSE
      if (present(last)) reverse = last

      pos = 0

      if (NOT reverse) then

         do i = 1,.dim
           if (self(i).same_as(val,eps)) then
              pos = i
              exit
           end
         end

      else

         do i = .dim,1,-1
           if (self(i).same_as(val,eps)) then
              pos = i
              exit
           end
         end

      end

   end


!  ======================
!  Binning and histograms
!  ======================

   to_histogram_from_data(data,X,X_min,X_max,X_bin,C) ::: PURE
   ! Set "self" to a histogram matrix whose i-th element contains the
   ! *sum* of the values in array "data" whose elements correspond to
   ! the i-th bin of "X", where a bin is a range of descriptor values
   ! in "X" of side length "X_bin" beginning at "X_min" and ending at
   ! "X_max". The dimension of self is calculated within this routine. 
   ! NOTE: Don't use binned data to calculate properties unless you
   ! really need to coarse grain.
      self :: INOUT
      data,X :: VEC{REAL}, IN
      X_min,X_max,X_bin :: REAL, IN
      C :: VEC{INT}, optional, OUT

   ENSURE(.dim==ceiling((1-TOL(4))*(X_max-X_min)/X_bin),"wrong size, self")
   ENSURE(data.dim==X.dim,"incompatible data and X descriptor")
   ENSURE(X_max>X_min,"X_max is smaller than X_min!")
   ENSURE(X_bin<(X_max-X_min),"X_bin size is larger than [X_min,X_max]")

      n_X, i,k :: INT
      X_ran :: REAL

      ! The range of value ...
      X_ran = X_max - X_min

      ! The number of bins ...
      n_X = ceiling((1-TOL(4))*X_ran/X_bin)

      ! Create the histogram (leaky)
      self = ZERO
      if (present(C)) C = 0

      ! Now do the binning ...
      do k = 1,data.dim

         ! Get the bin
         i = ceiling(min(X(k)-X_min,X_ran)/X_bin)
         i = max(i,  1)
         i = min(i,n_X)

         ! Accumulate
         self(i) = self(i) + data(k)
         if (present(C)) C(i) = C(i) + 1

      end

   end


!  =========================
!  Find and match operations
!  =========================

   find_opposite_pairs(pair,min,max)
   ! "pair(i)" returns the location of the element which has the opposite
   ! value to self(i) *and* is also negative, i.e. self(pair(i)) = -self(i) < 0.
   ! If no such match can be found, pair(i) is set to 0.
   ! unless self(i) is greater than max, in which case pair(i) is set to -1.
      pair :: VEC{INT}, OUT
      min,max :: REAL, IN

      i,j :: INT

      pair = 0

      do i = 1,size(self)

         if      (abs(self(i))<min) then
         
            pair(i) =  0

         else if (abs(self(i))>max) then

             if (self(i)<0)  pair(i) = -1
             if (self(i)>0)  pair(i) = -2

         else

            do j = 1,i-1

               if (any(pair==j)) cycle

               if (abs(self(j)+self(i))<min) then
                  if (self(i)>0) then; pair(i)=j
                  else;                pair(i)=0
                  end
               end

            end

         end

      end

   end

   find_pairs(pair,match_function,tol)
   ! Find pairs of values self(i) and self(pair(i)) where:
   ! match_function(self(i),self(pair(i))) = 0. If no such pair can be
   ! found, then pair(i) is set to 0. If more than one match is found
   ! then the first match from the start of the list is the one that
   ! is paired.
      pair :: VEC{INT}, OUT
      interface
         match_function(arg1,arg2) result (res)
            arg1,arg2 :: REAL, IN
            res :: REAL
         end
      end
      tol :: REAL, optional, IN

      i,j :: INT
      val :: REAL
      paired :: BIN

      pair = 0

      ! Loop over elements
      do i = 1,.dim

         ! Skip if used
         if (pair(i)>0) cycle

         paired = FALSE

         ! Loop over potential matches
         do j = 1,.dim

            ! Skip if used
            if (pair(j)>0) cycle
            if (any(pair==j)) cycle
        
            val = match_function(self(i),self(j))
        
            ! Does it match?
            if (val.is_zero(tol)) then
               pair(i) = j
               pair(j) = i
               paired = TRUE ! Found
               exit
            end
        
         end

         ! If NOT found, no pair, but used
         if (NOT paired) then
            pair(i) = i
         end

      end

   end

   find_non_unit_pairs(pair,match_function,tol)
   ! Find pairs of values self(i) and self(pair(i)) where:
   ! match_function(self(i),self(pair(i))) = 0. If no such pair can be
   ! found, then pair(i) is set to 0. If more than one match is found
   ! then the first match from the start of the list is the one that
   ! is paired.
      pair :: VEC{INT}, OUT
      interface
         match_function(arg1,arg2) result (res)
            arg1,arg2 :: REAL, IN
            res :: REAL
         end
      end
      tol :: REAL, optional, IN

      i,j :: INT
      val :: REAL
      paired :: BIN

      pair = 0

      ! Loop over elements
      do i = 1,.dim

         ! Skip if used
         if (pair(i)>0) cycle

         paired = FALSE

         ! Loop over potential matches
         do j = 1,.dim

            ! Skip if used
            if (pair(j)>0) cycle
            if (any(pair==j)) cycle
            if (self(j).equals( ONE,tol)) cycle
            if (self(j).equals(-ONE,tol)) cycle
        
            val = match_function(self(i),self(j))
        
            ! Does it match?
            if (val.is_zero(tol)) then
               pair(i) = j
               pair(j) = i
               paired = TRUE ! Found
               exit
            end
        
         end

         ! If NOT found, no pair, but used
         if (NOT paired) then
            pair(i) = i
         end

      end

   end


!  =============
!  String widths
!  =============
   
   str_lengths result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Returns the minimal string lengths.
   end 
   
   str_lengths(max_dp) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the string lengths "res" from the int part of the REAL value
   ! "self", keeping "max_dp" decimal places.
   end 
   
   str_lengths(error,max_dp) result (res) ::: get_from(VEC{INTRINSIC})
   ! Returns the minimal string lengths for "self" assuming it has
   ! an associated "error", with certain precision "dp" and optional
   ! extra "spaces".  NOTE: This version does not add alignment spaces.
   end 


   get_max_str_length(msl,spaces) ::: get_from(VEC{INTRINSIC}), pure
   ! Returns "msl", the maximum of the string lengths for "self",
   ! and with optional extra "spaces". 
   end

   get_max_str_length(msl,max_dp,spaces) ::: get_from(VEC{INTRINSIC}), pure
   ! Returns "msl", the maximum of the string lengths for "self", with
   ! certain precision "max_dp", and with optional extra "spaces". 
   end

   get_max_str_length(msl,error,max_dp) ::: get_from(VEC{INTRINSIC}), PURE
   ! Returns "msl", the maximum of the string lengths for "self",
   ! assuming it has an associated "error", with precision "max_dp".
   end

   get_max_str_length(msl,mdp,mcb,error,max_dp,max_cb) ::: get_from(VEC{INTRINSIC}), PURE
   ! Returns "msl", the maximum of the string lengths for "self", and
   ! the maximum decimal point "mdp", and the maximum closing bracket
   ! position "mcb" assuming "self" has an associated "error"s.
   ! If "max_cb" is present, use it to pad "msl".
   end


!  =====================
!  Conversion to strings
!  =====================

   to_str_vec_real_0 result (res) ::: get_from(VEC{INTRINSIC}:to_str), pure
   ! Change self to a string of minimal length
   end 

   to_str_vec_real_1(fmt,left_justify) result (res) ::: get_from(VEC{INTRINSIC}:to_str), pure
   ! Change self to a "string" using the specified fortran "fmt".
   end

   to_str_vec_real_2(style,width,precision,left_justify) result (res) ::: get_from(VEC{INTRINSIC}:to_str), pure
   ! Change self to a string with specified "style", "width" and
   ! "precision" as defined in the fortran standard 
   end

   to_concatenated_str(fmt,separator) result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Change self to a string using "fmt" if specified, and with
   ! "separator" between each item, if specified.
   end

   to_str_no_zeros result (res) ::: pure
   ! Change self to a "string" but remove trailing zeros
      self :: IN
      res :: VEC{STR}(.dim)
      i :: INT
      do i = 1,.dim
         res(i) = self(i).to_str_no_zeros
      end
   end


!  =====================
!  Conversion operations
!  =====================

   convert_to(units) ::: get_from(VEC{INTRINSIC}, nint=>), PURE
   ! Convert the "self" in atomic units or generic units to a new
   ! number in "units".
   end

   convert_from(units) ::: get_from(VEC{INTRINSIC}, nint=>), PURE
   ! Convert the number "self" from "units" system to a new number
   ! in atomic units or generic units.
   end


!  =======================
!  Spin-orbital operations
!  =======================

   alpha result (res) ::: get_from(VEC{INTRINSIC}), PURE
   ! return the alpha sector of the vector
   end

   beta result (res) ::: get_from(VEC{INTRINSIC}), PURE
   ! return the beta sector of the vector
   end

   alpha_set_to(X) ::: get_from(VEC{INTRINSIC}), PURE
   ! Set the alpha sector of the vector
   end

   beta_set_to(X) ::: get_from(VEC{INTRINSIC}), PURE
   ! Set the beta sector of the vector
   end

   alpha_put_to(X) ::: get_from(VEC{INTRINSIC}), PURE
   ! Put the alpha sector to the vector "X"
   end

   beta_put_to(X) ::: get_from(VEC{INTRINSIC}), PURE
   ! Put the beta sector to the vector "X"
   end


!  =====================
!  Root finding routines
!  =====================

   bracket_root(z,direction,x1,x2,factor,val,max_it) ::: routinal
   ! Given a vector function self(z), an initial point "z" and a "direction",
   ! and initial distances "x1" and "x2" along "direction" from "z", bracket
   ! a root of self along "direction" by expansion. If "factor" is present it is
   ! used as the (linear) interval expansion factor. If "val" is present the
   ! values "x1" and "x2" will bracket the value x where self(x) = val.
   ! If "max_it" is present then it is the number of times the interval is
   ! expanded.
      interface
         self(z) result (res)
            z :: VEC{REAL}, IN
            res :: REAL
         end
      end
      z,direction :: VEC{REAL}
      x1,x2  :: REAL
      factor,val :: REAL, optional
      max_it :: INT, optional

   ENSURE(x1/=x2,"non-zero range (x1,x2) required")

      j :: INT
      f1,f2 :: REAL
      fac :: REAL = 1.6d0
      iso :: REAL = 0.0d0
      maxit :: INT = 500

      if (present(factor)) fac = factor
      if (present(val))    iso = val
      if (present(max_it)) maxit = max_it

      if (x1>x2) x1.swap_with(x2)
      f1 = self(z + x1*direction) - iso
      f2 = self(z + x2*direction) - iso

      do j = 1,maxit

         if (f1*f2<ZERO) return

         if (abs(f1)<abs(f2)) then
            x1 = x1 + fac*(x1-x2)
            f1 = self(z + x1*direction) - iso
         else
            x2 = x2 + fac*(x2-x1)
            f2 = self(z + x2*direction) - iso
         end

      end

   end

   find_root_brent(z,direction,x1,x2,tol,root,val,max_it) ::: routinal
   ! Given a vector function self(x), an initial point "z", a "direction", and
   ! initial values "x1" and "x2" along this "direction" which bracket a root
   ! of self, return the "root" of self along "direction" to a precision "tol"
   ! using Brent's method. The point "z" is reset to be the vector point
   ! corresponding to this root. If "val" present, then root is set so that
   ! self(root) = val, i.e.  root is set top be an iso-value of self. If
   ! "max_it" is present it is set to the maximum number of iterations.
      interface
         self(z) result (res)
            z :: VEC{REAL}, IN
            res :: REAL
         end
      end
      z,direction :: VEC{REAL}
      x1,x2,tol :: REAL
      root,val :: REAL, optional
      max_it :: INT, optional

      iter :: INT
      a,b,c,d,e,fa,fb,fc,p,q,r,s,tol1,xm :: REAL
      maxit :: INT = 100
      iso   :: REAL = ZERO
      eps   :: REAL = TOL(8)

      if (present(max_it)) maxit = max_it
      if (present(val))    iso = val

      a  = x1
      b  = x2
      fa = self(z + a*direction) - iso
      fb = self(z + b*direction) - iso
      ENSURE((fa>0 AND fb<0) OR (fa<0 AND fb>0),"root is not bracketed")
      c = b
      fc = fb
      d = ZERO
      e = ZERO

      do iter = 1,maxit
         if ((fb>0 AND fc>0) OR (fb<0 AND fc<0)) then
            c = a    ! Rename a,b,c and adjust bounding interval d
            fc = fa
            d = b - a
            e = d
         end
         if (abs(fc)<abs(fb)) then
            a  = b ; b  = c ; c  = a
            fa = fb; fb = fc; fc = fa
         end
         ! Test convergence
         tol1 = TWO*eps*abs(b)+HALF*tol
         xm = HALF*(c-b)
         if (abs(xm)<=tol1 OR fb==ZERO) then
            if (present(root)) root = b
            z = z + b*direction
            return
         end
         if (abs(e)>=tol1 AND abs(fa)>abs(fb)) then
            s = fb/fa ! Attempt inverse quadratic interpolation
            if (a==c) then
               p = TWO*xm*s
               q = ONE - s
            else
               q = fa/fc
               r = fb/fc
               p = s*(TWO*xm*q*(q-r)-(b-a)*(r-ONE))
               q = (q-ONE)*(r-ONE)*(s-ONE)
            end
            if (p>ZERO) q = -q
            p = abs(p)
            if (TWO*p<min(THREE*xm*q-abs(tol1*q),abs(e*q))) then
               e = d  ! Accept interpolation
               d = p/q
            else
               d = xm ! Interpolation failed, use bisection
               e = d
            end
         else
            d = xm    ! Bounds decreasing too slowly, use bisection
            e = d
         end
         a = b; fa = fb
         if (abs(d)> tol1) then; b = b + d
         else;                   b = b+sign(tol1,xm)
         end
         fb = self(z + b*direction) - iso
      end

      DIE("maximum iterations exceeded")

   end

   find_isopoint(z,direction,isovalue,tol,x1,x2) ::: routinal
   ! Given an initial point "z" and a "direction" to search along, return the
   ! isopoint "z" where the function "self" has value "isovalue", i.e. where
   ! self(p) = isovalue. "tol" is the accuracy to which "z" is determined.
   ! If present, "x1" and "x2" are an initial interval along "direction" from
   ! "p" where the isopoint is suspected to lie.
      z,direction :: VEC{REAL}
      interface
         self(z) result (res)
            z :: VEC{REAL}, IN
            res :: REAL
         end
      end
      isovalue,tol :: REAL
      x1,x2 :: REAL, optional
      y1,y2 :: REAL
      y1 = ZERO; if (present(x1)) y1 = x1
      y2 = ONE;  if (present(x2)) y2 = x2
      VEC{REAL}:bracket_root(self,z,direction,y1,y2,val=isovalue)
      VEC{REAL}:find_root_brent(self,z,direction,y1,y2,tol,val=isovalue)
   end


!  =====================
!  Minimisation routines
!  =====================

   minimise(new_direction,gradient,old_val,old_gradient,hessian)
   ! Move the vector "self" to a position closer to the minimum, based on the
   ! gradient.  Uses the BFGS scheme.  Doesn't check for convergence, just does
   ! one iteration.
      new_direction :: VEC{REAL}, OUT
      gradient :: VEC{REAL}, IN
      old_val, old_gradient :: VEC{REAL}, INOUT
      hessian :: MAT{REAL}, INOUT
   ENSURE(.dim==new_direction.dim, "vector size mismatch")
   ENSURE(.dim==gradient.dim, "vector size mismatch")
   ENSURE(.dim==old_val.dim, "vector size mismatch")
   ENSURE(.dim==old_gradient.dim, "vector size mismatch")
   ENSURE(.dim==hessian.dim1, "incorrect dimension for hessian matrix")
   ENSURE(.dim==hessian.dim2, "incorrect dimension for hessian matrix")
      dx,dg,hdg,u :: VEC{REAL}*
      dxdg,dghdg,dghdg_inv :: REAL
      dim :: INT
      dim = .dim
      dx.create(dim); dg.create(dim); hdg.create(dim); u.create(dim)
      dg = gradient - old_gradient
      dx = self - old_val
      hdg.to_product_of(hessian,dg)
      dxdg = ONE / dot_product(dx,dg)
      dghdg = dot_product(dg,hdg)
      dghdg_inv = ONE / dghdg
      u  = dxdg * dx - dghdg_inv * hdg
      hessian = hessian &
             + dxdg * dx.outer_product_with(dx) &
             - dghdg_inv * hdg.outer_product_with(hdg) &
             + dghdg * u.outer_product_with(u)
      dx.to_product_of(hessian,gradient)
      old_val = self
      old_gradient = gradient
      new_direction = - dx
      dx.destroy; dg.destroy; hdg.destroy; u.destroy
   end

   minimize_BFGS(dself,p,fret,tol,gtol,step,max_it) ::: routinal
   ! Use the Broyden-Fletcher-Goldfarb-Shanno method to minimise a
   ! vector function self(p) with derivative function dself(p)
   ! starting from an initial point "p", returning the minimum point
   ! in "p", to a tolerance "gtol" in the gradient. If "step" is
   ! present it determines the size of the initial step in the line
   ! minimisation along the gradient direction. If "max_it" is
   ! present, set that to be the maximum iterations
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      interface
         dself(p) result (res)
            p :: VEC{REAL}, IN
            res :: VEC{REAL}(size(p))
         end
      end
      p :: VEC{REAL}
      fret :: REAL
      tol,gtol :: REAL, IN
      step :: REAL, optional
      max_it :: INT, optional, IN

      n,iter,i,itmax :: INT
      fac,fad,fae,fp,sumdg,sumxi,eps, stp,this_stp :: REAL
      g,dg,hdg,pnew,xi :: VEC{REAL}*
      hessian :: MAT{REAL}, PTR
      fail :: BIN

      eps = tol/FOUR

      stp = ONE
      if (present(step)) stp = step

      itmax = 200
      if (present(max_it)) itmax = max_it

      n = size(p)
      g.create(n)
      dg.create(n)
      hdg.create(n)
      pnew.create(n)
      xi.create(n)
      allocate(hessian(n,n))

      fp = self(p)
      g = dself(p)

      hessian = ZERO
      do i = 1,n
         hessian(i,i) = ONE
      end

      xi = -g
      iter = 0
      fail = FALSE

      do

         iter = iter + 1

         pnew = p

         xi = (stp/xi.norm) * xi ! This is new

         VEC{REAL}:line_minimize_from(self,pnew,xi,fret,tol,fp,this_stp)

         stp = stp*sqrt(abs(this_stp))
         fp = fret
         xi = pnew - p
         p = pnew

         if (xi.largest_value<tol) exit

         dg = g
         g = dself(p)
         if (g.largest_value<gtol) exit

         dg = g - dg

         hdg.to_product_of(hessian,dg)

         fac   = dg.dot(xi)
         fae   = dg.dot(hdg)
         sumdg = dg.dot(dg)
         sumxi = xi.dot(xi)

         if (fac**2>eps*sumdg*sumxi) then
            fac = ONE/fac
            fad = ONE/fae
            dg = fac*xi - fad*hdg
            hessian = hessian + fac * xi.outer_product_with(xi)   &
                              - fad * hdg.outer_product_with(hdg) &
                              + fae * dg.outer_product_with(dg)
            xi.minus_product_of(hessian,g)
         end

         if (i > itmax) then
            fail = TRUE
            exit
         end

      end

      DIE_IF(fail,"exceeded allowed iterations")

      deallocate(hessian)
      xi.destroy
      pnew.destroy
      hdg.destroy
      dg.destroy
      g.destroy

   end

   minimize_L_BFGS(dself,x,m,x_min,tol,max_it,it) ::: routinal, public
   ! Use the limited memory Broyden-Fletcher-Goldfarb-Shanno
   ! method to minimise a vector function self(x) with derivative
   ! function dself(x) starting from an initial point "x",
   ! returning the minimum point in "x_min", to a tolerance "tol"
   ! if present, otherwise it is set to 10^-3. A total of "m" vectors
   ! can be stored at any one time. If "max_it" is present, set that
   ! to be the maximum iterations, otherwise it
   ! is 1000 and "it" represents the number of iterations required
   ! to reach the minima. This code is all per the algorithm from
   ! Nocedal & Wright
      m :: INT, IN
      x :: VEC{REAL}, IN
   ! Interface for vector functions   
      interface
         self(x,res)
            x :: VEC{REAL}, IN
            res :: REAL, OUT
         end
      end
      interface
         dself(x,res)
            x :: VEC{REAL}, IN
            res :: VEC{REAL}, OUT
         end
      end
      
      x_min :: VEC{REAL}, OUT
      it :: INT, OUT
      tol :: REAL, optional, IN
      max_it :: INT, optional, IN
      k,j,n,iter :: INT
      
      ! mag represents the change in each iteration, alpha, c1 and c2 are
      ! used in the line search algorithm and beta, gamma and rho are
      ! used in the Hessian approximation
      mag,c1,c2,alpha,beta,gamma,eps,rho :: REAL
      
      ! a is used to store the various alpha values in the two loop
      ! recursion, p,q and r are used as generic vectors, and as part
      ! of the two loop recursion process
      a,p,q,r :: VEC{REAL}*
      
      ! used to calculate the vectors stored in S and Y and the
      ! diagonal Hessian, H
      x_0,x_1 :: VEC{REAL}(size(x))
      
      ! Represents the change in x vector, S, change in y
      ! vector, Y
      S,Y :: MAT{REAL}, PTR
   
      n = size(x)
      p.create(n)
      q.create(n)
      r.create(n)
      a.create(m)
      allocate(S(n,m))
      allocate(Y(n,m))

      ! Sets the iteration and step limits, if there is none input by
      ! the user
      iter = 1000
      eps = 10d-4
      if(present(max_it)) iter = max_it
      if(present(tol)) eps = tol

      ! The values used for line search algorithms. These values are
      ! the ones which usually work.
      c1 = 10d-4
      c2 = 9d-1
      
      ! Zeroes the S and Y matrices which store the s and y vectors.
      S = ZERO
      Y = ZERO

      ! Ensures the do while loop is entered
      k = 0
      mag = ONE

      ! Initialises the value of q, for use in step descent
      ! calculation 
      call dself(x,q)
      
      ! Initialises the values used in the two-loop recursion.
      rho = 1
      a = ZERO
      gamma = 1 
      
      ! Will cause the program to exit if a suitable step can not be
      ! determined 
      alpha = ZERO
      
      x_1 = x

      ! Performs the loop until convergence, or the maximum number of
      ! iterations are reached.
      do while((mag>eps) AND (k <= iter))

      ! The two loop recursion process approximates the Hessian by
      ! using stored values of delta x and delta grad, as well as a
      ! pre-scaling, gamma, to allow for a stepping at alpha = 1, to
      ! be suitable 
         
      ! H^0 is approximated by I   
         

         do j = k,max(1,k-m),-1
            n = mod(j,m)
            if (n==0) then
               n = m
            end if
            rho = 1/(dot_product(Y(:,n),S(:,n)))
            a(n) = rho*dot_product(S(:,n),q)
            q = q - a(n)*Y(:,n)
         end do

         r = gamma*q

         do j = max(1,k-m),k
            n = mod(j,m)
            if (n==0) then
               n = m
            end if
            rho = 1/dot_product(Y(:,n),S(:,n))
            beta = rho*dot_product(Y(:,n),r) 
            r = r + (a(n) - beta)*S(:,n)
         end do

      ! This is the step toward the minimum
         p = -r

      ! Fines the ideal multiple of the step to take (usually 1)
      ! and stores that in alpha
         VEC{REAL}::line_search(self,dself,10d0,x_1,p,c1,c2,alpha)
         
      ! Performs the step (and stores the previous x value)
         x_0 = x_1
         x_1 = x_1 + alpha*p
         
      ! Stores the vectors, s and y, in matrices S and Y. If there
      ! are already m vectors, then it overwrites the oldest
      ! vector.
         n = mod(k,m) + 1
         S(:,n) = x_1 - x_0
         call dself(x_1,q)
         call dself(x_0,p)
         Y(:,n) = q - p

      ! Calculates the pre-scaling for H
         gamma = dot_product(S(:,n),Y(:,n))/dot_product(Y(:,n),Y(:,n))
         
      ! Updates the iteration number and calculates the shift (to
      ! check for convergence)
         k = k + 1
         mag = norm2(S(:,n))
      end do

      ! Puts results to outputs
      x_min = x_1
      it = k

      ! Cleanup
      deallocate(S,Y)
      p.destroy
      q.destroy
      r.destroy
     
   end
  
   minimize_FRPR(dself,p,fret,tol,ftol,algorithm,step) ::: routinal
   ! Use the Fletcher-Reeves-Polak-Ribiere method to minimise a vector
   ! function self(p) with derivative function dself(p) starting from
   ! an initial point "p", returning the minimum point in "p", to a
   ! tolerance "tol" and the minimum function value in "fret" to a
   ! tolerance "ftol". "algorithm" (if present) can be set to
   ! "Polak-Ribiere" (default) or "Fletcher-Reeves".
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      interface
         dself(p) result (res)
            p :: VEC{REAL}, IN
            res :: VEC{REAL}(size(p))
         end
      end
      p :: VEC{REAL}
      fret,tol,ftol :: REAL
      algorithm :: STR, optional
      step :: REAL, optional

      itmax :: INT = 200
      n,iter :: INT
      stp,this_stp,dgg,fp,gam,gg,dtol :: REAL
      g,h,xi :: VEC{REAL}*
      alg :: STR
      fail :: BIN

      alg = "Polak-Ribiere"
      if (present(algorithm)) alg = algorithm

      stp = ONE
      if (present(step)) stp = step

      n = size(p)
      g.create(n)
      h.create(n)
      xi.create(n)

      fp = self(p)

      fret = fp
      xi = dself(p)
      g = -xi
      h = g
      xi = h
      iter = 0
      fail = FALSE

      do

         iter = iter + 1

         dtol = xi.largest_value
         if (dtol<tol) exit

         xi = (stp/xi.norm) * xi ! This is new

         VEC{REAL}:line_minimize_from(self,p,xi,fret,tol,fp,this_stp)

         if (abs(fret-fp)<=ftol AND dtol<tol) exit

         fail = iter>=itmax
         if (fail) exit

         stp = stp*sqrt(abs(this_stp))
         fp = fret
         xi = dself(p)

         gg = g.dot(g)
         if (gg==ZERO) exit

         dgg = ZERO
         select case (alg)
            case("Polak-Ribiere  "); dgg = xi.dot(xi) + g.dot(xi)
            case("Fletcher-Reeves"); dgg = xi.dot(xi)
            case default;        UNKNOWN(alg)
         end

         gam = dgg/gg
         g = -xi
         h = g + gam*h
         xi = h

      end

      DIE_IF(fail,"exceeded allowed iterations")

      xi.destroy
      h.destroy
      g.destroy

   end

   minimize_powell(p,directions,fret,tol,ftol) ::: routinal
   ! Use Powell's method to minimise a vector function self(p) starting from
   ! an initial point "p" along the initial (columns of) "directions", returning
   ! the minimum point in "p", the minimum function value in "fret" to a
   ! tolerance "ftol", and "tol" in the vector coordinates "p".
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      p :: VEC{REAL}
      directions :: MAT{REAL}
      fret,tol,ftol :: REAL

   ENSURE(size(p)==size(directions,1),"incompatible initial data")
   ENSURE(size(p)==size(directions,2),"incompatible initial data")

      itmax :: INT = 200
      n,iter,i,ibig :: INT
      del,fp,fptt,t :: REAL
      pt,ptt,xit :: VEC{REAL}*
      fail :: BIN
      n = size(p)
      pt.create(n)
      ptt.create(n)
      xit.create(n)
      fret = self(p)
      pt = p                                    ! Save initial point
      iter = 0
      fail = FALSE
      do                                        ! Iteration loop

         iter = iter + 1

         fp = fret
         ibig = 0
         del = 0
         do i = 1,n                             ! Loop over all directions in set
            xit = directions(:,i)               ! Get direction
            fptt = fret
            VEC{REAL}:line_minimize_from(self,p,xit,fret,tol) ! Minimize along direction
            if (abs(fptt-fret)>del) then        ! Save if largest decrease so far
               del = abs(fptt-fret)
               ibig = i
            end
         end

         if (TWO*abs(fp-fret)<=ftol*(abs(fp)+abs(fret))) exit

         fail = iter>=itmax
         if (fail) exit

         ptt = TWO*p - pt                       ! Construct extrapolated point and the
         xit = p - pt                           ! average direction moved; save old
         pt = p                                 ! starting point
         fptt = self(ptt)
         if (fptt>=fp) cycle
         t = TWO*(fp-TWO*fret+fptt)*(fp-fret-del)**2-del*(fp-fptt)**2
         if (t>=0) cycle

         VEC{REAL}:line_minimize_from(self,p,xit,fret,tol)    ! Move to minimum of the new direction

         directions(:,ibig) = directions(:,n)
         directions(:,n) = xit

      end

      DIE_IF(fail,"exceeded allowed iterations")
      xit.destroy
      ptt.destroy
      pt.destroy

   end

   line_minimize_from(p,direction,fret,tol,f0,del) ::: routinal ! Given a vector function self(x), minimise from point "p" along "direction".
   ! Return the minimum point in "p" and the minimum value "fret", with an
   ! accuracy "tol". If "f0" is present it is used as the value of the function
   ! "self" at p, f0 = self(p). If "del" is present it is set to the length
   ! along "direction" where p achieved its minimum, useful for monitoring the
   ! step size.
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      fret,tol :: REAL
      f0,del :: REAL, optional
      a,x,b,fa,fx,fb,xmin :: REAL
      a = ZERO
      x = ONE
      VEC{REAL}:bracket_minimum(self,p,direction,a,x,b,fa,fx,fb,f0)
      VEC{REAL}:minimize_brent(self,p,direction,a,x,b,xmin,fret,tol,fx)
      if (present(del)) del = xmin
   end

   bracket_minimum(p,direction,a,b,c,fa,fb,fc,fa0,fb0) ::: routinal
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a" and "b" along "direction" from "p", search in
   ! the downhill direction and return new distances "a", "b" and "c" along
   ! "direction" from "p" that bracket a minimum of the function self, and
   ! return the values of the function "fa", "fb", and "fc" at these points.
   ! NOTE: "c" is not used initially.
   ! If present, "fa0" is the initial value of self at a, fa0 = self(a).
   ! If present, "fb0" is the initial value of self at b, fb0 = self(b).
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,fa,fb,fc :: REAL
      fa0,fb0 :: REAL, optional

   ENSURE(size(p)==size(direction),"incompatible vectors")

      gold :: REAL = 1.618034
      glimit :: REAL = 100
      tiny :: REAL = 1.0d-20
      fu,q,r,u,ulim :: REAL
      iter :: INT
      fail :: BIN

      if (present(fa0)) then; fa = fa0
      else;                   fa = self(p + a*direction)
      end

      if (present(fb0)) then; fb = fb0
      else;                   fb = self(p + b*direction)
      end

      if (fb>fa) then
        a.swap_with(b)
        fa.swap_with(fb)
      end

      c  = b + gold*(b-a)
      fc = self(p + c*direction)
      fail = TRUE
      fu = ZERO

      do iter = 1, 100
         if (fb<fc) then
           fail = FALSE
           exit                           ! bracket found
         end
         r = (b-a)*(fb-fc)                ! get u by parabolic extrapolation
         q = (b-c)*(fb-fa)
         u = b - ((b-c)*q-(b-a)*r)/(TWO*sign(max(abs(q-r),tiny),q-r))
         ulim = b + glimit*(c-b)
         if ((b-u)*(u-c)>ZERO) then       ! Parabolic u lies between b and c
            fu = self(p + u*direction)
            if (fu<fc) then               ! got a minimum between b and c
               a = b; fa = fb
               b = u; fb = fu
               fail = FALSE
               exit
            else if (fu>fb) then          ! got a minimum between a and u
               c = u; fc = fu
               fail = FALSE
               exit
            end
            u = c + gold*(c-b)            ! parabolic fit no use, so magnify
            fu = self(p + u*direction)
         else if ((c-u)*(u-ulim)>0) then ! Fit is between c and its allowed limit
            fu = self(p + u*direction)
            if (fu<fc) then
               b = c; fb = fc
               c = u; fc = fu
               u = c + gold*(c-b)
               fu = self(p + u*direction)
            end
         else if ((u-ulim)*(ulim-c)>0) then
            u = ulim
            fu = self(p + u*direction)
         else
            u = c + gold*(c-b)            ! magnify
            fu = self(p + u*direction)
         end
         a = b; fa = fb
         b = c; fb = fc
         c = u; fc = fu
      end

      WARN_IF(fail, "exceeded maximum iterations")

      if (a>c) then
         a.swap_with(c)
         fa.swap_with(fc)
      end

   end

   minimize_brent(p,direction,a,b,c,xmin,f,tol,fb0) ::: routinal
   ! Given a vector function self(x), an initial point "p", a "direction", and
   ! initial distances "a", "b" and "c" along "direction" from "p" which
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at
   ! the minimum to a precision "tol", using Brent's search method.
   ! If present, "fb0" is the initial value of self at b, fb0 = self(b)
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,xmin,f,tol :: REAL
      fb0 :: REAL, IN, optional

   ENSURE(size(p)==size(direction),"incompatible vectors")

      itmax :: INT = 100
      cgold :: REAL = 0.3819660d0
      zeps :: REAL = TOL(10)
      d,e,etemp,fu,fv,fw,fx,pp,qq,r,tol1,tol2,u,v,w,x,xm :: REAL
      iter,iters :: INT
      fail :: BIN

      if (a>c) a.swap_with(c)
      v = b
      w = b
      x = b

      if (present(fb0)) then; fx = fb0
      else;                   fx = self(p + x*direction)
      end

      fv = fx
      fw = fx
      d = ZERO
      e = ZERO
      fail = TRUE
      b = c
      iters=0
      fu = ZERO

      do iter = 1,itmax
         xm = HALF*(a+b)
         tol1 = tol*abs(x) + zeps
         tol2 = TWO*tol1
         if (abs(x-xm)<(tol2-HALF*(b-a))) then
            fail = FALSE
            exit
         end
         if (abs(e)>tol1) then
            r = (x-w)*(fx-fv)
            qq = (x-v)*(fx-fw)
            pp = (x-v)*qq - (x-w)*r
            qq = TWO*(qq-r)
            if (qq>ZERO) pp = -pp
            qq = abs(qq)
            etemp = e
            e = d
            if (abs(pp)>=abs(HALF*qq*etemp) OR pp<=qq*(a-x) OR pp>=qq*(b-x)) then
              if (x>=xm) then; e = a-x
              else;            e = b-x
              end
              d = cgold*e
            else
              d = pp/qq
              u = x + d
              if ((u-a)<tol2 OR (b-u)<tol2) d = sign(tol1,xm-x)
            end
         else
           if (x>=xm) then; e = a-x
           else;            e = b-x
           end
           d = cgold*e
         end
         if (abs(d)>=tol1) then; u = x + d
         else;                   u = x + sign(tol1,d)
         end
         fu = self(p + u*direction)
         if (fu<=fx) then
            if (u>=x) then; a = x
            else;           b = x
            end
            v = w; fv = fw
            w = x; fw = fx
            x = u; fx = fu
         else
            if (u<x) then; a = u
            else;          b = u
            end
            if (fu<=fw OR w==x) then
               v = w; fv = fw
               w = u; fw = fu
            else if (fu<=fv OR v==x OR v==w) then
               v = u; fv = fu
            end
         end
         iters=iters+1
      end
      DIE_IF(fail,"maximum iterations exceeded")
      f = fx
      xmin = x
      p = p + x*direction
   end

   minimize_golden(p,direction,a,b,c,xmin,f,tol) ::: routinal
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a", "b" and "c" along "direction" from "p" which
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at
   ! the minimum to a precision "tol", using the golden section search method.
      interface
         self(p) result (res)
            p :: VEC{REAL}, IN
            res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,xmin,f,tol :: REAL

   ENSURE(size(p)==size(direction),"incompatible vectors")

      r :: REAL = 0.618033399
      s,f1,f2,x0,x1,x2,x3 :: REAL
      s = ONE - r
      x0 = a
      x3 = c
      if (abs(c-b)>abs(b-a)) then
         x1 = b; x2 = b + s*(c-b)
      else
         x2 = b; x1 = b - s*(b-a)
      end
      f1 = self(p + x1*direction)
      f2 = self(p + x2*direction)
      do
         if (abs(x3-x0)<=tol*(abs(x1)+abs(x2))) exit
         if (f2<f1) then
            x0 = x1
            x1 = x2
            x2 = r*x1 + s*x3
            f1 = f2
            f2 = self(p + x2*direction)
         else
            x3 = x2
            x2 = x1
            x1 = r*x2 + s*x0
            f2 = f1
            f1 = self(p + x1*direction)
         end
      end
      if (f1<f2) then; f = f1; xmin = x1; p = p + x1*direction
      else;            f = f2; xmin = x2; p = p + x2*direction
      end
   end

! These methods use a different routinal

   minimize_BFGS_v2(p,fret,tol,gtol,step,max_it) ::: routinal
   ! Use the Broyden-Fletcher-Goldfarb-Shanno (BFGS) method to
   ! minimise a vector function self(x,f,dval) of variables "x" which
   ! retuns result "f" with gradient "df", starting from an initial
   ! point "p". The routine returns the minimum point in "p", to a
   ! tolerance "gtol" in the gradient. If "step" is present it
   ! determines the size of the initial step in the line minimisation
   ! along the gradient direction. If "max_it" is present, set that to
   ! be the maximum iterations
      interface
         self(x,f,df) 
            x  :: VEC{REAL}, IN
            f  :: REAL, OUT
            df :: VEC{REAL}, optional, OUT
         end
      end
      p :: VEC{REAL}
      fret :: REAL
      tol,gtol :: REAL, IN
      step :: REAL, optional
      max_it :: INT, optional, IN

      n,iter,i,itmax :: INT
      fac,fad,fae,fp,sumdg,sumxi,eps, stp,this_stp :: REAL
      g,dg,hdg,pnew,xi :: VEC{REAL}*
      hessian :: MAT{REAL}, PTR
      fail :: BIN

      eps = tol/FOUR

      stp = ONE
      if (present(step)) stp = step

      itmax = 200
      if (present(max_it)) itmax = max_it

      n = size(p)
      g.create(n)
      dg.create(n)
      hdg.create(n)
      pnew.create(n)
      xi.create(n)
      allocate(hessian(n,n))

      call self(p,fp,g)

      hessian = ZERO
      do i = 1,n
         hessian(i,i) = ONE
      end

      xi = -g
      iter = 0
      fail = FALSE

      do

         iter = iter + 1

         pnew = p

         xi = (stp/xi.norm) * xi ! This is new

         VEC{REAL}:line_minimize_from_v2(self,pnew,xi,fret,tol,fp,this_stp)

         stp = stp*sqrt(abs(this_stp))
         fp  = fret
         xi  = pnew - p
         p   = pnew
         dg  = g

         call self(p,fac,g)

         if (xi.largest_value<tol OR g.largest_value<gtol) exit

         dg = g - dg
         hdg.to_product_of(hessian,dg)

         fac   = dg.dot(xi)
         fae   = dg.dot(hdg)
         sumdg = dg.dot(dg)
         sumxi = xi.dot(xi)

         if (fac**2>eps*sumdg*sumxi) then
            fac = ONE/fac
            fad = ONE/fae
            dg = fac*xi - fad*hdg
            hessian = hessian + fac * xi.outer_product_with(xi)   &
                              - fad * hdg.outer_product_with(hdg) &
                              + fae * dg.outer_product_with(dg)
            xi.minus_product_of(hessian,g)
         end

         if (i > itmax) then
            fail = TRUE
            exit
         end

      end

      DIE_IF(fail,"exceeded allowed iterations")

      deallocate(hessian)
      xi.destroy
      pnew.destroy
      hdg.destroy
      dg.destroy;
      g.destroy

   end

   minimize_FRPR_v2(p,fret,tol,ftol,algorithm,step) ::: routinal
   ! Use the Fletcher-Reeves-Polak-Ribiere (FRPR) method to minimise a
   ! vector function self(x,f,df) of variables "x" which returns
   ! result "f" and gradient "df", starting from an initial point "p",
   ! returning the minimum point in "p", to a tolerance "tol" and the
   ! minimum function value in "fret" to a tolerance "ftol".
   ! "algorithm" (if present) can be set to "Polak-Ribiere" (default)
   ! or "Fletcher-Reeves".
      interface
         self(x,f,df) 
            x  :: VEC{REAL}, IN
            f  :: REAL, OUT
            df :: VEC{REAL}, optional, OUT
         end
      end
      p :: VEC{REAL}
      fret,tol,ftol :: REAL
      algorithm :: STR, optional
      step :: REAL, optional

      itmax :: INT = 200
      n,iter :: INT
      stp,this_stp,dgg,fp,gam,gg,dtol :: REAL
      g,h,xi :: VEC{REAL}*
      alg :: STR
      fail :: BIN

      alg = "Polak-Ribiere"
      if (present(algorithm)) alg = algorithm

      stp = ONE
      if (present(step)) stp = step

      n = size(p)
      g.create(n)
      h.create(n)
      xi.create(n)

      call self(p,fp,xi)

      fret = fp
      g = -xi
      h = g
      xi = h
      iter = 0
      fail = FALSE

      do

         iter = iter + 1

         dtol = xi.largest_value
         if (dtol<tol) exit

         xi = (stp/xi.norm) * xi ! This is new
         VEC{REAL}:line_minimize_from_v2(self,p,xi,fret,tol,fp,this_stp)

         if (abs(fret-fp)<=ftol AND dtol<tol) exit

         stp = stp*sqrt(abs(this_stp))

         fail = iter>=itmax
         if (fail) exit

         call self(p,fp,xi)

         gg = g.dot(g)
         if (gg==ZERO) exit

         dgg = ZERO
         select case (alg)
            case("Polak-Ribiere  "); dgg = xi.dot(xi) + g.dot(xi)
            case("Fletcher-Reeves"); dgg = xi.dot(xi)
            case default;            UNKNOWN(alg)
         end

         gam = dgg/gg
         g = -xi
         h = g + gam*h
         xi = h

      end

      DIE_IF(fail,"exceeded allowed iterations")

      xi.destroy
      h.destroy
      g.destroy

   end

   line_minimize_from_v2(p,direction,fret,tol,f0,del) ::: routinal
   ! Given a vector function self(x,f,df) of variables "x" which returns result
   ! "f" and gradient "df", minimise from point "p" along "direction".  Return
   ! the minimum point in "p" and the minimum value "fret", with an accuracy
   ! "tol". If "f0" is present it is used as the value of the function "self" at
   ! p, f0 = self(p).  If "del" is present it is set to the length along
   ! "direction" where p achieved its minimum, useful for monitoring the step
   ! size. NOTE: returned gradient "df" is not used.
      interface
         self(x,f,df) 
            x  :: VEC{REAL}, IN
            f  :: REAL, OUT
            df :: VEC{REAL}, optional, OUT
         end
      end
      p,direction :: VEC{REAL}
      fret,tol :: REAL
      f0,del :: REAL, optional

      a,x,b,fa,fx,fb,xmin :: REAL

      a = ZERO
      x = ONE
      VEC{REAL}:bracket_minimum_v2(self,p,direction,a,x,b,fa,fx,fb,f0)
      VEC{REAL}:minimize_brent_v2(self,p,direction,a,x,b,xmin,fret,tol,fx)
      if (present(del)) del = xmin

   end

   bracket_minimum_v2(p,direction,a,b,c,fa,fb,fc,fa0,fb0) ::: routinal
   ! Given a vector function self(x,f,df) of variables "x" which returns result
   ! "f" and gradient "df", an initial point "p" and a "direction", and initial
   ! distances "a" and "b" along "direction" from "p", search in the downhill
   ! direction and return new distances "a", "b" and "c" along "direction" from
   ! "p" that bracket a minimum of the function self, and return the values of
   ! the function "fa", "fb", and "fc" at these points.  NOTE: "c" is not used
   ! initially. NOTE: the gradient "df" is not used at all.
   ! If present, "fa0" is the initial value of self at a, fa0 = self(a).
   ! If present, "fb0" is the initial value of self at b, fb0 = self(b).
      interface
         self(x,f,df) 
            x  :: VEC{REAL}, IN
            f  :: REAL, OUT
            df :: VEC{REAL}, optional, OUT
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,fa,fb,fc :: REAL
      fa0,fb0 :: REAL, optional

   ENSURE(size(p)==size(direction),"incompatible vectors")

      gold :: REAL = 1.618034
      glimit :: REAL = 100
      tiny :: REAL = 1.0d-20
      fu,q,r,u,ulim :: REAL
      iter :: INT
      fail :: BIN

      if (present(fa0)) then; fa = fa0
      else;                   call self(p+a*direction,fa)
      end

      if (present(fb0)) then; fb = fb0
      else;                   call self(p+b*direction,fb)
      end

      if (fb>fa) then
        a.swap_with(b)
        fa.swap_with(fb)
      end

      c  = b + gold*(b-a)
      call self(p+c*direction,fc)
      fail = TRUE
      fu = ZERO

      do iter = 1, 100
         if (fb<fc) then
           fail = FALSE
           exit                           ! bracket found
         end
         r = (b-a)*(fb-fc)                ! get u by parabolic extrapolation
         q = (b-c)*(fb-fa)
         u = b - ((b-c)*q-(b-a)*r)/(TWO*sign(max(abs(q-r),tiny),q-r))
         ulim = b + glimit*(c-b)
         if ((b-u)*(u-c)>ZERO) then       ! Parabolic u lies between b and c
            call self(p+u*direction,fu)
            if (fu<fc) then               ! got a minimum between b and c
               a = b; fa = fb
               b = u; fb = fu
               fail = FALSE
               exit
            else if (fu>fb) then          ! got a minimum between a and u
               c = u; fc = fu
               fail = FALSE
               exit
            end
            u = c + gold*(c-b)            ! parabolic fit no use, so magnify
            call self(p+u*direction,fu)
         else if ((c-u)*(u-ulim)>0) then ! Fit is between c and its allowed limit
            call self(p+u*direction,fu)
            if (fu<fc) then
               b = c; fb = fc
               c = u; fc = fu
               u = c + gold*(c-b)
               call self(p+u*direction,fu)
            end
         else if ((u-ulim)*(ulim-c)>0) then
            u = ulim
            call self(p+u*direction,fu)
         else
            u = c + gold*(c-b)            ! magnify
            call self(p+u*direction,fu)
         end
         a = b; fa = fb
         b = c; fb = fc
         c = u; fc = fu
      end
      WARN_IF(fail, "exceeded maximum iterations")
      if (a>c) then
         a.swap_with(c)
         fa.swap_with(fc)
      end
   end

   minimize_brent_v2(p,direction,a,b,c,xmin,f,tol,fb0) ::: routinal
   ! Given a vector function self(x,f,df) of variables "x" which returns result
   ! "f" and gradient "df", an initial point "p", a "direction", and initial
   ! distances "a", "b" and "c" along "direction" from "p" which bracket a
   ! minimum in function self, return the minimum point "p" and its distance
   ! "xmin" along the "direction" from "p", and also the value "f" at the
   ! minimum to a precision "tol", using Brent's search method.
   ! If present, "fb0" in the initial value of self at b, fb0 <- self(b,fb0)
      interface
         self(x,f,df) 
            x  :: VEC{REAL}, IN
            f  :: REAL, OUT
            df :: VEC{REAL}, optional, OUT
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,xmin,f,tol :: REAL
      fb0 :: REAL, IN, optional

   ENSURE(size(p)==size(direction),"incompatible vectors")

      itmax :: INT = 100
      cgold :: REAL = 0.3819660d0
      zeps :: REAL = TOL(10)
      d,e,etemp,fu,fv,fw,fx,pp,qq,r,tol1,tol2,u,v,w,x,xm :: REAL
      iter,iters :: INT
      fail :: BIN

      if (a>c) a.swap_with(c)
      v = b
      w = b
      x = b

      if (present(fb0)) then; fx = fb0
      else;                   call self(p+x*direction,fx)
      end

      fv = fx
      fw = fx
      d = ZERO
      e = ZERO
      fail = TRUE
      b = c
      iters=0
      fu = ZERO

      do iter = 1,itmax

         xm = HALF*(a+b)
         tol1 = tol*abs(x) + zeps
         tol2 = TWO*tol1

         if (abs(x-xm)<(tol2-HALF*(b-a))) then
            fail = FALSE
            exit
         end

         if (abs(e)>tol1) then
            r = (x-w)*(fx-fv)
            qq = (x-v)*(fx-fw)
            pp = (x-v)*qq - (x-w)*r
            qq = TWO*(qq-r)
            if (qq>ZERO) pp = -pp
            qq = abs(qq)
            etemp = e
            e = d
            if (abs(pp)>=abs(HALF*qq*etemp) OR pp<=qq*(a-x) OR pp>=qq*(b-x)) then
              if (x>=xm) then; e = a-x
              else;            e = b-x
              end
              d = cgold*e
            else
              d = pp/qq
              u = x + d
              if ((u-a)<tol2 OR (b-u)<tol2) d = sign(tol1,xm-x)
            end
         else
           if (x>=xm) then; e = a-x
           else;            e = b-x
           end
           d = cgold*e
         end
         if (abs(d)>=tol1) then; u = x + d
         else;                   u = x + sign(tol1,d)
         end

         call self(p+u*direction,fu)

         if (fu<=fx) then
            if (u>=x) then; a = x
            else;           b = x
            end
            v = w; fv = fw
            w = x; fw = fx
            x = u; fx = fu
         else
            if (u<x) then; a = u
            else;          b = u
            end
            if (fu<=fw OR w==x) then
               v = w; fv = fw
               w = u; fw = fu
            else if (fu<=fv OR v==x OR v==w) then
               v = u; fv = fu
            end
         end

         iters=iters+1

      end

      DIE_IF(fail,"maximum iterations exceeded")
      f = fx
      xmin = x
      p = p + x*direction

   end

   minimize_golden_v2(p,direction,a,b,c,xmin,f,tol) ::: routinal
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a", "b" and "c" along "direction" from "p" which
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at
   ! the minimum to a precision "tol", using the golden section search method.
      interface
         self(x,f,df) 
            x  :: VEC{REAL}, IN
            f  :: REAL, OUT
            df :: VEC{REAL}, optional, OUT
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,xmin,f,tol :: REAL

   ENSURE(size(p)==size(direction),"incompatible vectors")
      r :: REAL = 0.618033399
      s,f1,f2,x0,x1,x2,x3 :: REAL

      s = ONE - r
      x0 = a
      x3 = c

      if (abs(c-b)>abs(b-a)) then
         x1 = b; x2 = b + s*(c-b)
      else
         x2 = b; x1 = b - s*(b-a)
      end

      call self(p+x1*direction,f1)
      call self(p+x2*direction,f2)

      do

         if (abs(x3-x0)<=tol*(abs(x1)+abs(x2))) exit

         if (f2<f1) then
            x0 = x1
            x1 = x2
            x2 = r*x1 + s*x3
            f1 = f2
            call self(p+x2*direction,f2)
         else
            x3 = x2
            x2 = x1
            x1 = r*x2 + s*x0
            f2 = f1
            call self(p+x1*direction,f1)
         end

      end

      if (f1<f2) then; f = f1; xmin = x1; p = p + x1*direction
      else;            f = f2; xmin = x2; p = p + x2*direction
      end

   end

!  ==================
!  Householder vector 
!  ==================

   householder_vector(nu,b) ::: PURE
   ! Given a real vector self, returns the vector with nu(1) =
   ! 1 and real part b such that P = I - b*nu*nu^T is
   ! orthogonal. Furthermore P*self = norm2(x)*e_1
      self :: IN
      nu :: VEC{REAL}*, OUT
      b :: REAL, OUT ! b represents beta

   ENSURE(size(nu)==size(self),"incompatible vectors")

      s,m :: REAL ! s represents sigma and m represents mu
      dim :: INT

      dim = .dim
      s = dot_product(self(2:dim),self(2:dim))
      nu(1) = ONE
      nu(2:dim) = self(2:dim)

      ! if s == 0 self is already orthogonal,
      ! so no calcs required.
      if (s == 0) then

         b = 0

      else

         m = sqrt(self(1)**2+s)
         if (self(1) <=  0) then
            nu(1) = self(1)-m
         else
            nu(1) = -(s/(self(1)+m))
         end if
         ! beta is such that it normalises P
         b = 2*(nu(1)**2)/(s + nu(1)**2)
         nu(:) = nu(:)/nu(1)

      end if

   end

!  ====================
!  Fast Givens rotation 
!  ====================

   fast_givens_transformation(d,alpha,beta,typ) ::: PURE
   ! Given a real vector, x and positive diagonal matrix d
   ! computes the fast 2x2 Givens transformation such that
   ! M^Tx is zero and M^(T)DM is diagonal
      self :: IN
      d :: VEC{REAL}(2), INOUT ! d is the input diagonal matrix, altered to D
      typ :: INT, OUT          ! typ indicates the type of the transform
      alpha,beta :: REAL, OUT

   ENSURE(size(self)==2,"incorrect dimension of self")
   ENSURE(size(d)==2,"incorrect dimension of d")
   ENSURE(d(1)>0, "d(1) not positive")
   ENSURE(d(2)>0, "d(2) not positive")

      tau,gamma :: REAL

      if (self(2) /= 0) then

         ! By defining alpha, beta and gamma like this, M^Tx produces
         ! zero.
         alpha = -self(1)/self(2)
         beta  = -alpha*d(2)/d(1)
         gamma = -alpha*beta

         if (gamma <= 1) then

            ! type 1 is defined by alpha and beta on the diagonal.
            typ = 1
            tau = d(1)
            d(1) = (1+gamma)*d(2)
            d(2) = (1+gamma)*tau

         else

            ! type 2 is defined by 1's on the diagonal and alpha and
            ! beta onm the off diagonal.
            typ = 2
            alpha = 1/alpha
            beta = 1/beta
            gamma = 1/gamma
            d(1) = (1+gamma)*d(1)
            d(2) = (1+gamma)*d(2)

         end

      else

         typ   = 2
         alpha = 0
         beta  = 0

      end if

   end

!  =====================
!  3D Hermite polynomial
!  =====================

   hermite_polynomial_prob(n) result (res) ::: PURE
   ! Return the probabilists hermite polynomial with powers n(1),
   ! n(2), and n(3) for each of the cartesian directions.
      self :: IN
      n :: VEC{INT}(3), IN
      res :: REAL

      H :: VEC{REAL}(3)

      H(1) = self(1).hermite_polynomial_prob(n(1))
      H(2) = self(2).hermite_polynomial_prob(n(2))
      H(3) = self(3).hermite_polynomial_prob(n(3))

      res  = H(1)*H(2)*H(3)

   end

!  ======================
!  Line search operations
!  ======================

   goldstein_line_search(dself,a,alphamax,x,p,c1,alpha) ::: routinal
   ! Given a real vector, x, function f, gradient function
   ! df, calculaes the ideal stepping scale alpha, given
   ! stepping p and constants c1, c2.
   ! NB: needs more testing
      interface
         self(x,res)
            x :: VEC{REAL}, IN
            res :: REAL, OUT
         end
      end
      interface
         dself(x,res)
            x :: VEC{REAL}, IN
            res :: VEC{REAL}, OUT
         end
      end
      x :: VEC{REAL}, IN
      p :: VEC{REAL}, INOUT
      c1,a,alphamax :: REAL, IN
      alpha :: REAL, OUT

      b,alpha0,phi0,phi1,phi,dphi0 :: REAL
      temp :: VEC{REAL}*
      iter,j :: INT
      converged :: BIN
      iter = 10000
      
      temp.create(size(x))

      alpha0 = 0
      call self(x,phi0)
      call dself(x,temp)
      dphi0 = dot_product(temp,p)
      phi1 = 100
      alpha = a
      j = 0
      converged = FALSE 
      b = alphamax

      do while ((converged EQV FALSE) AND (j < iter)) 
         call self(x+alpha*p,phi)

         if (phi <= phi0 + c1*alpha*dphi0) then
            if (phi >= phi0 + (1 - c1)*alpha*dphi0) then
               converged = TRUE
            else
               alpha0 = alpha
            end if
         else
            b = alpha
         end if
         if (converged EQV TRUE) cycle
            alpha = (alpha0 + b)/2
            j = j + 1

     end
      temp.destroy
   end

   wp_line_search(dself,a,alphamax,x,p,c1,c2,alpha) ::: routinal
   ! Given a real vector, x, function f, gradient function
   ! df, calculaes the ideal stepping scale alpha, given
   ! stepping p and constants c1, c2.
   ! NB: needs more testing
      interface
         self(x,res)
            x :: VEC{REAL}, IN
            res :: REAL, OUT
         end
      end
      interface
         dself(x,res)
            x :: VEC{REAL}, IN
            res :: VEC{REAL}, OUT
         end
      end
      x :: VEC{REAL}, IN
      p :: VEC{REAL}, INOUT
      c1,c2,a,alphamax :: REAL, IN
      alpha :: REAL, OUT

      alpha1,alpha2,phi1,phi,dphi,dphi1 :: REAL
      temp :: VEC{REAL}*
      iter,j :: INT
      converged :: BIN
      iter = 10000
      
      temp.create(size(x))

      alpha1 = 0
      call self(x,phi1)
      call dself(x,temp)
      dphi1 = dot_product(temp,p)
      alpha = a
      j = 0
      converged = FALSE 
      alpha2 = alphamax

      do while ((converged EQV FALSE) AND (j < iter)) 
         call self(x+alpha*p,phi)

         if (phi <= phi1 + c1*alpha*dphi1) then
            call dself(x+alpha*p,temp)
            dphi = dot_product(temp,p)
            if (dphi >= c2*dphi1) then
               converged = TRUE
            else
               phi1 = phi
               dphi1 = dphi
               alpha1 = alpha
               alpha = alpha + ((alpha - alpha1)*dphi)/(dphi1 - dphi)
            end if
         else
            alpha2 = alpha
            alpha = alpha1 + &
                HALF*(alpha-alpha1)/(1+(phi1-phi)/((alpha-alpha1)*dphi1))
         end if
         if (converged EQV TRUE) cycle
            j = j + 1
     end
     temp.destroy
   end

   line_search(dself,alphamax,x,p,c1,c2,b) ::: routinal, public
   ! Given a real vector, x, function f, gradient function
   ! df, calculaes the ideal stepping scale alpha, given
   ! stepping p and constants c1, c2.
      
   ! Interface for vector functions   
      interface
         self(x,res)
            x :: VEC{REAL}, IN
            res :: REAL, OUT
         end
      end
      interface
         dself(x,res)
            x :: VEC{REAL}, IN
            res :: VEC{REAL}, OUT
         end
      end
      x :: VEC{REAL}, IN
      p :: VEC{REAL}, IN
      
      ! Wolfe constants c1 and c2 and a highest value of alpha
      c1,c2,alphamax :: REAL, IN
      
      ! The output alpha value
      b :: REAL, OUT

      ! alpha is the current value of alpha. alpha0 is the previous
      ! value. phi0 is the initial phi value, phi1 is the previous phi
      ! value and phi is thge current phi value. The same is true for
      ! dphi0, dphi1 and dphi.
      alpha,alpha0,phi0,phi1,phi,dphi,dphi0,dphi1 :: REAL
      
      ! temp is used in vector dot product calculations. Such as in
      ! phi' (dphi)
      temp :: VEC{REAL}*
      
      ! The maximum (iter) and current (j) number of iterations
      iter,j :: INT
      
      ! Logical for if the loop can conclude
      converged :: BIN

      ! The maximum number of iterations that may be performed
      iter = 10000
      
      ! Allows temp to be used for calculations
      temp.create(size(x))

      ! Gives the first value of alpha
      alpha = rand(1)*alphamax 
      
      ! Initialise alpha0, phi0, dphi0, phi1, j and converged
      alpha0 = 0
      call self(x,phi0)
      call dself(x,temp)
      dphi0 = dot_product(temp,p)
      call self(x+alpha*p,phi1)
      phi1 = phi1-1
      j = 0
      converged = FALSE 

      ! Performs the loop until it has converged or the loop has
      ! failed
      do while ((converged EQV FALSE) AND (j < iter)) 
         
      ! calculates phi for this iteration
         call self(x+alpha*p,phi)

      ! The interval alpha0, alpha will contain ideal step lengths if
      ! any of the if conditionals below are violated
         if (phi > phi0 + c1*alpha*dphi0) then
      
      ! Sends the interval off to find an ideal step and stores it in
      ! b
            VEC{REAL}::zoom(self,dself,alpha0,alpha,x,p,c1,c2,b,converged)
         else if (phi >= phi1 AND j > 1) then
      
      ! Sends the interval off to find an ideal step and stores it in
      ! b
            VEC{REAL}::zoom(self,dself,alpha0,alpha,x,p,c1,c2,b,converged)
         end if
      
      ! Ensures that if alpha has converged, the value does not
      ! change   
         if (converged EQV FALSE) then
      
      ! calculates dphi for this iteration      
            call dself(x+alpha*p,temp)
            dphi = dot_product(temp,p)
      
      ! If the second wolfe condition holds, this has converged      
            if (abs(dphi) <= -c2*dphi0) then
               converged = TRUE
      ! Stores the ideal stepping in b         
               b = alpha
            else if (dphi >= 0) then
      
      ! Sends the interval off to find an ideal step and stores it in
      ! b
               VEC{REAL}::zoom(self,dself,alpha,alpha0,x,p,c1,c2,b,converged)
            end if
      
      ! Ensures that if alpha has converged, the value does not
      ! change   
            if (converged EQV FALSE) then
      ! Stores the values from this iteration, and proceeds to the
      ! next iteration         
               phi1 = phi
               dphi1 = dphi
               j = j + 1
               alpha0 = alpha
               alpha = alpha + rand(1)*alphamax
            end if
         end if
     end
     
     ! Cleanup
     temp.destroy
   end

   zoom(dself,low,high,x,p,c1,c2,alpha,converged) ::: routinal
   ! Given a real vector, x, function f, gradient function
   ! df, calculaes the ideal stepping scale alpha, given
   ! stepping p and constants c1, c2. An ideal stepping must also
   ! reside between low and high.
      
      ! Interface for vector functions   
      interface
         self(x,res)
            x :: VEC{REAL}, IN
            res :: REAL, OUT
         end
      end
      interface
         dself(x,res)
            x :: VEC{REAL}, IN
            res :: VEC{REAL}, OUT
         end
      end
      
      ! Interval in which ideal step resides, low and high and Wolfe
      ! constants c1 and c2
      low,high,c1,c2 :: REAL, IN
      x,p :: VEC{REAL}, IN
      
      ! Ideal stepping scale
      alpha :: REAL, OUT

      ! Logical which describes whether or not it has converged to an
      ! ideal step
      converged :: BIN, OUT
      
      ! Vector used in various multiplications
      temp :: VEC{REAL}*
      
      ! Flexible interval alphalo and alphahi. Initial value of phi
      ! and dphi, phi0 and dphi0. Current values at phi and dphi. phi
      ! value at alpha lo is at philo.
      alphalo,alphahi,phi0,dphi,dphi0,phi,philo :: REAL
      
      ! The current (j) and maximum (iter) number of iterations
      j,iter :: INT
      iter = 10000
      
      ! creates temp
      temp.create(size(x))
      
      ! Initialise alphalo, alphahi, phi0, dphi0, converged and j
      alphalo = low
      alphahi = high
      call self(x,phi0)
      call dself(x,temp)
      dphi0 = dot_product(temp,p)
      converged = FALSE
      j = 0
 
      ! Does the loops until interations maximum is reached or the
      ! ideal stepping is found.
      do while ((converged EQV FALSE) AND (j < iter)) 
      
      ! New value of alpha is determined by bisection
         alpha = (alphalo+alphahi)/2
         
      ! Calculates current value of philo and phi   
         call self(x+alphalo*p,philo)
         call self(x+alpha*p,phi)

      ! If either of these condition are satisfied alphahi becomes
      ! alpha amd the cycle repeats   
         if (phi > phi0+c1*alpha*dphi0) then
            alphahi = alpha
         else if (phi >= philo) then
            alphahi = alpha
         else
     
      ! Calculates the current value of dphi
            call dself(x+alpha*p,temp)
            dphi = dot_product(temp,p)

      ! Cycle is complete if strong Wolfe condition holds      
            if (abs(dphi) <= -c2*dphi0) then
               converged = TRUE
            end if

      ! Stops pointless calculations if ideal stepping has been found
            if (converged EQV FALSE) then

      ! Ensures alphahi and alphalo are the right way around         
               if (dphi*(alphahi-alphalo) >= ZERO) then
                  alphahi = alphalo
               end if
      ! alphalo becomes alpha         
               alphalo = alpha
            end if
         end if
         j = j + 1
      end
      temp.destroy
   end

! ========================
! Multipoles and harmonics
! ========================

   make_R_harmonics(Rc,Rs,point,l_max) ::: selfless, leaky, PURE
   ! Make the scaled regular solid harmonics "Rc" and "Rs" evaluated at a single
   ! "point" in space, up to angular momentum "l_max". The particular solid
   ! harmonic for quantum numbers "L" and "M" is, e.g. Rc(L).element(M) for the
   ! given "point". See the book by Helgaker, Olsen, and Simons, p. 416. 
   ! NOTE: "Rc" and "Rs" are.associated.
   ! NOTE: this routine is here because VEC{REAL} cannot use VEC{VEC_{REAL}}
      Rc,Rs :: VEC{VEC_{REAL}}*
      point :: VEC{REAL}(3), IN
      l_max :: INT, IN

   ENSURE(l_max>=0,"l_max must be non-negative")

      L,M,sn :: INT
      top,bot,fac, r2,x,y,z :: REAL

      allocate(Rc(0:l_max))
      allocate(Rs(0:l_max))
      do L = 0,l_max
         allocate(Rc(L)[-L:L])
         allocate(Rs(L)[-L:L])
      end

      Rc(0)[0] = ONE
      Rs(0)[0] = ZERO

      x  = point(1)
      y  = point(2)
      z  = point(3)
      r2 = x*x + y*y + z*z

      do L = 0,l_max-1

         bot = 2*L + 2
         top = bot - 1
         fac = ONE/bot

         Rc(L+1)[L+1] = -fac*(x*Rc(L)[L] - y*Rs(L)[L])
         Rs(L+1)[L+1] = -fac*(y*Rc(L)[L] + x*Rs(L)[L])
         Rc(L+1)[L  ] =       z*Rc(L)[L]
         Rs(L+1)[L  ] =       z*Rs(L)[L]

         do M = 0,L-1
            bot = ONE/((L+M+1)*(L-M+1))
            fac = top*bot
            Rc(L+1)[M] = fac*z*Rc(L)[M] - bot*r2*Rc(L-1)[M]
            Rs(L+1)[M] = fac*z*Rs(L)[M] - bot*r2*Rs(L-1)[M]
         end

         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)==M
            Rc(L+1)[-M] =  sn * Rc(L+1)[M]
            Rs(L+1)[-M] = -sn * Rs(L+1)[M]
         end

      end

   end

   make_R_harmonics(Rc,Rs,points,l_max) ::: selfless, leaky, PURE
   ! Make the scaled regular solid harmonics "Rc" and "Rs" evaluated at a set of
   ! "points" in space, up to angular momentum "l_max". The particular solid
   ! harmonic for quantum numbers "L" and "M" evaluated at point "points(i,:)
   ! is, e.g.  Rc(L).element(M).element(i). See the book by Helgaker, Olsen, and
   ! Simons, p. 416. 
   ! NOTE: "Rc" and Rs are.associated.
   ! NOTE: this routine is here since VEC{REAL} cannot use VEC{VEC_{VEC_{REAL}}}
      Rc,Rs :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, target, IN
      l_max :: INT, IN
   
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      r2,x,y,z :: VEC{REAL}*
      L,M,sn :: INT
      top,bot,fac :: REAL

      allocate(Rc(0:l_max))
      allocate(Rs(0:l_max))
      do L = 0,l_max
         allocate(Rc(L)[-L:L])
         allocate(Rs(L)[-L:L])
         do M = -L,L
            allocate(Rc(L)[M][points.dim1])
            allocate(Rs(L)[M][points.dim1])
         end
      end

      Rc(0)[0][:] = ONE
      Rs(0)[0][:] = ZERO

      x.create_copy(points(:,1))
      y.create_copy(points(:,2))
      z.create_copy(points(:,3))

      r2.create(points.dim)
      r2 = x*x + y*y + z*z

      do L = 0,l_max-1

         bot = 2*L + 2
         top = bot - 1
         fac = ONE/bot

         Rc(L+1)[L+1][:] = -fac*(x*Rc(L)[L][:] - y*Rs(L)[L][:])
         Rs(L+1)[L+1][:] = -fac*(y*Rc(L)[L][:] + x*Rs(L)[L][:])
         Rc(L+1)[L  ][:] =       z*Rc(L)[L][:] 
         Rs(L+1)[L  ][:] =       z*Rs(L)[L][:] 

         do M = 0,L-1
            bot = ONE/((L+M+1)*(L-M+1))
            fac = top*bot
            Rc(L+1)[M][:] = fac*z*Rc(L)[M][:] - bot*r2*Rc(L-1)[M][:]
            Rs(L+1)[M][:] = fac*z*Rs(L)[M][:] - bot*r2*Rs(L-1)[M][:]
         end

         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)==M
            Rc(L+1)[-M][:] =  sn * Rc(L+1)[M][:]
            Rs(L+1)[-M][:] = -sn * Rs(L+1)[M][:]
         end

      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_R_multipoles(qc,qs,charges,points,l_max) ::: selfless, leaky, PURE
   ! Make the scaled regular solid harmonic multipole moments "qc" and "qs" for
   ! a given set of "charges" located at a set of "points", up to a maximum
   ! angular momentum "l_max".  Reference: the book by Helgaker, Olsen, and
   ! Simons, p. 414. NOTE: "qc" and "qs" are.associated.
      qc,qs :: VEC{REAL}*
      charges :: VEC{REAL}, IN
      points :: MAT{REAL}, IN
      l_max :: INT, IN

   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      Rc,Rs :: VEC{VEC_{VEC_{REAL}}}*
      L,M,n,lm :: INT

      n = (l_max+1)*(l_max+2)/2
      qc.create(n)
      qs.create(n)

      ! Leaky
      VEC{REAL}:make_R_harmonics(Rc,Rs,points,l_max)
      lm = 0
      do L = 0,l_max
         do M = 0,L
            lm = lm + 1
            qc(lm) = VEC{REAL}:sum_elements(charges * Rc(L)[M][:])
            qs(lm) = VEC{REAL}:sum_elements(charges * Rs(L)[M][:])
         end
      end

     !  Clean
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rs(L)[M].element)
            deallocate(Rc(L)[M].element)
         end
         deallocate(Rs(L).element)
         deallocate(Rc(L).element)
      end
      deallocate(Rs)
      deallocate(Rc)

   end

   make_R_mu_harmonics(Rm,points,l_max) ::: selfless, leaky, PURE
   ! Make scaled regular mu-type solid harmonics "Rm" evaluated at set of
   ! "points" in space, up to angular momentum "l_max". The particular solid
   ! harmonic is, e.g. Rm(L).element(M).element(i) where "L" and "M" are the
   ! angular quantum numbers and "i" is the point number. See the book by
   ! Helgaker, Olsen, and Simons, p. 412 and p. 416. NOTE: "Rm" are.associated.
      Rm :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, IN
      l_max :: INT, IN

   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      L,M :: INT
      Rc,Rs :: VEC{VEC_{VEC_{REAL}}}*

      allocate(Rm(0:l_max))
      do L = 0,l_max
         allocate(Rm(L)[-L:L])
         do M = -L,L
            allocate(Rm(L)[M][points.dim1])
         end
      end

      ! Leaky
      VEC{REAL}:make_R_harmonics(Rc,Rs,points,l_max) 

      do L = 0,l_max
         do M = 0,L
            Rm(L)[M][:] = Rc(L)[M][:]
         end
         do M = -L,-1
            Rm(L)[M][:] = Rs(L)[M][:]
         end
      end

      ! Clean
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rs(L)[M].element)
            deallocate(Rc(L)[M].element)
         end
         deallocate(Rs(L).element)
         deallocate(Rc(L).element)
      end
      deallocate(Rs)
      deallocate(Rc)

   end

   make_R_mu_multipoles(q,charges,points,l_max) ::: selfless, PURE
   ! Make the scaled regular mu-type solid harmonic multipole moments "q" for a
   ! given set of "charges" located at a set of "points", up to a maximum
   ! angular momentum "l_max".  Reference: the book by Helgaker, Olsen, and
   ! Simons, p. 414. 
      q :: VEC{REAL}, OUT
      charges :: VEC{REAL}, IN
      points :: MAT{REAL}, IN
      l_max :: INT, IN

   ENSURE(q.dim==(l_max+1)*(l_max+1),"wrong size for q")
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      Rm :: VEC{VEC_{VEC_{REAL}}}*
      L,M,lm :: INT

      ! Leaky
      VEC{REAL}:make_R_mu_harmonics(Rm,points,l_max)

      lm = 0
      do L = 0,l_max
         do M = -L,L ! note the canonoical order here
            lm = lm + 1
            q(lm) = VEC{REAL}:sum_elements(charges * Rm(L)[M][:])
         end
      end

      ! Clean
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rm(L)[M].element)
         end
         deallocate(Rm(L).element)
      end
      deallocate(Rm)

   end

   add_R_mu_multipoles(q,charges,points,l_max) ::: selfless, PURE
   ! Add the scaled regular mu-type solid harmonic multipole moments "q" for a
   ! given set of "charges" located at a set of "points", up to a maximum
   ! angular momentum "l_max".  Reference: the book by Helgaker, Olsen, and
   ! Simons, p. 414. 
      q :: VEC{REAL}, OUT
      charges :: VEC{REAL}, IN
      points :: MAT{REAL}, IN
      l_max :: INT, IN

   ENSURE(q.dim==(l_max+1)*(l_max+1),"wrong size for q")
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      Rm :: VEC{VEC_{VEC_{REAL}}}*
      L,M,lm :: INT

      ! Leaky
      VEC{REAL}:make_R_mu_harmonics(Rm,points,l_max)

      lm = 0

      ! Note canonoical order here
      do L = 0,l_max
      do M = -L,L 
         lm = lm + 1
         q(lm) = q(lm) + VEC{REAL}:sum_elements(charges * Rm(L)[M][:])
      end
      end

      ! Clean
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rm(L)[M].element)
         end
         deallocate(Rm(L).element)
      end
      deallocate(Rm)

   end

   make_I_harmonics(Ic,Is,point,l_max) ::: selfless, leaky, PURE
   ! Make the scaled irregular solid harmonics "Ic" and "Is" evaluated at a
   ! single "point" in space, up to angular momentum "l_max". The particular
   ! solid harmonic for quantum numbers "L" and "M" is, e.g. Ic(L).element(M)
   ! for the given "point". See the book by Helgaker, Olsen, and Simons, p. 416.
   ! NOTE: "Ic" and "Is" are.associated.
   ! NOTE: this routine is here since VEC{REAL} cannot use VEC{VEC_{REAL}}
      Ic,Is :: VEC{VEC_{REAL}}*
      point :: VEC{REAL}(3), IN
      l_max :: INT, IN

   ENSURE(l_max>=0,"l_max must be non-negative")

      L,M,sn :: INT
      top,fac, r2,x,y,z :: REAL

      allocate(Ic(0:l_max))
      allocate(Is(0:l_max))
      do L = 0,l_max
         allocate(Ic(L)[-L:L])
         allocate(Is(L)[-L:L])
      end
      x  = point(1)
      y  = point(2)
      z  = point(3)
      r2 = ONE/(x*x + y*y + z*z)

      Ic(0)[0] = sqrt(r2)
      Is(0)[0] = ZERO

      do L = 0,l_max-1

         fac = 2*L + 1
         Ic(L+1)[L+1] = -fac*r2*(x*Ic(L)[L] - y*Is(L)[L])
         Is(L+1)[L+1] = -fac*r2*(y*Ic(L)[L] + x*Is(L)[L])
         Ic(L+1)[L  ] =  fac*z*r2 *Ic(L)[L]
         Is(L+1)[L  ] =  fac*z*r2 *Is(L)[L]

         do M = 0,L-1
            top = L*L - M*M
            Ic(L+1)[M] = r2*(fac*z*Ic(L)[M] - top*Ic(L-1)[M])
            Is(L+1)[M] = r2*(fac*z*Is(L)[M] - top*Is(L-1)[M])
         end

         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)==M
            Ic(L+1)[-M] =  sn * Ic(L+1)[M]
            Is(L+1)[-M] = -sn * Is(L+1)[M]
         end

      end

   end

   make_I_harmonics(Ic,Is,points,l_max) ::: selfless, leaky, PURE
   ! Make the scaled irregular solid harmonics "Ic" and "Is" evaluated at set of
   ! "points" in space, up to maximum angular momentum "l_max".  The particular
   ! solid harmonic for quantum numbers "L" and "M" evaluated at point
   ! "points(i,:)" is, e.g. "Ic(L).element(M).element(i)".  See the book by
   ! Helgaker, Olsen, and Simons, p. 416. 
   ! NOTE: "Ic" and "Is" are.associated.
   ! NOTE: this routine is here since VEC{REAL} cannot use VEC{VEC_{VEC_{REAL}}}
      Ic,Is :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, IN
      l_max :: INT, IN

   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      r2,x,y,z :: VEC{REAL}*
      L,M,sn :: INT
      top,fac :: REAL

      allocate(Ic(0:l_max))
      allocate(Is(0:l_max))
      do L = 0,l_max
         allocate(Ic(L)[-L:L])
         allocate(Is(L)[-L:L])
         do M = -L,L
            allocate(Ic(L)[M][points.dim1])
            allocate(Is(L)[M][points.dim1])
         end
      end

      x.create_copy(points(:,1))
      y.create_copy(points(:,2))
      z.create_copy(points(:,3))

      r2.create(points.dim)
      r2 = ONE/(x*x + y*y + z*z)
      
      Ic(0)[0][:] = sqrt(r2)
      Is(0)[0][:] = ZERO

      do L = 0,l_max-1

         fac = 2*L + 1
         Ic(L+1)[L+1][:] = -fac*r2*(x*Ic(L)[L][:] - y*Is(L)[L][:])
         Is(L+1)[L+1][:] = -fac*r2*(y*Ic(L)[L][:] + x*Is(L)[L][:])
         Ic(L+1)[L  ][:] =  fac*z*r2 *Ic(L)[L][:] 
         Is(L+1)[L  ][:] =  fac*z*r2 *Is(L)[L][:] 

         do M = 0,L-1
            top = L*L - M*M
            Ic(L+1)[M][:] = r2*(fac*z*Ic(L)[M][:] - top*Ic(L-1)[M][:])
            Is(L+1)[M][:] = r2*(fac*z*Is(L)[M][:] - top*Is(L-1)[M][:])
         end

         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)==M
            Ic(L+1)[-M][:] =  sn * Ic(L+1)[M][:]
            Is(L+1)[-M][:] = -sn * Is(L+1)[M][:]
         end

      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_I_mu_harmonics(Im,points,l_max) ::: selfless, leaky
   ! Make scaled irregular mu-type solid harmonics "Im" evaluated at set of
   ! "points" in space, up to angular momentum "l_max". The particular solid
   ! harmonic is, e.g. Im(L).element(M).element(i) where "L" and "M" are the
   ! angular quantum numbers and "i" is the point number. See the book by
   ! Helgaker, Olsen, and Simons, p. 412 and p. 416. NOTE: "Rm" are.associated.
      Im :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, IN
      l_max :: INT, IN

   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")

      L,M :: INT
      Ic,Is :: VEC{VEC_{VEC_{REAL}}}*

      allocate(Im(0:l_max))
      do L = 0,l_max
         allocate(Im(L)[-L:L])
         do M = -L,L
            allocate(Im(L)[M][points.dim1])
         end
      end

      ! Leaky
      VEC{REAL}:make_I_harmonics(Ic,Is,points,l_max) 

      do L = 0,l_max
         do M = 0,L
            Im(L)[M][:] = Ic(L)[M][:]
         end
         do M = -L,-1
            Im(L)[M][:] = Is(L)[M][:]
         end
      end

      ! Clean
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Is(L)[M].element)
            deallocate(Ic(L)[M].element)
         end
         deallocate(Is(L).element)
         deallocate(Ic(L).element)
      end
      deallocate(Is)
      deallocate(Ic)

   end

   to_multipole_T_interaction_vec(R,j_max) ::: PURE
   ! Make the multipole translation vector T(1,jk)(R) evaluated at position "R"
   ! where the maximum value of j is "j_max" and only the monopole term is
   ! calculated for the first indsex of the T matrix. This is used for
   ! evaluating the potential at the position "R" where a charge is located.
   ! See the book by Helgaker, Olsen, and Simons, equation (9.13.75), p. 415.
   ! NOTE: self is associated.
      self :: PTR
      R :: VEC{REAL}(3), IN
      j_max :: INT, IN

   ENSURE(j_max>=0,"j_max must be non-negative")
   ENSURE(.dim==(j_max+1)*(j_max+1),"self has wrong length")

      Ic,Is :: VEC{VEC_{REAL}}*
      Ic_lj,Is_lj :: VEC{REAL}*
      j,k,jk,sj,sk, L :: INT
      fac,fk :: REAL

      ! Leaky
      VEC{REAL}:make_I_harmonics(Ic,Is,R,j_max)

      jk = 0
      do j = 0,j_max

         sj = -1
         if (j.is_even) sj = 1
         sk = -sj

         ! First do k<0
         do k = -j,-1
            jk = jk + 1
            sk = -sk           ! initially,  (-1)==j
            fk = ONE
            if (k==0) fk = HALF
            Ic_lj => Ic(j).element
            Is_lj => Is(j).element
            fac = sj*fk
            self(jk) = fac*( Is_lj(k) - sk*Is_lj(-k)) ! T^cs
         end

         ! Now do k>=0
         do k = 0,j
            jk = jk + 1
            sk = -sk           ! initially,  (-1)==j
            fk = ONE
            if (k==0) fk = HALF
            Ic_lj => Ic(j).element
            Is_lj => Is(j).element
            fac = sj*fk
            self(jk) = fac*( Ic_lj(k) + sk*Ic_lj(-k)) ! T^cc
         end

      end

      ! Must deallocate Ic, Is
      do L = j_max,0,-1
         deallocate(Is(L).element)
         deallocate(Ic(L).element)
      end
      deallocate(Is)
      deallocate(Ic)

   end

! ==============
! Test functions
! ==============

   rosenbrock_function(x,res) ::: selfless, public
   ! Calculates the rosenbrock function   
      x :: VEC{REAL}, IN
      res :: REAL, OUT
      res = (1-x(1))**2+100*(x(2)-x(1)**2)**2
   end

   d_rosenbrock_function(x,res) ::: selfless, public
   ! Calculates the gradient functon of the rosenbrock function   
      x :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT
      res(1) = -2+2*x(1)-400*x(1)*(x(2)-x(1)**2)
      res(2) = -200*x(1)**2+200*x(2)
   end

   himmelblau_function(x,res) ::: selfless, public
   ! alculates the himmelblau function   
      x :: VEC{REAL}, IN
      res :: REAL, OUT
      res = (x(1)**2 + x(2) - 11)**2 + (x(1) + x(2)**2 - 7)**2
   end

   d_himmelblau_function(x,res) ::: selfless, public
   ! Calculates the gradient functon of the himmelblau function   
      x :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT
      res(1) = 4*x(1)*(x(1)**2+x(2)-11)+2*(x(1)+x(2)**2-7) 
      res(2) = 2*(x(1)**2+x(2)-11)+4*x(2)*(x(1)+x(2)**2-7)
   end

   beale_function(x,res) ::: selfless, public
   ! calculates the beale function   
      x :: VEC{REAL}, IN
      res :: REAL, OUT
      res=(1.5-x(1)*(1-x(2)))**2+(2.25-x(1)*(1-x(2)**2))**2+(2.625-x(1)*(1-x(2)**3))**2
   end

   d_beale_function(x,res) ::: selfless, public
   ! Calculates the gradient functon of the beale function   
      x :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT
      res(1) = (x(2)-1)*(2*x(1)*(x(2)-1)+3)+&
      (x(2)**2-1)/2*(4*x(1)*(x(2)**2-1)+9)+(x(2)**3-1)/4*(8*x(1)*(x(2)**3-1)+21) 
      res(2) = x(1)/4*(8*x(1)*(x(2)-1)+x(2)**2*(24*x(1)*(x(2)**3-1)+63)+4*&
      x(2)*(4*x(1)*(x(2)**2-1)+9)+12)
   end

   sphere_function(x,res) ::: selfless, public
   ! calculates the sphere function   
      x :: VEC{REAL}, IN
      res :: REAL, OUT
      i :: INT
      res = ZERO
      do i=1,size(x)
         res=res+x(i)**2
      end do
   end

   d_sphere_function(x,res) ::: selfless, public
   ! Calculates the sphere functon of the beale function   
      x :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT
      i :: INT
      do i=1,size(x)
         res(i)=2*x(i)
      end do
   end

end

