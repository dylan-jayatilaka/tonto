!---------------------------------------------------------------------------
!
!  GAUSSIAN4 : Quartets of gaussian functions
!
! Copyright (C) Dylan Jayatilaka, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: gaussian4.foo 3809 2012-10-25 06:59:50Z dylan_ $
!
!---------------------------------------------------------------------------

module GAUSSIAN4

   implicit none

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object. This does not nullify point parts or set
   ! defaults.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(G)
   ! Set the gaussian quartet object to "G"
      G :: GAUSSIAN4
      self = G
   end

   make_ERI_ints(I)
   ! Make ERI matrix "I" using Rys decomposition of 1/r_{12}.
      self :: INOUT
      I :: MAT4{REAL}, OUT

      Ix,Iy,Iz :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      rys :: RYS@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      ! Angular momenta and # of roots
      l_e = .a.l + .b.l
      l_f = .c.l + .d.l
      n_roots = (l_e+l_f)/2 + 2

      ! Allocate 2D integrals
      Ix.create(n_roots,l_e+1,.b.l+1,l_f+1,.d.l+1)
      Iy.create(n_roots,l_e+1,.b.l+1,l_f+1,.d.l+1)
      Iz.create(n_roots,l_e+1,.b.l+1,l_f+1,.d.l+1)

      ! Gaussian index arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      ! Exponents
      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      ! Positions
      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P

      ! Rys roots
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      ! Form the 2D integrals
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD)

      ! Form the integrals
      I = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)

      ! Cleanup
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy

      ! Prefactor
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)
      I = fac*I

   end

   transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b,max_d) ::: pure, private
   ! Use the transfer relation to put momenta on centers B and D to get all
   ! the 2d integrals "Ix", "Iy" and "Iz". If present, "max_b" and "max_d"
   ! are the maximum l-values desired for centers b and d, respectively.
   ! You must ensure that the "Ii" arrays are big enough, in this case.
      self :: IN
      Ix,Iy,Iz :: MAT5{REAL}, INOUT
      AB,CD :: VEC{REAL}(3), IN
      max_b,max_d :: INT, IN, optional
      le1,lf1,l_a,l_b,l_c,l_d,a,b,c,d,a1,b1,c1,d1,la1 :: INT
      l_a = .a.l; l_b = .b.l; l_c = .c.l; l_d = .d.l
      if (present(max_b)) l_b=max_b
      if (present(max_d)) l_d=max_d
      if (l_b==0 AND l_d==0) return
      if (l_b/=0) then
         le1 = l_a + l_b + 1
         do b = 1,l_b
         do a = 1,le1 - b
            b1 = b + 1
            a1 = a + 1
            Ix(:,a,b1,:,1) = Ix(:,a1,b,:,1) + AB(1)*Ix(:,a,b,:,1)
            Iy(:,a,b1,:,1) = Iy(:,a1,b,:,1) + AB(2)*Iy(:,a,b,:,1)
            Iz(:,a,b1,:,1) = Iz(:,a1,b,:,1) + AB(3)*Iz(:,a,b,:,1)
         end
         end
      end
      if (l_d/=0) then
      !  la1 = l_a + 1
         la1 = l_a + l_b - .b.l + 1 ! increase more along a as for b
         lf1 = l_c + l_d + 1
         do d = 1,l_d
         do c = 1,lf1 - d
            d1 = d + 1
            c1 = c + 1
            Ix(:,1:la1,:,c,d1) = Ix(:,1:la1,:,c1,d) + CD(1)*Ix(:,1:la1,:,c,d)
            Iy(:,1:la1,:,c,d1) = Iy(:,1:la1,:,c1,d) + CD(2)*Iy(:,1:la1,:,c,d)
            Iz(:,1:la1,:,c,d1) = Iz(:,1:la1,:,c1,d) + CD(3)*Iz(:,1:la1,:,c,d)
         end
         end
      end
   end

   form_2d_ints(Ix,Iy,Iz,t2,wt,rho,zinv,einv,PA,QC,QP,max_e,max_f) ::: pure
   ! Forms the two dimensional integrals "Ix", "Iy" and "Iz" with momenta only
   ! on centers A and C, using Rys roots "t2" and weights "wt".
   ! Other variables are intermediates, to avoid calculations: see make_ERI_ints.
   ! If present, "max_e" and "max_f" are used for the maximum angular momenta
   ! of centers (a+b) and (c+d) respectively -- for derivative integrals.
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, INOUT
      t2,wt :: VEC{REAL}, IN
      rho,zinv,einv :: REAL, IN
      PA,QC,QP :: VEC{REAL}(3), IN
      max_e,max_f :: INT, IN, optional

      ret,rzt,ce,cf,bb,ce1,cf1 :: VEC{REAL}(size(t2))
      l_e,l_f,e,f,em1,fm1,fp1,ep1,k :: INT

      l_e = .a.l + .b.l
      l_f = .c.l + .d.l
      if (present(max_e)) l_e = max_e
      if (present(max_f)) l_f = max_f

      Ix(:,1,1) = ONE
      Iy(:,1,1) = ONE
      Iz(:,1,1) = ONE

      if (l_e/=0 OR l_f/=0) then

       if (l_f>0) then

         ret = rho*t2*einv
         Ix(:,1,2) = QC(1) - ret(:)*QP(1)
         Iy(:,1,2) = QC(2) - ret(:)*QP(2)
         Iz(:,1,2) = QC(3) - ret(:)*QP(3)

         if (l_f>1) then
           cf = (ONE - ret) * HALF * einv
           do f = 2,l_f
             fm1 = f - 1
             fp1 = f + 1
             cf1 = fm1 * cf
             Ix(:,1,fp1) = Ix(:,1,2)*Ix(:,1,f) + cf1*Ix(:,1,fm1)
             Iy(:,1,fp1) = Iy(:,1,2)*Iy(:,1,f) + cf1*Iy(:,1,fm1)
             Iz(:,1,fp1) = Iz(:,1,2)*Iz(:,1,f) + cf1*Iz(:,1,fm1)
           end
         end

       end

       if (l_e>0) then

         rzt = rho*t2*zinv
         Ix(:,2,1) = PA(1) + rzt(:)*QP(1)
         Iy(:,2,1) = PA(2) + rzt(:)*QP(2)
         Iz(:,2,1) = PA(3) + rzt(:)*QP(3)

         if (l_e>1) then
           ce = (ONE - rzt) * HALF * zinv
           do e = 2,l_e
             em1 = e - 1
             ep1 = e + 1
             ce1 = em1 * ce
             Ix(:,ep1,1) = Ix(:,2,1)*Ix(:,e,1) + ce1*Ix(:,em1,1)
             Iy(:,ep1,1) = Iy(:,2,1)*Iy(:,e,1) + ce1*Iy(:,em1,1)
             Iz(:,ep1,1) = Iz(:,2,1)*Iz(:,e,1) + ce1*Iz(:,em1,1)
           end
         end

       end

       if (l_f>0 AND l_e>0) then

         bb = HALF*einv*rzt
         Ix(:,2,2) = Ix(:,1,2)*Ix(:,2,1)+bb
         Iy(:,2,2) = Iy(:,1,2)*Iy(:,2,1)+bb
         Iz(:,2,2) = Iz(:,1,2)*Iz(:,2,1)+bb

         do f= 2,l_f
           fm1 = f - 1
           fp1 = f + 1
           cf1 = fm1 * cf
           Ix(:,2,fp1) = Ix(:,1,2)*Ix(:,2,f) + cf1*Ix(:,2,fm1) + bb*Ix(:,1,f)
           Iy(:,2,fp1) = Iy(:,1,2)*Iy(:,2,f) + cf1*Iy(:,2,fm1) + bb*Iy(:,1,f)
           Iz(:,2,fp1) = Iz(:,1,2)*Iz(:,2,f) + cf1*Iz(:,2,fm1) + bb*Iz(:,1,f)
         end

         do e = 2,l_e
           em1 = e - 1
           ep1 = e + 1
           ce1 = em1 * ce
           do f = 2,l_f+1
             fm1 = f - 1
             Ix(:,ep1,f) = Ix(:,2,1)*Ix(:,e,f) + ce1*Ix(:,em1,f) + fm1*bb(:)*Ix(:,e,fm1)
             Iy(:,ep1,f) = Iy(:,2,1)*Iy(:,e,f) + ce1*Iy(:,em1,f) + fm1*bb(:)*Iy(:,e,fm1)
             Iz(:,ep1,f) = Iz(:,2,1)*Iz(:,e,f) + ce1*Iz(:,em1,f) + fm1*bb(:)*Iz(:,e,fm1)
           end
         end

       end
      end

      ! Multiply Iz by the weight
      do k = 1,size(Iz,1)
        Iz(k,:,:) = Iz(k,:,:)*wt(k)
      end

   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the same-spin orbit integrals "Sx" "Sy" "Sz"  and the
   ! other spin orbit integrals  "Ox" "Oy" "Oz" using Rys method.
   ! Reference: Bearpark et al., Mol. Phys. 80, p. 479 (1993)
      self :: INOUT
      Sx,Sy,Sz,Ox,Oy,Oz :: MAT4{REAL}, OUT

      Ix,Iy,Iz,LLx,LLy,LLz,RRx,RRy,RRz :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      rys :: RYS@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,l_a,l_b,l_c,l_d,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      l_a = .a.l + 1; l_b = .b.l + 1
      l_c = .c.l + 1; l_d = .d.l + 1
      l_e = .a.l + .b.l + 1; l_f = .c.l + .d.l + 1 ! One higherfor differentiating
      n_roots = (l_e+l_f+2)/2

      Ix.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)   ! Basic intermediate integrals
      Iy.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      Iz.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Ix = ZERO; Iy = ZERO; Iz = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP,l_e,l_f)
                                                            ! one unit higher for differentiating
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b=l_b,max_d=l_d) ! a & c will automatically be one unit higher
      LLx.create(n_roots,l_a,l_b,l_c,l_d) ! Derivative integrals
      LLy.create(n_roots,l_a,l_b,l_c,l_d)
      LLz.create(n_roots,l_a,l_b,l_c,l_d)
      RRx.create(n_roots,l_a,l_b,l_c,l_d)
      RRy.create(n_roots,l_a,l_b,l_c,l_d)
      RRz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(Ix,"a",LLx); .differentiate(Iy,"a",LLy); .differentiate(Iz,"a",LLz)
      .differentiate(Ix,"b",RRx); .differentiate(Iy,"b",RRy); .differentiate(Iz,"b",RRz)
      ! Form the same-spin orbit integrals

      Sx = sum(Ix(:,ax,bx,cx,dx)*(LLy(:,ay,by,cy,dy)*RRz(:,az,bz,cz,dz)-RRy(:,ay,by,cy,dy)*LLz(:,az,bz,cz,dz)),dim=1)
      Sy = sum(Iy(:,ay,by,cy,dy)*(LLz(:,az,bz,cz,dz)*RRx(:,ax,bx,cx,dx)-RRz(:,az,bz,cz,dz)*LLx(:,ax,bx,cx,dx)),dim=1)
      Sz = sum(Iz(:,az,bz,cz,dz)*(LLx(:,ax,bx,cx,dx)*RRy(:,ay,by,cy,dy)-RRx(:,ax,bx,cx,dx)*LLy(:,ay,by,cy,dy)),dim=1)

      .differentiate(Ix,"c",LLx); .differentiate(Iy,"c",LLy); .differentiate(Iz,"c",LLz)
      .differentiate(Ix,"d",RRx); .differentiate(Iy,"d",RRy); .differentiate(Iz,"d",RRz)
      ! Form the other spin orbit integrals

      Ox = sum(Ix(:,ax,bx,cx,dx)*(LLy(:,ay,by,cy,dy)*RRz(:,az,bz,cz,dz)-RRy(:,ay,by,cy,dy)*LLz(:,az,bz,cz,dz)),dim=1)
      Oy = sum(Iy(:,ay,by,cy,dy)*(LLz(:,az,bz,cz,dz)*RRx(:,ax,bx,cx,dx)-RRz(:,az,bz,cz,dz)*LLx(:,ax,bx,cx,dx)),dim=1)
      Oz = sum(Iz(:,az,bz,cz,dz)*(LLx(:,ax,bx,cx,dx)*RRy(:,ay,by,cy,dy)-RRx(:,ax,bx,cx,dx)*LLy(:,ay,by,cy,dy)),dim=1)

      RRz.destroy; RRy.destroy; RRx.destroy
      LLz.destroy; LLy.destroy; LLx.destroy

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy

      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)

      Sx = fac*Sx; Sy = fac*Sy; Sz = fac*Sz
      Ox = fac*Ox; Oy = fac*Oy; Oz = fac*Oz

   end

   differentiate(I,index,ID)
   ! Differentiate a gaussian-integral matrix "I" with respect to the
   ! *nuclear* coordinate on basis function "index", which can be
   ! "a" "b" "c" or "d" depending on which center is differntiated.
   ! Place the result in "ID".
      I,ID :: MAT5{REAL}
      index :: STR

      d_a,d_b,d_c,d_d,a,b,c,d :: INT
      a2,b2,c2,d2 :: REAL

      d_a = ubound(ID,2); d_b = ubound(ID,3); d_c = ubound(ID,4); d_d = ubound(ID,5)

      ID = ZERO
      select case (index)
         case("a")
            ENSURE(ubound(I,2)>1,  "I array too small to differentiate")
            ENSURE(ubound(I,2)>d_a,"I and ID arrays are incompatible")
            a2 = TWO*.a.exponent
            ID(:,1,:,:,:) = a2*I(:,2  ,1:d_b,1:d_c,1:d_d)
            do a = 2,d_a
            ID(:,a,:,:,:) = a2*I(:,a+1,1:d_b,1:d_c,1:d_d) - (a-1)*I(:,a-1,1:d_b,1:d_c,1:d_d)
            end
         case("b")
            ENSURE(ubound(I,3)>1,  "I array too small to differentiate")
            ENSURE(ubound(I,3)>d_b,"I and ID arrays are incompatible")
            b2 = TWO*.b.exponent
            ID(:,:,1,:,:) = b2*I(:,1:d_a,2  ,1:d_c,1:d_d)
            do b = 2,d_b
            ID(:,:,b,:,:) = b2*I(:,1:d_a,b+1,1:d_c,1:d_d) - (b-1)*I(:,1:d_a,b-1,1:d_c,1:d_d)
            end
         case("c")
            ENSURE(ubound(I,4)>1,  "I array too small to differentiate")
            ENSURE(ubound(I,4)>d_c,"I and ID arrays are incompatible")
            c2 = TWO*.c.exponent
            ID(:,:,:,1,:) = c2*I(:,1:d_a,1:d_b,2  ,1:d_d)
            do c = 2,d_c
            ID(:,:,:,c,:) = c2*I(:,1:d_a,1:d_b,c+1,1:d_d) - (c-1)*I(:,1:d_a,1:d_b,c-1,1:d_d)
            end
         case("d")
            ENSURE(ubound(I,5)>1,  "I array too small to differentiate")
            ENSURE(ubound(I,5)>d_d,"I and ID arrays are incompatible")
            d2 = TWO*.d.exponent
            ID(:,:,:,:,1) = d2*I(:,1:d_a,1:d_b,1:d_c,2  )
            do d = 2,d_d
            ID(:,:,:,:,d) = d2*I(:,1:d_a,1:d_b,1:d_c,d+1) - (d-1)*I(:,1:d_a,1:d_b,1:d_c,d-1)
            end
      end
   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole-dipole integrals "Dij" using Rys method.
   ! Reference: None. But see Bearpark et al., Mol. Phys. 80, p. 479 (1993) for
   ! inspiration.
      self :: INOUT
      Dxx,Dyy,Dzz,Dxy,Dxz,Dyz :: MAT4{REAL}, OUT

      Ix,Iy,Iz,Lx,Ly,Lz,Rx,Ry,Rz,LL,LR,RR :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      rys :: RYS@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      Dxx_abcd,Dyy_abcd,Dzz_abcd,Dxy_abcd,Dxz_abcd,Dyz_abcd,Ixyn,Ixzn,Iyzn :: REAL
      Lxn,Lyn,Lzn,Ixn,Iyn,Izn,Rxn,Ryn,Rzn :: REAL
      l_e,l_f,l_a,l_b,l_c,l_d,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT
      a,b,c,d,n,aix,aiy,aiz,bix,biy,biz,cix,ciy,ciz,dix,diy,diz :: INT

      l_a = .a.l + 1; l_b = .b.l + 1
      l_c = .c.l + 1; l_d = .d.l + 1
      l_e = .a.l + .b.l + 2; l_f = .c.l + .d.l    ! Two higher for differentiating A, B.
      n_roots = (l_e+l_f+2)/2

      Ix.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)  ! Basic intermediate integrals
      Iy.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)
      Iz.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Ix = ZERO; Iy = ZERO; Iz = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP,l_e,l_f)
                                                    ! two units higher on B for differentiating
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_b=l_b+1) ! A will automatically be 2 units higher

      Lx.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Ly.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Lz.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Rx.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Ry.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Rz.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      LL.create(n_roots,l_a  ,l_b  ,l_c,l_d)
      LR.create(n_roots,l_a  ,l_b  ,l_c,l_d)
      RR.create(n_roots,l_a  ,l_b  ,l_c,l_d)

      .differentiate(Ix,"a",Lx); .differentiate(Ix,"b",Rx)
      .differentiate(Iy,"a",Ly); .differentiate(Iy,"b",Ry)
      .differentiate(Iz,"a",Lz); .differentiate(Iz,"b",Rz)

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      .differentiate(Lx,"a",LL); .differentiate(Rx,"b",RR)
      .differentiate(Lx,"b",LR); LR = TWO*LR

!     Dxx = sum(LL(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     LR(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     RR(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)

      do d=1,.d.n_comp
        dix=dx(d)
        diy=dy(d)
        diz=dz(d)
        do c=1,.c.n_comp
          cix=cx(c)
          ciy=cy(c)
          ciz=cz(c)
          do b=1,.b.n_comp
            bix=bx(b)
            biy=by(b)
            biz=bz(b)
            do a=1,.a.n_comp
              aix=ax(a)
              aiy=ay(a)
              aiz=az(a)
              Dxx_abcd = ZERO
              do n=1,n_roots
                Iyzn = Iy(n,aiy,biy,ciy,diy) * Iz(n,aiz,biz,ciz,diz)
                Dxx_abcd = Dxx_abcd + Iyzn * (LL(n,aix,bix,cix,dix) + &
                                              LR(n,aix,bix,cix,dix) + &
                                              RR(n,aix,bix,cix,dix))
              end
              Dxx(a,b,c,d) = Dxx_abcd
            end
          end
        end
      end

      .differentiate(Ly,"a",LL); .differentiate(Ry,"b",RR)
      .differentiate(Ly,"b",LR); LR = TWO*LR

!     Dyy = sum(Ix(:,ax,bx,cx,dx)*LL(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*LR(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*RR(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)


      do d=1,.d.n_comp
        dix=dx(d)
        diy=dy(d)
        diz=dz(d)
        do c=1,.c.n_comp
          cix=cx(c)
          ciy=cy(c)
          ciz=cz(c)
          do b=1,.b.n_comp
            bix=bx(b)
            biy=by(b)
            biz=bz(b)
            do a=1,.a.n_comp
              aix=ax(a)
              aiy=ay(a)
              aiz=az(a)
              Dyy_abcd = ZERO
              do n=1,n_roots
                Ixzn = Ix(n,aix,bix,cix,dix) * Iz(n,aiz,biz,ciz,diz)
                Dyy_abcd = Dyy_abcd + Ixzn * (LL(n,aiy,biy,ciy,diy) + &
                                              LR(n,aiy,biy,ciy,diy) + &
                                              RR(n,aiy,biy,ciy,diy))
              end
              Dyy(a,b,c,d) = Dyy_abcd
            end
          end
        end
      end

      .differentiate(Lz,"a",LL); .differentiate(Rz,"b",RR)
      .differentiate(Lz,"b",LR); LR = TWO*LR

!     Dzz = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*LL(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*LR(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*Iz(:,ay,by,cy,dy)*RR(:,az,bz,cz,dz),dim=1)

      do d=1,.d.n_comp
        dix=dx(d)
        diy=dy(d)
        diz=dz(d)
        do c=1,.c.n_comp
          cix=cx(c)
          ciy=cy(c)
          ciz=cz(c)
          do b=1,.b.n_comp
            bix=bx(b)
            biy=by(b)
            biz=bz(b)
            do a=1,.a.n_comp
              aix=ax(a)
              aiy=ay(a)
              aiz=az(a)
              Dzz_abcd = ZERO
              do n=1,n_roots
                Ixyn = Ix(n,aix,bix,cix,dix) * Iy(n,aiy,biy,ciy,diy)
                Dzz_abcd = Dzz_abcd + Ixyn * (LL(n,aiz,biz,ciz,diz) + &
                                              LR(n,aiz,biz,ciz,diz) + &
                                              RR(n,aiz,biz,ciz,diz))
              end
              Dzz(a,b,c,d) = Dzz_abcd
            end
          end
        end
      end

      RR.destroy; LR.destroy; LL.destroy
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!     Dxy = sum(Lx(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     Lx(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     Rx(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
!         +     Rx(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
!     Dxz = sum(Lx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
!         +     Lx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz) &
!         +     Rx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
!         +     Rx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz),dim=1)
!     Dyz = sum(Ix(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
!         +     Ix(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz),dim=1)

      do d=1,.d.n_comp
        dix=dx(d)
        diy=dy(d)
        diz=dz(d)
        do c=1,.c.n_comp
          cix=cx(c)
          ciy=cy(c)
          ciz=cz(c)
          do b=1,.b.n_comp
            bix=bx(b)
            biy=by(b)
            biz=bz(b)
            do a=1,.a.n_comp
              aix=ax(a)
              aiy=ay(a)
              aiz=az(a)
              Dxy_abcd = ZERO
              Dxz_abcd = ZERO
              Dyz_abcd = ZERO
              do n=1,n_roots
                Lxn = Lx(n,aix,bix,cix,dix)
                Lyn = Ly(n,aiy,biy,ciy,diy)
                Lzn = Lz(n,aiz,biz,ciz,diz)
                Ixn = Ix(n,aix,bix,cix,dix)
                Iyn = Iy(n,aiy,biy,ciy,diy)
                Izn = Iz(n,aiz,biz,ciz,diz)
                Rxn = Rx(n,aix,bix,cix,dix)
                Ryn = Ry(n,aiy,biy,ciy,diy)
                Rzn = Rz(n,aiz,biz,ciz,diz)
                Dxy_abcd = Dxy_abcd + Izn * (Lxn*Lyn + Lxn*Ryn + Rxn*Lyn + Rxn*Ryn)
                Dxz_abcd = Dxz_abcd + Iyn * (Lxn*Lzn + Lxn*Rzn + Rxn*Lzn + Rxn*Rzn)
                Dyz_abcd = Dyz_abcd + Ixn * (Lyn*Lzn + Lyn*Rzn + Ryn*Lzn + Ryn*Rzn)
              end
              Dxy(a,b,c,d) = Dxy_abcd
              Dxz(a,b,c,d) = Dxz_abcd
              Dyz(a,b,c,d) = Dyz_abcd
            end
          end
        end
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Rz.destroy; Ry.destroy; Rx.destroy
      Lz.destroy; Ly.destroy; Lx.destroy
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy

      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)

      Dxx = fac*Dxx; Dyy = fac*Dyy; Dzz = fac*Dzz
      Dxy = fac*Dxy; Dxz = fac*Dxz; Dyz = fac*Dyz

   end

   make_ERI_derivatives(AA,BB,CC,DD)
   ! Make the ERI gradient integrals "AA", "BB", "CC" and "DD". The last dimension
   ! determines whether the derivative is x, y, or z.
      self :: INOUT
      AA,BB,CC,DD :: MAT5{REAL}, optional, OUT

      IIx,IIy,IIz,AAx,AAy,AAz,BBx,BBy,BBz,CCx,CCy,CCz,DDx,DDy,DDz :: MAT5{REAL}@
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}@
      rys :: RYS@
      AB,CD,P,Q,PA,QC,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac :: REAL
      l_e,l_f,l_a,l_b,l_c,l_d,n_roots,fa,la,fb,lb,fc,lc,fd,ld :: INT

      l_a = .a.l + 1; l_b = .b.l + 1
      l_c = .c.l + 1; l_d = .d.l + 1
      l_e = .a.l + .b.l + 1; l_f = .c.l + .d.l + 1 ! One higher for differentiating
      n_roots = (l_e+l_f+2)/2

      IIx.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)   ! Basic intermediate integrals
      IIy.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      IIz.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = .c.first_gaussian; lc = .c.last_gaussian
      fd = .d.first_gaussian; ld = .d.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      zeta = .a.exponent + .b.exponent
      eta  = .c.exponent + .d.exponent
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .a.position - .b.position
      CD  = .c.position - .d.position
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = (.c.exponent*.c.position + .d.exponent*.d.position)*einv
      PA  = P - .a.position
      QC  = Q - .c.position
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = .a.exponent*.b.exponent*AB2*zinv + .c.exponent*.d.exponent*CD2*einv
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-fac)

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      IIx = ZERO; IIy = ZERO; IIz = ZERO
      .form_2d_ints(IIx(:,:,1,:,1),IIy(:,:,1,:,1),IIz(:,:,1,:,1),rys.root,rys.weight,rho,zinv,einv,PA,QC,QP,l_e,l_f)
                                                               ! one unit higher for differentiating
      .transfer_2d_ints(IIx,IIy,IIz,AB,CD,max_b=l_b,max_d=l_d) ! a & c will automatically be one unit higher

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (present(AA)) then
      AAx.create(n_roots,l_a,l_b,l_c,l_d) ! Derivative integrals
      AAy.create(n_roots,l_a,l_b,l_c,l_d)
      AAz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"a",AAx); .differentiate(IIy,"a",AAy); .differentiate(IIz,"a",AAz)
      AA(:,:,:,:,1) = sum(AAx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      AA(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*AAy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      AA(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*AAz(:,az,bz,cz,dz),dim=1)
      AAz.destroy; AAy.destroy; AAx.destroy
      AA = fac*AA
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (present(BB)) then
      BBx.create(n_roots,l_a,l_b,l_c,l_d) ! Derivative integrals
      BBy.create(n_roots,l_a,l_b,l_c,l_d)
      BBz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"b",BBx); .differentiate(IIy,"b",BBy); .differentiate(IIz,"b",BBz)
      BB(:,:,:,:,1) = sum(BBx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      BB(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*BBy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      BB(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*BBz(:,az,bz,cz,dz),dim=1)
      BBz.destroy; BBy.destroy; BBx.destroy
      BB = fac*BB
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (present(CC)) then
      CCx.create(n_roots,l_a,l_b,l_c,l_d) ! Derivative integrals
      CCy.create(n_roots,l_a,l_b,l_c,l_d)
      CCz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"c",CCx); .differentiate(IIy,"c",CCy); .differentiate(IIz,"c",CCz)
      CC(:,:,:,:,1) = sum(CCx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      CC(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*CCy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      CC(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*CCz(:,az,bz,cz,dz),dim=1)
      CCz.destroy; CCy.destroy; CCx.destroy
      CC = fac*CC
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (present(DD)) then
      DDx.create(n_roots,l_a,l_b,l_c,l_d) ! Derivative integrals
      DDy.create(n_roots,l_a,l_b,l_c,l_d)
      DDz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(IIx,"d",DDx); .differentiate(IIy,"d",DDy); .differentiate(IIz,"d",DDz)
      DD(:,:,:,:,1) = sum(DDx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      DD(:,:,:,:,2) = sum(IIx(:,ax,bx,cx,dx)*DDy(:,ay,by,cy,dy)*IIz(:,az,bz,cz,dz),dim=1)
      DD(:,:,:,:,3) = sum(IIx(:,ax,bx,cx,dx)*IIy(:,ay,by,cy,dy)*DDz(:,az,bz,cz,dz),dim=1)
      DDz.destroy; DDy.destroy; DDx.destroy
      DD = fac*DD
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      rys.destroy
      IIz.destroy; IIy.destroy; IIx.destroy

   end

   put
   ! Put the object to file "out"
      self :: IN

      stdout.flush
      stdout.text("GAUSSIAN4 output:")
      stdout.flush
      stdout.show("l_a   =",.a.l)
      stdout.show("l_b   =",.b.l)
      stdout.show("l_c   =",.c.l)
      stdout.show("l_d   =",.d.l)
      stdout.show("Ra    =",.a.position(1),.a.position(2),.a.position(3))
      stdout.show("Rb    =",.b.position(1),.b.position(2),.b.position(3))
      stdout.show("Rc    =",.c.position(1),.c.position(2),.c.position(3))
      stdout.show("Rd    =",.d.position(1),.d.position(2),.d.position(3))
      stdout.show("alpha =",.a.exponent)
      stdout.show("beta  =",.b.exponent)
      stdout.show("gamma =",.c.exponent)
      stdout.show("delta =",.d.exponent)

   end

end
