!===================================================================
!
! CRYSTAL: Data structure for crystals
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module CRYSTAL

   implicit none

contains

!  ===========
!  Allocatiion
!  ===========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Erase all pointer information
      self :: INOUT

      .spacegroup.destroy_ptr_part
      .destroy_fragment_data
      .destroy_asymmetric_unit
      .destroy_data

   end

   destroy_data ::: leaky, PURE
   ! Erase all data pointer information
      self :: INOUT

      .xray_data.SET:destroy
      .xray_r_free_data.SET:destroy

    ! .pnd_data.destroy
    ! .pnd_r_free_data.destroy

   end

   destroy_fragment_data ::: leaky, PURE
   ! Destroy the geometry and symmetry data for the fragment and unit cell.
   ! NOTE: Don't destroy asymmetric unit atom info
      self :: INOUT

      .fragment_atom.destroy
      .fragment_geometry.destroy

      ! Never destroy .asymmetric_unit_geometry
      ! Never destroy .asymmetric_unit_atom

      .unit_cell_geometry.destroy
      .unit_cell_atom.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy
      .asym_shift_for_unit_cell_atom.destroy
      .frag_parent_for_cell_atom.destroy

      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .unit_cell_shft_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy

      .unique_frag_atom.destroy
      .unique_index_for_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_symops_for_frag_atom.destroy
    ! .frag_pair_for_asym_atom_pair.destroy
    ! .asym_pair_for_frag_atom_pair.destroy

      .repetition_factor.destroy
      .asym_atom_sym_factor.destroy
      .asym_atom_stabilizer.destroy

      .unit_cell_connection.destroy
      .uc_vdw_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .stabilizer_symop.destroy
      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      .fragment_info_made = FALSE

   end

   destroy_asymmetric_unit ::: leaky, PURE
   ! Destroy the asymmetric unit geometry. Normally this will be set
   ! by reading a CIF file. If not, it will be set from a given
   ! fragment atom list, in the "update_fragment_info" routine. Once
   ! set, it is never destroyed unless explicitly requested by a call
   ! or a keyword.
      self :: INOUT

      .asymmetric_unit_geometry.destroy 
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_source = "?"

      ! Destroy unit cell as well ...
      ! which depends on asymmetric unit
      .unit_cell_geometry.destroy 
      .unit_cell_atom.destroy     

   end

!  ===========
!  Set methods
!  ===========

   update_diffraction_data ::: leaky
   ! Set angles, equivalence factors, and the free reflection data.
      self :: INOUT

      list :: VEC{INT}@
      n_refl, n_unique :: INT

      if (.xray_data.allocated) then

        ! Test for equivalents & remove
        ! This could also go in xray_data.update below ...
        if (.xray_data.reflections.allocated) then
        if (NOT .xray_data.use_equivalents) then
           n_refl = .xray_data.reflections.dim
           .make_list_of_equivalents_v2(list,n_unique)
           if (n_unique<n_refl) then
              stdout.flush
              stdout.flush
              stdout.text("===============================")
              stdout.text("Equivalent reflections detected")
              stdout.text("===============================")
              stdout.flush
              stdout.text(". You have equivalent reflections in your data!")
              stdout.text("  This isn't allowed so I will keep only the first ")
              stdout.text("  equivalent, and purge the rest.")
              stdout.flush
              stdout.text(". If you don't like this then first merge your data.")
              stdout.flush
              stdout.text(". Alternatively, set use_equivalents= to stop this.")
              stdout.flush
              stdout.show("No. of reflections before removing equivalents = ", n_refl)
              stdout.show("No. of reflections after purging               = ", n_unique)
              .remove_equivalents(list,n_unique)
           end
           list.destroy
        end
        end

        ! Prune reflections
        .xray_data.SET:update(.unit_cell,.spacegroup) ! NOT PURE

        if (.r_free_percentage>0 AND .xray_data.reflections.allocated) then
           .xray_r_free_data = .xray_data
           .xray_r_free_data.reflections.destroy
           .set_r_free_reflections(.xray_data.reflections,.xray_r_free_data.reflections)
        end

      end

    ! if (.pnd_data.allocated) then
    !   .pnd_data.update(.unit_cell,.spacegroup) ! NOT PURE
    !   if (.r_free_percentage>0 AND .pnd_data.reflections.allocated) then
    !      .pnd_r_free_data = .pnd_data
    !      .pnd_r_free_data.reflections.destroy
    !      .set_r_free_reflections(.pnd_data.reflections,.pnd_r_free_data.reflections)
    !   end
    ! end

   end

   set_r_free_reflections(data,free_data) ::: leaky
   ! Set the R free reflection data. "data" is destroyed and created
   ! again without those reflections in "free_data".
      self :: INOUT
      data :: VEC{REFLECTION}@, INOUT
      free_data :: VEC{REFLECTION}@, OUT

   ENSURE(data.allocated,"no diffraction data")
   ENSURE(free_data.deallocated,"r_free_data exists")

      harvest :: VEC{REAL}@
      free,keep :: VEC{INT}@
      percentage :: REAL
      i,n :: INT

      if (.r_free_percentage<=0) return
      if (data.deallocated) return

      ! Set the percentage of reflections to reject
      percentage = .r_free_percentage/100.0d0

      ! Harvest random numbers
      n = data.dim
      harvest.create(n)

      if (tonto.is_master_processor) then
         call random_number(harvest) ! NOT PURE
      end
      PARALLEL_BROADCAST(harvest,tonto.master_processor)

      ! Reflections for r_free have p<percentage
      ! Otherwise, they are kept and used for fitting
      do i = 1,n
         if (harvest(i)<percentage) then; free.append(i)
         else;                            keep.append(i)
         end
      end
      harvest.destroy

    ! stdout.show("No. of reflections kept for R free =",free.dim)
    ! stdout.flush

      ! Set free_data & kept data
      free_data = data(free)
      data      = data(keep)

      ! Clean
      free.destroy
      keep.destroy

   end

!  ===================
!  Cluster set methods
!  ===================

   set_radius(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.radius), PURE
   ! Generic set
   end

   set_defragment(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.defragment), PURE
   ! Generic set
   end

   set_fragment_geometry(fragment_geometry,cartesian) ::: leaky, PURE
   ! Makes an atom list from "fragment_geometry" to which
   ! .fragment_atoms gets set. The .asymmetric_unit_atoms (which must
   ! be in cartesian system) and .unit_cell_geometry have to be
   ! defined. Set "cartesian" to TRUE if the "fragment_geometry" is in
   ! cartesians, default is fractional coordinates.
      self :: INOUT
      fragment_geometry :: MAT{REAL}, IN
      cartesian :: BIN, optional, IN

   ENSURE(.unit_cell_geometry.allocated, "no .unit_cell_geometry")
   ENSURE(.asymmetric_unit_atom.allocated, "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated, "no .asym_atom_for_unit_cell_atom")

      atom  :: VEC{ATOM}@
      list  :: VEC{INT}@
      pf,pu :: VEC{REAL}(3)
      fg :: MAT{REAL}@
      n_frag_atoms,f,u,a :: INT
      tol :: REAL
      cart,found :: BIN

      cart = FALSE
      if (present(cartesian)) cart = cartesian

      ! Transform fragment geometry to fractional
      fg = fragment_geometry
      if (cart) .unit_cell.change_into_fractional(fg)

      ! Create the list of atom indices -- leaky!!
      n_frag_atoms = fg.dim2
      list.create(n_frag_atoms)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = CRYSTAL_SAME_ATOM_TOL

      ! Find and create fragment atoms
      do f = 1,n_frag_atoms

         ! Shift fragment atom to unit cell
         pf = fg(:,f)
         .put_to_unit_cell(pf)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Is u the same as f?
            pu = .unit_cell_geometry(:,u)
            found = pu.same_as(pf,tol)

            if (NOT found) cycle

            ! Set asymmetric atom index for atom f
            a = .asym_atom_for_unit_cell_atom(u)
            list(f) = a

            exit

         end

         ENSURE(found,"fragment atom "//trim(f.to_str)//" was not found in the unit cell")

      end

      ! Make the atom list, cartesian coordinates
      atom = .asymmetric_unit_atom(list)
      atom.set_axis_system_to("crystal")
      atom.set_positions_to(fg)
      atom.zero_pADP_errors
      atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Make the fragment data; make it destroyable
      .update_fragment_info(atom)

      ! Clean
      atom.destroy
      list.destroy
      fg.destroy

   end

   set_generation_method(method) ::: PURE
   ! Set the generation method, which tells how to generate the cluster e.g.
   ! whether to add atoms to the cluster within a certain radius of the starting
   ! fragment, or whether to use the unit cell ad the cluster, or just the
   ! initial starting fragment (i.e. the null cluster) or the initial fragment
   ! and the unit cell.
      self :: INOUT
      method :: STR, IN

      .generation_method = method
      .generation_method.to_lower_case

      select case (.generation_method)
      case("for_hirshfeld_surface     ")
      case("fragment                  ")
      case("unit_cell                 ")
      case("unit_cell_plus            ")
      case("for_unit_cell_density     ")
      case("offset_unit_cell          ")
      case("offset_unit_cell_density  ")
      case("within_radius             ")
    ! case default;   UNKNOWN(.generation_method)
      end

   end

   set_atom_density_cutoff(tol) ::: PURE
   ! Set the atom_density_cutoff used to eliminate spherical atomic
   ! density contributions less than "tol". The interpolator table
   ! will not hold values smaller than "tol".
      self :: INOUT
      tol :: REAL, IN

   ENSURE(tol>ZERO,"tol must be +ve")

      .atom_density_cutoff = tol

   end

   set_unit_cell_offset(offset) ::: PURE
   ! Set the unit_cell_offset to use when making an offset unit cell.
      self :: INOUT
      offset :: VEC{REAL}(3), IN

   ENSURE(all(-HALF<=offset) AND all(offset<=HALF), "offset must be between -1/2 and +1/2")

      .unit_cell_offset = offset

   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}                             ")  ! exit read_loop
      case ("asymmetric_unit_geometry=     "); .read_asymmetric_unit_geometry
      case ("destroy                       "); .destroy_ptr_part
    ! case ("bijvoet                       "); .make_list_of_Bijvoet_classes
      case ("destroy_asymmetric_unit       "); .destroy_asymmetric_unit
      case ("destroy_spacegroup            "); .spacegroup.destroy_ptr_part
    ! case ("expand_unique_reflections     "); .expand_unique_reflections
      case ("finalize=                     "); .read_finalize
      case ("junk=                         "); .read_junk
    ! case ("kind=                         "); .read_kind
    ! case ("merge_equivalents             "); .merge_equivalents
    ! case ("merge_ordered_equivalents     "); .merge_ordered_equivalents
    ! case ("pnd_data=                     "); .read_pnd_data
      case ("prune_asymmetric_unit=        "); .read_prune_asymmetric_unit
      case ("put                           "); .put
      case ("put_bond_info_with_errors     "); .put_bond_info_with_errors
      case ("put_bond_info_with_errors_to  "); .put_bond_info_with_errors_to
      case ("put_data_analysis             "); .put_X_data_analysis
      case ("put_all_reflection_data       "); .put_all_reflection_data
      case ("put_reflection_data           "); .put_reflection_data
      case ("put_reflection_intensities    "); .put_reflection_intensities
      case ("put_reflection_intensities_xd "); .put_reflection_intensities_XD
      case ("r_free_percentage=            "); .read_r_free_percentage
      case ("read_cif                      "); .read_CIF
      case ("redirect                      "); .redirect
      case ("repetition_factors=           "); .read_repetition_factors
      case ("revert                        "); .revert
      case ("same_atom_tol=                "); .read_same_atom_tol
      case ("spacegroup=                   "); .read_spacegroup
      case ("unit_cell=                    "); .read_unit_cell
      case ("unit_cell_tol=                "); .read_unit_cell_tol
      case ("units=                        "); .read_units
      case ("use_manual_repetition_factors="); .read_use_manual_rep_factors
      case ("xray_data=                    "); .read_xray_data

      case ("! Cluster keywords            ")

      case ("atom_density_cutoff=          "); .read_atom_density_cutoff
      case ("defragment=                   "); .read_defragment
      case ("fractional_fragment=          "); .read_fractional_fragment
      case ("generation_method=            "); .read_generation_method
      case ("make_cluster_info             "); .make_cluster_info
      case ("unit_cell_offset=             "); .read_unit_cell_offset
      case ("put_averaged_lff_l_tensors    "); .put_averaged_LFF_tensors
      case ("put_centroid_lff_l_tensors    "); .put_centroid_LFF_tensors
      case ("put_centroid_lff_l_tensors_old"); .put_centroid_LFF_tensors_old
      case ("put_cluster_info              "); .put_cluster_info
      case ("put_lff_info                  "); .put_LFF_info
      case ("radius=                       "); .read_radius

      case default;                       UNKNOWN(word)

      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

!   read_kind
!   ! Read the kind of crystal experiment
!      self :: INOUT
!
!      stdin.read(.data_kind)
!      .data_kind.to_lower_case
!
!      select case (.data_kind)
!      case("x-ray")
!      case("pnd  ")
!      case default; UNKNOWN(.data_kind)
!      end
!
!   end

   read_finalize
   ! Read whether to finalize the object.
      self :: INOUT
      stdin.read(.finalize)
   end

   read_r_free_percentage
   ! Read the R free percentage
      self :: INOUT

      stdin.read(.r_free_percentage)

   DIE_IF(.r_free_percentage<0,  "percentage must be non-negative")
   DIE_IF(.r_free_percentage>100,"percentage must be less than 100")

   end

   read_same_atom_tol
   ! Read the tolerance for deciding if two atoms are
   ! the same in fractional coordinates.
      self :: INOUT
      stdin.read(.same_atom_tol)
   end

   read_spacegroup ::: leaky
   ! Read the spacegroup
      self :: INOUT
      .spacegroup.read_keywords
      .spacegroup.analyze
   end

   read_unit_cell
   ! Read the unit cell information
      self :: INOUT

   ENSURE(.xray_data.deallocated,"enter unit cell information before xray_data= !")
 ! ENSURE(.pnd_data.deallocated, "enter unit cell information before pnd_data= !")

      .unit_cell.read_keywords
      .unit_cell.make_info

   end

   read_unit_cell_tol
   ! Read the tolerance for deciding if two atoms are
   ! the same in fractional coordinates.
      self :: INOUT
      stdin.read(.unit_cell_tol)
   end

   read_xray_data ::: leaky
   ! Read in the xray diffraction data
      self :: INOUT

   ENSURE(.unit_cell.info_made,"enter unit cell information before xray_data= !")
   ENSURE(.spacegroup.analyzed,"enter spacegroup information before xray_data= !")
 ! WARN_IF(.xray_data.allocated,"xray diffraction data already defined!")

      if (.xray_data.deallocated) .xray_data.SET:create
      .xray_data.READ:read_keywords
      .xray_data.SET:update(.unit_cell,.spacegroup)

   end

!   read_pnd_data ::: leaky
!   ! Read in the pnd diffraction data
!      self :: INOUT
!
!   ENSURE(.unit_cell.info_made,"enter unit cell information before pnd_data= !")
!   ENSURE(.spacegroup.analyzed,"enter spacegroup information before xray_data= !")
! ! WARN_IF(.pnd_data.allocated,"pnd diffraction data already defined!")
!
!      .pnd_data.destroy
!      .pnd_data.create
!      .pnd_data.data_kind = "pnd"
!      .pnd_data.read_keywords
!      .pnd_data.update(.unit_cell,.spacegroup)
!
!   end

   read_use_manual_rep_factors ::: leaky, private
   ! Read whether to use manually entered repetition factors.
   ! If set set FALSE, the repetition factors will be destroyed.
      self :: INOUT

      stdin.read(.use_manual_repetition_factors)
      if (NOT .use_manual_repetition_factors) .repetition_factor.destroy

   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
      self :: INOUT

      stdin.read_all(.repetition_factor)
      .use_manual_repetition_factors = TRUE

   end

   read_prune_asymmetric_unit ::: private
   ! Read whether to prune the asymmetric unit or not. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to prune the asymmetric atom list, but for crystal
   ! calculations you must do so.
      self :: INOUT
      stdin.read(.prune_asymmetric_unit)
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File object, with
   ! the "name" taken from stdin.
      self :: INOUT

      name :: STR
      found :: BIN
      cif :: CIF@

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.destroy
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif,skip_atoms) ::: leaky
   ! Read information from "cif".  If "skip_atoms" is TRUE,
   ! the fragment_atom coordinates are not processed.
      self :: INOUT
      cif :: CIF, INOUT
      skip_atoms :: BIN, optional, IN

      skip :: BIN

      skip = FALSE
      if (present(skip_atoms)) skip = skip_atoms

      ! Read the spacegroup &  unit_cell
      .:read_CIF_spacegroup_and_cell(cif)

      ! Read the atom list (if requested)
      if (NOT skip) then
         .fragment_atom.read_CIF(cif)
      end

      ! Assume this is X-ray data! BAD !!!
      if (.xray_data.deallocated) .xray_data.SET:create
      .xray_data.SET:set_data_kind("x-ray")
      .xray_data.READ:read_CIF(cif)
      .xray_data.SET:update(.unit_cell,.spacegroup)

      ! Update
      .update_diffraction_data

      ! Eventually, this will be used
      .asymmetric_unit_source = "from-cif"

   end

   read_CIF_spacegroup_and_cell(cif) ::: leaky
   ! Set "self" to *default values* and read only the spacegroup and
   ! unit_cell information from "cif". This is what you normally want
   ! to do first up when you read a CIF.
      self :: INOUT
      cif :: CIF, INOUT

      found :: BIN
      itemvec :: VEC{STR}@
      clean :: CRYSTAL

      ! Set defaults
      self = clean

      ! Read the chemical formula if it is there
      cif.read_item("_chemical_formula_sum",.CIF_chemical_formula,itemvec,found)
      if (NOT found) .CIF_chemical_formula = "?"
      ENSURE(itemvec.deallocated,"multi line chemical formula")

      ! Read the spacegroup
      .spacegroup.read_CIF(cif)

      ! Read the unit cell
      .unit_cell.read_CIF(cif)

   end

   read_CIF_xray_data(cif) ::: leaky
   ! Read only the xray_data information from "cif".
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(.unit_cell.info_made,"enter unit cell information before xray_data= !")
   ENSURE(.spacegroup.analyzed,"enter spacegroup information before xray_data= !")

      if (.xray_data.deallocated) .xray_data.SET:create
      .xray_data.SET:set_data_kind("x-ray")
      .xray_data.READ:read_CIF(cif)
      .xray_data.SET:update(.unit_cell,.spacegroup)

      ! Update
      .update_diffraction_data

   end

   read_asymmetric_unit_geometry ::: private
   ! Read in the asymmetric unit geometry in crystal coordinates.
   ! The coordinates are read in as a single vector ordered as x,y,z
   ! incrementing fastest, for the first to the last atom.
      self :: INOUT
      geometry :: VEC{REAL}@

 ! WARN_IF(.asymmetric_unit_geometry.allocated,"asymmetric_unit_geometry exists!")

      stdin.read_all(geometry)
      ENSURE(modulo(geometry.dim,3)==0,"number of coordinates must be divisible by 3")

      .n_asymmetric_unit_atoms = geometry.dim/3
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,.n_asymmetric_unit_atoms)
      .asymmetric_unit_geometry = reshape(geometry,[3,.n_asymmetric_unit_atoms])
      geometry.destroy

      .asymmetric_unit_source = "manual-input"

   end

!  Cluster keywords

   read_atom_density_cutoff
   ! This number is used to define a cluster radius (see above). The radius is
   ! defined from it, as the *largest* distance from any atom in the
   ! asymmetric_cell_atom list where the atomic electron density becomes smaller
   ! than this number. It requires that slater or coppens bases are defined for
   ! the asymmetric_cell_atom's, and it requires that the generation method be
   ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
   ! from a fragment, which will correctly produce the Hirshfeld surface.
      self :: INOUT
      stdin.read_quantity(.atom_density_cutoff)
   end

   read_defragment
   ! Read whether to defragment the cluster at the boundaries. If set TRUE, the
   ! cluster ends are defragmented, i.e. any atoms which are bonded at the ends
   ! of the cluster are included into the cluster.
      self :: INOUT
      stdin.read(.defragment)
   end

   read_generation_method
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      self :: INOUT

      generation_method :: STR

      stdin.read(generation_method)
      .set_generation_method(generation_method)

   end

   read_fractional_fragment ::: leaky
   ! Read in the fragment geometry, in fractional coordinates.
   ! NOTE: All fragment atom positions must correspond to the
   ! positions of actual atoms in the crystal lattice.
      self :: INOUT

      fragment_geometry :: MAT{REAL}@
      tmp :: VEC{REAL}@
      n :: INT

      stdin.read_all(tmp)
      ENSURE(mod(tmp.dim,3)==0,"# of elements not divisible by 3")

      n = tmp.dim/3
      fragment_geometry.create(3,n)
      fragment_geometry = reshape(tmp,[3,n])
      .set_fragment_geometry(fragment_geometry)

      ! Clean
      fragment_geometry.destroy
      tmp.destroy

   end

   read_radius
   ! Read the radius of the cluster. Usually, all atoms with this distance of
   ! any atom in the fragment_geometry will appear in the cluster.
      self :: INOUT
      stdin.read_quantity(.radius)
   end

   read_unit_cell_offset
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      self :: INOUT

      offset :: VEC{REAL}(3)

      stdin.read(offset)
      .set_unit_cell_offset(offset)

   end

!  ===============
!  General methods
!  ===============
 
   n_unique_SF_k_pts result (res) ::: PURE
   ! The number of unique k-points for an SF calculation
      self :: IN
      res :: INT

   ENSURE(.spacegroup.analyzed,"spacegroup not analyzed")
   ENSURE(.xray_data.allocated,"no data")
   ENSURE(.xray_data.reflections.allocated,"no reflection data")

      res = .xray_data.reflections.n_unique_SF_k_pts(.spacegroup)

   end

   make_unique_X_SF_k_pts(k) ::: PURE
   ! Make the non-translational non-inverted symmetry generated
   ! reciprocal lattice vectors "k" required for structure factor
   ! calculations.
      self :: IN
      k    :: MAT{REAL}, OUT

   ENSURE(k.dim1==.n_unique_SF_k_pts,"k: wrong dim1")
   ENSURE(k.dim2==3,"k: wrong dim2")

      .xray_data.reflections.make_unique_SF_k_pts(k(:,1),k(:,2),k(:,3),.spacegroup,.unit_cell)

   end
 
   n_symop_generated_SF_k_pts result (res) ::: PURE
   ! The number of symmetry generated k-points for an SF calculation
      self :: IN
      res :: INT

   ENSURE(.spacegroup.analyzed,"spacegroup not analyzed")
   ENSURE(.xray_data.allocated,"no data")
   ENSURE(.xray_data.reflections.allocated,"no reflection data")

      res = .spacegroup.n_seitz * .xray_data.reflections.dim

   end

!  ====================================================
!  Set fragment info arrays, unique operators, Z number
!  ====================================================

!  This is the initialisation or update

   update_fragment_info(atom) ::: leaky, PURE
   ! This routine sets the ".fragment_atom" from the "atom" list.
   !
   ! The fragment is a finite portion/model of the crystal, perhaps
   ! one molecule or a cluster of atoms.
   !
   ! In addition a slew of information arrays about the fragment and
   ! crystal are made e.g. like the asymmetric unit atoms, the unit
   ! cell atoms; mapping arrays between these atoms; the stablizer
   ! symops ! for the fragment atoms; and the unit-cell connection
   ! table.
   !
   ! This is a suped-up set_defaults routine.
   !
   ! DETAILS:
   !
   ! A. The .asymmetric_unit_geometry is defined from the symmetry
   !    unique "atoms", if it is not already defined. If it is already
   !    defined the fragment atoms must be symmetry related to these
   !    asymmetric unit atom positions. The asymmetric unit is crucial
   ! B. The .asymmetric_unit_geometry is never destroyed unless
   !    explicitly requested.
   ! 1. The .unit_cell_geometry is made from the asymmetric unit.
   !    Mapping arrays which relate the unit cell atoms to the
   !    asymmetric unit atoms are made,
   ! 2. Other mapping arrays are made which relate the fragment atoms
   !    to the unique asymmetric unit atoms, including sometimes the
   !    symops needed to generate them.
   ! 3. The .repetition factors needed for structure factor calcs on
   !    the fragment are made. The Z number is made.
   !    unchanged (the stabilizer) is made
   ! 4. The unit cell connection table is made.
   ! 5. The set of symmetry operations which leave the fragment
   !    unchanged (the stabilizer) is made
      self :: INOUT
      atom :: VEC{ATOM}, IN

      if (NOT .spacegroup.analyzed) return

      ! Store the fragment atom list
      .fragment_atom = atom
      .destroy_fragment_atom = TRUE

      ! Get fragment geometry from the atom list
      .fragment_geometry = .fragment_atom.coordinates(skip_dummies=TRUE)
      .n_fragment_atoms  = .fragment_geometry.dim2

      ! Fragment unit-cell offset
      .unit_cell.change_into_fractional(.fragment_geometry)
      .fragment_offset   = int(.fragment_geometry.mean_column_vector)

      ! Make asymmetric_unit_geometry only if it does not already
      ! exist e.g. from having been ready previously from a CIF
      if (.asymmetric_unit_geometry.deallocated) then

         ! From fragment geometry make:
         !  .asymmetric_unit_geometry
         !  .unit_cell_geometry
         !  .asymmetric_unit_atoms
         !  .unit_cell_atom
         !  .asym_atom_for_unit_cell_atom.destroy
         !  .asym_symop_for_unit_cell_atom.destroy
         !  .asym_shift_for_unit_cell_atom.destroy
         .make_asymmetric_unit(.prune_asymmetric_unit)
         if (.asymmetric_unit_source=="?") .asymmetric_unit_source = "from-fragment"

      end

      ! Sanity check
      ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list!")

      ! Relate fragment atoms to unit cell
      .make_frag_atom_for_cell_atom

      ! Make unique fragment atoms
      .make_unique_frag_atoms

      ! Make unique fragment atom-pairs
      .make_asym_symops_for_frag_atom

      ! Make the unit cell connection table
      .make_unit_cell_connections
      .make_uc_vdw_connections

      ! Z factors and zep. factors for SF calculations
      .make_repetition_factors
      .make_asym_atom_sym_factors
      .make_frag_atom_sym_factors
      .Z = .z_factor

      ! Symops which leave fragment_geometry unchanged
      .make_stabilizer_symops
      .make_stabilizer_xyz_matrices

      .fragment_info_made = TRUE

   end

   make_asymmetric_unit(prune_asymmetric_unit) ::: leaky, private, PURE
   ! Get the all the atom positions in the unit cell. Also make the
   ! symops allocated with each unit cell atom when it is made from
   ! the asymmetric unit atoms. If "prune_asymmetric_unit" is present
   ! and true, any non-asymmetric unit atoms are eliminated from the
   ! asymmetric unit. This should always be done.
   ! NOTE: .fragment_atom is in the cartesian axis system, but
   !       .fragment_geometry is in the fractional crystal system.
      self :: INOUT
      prune_asymmetric_unit :: BIN, optional, IN

   ENSURE(.fragment_atom.allocated,"no .fragment_atom")
   ENSURE(.fragment_geometry.allocated,"no .fragment_geometry")
   ENSURE(.asymmetric_unit_geometry.deallocated,"asymmetric unit exists")

      pa,pos :: VEC{REAL}(3)
      offset :: VEC{INT}(3)
      seitz :: MAT3{REAL}@
      asymmetric_unit_geometry :: MAT{REAL}@
      n,a,b,s,col, i,u :: INT
      prune,new,unique,frac,redundant,mess :: BIN
      pruned :: MAP{INT,INT}@
      list :: VEC{INT}@
      cols :: VEC{INT}@
      tol :: REAL

      ! Set default options
      prune = TRUE
      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit

      ! Clean up from before
      .unit_cell_geometry.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy
      .asym_shift_for_unit_cell_atom.destroy

      ! List of indices of the asymmetric unit atoms to be made
      list = [(a, a=1,.n_fragment_atoms)]

      ! Initialise .asymmetric_unit_geometry as the whole fragment
      .asymmetric_unit_geometry = .fragment_geometry
      .n_asymmetric_unit_atoms  = .n_fragment_atoms

      ! Copy asymmetric unit & shift it to the unit cell
      asymmetric_unit_geometry = .asymmetric_unit_geometry
      .put_to_unit_cell(asymmetric_unit_geometry)

      ! Append new atoms "n" to unit cell
      .unit_cell_geometry.create(3,0)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = CRYSTAL_SAME_ATOM_TOL

      ! Fractional atom occupancies?
      frac = .fragment_atom.has_disorder
    ! WARN_IF(frac,"This structure has fractional occupancies and is disordered.")

      ! Initial loop counters
      pruned.create(0)
      redundant = FALSE
      n = 0 ! unit cell atom counter
      a = 0 ! asymmetric unit atom counter

      ! Loop: atoms "a" in
      ! the asymmetric unit
      do

         ! Next asymmetric unit atom
         a = a + 1

         ! Loop over symops
         do s = 1,.spacegroup.n_seitz

            ! Get the (unshifted) unit atom cell-offset
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,1,to_unit_cell=TRUE,unit_cell_shift=offset)

            ! Transform (shifted) asym unit atom with symop "s"
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)

            ! Prune symmetry redundant atoms?
            if (prune) then

               do ! remove *all* redundant atoms

                  ! Is symmetry-generated atom "pa" already in the asymmetric unit?
                  col = asymmetric_unit_geometry(:,a+1:).index_for_column(pa,tol)
                  unique = col==0

                  if (unique) exit

                  ! Actual atom index to prune
                  b = col + a

                  ! If already there, are the atoms at the two sites
                  ! crystallographically distinct?
                  unique = .fragment_atom.are_distinct(list(a),list(b))
                  if (unique) exit

                  ! Store pruned pair
                  pruned.append_pair(list(a),list(b))

                  ! This is a symmetry-redundant structure
                  redundant = TRUE
                  frac = NOT .fragment_atom(list(b)).site_occupancy.equals(ONE)

                  ! Prune the atom
                  .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
                  .asymmetric_unit_geometry.prune_column(b)
                   asymmetric_unit_geometry.prune_column(b)
                  list.prune_element(b)

               end

            end

            ! Is generated position "pa" new in the unit cell?
            cols = .unit_cell_geometry.indices_for_column(pa,tol)
            new  = cols.dim==0

            ! If old, is it distinct? E.g. different occupancy?
            if (NOT new) then
               do i = 1,cols.dim
                  b = .asym_atom_for_unit_cell_atom(cols(i))
                  new = .fragment_atom.are_distinct(list(a),list(b))
                  if (NOT new) exit
               end
            end
            cols.destroy

            if (NOT new) cycle

            ! New unit cell atom here ...
            n = n + 1

            ! Append it's info ...
            .unit_cell_geometry.append_column(pa)
            .asym_atom_for_unit_cell_atom.append(a)
            .asym_symop_for_unit_cell_atom.append(s)
            .asym_shift_for_unit_cell_atom.append_column(offset)

            ! If s=1 it must be an asymmetric unit atom
            if (s==1) then
               .unique_unit_cell_atom.append(n)
               .unique_uc_atom_offset.append(offset)
               .is_asym_unit_cell_atom.append(TRUE)
            else
               .is_asym_unit_cell_atom.append(FALSE)
            end

         end

         ! Finished?
         if (a==.n_asymmetric_unit_atoms) exit

      end

      .n_unit_cell_atoms = n

      ! Sanity check and print out
      mess = redundant AND prune
    ! WARN_IF(mess,"Symmetry-redundant atoms were pruned.")

      ! Die if pruned a symmetry-redundant fractional atom.
      if (mess AND frac) then

       ! WARN("Symmetry-redundant pruned atom had a fractional occupancy!")

       ! stdout.flush
       ! stdout.text("Fragment atom list:")
       ! .fragment_atom.put_coordinates

       ! stdout.flush
       ! stdout.text("Parent and pruned fragment atoms:")
       ! stdout.flush
       ! do i = 1,pruned.n_keys
       !    stdout.put(pruned.keys(i))
       !    stdout.put(pruned.values(i))
       !    stdout.flush
       ! end
       ! WARN("Symmetry-redundant pruned atom had a fractional occupancy!")

      end

      ! Die if no unit cell
    ! ENSURE(.unit_cell_geometry.allocated,"The unit_cell_geometry was not created!")

      ! >> Make the asymmetric unit atoms <<
      ! NOTE: everything in cartesian system.
      .asymmetric_unit_atom = .fragment_atom(list)

      ! >> Make the unit cell atoms <<
      .unit_cell_atom.destroy
      .unit_cell_atom.create(.n_unit_cell_atoms)

      seitz = .xyz_seitz_matrices
      do u = 1,.n_unit_cell_atoms

         a = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Copy the parent asymmetric atom
         .unit_cell_atom(u) = .asymmetric_unit_atom(a)

         ! Transform the pADPs (which must be in cartesians)
         .unit_cell_atom(u).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset position manually
         pos = matmul(.unit_cell.direct_mx,.unit_cell_geometry(:,u))
         .unit_cell_atom(u).set_position(pos)

      end
      seitz.destroy

      .unit_cell_atom.set_axis_system_to("cartesian")
      .unit_cell_atom.update

      ! Clean
      asymmetric_unit_geometry.destroy
      list.destroy
      pruned.destroy

   end

   make_frag_atom_for_cell_atom ::: leaky, private, PURE
   ! Arrays which relate the fragment atoms to the unit cell atoms.
      self :: INOUT

   ENSURE(.fragment_atom.allocated,                "no .fragment_atom")
   ENSURE(.fragment_geometry.allocated,            "no .fragment_geometry")
   ENSURE(.unit_cell_geometry.allocated,           "no .unit_cell_geometry")
   ENSURE(.asymmetric_unit_atom.allocated,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated, "no .asym_atom_for_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.allocated,"no .asym_symop_for_cell_atom")
   ENSURE(.spacegroup.analyzed,                  "no spacegroup info")

      sh :: VEC{INT}(3)
      pu,pa,pf,pf0 :: VEC{REAL}(3)
      u,f,a,s :: INT
      found,ident :: BIN
      tol :: REAL

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = .same_atom_tol

      ! Create the arrays we want
      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .unit_cell_shft_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      .frag_atom_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .unit_cell_atom_for_frag_atom.create(.n_fragment_atoms)
      .unit_cell_shft_for_frag_atom.create(3,.n_fragment_atoms)
      .frag_atom_for_asym_atom.create(.n_asymmetric_unit_atoms)
      .asym_atom_for_frag_atom.create(.n_fragment_atoms)
      .asym_symop_for_frag_atom.create(.n_fragment_atoms)
      .asym_shift_for_frag_atom.create(3,.n_fragment_atoms)

      ! Initialise
      .frag_atom_for_unit_cell_atom = 0
      .unit_cell_atom_for_frag_atom = 0
      .unit_cell_shft_for_frag_atom = 0
      .frag_atom_for_asym_atom = 0
      .asym_atom_for_frag_atom = 0

      ! Loop over fragment atoms
      do f = 1,.n_fragment_atoms

         ! Shift fragment atom to unit cell
         pf0 = .fragment_geometry(:,f)
         pf  = pf0
         .put_to_unit_cell(pf,shift=sh)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Asymmetric atom a for unit cell atom u
            a = .asym_atom_for_unit_cell_atom(u)

            ! Unit cell position
            pu = .unit_cell_geometry(:,u)

            ! Is unit cell atom u the fragment atom f?
            found = pu.same_as(pf,tol)
            ident = .fragment_atom(f).is_xtal_identical_kind_to(.asymmetric_unit_atom(a))
            found = found AND ident

            ! Cycle if not the same
            if (NOT found) cycle

            ! Relate unit cell atom and fragment atom
            ! These are identical by translation.
            .frag_atom_for_unit_cell_atom(u) = f
            .unit_cell_atom_for_frag_atom(f) = u
            .unit_cell_shft_for_frag_atom(:,f) = sh

            ! Relate asym unit atom and fragent atom
            ! Maybe >1 frag atom  matching the asym atom
            .asym_atom_for_frag_atom(f) = a
            if (.frag_atom_for_asym_atom(a)==0) &
                .frag_atom_for_asym_atom(a) = f

            ! Asym symop which can generate this frag atom
            s = .asym_symop_for_unit_cell_atom(u)
            .asym_symop_for_frag_atom(f) = s

            ! Get shift for asym atom -> frag atom
            pa = .asymmetric_unit_geometry(:,a)
            pf = .fragment_geometry(:,f)
            .transform_position(pa,s,ignore_glide=TRUE)
            .asym_shift_for_frag_atom(:,f) = pf - pa

            exit

         end

         ENSURE(found,"fragment atom "//f.to_str.trim//" was not found in the unit cell")

      end

      ! Relate unit cell atom to parent frag atom
      ! These are identical by a crystal symop.
      .frag_parent_for_cell_atom.destroy
      .frag_parent_for_cell_atom.create(.n_unit_cell_atoms)
      do u = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(u)
         f = .frag_atom_for_asym_atom(a)
         .frag_parent_for_cell_atom(u) = f
      end

   end

   make_unique_frag_atoms ::: leaky, private, PURE
   ! Make the unique fragment atoms (these are those corresponding to
   ! the asymmetric unit atoms) and also make symops which relate the
   ! non-unique to the unique.
      self :: INOUT

   ENSURE(.asym_atom_for_frag_atom.allocated, "no .asym_atom_for_frag_atom")
   ENSURE(.unit_cell_atom_for_frag_atom.allocated, "no .unit_cell_atom_for_frag_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.allocated,"no .asym_symop_for_cell_atom")

      f,a,m,u,s,t :: INT
      unique :: BIN

      ! Create the arrays we want
      .unique_frag_atom.destroy
      .unique_index_for_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy

      .unique_index_for_frag_atom.create(.n_fragment_atoms)
      .unique_atom_for_frag_atom.create(.n_fragment_atoms)
      .unique_symop_for_frag_atom.create(.n_fragment_atoms)

      .n_unique_frag_atoms = 0

      ! Loop over the fragment atoms
      do f = 1,.n_fragment_atoms

         ! Asym atom for this fragment atom
         a = .asym_atom_for_frag_atom(f)

         ! Asym symop which can generate this frag atom
         u = .unit_cell_atom_for_frag_atom(f)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Does this asym atom "a" occur before?
         ! If not, its unique.
         m = .asym_atom_for_frag_atom(1:f-1).index_of_value(a)
         unique = m==0
         if (unique) then
            .n_unique_frag_atoms = .n_unique_frag_atoms + 1
            .unique_index_for_frag_atom(f) = .n_unique_frag_atoms
            .unique_atom_for_frag_atom(f) = f
            .unique_symop_for_frag_atom(f) = 1     ! identity
            .unique_frag_atom.append(f)            ! Indices of unique frag atoms
         else
            .unique_index_for_frag_atom(f) = 0
            .unique_atom_for_frag_atom(f) = m      ! 1 <= m <= f-1
            u = .unit_cell_atom_for_frag_atom(m)
            t = .asym_symop_for_unit_cell_atom(u)
            t = .spacegroup.inverse_of_symops(t)   ! inverse of symop(t) maps m -> a
            t = .spacegroup.product_of_symops(s,t) ! s maps a -> f (except for trans)
            .unique_symop_for_frag_atom(f) = t
         end

      end

   end

   make_asym_symops_for_frag_atom ::: leaky, private, PURE
   ! Make all symops which generate a fragment atom (up to
   ! translation equivalence) from a given asymmetric unit atom.
   ! These are only a given symop which does the mapping multiplied by
   ! the asym atoms stabilizer group, but it is convenient for
   ! symmetrisation.
      self :: INOUT

   ENSURE(.asym_atom_for_frag_atom.allocated, "no .asym_atom_for_frag_atom")
   ENSURE(.asymmetric_unit_geometry.allocated, "no .asym_atom_for_frag_atom")

      pa,pf :: VEC{REAL}(3)
      s,f,a :: INT
      same  :: BIN
      tol   :: REAL

      tol = CRYSTAL_SAME_ATOM_TOL

      ! Create
      .asym_symops_for_frag_atom.destroy
      .asym_symops_for_frag_atom.create(.n_fragment_atoms)

      ! Loop over symops
      do s = 1,.spacegroup.n_seitz

         ! Loop over the fragment atoms
         do f = 1,.n_fragment_atoms

            ! Asym atom for this fragment atom
            a = .asym_atom_for_frag_atom(f)

            ! Put asym atom into unit cell.
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,1,to_unit_cell=TRUE)

            ! Transform asym unit atom with symop "s"
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)

            ! Put fragment atom to unit cell
            pf = .fragment_geometry(:,f)
            .put_to_unit_cell(pf)

            ! If same add the symop to the list
            same = pa.same_as(pf,tol) 
            if (same) then
               .asym_symops_for_frag_atom(f).element.append(s)
            end

         end

      end

   end

   make_unit_cell_connections ::: leaky, PURE
   ! From the .asymmetric_unit_atom list make the .unit_cell_connection
   ! table and the .unit_cell_mol_for_atom list which has the list of
   ! distinct molecules in the unit cell i.e. those groups of unit
   ! cell atoms which are connected to each other (ignoring/accounting
   ! for translational symmetry). NOTE: only connections to
   ! next-neighboring unit cells are considered regardless of the size
   ! of covalent radii.
      self :: INOUT

   ENSURE(.unit_cell_geometry.allocated,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.allocated,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list")

      new :: VEC{EVEC{INT}}@
      unit_cell_mol_for_atom,unique :: VEC{INT}@
      geom0,geom1 :: MAT{REAL}@
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3, mi,mj :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .unit_cell_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .unit_cell_connection.create(.n_unit_cell_atoms,0)
      .unit_cell_mol_for_atom.create(.n_unit_cell_atoms)

      ! Set worst case scenario: all atoms on different molecules
      unit_cell_mol_for_atom.create(.n_unit_cell_atoms)
      do i = 1,.n_unit_cell_atoms
         unit_cell_mol_for_atom(i) = i
      end

      ! Define a new connected atom: its 3-element shift and index
      ! This is just an expanded version of CLUSTER_UA_CODE
      new.create(1)
      new(1).element.create(4)

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_mx
      geom0.create(3,.n_unit_cell_atoms)
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0
      h2 = 0
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i)

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom0(:,j)
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              new(1)[:] = [h1,h2,h3,j]; .unit_cell_connection(i).element.append(new)
              new(1)[4] = i;            .unit_cell_connection(j).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)

              ! Replace all previous by the lowest mol
              if (mj<mi) then
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms)
      do h1 = -1,1
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) ! Atom i belongs to mol "mi"

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom1(:,j)
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              new(1)[:] = [h1,h2,h3,j]
              .unit_cell_connection(i).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)
              if (mj<mi) then        ! replace all previous by the lowest mol
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end

        end ! unit cell atoms

      end
      end
      end

      ! Clean
      geom1.destroy
      geom0.destroy
      new.destroy

      ! Now make the .unit_cell_mol_for_atom list consecutive
      .unit_cell_mol_for_atom = unit_cell_mol_for_atom
      unique.to_unique_elements_of(unit_cell_mol_for_atom)
      unique.sort
      .n_unit_cell_mols = unique.dim
      do mi = 1,.n_unit_cell_mols
         mj = unique(mi)
         if (mj==mi) cycle
         where (unit_cell_mol_for_atom==mj) .unit_cell_mol_for_atom = mi
      end
      unique.destroy
      unit_cell_mol_for_atom.destroy

   end

   make_uc_vdw_connections ::: leaky, PURE
   ! From the .asymmetric_unit_atom list make the .uc_vdw_connection
   ! table. Essentially aame as above with different bond criteria.
      self :: INOUT

   ENSURE(.unit_cell_geometry.allocated,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.allocated,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list")
   ENSURE(.unit_cell_mol_for_atom.allocated,"no unit_cell_mol_for_atom list")

      vdw :: VEC{EVEC{INT}}@
      geom0,geom1 :: MAT{REAL}@
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3 :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .uc_vdw_connection.destroy
      .uc_vdw_connection.create(.n_unit_cell_atoms,0)

      ! Define a new connected atom: its index and 3-element shift
      vdw.create(1)
      vdw(1).element.create(4)

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_mx
      geom0.create(3,.n_unit_cell_atoms)
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0
      h2 = 0
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom0(:,j)
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              vdw(1)[:] = [h1,h2,h3,j]; .uc_vdw_connection(i).element.append(vdw)
              vdw(1)[4] = i;            .uc_vdw_connection(j).element.append(vdw)

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms)
      do h1 = -1,1
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom1(:,j)
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              vdw(1)[:] = [h1,h2,h3,j]
              .uc_vdw_connection(i).element.append(vdw)

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy
      geom0.destroy
      vdw.destroy

   end

   z_factor result (res) ::: PURE
   ! The Z crystallographic factor for ".fragment_geometry", defined
   ! as the ratio of the number of electrons in the unit cell on the
   ! number of electrons in the fragment.
      self :: IN
      res :: REAL

   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom")
   ENSURE(.fragment_atom.allocated,       "no fragment_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated,"no asym_atom_for_unit_cell_atom")

      ue,fe :: REAL

      ! Get # of electrons in unit cell
      !ue = .asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).no_of_electrons
      ue = .asymmetric_unit_atom.no_of_electrons(.asym_atom_for_unit_cell_atom)

      ! Get # of electrons in fragment
      fe = .fragment_atom.no_of_electrons

      ! Z factor is the ratio
      res = ue/fe

   end

   no_of_unit_cell_electrons result (res) ::: PURE
   ! The totl number of electrons in the unit cell aka F_000.
      self :: IN
      res :: REAL

   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom")
   ENSURE(.asym_atom_sym_factor.allocated, "no .asym_atom_sym_factor")

      a, n,r :: INT

      n = .spacegroup.n_seitz

      res = 0

      do a = 1,.n_asymmetric_unit_atoms
         r   = int(.asym_atom_sym_factor(a))
         res = res + .asymmetric_unit_atom(a).atomic_number*n/r
      end

   end

!  ==================
!  Repetition factors
!  ==================

   make_repetition_factors ::: leaky, private, PURE
   ! The number of times *any* fragment atom is mapped onto a
   ! particular fragment atom with index "a" under *all* spacegroup
   ! symmetry group, is the ".repetition_factor(a)".
   ! It is used to correct structure factors for fragment geometries
   ! which are "oversampled" relative to the asymmetric cell geometry.
      self :: INOUT

   ENSURE(.fragment_geometry.allocated, "no fragment_geometry!")

      pa,pb :: VEC{REAL}(3)
      a,b,n,n_same :: INT
      same :: BIN
      tol :: REAL

      if (.use_manual_repetition_factors) then

         ENSURE(.repetition_factor.allocated,"no repetiton_factors entered!")

      else

         tol = CRYSTAL_SAME_ATOM_TOL

         .repetition_factor.destroy
         .repetition_factor.create(.n_fragment_atoms)

         do a = 1,.n_fragment_atoms

            pa = .fragment_geometry(:,a)
            .put_to_unit_cell(pa)

            n_same = 0
            do b = 1,.n_fragment_atoms
            do n = 1,.spacegroup.n_seitz
               pb = .fragment_geometry(:,b)
               .transform_position(pb,n,to_unit_cell=TRUE)
               same = pa.same_as(pb,tol)
               if (same) n_same = n_same + 1
            end
            end

            .repetition_factor(a) = n_same

         end

      end

   end

   make_asym_atom_sym_factors ::: leaky, private, PURE
   ! The number of times an asymmetric cell atom with index "a" is
   ! mapped into itself under the symmetry group is the
   ! ".asym_atom_sym_factor(a)". Also record the stabilizing
   ! operations in ".asym_atom_stabilizer(a)[:]". These are used in
   ! atomic-type structure factor calculations based on the asymmetric
   ! cell geometry.
      self :: INOUT

   ENSURE(.fragment_geometry.allocated, "no fragment_geometry!")

      pa,pn :: VEC{REAL}(3)
      a,n,n_same :: INT
      same :: BIN
      tol :: REAL

      tol = CRYSTAL_SAME_ATOM_TOL

      .asym_atom_sym_factor.destroy
      .asym_atom_stabilizer.destroy
      .asym_atom_sym_factor.create(.n_asymmetric_unit_atoms)
      .asym_atom_stabilizer.create(.n_asymmetric_unit_atoms)

      .n_stabilizer_max = 0

      do a = 1,.n_asymmetric_unit_atoms

         pa = .asymmetric_unit_geometry(:,a)
         .put_to_unit_cell(pa)

         n_same = 0

         do n = 1,.spacegroup.n_seitz

            pn = pa
            .transform_position(pn,n,to_unit_cell=TRUE)
            same = pa.same_as(pn,tol)

            if (NOT same) cycle

            n_same = n_same + 1
            .asym_atom_stabilizer(a).element.append(n)

            .n_stabilizer_max = max(n_same,.n_stabilizer_max)

         end

         .asym_atom_sym_factor(a) = n_same

      end

   end

   make_frag_atom_sym_factors ::: leaky, private, PURE
   ! The number of times a fragment atom with index "f" is mapped into
   ! itself under the symmetry group is ".frag_atom_sym_factor(a)". 
   ! The stabilizing operations in ".frag_atom_stabilizer(a)[:]". 
   ! These are used in atomic-type structure factor calculations based
   ! on the fragment geometry.
      self :: INOUT

   ENSURE(.fragment_geometry.allocated, "no fragment_geometry!")
   ENSURE(.asym_atom_sym_factor.allocated, "no asym_atom_sym_factor!")
   ENSURE(.asym_atom_stabilizer.allocated, "no asym_atom_sym_factor!")

      f,a :: INT

      .frag_atom_sym_factor.destroy
      .frag_atom_stabilizer.destroy
      .frag_atom_sym_factor.create(.n_fragment_atoms)
      .frag_atom_stabilizer.create(.n_fragment_atoms)

      do f = 1,.n_fragment_atoms

         a = .asym_atom_for_frag_atom(f)

         .frag_atom_sym_factor(f) = .asym_atom_sym_factor(a)
         .frag_atom_stabilizer(f).element = .asym_atom_stabilizer(a).element

      end

   end

!  =============================
!  Reset hydrogen atom positions
!  =============================

   reset_H_bond_lengths_in(atom,H_bond_length,reset) ::: PURE
   ! Resets the coordinates of the single-bonded H "atoms" so that
   ! their bond lengths have those in the "H_bond_length" array.
   ! Negative values mean no changes. If present "reset" is set
   ! TRUE if at least on the H atom positions was reset.
   ! *Multiple bonded H atom (from unit cell conn. table) *ignored*
   ! WARNING: this routine destroys all the fragment data.
      self :: allocatable, INOUT
      atom :: VEC{ATOM}, INOUT
      H_bond_length :: VEC{REAL}@, IN
      reset :: BIN, optional, OUT

   ENSURE(H_bond_length.allocated,"no H_bond_length array")

      lb,ub,ua,fh,fa,uh,Za,n :: INT
      hh,ph,pa,sh,ch,ca,dd,d :: VEC{REAL}(3)
      rcm,inv :: MAT{REAL}(3,3)
      done :: BIN

      done = FALSE
      if (present(reset)) reset = done

      if (all(H_bond_length<ZERO)) return

      ! Destroy all the fragment and asymmetric unit data
      .destroy_fragment_data
      .destroy_asymmetric_unit

      ! Make unit cell connection table
      .update_fragment_info(atom)

      ! Elements whose bond lengths to change
      lb = lbound(H_bond_length,1)
      ub = ubound(H_bond_length,1)

      ! Cell matrices
      rcm = .unit_cell.direct_mx
      inv = .unit_cell.inverse_mx

      ! Loop fragment atom positions
      do fh = 1,.n_fragment_atoms

         ! If fragment atom is not H atom, cycle ...
         if (atom(fh).atomic_number/=1) cycle

         ! The H atom  must have only one bond
         uh = .unit_cell_atom_for_frag_atom(fh)
         if (.unit_cell_connection(uh).element.dim>1) then
            n = .unit_cell_connection(uh).element.dim
          ! WARN("Hydrogen #"//fh.to_str.trim//" is bonded to "//n.to_str.trim//" atoms")
            cycle
         end

         ! Which frag atom is the H connected to?
         ua = .unit_cell_connection(uh)[1][4]
         fa = .frag_atom_for_unit_cell_atom(ua)
         if (fa==0) cycle

         ! If it isn't one of those to be reset, cycle
         Za = atom(fa).atomic_number
         if (Za<lb OR Za>ub) cycle
         if (H_bond_length(Za)<ZERO) cycle

         done = TRUE

         ! Get the H atom pos relative to A
         hh = .fragment_geometry(:,fh)
         pa = .fragment_geometry(:,fa)
         dd = hh - pa
         d  = mod(dd,[ONE,ONE,ONE])
         where (d> HALF) d = d - ONE
         where (d<-HALF) d = d + ONE
         ph = pa + d
         sh = ph - hh

         ! Get new cartesian H atom position
         ch = matmul(rcm,ph)
         ca = matmul(rcm,pa)
         dd = ch - ca
         dd.normalize
         ch = ca + H_bond_length(Za)*dd

         ! Put H atom back
         ph = matmul(inv,ch) - sh
         ch = matmul(rcm,ph)

         ! Reset the H atom position
         atom(fh).set_position(ch)

      end

      if (present(reset)) reset = done

      ! Clean up
      .destroy_fragment_data

   end

!  ================
!  Position changes
!  ================

   ! The next three routines should be in SPACEGROUP

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell) ::: PURE
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      self :: IN
      g :: MAT{REAL}, INOUT
      op :: INT, IN
      translate :: VEC{REAL}(3), optional, IN
      ignore_glide :: BIN, optional, IN
      to_unit_cell :: BIN, optional, IN

   ENSURE(g.dim1==3,"incorrect size for array g")

      n :: INT

      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end

   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) ::: PURE
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE,
   ! "ignore_glide" will not add the glide vector part of the Seitz
   ! operator.  If present and TRUE, "to_unit_cell" will translate the
   ! fractional coordinates into the (0:1,0:1,0:1) unit cell, and
   ! "unit_cell_shift" is set to the translation vector required to do
   ! this.
      self :: IN
      p :: VEC{REAL}(3), INOUT
      op :: INT, IN
      translate :: VEC{REAL}(3), optional, IN
      ignore_glide :: BIN, optional, IN
      to_unit_cell :: BIN, optional, IN
      unit_cell_shift :: VEC{INT}(3), optional, OUT

   ENSURE(.spacegroup.seitz.allocated,"Seitz matrices not initialized")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")

      ignore,to_cell :: BIN

      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide

      if (ignore) then
         p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
         p = matmul(.spacegroup.seitz(1:3,1:3,op),p) &
                  + .spacegroup.seitz(1:3,4  ,op)
      end

      if (present(translate)) p = p + translate

      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell

      if (to_cell) .put_to_unit_cell(p,unit_cell_shift)

   end

   transform_xyz_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) ::: PURE
   ! Transform the *cartesian* position "p" with the Seitz operator
   ! with index "op". If present, "translate" will be added to the
   ! transformed position. If present and TRUE, "ignore_glide" will
   ! not add the glide vector part of the Seitz operator.  If present
   ! and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (0:1,0:1,0:1) unit cell, and
   ! "unit_cell_shift" is set to the translation vector required to do
   ! this.
      self :: IN
      p :: VEC{REAL}(3), INOUT
      op :: INT, IN
      translate :: VEC{REAL}(3), optional, IN
      ignore_glide :: BIN, optional, IN
      to_unit_cell :: BIN, optional, IN
      unit_cell_shift :: VEC{INT}(3), optional, OUT

      pc :: VEC{REAL}(3)

      pc = p

      .unit_cell.change_into_fractional(pc)
      .transform_position(pc,op,translate,ignore_glide,to_unit_cell,unit_cell_shift)
      .unit_cell.change_from_fractional(pc)

      p = pc

   end

   ! The next four routines should be in UNITCELL

   put_to_unit_cell(g) ::: PURE
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      self :: IN
      g :: MAT{REAL}, INOUT

   ENSURE(g.dim1==3 OR g.dim2==3, "incorrect shape for array g")

      n :: INT

      if (g.dim1==3) then
         do n = 1,g.dim2
            .put_to_unit_cell(g(:,n))
         end
      else
         do n = 1,g.dim1
            .put_to_unit_cell(g(n,:))
         end
      end

   end

   put_to_unit_cell(p,shift) ::: PURE
   ! Transform the position "p" in fractional coordinates into the
   ! [0:1,0:1,0:1) unit cell. If present, "shift" is set to the
   ! translation vector needed to effect the change to the unit cell.
      self :: IN
      p :: VEC{REAL}(3), INOUT
      shift :: VEC{INT}(3), optional, OUT

   ENSURE(size(p)==3, "p must be length 3")

      new,pi :: VEC{REAL}(3)
      tol :: REAL

      tol = .unit_cell_tol

      ! Change p to cell boundary (within tol)
      pi = REALIFY(nint(p))
      where (abs(p-pi)<tol) p = pi

      ! The new unit cell coordinate
      new = p - floor(p)

      ! The shift applied to the (corrected) p
      ! to get it into the unit cell ...
      if (present(shift)) shift = int(new - p)

      ! Set p
      p = new

   end

!   move_to_unit_cell(g) ::: PURE
!   ! Transform the geometry "g" in fractional coordinates into the first
!   ! lattice cell.  The shape of the molecule remains intact, so some of it
!   ! may cross into other cells.  The center of the molecule will be in the
!   ! first cell.
!      self :: INOUT
!      g :: MAT{REAL}, INOUT
!
!   ENSURE(g.dim1==3, "incorrect size for array g")
!
!      n,n_atom :: INT
!      center :: VEC{INT}(3)
!
!      n_atom = g.dim2
!      center = CRYSTAL::unit_cell_offset(g)
!      do n = 1, n_atom
!         g(:,n) = g(:,n) - center
!      end
!
!   end

!   unit_cell_offset(g) result (res) ::: selfless, private, PURE
!   ! Which hkl indices match the center of the fragment geometry "g" when
!   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
!   ! not always.
!      g :: MAT{REAL}, IN
!      res :: VEC{INT}(3)
!
!   ENSURE(g.dim1==3, "incorrect size for array g")
!
!      res = int(g.sum_column_vectors/g.dim2)
!
!   end

   ! For integration grids

!   make_symmetry_equivalents_from(pt0,wt0,site_index,pt,wt) ::: PURE, leaky
!   ! Transform *cartesian* 3D points "pt0" and correspoding 1D weights
!   ! "wt0" from an integration grid by the symmetry operators whose
!   ! indices are in "site_symops" and return them in "pt" and "wt"
!      self :: IN
!      pt0 :: MAT{REAL}, IN
!      wt0 :: VEC{REAL}, IN
!      site_index :: INT, IN
!      pt :: MAT{REAL}@, OUT
!      wt :: VEC{REAL}@, OUT
!
!   ENSURE(.spacegroup.seitz.allocated,"Seitz matrices not initialized")
!   ENSURE(.frag_atom_stabilizer.allocated,"No site symmetry operators!")
!   ENSURE(site_index>0,     "operator index out of bounds")
!
!     seitz :: MAT3{REAL}@
!     g,s,ss, n_ss,n_pt :: INT
!
!     n_pt = wt0.dim
!     n_ss = .frag_atom_stabilizer(site_index).element.dim
!
!     ! Rotated points & cloned weights (leaky)
!     pt.create(n_pt*n_ss,3)              
!     wt.create(n_pt*n_ss)
! 
!     ! Cartesian seitz matrices
!     seitz = .transposed_xyz_seitz_matrices 
!
!     s = 0
!     do ss = 1,n_ss
!
!        ! Site symop index
!        g = .frag_atom_stabilizer(site_index).element(ss)
!
!        ! Do the rotation
!        pt(s+1:s+n_pt,:) = matmul(pt0,seitz(:,:,g))
!        wt(s+1:s+n_pt  ) = wt0
!
!        ! Space for next block of pointsd
!        s = s + n_pt
!
!     end
!
!     ! Average by the no. of site symops
!     wt = wt/n_ss
!
!   end

!  ===============
!  Fragment widths
!  ===============

   fragment_width result (res) ::: pure
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      self :: IN
      res :: VEC{REAL}(3)

   ENSURE(.fragment_geometry.allocated,"no fragment geometry")

      res = .fragment_geometry.max_abs_column_difference

   end

!  ==============
!  Seitz matrices
!  ==============

   make_xyz_seitz_matrices(res) ::: leaky, PURE
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      self :: IN
      res :: MAT3{REAL}@, OUT

   ENSURE(.spacegroup.seitz.allocated,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_mx, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_mx))
      end

   end

   xyz_seitz_matrices result (res) ::: leaky, PURE
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system.
      self :: IN
      res :: MAT3{REAL}@

   ENSURE(.spacegroup.seitz.allocated,"no Seitz matrices")

      i :: INT

      ! leaky
      res.create(3,3,.spacegroup.n_seitz) 
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_mx, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_mx))
      end

   end

   transposed_xyz_seitz_matrices result (res) ::: leaky, PURE
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system.
      self :: IN
      res :: MAT3{REAL}@

   ENSURE(.spacegroup.seitz.allocated,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.reciprocal_mx, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.unit_cell.direct_mx)))
      end

   end

!  ===========
!  Stabilizers
!  ===========

   make_stabilizer_symops ::: leaky, private, PURE
   ! Make a list of the indices of the Seitz matrices,
   ! ".stabilizer_symop", which will generate the same geometries to
   ! that in ".fragment_geometry" when both the original and
   ! transformed geometries are converted to unit cell coordinates.
   ! ".n_stabilizer_symops" is set to the number of these symmetry
   ! operations.
   ! NOTE: geometries NOT whole-shifted to unit cell ... should they ! be?
      self :: INOUT

      g1,gi :: MAT{REAL}@
      i,n :: INT
      identical :: BIN

      .stabilizer_symop.destroy
      .stabilizer_symop.create(.spacegroup.n_seitz)

      g1.create(3,.n_fragment_atoms)
      gi.create(3,.n_fragment_atoms)
      g1 = .fragment_geometry

      n = 1
      .stabilizer_symop(1) = 1

      do i = 2,.spacegroup.n_seitz

         gi = .fragment_geometry
         .transform_geometry(gi,i)
         identical  = ::is_same_geometry(gi,g1)

         if (NOT identical) cycle

         n = n + 1
         .stabilizer_symop(n) = i

      end

      gi.destroy
      g1.destroy

      .n_stabilizer_symops = n
      .stabilizer_symop.shrink(n)

   end

   is_same_geometry(geom_i,geom_j) result (res) ::: selfless, private, PURE
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: MAT{REAL}, IN
      res :: BIN

   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")

      i,j,n_atom :: INT
      skip :: VEC{BIN}@
      same :: BIN
      tol :: REAL

      tol = CRYSTAL_SAME_ATOM_TOL

      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE

      do i = 1,n_atom
      do j = 1,n_atom

         same = geom_i(:,i).same_as(geom_j(:,j),tol)

         if (NOT same OR skip(j)) cycle

         skip(j) = TRUE
         exit

      end
      end

      res = all(skip) ! True if all atoms in i were matched (skipped) in j

      skip.destroy

   end

   xyz_stabilizer_matrices result (res) ::: leaky, PURE
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis which stabilize the fragment geometry.
      self :: IN
      res :: MAT3{REAL}@

   ENSURE(.spacegroup.seitz.allocated,"no Seitz matrices")
   ENSURE(.stabilizer_symop.allocated,"no stabilizer symop matrices")

      i,s :: INT

      res.create(3,3,.n_stabilizer_symops)
      do i = 1,.n_stabilizer_symops
         s = .stabilizer_symop(i)
         res(:,:,i) = matmul(.unit_cell.direct_mx, &
                      matmul(.spacegroup.seitz(1:3,1:3,s),.unit_cell.inverse_mx))
      end

   end

!  Use GAUSSIAN_DATA for the routines below ...

   make_stabilizer_xyz_matrices ::: leaky, private, PURE
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is a stabilizer symop.
   ! WARNING: this routine is tied to an explicit ordering of the cartesian
   ! gaussian basis functions in a shell.
      self :: INOUT

      .str.create(1,1,.n_stabilizer_symops)
      .str = ONE
      .ptr = .xyz_stabilizer_matrices     ! 3  x 1
      .dtr = .ptr.gaussian_d_xyz_matrices ! 6  x 6
      .ftr = .ptr.gaussian_f_xyz_matrices ! 10 x 10
      .gtr = .ptr.gaussian_g_xyz_matrices ! 15 x 15

   end

   xyz_stabilizer_mx(n,l) result (res) ::: PURE
   ! Return the "n"-th stabilizer representation matrix for xyz
   ! product found in a gaussian shell of angular momentum "l"
      self :: IN
      n,l :: INT, IN
      res :: MAT{REAL}@

   ENSURE(l>=0,"l must be non-negative")
   ENSURE(l<=4,"l must be no greater than 4 (no h functions or higher)")

      select case (l)
      case(0); res = .str(:,:,n)
      case(1); res = .ptr(:,:,n)
      case(2); res = .dtr(:,:,n)
      case(3); res = .ftr(:,:,n)
      case(4); res = .gtr(:,:,n)
     !case default; DIE("not implemented beyond l=4")
      end

   end

!  =====================================
!  Service methods used by other modules
!  =====================================

! Don't delete code below just yet ...

!   make_phased_mx_for_symop(u,phase,mask) ::: private
!   ! Return the sum of the "phase" shifts times the seitz matrices for all
!   ! symops which are equivalent to the "u"-th unique symmetry operation,
!   ! .spacegroup.unique_SF_symop(u), as determined by the "mask" array, when
!   ! mask(u)==.spacegroup.unique_SF_symop(u).
!     u :: INT, IN
!     phase :: MAT3{CPX}, OUT
!     mask :: VEC{INT}, IN
!
!   ENSURE(.spacegroup.analyzed,"no spacegroup")
!   ENSURE(u<=.spacegroup.n_unique_SF_symops,"symop index out of range")
!   ENSURE(phase.dim1==.xray_data.reflections.dim,"wrong size, dim=1, phase array")
!   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
!   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
!
!     pi2,tx,ty,tz,dot :: REAL
!     s,n,n_refl,h,k,l :: INT
!     seitz :: MAT{REAL}(4,4)
!     refl :: VEC{REFLECTION}*
!
!     refl => .xray_data.reflections
!     n_refl = refl.dim
!     pi2 = TWO*PI
!
!     phase = ZERO
!     do s = 1,.spacegroup.n_seitz
!
!       ! Sum only those which match unique symop u
!       if (mask(s)/=.spacegroup.unique_SF_symop(u)) cycle
!
!       ! Get the symop translation vector
!       seitz = .spacegroup.seitz(:,:,s)
!       tx = pi2*seitz(1,4)
!       ty = pi2*seitz(2,4)
!       tz = pi2*seitz(3,4)
!
!       ! Sum the phase here
!       ! This seems a kludge because we don't know the magnetic symmetry
!       if (seitz(3,3)>0) then                  ! M points along +z always
!         do n = 1,n_refl
!           h = refl(n).h1
!           k = refl(n).h2
!           l = refl(n).h3
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       else                                    ! M points in -z direction
!         seitz(3,:3) = -seitz(3,:3)            ! Invert
!         do n = 1,n_refl
!           h = refl(n).h1
!           k = refl(n).h2
!           l = refl(n).h3
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       end
!
!     end
!
!   end
!
!   sum_PND_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.reflections.dim,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.xray_data.allocated,"no data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!   ENSURE(ft_ints.dim1==.xray_data.reflections.dim,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.xray_data.reflections.dim,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .xray_data.reflections.dim
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phased_mx_for_symop(u,phase,.spacegroup.translated_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              unique_ft_ints(uf+n,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phased_mx_for_symop(u,phase,.spacegroup.inverted_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!        end
!
!     end
!     phase.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
!   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
!   ! Dimensions of ft_ints are [.reflections.dim,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT3{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.xray_data.allocated,"no data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!   ENSURE(ft_ints.dim1==.xray_data.reflections.dim,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.xray_data.reflections.dim,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .xray_data.reflections.dim
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phased_mx_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phased_mx_for_symop(u,phase,mask=.spacegroup.translated_symop) ! .inverted_symop here ??????????????
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
!       end
!     end
!     phase.destroy
!
!     ! The factor of 2 to convert to Bohr magnetons cancels the factor
!     ! of 1/2 for the Bohr magneton.
!     do n = 1,n_refl
!       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_ft_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.reflections.dim,n_comp_a,n_comp_b,3,3].
!     ft_ints :: MAT5{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.xray_data.allocated,"no data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!   ENSURE(ft_ints.dim1==.xray_data.reflections.dim,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.xray_data.reflections.dim,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT{CPX}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .xray_data.reflections.dim
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:)
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     do n = 1,n_refl
!        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
!   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Dimensions of ft are [.reflections.dim,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!     B :: VEC{REAL}(3)
!
!   ENSURE(.xray_data.allocated,"no data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!   ENSURE(ft_ints.dim1==.xray_data.reflections.dim,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.xray_data.reflections.dim,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT3{CPX}*
!     u,uf,n,n_refl :: INT
!     ci :: CPX
!
!     n_refl = .xray_data.reflections.dim
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     ci = (ZERO,ONE)
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
!   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.reflections.dim,n_comp_a,n_comp_b,3].
!      ft_ints :: MAT4{CPX}
!      unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.xray_data.allocated,"no data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!   ENSURE(ft_ints.dim1==.xray_data.reflections.dim,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.xray_data.reflections.dim,"wrong size, array unique_ft_ints")
!
!      phase :: VEC{CPX}*
!      q :: MAT{REAL}*
!      ints :: MAT3{CPX}*
!      u,uf,n,n_refl :: INT
!
!      n_refl = .xray_data.reflections.dim
!      phase.create(n_refl)
!      q.create(n_refl,3)
!      ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!      .make_k_pts(q)
!
!      ft_ints = ZERO
!      do u = 1,.spacegroup.n_unique_SF_symops
!
!         uf = n_refl*(u-1)
!
!         ! Add up translated symop contribution
!         .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!         do n = 1,n_refl
!            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!         ! Add up inverted symop contribution, if any
!         if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!         .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!         do n = 1,n_refl
!            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!      end
!      ints.destroy
!
!      ! The factor of 2 to convert to Bohr magnetons cancels the factor
!      ! of 1/2 for the Bohr magneton
!      ! Extra minus sign introduced, but not sure why ...
!      ! Reversed minus sign introduced ...
!      do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!      end
!      q.destroy
!      phase.destroy
!
!   end
!
!   sum_ft_j_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform j integrals "ft_ints", required for the PND
!   ! magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.reeflections.dim,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.xray_data.allocated,"no data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!   ENSURE(ft_ints.dim1==.xray_data.reflections.dim,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.xray_data.reflections.dim,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     u,uf, n,n_refl :: INT
!
!     n_refl = .xray_data.reflections.dim
!     phase.create(n_refl)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
!        end
!
!     end
!     phase.destroy
!
!   end

!  =====
!  Tests
!  =====

   do_fragHAR result (res) ::: PURE
   ! Returns TRUE if we are refining fragments.
      self :: allocatable, IN
      res :: BIN

      res = FALSE
      if (.allocated) then
      if (.xray_data.allocated) then
         res = .xray_data.refine_fragments
      end
      end

   end

   use_Ryde_capping result (res) ::: pure
   ! Return TRUE if Ulf Ryde's capping method for proteins is to be
   ! used in a fragHAR refinement.
      self :: allocatable, IN
      res :: BIN

      res = FALSE
      if (.allocated) then
      if (.xray_data.allocated) then
         res = .xray_data.use_Ryde_capping
      end
      end

   end

!  ===============
!  Inquiry methods
!  ===============

   xray_data_exists result (res) ::: pure
   ! Return TRUE if the diffraction data information exists
      self :: IN
      res :: BIN
      res = .xray_data.allocated
   end

   fragment_data_exists result (res) ::: pure
   ! Return TRUE if a fragment information exists
      self :: IN
      res :: BIN
      res = .fragment_geometry.allocated
   end


   asymmetric_unit_exists result (res) ::: pure
   ! Return TRUE if the asymmetric unit geometry information exists
      self :: IN
      res :: BIN
      res = .asymmetric_unit_geometry.allocated
   end

   unit_cell_geometry_exists result (res) ::: pure
   ! Return TRUE if the unit_cell_geometry information exists
      self :: IN
      res :: BIN
      res = .unit_cell_geometry.allocated
   end

!  ==========================================
!  Partitioning and temperature factor models
!  ==========================================

   partition_model result (res) ::: pure
   ! Model for partitioning fragments of the molecule
      self :: IN
      res :: STR
      if (.xray_data_exists) then; res = .xray_data.partition_model
      else;                        res = " "
      end
   end

   uses_numerical_FFs result (res) ::: pure
   ! Returns TRUE if numerical integration of the electron density is
   ! required for atomic form factors (or other) refinements.
   ! Currently only "hirshfeld" is supported for this.
      self :: IN
      res :: BIN
      res = .partition_model=="oc-hirshfeld"
   end

   uses_Hirshfeld_atoms result (res) ::: pure
   ! Returns TRUE if numerical integration of the electron density is
      self :: IN
      res :: BIN
      res = .partition_model=="oc-hirshfeld"
   end

   uses_Tanaka_atoms result (res) ::: pure
   ! Returns TRUE if one-center Tanaka atoms are being used.
      self :: IN
      res :: BIN
      res = .partition_model=="oc-tanaka"
   end


   temperature_factor_model result (res) ::: pure
   ! Temperature factor model to use for structure factors.
      self :: IN
      res :: STR
      if (.xray_data_exists) then; res = .xray_data.temperature_factor_model
      else;                        res = " "
      end
   end

   uses_one_center_TF_model result (res) ::: pure
   ! Temperature factor model to use for structure factors.
      self :: IN
      res :: BIN

      val :: STR

      val = .temperature_factor_model
      res = val=="one-center" OR val=="atom-based"

   end

!  =======================
!  Equivalents and merging
!  =======================

   is_symmetry_unmerged result (res) ::: PURE
   ! Returns TRUE if the list of reflections has symmetry equivalents
   ! i.e. is symmetry *unmerged* or is Friedel unmerged.
      self :: IN
      res :: BIN

   ENSURE(.xray_data.allocated,"no diffraction data")
   ENSURE(.xray_data.reflections.allocated,"no reflection data")

      i,j,g  :: INT
      n_refl :: INT
      p,q,r  :: VEC{INT}(3)
      same :: BIN

      n_refl = .xray_data.reflections.dim

      ! Loop reflection
      same = FALSE
      refl: do i = 1,n_refl

         p = .xray_data.reflections(i).Miller_indices
        
         ! The other reflection
         same = FALSE
         do j = i+1,n_refl
         do g = 1  ,.spacegroup.n_seitz
            ! Symmetry transform it
            q = .xray_data.reflections(j).Miller_indices
            r = int(matmul(q,.spacegroup.seitz(1:3,1:3,g)),kind=INT_KIND)
            same = p.same_as(r)
            if (same) exit refl
         end
         end
        
      end do refl

      res = same

   end

   make_list_of_equivalents_v2(list,n_unique) ::: leaky, PURE
   ! Make a "list" of the indices of the first equivalent reflection
   ! i.e. list(i) = j < i is the first reflection symmetry-equivalent 
   ! the i-th reflection.  "n_unique" is returned as the number of
   ! unique reflections, where list(i) == i.
   ! NOTE: Includes inversions, if the spacegroup is centrosymmetric.
      self :: IN
      list :: VEC{INT}@, OUT
      n_unique :: INT, OUT

   ENSURE(.xray_data.allocated,"no diffraction data")
   ENSURE(.xray_data.reflections.allocated,"no reflection data")

      i,j,g, n_refl :: INT
      p,q,r :: VEC{INT}(3)
      seitz :: MAT{REAL}(3,3)
      same :: BIN

      n_refl = .xray_data.reflections.dim

      ! Default list(:) values
      list.create(n_refl) ! leaky
      list.to_sequence(1,n_refl)

      n_unique = 0

      ! Loop reflection indices "p"
      do i = 1,n_refl

         p = .xray_data.reflections(i).Miller_indices

         ! Find equivalents
         same = FALSE
         refl: do j = i+1,n_refl
            q = .xray_data.reflections(j).Miller_indices
            do g = 1,.spacegroup.n_seitz
               ! Get symmetry equivalent indices "r"
               seitz = transpose(.spacegroup.seitz(1:3,1:3,g))
               r = nint(matmul(seitz,q))
               ! Equivalent?
               same = p.same_as(r)
               if (same) then
                  list(j) = i ! Set here
                  exit refl
               end
            end
         end do refl

         ! Increment
         if (NOT same) n_unique = n_unique + 1

      end

   end

   remove_equivalents(list,n_unique) ::: leaky, PURE
   ! If there are any equivalent reflections keep only the one that
   ! occures first in the list.
      self :: INOUT
      list :: VEC{INT}, IN
      n_unique :: INT, IN

   ENSURE(.xray_data.allocated,"no diffraction data")
   ENSURE(.xray_data.reflections.allocated,"no reflection data")

      reflections :: VEC{REFLECTION}@
      i, n :: INT

      ! Define set of new unique reflections
      reflections.create(n_unique) ! leaky
      n = 0
      do i = 1,.xray_data.reflections.dim
         if (list(i)<i) cycle
         n = n + 1
         reflections(n) = .xray_data.reflections(i)
      end

      ! Set new reflections
      .xray_data.reflections = reflections

   end

!   merge_equivalents ::: leaky, PURE
!   ! This routine will merge this list of equivalents into a single reflections
!   ! with a particular sigma value allocated with it. WARNING: it assumes that
!   ! there are a sufficient number of equivalents so that the sigma value can be
!   ! calculated by the standard formula for the standard deviation.
!      self :: INOUT
!
!   ENSURE(.xray_data.allocated,"no diffraction data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!
!      list :: VEC{EVEC{INT}}@
!      reflections :: VEC{REFLECTION}@
!      n_unique,n_refl,n,i :: INT
!
!      n_refl = .xray_data.reflections.dim
!
!      .make_list_of_equivalents(list,n_unique)
!
!      ! Define set of new reflections
!      reflections.create(n_unique)
!      n = 0
!      do i = 1,n_refl
!
!         if (any(list(i)[:]<i)) cycle
!
!         n = n + 1
!
!         reflections(n) = .xray_data.reflections(i)
!         reflections(n).set_F_exp(.xray_data.reflections(list(i)[:]).F_exp.mean)
!         reflections(n).set_F_sigma(.xray_data.reflections(list(i)[:]).F_sigma.mean)
!
!      end
!
!      ! Set new reflections
!      .xray_data.reflections = reflections
!
!      ! Clean up
!      list.destroy
!
!   end

!   remove_equivalents ::: leaky, PURE
!   ! If there are any equivalent reflections keep only the one that
!   ! occurs first in the list.
!      self :: INOUT
!
!      list :: VEC{INT}@
!      n_unique :: INT
!
!      .make_list_of_equivalents_v2(list,n_unique)
!      .remove_equivalents(list,n_unique)
!      list.destroy
!
!   end

!   merge_ordered_equivalents ::: leaky, PURE
!   ! This routine will merge apartially ordered list of equivalents
!   ! into a single reflections with a particular sigma value
!   ! allocated with it.
!   ! WARNING: it assumes that there are a sufficient number of
!   ! equivalents so that the sigma value can be calculated by the
!   ! standard formula for the standard deviation.
!      self :: INOUT
!
!   ENSURE(.xray_data.allocated,"no diffraction data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!
!      list :: VEC{EVEC{INT}}@
!      reflections :: VEC{REFLECTION}@
!      n_unique,n_refl,n,i :: INT
!
!      n_refl = .xray_data.reflections.dim
!
!      .make_list_of_equivalents_ord(list,n_unique)
!
!      ! Define set of new reflections
!      reflections.create(n_unique)
!      n = 0
!      do i = 1,n_refl
!
!         if (list(i)[1]<i) cycle
!
!         n = n + 1
!         reflections(n) = .xray_data.reflections(i)
!         reflections(n).set_F_exp(.xray_data.reflections(list(i)[:]).F_exp.mean)
!         reflections(n).set_F_sigma(.xray_data.reflections(list(i)[:]).F_exp.standard_deviation)
!
!      end
!
!      ! Reset reflections
!      .xray_data.reflections = reflections
!
!      list.destroy
!
!   end

!   make_list_of_equivalents_ord(list,n_unique) ::: leaky, private, PURE
!   ! Make a list of the equivalent reflections. For each reflection i,
!   ! list(i).element gives the list of equivalent reflections. If
!   ! list(i).element has only one element and its index is less than i then we
!   ! know it is an equivalent, and this index is the index of its equivalent.
!      self :: IN
!      list :: VEC{EVEC{INT}}@, OUT
!      n_unique :: INT, OUT
!
!   ENSURE(.xray_data.allocated,"no diffraction data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!
!      i,j,g,n_refl :: INT
!      p,q,r :: VEC{INT}(3)
!      same :: BIN
!
!      n_refl = .xray_data.reflections.dim
!
!      list.create(n_refl)
!      list(1).element.append(1)
!
!      n_unique = 1
!
!      do i = 2,n_refl
!
!         p(1) = .xray_data.reflections(i).h1
!         p(2) = .xray_data.reflections(i).h2
!         p(3) = .xray_data.reflections(i).h3
!         
!         same = FALSE
!         
!         j = i - 1
!         main: do g = 1,.spacegroup.n_seitz
!            q(1) = .xray_data.reflections(j).h1
!            q(2) = .xray_data.reflections(j).h2
!            q(3) = .xray_data.reflections(j).h3
!            r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
!            same = p.same_as(r) OR p.same_as(-r)
!            if (NOT same) cycle
!            exit main
!         end do main
!         
!         if (same) then
!            list(j).element.append(i)
!            list(i).element.append(j)
!          ! stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
!         else
!            n_unique = n_unique + 1
!            list(i).element.append(i)
!         end
!
!      end
!
!   end

!   make_list_of_Bijvoet_classes ::: leaky, private
!   ! Make a list of the bijvoet classes. For each reflection i,
!   ! list(1:2)[i][j] gives the list of bijvoet equivalent 
!   ! reflections. Class one has determinant 1 for the Miller 
!   ! indices, class 2 has determinant -1. 
!      self :: IN
!
!   ENSURE(.xray_data.allocated,"no diffraction data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!
!    ! list :: VEC{EVEC{EVEC{INT}}}@
!      n_refl,np,nm :: INT
!      i, j, g, sgn :: INT
!      signp,signm,skip :: VEC{BIN}@
!      listp,listm :: VEC{EVEC{INT}}@
!      hi,hj,hg :: VEC{INT}(3)
!      same :: BIN
!
!      n_refl = .xray_data.reflections.dim
!
!      ! Bijvoet pairs
!      signp.create(n_refl)
!      signm.create(n_refl)
!       skip.create(n_refl)
!
!      ! Sort into the two classes
!      np = 0
!      nm = 0
!      signp = FALSE
!      signm = FALSE
!      skip  = FALSE
!      do i = 1,n_refl
!         hi = .xray_data.reflections(i).miller_indices
!         where (hi==0) hi = 1
!         sgn = sign(1,product(hi))
!         if (sgn==1) then; signp(i) = TRUE
!         else;             signm(i) = TRUE
!         end
!      end
!
!      np = count(signp)
!      nm = count(signm)
!      if (np+nm/=n_refl) then
!         stdout.text("Two classes do not exhaust reflections!")
!         stdout.show("np     = ",np)
!         stdout.show("nm     = ",nm)
!         stdout.show("n_refl = ",n_refl)
!         DIE("Two classes do not exhaust reflections!")
!      end
!
!      ! Do +ve sign class first
!      skip = FALSE
!      listp.create(np)
!      np = 0
!      do i = 1,n_refl
!
!         if (skip(i)) cycle
!         if (signm(i)) cycle
!
!         ! Include reflection itself
!         np = np + 1
!         listp(np).element.append(i)
!        
!         do j = 2,n_refl
!
!            if (skip(j)) cycle
!            if (signm(j)) cycle
!
!            do g = 1,.spacegroup.n_seitz
!           
!               hj = .xray_data.reflections(j).miller_indices
!               hg = int(matmul(hj,.spacegroup.seitz(1:3,1:3,g)),kind=INT_KIND)
!           
!               ! Equivalent class j-Bijvoet refln? 
!               ! By symop "g"
!               same = hi.same_as(hg)
!               if (same) then
!                  listp(np).element.append(j)
!                  skip(j) = TRUE
!                  exit
!               end
!            end
!         end
!      end
!    ! listp.shrink(np)
!
!      stdout.text("List of +ve Bijovoet pairs")
!      do i = 1,np
!         stdout.show("i = ",i)
!         stdout.put(listp(i).element,by_column=TRUE)
!      end
!
!      ! Do -ve sign class first
!      skip = FALSE
!      listm.create(nm)
!      nm = 0
!      do i = 1,n_refl
!
!         if (skip(i)) cycle
!         if (signp(i)) cycle
!
!         ! Include reflection itself
!         nm = nm + 1
!         listm(nm).element.append(i)
!        
!         do j = 2,n_refl
!
!            if (skip(j)) cycle
!            if (signp(j)) cycle
!
!            do g = 1,.spacegroup.n_seitz
!           
!               hj = .xray_data.reflections(j).miller_indices
!               hg = int(matmul(hj,.spacegroup.seitz(1:3,1:3,g)),kind=INT_KIND)
!           
!               ! Equivalent class j-Bijvoet refln? 
!               ! By symop "g"
!               same = hi.same_as(hg)
!               if (same) then
!                  listm(nm).element.append(j)
!                  skip(j) = TRUE
!                  exit
!               end
!            end
!         end
!      end
!    ! listm.shrink(nm)
!
!      stdout.text("List of -ve Bijovoet pairs")
!      do i = 1,nm
!         stdout.show("i = ",i)
!         stdout.put(listm(i).element,by_column=TRUE)
!      end
!
!      ! Move the answers in
!    ! list.create(2)
!    ! call move_alloc(listp,list(1).element)
!    ! call move_alloc(listm,list(2).element)
!
!   end

!   is_Friedel_unmerged result (res)  ::: PURE
!   ! Returns TRUE if the list of reflections is Friedel unmerged.
!   ! *Every* reflection must have matching Friedel pair.
!      self :: IN
!      res :: BIN
!
!   ENSURE(.xray_data.allocated,"no diffraction data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!
!      res = .xray_data.reflections.is_Friedel_unmerged
!
!   end

!   expand_unique_reflections ::: leaky
!   ! This routine will expand a unique list of reflections into a
!   ! complete redundant list of reflections.
!      self :: INOUT
!
!   ENSURE(.xray_data.allocated,"no diffraction data")
!   ENSURE(.xray_data.reflections.allocated,"no reflection data")
!
!      list :: VEC{EVEC{INT}}@
!      reflections :: VEC{REFLECTION}*
!      n_unique,n_refl,n_max,n,i,j,g :: INT
!      p,q,r :: VEC{INT}(3)
!      same :: BIN
!
!      ! Store the number of reflections
!      n_refl = .xray_data.reflections.dim
!
!      ! Make the list of equivalents, to detect any repetitions
!      .make_list_of_equivalents(list,n_unique,show=TRUE)
!      DIE_IF(n_unique/=n_refl,"the list of reflections is not unique")
!      list.destroy
!
!      ! Create the maximum possible list of total reflections
!      n_max = n_refl*.spacegroup.n_seitz
!      reflections.create(n_refl*.spacegroup.n_seitz)
!
!      ! Loop over remaining reflections
!      n = 0
!      do i = 1,n_refl
!
!        p = .xray_data.reflections(i).Miller_indices
!
!        ! Apply symmetry to this relflection
!        do g = 1,.spacegroup.n_seitz
!           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),p),kind=INT_KIND)
!
!           ! Is it the same as another in the list?
!           same = FALSE
!           do j = 1,n-1
!              q = reflections(j).Miller_indices
!              same = q.same_as(r)
!              if (same) exit
!           end
!           if (NOT same) then
!              n = n + 1
!              DIE_IF(n>n_max,"more than expected number of reflections")
!              reflections(n) = .xray_data.reflections(i)
!              reflections(n).set_hkl(r)
!           end
!        end
!      end
!      reflections.shrink(n)
!      .xray_data.reflections.destroy
!      .xray_data.reflections => reflections
!   end


!  =============================
!  Wrappered reflection routines
!  =============================

   F2_exp_scaled_corrected result (res)
   ! The experimental structure factors squares, F_exp, on an absolute
   ! scale, and corrected for dispersion (if any).
   ! Method follows XD (2015) manual p. 45.
   ! See also Ibers & Hamilton (1964) ACta Cryst. 17 p781.
      self :: IN
      res :: VEC{REAL}(.xray_data.reflections.dim)

   ENSURE(.xray_data_exists, "no diffraction data")

      res = .F_exp_scaled_corrected
      res = res*res

   end

!   F_exp result (res) ::: PURE
!   ! The experimental structure factors
!      self :: IN
!      res :: VEC{REAL}(.xray_data.reflections.dim)
!
!   ENSURE(.xray_data_exists, "no diffraction data")
!
!      res = .xray_data.reflections(:).F_exp
!
!   end

   F_exp_scaled_corrected result (res) ::: PURE
   ! The experimental structure factors F_exp on an absolute scale,
   ! and corrected for dispersion (if any).
   ! Method follows XD (2015) manual p. 45.
   ! See also Ibers & Hamilton (1964) Acta Cryst. 17 p781.
      self :: IN
      res :: VEC{REAL}(.xray_data.reflections.dim)

   ENSURE(.xray_data_exists, "no diffraction data")

      Fc :: VEC{CPX}@

      if (.xray_data.add_dispersion_to_F_calc) then

         ! Get dispersion correction
         Fc.create(.xray_data.reflections.dim)
         .add_dispersion_correction(Fc)
        
         ! Get complex F_exp on absolute scale & remove dispersion
         Fc = .xray_data.INQ:F_exp_on_absolute_scale - abs(Fc)

         ! Get corrected F_exp
         res = abs(Fc)

         ! Clean
         Fc.destroy

      else

         ! Get F_exp on absolute scale
         res = .xray_data.INQ:F_exp_on_absolute_scale

      end

   end

   xyz_asymmetric_unit_geometry result (res) ::: PURE
   ! Return the asymmetric unit geometry in cartesian coordinates.
      self :: IN
      res :: MAT{REAL}(3,.n_asymmetric_unit_atoms)

   ENSURE(.asymmetric_unit_geometry.allocated,"no asymmetric unit")

      res = matmul(.unit_cell.direct_mx,.asymmetric_unit_geometry)

   end

!  =================
!  Structure factors
!  =================

   make_F_predicted(sf_n)
   ! Make and set the predicted structure factors, F_pred, from
   ! "sf_n", the unique *fragment* atom structure factors for the
   ! symmetry-generated related k points
      self :: INOUT
      sf_n :: MAT{CPX}, IN

   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      ! Make F_predicted, F_calc & derivatives
      .:set_F_calc_from(sf_n)

      ! Optimise scale, extinction & set chi2(F)
      .xray_data.SET:make_F_predicted
        

   end

   make_F_predicted(prune)
   ! Make and set the predicted structure factors, F_pred, reading the
   ! temperature independent aspherical atomic form factors from disk.
      self :: INOUT
      prune :: BIN, optional, IN

   ENSURE(.xray_data.allocated,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      ! Make F_predicted, F_calc & derivatives
      .:set_F_calc_from(prune) ! NOT PURE

      ! Optimise scale, extinction & set chi2(F)
      .xray_data.SET:make_F_predicted

   end

   set_F_calc_from(sf_n,prune)
   ! Set the predicted structure factors, F_pred, from "sf_n", the
   ! unique *fragment* atom structure factors for the
   ! symmetry-generated related k points
      self :: INOUT
      sf_n :: MAT{CPX}, IN
      prune :: BIN, optional, IN

   ENSURE(.xray_data.allocated,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}@
      do_prune,has_zeros,show :: BIN

      do_prune = FALSE
      if (present(prune)) do_prune = prune

      Fc.create(.xray_data.reflections.dim)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc(Fc,sf_n)

      ! Set the calculated SF's
      has_zeros = any(abs(Fc)<=.xray_data.F_calc_cutoff)
      .xray_data.reflections.set_F_calc(Fc)

      Fc.destroy

      if (do_prune AND has_zeros) then
         WARN("zero or small F_calc's are being pruned")
         show = .xray_data.show_rejects
         .xray_data.SET:set_show_rejects(TRUE)
         .xray_data.SET:prune_zero_F_calcs
         .xray_data.SET:set_show_rejects(show)
      end

   end

   set_F_calc_from(prune)
   ! Set the predicted structure factors, F_pred, reading the
   ! temperature independent structure factors from disk.
      self :: INOUT
      prune :: BIN, optional, IN

   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made, "no fragment info")

      Fc :: VEC{CPX}@
      do_prune,has_zeros,show :: BIN

      do_prune = FALSE
      if (present(prune)) do_prune = prune

      Fc.create(.xray_data.reflections.dim)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc(Fc)

      ! Set the calculated SF's
      has_zeros = any(abs(Fc) <= .xray_data.F_calc_cutoff)
      .xray_data.reflections.set_F_calc(Fc)
      
      Fc.destroy

      if (do_prune AND has_zeros) then
         WARN("zero or small F_calc's are being pruned")
         show = .xray_data.show_rejects
         .xray_data.SET:set_show_rejects(TRUE)
         .xray_data.SET:prune_zero_F_calcs
         .xray_data.SET:set_show_rejects(show)
      end


   end

   make_F_calc(Fc,sf_n)
   ! Make the calculated structure factors "Fc", where "sf_n" are
   ! the unique *fragment* atom structure factors for the symmetry
   ! generated related k points
      self :: INOUT
      Fc :: VEC{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(Fc.dim==.xray_data.reflections.dim, "wrong size, Fc")
   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_e :: VEC{CPX}@
      n_k :: INT

      n_k = .n_unique_SF_k_pts

      ! Symmetry-generated T-indepedent structure factors
      sf_e.create(n_k)

      ! Make them
      .make_unique_sf(sf_e,sf_n)

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      .make_F_calc_from(sf_e,Fc)

      sf_e.destroy

   end

   make_F_calc(Fc)
   ! Make the calculated structure factors "Fc", where "sf_n" are
   ! the unique *fragment* atom structure factors for the symmetry
   ! generated related k points
      self :: INOUT
      Fc :: VEC{CPX}, OUT

   ENSURE(Fc.dim==.xray_data.reflections.dim, "wrong size, Fc")
   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_e :: VEC{CPX}@
      n_k :: INT

      n_k = .n_unique_SF_k_pts

      ! Symmetry-generated T-indepedent structure factors
      sf_e.create(n_k)

      ! Make them
      .make_unique_sf(sf_e)

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      .make_F_calc_from(sf_e,Fc)

      sf_e.destroy

   end


   make_F_predicted_from(sf_e)
   ! Make and set the predicted structure factors, F_pred, from
   ! "sf_e", the aspherical temperature-independent form factors for
   ! every symmetry-generated structure factor.
      self :: INOUT
      sf_e :: VEC{CPX}, IN

   ENSURE(sf_e.dim1==.n_unique_SF_k_pts, "wrong size, sf_e")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}@

      Fc.create(.xray_data.reflections.dim)

      ! Make the calculated SF's
      .make_F_calc_from(sf_e,Fc)

      ! Set the calculated SF's
      .xray_data.reflections.set_F_calc(Fc)

      Fc.destroy

      ! Optimise scale, extinction & set chi2(F)
      .xray_data.SET:make_F_predicted

   end

   set_F_calc_from(sf_e)
   ! Set the predicted structure factors, F_pred, from "sf_e", the
   ! aspherical temperature-independent form factors for every
   ! symmetry-generated structure factor.
      self :: INOUT
      sf_e :: VEC{CPX}, IN

   ENSURE(sf_e.dim1==.n_unique_SF_k_pts, "wrong size, sf_e")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}@

      Fc.create(.xray_data.reflections.dim)
      .make_F_calc_from(sf_e,Fc)
      Fc.destroy

   end

   make_F_calc_from(sf_e,Fc)
   ! Make and set the predicted structure factors, F_pred, from
   ! "sf_e", the aspherical temperature-independent form factors for
   ! every symmetry-generated structure factor.
   ! NOTE: This method was first described by Rollet (1970) in
   !       "Crystallographic Computing", ed. F.R. Ahmed, p. 167-84.
      self :: INOUT
      sf_e :: VEC{CPX}, IN
      Fc :: VEC{CPX}, OUT

   ENSURE(sf_e.dim1==.n_unique_SF_k_pts, "wrong size, sf_e")
   ENSURE(.fragment_info_made,"no fragment info")

      Fa :: VEC{CPX}@

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      .spacegroup.sum_unique_sf(Fc,sf_e,.xray_data.reflections)

      ! Include dispersion?
      if (.xray_data.INQ:correct_dispersion) then

         ! Get dispersion correction
         Fa.create(.xray_data.reflections.dim)
         .get_dispersion_correction(Fa)
         .xray_data.reflections.set_F_disp(Fa)

         ! Add dispersion into Fc
         Fc = Fc + Fa

         Fa.destroy

      end

      ! Set the calculated SF's
    ! has_zeros = any(abs(Fc)<=.xray_data.F_calc_cutoff)
    ! WARN_IF(has_zeros,"there are zero or small F_calc's; do you need to prune them?")
      .xray_data.reflections.set_F_calc(Fc)

   end


   make_F_calc_derivs(dFc,sf_n)
   ! Make "dFc", the derivatives of the calculated structure factors
   ! with respect to positional and ADP parameters, using "sf_n", the
   ! temperature-independent structure factors. Also set the
   ! calculated and prediected structure factors.
      self :: INOUT
      dFc :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(dFc.dim1==.xray_data.reflections.dim, "dFc: wrong dim1")
   ENSURE(dFc.dim2==.asymmetric_unit_atom.no_of_pADPs, "dFc: wrong dim2")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_d :: MAT{CPX}@
      sf_e :: VEC{CPX}@
      n_k,n_p :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the symmetry-generated structure factors and their
      ! derivatives including ADPs but no dispersion.
      .make_unique_sf_derivs(sf_e,sf_d,sf_n)

      ! Make and set F_pred with scale & extinction.
      .xray_data.reflections.reset_F_corr_to_F_exp ! We fit to F_corr
      .make_F_predicted_from(sf_e)            ! Always includes dispersion
      sf_e.destroy

      ! Remove dispersion from F_calc, and F_exp to make F_corr?
      ! WARNING: this is untested & fails
      if (.xray_data.remove_dispersion_from_F_exp) then
         .xray_data.reflections.remove_anom_from_F_exp(.xray_data.scale_factor)
         .xray_data.reflections.remove_anom_from_F_calc
         .xray_data.SET:make_F_predicted(update_n_param=FALSE) ! new scale
      end

      ! Sum the symmetry-generated SF's to get
      ! the derivative structure factors dFc
      .spacegroup.sum_unique_sf_derivs(dFc,sf_d,.xray_data.reflections)
      sf_d.destroy

      ! Add derivative of anomalous contribution to |SF|, dFc
      ! Only if F_calc has anomalous dispersion added into it.
      if (.xray_data.add_dispersion_to_F_calc) then
         .add_D_dispersion_correction(dFc)
      end

   end

   make_F_calc_derivs(dFc)
   ! Make "dFc", the derivatives of the calculated structure factors
   ! with respect to positional and ADP parameters, reading
   ! temperature-independent structure factors from disk. Also set the
   ! calculated and prediected structure factors.
      self :: INOUT
      dFc :: MAT{CPX}, OUT

   ENSURE(dFc.dim1==.xray_data.reflections.dim, "dFc: wrong dim1")
   ENSURE(dFc.dim2==.asymmetric_unit_atom.no_of_pADPs, "dFc: wrong dim2")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_d :: MAT{CPX}@
      sf_e :: VEC{CPX}@
      n_k,n_p :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the symmetry-generated structure factors and their
      ! derivatives including ADPs but no dispersion.
      .make_unique_sf_derivs(sf_e,sf_d) ! processor 1 stops here

      ! Make and set F_pred with scale & extinction.
      .xray_data.reflections.reset_F_corr_to_F_exp ! We fit to F_corr
      .make_F_predicted_from(sf_e)            ! Always includes dispersion
      sf_e.destroy

      ! Remove dispersion from F_calc, and F_exp to make F_corr?
      if (.xray_data.remove_dispersion_from_F_exp) then
         .xray_data.reflections.remove_anom_from_F_exp(.xray_data.scale_factor)
         .xray_data.reflections.remove_anom_from_F_calc
         .xray_data.SET:make_F_predicted(update_n_param=FALSE) ! new scale
      end

      ! Sum the symmetry-generated SF's to get
      ! the derivative structure factors dFc
      .spacegroup.sum_unique_sf_derivs(dFc,sf_d,.xray_data.reflections)
      sf_d.destroy

      ! Add derivative of anomalous contribution to |SF|, dFc
      ! Only if F_calc has anomalous dispersion added into it.
      if (.xray_data.add_dispersion_to_F_calc) then
         .add_D_dispersion_correction(dFc)
      end

   end


   make_F_calc_derivs_for_atom(a,dFc,sf_n)
   ! Make "dFc", the derivatives of the calculated structure factors
   ! with respect to positional and ADP parameters for asymmetric unit
   ! atom "a", using "sf_n", the temperature-independent structure
   ! factors. 
      self :: INOUT
      a :: INT, IN
      dFc :: MAT{CPX}, OUT
      sf_n :: VEC{CPX}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(dFc.dim1==.xray_data.reflections.dim, "dFc: wrong dim1")
   ENSURE(dFc.dim2==.asymmetric_unit_atom(a).no_of_pADPs, "dFc: wrong dim2")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_d :: MAT{CPX}@
      sf_e :: VEC{CPX}@
      n_k,n_p :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom(a).no_of_pADPs

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the symmetry-generated structure factors and their
      ! derivatives including ADPs but no dispersion.
      .make_unique_sf_derivs_for_atom(a,sf_e,sf_d,sf_n)

      ! Sum the symmetry-generated SF's to get
      ! the derivative structure factors dFc
      .spacegroup.sum_unique_sf_derivs(dFc,sf_d,.xray_data.reflections)
      sf_d.destroy

      ! Add derivative of anomalous contribution to |SF|, dFc
      ! Only if F_calc has anomalous dispersion added into it.
      if (.xray_data.add_dispersion_to_F_calc) then
         .add_D_dispersion_correction_for_atom(a,dFc)
      end

   end

!  ============================
!  Structure refinement methods
!  ============================

   LS_structure_fit(output,results) ::: leaky
   ! Least-squares fit the the positions and ADPs of the unique
   ! fragment atoms so that the structure factors obtained from the
   ! static *aspherical* *atomic* form factor, read from disk, match
   ! the experimental structure factors. The structure factors are for
   ! all symmetry genetrated structure factors, and only for the
   ! *unique* .fragment atom's which correspond to but are not
   ! necessarily the same as the .asymmetric_unit_atom's.
   !
   ! NOTE: this routine does only one cycle of fitting with the
   !       current density matrix i.e. this is a "rigid atom fit".
   !
   ! NOTE: It's tricky exactly which atom's pADPs are used to do the
   !       refinement:
   !
   ! * Structure factors are only for *unique* fragment atoms since
   !   the QM wavefunction refers to the fragment_atoms.
   !
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to these unique
   !   fragment atom positions and ADPs) but these parameters and
   !   shifts are later transformed back into asymmetric unit.
      self :: INOUT
      output,results :: BIN, IN

   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made,                 "no fragment info")

      dF :: MAT{REAL}@

      ! Create refinement arrays & initialize (leaky)
      ! - asymmetric atom and fragment atom pADPs are set.
      .initialize_fit_data

      ! Place asym atom position/ADPs in vector .xray_data.X_fit
      ! - asymmetric_unit_atom keeps the pADPs
      .asymmetric_unit_atom.put_pADP_vector_to(.xray_data.X_fit)

      ! If refining, store a copy of the pADPs in .xray_data.X_ref
      if (.xray_data.refine_structure) .xray_data.X_ref = .xray_data.X_fit

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header.
      if (output) then
         .put_fit_header_info
      end

      ! Begin rigid-atom fit loop
      do

         ! Set asym atom positions/ADPs from param vector
       ! .asymmetric_unit_atom.set_pADP_vector_to(.xray_data.X_fit)

         ! Get unique *fragment* atom shifts in .xray_data.dX ...
         .get_parameter_shifts ! .data

         ! Change/store unique frag atom -> asym atom shifts
         ! Change/store the covariance matrix too.
         .set_asym_from_ufrag_shifts ! .xray_data.dX now for asym atoms
         .set_asym_from_ufrag_cov_mx

         ! Stop symmetry breaking
         ! NOTE: we should apply this to the gradient *not*
         ! the shift to make sure the shift maintains symmetry
         .stabilize_asym_atom_shifts

         ! Store old asym-atom parameter vector.
         ! Add shift dA to get new .xray_data.X_fit
         .xray_data.SET:update_fit_parameters
         .asymmetric_unit_atom.set_pADP_vector_to(.xray_data.X_fit)

         ! Set the fit errors e.g. max(dX/esd)
         ! Copy them to the asymmetric unit atoms.
         .update_fit_esds
         .asymmetric_unit_atom.set_pADP_errors_to(.xray_data.covariance_mx,.xray_data.refine_H_U_iso)

         ! Set ALL fragment_atom positions/ADPs from asym atoms HERE
         ! >>>fragment_atom must be the same as molecule.atom
         dF.create(3,.n_fragment_atoms)
         .set_frag_from_asym_pADPs(dF)

         ! Update structure factors, the unique (rigid) frag atom SF's.
         ! Use the frag atom position shifts "dF".
         .shift_update_sf_n(dF)
         dF.destroy

         ! Put the iteration results
         if (output) then
            .xray_data.PUT:put_fit_table_body
         end

         ! Finished?
         .xray_data.SET:update_fit_info
         if (.xray_data.fit_finished) exit

         ! Prune?
         if (.xray_data.INQ:is_F_calc_prunable) then
            .xray_data.SET:prune_reflections
         end

      end


      ! Table footer
      if (output) then
         .xray_data.fit_table.put_footer
      end

      ! Set the fragment covariances from cov matrix
      .set_fragment_esds

      ! Final results
      if (results) then
         .put_fit_results
      end

      ! Print out bond length, angle, torsion tables with errors
      if (output) then
         .put_bond_info_with_errors
      end

      ! Finally: remake .asymmetric_unit_atom/unit_cell geometry from
      ! .fragment_atom, which *must* be assigned since it must point
      ! to molecule.atom
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_source = "tonto-ls-structure-fit"
      .update_fragment_info(.fragment_atom)

   end

   LS_structure_fit(sf_n,output,results) ::: leaky
   ! Least-squares fit the the positions and ADPs of the unique
   ! fragment atoms so that the structure factors obtained from the
   ! static *aspherical* *atomic* form factor, in "sf_n", match the
   ! experimental structure factors. The structure factors are for all
   ! symmetry genetrated structure factors, and only for the *unique*
   ! .fragment atom's which correspond to but are not necessarily the
   ! same as the .asymmetric_unit_atom's.
   !
   ! NOTE: this routine does only one cycle of fitting with the
   !       current density matrix i.e. this is a "rigid atom fit".
   !
   ! NOTE: It's tricky exactly which atom's pADPs are used to do the
   !       refinement:
   !
   ! * Structure factors are calculated only for *unique* fragment
   !   atoms since the QM wavefunction refers to the fragment_atoms.
   !   cf. the description of "sf_n" above.
   !
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to these unique
   !   fragment atom positions and ADPs) but these parameters and
   !   shifts are later transformed back into asymmetric unit.
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT
      output,results :: BIN, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made,                 "no fragment info")

      dF :: MAT{REAL}@

      ! Create refinement arrays & initialize (leaky)
      ! - asymmetric atom and fragment atom pADPs are set.
      .initialize_fit_data

      ! Place asym atom position/ADPs in vector .xray_data.X_fit
      ! - asymmetric_unit_atom keeps the pADPs
      ! - unique frag atoms are *refined* cf. sf_n
      .asymmetric_unit_atom.put_pADP_vector_to(.xray_data.X_fit)

      ! If refining, store a copy of the pADPs in .xray_data.X_ref
      if (.xray_data.refine_structure) .xray_data.X_ref = .xray_data.X_fit

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header.
      if (output) then
         .put_fit_header_info
      end

      ! Begin rigid-atom fit loop
      do

         ! Set asym atom positions/ADPs from param vector
       ! .asymmetric_unit_atom.set_pADP_vector_to(.xray_data.X_fit)

         ! Get unique *fragment* atom shifts in .xray_data.dX ...
         .get_parameter_shifts(sf_n) ! .data

         ! Change/store unique frag atom -> asym atom shifts
         ! Change/store the covariance matrix too.
         .set_asym_from_ufrag_shifts ! .xray_data.dX now for asym atoms
         .set_asym_from_ufrag_cov_mx

         ! Stop symmetry breaking
         ! NOTE: we should apply this to the gradient *not*
         ! the shift to make sure the shift maintains symmetry
         .stabilize_asym_atom_shifts

         ! Store old asym-atom parameter vector.
         ! Add shift dA to get new .xray_data.X_fit
         .xray_data.SET:update_fit_parameters
         .asymmetric_unit_atom.set_pADP_vector_to(.xray_data.X_fit)

         ! Set the fit errors e.g. max(dX/esd)
         ! Copy them to the asymmetric unit atoms.
         .update_fit_esds
         .asymmetric_unit_atom.set_pADP_errors_to(.xray_data.covariance_mx,.xray_data.refine_H_U_iso)

         ! Set ALL fragment_atom positions/ADPs from asym atoms HERE
         ! >>>fragment_atom must be the same as molecule.atom
         dF.create(3,.n_fragment_atoms)
         .set_frag_from_asym_pADPs(dF)

         ! Update "sf_n", the unique (rigid) frag atom SF's.
         ! Use the frag atom position shifts "dF".
         .shift_update_sf_n(sf_n,dF)
         dF.destroy

         ! Put the iteration results
         if (output) then
            .xray_data.PUT:put_fit_table_body
         end

         ! Finished?
         .xray_data.SET:update_fit_info
         if (.xray_data.fit_finished) exit

      end 

      ! Table footer
      if (output) then
         .xray_data.fit_table.put_footer
      end

      ! Set the fragment covariances from asymm cov matrix
      ! If yopu want errors to be right *during* fit cycles
      ! you must call this inside the above loop!
      .set_fragment_esds

      ! Final results
      if (results) then
         .put_fit_results
      end

      ! Print out bond length, angle, torsion tables with errors
      if (output) then
         .put_bond_info_with_errors
      end

      ! Finally: remake .asymmetric_unit_atom/unit_cell geometry from
      ! .fragment_atom, which *must* be assigned since it must point
      ! to molecule.atom
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_source = "tonto-ls-structure-fit"
      .update_fragment_info(.fragment_atom)

   end

!  Refinement initialization

   initialize_fit_data ::: leaky
   ! Initialise a rigid-atom fit
      self :: INOUT

   ENSURE(.xray_data.allocated, "no diffraction data")
   ENSURE(.fragment_info_made,"no fragment info")

      labels :: VEC{STR}@
      f,a, n_p,n_f :: INT

      ! Create space for asymmetric unit atom pADPs (leaky)
      .asymmetric_unit_atom.reset_pADPs_and_errors( &
         .xray_data.refine_3rd_order_for_atom, &
         .xray_data.refine_4th_order_for_atom)

      ! Create space for the fragment_atom pADPs (leaky)
      do f = 1,.n_fragment_atoms
         a = .asym_atom_for_frag_atom(f)
         n_p = .asymmetric_unit_atom(a).no_of_pADPs
         .fragment_atom(f).reset_pADPs_and_errors(n_p)
      end

      ! Set fragment_atom pADPs from asymmetric unit atom pADPs
      .set_frag_from_asym_pADPs

      ! Set the no. of parameters
      n_p = .asymmetric_unit_atom.no_of_pADPs
      n_f = .fragment_atom.no_of_pADPs

      ! Create refinement arrays & initialize (leaky)
      labels = .asymmetric_unit_atom.tag_pADP_labels
      .xray_data.SET:initialize_fit_data(n_p,n_f,labels)

   end

   initialize_refinement_data ::: leaky
   ! Initialise a full refinement
      self :: INOUT

   ENSURE(.xray_data.allocated, "no diffraction data")

      labels :: VEC{STR}@
      n_p :: INT

      ! Create space for parameters (leaky)
      .asymmetric_unit_atom.reset_pADPs_and_errors( &
         .xray_data.refine_3rd_order_for_atom, &
         .xray_data.refine_4th_order_for_atom)

      ! Set the no. of parameters
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Create refinement arrays & initialize (leaky)
      labels = .asymmetric_unit_atom.tag_pADP_labels
      .xray_data.SET:initialize_refinement_data(n_p,labels)

   end

   get_parameter_shifts(sf_n)
   ! Get the param shifts -- either F or F2
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT

   ENSURE(.xray_data.allocated, "no data")

      if(.xray_data.refine_F) then;  .get_parameter_shifts_F(sf_n)
    ! else;                          .get_parameter_shifts_I(sf_n)
      end

   end

   get_parameter_shifts
   ! Get the param shifts -- either F or F2
      self :: INOUT

   ENSURE(.xray_data.allocated,"no data")

      if(.xray_data.refine_F) then;  .get_parameter_shifts_F
    ! else;                          .get_parameter_shifts_I
      end

   end

!  Refinement: shifts and SF update

   get_parameter_shifts_F(sf_n) ::: leaky, private
   ! Get the *asymmetric* atom shifts in ".xray_data.dX" by solving the
   ! normal equations, where "sf_n", the unique *fragment* atom
   ! structure factors for the symmetry generated k points
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made, "no fragment info")

      dFc :: MAT{CPX}@
      dFa  :: MAT{REAL}@
      n_k,n_p :: INT

      ! Constants
      n_k = sf_n.dim1
      n_p = .asymmetric_unit_atom.no_of_pADPs

      dFa.create(.xray_data.reflections.dim,n_p)
      dFc.create(.xray_data.reflections.dim,n_p)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc_derivs(dFc,sf_n)

      ! Get the derivative absolute SF's, F_abs = |F_calc|
      .xray_data.INQ:d_F_abs_dX(dFa,dFc)
      dFc.destroy

      ! Get the unique atom shifts, dX (leaky)
      .xray_data.SET:solve_normal_equations(dFa)

      dFa.destroy

   end

   get_parameter_shifts_F ::: leaky, private
   ! Get the *asymmetric* atom shifts in ".xray_data.dX" by solving the
   ! normal equations. Structure factors are read from disk.
      self :: INOUT

   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.fragment_info_made, "no fragment info")

      dFc :: MAT{CPX}@
      dFa  :: MAT{REAL}@
      n_k,n_p,n_r :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom.no_of_pADPs
      n_r = .xray_data.reflections.dim

      dFa.create(n_r,n_p)
      dFc.create(n_r,n_p)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc_derivs(dFc)

      ! Get the derivative absolute SF's, F_abs = |F_calc|
      .xray_data.INQ:d_F_abs_dX(dFa,dFc)
      dFc.destroy

      ! Get the unique atom shifts, dX (leaky)
      .xray_data.SET:solve_normal_equations(dFa)

      dFa.destroy

   end

   get_dispersion_correction(Fa) ::: PURE
   ! Get the anomalous dispersion correction in "Fa" for the set of
   ! symmetry-unique atoms - do not add the contribution into anything.
   ! 1/2/18 
      self :: IN
      Fa :: VEC{CPX}, OUT

   ENSURE(.xray_data.allocated, "no diffraction data!")

      Fu :: VEC{CPX}@
      k_pts :: MAT{REAL}@
      n_k, u,f :: INT
      rf :: REAL

      n_k = .n_symop_generated_SF_k_pts

      k_pts.create(n_k,3)
      Fu.create(n_k)

      ! The full list of symmetry-generated k points
      .xray_data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      Fu = ZERO
      do u = 1,.n_unique_frag_atoms
         f  = .unique_frag_atom(u)
         rf = .frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         .fragment_atom(f).add_dispersion(Fu,k_pts,rf)
      end

      ! Add together symmetry contributions from Fu into Fa
      .spacegroup.get_full_sd(Fa,Fu,.xray_data.reflections)

   end

   add_dispersion_correction(Fc) ::: PURE
   ! Add the anomalous dispersion correction in "Fc" for the set of
   ! symmetry-unique atoms.
   ! 1/2/18 
   ! Anomalous dispersion checked for the YQ28 (harmonic) IAM refined
   ! job but modified to remove refinement and calculate a molecular
   ! density with STO-3G basis, and by comparing to structure factors
   ! from the version below which was previously checked against XD:
   !    Version: 18.01.31 v. daf061c
   !    Platform: Linux-4.13.0-32-generic
   !    Build-date: 2018-01-31 14:35
      self :: IN
      Fc :: VEC{CPX}, INOUT

   ENSURE(.xray_data.allocated, "no diffraction data!")

      Fu :: VEC{CPX}@
      k_pts :: MAT{REAL}@
      n_k, u,f :: INT
      rf :: REAL

      n_k = .n_symop_generated_SF_k_pts

      k_pts.create(n_k,3)
      Fu.create(n_k)

      ! The full list of symmetry-generated k points
      .xray_data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      Fu = ZERO
      do u = 1,.n_unique_frag_atoms
         f  = .unique_frag_atom(u)
         rf = .frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         .fragment_atom(f).add_dispersion(Fu,k_pts,rf)
      end

      ! Add together symmetry contributions
      .spacegroup.add_full_sd(Fc,Fu,.xray_data.reflections)

   end


   add_D_dispersion_correction(dFc) ::: PURE
   ! Add the derivative anomalous dispersion correction in "dFc" for
   ! wrt all paameters. This routine sums over all atoms in the unit
   ! cell --- it does not take advantage of inversion symmetry.
      self :: IN
      dFc :: MAT{CPX}, INOUT

   ENSURE(.xray_data.allocated, "no diffraction data!")

      dFa,dFb :: MAT{CPX}@
      k_pts :: MAT{REAL}@
      n_k,n_p, u,f,base :: INT
      rf :: REAL

      ! Size of symmetry generated k points
      n_k = .n_symop_generated_SF_k_pts
      k_pts.create(n_k,3)

      ! Size of anamalous Jacobian
      n_p = .asymmetric_unit_atom.no_of_pADPs
      dFa.create(n_k,n_p)
      dFb.create(.xray_data.reflections.dim,n_p)

      ! The full list of symmetry-generated k points
      .xray_data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      dFa = ZERO

      do u = 1,.n_unique_frag_atoms
         f  = .unique_frag_atom(u)
         rf = .frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)
         .fragment_atom(f).add_derivative_dispn(dFa,base,k_pts,rf)
      end

      ! Add together symmetry contributions
      dFb = ZERO
      .spacegroup.add_full_sf_derivs_d(dFb,dFa,.xray_data.reflections)

      dFc = dFc + dFb

      ! Clean
      dFb.destroy
      dFa.destroy
      k_pts.destroy

   end

   add_D_dispersion_correction_for_atom(a,dFc) ::: PURE
   ! Add the derivative anomalous dispersion correction in "dFc" for
   ! wrt the parameters on asymmetric unit atom "a". This routine sums
   ! over all atoms in the unit cell --- it does not take advantage of
   ! inversion symmetry.
      self :: IN
      a :: INT, IN
      dFc :: MAT{CPX}, INOUT

   ENSURE(.xray_data.allocated, "no diffraction data!")

      dFa,dFb :: MAT{CPX}@
      k_pts :: MAT{REAL}@
      n_k,n_p, f,base :: INT
      rf :: REAL

      ! Size of symmetry generated k points
      n_k = .n_symop_generated_SF_k_pts
      k_pts.create(n_k,3)

      ! Size of anamalous Jacobian
      n_p = .asymmetric_unit_atom(a).no_of_pADPs
      dFa.create(n_k,n_p)
      dFb.create(.xray_data.reflections.dim,n_p)

      ! The full list of symmetry-generated k points
      .xray_data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      dFa = ZERO

      ! Sum over unit cell atoms
      f  = .unique_frag_atom(a)
      rf = .frag_atom_sym_factor(f)
      if (NOT rf.is_zero) then
         base = 0
         .fragment_atom(f).add_derivative_dispn(dFa,base,k_pts,rf)
      end

      ! Add together symmetry contributions
      dFb = ZERO
      .spacegroup.add_full_sf_derivs_d(dFb,dFa,.xray_data.reflections)

      dFc = dFc + dFb

      ! Clean
      dFb.destroy
      dFa.destroy
      k_pts.destroy

   end


   shift_update_sf_n(sf_n,dF) ::: private, PURE
   ! Update the unique *fragment* atom structure factors "sf_n" with
   ! the frag atom positional shifts (after stabilization) in "dF"
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT
      dF   :: MAT{REAL}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(dF.dim1==3,                          "dF: wrong dim1")
   ENSURE(dF.dim2==.n_fragment_atoms,          "dF: wrong dim2")

      d1,d2,d3, k1,k2,k3, kr  :: REAL
      n_k, u,f, k :: INT
      k_pt :: MAT{REAL}@

      ! Get the # of k points
      n_k = .n_unique_SF_k_pts

      ! Make k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Loop over unique *frag* atoms
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)

         ! Get the shift
         d1 = dF(1,f)
         d2 = dF(2,f)
         d3 = dF(3,f)

         ! Update sf_u
         do k = 1,n_k
            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)
            kr = k1*d1 + k2*d2 + k3*d3
            sf_n(k,u) = sf_n(k,u) * cmplx(cos(kr),sin(kr),kind=CPX_KIND)
         end

      end

      ! Clean
      k_pt.destroy

   end

   shift_update_sf_n(dF)
   ! Update the unique *fragment* atom structure factors "sf_n" with
   ! the frag atom positional shifts (after stabilization) in "dF"
      self :: INOUT
      dF   :: MAT{REAL}, IN

   ENSURE(.xray_data.allocated, "no diffraction data!")
   ENSURE(dF.dim1==3, "dF: wrong dim1")
   ENSURE(dF.dim2==.n_fragment_atoms, "dF: wrong dim2")

      d1,d2,d3, k1,k2,k3, kr  :: REAL
      n_k, u,f, k :: INT
      sf_u :: VEC{CPX}@
      k_pt :: MAT{REAL}@
      arch :: ARCHIVE*

      ! Get the # of k points
      n_k = .n_unique_SF_k_pts

      ! Space for temp-indepedent aspherical SFs
      sf_u.create(n_k)

      ! Make k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Loop over unique *frag* atoms
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)

         ! Get the shift
         d1 = dF(1,f)
         d2 = dF(2,f)
         d3 = dF(3,f)

         ! Read stored SFS
         arch.create(trim(.fragment_atom(f).tag)//"-SFs")
         if (.xray_data.use_text_SFs) arch.set_format("ascii")
       ! arch.parallel_read(sf_u)
         arch.read(sf_u) ! NOT PURE
         arch.destroy

         ! Update sf_u
         do k = 1,n_k
            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)
            kr = k1*d1 + k2*d2 + k3*d3
            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr),kind=CPX_KIND)
         end

         ! Write out updated SFs
         arch.create(trim(.fragment_atom(f).tag)//"-SFs")
         if (.xray_data.use_text_SFs) arch.set_format("ascii")
         arch.parallel_write(sf_u)
         arch.destroy

      end

      ! Clean
      k_pt.destroy
      sf_u.destroy

   end

   set_fragment_esds  ::: PURE
   ! Set *all* the errors in the .fragment_atom positions/ADPs
      self :: INOUT
      .set_fragment_esds(.fragment_atom)
   end

   set_fragment_esds(fragment_atom) ::: PURE
   ! Set *all* the errors in the .fragment_atom positions/ADPs
      self :: INOUT
      fragment_atom :: VEC{ATOM}, INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.xray_data.allocated, "no data")
   ENSURE(.xray_data.fragment_covariance_mx.allocated,"no data.fragment_covariance_mx")
   ENSURE(.fragment_atom.dim==fragment_atom.dim,"wrong dim, fragment_atom")

      ! Get the fragment covariances
      .set_frag_from_asym_cov_mx

      ! Set the errors
      fragment_atom.set_pADP_errors_to( &
         .xray_data.fragment_covariance_mx, &
         .xray_data.refine_H_U_iso)

   end

!  Refinement: unique frag <-> asym frag parameters

   set_frag_from_asym_pADPs(dF) ::: PURE
   ! Set *all* .fragment_atom pADPs from the .asymmetric_unit_atom pADPs.
   ! If "dF" present, the shift in each frag atom position is returned.
      self :: INOUT
      dF :: MAT{REAL}, optional, OUT

   ENSURE(.fragment_info_made,"no fragment info")

      f,a,s :: INT
      seitz :: MAT3{REAL}@
      CM :: MAT{REAL}(3,3)
      shift :: VEC{REAL}(3)

      ! Symmetry operators & cell matrix
      seitz = .xyz_seitz_matrices

      ! Cell matrix
      CM = .unit_cell.direct_mx

      ! Loop on *all* fragment atom's
      ! Set the .fragment_atom positions/ADP's
      ! from the .asymmetric_unit_atom's
      do f = 1,.n_fragment_atoms

         ! Links between the atom indices & symop s
         a = .asym_atom_for_frag_atom(f)
         s = .asym_symop_for_frag_atom(f)

         ! Store original position
         if (present(dF)) dF(:,f) = -.fragment_atom(f).position

         ! Set frag atom pADPs
         .fragment_atom(f).set_pADP_vector_to(.asymmetric_unit_atom(a).pADP_vector)

         ! Now transform frag atom pADPs with symop
         .fragment_atom(f).transform_pADP_vector_with(seitz(:,:,s))

         ! Add any fragment shift to (cartesian)  position
         shift.to_product_of(CM,.asym_shift_for_frag_atom(:,f))
         shift = .fragment_atom(f).position + shift
         .fragment_atom(f).set_position(shift)

         ! Store shift
         if (present(dF)) dF(:,f) = dF(:,f) + .fragment_atom(f).position

      end

      ! Clean
      seitz.destroy

   end

   set_asym_from_ufrag_shifts ::: PURE
   ! From "dX", the unique .fragment_atom shifts in positions and
   ! ADP's, return the *asymmetric* atom shifts in positions and
   ! ADP's; place the shifts in the same "dX" parameter vector.
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom")
   ENSURE(.xray_data.allocated,"no data")
   ENSURE(.xray_data.dX.allocated,"no data.dX")

      u,f,a,s, n, ub,uf,ul, ab,af,al :: INT
      dA :: VEC{REAL}@
      seitz :: MAT3{REAL}@
      X_atom :: ATOM

      ! Get symops
      seitz = .transposed_xyz_seitz_matrices

      ! Asym atom shift vector
      dA.create(.xray_data.dX.dim)

      ! Base for ufrag atoms
      ub = 0

      ! Loop over unique frag atoms
      ! Order of asym atoms is the same.
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)
         a = .asym_atom_for_frag_atom(f)
         s = .asym_symop_for_frag_atom(f)

         ! No of pADPs & a-base
         n  = .asymmetric_unit_atom(a).no_of_pADPs
         ab = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a)

         ! Block limits
         af = ab + 1
         al = ab + n
         uf = ub + 1
         ul = ub + n

         ! Put ufrag shifts at position f1 in "X_atom" (leaky)
         X_atom.pADP_vector.create(n)
         X_atom.set_pADP_vector_to(.xray_data.dX(uf:ul))

         ! Change ufrag atom shifts -> asym atom shifts
         X_atom.transform_pADP_vector_with(seitz(:,:,s))

         ! Store asym shifts in position a0 for asym atom "a"
         X_atom.put_pADP_vector_to(dA(af:al))

         ! Clean
         X_atom.destroy_ptr_part

         ! Increment u-base
         ub = ub + n

      end

      ! Replace .dX
      .xray_data.dX = dA

      ! Clean
      dA.destroy
      seitz.destroy

   end

   stabilize_asym_atom_shifts ::: PURE
   ! Stabilize ".dX", parameter vector for asymmetric atom *shifts*
   ! in positions and ADP's, removing any symmetry breaking.
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.xray_data.allocated,"no data")
   ENSURE(.xray_data.dX.allocated,"no data.dX")

      a, n,ab,af,al, n_stab,s,t :: INT
      stabilizer :: VEC{INT}@
      seitz :: MAT3{REAL}@
      X_atom,Y_atom :: ATOM
      fac :: REAL

      ! Get symops
      seitz = .xyz_seitz_matrices

      ! Base for asym atoms
      ab = 0

      ! Symmetrize the asym atom positions/ADP's
      ! We can use the asym atom stabilizers for the ufrag
      do a = 1,.n_asymmetric_unit_atoms

         ! List of stabilizer symops
         stabilizer = .asym_atom_stabilizer(a).element

         ! Any stabilizers?
         n_stab = stabilizer.dim
         if (n_stab<=1) cycle

         ! Block limits
         n  = .asymmetric_unit_atom(a).no_of_pADPs
         af = ab + 1
         al = ab + n

         ! Set pADPs (leaky)
         X_atom.pADP_vector.create(n)
         Y_atom.pADP_vector.create(n)
         X_atom.set_pADP_vector_to(.xray_data.dX(af:al))
         Y_atom.set_pADP_vector_to(.xray_data.dX(af:al))

         ! Apply symops and accumulate
         do s = 2,n_stab
            t = stabilizer(s)
            X_atom.transform_pADP_vector_with(seitz(:,:,t))
            Y_atom.set_pADP_vector_to(Y_atom.pADP_vector+X_atom.pADP_vector)
         end

         ! Stabilize
         fac = ONE/REALIFY(n_stab)
         Y_atom.set_pADP_vector_to(fac*Y_atom.pADP_vector)

         ! Put back shifts
         Y_atom.put_pADP_vector_to(.xray_data.dX(af:al))

         ! Clean
         Y_atom.destroy_ptr_part
         X_atom.destroy_ptr_part

         ! Increment a-base
         ab = ab + n

      end

      ! Clean
      seitz.destroy

   end

   update_fit_esds ::: PURE
   ! Set the fit errors e.g. maximum shift on esd and the positional
   ! and ADP errors for the asym unit.
      self :: INOUT

   ENSURE(.xray_data.allocated,"no data")

      val :: STR

      ! Reset the esd's and maximum shifts on esd
      .xray_data.SET:update_fit_esds

      ! Set asym atom par label value corresponding to the max shift/esd
      if (.xray_data.max_shift_on_esd_ind/=DIFFRACTION_DATA_INDMAX_INIT) then
         val = .asymmetric_unit_atom.tag_pADP_label(.xray_data.max_shift_on_esd_ind)
         .xray_data.SET:set_max_shift_on_esd_par(val)
      else
         .xray_data.SET:set_max_shift_on_esd_par("--")
      end

   end

   update_refinement_ESDs ::: PURE
   ! Update the refinement errors e.g. maximum shift on esd and the
   ! positional and ADP errors for the asym unit.
      self :: INOUT

   ENSURE(.xray_data.allocated,"no data")

      val :: STR

      ! Set the refinement errors
      .xray_data.SET:update_refinement_ESDs

      ! Set asym atom max refinement shift on easd par value
      if (.xray_data.max_refshift_on_esd_ind/=DIFFRACTION_DATA_INDMAX_INIT) then
         val = .asymmetric_unit_atom.tag_pADP_label(.xray_data.max_refshift_on_esd_ind)
         .xray_data.SET:set_max_refshift_on_esd_par(val)
      else
         .xray_data.SET:set_max_refshift_on_esd_par("--")
      end

   end

!  Refinement: transform covariance matrix

   set_asym_from_ufrag_cov_mx ::: PURE
   ! Set the asymmetric atom covariance matrix from the unique
   ! fragment atom covariance_mx (produced from refinement)
   ! Note: .covariance_mx is over-written.
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom")
   ENSURE(.xray_data.allocated,"no data")
   ENSURE(.xray_data.covariance_mx.allocated,"no covariance matrix")

      u1,f1,a1,s1,n1, u1b,u1f,u1l, a1b,a1f,a1l :: INT
      u2,f2,a2,s2,n2, u2b,u2f,u2l, a2b,a2f,a2l :: INT
      dim  :: INT
      T1,T2 :: MAT{REAL}@
      acov  :: MAT{REAL}@
      seitz :: MAT3{REAL}@

      ! *Inverse* symops (see below)
      seitz = .transposed_xyz_seitz_matrices

      ! Create asym atom frag covariance matrix
      dim = .xray_data.covariance_mx.dim1
      acov.create(dim,dim)
      acov = ZERO

      ! Transform the unique .fragment_atom to the asym unit covariances
      u1b = 0
      do u1 = 1,.n_unique_frag_atoms

         ! s1 maps: asym atom a1 -> frag atom f1, but use transpose
         f1 = .unique_frag_atom(u1)
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1)

         ! Block limits
         n1  = .asymmetric_unit_atom(a1).no_of_pADPs
         a1b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a1)
         a1f = a1b +  1
         a1l = a1b + n1
         u1f = u1b +  1
         u1l = u1b + n1

         ! Transformation matrix
         T1.create(n1,n1)
         GAUSSIAN_DATA:symmetric_tensor_product_mx(T1,seitz(:,:,s1))

         u2b = 0
         do u2 = 1,.n_unique_frag_atoms

            ! s2 maps: asym atom a2 -> frag atom f2, but use transpose
            f2 = .unique_frag_atom(u2)
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)

            ! Block limits
            n2  = .asymmetric_unit_atom(a2).no_of_pADPs
            a2b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a2)
            a2f = a2b +  1
            a2l = a2b + n2
            u2f = u2b +  1
            u2l = u2b + n2

            ! Transform covariances: ufrag -> asym atom
            T2.create(n2,n2)
            GAUSSIAN_DATA:symmetric_tensor_product_mx(T2,seitz(:,:,s2))
            .xray_data.covariance_mx(u1f:u1l,u2f:u2l).back_transform_to( &
               acov(a1f:a1l,a2f:a2l),T1,T2)
            T2.destroy

            ! Increment
            u2b = u2b + n2

         end

         ! Increment
         u1b = u1b + n1

      end

      ! Overwrite ufrag-atom cov mx with asym-atom cov mx
      .xray_data.covariance_mx = acov ! <<<<<<

      ! Clean
      acov.destroy
      seitz.destroy

   end

   set_frag_from_asym_cov_mx ::: PURE
   ! Set the total frag atom covariance matrix from the asym atom
   ! covariance matrix. Seems correct 12/9/11
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.xray_data.allocated,"no data")
   ENSURE(.xray_data.covariance_mx.allocated,"no covariance matrix")
   ENSURE(.xray_data.fragment_covariance_mx.allocated,"no fragment covariance matrix")

      f1,a1,s1,n1, f1b,f1f,f1l, a1b,a1f,a1l :: INT
      f2,a2,s2,n2, f2b,f2f,f2l, a2b,a2f,a2l :: INT
      T1,T2 :: MAT{REAL}@
      seitz :: MAT3{REAL}@

      ! Symops
      seitz = .xyz_seitz_matrices

      ! Copy the asymmetric atom covariances to *all* .fragment_atom ADPs
      f1b = 0
      do f1 = 1,.n_fragment_atoms

         ! s1 maps: asym atom a1 -> frag atom f1
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1)

         ! Block limits
         n1  = .asymmetric_unit_atom(a1).no_of_pADPs
         a1b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a1)
         a1f = a1b +  1
         a1l = a1b + n1
         f1f = f1b +  1
         f1l = f1b + n1

         ! Transformation matrix
         T1.create(n1,n1)
         GAUSSIAN_DATA:symmetric_tensor_product_mx(T1,seitz(:,:,s1))

         f2b = 0
         do f2 = 1,.n_fragment_atoms

            ! s2 maps: asym atom a2 -> frag atom f2
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)

            ! Block limits
            n2  = .asymmetric_unit_atom(a2).no_of_pADPs
            a2b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a2)
            a2f = a2b +  1
            a2l = a2b + n2
            f2f = f2b +  1
            f2l = f2b + n2

            ! Transformation matrix
            T2.create(n2,n2)
            GAUSSIAN_DATA:symmetric_tensor_product_mx(T2,seitz(:,:,s2))
            .xray_data.covariance_mx(a1f:a1l,a2f:a2l).back_transform_to( &
               .xray_data.fragment_covariance_mx(f1f:f1l,f2f:f2l),T1,T2)
            T2.destroy

            f2b = f2b + n2

         end

         ! Clean, increment
         T1.destroy
         f1b = f1b + n1

      end

      ! Clean
      seitz.destroy

   end

!  Structure factors only

   make_unique_sf(sf_e,sf_n) ::: private, PURE
   ! Make the *temperature dependent* unique structure factors and
   ! their derivatives "sf_e" corresponding to the unique_SF_k_pts
   ! from the temperature independent SFs, "sf_n" and atom parameters
   ! in .fragment_atom.
      self :: IN
      sf_e :: VEC{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.xray_data.allocated, "no x-ray reflection data")

      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k_pt :: MAT{REAL}@
      kv :: VEC{REAL}(3)
      c2,c3,c4 :: REAL
      n_k,f,u,k :: INT
      do_ADP3s,do_ADP4s :: BIN
      II,sf2,sf3,sf4 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = sf_n.dim1

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Initialize
      sf_e = ZERO

      ! Make the structure factors
      parallel do u = 1,.n_unique_frag_atoms

         ! Fragment atom "F"
         f = .unique_frag_atom(u)

         ! Doing anharmomic terms?
         do_ADP4s = .fragment_atom(f).has_only_ADP4s_and_errors
         do_ADP3s = .fragment_atom(f).has_only_ADP3s_and_errors

       ! stdout.text("pADPs:")
       ! stdout.put(.fragment_atom(f).pADP_vector)

         ! Quartic terms (if any)
         if (do_ADP4s) then

            .fragment_atom(f).put_ADP2_vector_to(adp2)
            .fragment_atom(f).put_ADP3_vector_to(adp3)
            .fragment_atom(f).put_ADP4_vector_to(adp4)

            do k = 1,n_k
               kv = k_pt(k,:)

               ! ADP2s & ADP4s
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER
         
               ! Quartic term only
               sf2 = sf_n(k,u) * exp(-c2)
               sf4 = sf2 * (ONE - II*c3 + c4)

               ! SF contribution
               sf_e(k) = sf_e(k) + sf4
            end

         else if (do_ADP3s) then

            .fragment_atom(f).put_ADP2_vector_to(adp2)
            .fragment_atom(f).put_ADP3_vector_to(adp3)

            do k = 1,n_k
               kv = k_pt(k,:)

               ! ADP2s & ADP4s
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
         
               ! Quartic term only
               sf2 = sf_n(k,u) * exp(-c2)
               sf3 = sf2 * (ONE - II*c3)

               ! SF contribution
               sf_e(k) = sf_e(k) + sf3
            end
         
         else

            ! ADP2s
            .fragment_atom(f).put_ADP2_vector_to(adp2)
   
            do k = 1,n_k
               kv = k_pt(k,:)
   
               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
             
               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sf2 = sf_n(k,u) * exp(-c2)
   
               ! SF contribution
               sf_e(k) = sf_e(k) + sf2
            end

         end 

      end ! loop over unqique/asym atoms "u"

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
      end

      ! Clean
      k_pt.destroy

   end

   make_unique_sf(sf_e) ::: private
   ! Make the *temperature dependent* unique structure factors and
   ! their derivatives "sf_e" corresponding to the unique_SF_k_pts
   ! and from atom parameters in .fragment_atom.
   ! NOTE: this version reads SFs from the disk
      self :: IN
      sf_e :: VEC{CPX}, OUT

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts, "sf_e, wrong dim")
   ENSURE(.xray_data.allocated, "no x-ray reflection data")

      sf_u :: VEC{CPX}@
      arch :: ARCHIVE*
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k_pt :: MAT{REAL}@
      kv :: VEC{REAL}(3)
      c2,c3,c4 :: REAL
      n_k,f,u,k :: INT
      do_ADP3s,do_ADP4s :: BIN
      II,sf2,sf3,sf4 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! K times thermal tensors
      sf_u.create(n_k)

      ! Initialize
      sf_e = ZERO

      ! Make the structure factors
      parallel do u = 1,.n_unique_frag_atoms

         ! Fragment atom "F"
         f = .unique_frag_atom(u)

         ! Doing anharmomic terms?
         do_ADP4s = .fragment_atom(f).has_only_ADP4s_and_errors
         do_ADP3s = .fragment_atom(f).has_only_ADP3s_and_errors

         ! Read stored SFS
         arch.create(trim(.fragment_atom(f).tag)//"-SFs")
         if (.xray_data.use_text_SFs) arch.set_format("ascii")
         arch.read(sf_u)
         arch.destroy

         ! Quartic terms (if any)
         if (do_ADP4s) then

            .fragment_atom(f).put_ADP2_vector_to(adp2)
            .fragment_atom(f).put_ADP3_vector_to(adp3)
            .fragment_atom(f).put_ADP4_vector_to(adp4)

            do k = 1,n_k
               kv = k_pt(k,:)

               ! ADP2s & ADP4s
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER
         
               ! Quartic term only
               sf2 = sf_u(k) * exp(-c2)
               sf4 = sf2 * (ONE - II*c3 + c4)

               ! SF contribution
               sf_e(k) = sf_e(k) + sf4
            end

         else if (do_ADP3s) then

            .fragment_atom(f).put_ADP2_vector_to(adp2)
            .fragment_atom(f).put_ADP3_vector_to(adp3)

            do k = 1,n_k
               kv = k_pt(k,:)

               ! ADP2s & ADP4s
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
         
               ! Quartic term only
               sf2 = sf_u(k) * exp(-c2)
               sf3 = sf2 * (ONE - II*c3)

               ! SF contribution
               sf_e(k) = sf_e(k) + sf3
            end
         
         else

            ! ADP2s
            .fragment_atom(f).put_ADP2_vector_to(adp2)
   
            do k = 1,n_k
               kv = k_pt(k,:)
   
               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
             
               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sf2 = sf_u(k) * exp(-c2)
   
               ! SF contribution
               sf_e(k) = sf_e(k) + sf2
            end

         end 

      end ! loop over unqique/asym atoms "u"

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
      end

      ! Clean
      sf_u.destroy
      k_pt.destroy

   end

!  SF derivatives 

   make_unique_sf_derivs(sf_e,sf_d,sf_n) ::: private, PURE
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from the given
   ! set of temperature-independent form factors "sf_n", 
   !   - skipping atoms in .refine_nothing_for_atom list, &
   !   - refining U_iso for atoms in .refine_U_iso_for_atom list
   !   - The rest are refined *An*isotropically unless
   !     you specify refine_H_positions or refine_H_ADPs FALSE
   ! Atom parameters are those in .fragment_atom.
      self :: IN
      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts, "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts, "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.asymmetric_unit_atom.no_of_pADPs, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,"sf_n, wrong dim2")
   ENSURE(.xray_data.allocated, "no x-ray reflection data")

      list :: VEC{STR}@
      tags :: VEC{STR}@
      sf_u :: VEC{CPX}@
      kv   :: VEC{REAL}(3)
      k_pt :: MAT{REAL}@
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      zero3 :: REAL
      n_k,f,u,k,base :: INT
      has_skip,has_Uiso,is_H_atom :: BIN
      refine_positions,refine_Uiso :: BIN
      refine_positions_only,refine_ADPs_only :: BIN
      refine_ADPs,refine_ADP4s,refine_ADP3s :: BIN
      II,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      tag :: STR

      ! Is there a nothing list?
      has_skip = .xray_data.refine_nothing_for_atom.allocated
      if (has_skip) then
         tags = .fragment_atom(:).tag
         list = .xray_data.refine_nothing_for_atom
         ENSURE(list.has_all_elements_common_with(tags), "trying to refine nothing for an atom that is not in your list")
      end
      
      ! Are there atoms to be refined isotropically?
      has_Uiso = .xray_data.refine_U_iso_for_atom.allocated
      if (has_Uiso) then
         tags = .fragment_atom(:).tag
         list = .xray_data.refine_U_iso_for_atom
         ENSURE(list.has_all_elements_common_with(tags), "trying to refine an atom isotropically that is not in your list")
      end

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Refine only 4th's?
      zero3 = ONE
      if (.xray_data.refine_4th_order_only) zero3 = ZERO

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         ! Fragment atom
         f = .unique_frag_atom(u)

         ! This atom's label
         tag = .fragment_atom(f).tag

         ! Structure factor, unique frag atom "u"
         sf_u = sf_n(:,u)


         ! Base index for unique frag atom
         !base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)
         base = .fragment_atom.no_of_pADPs_up_to_atom(u,.unique_frag_atom)

         refine_ADPs_only      = .xray_data.refine_ADPs_only
         refine_positions_only = .xray_data.refine_positions_only

         ! Defaults per atom
         if (NOT refine_ADPs_only) then 
            refine_positions = TRUE 
         else
            refine_positions = FALSE
         end

         if (NOT refine_positions_only) then 
            refine_ADPs      = TRUE
         else
            refine_ADPs      = FALSE
         end
         refine_Uiso      = FALSE
         refine_ADP4s     = .fragment_atom(f).has_only_ADP4s_and_errors
         refine_ADP3s     = .fragment_atom(f).has_only_ADP3s_and_errors

         ! Special cases for H atom
         is_H_atom = .fragment_atom(f).atomic_number==1
         if (is_H_atom) then
            refine_positions = .xray_data.refine_H_positions
            refine_ADPs      = .xray_data.refine_H_ADPs
            refine_Uiso      = .xray_data.refine_H_U_iso
         end

         ! Final check to do U_iso this atom?
         if (NOT refine_Uiso) then
         if (has_Uiso) then
         if (any(.xray_data.refine_U_iso_for_atom==tag)) then
            refine_Uiso = TRUE
         end
         end
         end

         ! Skip derivatives for this atom?
         if (has_skip) then
         if (any(.xray_data.refine_nothing_for_atom==tag)) then
            refine_positions = FALSE
            refine_ADPs      = FALSE
         end
         end

         ! Get ADP2s
         .fragment_atom(f).put_ADP2_vector_to(adp2)

         ! Sanity check
         ENSURE(NOT (refine_Uiso AND refine_ADP4s),"can't refine isotropic ADPs & ADP4s for "//trim(tag))
         ENSURE(NOT (refine_Uiso AND refine_ADP3s),"can't refine isotropic ADPs & ADP3s for "//trim(tag))
         ENSURE(adp2.equals(.fragment_atom(f).ADP_tensor),"ADP2 not equal to ADP_tensor")

         ! ADP4's !!!!!!!!!!!!!
         if (refine_ADP4s) then
         !!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)
            .fragment_atom(f).put_ADP4_vector_to(adp4)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               sf1 = sfh * (ONE - II*c3 + c4)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               if (refine_positions) then 
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1
               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf4  = sf1 * QUARTER
                  sf6  = sf1 * SIXTH
                  sf24 = sf1 * SIXTH*QUARTER
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6*zero3
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6*zero3
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6*zero3
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2*zero3
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2*zero3
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2*zero3
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2*zero3
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2*zero3
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2*zero3
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1*zero3
                 
                  ! U4 derivatives
                  sf_d(k,base+20) = k1_k1*k1_k1*sf24
                  sf_d(k,base+21) = k2_k2*k2_k2*sf24
                  sf_d(k,base+22) = k3_k3*k3_k3*sf24
                  sf_d(k,base+23) = k1_k1*k1_k2*sf6
                  sf_d(k,base+24) = k1_k1*k1_k3*sf6
                  sf_d(k,base+25) = k2_k2*k1_k2*sf6
                  sf_d(k,base+26) = k2_k2*k2_k3*sf6
                  sf_d(k,base+27) = k3_k3*k1_k3*sf6
                  sf_d(k,base+28) = k3_k3*k2_k3*sf6
                  sf_d(k,base+29) = k1_k1*k2_k2*sf4
                  sf_d(k,base+30) = k1_k1*k3_k3*sf4
                  sf_d(k,base+31) = k2_k2*k3_k3*sf4
                  sf_d(k,base+32) = k1_k1*k2_k3*sf2
                  sf_d(k,base+33) = k2_k2*k1_k3*sf2
                  sf_d(k,base+34) = k3_k3*k1_k2*sf2

               end

            end

         ! ADP3's !!!!!!!!!!!!!!!!!!
         else if (refine_ADP3s) then
         !!!!!!!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               ! -- 3rd order only.
               sf1 = sfh * (ONE - II*c3)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               !test refine_H_positions Lorraine
               if (refine_positions) then

                  ! Pos derivatives
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1

               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic!)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf6  = sf1 * SIXTH
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1

               end

            end

         ! ADP2's !!!!!!!!!!!!!!
         else ! NO anharmonicity
         !!!!!!!!!!!!!!!!!!!!!!!

            ! This is for isotropic refinement
            if (refine_Uiso) then ! For U_iso 

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF * (k1_k1+k2_k2+k3_k3)
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U_iso derivatives
                     sf_d(k,base+ 4) = -sf2
                     sf_d(k,base+ 5) = -sf2
                     sf_d(k,base+ 6) = -sf2
                     sf_d(k,base+ 7) = ZERO
                     sf_d(k,base+ 8) = ZERO
                     sf_d(k,base+ 9) = ZERO
   
                  end
   
               end

            ! This is *AN*isotropic refinement
            else ! For ADP2s !!!!!!!!!!!!!!!!!

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U2 derivatives
                     sf_d(k,base+ 4) = -k1_k1*sf2
                     sf_d(k,base+ 5) = -k2_k2*sf2
                     sf_d(k,base+ 6) = -k3_k3*sf2
                     sf_d(k,base+ 7) = -k1_k2*sf1
                     sf_d(k,base+ 8) = -k1_k3*sf1
                     sf_d(k,base+ 9) = -k2_k3*sf1
   
                  end
   
               end

            end

         end

      end

      ! Clean
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sf_derivs(sf_e,sf_d) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from the given
   ! set of temperature-independent form factors, on disk.
   !   - skipping atoms in .refine_nothing_for_atom list, &
   !   - refining U_iso for atoms in .refine_U_iso_for_atom list
   !   - The rest are refined *An*isotropically unless
   !     you specify refine_H_positions or refine_H_ADPs FALSE
   ! Atom parameters are those in .fragment_atom.
      self :: IN
      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts, "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts, "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.asymmetric_unit_atom.no_of_pADPs, "sf_d, wrong dim2")
   ENSURE(.xray_data.allocated, "no x-ray reflection data")

      list :: VEC{STR}@
      tags :: VEC{STR}@
      sf_u :: VEC{CPX}@
      kv   :: VEC{REAL}(3)
      k_pt :: MAT{REAL}@
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      zero3 :: REAL
      n_k,f,u,k,base :: INT
      has_skip,has_Uiso,is_H_atom :: BIN
      refine_positions,refine_Uiso :: BIN
      refine_positions_only,refine_ADPs_only :: BIN
      refine_ADPs,refine_ADP4s,refine_ADP3s :: BIN
      II,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      tag :: STR
      arch :: ARCHIVE*

      ! Is there a nothing list?
      has_skip = .xray_data.refine_nothing_for_atom.allocated
      if (has_skip) then
         tags = .fragment_atom(:).tag
         list = .xray_data.refine_nothing_for_atom
         ENSURE(list.has_all_elements_common_with(tags), "trying to refine nothing for an atom that is not in your list")
      end
      
      ! Are there atoms to be refined isotropically?
      has_Uiso = .xray_data.refine_U_iso_for_atom.allocated
      if (has_Uiso) then
         tags = .fragment_atom(:).tag
         list = .xray_data.refine_U_iso_for_atom
         ENSURE(list.has_all_elements_common_with(tags), "trying to refine an atom isotropically that is not in your list")
      end

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Aspherical temperature independent SFs

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Refine only 4th's?
      zero3 = ONE
      if (.xray_data.refine_4th_order_only) zero3 = ZERO

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      do u = 1,.n_unique_frag_atoms

         sf_u.create(n_k)
         
         ! Fragment atom
         f = .unique_frag_atom(u)

         ! This atom's label
         tag = .fragment_atom(f).tag

         ! Read stored SFS !!!!!!!!!!!!
         arch.create(trim(tag)//"-SFs")
         if (.xray_data.use_text_SFs) arch.set_format("ascii")
         arch.read(sf_u)
         arch.destroy
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! Base index for unique frag atom
       ! base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)
         base = .fragment_atom.no_of_pADPs_up_to_atom(u,.unique_frag_atom)

         refine_ADPs_only      = .xray_data.refine_ADPs_only
         refine_positions_only = .xray_data.refine_positions_only

         ! Defaults per atom
         if (NOT refine_ADPs_only) then 
            refine_positions = TRUE 
         else
            refine_positions = FALSE
         end

         if (NOT refine_positions_only) then 
            refine_ADPs      = TRUE
         else
            refine_ADPs      = FALSE
         end
         refine_Uiso      = FALSE
         refine_ADP4s     = .fragment_atom(f).has_only_ADP4s_and_errors
         refine_ADP3s     = .fragment_atom(f).has_only_ADP3s_and_errors

         ! Special cases for H atom
         is_H_atom = .fragment_atom(f).atomic_number==1
         if (is_H_atom) then
            refine_positions = .xray_data.refine_H_positions
            refine_ADPs      = .xray_data.refine_H_ADPs
            refine_Uiso      = .xray_data.refine_H_U_iso
         end

         ! Final check to do U_iso this atom?
         if (NOT refine_Uiso) then
         if (has_Uiso) then
         if (any(.xray_data.refine_U_iso_for_atom==tag)) then
            refine_Uiso = TRUE
         end
         end
         end

         ! Skip derivatives for this atom?
         if (has_skip) then
         if (any(.xray_data.refine_nothing_for_atom==tag)) then
            refine_positions = FALSE
            refine_ADPs      = FALSE
         end
         end

         ! Get ADP2s
         .fragment_atom(f).put_ADP2_vector_to(adp2)

         ! Sanity check
         ENSURE(NOT (refine_Uiso AND refine_ADP4s),"can't refine isotropic ADPs & ADP4s for "//trim(tag))
         ENSURE(NOT (refine_Uiso AND refine_ADP3s),"can't refine isotropic ADPs & ADP3s for "//trim(tag))
         ENSURE(adp2.equals(.fragment_atom(f).ADP_tensor),"ADP2 not equal to ADP_tensor")

         ! ADP4's !!!!!!!!!!!!!
         if (refine_ADP4s) then
         !!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)
            .fragment_atom(f).put_ADP4_vector_to(adp4)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               sf1 = sfh * (ONE - II*c3 + c4)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               if (refine_positions) then 
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1
               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf4  = sf1 * QUARTER
                  sf6  = sf1 * SIXTH
                  sf24 = sf1 * SIXTH*QUARTER
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6*zero3
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6*zero3
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6*zero3
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2*zero3
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2*zero3
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2*zero3
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2*zero3
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2*zero3
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2*zero3
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1*zero3
                 
                  ! U4 derivatives
                  sf_d(k,base+20) = k1_k1*k1_k1*sf24
                  sf_d(k,base+21) = k2_k2*k2_k2*sf24
                  sf_d(k,base+22) = k3_k3*k3_k3*sf24
                  sf_d(k,base+23) = k1_k1*k1_k2*sf6
                  sf_d(k,base+24) = k1_k1*k1_k3*sf6
                  sf_d(k,base+25) = k2_k2*k1_k2*sf6
                  sf_d(k,base+26) = k2_k2*k2_k3*sf6
                  sf_d(k,base+27) = k3_k3*k1_k3*sf6
                  sf_d(k,base+28) = k3_k3*k2_k3*sf6
                  sf_d(k,base+29) = k1_k1*k2_k2*sf4
                  sf_d(k,base+30) = k1_k1*k3_k3*sf4
                  sf_d(k,base+31) = k2_k2*k3_k3*sf4
                  sf_d(k,base+32) = k1_k1*k2_k3*sf2
                  sf_d(k,base+33) = k2_k2*k1_k3*sf2
                  sf_d(k,base+34) = k3_k3*k1_k2*sf2

               end

            end

         ! ADP3's !!!!!!!!!!!!!!!!!!
         else if (refine_ADP3s) then
         !!!!!!!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               ! -- 3rd order only.
               sf1 = sfh * (ONE - II*c3)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               !test refine_H_positions Lorraine
               if (refine_positions) then

                  ! Pos derivatives
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1

               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic!)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf6  = sf1 * SIXTH
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1

               end

            end

         ! ADP2's !!!!!!!!!!!!!!
         else ! NO anharmonicity
         !!!!!!!!!!!!!!!!!!!!!!!

            ! This is for isotropic refinement
            if (refine_Uiso) then ! For U_iso 

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF * (k1_k1+k2_k2+k3_k3)
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U_iso derivatives
                     sf_d(k,base+ 4) = -sf2
                     sf_d(k,base+ 5) = -sf2
                     sf_d(k,base+ 6) = -sf2
                     sf_d(k,base+ 7) = ZERO
                     sf_d(k,base+ 8) = ZERO
                     sf_d(k,base+ 9) = ZERO
   
                  end
   
               end

            ! This is *AN*isotropic refinement
            else ! For ADP2s !!!!!!!!!!!!!!!!!

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U2 derivatives
                     sf_d(k,base+ 4) = -k1_k1*sf2
                     sf_d(k,base+ 5) = -k2_k2*sf2
                     sf_d(k,base+ 6) = -k3_k3*sf2
                     sf_d(k,base+ 7) = -k1_k2*sf1
                     sf_d(k,base+ 8) = -k1_k3*sf1
                     sf_d(k,base+ 9) = -k2_k3*sf1
   
                  end
   
               end

            end

         end

         sf_u.destroy

      end

      ! Clean
      k_pt.destroy

   end


   make_unique_sf_derivs_for_atom(a,sf_e,sf_d,sf_n) ::: PURE
   ! Make the unique structure factors and their derivatives "sf_e"
   ! for the fragment atom correspondihnbg to asymm unit atom "a".
      self :: IN
      a :: INT, IN
      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: VEC{CPX}, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts, "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts, "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.asymmetric_unit_atom(a).no_of_pADPs, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n, wrong dim1")
   ENSURE(.xray_data.allocated, "no x-ray reflection data")

      kv   :: VEC{REAL}(3)
      k_pt :: MAT{REAL}@
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      n_k,f,k,base :: INT
      do_ADP3s,do_ADP4s :: BIN
      II,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      tag :: STR

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .xray_data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Fragment atom
      f = .unique_frag_atom(a)

      ! This atom's label
      tag = .fragment_atom(f).tag

      ! Base index for unique frag atom
      base = 0

      ! Get ADP2s
      .fragment_atom(f).put_ADP2_vector_to(adp2)

      ! Sanity check
      ENSURE(adp2.equals(.fragment_atom(f).ADP_tensor),"ADP2 not equal to ADP_tensor")

      ! Doing anharmomic terms?
      do_ADP4s = .fragment_atom(f).has_only_ADP4s_and_errors
      do_ADP3s = .fragment_atom(f).has_only_ADP3s_and_errors

      ! ADP4's !!!!!!!!!!!!!
      if (do_ADP4s) then
      !!!!!!!!!!!!!!!!!!!!!!

         ! Get ADP tensors
         .fragment_atom(f).put_ADP3_vector_to(adp3)
         .fragment_atom(f).put_ADP4_vector_to(adp4)

         do k = 1,n_k

            ! Scattering vector
            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)
            kv = [k1,k2,k3]

            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3

            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
            c3 = adp3.contract_with(kv)*SIXTH
            c4 = adp4.contract_with(kv)*SIXTH*QUARTER

            ! Static structure factor x TF
            ! i.e. dynamic structure factor,
            ! in the harmonic approximation
            sfh = sf_n(k) * exp(-c2)

            ! Multiples of *anharmonic* structure factor
            sf1 = sfh * (ONE - II*c3 + c4)
            sf2 = sf1 * HALF

            ! SF contribution (anharmonic!)
            sf_e(k) = sf_e(k) + sf1

            sf_d(k,base+ 1) =  II*k1*sf1
            sf_d(k,base+ 2) =  II*k2*sf1
            sf_d(k,base+ 3) =  II*k3*sf1

            ! U2 derivatives
            sf_d(k,base+ 4) = -k1_k1*sf2
            sf_d(k,base+ 5) = -k2_k2*sf2
            sf_d(k,base+ 6) = -k3_k3*sf2
            sf_d(k,base+ 7) = -k1_k2*sf1
            sf_d(k,base+ 8) = -k1_k3*sf1
            sf_d(k,base+ 9) = -k2_k3*sf1
            
            ! Structure factor (harmonic)
            sf1  = sfh
            
            ! Multiples of *harmonic* sf
            sf2  = sf1 * HALF
            sf4  = sf1 * QUARTER
            sf6  = sf1 * SIXTH
            sf24 = sf1 * SIXTH*QUARTER
            
            ! U3 derivatives
            sf_d(k,base+10) = -II*k1_k1*k1*sf6
            sf_d(k,base+11) = -II*k2_k2*k2*sf6
            sf_d(k,base+12) = -II*k3_k3*k3*sf6
            sf_d(k,base+13) = -II*k1_k1*k2*sf2
            sf_d(k,base+14) = -II*k1_k1*k3*sf2
            sf_d(k,base+15) = -II*k2_k2*k1*sf2
            sf_d(k,base+16) = -II*k2_k2*k3*sf2
            sf_d(k,base+17) = -II*k3_k3*k1*sf2
            sf_d(k,base+18) = -II*k3_k3*k2*sf2
            sf_d(k,base+19) = -II*k1*k2*k3*sf1
            
            ! U4 derivatives
            sf_d(k,base+20) = k1_k1*k1_k1*sf24
            sf_d(k,base+21) = k2_k2*k2_k2*sf24
            sf_d(k,base+22) = k3_k3*k3_k3*sf24
            sf_d(k,base+23) = k1_k1*k1_k2*sf6
            sf_d(k,base+24) = k1_k1*k1_k3*sf6
            sf_d(k,base+25) = k2_k2*k1_k2*sf6
            sf_d(k,base+26) = k2_k2*k2_k3*sf6
            sf_d(k,base+27) = k3_k3*k1_k3*sf6
            sf_d(k,base+28) = k3_k3*k2_k3*sf6
            sf_d(k,base+29) = k1_k1*k2_k2*sf4
            sf_d(k,base+30) = k1_k1*k3_k3*sf4
            sf_d(k,base+31) = k2_k2*k3_k3*sf4
            sf_d(k,base+32) = k1_k1*k2_k3*sf2
            sf_d(k,base+33) = k2_k2*k1_k3*sf2
            sf_d(k,base+34) = k3_k3*k1_k2*sf2

         end

      ! ADP3's !!!!!!!!!!!!!!!!!!
      else if (do_ADP3s) then
      !!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! Get ADP tensors
         .fragment_atom(f).put_ADP3_vector_to(adp3)

         do k = 1,n_k

            ! Scattering vector
            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)
            kv = [k1,k2,k3]

            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3

            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
            c3 = adp3.contract_with(kv)*SIXTH

            ! Static structure factor x TF
            ! i.e. dynamic structure factor,
            ! in the harmonic approximation
            sfh = sf_n(k) * exp(-c2)

            ! Multiples of *anharmonic* structure factor
            ! -- 3rd order only.
            sf1 = sfh * (ONE - II*c3)
            sf2 = sf1 * HALF

            ! SF contribution (anharmonic!)
            sf_e(k) = sf_e(k) + sf1

            ! Pos derivatives
            sf_d(k,base+ 1) =  II*k1*sf1
            sf_d(k,base+ 2) =  II*k2*sf1
            sf_d(k,base+ 3) =  II*k3*sf1

            ! U2 derivatives
            sf_d(k,base+ 4) = -k1_k1*sf2
            sf_d(k,base+ 5) = -k2_k2*sf2
            sf_d(k,base+ 6) = -k3_k3*sf2
            sf_d(k,base+ 7) = -k1_k2*sf1
            sf_d(k,base+ 8) = -k1_k3*sf1
            sf_d(k,base+ 9) = -k2_k3*sf1
            
            ! Structure factor (harmonic!)
            sf1  = sfh
            
            ! Multiples of *harmonic* sf
            sf2  = sf1 * HALF
            sf6  = sf1 * SIXTH
            
            ! U3 derivatives
            sf_d(k,base+10) = -II*k1_k1*k1*sf6
            sf_d(k,base+11) = -II*k2_k2*k2*sf6
            sf_d(k,base+12) = -II*k3_k3*k3*sf6
            sf_d(k,base+13) = -II*k1_k1*k2*sf2
            sf_d(k,base+14) = -II*k1_k1*k3*sf2
            sf_d(k,base+15) = -II*k2_k2*k1*sf2
            sf_d(k,base+16) = -II*k2_k2*k3*sf2
            sf_d(k,base+17) = -II*k3_k3*k1*sf2
            sf_d(k,base+18) = -II*k3_k3*k2*sf2
            sf_d(k,base+19) = -II*k1*k2*k3*sf1

         end

      ! ADP2's !!!!!!!!!!!!!!
      else ! NO anharmonicity
      !!!!!!!!!!!!!!!!!!!!!!!

         do k = 1,n_k
   
            ! Scattering vector
            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)
            kv = [k1,k2,k3]
   
            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3
   
            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
   
            ! Static structure factor x TF
            ! i.e. dynamic structure factor,
            ! in the harmonic approximation
            sfh = sf_n(k) * exp(-c2)
   
            ! Multiples *harmonic* structure factor
            sf1 = sfh
            sf2 = sf1 * HALF
   
            ! SF contribution (harmonic)
            sf_e(k) = sf_e(k) + sf1
   
            ! Pos derivatives
            sf_d(k,base+ 1) =  II*k1*sf1
            sf_d(k,base+ 2) =  II*k2*sf1
            sf_d(k,base+ 3) =  II*k3*sf1
   
            ! U2 derivatives
            sf_d(k,base+ 4) = -k1_k1*sf2
            sf_d(k,base+ 5) = -k2_k2*sf2
            sf_d(k,base+ 6) = -k3_k3*sf2
            sf_d(k,base+ 7) = -k1_k2*sf1
            sf_d(k,base+ 8) = -k1_k3*sf1
            sf_d(k,base+ 9) = -k2_k3*sf1
   
         end

      end

      ! Clean
      k_pt.destroy

   end


!   d_F_abs_dX(res,dFdX)
!   ! Evaluate "res", the derivative of the F_abs = |F_calc| with
!   ! respect to some parameters X (e.g. thermal parameters) given
!   ! "dFdX", the derivatives of the complex structure factors  w.r.t.
!   ! the X parameters.
!      self :: INOUT
!      res :: MAT{REAL}, OUT
!      dFdX :: MAT{CPX}, IN
!
!   ENSURE(.xray_data_exists,"no diffraction data")
!
!      .xray_data.d_F_abs_dX(res,dFdX)
!
!   end

!   d_F_abs_2_dX(res,dFdX)
!   ! Evaluate "res", the derivative of the F_abs with respect to some
!   ! parameters X (e.g. thermal parameters) given "dFdX", the
!   ! derivatives of the complex structure factors  w.r.t. the X
!   ! parameters.
!      res :: MAT{REAL}, OUT
!      dFdX :: MAT{CPX}, IN
!
!   ENSURE(.xray_data_exists,"no diffraction data")
!
!      .xray_data.d_F_abs_2_dX(res,dFdX)
!
!   end

!  Normal equations

!   solve_normal_equations(dFdX) ::: leaky
!   ! Get the ".dX" in the parameters by solving the normal equations,
!   ! given "dFdX", the derivatives of the *absolute* *uscaled*
!   ! structure factors |F_calc| w.r.t. those parameters.
!      self :: INOUT
!      dFdX :: MAT{REAL}, INOUT
!
!   ENSURE(.xray_data_exists,"no diffraction data")
!
!      .xray_data.solve_normal_equations(dFdX)
!
!   end

!  =================
!  Refinement output
!  =================

   put_fit_header ::: public
   ! Put out the fit header
      self :: IN

   ENSURE(.xray_data.allocated, "no diffraction data")

      .put_fit_header_info

   end

   put_fit_header_info ::: private
   ! Put out the fit header
      self :: IN

   ENSURE(.xray_data.allocated, "no diffraction data")

      ! Print header
      DIFFRACTION_DATA.PUT:put_fit_header

      ! Put the fit control switches
      .xray_data.PUT:put_refinement_switches

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Initial parameter values:")
      stdout.flush
      .put_parameters

      ! Put the fit table header
      .xray_data.PUT:put_fit_table_headings

   end

   put_refinement_header_info
   ! Put out the fit header
      self :: IN

   ENSURE(.xray_data.allocated, "no diffraction data")

      ! Print header
      DIFFRACTION_DATA.PUT:put_refinement_header

      ! Put the refinement control switches
      .xray_data.PUT:put_refinement_switches
      
      ! Put the initial parameters
      stdout.flush
      stdout.text("Initial asymmetric unit parameter values:")
      stdout.flush
      .put_parameters
      
      ! Put the refinement header info
      .xray_data.PUT:put_refinement_table_headings

   end

   put_parameters(covariance) ::: private
   ! Write refinement results
      self :: IN
      covariance :: MAT{REAL}, optional, IN

   ENSURE(.xray_data.allocated, "no diffraction data")
   ENSURE(.asymmetric_unit_atom.allocated,"no .asymmetric_unit_atom's")

      n_p :: INT

      ! Put positions and ADPs
      .asymmetric_unit_atom.put_coordinates(no_header=TRUE)
      .asymmetric_unit_atom.put_ADPs(no_header=TRUE,covariance=covariance)
      
      ! Put zero eigenvalue information
      if (.xray_data.show_near_0_eigenvectors) then
      if (.xray_data.fit_finished) then
         n_p = .asymmetric_unit_atom.no_of_pADPs
         .xray_data.PUT:put_near_0_evecs(n_p)
      end
      end

   end

   put_correlations(name)
   ! Put the correlation matrix
      self :: IN
      name :: STR, optional, IN

   ENSURE(.xray_data.allocated, "no diffraction data")
   ENSURE(.xray_data.correlation_mx.allocated,"no data.correlation_mx")
   ENSURE(.asymmetric_unit_atom.allocated,"no .asymmetric_unit_atom's")

      val :: VEC{REAL}@
      row,col,ind :: VEC{INT}@
      labr,labc,dsh :: VEC{STR}@
      table :: VEC{TABLE_COLUMN}@
      min_corr :: REAL
      n_corr :: INT

      ! How many large correlations?
      min_corr = .xray_data.min_correlation
      n_corr   = .xray_data.correlation_mx.number_in_range([min_corr,0.9999d0],TRUE,TRUE)

      ! If no large correlations, return
      if (n_corr<=0) return

      ! Change to a new file
      if (present(name)) stdout.redirect(name)

      stdout.flush
      stdout.text("============================")
      stdout.text("Large parameter correlations")
      stdout.text("============================")
      stdout.flush
      stdout.show("Smallest absolute correlation to show    =",min_corr)
      stdout.show("No. pairs with at least this correlation =",n_corr)

      val.create(n_corr)
      ind.create(n_corr)
      row.create(n_corr)
      col.create(n_corr)
      dsh.create(n_corr)
      dsh = "--"

      ! Get row and column indices
      .xray_data.correlation_mx.get_indices_in_range([min_corr,0.9999d0],row,col,val,TRUE,TRUE)

      ! Construct the row labels
      labr = .asymmetric_unit_atom.tag_pADP_labels(row)
      labc = .asymmetric_unit_atom.tag_pADP_labels(col)

      ! Sort
      val.quick_sort(ind,decreasing_order=TRUE)
      val  = val(ind)
      labr = labr(ind)
      labc = labc(ind)

      ! Set the table
      table.create(4)
      table(1).set_heading("Parameter")
      table(1).set_subhead("1")
      table(1).set_width_from(labr)
      table(1).set_values(labr)

      table(2).set_column_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)
      table(2).set_values(dsh)

      table(3).set_heading("Parameter")
      table(3).set_subhead("2")
      table(3).set_width_from(labc)
      table(3).set_left_justify(TRUE)
      table(3).set_values(labc)

      table(4).set_heading("Correlation")
      table(4).set_subhead("Coefficeint")
      table(4).set_values(val)

      ! Put body
      table.put

      ! Clean
      table.destroy
      labc.destroy; labr.destroy
      dsh.destroy; col.destroy; row.destroy
      ind.destroy; val.destroy

      ! Change back
      if (present(name)) stdout.revert

   end

   put_correlations_in_cif(name)
   ! Put the correlation matrix
      self :: IN
      name :: STR, optional, IN

   ENSURE(.xray_data.allocated, "no diffraction data")
   ENSURE(.xray_data.correlation_mx.allocated,"no data.correlation_mx")
   ENSURE(.asymmetric_unit_atom.allocated,"no .asymmetric_unit_atom's")

      val :: VEC{REAL}@
      row,col,ind :: VEC{INT}@
      labr,labc,dsh :: VEC{STR}@
      table :: VEC{TABLE_COLUMN}@
      min_corr :: REAL
      n_corr :: INT

      ! How many large correlations?
      min_corr = .xray_data.min_correlation
      n_corr   = .xray_data.correlation_mx.number_in_range([min_corr,0.9999d0],TRUE,TRUE)

      ! If no large correlations, return
      if (n_corr<=0) return

      ! Change to a new file
      if (present(name)) stdout.redirect(name)

      stdout.flush
      stdout.text("# ============================")
      stdout.text("# Large parameter correlations")
      stdout.text("# ============================")
      stdout.flush

      ! Loop 
      stdout.flush
      stdout.text("loop_")
      stdout.text(" _geom_correlation_atom_site_label_1")
      stdout.text(" _geom_correlation_param_site_label_1")
      stdout.text(" _geom_correlation_atom_site_label_2")
      stdout.text(" _geom_correlation_param_site_label_2")
      stdout.text(" _geom_correlation_coef")

      val.create(n_corr)
      ind.create(n_corr)
      row.create(n_corr)
      col.create(n_corr)
      dsh.create(n_corr)
      dsh = " "

      ! Get row and column indices
      .xray_data.correlation_mx.get_indices_in_range([min_corr,0.9999d0],row,col,val,TRUE,TRUE)

      ! Construct the row labels
      labr = .asymmetric_unit_atom.tag_pADP_labels(row)
      labc = .asymmetric_unit_atom.tag_pADP_labels(col)

      ! Sort
      val.quick_sort(ind,decreasing_order=TRUE)
      val  = val(ind)
      labr = labr(ind)
      labc = labc(ind)
      
      ! Set the table
      table.create(4)
      table(1).set_left_justify(TRUE)
      table(1).set_width_from(labr)
      table(1).set_values(labr)

      table(2).set_column_spacing(0)
      table(2).set_width(1)
      table(2).set_values(dsh)

      table(3).set_left_justify(TRUE)
      table(3).set_width_from(labc)
      table(3).set_values(labc)

      table(4).set_left_justify(FALSE)
      table(4).set_values(val)

      ! Put body
      table.put_body

      ! Clean
      table.destroy
      labc.destroy; labr.destroy
      dsh.destroy; col.destroy; row.destroy
      ind.destroy; val.destroy

      ! Change back
      if (present(name)) stdout.revert

   end

   put_fit_results
   ! Finalise fit, write results
      self :: IN

   ENSURE(.xray_data.allocated, "no diffraction data")

      ! Iteration footer
      .xray_data.PUT:put_fit_results

      ! Put the parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      stdout.flush
      if (.xray_data.covariance_mx.allocated) then
         .put_parameters(.xray_data.covariance_mx)
      else
         .put_parameters
      end

      ! Worst reflections
      .xray_data.PUT:put_worst_reflections

   end

   put_refinement_results
   ! Finalise refinement, write results
      self :: IN

   ENSURE(.xray_data.allocated, "no diffraction data")

      ! Iteration footer
      .xray_data.PUT:put_refinement_results

      ! Put the final parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      stdout.flush
      if (.xray_data.covariance_mx.allocated) then
         .put_parameters(.xray_data.covariance_mx)
      else
         .put_parameters
      end

      ! Worst reflections
      .xray_data.PUT:put_worst_reflections

   end

   put_bond_info_with_errors
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors in brackets
      self :: IN

   ENSURE(.xray_data.allocated,   "no data")
   ENSURE(.fragment_atom.allocated,"no fragment_atoms")
   ENSURE(.xray_data.fragment_covariance_mx.allocated,"no fragment_covariance_mx")

      cx,cm :: MAT{REAL}@

      ! Get the pos (cx) and pADP (cm) covariance matrices
      cx.create(3*.n_fragment_atoms,3*.n_fragment_atoms)
      CRYSTAL:make_pos_covariance_mx(cx,.fragment_atom,.xray_data.fragment_covariance_mx)
      cm.create(9*.n_fragment_atoms,9*.n_fragment_atoms)
      CRYSTAL:make_pADP2_covariance_mx(cm,.fragment_atom,.xray_data.fragment_covariance_mx)

      ! ADP3s in principal axis frame
      if (.fragment_atom.has_any_ADP3s_and_errors) then
          .fragment_atom.put_ADP3s_in_ADP2_principal_axes(.xray_data.fragment_covariance_mx)
      end

      ! ADP4s in principal axis frame
      if (.fragment_atom.has_any_ADP4s_and_errors) then
          .fragment_atom.put_ADP4s_in_ADP2_principal_axes(.xray_data.fragment_covariance_mx)
      end

      ! Bond length tables with Hirshfeld test
      .fragment_atom.put_bonds_and_Hirshfeld_test(cx,cm)

      ! Bond angle tables
    ! .fragment_atom.put_bond_length_table(cx)
      .fragment_atom.put_bond_angle_table(cx)
      .fragment_atom.put_torsion_angle_table(cx)

      if (.xray_data.show_correlation_mx) then
         stdout.flush
         stdout.text("Covariance matrix:")
         stdout.put(.xray_data.fragment_covariance_mx)
      end

      ! Clean
      cm.destroy
      cx.destroy

   end

   put_CIF_bond_info_tables(atom,covariance) ::: selfless
   ! Put out the CIF bond lengths for an "atom" list with an
   ! allocated "covariance_mx"
      atom :: VEC{ATOM}, IN
      covariance :: MAT{REAL}, IN

      cx :: MAT{REAL}@

      ! Get the pos covariance matrices
      cx.create(3*atom.dim,3*atom.dim)
      CRYSTAL:make_pos_covariance_mx(cx,atom,covariance)

      ! Print out the *CIF* tables with errors
      atom.put_CIF_bond_length_table(cx)
      atom.put_CIF_bond_angle_table(cx)
      atom.put_CIF_bond_torsion_angle_table(cx,parentheses=TRUE)

      cx.destroy

   end

   put_CIF_bond_Hirshfeld_tables(atom,covariance_mx) ::: selfless
   ! Put out the CIF bond lengths for an "atom" list with an
   ! allocated "covariance_mx"
      atom :: VEC{ATOM}, IN
      covariance_mx :: MAT{REAL}, IN
      cx,cm :: MAT{REAL}@

      ! Get the pos (cx) and pADP (cm) covariance matrices
      cx.create(3*atom.dim,3*atom.dim)
      CRYSTAL:make_pos_covariance_mx(cx,atom,covariance_mx)
      cm.create(9*atom.dim,9*atom.dim)
      CRYSTAL:make_pADP2_covariance_mx(cm,atom,covariance_mx)

      ! Print out the *CIF* tables with errors
      atom.put_CIF_bond_Hirshfeld_table(cx,cm)
      atom.put_CIF_bond_angle_table_HBB(cx)
      atom.put_CIF_bond_torsion_angle_table(cx,parentheses=FALSE)

      cm.destroy
      cx.destroy

   end

   make_pos_covariance_mx(cm) ::: PURE
   ! Make the positional covarinace matrix "cm".
      self :: IN
      cm :: MAT{REAL}, OUT

   ENSURE(.xray_data.allocated,   "no data")
   ENSURE(.xray_data.fragment_covariance_mx.allocated,"no fragment_covariance_mx")
   ENSURE(.fragment_atom.allocated,"no fragment_atoms")

      CRYSTAL:make_pos_covariance_mx(cm,.fragment_atom,.xray_data.fragment_covariance_mx)

   end

   make_pos_covariance_mx(cm,atom,covariance) ::: selfless, PURE
   ! Make the positional covarinace matrix "cm".
      self :: IN
      cm :: MAT{REAL}, OUT
      atom :: VEC{ATOM}, IN
      covariance :: MAT{REAL}, IN

   ENSURE(cm.is_square,"cm is not square")
   ENSURE(cm.dim1==3*atom.dim,"cm is not square")

      n_pADPs :: VEC{INT}@
      dim :: INT

      ! Get block dimensions
      dim = atom.dim
      n_pADPs.create(dim)
      atom.put_no_of_pADPs_per_atom_to(n_pADPs)

      ! Get it
      covariance.put_sub_blocks_to(cm,dim=3,block_dims=n_pADPs)

      ! Clean
      n_pADPs.destroy

   end

   make_pADP2_covariance_mx(cm) ::: PURE
   ! Make the pADP2 covarinace matrix "cm".
      self :: IN
      cm :: MAT{REAL}, OUT

   ENSURE(.xray_data.allocated,   "no data")
   ENSURE(.xray_data.fragment_covariance_mx.allocated,"no fragment_covariance_mx")
   ENSURE(.fragment_atom.allocated,"no fragment_atoms")

      CRYSTAL:make_pADP2_covariance_mx(cm,.fragment_atom,.xray_data.fragment_covariance_mx)

   end

   make_pADP2_covariance_mx(cm,atom,covariance) ::: selfless, PURE
   ! Make the pADP2 covarinace matrix "cm".
      cm :: MAT{REAL}, OUT
      atom :: VEC{ATOM}, IN
      covariance :: MAT{REAL}, IN

   ENSURE(cm.is_square,"cm is not square")
   ENSURE(cm.dim1==9*atom.dim,"cm is not square")

      n_pADPs :: VEC{INT}@
      dim :: INT

      ! Get block dimensions
      dim = atom.dim
      n_pADPs.create(dim)
      atom.put_no_of_pADPs_per_atom_to(n_pADPs)

      ! Get it
      covariance.put_sub_blocks_to(cm,dim=9,block_dims=n_pADPs)

      ! Clean
      n_pADPs.destroy

   end

   put_bond_info_with_errors_to
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors with *no* brackets to a file, name read from stdin
      self :: IN

   ENSURE(.xray_data.allocated,   "no data")
   ENSURE(.fragment_atom.allocated,"no fragment_atoms")
   ENSURE(.xray_data.fragment_covariance_mx.allocated,"no fragment_covariance_mx")

      cm :: MAT{REAL}@
      name :: STR
      save,file :: TEXTFILE*

      ! Read the name
      stdin.read(name)

      ! Create the new file
      file.create(trim(name))
      file.open_for("write")

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)
      .make_pos_covariance_mx(cm)

      ! Print out the tables with errors
      save   => TEXTFILE::stdout
      stdout => file
      .fragment_atom.put_bond_length_table(cm,parentheses=FALSE)
      .fragment_atom.put_bond_angle_table(cm,parentheses=FALSE)
      .fragment_atom.put_torsion_angle_table(cm,parentheses=FALSE)
      stdout => save

      ! Clean
      cm.destroy
      file.close
      file.destroy

   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text
      self :: IN

      stdout.dump("CIF_chemical_formula",.CIF_chemical_formula)
      .spacegroup.dump("spacegroup")
      .unit_cell.dump("unit_cell")
      stdout.dump("n_fragment_atoms",.n_fragment_atoms)
      .fragment_atom.dmpa("fragment_atom")
      stdout.dump("destroy_fragment_atom",.destroy_fragment_atom)
      stdout.dmpa("fragment_geometry",.fragment_geometry)
      stdout.dump("fragment_offset",.fragment_offset)
      stdout.dump("asymmetric_unit_source",.asymmetric_unit_source)
      stdout.dump("n_asymmetric_unit_atoms",.n_asymmetric_unit_atoms)
      .asymmetric_unit_atom.dmpa("asymmetric_unit_atom")
      stdout.dmpa("asymmetric_unit_geometry",.asymmetric_unit_geometry)
      stdout.dump("prune_asymmetric_unit",.prune_asymmetric_unit)
      stdout.dump("n_unit_cell_atoms",.n_unit_cell_atoms)
      stdout.dmpa("unit_cell_geometry",.unit_cell_geometry)
      stdout.dmpa("unique_unit_cell_atom",.unique_unit_cell_atom)
    ! stdout.dmpa("unique_uc_atom_offset",.unique_uc_atom_offset)
      stdout.dmpa("is_asym_unit_cell_atom",.is_asym_unit_cell_atom)
      stdout.dump("fragment_info_made",.fragment_info_made)
      stdout.dmpa("asym_atom_for_unit_cell_atom",.asym_atom_for_unit_cell_atom)
      stdout.dmpa("asym_symop_for_unit_cell_atom",.asym_symop_for_unit_cell_atom)
      stdout.dmpa("frag_atom_for_unit_cell_atom",.frag_atom_for_unit_cell_atom)
      stdout.dmpa("unit_cell_atom_for_frag_atom",.unit_cell_atom_for_frag_atom)
      stdout.dmpa("unit_cell_shft_for_frag_atom",.unit_cell_shft_for_frag_atom)
      stdout.dmpa("frag_atom_for_asym_atom",.frag_atom_for_asym_atom)
      stdout.dmpa("asym_atom_for_frag_atom",.asym_atom_for_frag_atom)
      stdout.dmpa("frag_parent_for_cell_atom",.frag_parent_for_cell_atom)
      stdout.dump("n_unique_frag_atoms",.n_unique_frag_atoms)
      stdout.dmpa("unique_frag_atom",.unique_frag_atom)
      stdout.dmpa("unique_atom_for_frag_atom",.unique_atom_for_frag_atom)
      stdout.dmpa("unique_symop_for_frag_atom",.unique_symop_for_frag_atom)
      stdout.dmpa("asym_symop_for_frag_atom",.asym_symop_for_frag_atom)
      stdout.dmpa("asym_shift_for_frag_atom",.asym_shift_for_frag_atom)
      stdout.dump("Z",.Z)
      stdout.dump("use_manual_repetition_factors",.use_manual_repetition_factors)
      stdout.dmpa("repetition_factor",.repetition_factor)
      stdout.dmpa("asym_atom_sym_factor",.asym_atom_sym_factor)
    ! stdout.dmpa("asym_atom_stabilizer",.asym_atom_stabilizer)
    ! stdout.dmpa("unit_cell_connection",.unit_cell_connection)
    ! stdout.dmpa("uc_vdw_connection",.uc_vdw_connection)
      stdout.dmpa("unit_cell_mol_for_atom",.unit_cell_mol_for_atom)
      stdout.dump("n_unit_cell_mols",.n_unit_cell_mols)
      stdout.dump("n_stabilizer_symops",.n_stabilizer_symops)
    ! stdout.dmpa("stabilizer_symop",.stabilizer_symop)
      stdout.dmpa("str",.str)
      stdout.dmpa("ptr",.ptr)
      stdout.dmpa("dtr",.dtr)
      stdout.dmpa("ftr",.ftr)
      stdout.dmpa("gtr",.gtr)
    ! stdout.dump("data_kind",.data_kind)
    ! stdout.dmpa("data",.xray_data)
    ! stdout.dmpa("xray_data",.xray_data)
    ! stdout.dmpa("pnd_data",.pnd_data)
      stdout.dump("r_free_percentage",.r_free_percentage)
    ! stdout.dmpa("xray_r_free_data",.xray_r_free_data)
    ! stdout.dmpa("pnd_r_free_data",.pnd_r_free_data)
      stdout.dump("finalize",.finalize)

      stdout.dump("radius",.radius)
      stdout.dump("atom_density_cutoff",.atom_density_cutoff)
      stdout.dump("generation_method",.generation_method)
      stdout.dump("defragment",.defragment)
      stdout.dump("n_atoms",.n_atoms)
      stdout.dmpa("geometry",.geometry)
      stdout.dump("unit_cell_offset",.unit_cell_offset)
      stdout.dump("h_min",.h_min)
      stdout.dump("h_max",.h_max)
      stdout.dump("n_shift",.n_shift)
      stdout.dmpa("shift",.shift)
      stdout.dmpa("shift_for_atom",.shift_for_atom)
      stdout.dmpa("is_fragment_atom",.is_fragment_atom)
      stdout.dmpa("occupation_list",.occupation_list)

      stdout.dump("n_molecules",.n_molecules)
    ! stdout.dmpa("molecule_for_atom",.molecule_for_atom)
    ! stdout.dmpa("molecule",.molecule)
      stdout.dmpa("molecule_centroid",.molecule_centroid)
      stdout.dmpa("unique_molecule_for",.unique_molecule_for)
      stdout.dmpa("unique_sycode_for",.unique_symcode_for)
    ! stdout.dmpa("atom_connection",.atom_connection)
      stdout.dmpa("unit_cell_atoms_to_suppress",.unit_cell_atoms_to_suppress)

      stdout.dump("cluster_info_made",.cluster_info_made)

   end

   dump(object_name,all) ::: get_from(OBJECT, TYPE?=>CRYSTAL)
   ! Dump object data as text
   end

   dmpa(object_name) ::: get_from(OBJECT, TYPE?=>CRYSTAL)
   ! Dump allocatable object data as text
   end

!  ===========
!  Put methods
!  ===========

   put
   ! Put out the crystal data to file "out"
      self :: INOUT

      .unit_cell.put

      .spacegroup.put
    ! if (NOT tonto.low_verbosity) .put_xyz_seitz_matrices

      if (.asymmetric_unit_geometry.allocated) .put_asymmetric_unit_geometry

      if (tonto.low_verbosity) then
      if (.fragment_geometry.allocated) then
         if (.fragment_geometry.dim>100) return
      end
      end

      if (.fragment_geometry.allocated)        .put_fragment_data
      if (.unit_cell_geometry.allocated)       .put_unit_cell_geometry

    ! if (.unit_cell_connection.allocated)     .put_uc_connection_table
    ! if (.uc_vdw_connection.allocated)        .put_uc_vdw_connection_table

    ! .put_reflection_data

   end

   put_xyz_seitz_matrices
   ! Put out the cartesian seitz matrices.
      self :: IN

      symop :: MAT3{REAL}@

      stdout.save
      stdout.set_using_array_labels(FALSE)
      stdout.set_real_precision(3)

      symop = .xyz_seitz_matrices

      stdout.flush
      stdout.text("========================")
      stdout.text("Cartesian Seitz matrices")
      stdout.text("========================")
      stdout.put(symop,auto_width=TRUE)

      ! Clean
      symop.destroy
      stdout.unsave

   end

   put_asymmetric_unit_geometry ::: private
   ! Put out the asymmetric unit geometry.
      self :: IN

   ENSURE(.asymmetric_unit_geometry.allocated,"no asymmetric unit geometry")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric unit atoms")
   ENSURE(.asym_atom_sym_factor.allocated,"no asym_atom_sym_factor")
   ENSURE(.asym_atom_stabilizer.allocated,"no asym_atom_stabilizer")

      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.flush
      stdout.text("===============")
      stdout.text("Asymmetric unit")
      stdout.text("===============")
      stdout.flush
      stdout.show("Asymmetric unit source       =",.asymmetric_unit_source)
      stdout.show("No. of asymmetric unit atoms =",.n_asymmetric_unit_atoms)
      stdout.flush

      ! Table
      table.create(6)
      table(1).set_heading("ID");         table(1).set_values(.asymmetric_unit_atom(:).tag)
      table(2).set_heading("x");          table(2).set_values(.asymmetric_unit_geometry(1,:))
      table(3).set_heading("y");          table(3).set_values(.asymmetric_unit_geometry(2,:))
      table(4).set_heading("z");          table(4).set_values(.asymmetric_unit_geometry(3,:))
      table(3).set_sb3head("/frac")
      table(5).set_heading("Site");       table(5).set_values(int(.asym_atom_sym_factor))
      table(5).set_subhead("symm")
      table(5).set_sb3head("fact")
      table(6).set_item_width(2)
      table(6).set_heading("Stabilizer"); table(6).set_values(.asym_atom_stabilizer)
      table(6).set_subhead("symops")
      table.put

      ! Clean
      table.destroy

   end

   put_unit_cell_geometry
   ! Put out the unit_cell_geometry.
      self :: IN

   ENSURE(.unit_cell_geometry.allocated,"no unit_cell_geometry")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated, "no asym-atom_for_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.allocated,"no asym_symop_for_cell_atom")
   ENSURE(.frag_atom_for_unit_cell_atom.allocated, "no frag_atom_for_cell_atom")
   ENSURE(.frag_parent_for_cell_atom.allocated,    "no frag_parent_for_cell_atom")

      table :: VEC{TABLE_COLUMN}@

      ! Header
      stdout.flush
      stdout.flush
      stdout.text("==================")
      stdout.text("Unit cell geometry")
      stdout.text("==================")

      if (.spacegroup.n_seitz==1) then
      stdout.flush
      stdout.text(". The spacegroup is P1. The unit cell")
      stdout.text("  is the same as the asymmetric unit.")
      end

      if (any(.frag_parent_for_cell_atom==0)) then
      stdout.flush
      stdout.text(". The fragment does encompass the whole")
      stdout.text("  unit cell - there are 0 indices.")
      end

      stdout.flush
      stdout.show("No. of unit cell atoms =",.n_unit_cell_atoms)
      stdout.flush

      ! Table
      table.create(10)

      table(1).set_heading("ID");        table(1).set_values(.asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).tag)

      table(3).set_heading("Coord")
      table(2).set_subhead("- x -");     table(2).set_values(.unit_cell_geometry(1,:))
      table(3).set_subhead("- y -");     table(3).set_values(.unit_cell_geometry(2,:))
      table(4).set_subhead("- z -");     table(4).set_values(.unit_cell_geometry(3,:))
      table(3).set_sb3head("/frac")

      table(5).set_heading("From");      table(5).set_values(.asym_atom_for_unit_cell_atom)
      table(5).set_subhead("asym")
      table(5).set_sb3head("atom")

      table(6).set_heading("Using");     table(6).set_values(.asym_symop_for_unit_cell_atom)
      table(6).set_subhead("symop")
      table(6).set_sb3head("    #")

      table(7).set_heading("Asym");      table(7).set_values(.is_asym_unit_cell_atom)
      table(7).set_subhead("atom")
      table(7).set_sb3head("   ?")

      table(8).set_heading("Made by a"); table(8).set_values(.frag_atom_for_unit_cell_atom)
      table(8).set_subhead("shift frm")
      table(8).set_sb3head("frag atom")

      table(9).set_heading("Made by a"); table(9).set_values(.frag_parent_for_cell_atom)
      table(9).set_subhead("symop frm")
      table(9).set_sb3head("frag atom")

      table(10).set_heading("Unit"); table(10).set_values(.unit_cell_mol_for_atom)
      table(10).set_subhead("cell")
      table(10).set_sb3head("Mol #")

      table.put

      ! Clean
      table.destroy

   end

   put_pdb(pdbfile)
   ! pdb file header generation
   ! Put unit cell information
   ! CRYST1   31.595   32.369   24.219  90.00  90.00  90.00 P 21 21 21    8
      self :: IN
      pdbfile :: TEXTFILE*

      factor :: REAL

      pdbfile.save
      pdbfile.set_margin_width(0)
      pdbfile.put("CRYST1",width=6)
      pdbfile.set_real_precision(3)
      pdbfile.set_real_width(9)

      pdbfile.put(.unit_cell.length(1).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(2).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(3).to_units("angstrom"))

      pdbfile.set_real_precision(2)
      pdbfile.set_real_width(7)

      pdbfile.put(.unit_cell.angle(1).to_units("degree"))
      pdbfile.put(.unit_cell.angle(2).to_units("degree"))
      pdbfile.put(.unit_cell.angle(3).to_units("degree"))
      pdbfile.put(.spacegroup.HM_symbol,width=10)
      pdbfile.put(.Z,width=5)
      pdbfile.flush

      pdbfile.put("SCALE1",width=6)
      pdbfile.tab(width=6)
      pdbfile.set_real_precision(7)
      pdbfile.set_real_width(10)
      factor=1.0d0
      factor.convert_to("angstrom^-1")

      pdbfile.put(.unit_cell.inverse_mx(1,1)*factor)
      pdbfile.put(.unit_cell.inverse_mx(1,2)*factor)
      pdbfile.put(.unit_cell.inverse_mx(1,3)*factor)
      pdbfile.flush

      pdbfile.put("SCALE2",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_mx(2,1)*factor)
      pdbfile.put(.unit_cell.inverse_mx(2,2)*factor)
      pdbfile.put(.unit_cell.inverse_mx(2,3)*factor)
      pdbfile.flush

      pdbfile.put("SCALE3",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_mx(3,1)*factor)
      pdbfile.put(.unit_cell.inverse_mx(3,2)*factor)
      pdbfile.put(.unit_cell.inverse_mx(3,3)*factor)
      pdbfile.flush

      !SCALE1     0.1053741 0.0175390 0.0172991      0.0000000
      !SCALE2     0.0000000 0.0601636 0.0076747      0.0000000
      !SCALE3     0.0000000 0.0000000 0.0321397      0.0000000
      pdbfile.unsave

   end

! CIF

   put_asymm_unit_CIF(cif)
   ! Put out an asymmetric-unit "cif" file
      self :: INOUT
      cif :: CIF, IN

   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list")

      has_covariances :: BIN

      has_covariances = .has_covariance_mx
      if (has_covariances) then
         .:put_CIF(cif,.asymmetric_unit_atom,.xray_data.covariance_mx)
      else
         .:put_CIF(cif,.asymmetric_unit_atom)
      end

   end

   put_fragment_CIF(cif)
   ! Put out a fragment_atom "cif" file
      self :: INOUT
      cif :: CIF, IN

   ENSURE(.fragment_atom.allocated,"no fragment_atom list")

      has_covariances :: BIN

      has_covariances = .has_fragment_covariance_mx
      if (has_covariances) then
         .:put_CIF(cif,.fragment_atom,.xray_data.fragment_covariance_mx)
      else
         .:put_CIF(cif,.fragment_atom)
      end

   end

   put_fragment_CIF_HBB(cif)
   ! Put out a fragment_atom "cif" file
      self :: INOUT
      cif :: CIF, IN

   ENSURE(.fragment_atom.allocated,"no fragment_atom list")

      has_covariances :: BIN

      has_covariances = .has_fragment_covariance_mx
      if (has_covariances) then
         .:put_CIF_HBB(cif,.fragment_atom,.xray_data.fragment_covariance_mx)
      end

   end

   put_asymm_unit_CIF_bond_info 
   ! Put out an asymmetric-unit "cif" file, bond info only
      self :: INOUT

   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list")
   ENSURE(.asymmetric_unit_atom(1).pos_axis_system=="cartesian","not cartesian axes!")

      if (NOT .has_covariance_mx) return
      ::put_CIF_bond_info_tables(.asymmetric_unit_atom,.xray_data.covariance_mx)

   end

   put_fragment_CIF_bond_info
   ! Put out a fragment_atom "cif" file, bond info only
      self :: IN

   ENSURE(.fragment_atom.allocated,"no fragment_atom list")
   ENSURE(.fragment_atom(1).pos_axis_system=="cartesian","not cartesian axes!")

      if (NOT .has_fragment_covariance_mx) return
      ::put_CIF_bond_info_tables(.fragment_atom,.xray_data.fragment_covariance_mx)

   end


   has_covariances result (res) ::: PURE
   ! Does the covariance matrix exist?
      self :: IN
      res :: BIN

      res = .has_covariance_mx AND .has_fragment_covariance_mx

   end

   has_covariance_mx result (res) ::: PURE
   ! Does the covariance matrix exist?
      self :: IN
      res :: BIN
      res = FALSE
      if (.xray_data.allocated) then
      if (.xray_data.covariance_mx.allocated) then
         res = TRUE
      end
      end
   end

   has_fragment_covariance_mx result (res) ::: PURE
   ! Does the fragment_covariance matrix exist?
      self :: IN
      res :: BIN
      res = FALSE
      if (.xray_data.allocated) then
      if (.xray_data.fragment_covariance_mx.allocated) then
         res = TRUE
      end
      end
   end


   put_CIF(cif,atom) ::: private
   ! Put an "atom" cif file without errors.
      self :: INOUT
      cif  :: CIF, IN
      atom :: VEC{ATOM}, IN

      thresh :: STR
      lambda :: REAL
      refine_H_U_iso,cart,har :: BIN

      ! Placeholders
      ::put_CIF_crystal_data

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      cart = atom(1).pos_axis_system == "cartesian"
      har  = FALSE
      if (.xray_data.allocated) har = .xray_data.refine_structure OR .xray_data.fit_structure
      .unit_cell.put_CIF(.Z,cart,har)

      ! Any data?
      refine_H_U_iso = TRUE
      if (.xray_data.allocated) refine_H_U_iso = .xray_data.refine_H_U_iso

      ! Put the info
      atom.put_CIF_coords(refine_H_U_iso)
      atom.put_CIF_ADP2(refine_H_U_iso)
      atom.put_CIF_ADPn(cif)

      ! Put covariance matrix  
      if (cif.use_CIF2) then
      if (atom(1).pos_axis_system=="cartesian") then
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         .xray_data.PUT:put_CIF_covariance_matrices(cif)
      end
      end
      end
      end
      
      ! Put wavelength and other refl data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         thresh = .xray_data.INQ:CIF_threshold_expression
         lambda = .xray_data.INQ:wavelength
         .xray_data.reflections.put_CIF_refln_data(thresh,lambda)
      end
      end

      ! Put the reflection data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
       ! .put_xd_fco
      end
      end

   end

   put_CIF(cif,atom,covariance_mx) ::: private
   ! Put a *molecular fragment* cif file with errors, using "atom"
   ! list.  ESDs are produced from .xray_data.fragment_covariance_mx
   ! and NOTE: must have the correct units on entry.
      self :: INOUT
      cif  :: CIF, IN
      atom :: VEC{ATOM}, IN
      covariance_mx :: MAT{REAL}, IN

   ENSURE(.xray_data.allocated,"no diffraction data!")

      n_pADPs :: INT
      thresh :: STR
      lambda :: REAL
      cart,har :: BIN
      esd :: VEC{REAL}@

      ! Placeholders
      ::put_CIF_crystal_data

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      cart = atom(1).pos_axis_system == "cartesian"
      har  = FALSE
      if (.xray_data.allocated) har = .xray_data.refine_structure OR .xray_data.fit_structure
      .unit_cell.put_CIF(.Z,cart,har)

      ! Put refinement special info
      .xray_data.PUT:put_CIF_refinement

      ! Errors
      n_pADPs = atom.no_of_pADPs
      esd.create(n_pADPs)
      .::make_CIF_esds(atom,covariance_mx,esd)
      esd = sqrt(esd)

      ! Put the info
      atom.put_CIF_coords(.xray_data.refine_H_U_iso,esd)
      atom.put_CIF_ADP2(.xray_data.refine_H_U_iso,esd)
      atom.put_CIF_ADPn(cif,esd)

      ! Put bond & angle info
      if (atom(1).pos_axis_system=="cartesian") then
      ::put_CIF_bond_info_tables(atom,covariance_mx)
      end

      ! Clean
      esd.destroy

      ! Put covariance matrix  
      if (cif.use_CIF2) then
      if (stdout.name.includes("cif2")) then
      if (atom(1).pos_axis_system=="cartesian") then
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         .xray_data.PUT:put_CIF_covariance_matrices(cif)
      end
      end
      end
      end
      end

      ! Put wavelength and other refl data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         thresh = .xray_data.INQ:CIF_threshold_expression
         lambda = .xray_data.INQ:wavelength
         .xray_data.reflections.put_CIF_refln_data(thresh,lambda)
      end
      end

      ! Put the reflection data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
       ! .put_xd_fco
      end
      end

   end

   put_CIF_HBB(cif,atom,covariance_mx) ::: private
   ! Put a *molecular fragment* cif file with errors, using "atom"
   ! list.  ESDs are produced from .xray_data.fragment_covariance_mx
   ! and NOTE: must have the correct units on entry.
      self :: INOUT
      cif  :: CIF, IN
      atom :: VEC{ATOM}, IN
      covariance_mx :: MAT{REAL}, IN

   ENSURE(.xray_data.allocated,"no diffraction data!")

      n_pADPs :: INT
      cart,har :: BIN
      esd :: VEC{REAL}@

      ! Placeholders
      ::put_CIF_crystal_data

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      cart = atom(1).pos_axis_system == "cartesian"
      har  = FALSE
      if (.xray_data.allocated) har = .xray_data.refine_structure OR .xray_data.fit_structure
      .unit_cell.put_CIF(.Z,cart,har)

      ! Put refinement special info
      .xray_data.PUT:put_CIF_refinement

      ! Errors
      n_pADPs = atom.no_of_pADPs
      esd.create(n_pADPs)
      .::make_CIF_esds(atom,covariance_mx,esd)
      esd = sqrt(esd)

      ! Put the info
      atom.put_CIF_coords_cartn_HBB(.xray_data.refine_H_U_iso,esd)
      atom.put_CIF_ADP2_cartn_HBB(.xray_data.refine_H_U_iso,esd)
      atom.put_CIF_ADP2_in_inertial_axes_cartn_HBB(covariance_mx,.xray_data.refine_H_U_iso)
      atom.put_CIF_ADP2_in_ADP2_principal_axes_cartn_HBB(covariance_mx,.xray_data.refine_H_U_iso)

      atom.put_CIF_ADP3_cartn_HBB(esd,cif.GC3_scale_factor)
      atom.put_CIF_ADP3_in_inertial_axes_cartn_HBB(covariance_mx,cif.GC3_scale_factor)
      atom.put_CIF_ADP3_in_ADP2_principal_axes_cartn_HBB(covariance_mx,cif.GC3_scale_factor)

      atom.put_CIF_ADP4_cartn_HBB(esd,cif.GC4_scale_factor)
      atom.put_CIF_ADP4_in_inertial_axes_cartn_HBB(covariance_mx,cif.GC4_scale_factor)
      atom.put_CIF_ADP4_in_ADP2_principal_axes_cartn_HBB(covariance_mx,cif.GC4_scale_factor)


      ! Put bond & angle info
      if (atom(1).pos_axis_system=="cartesian") then
      ::put_CIF_bond_Hirshfeld_tables(atom,covariance_mx)
      end

      ! Correlations
      stdout.flush
      .put_correlations_in_cif

      ! Clean
      esd.destroy

   end

   put_CIF_crystal_data ::: selfless, private
   ! Put placeholders forCIF crystal data
      self :: IN

      stdout.flush
      stdout.text("# =======")
      stdout.text("# Crystal")
      stdout.text("# =======")

      stdout.flush
      stdout.show("_exptl_crystal_description         ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_colour              ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_size_max            ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_size_mid            ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_size_min            ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_density_diffrn      ","?"     ,dots=FALSE)

      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Absortion data")
      stdout.text("# ==============")

      stdout.flush
      stdout.show("_exptl_absorpt_coefficient_mu      ","?"     ,dots=FALSE)
      stdout.show("_exptl_absorpt_correction_type     ","'none'",dots=FALSE)
      stdout.show("_exptl_absorpt_process_details     ","?"     ,dots=FALSE)
      stdout.show("_exptl_absorpt_correction_T_min    ","?"     ,dots=FALSE)
      stdout.show("_exptl_absorpt_correction_T_max    ","?"     ,dots=FALSE)

   end

   make_CIF_esds(atom,covariance_mx,esd)
   ! Make the "esd"s in the pADPs for the "atom" list from the
   ! "covariance_mx", required for the "cif" file output.  if
   ! "atom.axis_system" is "cartesian", only the diagonal covariances
   ! are extracted. For "crystal" axis system, positions are unitless
   ! and ADP's are in bohr^2, and anharmonic constants are
   ! dimensionless Gram-Charlier.
      self :: IN
      atom :: VEC{ATOM}, IN
      covariance_mx :: MAT{REAL}, IN
      esd :: VEC{REAL}, OUT

   ENSURE(.xray_data.allocated,"no data")
   ENSURE(atom(1).pos_axis_system==atom(1).ADP_axis_system, "inconsistent pos and ADP axis systems")
   ENSURE(atom(1).pos_axis_system==atom(1).ADPn_axis_system,"inconsistent pos and ADPn axis systems")

      T,C :: MAT{REAL}@
      n_pADPs :: INT
      a,n, ab,af,al :: INT

      ! No of pADPs
      n_pADPs = atom.no_of_pADPs
      ENSURE(esd.dim==n_pADPs,"wrong size, esd")

      ! Get standard deviations and covariances
      ! ... in crystal coordinates
      C.create(n_pADPs,n_pADPs)
      C = ZERO

      ! The covariance matrix transformation matrix
      ! This is only applied to the diagonal blocks.
      T.create(34,34)
      T = ZERO
      if (atom(1).ADP_axis_system=="cartesian") then 
         ! Do nothing
         T.to_unit_mx
      else                         
         ! Usual ADPs & dimensionless positions and (GC) anharmonics
         T(1:3,1:3) = .unit_cell.inverse_mx ! Reset positional transform
         GAUSSIAN_DATA:symmetric_tensor_2_product_mx(T( 4: 9, 4: 9),.unit_cell.reciprocal_U_mx)
         GAUSSIAN_DATA:symmetric_tensor_3_product_mx(T(10:19,10:19),.unit_cell.reciprocal_mx)
         GAUSSIAN_DATA:symmetric_tensor_4_product_mx(T(20:34,20:34),.unit_cell.reciprocal_mx)
      end

      do a = 1,atom.dim

         ! Block limits
         n  = atom(a).no_of_pADPs
         ab = atom.no_of_pADPs_up_to_atom(a)
         af = ab +  1
         al = ab + n

         ! Transform ...
         covariance_mx(af:al,af:al).back_transform_to(C(af:al,af:al),T(1:n,1:n))

      end

      ! Get the esd's ... only diagonal (blocks) needed
      C.put_diagonal_to(esd)

      ! Clean
      C.destroy
      T.destroy

   end


   put_CIF_reflections_head ::: private
   ! Put reflection information in CIF format *on an absolute scale*
      self :: IN

   ENSURE(.xray_data.allocated,"no diffraction data!")

      lambda :: REAL
      thmax  :: REAL

      stdout.flush
      stdout.text("# ================")
      stdout.text("# Diffraction data")
      stdout.text("# ================")

      lambda = .xray_data.wavelength
      lambda.convert_to("angstrom")

      stdout.flush
      stdout.show("_diffrn_radiation_type             ","?"                     ,dots=FALSE)
      stdout.show("_diffrn_radiation_wavelength       ",lambda                  ,dots=FALSE)

      stdout.flush
      stdout.show("_diffrn_measurement_method         ","?"                     ,dots=FALSE)
      stdout.show("_diffrn_measurement_device_type    ","?"                     ,dots=FALSE)

      thmax = maxval(abs(.xray_data.reflections(:).theta))*DEGREE_PER_RADIAN

      stdout.flush
      stdout.show("_diffrn_reflns_number              ","?"                     ,dots=FALSE)
      stdout.show("_diffrn_reflns_theta_max           ",thmax                   ,dots=FALSE)

   end

   put_CIF_reflections_rlim(threshold) ::: private
   ! Put reflection information in CIF format *on an absolute scale*
      self :: IN
      threshold :: STR, IN

   ENSURE(.xray_data.allocated,"no diffraction data!")

      n_refl :: INT

      ! Constants
      n_refl = .xray_data.reflections.dim

      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Reflections")
      stdout.text("# ===========")

      stdout.flush
      stdout.show("_reflns_d_resolution_low           ",.xray_data.reflections(:).d_max*ANGSTROM_PER_BOHR,dots=FALSE)
      stdout.show("_reflns_d_resolution_high          ",.xray_data.reflections(:).d_min*ANGSTROM_PER_BOHR,dots=FALSE)
      stdout.show("_reflns_limit_h_min                ",minval(.xray_data.reflections(:).h1),dots=FALSE)
      stdout.show("_reflns_limit_h_max                ",maxval(.xray_data.reflections(:).h1),dots=FALSE)
      stdout.show("_reflns_limit_k_min                ",minval(.xray_data.reflections(:).h2),dots=FALSE)
      stdout.show("_reflns_limit_k_max                ",maxval(.xray_data.reflections(:).h2),dots=FALSE)
      stdout.show("_reflns_limit_l_min                ",minval(.xray_data.reflections(:).h3),dots=FALSE)
      stdout.show("_reflns_limit_l_max                ",maxval(.xray_data.reflections(:).h3),dots=FALSE)
      stdout.show("_reflns_number_gt                  ",n_refl                   ,dots=FALSE)
      stdout.show("_reflns_number_total               ",n_refl                   ,dots=FALSE)
      stdout.show("_reflns_threshold_expression       ",threshold                ,dots=FALSE)

      stdout.flush
      stdout.text("_reflns_special_details            ")
      stdout.text(";")
      stdout.text("* Specify symmetry and Friedel pair averaging *")

      stdout.flush
      stdout.text(". Only.data reflections which satisfy the threshold expression")
      stdout.text("  are listed below, and only they are considered observed,")
      stdout.text("  thus the *_gt, *_all, & *_total data are always the same")
      stdout.text(";")

    ! fcmax = maxval(abs(.xray_data.reflections(:).F_calc))
    ! stdout.flush
    ! stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)

   end

   put_CIF_reflections(threshold)
   ! Put reflection information in CIF format *on an absolute scale*
      self :: IN
      threshold :: STR, IN

   ENSURE(.xray_data.allocated,"no diffraction data!")

      table :: VEC{TABLE_COLUMN}@
      stl,d,fac :: VEC{REAL}@
      F_p :: VEC{CPX}@
      F_cr,F_ci,F_ph :: VEC{REAL}@
      F_pred,F_exp,F_sigma,F_z :: VEC{REAL}@
      n_refl :: INT

      ! Constants
      n_refl = .xray_data.reflections.dim

      .put_CIF_reflections_head
      .put_CIF_reflections_rlim(threshold)

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _refln_index_h")
      stdout.text("    _refln_index_k")
      stdout.text("    _refln_index_l")
      stdout.text("    _refln_index_group")
      stdout.text("    _refln_stl")
      stdout.text("    _refln_d_spacing")
      stdout.text("    _refln_A_calc")
      stdout.text("    _refln_B_calc")
      stdout.text("    _refln_phase_calc")
      stdout.text("    _refln_F_calc")
      stdout.text("    _refln_F_meas")
      stdout.text("    _refln_F_sigma")
      stdout.text("    _refln_delta_F_on_sigma")

      ! Get data
      stl     = .xray_data.reflections(:).stl*BOHR_PER_ANGSTROM
      d       = .xray_data.reflections(:).d  *ANGSTROM_PER_BOHR
      F_p     = .xray_data.INQ:F_pred_cpx
      F_ph.create(n_refl)
      F_exp.create(n_refl)
      F_pred.create(n_refl)
      F_cr.create(n_refl)
      F_ci.create(n_refl)
      F_z.create(n_refl)
      F_sigma.create(n_refl)
      F_ph    = REFLECTION:F_phase_angle_in_degrees(.xray_data.reflections(:))
      F_exp   = .F_exp_scaled_corrected
      fac     = ONE/.xray_data.INQ:F_scale_and_extn_correction
    ! fac     = sqrt(fac) ! ??? CHECK
      F_pred  = abs(F_p) * fac  ! Warning ... this may include dispersion !
      F_cr    = RE(F_p) * fac
      F_ci    = IM(F_p) * fac
      F_sigma = .xray_data.reflections.F_sigma*fac
      F_z     = REFLECTION:F_z(.xray_data.reflections(:))

      ! Make table
      table.create(13)
       table(1).set_values(.xray_data.reflections(:).h1)
       table(2).set_values(.xray_data.reflections(:).h2)
       table(3).set_values(.xray_data.reflections(:).h3)
       table(4).set_values(.xray_data.reflections(:).group)
       table(5).set_values(stl)
       table(6).set_values(d)
       table(7).set_values(F_cr)
       table(8).set_values(F_ci)
       table(9).set_values(F_ph)
      table(10).set_values(F_pred)
      table(11).set_values(F_exp)
      table(12).set_values(F_sigma)
      table(13).set_values(F_z)

      ! Make table
       table(1).set_width(4)
       table(2).set_width(4)
       table(3).set_width(4)
       table(4).set_width(3)
       table(5).set_width(8)
       table(5).set_real_precision(3)
       table(6).set_width(8)
       table(6).set_real_precision(3)
       table(7).set_width(8)
       table(7).set_real_precision(3)
       table(8).set_width(8)
       table(8).set_real_precision(3)
       table(9).set_width(8)
       table(9).set_real_precision(3)
      table(10).set_width(8)
      table(10).set_real_precision(3)
      table(11).set_width(8)
      table(11).set_real_precision(3)
      table(12).set_width(8)
      table(12).set_real_precision(3)
      table(13).set_width(8)
      table(13).set_real_precision(3)

      ! Body
      table.put_body

      ! Clean
      table.destroy
      F_ph.destroy
      F_exp.destroy
      F_pred.destroy
      F_cr.destroy
      F_ci.destroy
      F_z.destroy
      F_sigma.destroy

   end

! fcf files

   put_Olex2_fcf(threshold)
   ! Put reflection information in CIF format *on an absolute scale*
   ! in the Olex2 way ... ?
      self :: IN
      threshold :: STR, IN

   ENSURE(.xray_data.allocated,"no diffraction data!")

      table :: VEC{TABLE_COLUMN}@
      stl,d,fac :: VEC{REAL}@
      F_p :: VEC{CPX}@
      F_cr,F_ci,F_ph,F2m,F2s,F2c :: VEC{REAL}@
      F_pred,F_exp,F_sigma,F_z :: VEC{REAL}@
      n_refl :: INT

      ! Constants
      n_refl = .xray_data.reflections.dim

      .put_CIF_reflections_head
      .put_CIF_reflections_rlim(threshold)

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _refln_index_h")
      stdout.text("    _refln_index_k")
      stdout.text("    _refln_index_l")
      stdout.text("    _refln_index_group")
      stdout.text("    _refln_stl")
      stdout.text("    _refln_d_spacing")
      stdout.text("    _refln_A_calc")
      stdout.text("    _refln_B_calc")
      stdout.text("    _refln_phase_calc")
      stdout.text("    _refln_F_calc")
      stdout.text("    _refln_F_meas")
      stdout.text("    _refln_F_sigma")
      stdout.text("    _refln_delta_F_on_sigma")
      stdout.text("    _refln_F_squared_meas")
      stdout.text("    _refln_F_squared_sigma")
      stdout.text("    _refln_F_squared_calc")

      ! Get data
      stl = .xray_data.reflections(:).stl*BOHR_PER_ANGSTROM
      d   = .xray_data.reflections(:).d  *ANGSTROM_PER_BOHR
      F_p = .xray_data.INQ:F_pred_cpx
      F_ph.create(n_refl)
      F2m.create(n_refl)
      F2c.create(n_refl)
      F2s.create(n_refl)
      F_exp.create(n_refl)
      F_pred.create(n_refl)
      F_cr.create(n_refl)
      F_ci.create(n_refl)
      F_z.create(n_refl)
      F_sigma.create(n_refl)

      F2m = .F2_exp_scaled_corrected
      fac = F2m/.xray_data.reflections(:).F2_exp
      F2s = .xray_data.reflections(:).F2_sigma*fac
      F2c = .xray_data.reflections(:).F2_calc_abs

      F_ph    = REFLECTION:F_phase_angle_in_degrees(.xray_data.reflections(:))
      F_exp   = .F_exp_scaled_corrected
      fac     = ONE/.xray_data.INQ:F_scale_and_extn_correction
      F_pred  = abs(F_p) * fac  ! Warning ... this may include dispersion !
      F_cr    = RE(F_p)
      F_cr    = F_cr * fac
      F_ci    = IM(F_p)
      F_ci    = F_ci * fac
      F_sigma = .xray_data.reflections.F_sigma*fac
      F_z     = REFLECTION:F_z(.xray_data.reflections(:))

      ! Make table
      table.create(16)
       table(1).set_values(.xray_data.reflections(:).h1)
       table(2).set_values(.xray_data.reflections(:).h2)
       table(3).set_values(.xray_data.reflections(:).h3)
       table(4).set_values(.xray_data.reflections(:).group)
       table(5).set_values(stl)
       table(6).set_values(d)
       table(7).set_values(F_cr)
       table(8).set_values(F_ci)
       table(9).set_values(F_ph)
      table(10).set_values(F_pred)
      table(11).set_values(F_exp)
      table(12).set_values(F_sigma)
      table(13).set_values(F_z)
      table(14).set_values(F2m)
      table(15).set_values(F2s)
      table(16).set_values(F2c)

      ! Body
      table.put_body

      ! Clean
      table.destroy
      F_ph.destroy
      F_exp.destroy
      F_pred.destroy
      F_cr.destroy
      F_ci.destroy
      F_z.destroy
      F_sigma.destroy
      F2m.destroy
      F2c.destroy
      F2s.destroy

   end

   put_tonto_fcf
   ! Put a tonto fcf file with all the info and scaled so that
   ! Olex2 can make difference density maps.
      self :: IN

      thresh :: STR

      if (.xray_data.deallocated)           return
      if (.xray_data.reflections.deallocated) return

      thresh = .xray_data.INQ:CIF_threshold_expression
      .put_CIF_reflections(thresh)

   end

   put_shelx_fcf5
   ! Put shelx fcf LIST=5 reflection file.
      self :: INOUT

      F000 :: REAL
      fcmax :: REAL
      F_corr :: VEC{REAL}@
      i :: INT

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      .unit_cell.put_CIF(.Z,cart=FALSE,har=FALSE)

      ! Put the reflection data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then

         F000 = .no_of_unit_cell_electrons

         stdout.flush
         stdout.text("# The value below is just the no. of unit cell electrons")
         stdout.flush
         stdout.show("_exptl_crystal_F_000               ",F000,dots=FALSE)
         stdout.flush

         stdout.text("# ===============")
         stdout.text("# Reflection data")
         stdout.text("# ===============")
   
         stdout.flush
         stdout.show("_reflns_d_resolution_low           ",.xray_data.reflections.d_max*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_d_resolution_high          ",.xray_data.reflections.d_min*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_limit_h_min                ",minval(.xray_data.reflections(:).h1),dots=FALSE)
         stdout.show("_reflns_limit_h_max                ",maxval(.xray_data.reflections(:).h1),dots=FALSE)
         stdout.show("_reflns_limit_k_min                ",minval(.xray_data.reflections(:).h2),dots=FALSE)
         stdout.show("_reflns_limit_k_max                ",maxval(.xray_data.reflections(:).h2),dots=FALSE)
         stdout.show("_reflns_limit_l_min                ",minval(.xray_data.reflections(:).h3),dots=FALSE)
         stdout.show("_reflns_limit_l_max                ",maxval(.xray_data.reflections(:).h3),dots=FALSE)

         if (.xray_data.scale_factors.deallocated) then
         fcmax = .xray_data.scale_factor
         stdout.flush
         stdout.show("_tonto_F_scale_factor              ",fcmax,dots=FALSE)
         end
   
         fcmax = maxval(.xray_data.reflections.F_calc_abs)

         stdout.flush
         stdout.show("_shelx_refln_list_code             ", 5,dots=FALSE)
         stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)
   
         F_corr = .F_exp_scaled_corrected
   
         stdout.flush
         stdout.text("loop_")
         stdout.text("    _refln_index_h")
         stdout.text("    _refln_index_k")
         stdout.text("    _refln_index_l")
         stdout.text("    _refln_F_meas")
         stdout.text("    _refln_F_calc")
         stdout.text("    _refln_phase_calc")
   
         do i = 1,.xray_data.reflections.dim
            stdout.put(.xray_data.reflections(i).h1,width=4)
            stdout.put(.xray_data.reflections(i).h2,width=4)
            stdout.put(.xray_data.reflections(i).h3,width=4)
            stdout.put(F_corr(i),                           width=10,precision=2)
            stdout.put(.xray_data.reflections(i).F_calc_abs,width=10,precision=2)
            stdout.put(.xray_data.reflections(i).F_phase_angle_in_degrees,width= 7,precision=2)
            stdout.flush
         end

      end
      end

   end

   put_shelx_fcf6
   ! Put shelx fcf LIST=6 reflection file
      self :: INOUT

      F000 :: REAL
      fcmax :: REAL
      F2_cor,factor :: VEC{REAL}@
      i :: INT

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      .unit_cell.put_CIF(.Z,cart=FALSE,har=FALSE)

      ! Put the reflection data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then

         F000 = .no_of_unit_cell_electrons

         stdout.flush
         stdout.text("# The value below is just the no. of unit cell electrons")
         stdout.flush
         stdout.show("_exptl_crystal_F_000               ",F000,dots=FALSE)
         stdout.flush
   
         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Reflection data")
         stdout.text("# ===============")
   
         stdout.flush
         stdout.show("_reflns_d_resolution_low           ",.xray_data.reflections.d_max*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_d_resolution_high          ",.xray_data.reflections.d_min*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_limit_h_min                ",minval(.xray_data.reflections(:).h1),dots=FALSE)
         stdout.show("_reflns_limit_h_max                ",maxval(.xray_data.reflections(:).h1),dots=FALSE)
         stdout.show("_reflns_limit_k_min                ",minval(.xray_data.reflections(:).h2),dots=FALSE)
         stdout.show("_reflns_limit_k_max                ",maxval(.xray_data.reflections(:).h2),dots=FALSE)
         stdout.show("_reflns_limit_l_min                ",minval(.xray_data.reflections(:).h3),dots=FALSE)
         stdout.show("_reflns_limit_l_max                ",maxval(.xray_data.reflections(:).h3),dots=FALSE)

         if (.xray_data.scale_factors.deallocated) then
         fcmax = .xray_data.scale_factor
         fcmax = fcmax*fcmax
         stdout.flush
         stdout.show("_tonto_F2_scale_factor             ",fcmax,dots=FALSE)
         end
   
         fcmax = maxval(.xray_data.reflections.F_calc_abs)
   
         stdout.flush
         stdout.show("_shelx_refln_list_code             ", 6,dots=FALSE)
         stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)
   
         stdout.flush
         stdout.text("loop_")
         stdout.text("    _refln_index_h")
         stdout.text("    _refln_index_k")
         stdout.text("    _refln_index_l")
         stdout.text("    _refln_F_squared_meas")
         stdout.text("    _refln_F_squared_sigma")
         stdout.text("    _refln_F_squared_calc")
         stdout.text("    _refln_phase_calc")
   
         F2_cor = .F2_exp_scaled_corrected
         factor = F2_cor/.xray_data.reflections(:).F2_exp
   
         do i = 1,.xray_data.reflections.dim
            stdout.put(.xray_data.reflections(i).h1,width=4)
            stdout.put(.xray_data.reflections(i).h2,width=4)
            stdout.put(.xray_data.reflections(i).h3,width=4)
            stdout.put(F2_cor(i))
            stdout.put(.xray_data.reflections(i).F2_sigma*factor(i))
            stdout.put(.xray_data.reflections(i).F2_calc_abs       )
            stdout.put(.xray_data.reflections(i).F_phase_angle_in_degrees)
            stdout.flush
         end

      end
      end

   end

! XD fco file

   put_xd_fco
   ! Put XD fco reflection file
      self :: INOUT

      F000,F2_cal,F2_exp,F2_sig :: REAL
      F_p :: VEC{CPX}@
      F_exp,fac,F_sigma :: VEC{REAL}@
      d_max,d_min :: REAL
      h_max,h_min :: VEC{INT}(3)
      ref :: REFLECTION
      i,n_refl :: INT

      !Get Number of reflections
      n_refl = .xray_data.reflections.dim

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      .unit_cell.put_CIF(.Z,cart=FALSE,har=FALSE)

      ! Put the reflection data
      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then

         F000 = .no_of_unit_cell_electrons
         F000 = F000*F000

         stdout.flush
         stdout.show("_exptl_crystal_F_squared_000        ",F000,dots=FALSE)
         stdout.flush

        
         stdout.flush
         stdout.text("# ======================")
         stdout.text("# XD fco reflection data")
         stdout.text("# ======================")
        
         stdout.flush
         stdout.text("# . checkCIF also accepts this as fcf format")
        
         stdout.flush
         stdout.show("_shelx_refln_list_code             ", 4,dots=FALSE)
         stdout.flush

         d_max = .xray_data.reflections.d_max*ANGSTROM_PER_BOHR
         d_min = .xray_data.reflections.d_min*ANGSTROM_PER_BOHR
         stdout.show("_reflns_d_resolution_high          ",d_min   ,dots=FALSE)
         stdout.show("_reflns_d_resolution_low           ",d_max   ,dots=FALSE)

         h_max = .xray_data.reflections.h_max
         h_min = .xray_data.reflections.h_min
         stdout.show("_reflns_limit_h_max                ",h_max(1),dots=FALSE)
         stdout.show("_reflns_limit_h_min                ",h_min(1),dots=FALSE)
         stdout.show("_reflns_limit_k_max                ",h_max(2),dots=FALSE)
         stdout.show("_reflns_limit_k_min                ",h_min(2),dots=FALSE)
         stdout.show("_reflns_limit_l_max                ",h_max(3),dots=FALSE)
         stdout.show("_reflns_limit_l_min                ",h_min(3),dots=FALSE)
        
         stdout.flush
         stdout.text("# NOTE: F_squared_meas is scaled to F_squared_calc")
         stdout.text("#       and so it is on an absolute scale")
         if (NOT .xray_data.INQ:use_multiple_scale_factors) then
         stdout.show("_reflns_tonto_F_scale_factor       ",.xray_data.scale_factor      ,dots=FALSE)
         end
        
        
         stdout.flush
         stdout.text("loop_")
         stdout.text("    _refln_index_h")
         stdout.text("    _refln_index_k")
         stdout.text("    _refln_index_l")
         stdout.text("    _refln_F_squared_calc")
         stdout.text("    _refln_F_squared_meas")
         stdout.text("    _refln_F_squared_sigma")
         stdout.text("    _refln_observed_status")

         F_exp = .xray_data.INQ:F_exp_on_absolute_scale ! We can just multiply F_exp b y fac below!
         F_p   = .xray_data.INQ:F_pred_cpx
         fac   = ONE/.xray_data.INQ:F_scale_and_extn_correction
         F_sigma = .xray_data.reflections(:).F_sigma*fac
        
         do i = 1,.xray_data.reflections.dim

            ! The reflection
            ref = .xray_data.reflections(i)

            ! The numbers
          ! F2_cal = ref.F2_calc_abs
            F2_exp = F_exp(i)*F_exp(i)
          ! factor = F_exp(i)/ref.F_exp ! scale factor
          ! F2_sig = fac(i)*fac(i) * F_exp(i) * ref.F_sigma * TWO ! Lorraine, CHECK !!!!
          ! Lorraine here: Checked, and its wrong, corrected equation
          ! below. Tested against alanine dataset with scale factor 4.85
            F2_sig = F_exp(i) * F_sigma(i) * TWO 
            F_p(i) = F_p(i) * fac(i)
            F2_cal = RE(F_p(i)) * RE(F_p(i)) + IM(F_p(i)) * IM(F_p(i)) 

            if (IO_IS_ALLOWED) then
               write(stdout.unit,"(3i4,2f12.2,1f10.2,1x,a1)") &
                  ref.h1,ref.h2,ref.h3,F2_cal,F2_exp,F2_sig,"o"
            end

         end

      end
      end

   end


   put_NKA_cartesian
   ! Put out the NKA information in cartesian coordinates
      self :: IN

   ENSURE(.xray_data.allocated,"no diffraction data")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list")

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.xray_data.NKA_T_sequence_no,width=3)
      stdout.put(.xray_data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Coordinate information
      .asymmetric_unit_atom.put_NKA_with_errors(.xray_data.NKA_T_sequence_no)

   end

   put_excel_crystal
   ! Put out the coordinate and ADP information in Excel format
      self :: INOUT

   ENSURE(.xray_data.allocated,"no diffraction data")
   ENSURE(.xray_data.covariance_mx.allocated,"no covariance_mx")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_unit_atom list")

      esd :: VEC{REAL}@
      n_pADPs :: INT

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.xray_data.NKA_T_sequence_no,width=3)
      stdout.put(.xray_data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Get errors in crystal coordinates
      n_pADPs = .asymmetric_unit_atom.no_of_pADPs
      esd.create(n_pADPs)
      .make_CIF_esds(.asymmetric_unit_atom,.xray_data.covariance_mx,esd)
      esd = sqrt(esd)

      ! Change axis system to crystal
      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell,FALSE)

      ! Dump the data
      .asymmetric_unit_atom.put_excel_with_errors(esd,.xray_data.temperature)

      ! Change axes back to cartesian
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Clean up
      esd.destroy

   end

   put_uc_connection_table
   ! Put the .unit_cell_connection table
      self :: IN

   ENSURE(.unit_cell_connection.allocated,"no unit_cell_connection")
   ENSURE(.unit_cell_mol_for_atom.allocated,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Unit cell atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)

         first = TRUE
         do a = 1,.unit_cell_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.unit_cell_connection(a).element.dim==0) then

               stdout.flush

            else

               do i = 1,.unit_cell_connection(a).element.dim

                  if (i>1) &
                  stdout.tab(int_fields=2)

                  b = .unit_cell_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.unit_cell_connection(a)[i][1])
                  stdout.put(.unit_cell_connection(a)[i][2])
                  stdout.put(.unit_cell_connection(a)[i][3])
                  stdout.flush

               end

            end
         end
      end

      stdout.dash(int_fields=6)

   end

   put_uc_vdw_connection_table
   ! Put the .unit_cell_connection table
      self :: IN

   ENSURE(.uc_vdw_connection.allocated,"no uc_vdw_connection")
   ENSURE(.unit_cell_mol_for_atom.allocated,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Cell VDW atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)

         first = TRUE
         do a = 1,.uc_vdw_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.uc_vdw_connection(a).element.dim==0) then

               stdout.flush

            else

               do i = 1,.uc_vdw_connection(a).element.dim

                  if (i>1) &
                  stdout.tab(int_fields=2)

                  b = .uc_vdw_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.uc_vdw_connection(a)[i][1])
                  stdout.put(.uc_vdw_connection(a)[i][2])
                  stdout.put(.uc_vdw_connection(a)[i][3])
                  stdout.flush

               end

            end
         end
      end

      stdout.dash(int_fields=6)

   end

!  ================================
!  Put Fragment related information
!  ================================

   put_fragment_data ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      self :: IN

      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Crystal fragment")
      stdout.text("================")
      stdout.flush
      stdout.text(". Ab initio calculations are performed on the fragment")
      stdout.text("  to obtain structure factors, charges, etc.")
      stdout.flush
      stdout.text(". The fragment need not be an asymmetric unit.")
      stdout.flush
      stdout.text(". Repeated atoms are assigned a 'repetition factor' which")
      stdout.text("  is used to scale the structure factor contribution from")
      stdout.text("  that atom. You can manually reset this.")
      stdout.flush
      stdout.text(". Only the unique atoms in the fragment have their ")
      stdout.text("  positions and ADPs refined.")
      stdout.flush
      stdout.text(". The Z factor for the crystal is defined with respect to")
      stdout.text("  the no. of electrons in the fragment")

      stdout.flush
      stdout.flush
      stdout.show("No. of fragment atoms        =",.n_fragment_atoms)
      stdout.show("No. of unique fragment atoms =",.n_unique_frag_atoms)
      stdout.show("Z factor                     =",.Z)

      if (.partition_model/=" " OR .temperature_factor_model/=" ") then
      stdout.flush
      stdout.show("Density partition model      =",.partition_model)
      stdout.show("Thermal smearing model       =",.temperature_factor_model)
      end

      .put_fragment_geometry
      .put_stabilizer_symops

   end

   put_stabilizer_symops ::: private
   ! Put out the stabilizer symop data
      self :: IN

   ENSURE(.stabilizer_symop.allocated,"no stabilizer_symop")

      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("=========================")
      stdout.text("Crystal stabilizer symops")
      stdout.text("=========================")
      stdout.flush
      stdout.text(". The stablizer is the subgroup of symops which")
      stdout.text("  map the fragment_geometry into itself.")
      stdout.flush
      stdout.show("n_stabilizer_symops =",.n_stabilizer_symops)
      stdout.flush

      ! Table
      table.create(1)
      table(1).set_heading("Stablizer")
      table(1).set_subhead("symops")
      table(1).set_values(.stabilizer_symop(:))
      table.put

      ! Clean
      table.destroy

   end

   put_fragment_geometry ::: private
   ! Put out the fragment_geometry information
      self :: IN

   ENSURE(.fragment_info_made,"no fragment info")

      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.flush
      stdout.text("QM fragment geometry:")
      stdout.flush

      ! Table
      table.create(13)

      table( 1).set_heading("ID");     table(1).set_values(.fragment_atom.tag)

      table( 2).set_column_spacing(2)
      table( 2).set_heading("Rep");    table(2).set_values(int(.repetition_factor))
      table( 2).set_subhead("fac")
      table( 2).set_sb3head("tor")

      table( 3).set_column_spacing(2)
      table( 3).set_heading("Site");   table(3).set_values(.frag_atom_sym_factor)
      table( 3).set_subhead("symm")
      table( 3).set_sb3head("fact")

      table( 4).set_column_spacing(2)
      table( 4).set_heading("Uniq");   table(4).set_values(.unique_index_for_frag_atom)
      table( 4).set_subhead("atom")

      table( 5).set_column_spacing(3)
      table( 5).set_heading("Uniq");   table(5).set_values(.unique_atom_for_frag_atom)
      table( 5).set_subhead("atom")
      table( 5).set_sb3head("ID")

      table( 7).set_heading("Coord")
      table( 6).set_subhead("- x -");  table(6).set_values(.fragment_geometry(1,:))
      table( 7).set_subhead("- y -");  table(7).set_values(.fragment_geometry(2,:))
      table( 8).set_subhead("- z -");  table(8).set_values(.fragment_geometry(3,:))
      table( 7).set_sb3head("/frac")

      table( 9).set_heading("From");   table(9).set_values(.asym_atom_for_frag_atom)
      table( 9).set_subhead("asym")
      table( 9).set_sb3head("atom")

      table(10).set_column_spacing(2)
      table(10).set_heading("Using");  table(10).set_values(.asym_symop_for_frag_atom)
      table(10).set_subhead("symop")

      table(11).set_column_spacing(2)
      table(11).set_real_precision(1)
      table(11).set_heading("     ");  table(11).set_values(.asym_shift_for_frag_atom(1,:)) 
      table(11).set_subhead("- x -")
      table(12).set_column_spacing(2)
      table(12).set_real_precision(1)
      table(12).set_heading("Shift");  table(12).set_values(.asym_shift_for_frag_atom(2,:))
      table(12).set_subhead("- y -")
      table(13).set_column_spacing(2)
      table(13).set_real_precision(1)
      table(13).set_heading("     ");  table(13).set_values(.asym_shift_for_frag_atom(3,:))
      table(13).set_subhead("- z -")
      table(12).set_sb3head("/frac")

      table.put

      ! Clean
      table.destroy

   end

!  ==================================
!  Put reflection related information
!  ==================================

   put_X_data_analysis(output)
   ! Put out analysis data for the reflections after a fit/refinement
      self :: INOUT
      output :: BIN, optional, IN

   ENSURE(.xray_data.allocated,"no diffraction data")

      show :: BIN

      show = TRUE
      if (present(output)) show = output

      if (NOT show) return

      .xray_data.PUT:put_GOF_vs_STL_table
      .xray_data.PUT:put_GOF_vs_F_exp_table

      .xray_data.PUT:put_N_worst_reflections

      .put_fitting_plots

   end


   put_reflection_data
   ! Put out the reflection data to file "out".  Both Neutron and
   ! X-ray will be put if present.
      self :: IN
      .put_X_reflection_data
    ! .put_N_reflection_data
   end

   put_X_reflection_data
   ! Put out the X-ray reflection data.
      self :: IN

      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         .xray_data.PUT:put_reflections
      end
      end

      if (.xray_r_free_data.allocated) then
      if (.xray_r_free_data.reflections.allocated) then
         .xray_r_free_data.PUT:put_reflections
      end
      end

   end

!   put_N_reflection_data
!   ! Put out the PND reflection data
!      self :: IN
!      if (.pnd_data.allocated) then
!      if (.pnd_data.reflections.allocated) then
!         .pnd_data.PUT:put_reflections
!      end
!      end
!   end

   put_all_reflection_data
   ! Put out all the X-ray reflection data.
      self :: IN

      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         .xray_data.reflections.put_F_all_data
      end
      end

      if (.xray_r_free_data.allocated) then
      if (.xray_r_free_data.reflections.allocated) then
         .xray_r_free_data.reflections.put_F_all_data
      end
      end

   end


   put_reflection_intensities
   ! Put out the reflection data to file "out".  Both Neutron and
   ! X-ray will be put if present.
      self :: IN
      .put_X_reflection_intensities
   end

   put_X_reflection_intensities
   ! Put out the X-ray reflection data.
      self :: IN

      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         .xray_data.PUT:put_reflection_intensities
      end
      end

      if (.xray_r_free_data.allocated) then
      if (.xray_r_free_data.reflections.allocated) then
         .xray_r_free_data.PUT:put_reflection_intensities
      end
      end

   end

   put_reflection_intensities_XD
   ! Put out the reflection data to file "out".  Both Neutron and
   ! X-ray will be put if present.
      self :: IN
      .put_X_reflection_intensities_XD
   end

   put_X_reflection_intensities_XD
   ! Put out the X-ray reflection data.
      self :: IN

      if (.xray_data.allocated) then
      if (.xray_data.reflections.allocated) then
         .xray_data.PUT:put_reflection_intensities_XD
      end
      end

      if (.xray_r_free_data.allocated) then
      if (.xray_r_free_data.reflections.allocated) then
         .xray_r_free_data.PUT:put_reflection_intensities_XD
      end
      end

   end


!   put_PND_sf(name)
!   ! outputs the polarised neutron structure factors
!      self :: IN
!      name :: STR, IN
!
!   ENSURE(.xray_data.allocated, "no diffraction data")
!
!      .xray_data.PUT:put_PND_sf(name)
!
!   end


   put_correction_data
   ! Output the correction data
      self :: IN

   ENSURE(.xray_data.allocated, "no diffraction data")

      .xray_data.PUT:put_correction_data

      if (.asymmetric_unit_atom.has_any_ADP3s_and_errors) then
      stdout.flush
      stdout.show("Using ADP3's?                  =",TRUE)
      if (.asymmetric_unit_atom.has_any_ADP4s_and_errors) then
      stdout.show("Using ADP4's?                  =",TRUE)
      end
      end

   end

!  ================
!  Crystal Explorer
!  ================

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
      self :: INOUT
      label,formula,spacegroup :: STR, IN
      .unit_cell.put_CX(label,formula,spacegroup) ! INOUT - change
   end

!  ==================
!  Put plots and maps
!  ==================

   put_fitting_plots
   ! Output all the fitting plot information to "stdout.fit_analysis"
      self :: INOUT

   ENSURE(.xray_data.allocated,"no reflection data")

      ! Fit analysis
      stdout.flush
      stdout.text("==================================")
      stdout.text("Analysis of the Hirshfeld atom fit")
      stdout.text("==================================")
      stdout.flush
      stdout.text("An analysis of the fit is deposited in 'stdout.fit_analysis'.")
      stdout.flush
      stdout.text("This large file includes:")
      stdout.text(". A normal QQ plot with each datum labelled by (hkl)")
      stdout.text(". A plot of F_z = (F_exp-F_pred)/F_sigma vs sin(theta)/lambda :")
      stdout.text(". A plot of F_z = (F_exp-F_pred)/F_sigma vs F_exp")
      stdout.text(". A plot of Delta F = (F_exp-F_pred) vs sin(theta)/lambda :")
      stdout.flush
      stdout.text("If you used an extinction correction, you also get:")
      stdout.text(". A plot of (F_pred(no ext)-F_pred(ext))/F_sigma vs. sin (theta/lambda)")
      stdout.text(". A plot of (F_pred(no ext)-F_pred(ext))/F_sigma vs. F_pred")
      stdout.flush
      stdout.text("All of the above plots are available for the reserved (free) data")
      stdout.text("if you made use of that option. Phew.")
      stdout.flush
      stdout.text("Use Excel or gnuplot to view these data. Do it.")

      ! Data analysis
      if (.xray_data.allocated) then

      !  stdout.flush
      !  stdout.text("====================================")
      !  stdout.text("Plots based on data used for fitting")
      !  stdout.text("====================================")

      !  .put_GOF_vs_STL_plot(.xray_data)
      !  .put_GOF_vs_F_exp_plot(.xray_data)
      !  .put_ratio_vs_STL_plot(.xray_data)
      !  .put_ratio_vs_F_exp_plot(.xray_data)
      !  .put_qq_plot(.xray_data)
         .xray_data.PUT:put_labelled_qq_plot
         .xray_data.PUT:put_F_calc_plots

      end

      ! Reserved data analysis
      if (.xray_r_free_data.allocated) then

      !  stdout.flush
      !  stdout.text("===================================")
      !  stdout.text("Plots based on free (reserved) data")
      !  stdout.text("===================================")

      !  .put_GOF_vs_STL_plot(.xray_data)
      !  .put_GOF_vs_F_exp_plot(.xray_data)
      !  .put_ratio_vs_STL_plot(.xray_data)
      !  .put_ratio_vs_F_exp_plot(.xray_data)
      !  .put_qq_plot(.xray_data)
         .xray_data.PUT:put_labelled_qq_plot("free")
         .xray_data.PUT:put_F_calc_plots("free")

      end

   end

!   put_GOF_vs_STL_plot(data)
!   ! Output the GOF vs. sin(theta)/angle bins
!      self :: INOUT
!      data :: DIFFRACTION_DATA
!      data.PUT:put_GOF_vs_STL_plot
!   end

!   put_GOF_vs_F_exp_plot(data)
!   ! Output the GOF vs. F_pred bins
!      self :: INOUT
!      data :: DIFFRACTION_DATA
!      data.PUT:put_GOF_vs_F_exp_plot
!   end

!   put_ratio_vs_STL_plot(data)
!   ! Output the mean ratio F_obs/F_pred vs. sin(theta)/angle bins
!      self :: INOUT
!      data :: DIFFRACTION_DATA
!      data.put_ratio_vs_STL_plot
!   end

!   put_ratio_vs_F_exp_plot(data)
!   ! Output the GOF vs. F_pred bins
!      self :: INOUT
!      data :: DIFFRACTION_DATA
!      data.put_ratio_vs_F_exp_plot
!   end

!   put_labelled_qq_plot(data,tag)
!   ! Output a qq plot to the text file.
!   ! It is a plot of the experimental quantile vs expected quantile.
!      self :: INOUT
!      data :: DIFFRACTION_DATA
!      tag :: STR, optional, IN
!      data.put_labelled_qq_plot(tag)
!   end

!   put_fcalc_plots(data,tag)
!   ! Output some different plots about the calculated structure factors.
!      self :: INOUT
!      data :: DIFFRACTION_DATA
!      tag :: STR, optional, IN
!      data.put_fcalc_plots(tag)
!   end


!  ====================
!  Residual density map
!  ====================

!   make_inverse_FT_F_calc_ED_grid(map,pts) ::: PURE
!   ! Make the electron density "map" values using an inverse Fourier
!   ! synthesis F_calc values, removing corrections for dispersion,
!   ! corrections for extinction. Friedel pairs are accounted for.
!   ! The supplied points "pts" are in a cartesian system (n_pts x 3)
!      self :: IN
!      map  :: VEC{REAL}, OUT
!      pts  :: MAT{REAL}, IN
!
!   ENSURE(map.dim ==pts.dim1,"wrong dim: map")
!   ENSURE(pts.dim2==3,       "wrong dim2: pts")
!   ENSURE(.xray_data.allocated, "no diffraction data")
!   ENSURE(.xray_data.reflections.allocated, "no structure factors")
!   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
!   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
!   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")
!
!      frac  :: MAT{REAL}@
!      Fc,Fe :: VEC{CPX}@
!      gx,gy,gz :: VEC{INT}@
!      n_pts,n_refl, n,p :: INT
!      xi,yi,zi,den :: REAL
!      ci,val :: CPX
!
!      ! Constants
!      n_pts  = pts.dim1
!      n_refl = .xray_data.reflections.dim*.spacegroup.n_seitz
!      ci     = -2*PI * IMAGIFY(ONE)
!
!      ! Get phased structure factor differences, absolute scale
!      ! And the symmetry generated Miller indices, the g's.
!      gx.create(n_refl)
!      gy.create(n_refl)
!      gz.create(n_refl)
!      Fc.create(n_refl)
!      Fe.create(n_refl)
!      .xray_data.make_symmetry_equivalents(Fc,Fe,gx,gy,gz,.spacegroup)
!      Fe.destroy
!
!      ! Volume factor
!      Fc  = Fc/.unit_cell.volume
!
!      ! Get the fractional coordinates. Hard coded !
!      frac = matmul(pts,.unit_cell.reciprocal_mx)
!
!      ! Make the phases x del F
!      do p = 1,n_pts
!
!         xi = frac(p,1)
!         yi = frac(p,2)
!         zi = frac(p,3)
!
!         ! Assign value
!         den = ZERO
!         do n = 1,n_refl
!            val = ci*(gx(n)*xi + gy(n)*yi + gz(n)*zi)
!            den = den + REALIFY(exp(val)*Fc(n)) ! <--
!         end
!         map(p) = den
!
!      end
!
!      ! Clean
!      gz.destroy
!      gy.destroy
!      gx.destroy
!      Fc.destroy
!
!   end

   make_residual_density_cell(map,nx,ny,nz) ::: PURE
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version need to gather the 1D phases over miller indices.
      self :: IN
      map :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

      ! This version seems fastest
      .make_residual_density_cell_n(map,nx,ny,nz)

   end

   make_residual_density_cell_n(map,nx,ny,nz) ::: PURE
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version uses more memory for the 1D phase arrays.
      self :: IN
      map  :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

   ENSURE(.xray_data.allocated, "no diffraction data")
   ENSURE(.xray_data.reflections.allocated, "no structure factors")
   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")

      ix,iy,iz, n_refl,r,p :: INT
      xi,yi,zi, del :: REAL
      gx,gy,gz,mult :: VEC{INT}@
      phx,phy,phz :: MAT{CPX}@
      dF :: VEC{CPX}@
      ci :: CPX

      ! Constants
      n_refl = .xray_data.reflections.dim*.spacegroup.n_seitz
      ci     = -2*PI * IMAGIFY(ONE)

      ! Multiplicity factor for Friedel-pairs (if any)
      mult.create(.xray_data.reflections.dim)
      if (.spacegroup.centrosymmetric) then
          mult = 2
      else
         .xray_data.reflections.get_all_Friedel_pairs(mult)
      end

      ! Get phased structure factor differences, absolute scale
      ! And P1 expanded symmetry generated h's -> g's .
      dF.create(n_refl)
      gx.create(n_refl)
      gy.create(n_refl)
      gz.create(n_refl)
      .xray_data.SET:make_symop_generated_dF_a_v2(dF,gx,gy,gz,.spacegroup,mult)
      mult.destroy

      ! Volume factor
      dF = dF/.unit_cell.volume

      ! Make the 1D x phases
      phx.create(n_refl,nx)
      del = ONE/(nx-1)
      xi = ZERO
      do ix = 1,nx
         do r = 1,n_refl
            phx(r,ix) = exp(ci*gx(r)*xi)
         end
         xi = xi + del
      end

      ! Make the 1D y phases
      phy.create(n_refl,ny)
      del = ONE/(ny-1)
      yi = ZERO
      do iy = 1,ny
         do r = 1,n_refl
            phy(r,iy) = exp(ci*gy(r)*yi)
         end
         yi = yi + del
      end

      ! Make the 1D z phases
      ! Include SF part in z term
      phz.create(n_refl,nz)
      del = ONE/(nz-1)
      zi = ZERO
      do iz = 1,nz
         zi = (iz-1) * del
         do r = 1,n_refl
            phz(r,iz) = exp(ci*gz(r)*zi) * dF(r) ! <--
         end
         zi = zi + del
      end

      ! Grid point
      p = 0

      ! Make the residual map
      do iz = 1,nz
      do iy = 1,ny
      do ix = 1,nx
         p = p + 1
         map(p) = sum( REALIFY(phx(:,ix)*phy(:,iy)*phz(:,iz)) )
      end
      end
      end

      ! Clean
      phz.destroy
      phy.destroy
      phx.destroy
      gz.destroy
      gy.destroy
      gx.destroy
      dF.destroy

   end

   make_residual_density_grid(grid,pts) ::: PURE
   ! Make the crystal residual error "map" in the unit cell with
   ! the supplied points "pts" in a cartesian system.
   ! NOTE: the pts is (n_pts x 3)
      self :: IN
      grid :: VEC{REAL}, OUT
      pts  :: MAT{REAL}, IN

   ENSURE(grid.dim==pts.dim1,"wrong dim, grid")
   ENSURE(pts.dim2==3,       "wrong dim2, pts")
   ENSURE(.xray_data.allocated, "no diffraction data")
   ENSURE(.xray_data.reflections.allocated, "no structure factors")
   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")

      n_pts,n_refl, r,p :: INT
      gx,gy,gz,mult :: VEC{INT}@
      dF   :: VEC{CPX}@
      frac :: MAT{REAL}@
      xi,yi,zi,den :: REAL
      ci,val :: CPX

      ! Constants
      n_pts  = pts.dim1
      n_refl = .xray_data.reflections.dim*.spacegroup.n_seitz
      ci     = -2*PI * IMAGIFY(ONE)

      ! Multiplicity factor for Friedel-pairs (if any)
      mult.create(.xray_data.reflections.dim)
      if (.spacegroup.centrosymmetric) then
          mult = 2
      else
         .xray_data.reflections.get_all_Friedel_pairs(mult)
      end

      ! Get phased structure factor differences, absolute scale
      ! And the symmetry generated Miller indices, the g's.
      dF.create(n_refl)
      gx.create(n_refl)
      gy.create(n_refl)
      gz.create(n_refl)
      .xray_data.SET:make_symop_generated_dF_a_v2(dF,gx,gy,gz,.spacegroup,mult)
      mult.destroy

      ! Volume factor
      dF  = dF/.unit_cell.volume

      ! Get the fractional coordinates. Hard coded !
      frac = matmul(pts,.unit_cell.reciprocal_mx)

      ! Make the phases x del F
      do p = 1,n_pts

         xi = frac(p,1)
         yi = frac(p,2)
         zi = frac(p,3)

         den = ZERO
         do r = 1,n_refl
            val = ci*(gx(r)*xi + gy(r)*yi + gz(r)*zi)
            den = den + REALIFY(exp(val)*dF(r)) ! <--
         end

         ! Assign value
         grid(p) = den

      end

      ! Clean
      gz.destroy
      gy.destroy
      gx.destroy
      dF.destroy

   end

!   make_residual_density_cell_c(map)
!   ! Make the crystal residual error "map" in the unit cell with
!   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
!   ! The "map" array increments first on the x axis, then y, then z
!   ! i.e. it must be compatible with PLOT_GRID:make_points.
!   ! This routine takes advantage of the grid structure for speed.
!   ! This version uses a cube of structure factors.
!      self :: IN
!      map :: MAT3{REAL}, OUT
!
!   ENSURE(.xray_data.allocated, "no diffraction data")
!   ENSURE(.xray_data.reflections.allocated, "no structure factors")
!   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
!   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
!   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")
!
!      n_refl :: INT
!      nx,ny,nz :: INT
!      hx,hy,hz :: INT
!      ix,iy,iz :: INT
!      xi,yi,zi :: REAL
!      fac,del  :: REAL
!      phx,phy,phz :: MAT{CPX}*
!      h_min,h_max :: VEC{INT}(3)
!      dF :: MAT3{CPX}*
!      ci :: CPX
!
!      ! Constants
!      nx = map.dim1
!      ny = map.dim2
!      nz = map.dim3
!      n_refl = .xray_data.reflections.dim
!      ci     = -2*PI * IMAGIFY(ONE)
!
!      ! Maximum Miller indices
!      h_min = .xray_data.reflections.h_min
!      h_max = .xray_data.reflections.h_max
!
!      ! Get phased structure factor differences
!      ! (without extinction, but with scale correction)
!      dF.create(h_min,h_max)
!      .xray_data.make_phased_dF_b(dF)
!
!      ! Prefactor
!      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
!      fac = TWO/.unit_cell.volume
!
!      ! Make the 1D x phases
!      phx.create([h_min(1),h_max(1)],[1,nx])
!      del = ONE/(nx-1)
!      do ix = 1,nx
!      do hx = h_min(1),h_max(1)
!         xi = (ix-1) * del
!         phx(hx,ix) = exp(ci*hx*xi)
!      end
!      end
!
!      ! Make the 1D y phases
!      phy.create([h_min(2),h_max(2)],[1,ny])
!      del = ONE/(ny-1)
!      do iy = 1,ny
!      do hy = h_min(2),h_max(2)
!         yi = (iy-1) * del
!         phy(hy,iy) = exp(ci*hy*yi)
!      end
!      end
!
!      ! Make the 1D z phases
!      phz.create([h_min(3),h_max(3)],[1,nz])
!      del = ONE/(nz-1)
!      do iz = 1,nz
!      do hz = h_min(3),h_max(3)
!         zi = (iz-1) * del
!         phz(hz,iz) = exp(ci*hz*zi) * fac ! <--
!      end
!      end
!
!      ! Do it
!      dF.change_basis_to(map,phx,phy,phz)
!
!      ! Clean
!      phx.destroy
!      phy.destroy
!      phz.destroy
!      dF.destroy
!
!   end

!   make_residual_density_cell_g(map,nx,ny,nz)
!   ! Make the crystal residual error "map" in the unit cell with
!   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
!   ! The "map" array increments first on the x axis, then y, then z
!   ! i.e. it must be compatible with PLOT_GRID:make_points.
!   ! This routine takes advantage of the grid structure for speed.
!   ! This version need to gather the 1D phases over miller indices.
!      self :: IN
!      map :: VEC{REAL}, OUT
!      nx,ny,nz :: INT, IN
!
!   ENSURE(.xray_data.allocated, "no diffraction data")
!   ENSURE(.xray_data.reflections.allocated, "no structure factors")
!   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
!   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
!   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")
!
!      n_refl,r,p :: INT
!      hx,hy,hz :: INT
!      ix,iy,iz :: INT
!      xi,yi,zi :: REAL
!      fac,del,res :: REAL
!      phx,phy,phz :: MAT{CPX}*
!      h_max :: VEC{INT}(3)
!      dF :: VEC{CPX}*
!      ci :: CPX
!
!      ! Constants
!      n_refl = .xray_data.reflections.dim
!      ci     = -2*PI * IMAGIFY(ONE)
!
!      ! Maximum Miller indices
!      h_max = .xray_data.reflections.h_max
!
!      ! Get phased structure factor differences
!      ! (without extinction, but with scale correction)
!      dF.create(n_refl)
!      .xray_data.make_phased_dF_a(dF)
!
!      ! Prefactor
!      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
!      fac = TWO/.unit_cell.volume
!
!      ! Make the 1D x phases
!      phx.create([1,nx],[0,h_max(1)])
!      del = ONE/(nx-1)
!      do hx = 0,h_max(1)
!      do ix = 1,nx
!         xi = (ix-1) * del
!         phx(ix,hx) = exp(ci*hx*xi)
!      end
!      end
!
!      ! Make the 1D y phases
!      phy.create([1,ny],[0,h_max(2)])
!      del = ONE/(ny-1)
!      do hy = 0,h_max(2)
!      do iy = 1,ny
!         yi = (iy-1) * del
!         phy(iy,hy) = exp(ci*hy*yi)
!      end
!      end
!
!      ! Make the 1D z phases
!      phz.create([1,nz],[0,h_max(3)])
!      del = ONE/(nz-1)
!      do hz = 0,h_max(3)
!      do iz = 1,nz
!         zi = (iz-1) * del
!         phz(iz,hz) = exp(ci*hz*zi)
!      end
!      end
!
!
!      ! Grid point
!      p = 0
!
!      ! Make the residual map
!      do iz = 1,nz
!      do iy = 1,ny
!      do ix = 1,nx
!
!         p = p + 1
!
!         res = ZERO
!         do r = 3,n_refl
!            hx = .xray_data.reflections(r).h1
!            hy = .xray_data.reflections(r).h2
!            hz = .xray_data.reflections(r).h3
!            res = res + REALIFY(dF(r)*phx(ix,hx)*phy(iy,hy)*phz(iz,hz))
!         end
!
!         map(p) = fac*res
!
!      end
!      end
!      end
!
!      ! Clean
!      phx.destroy
!      phy.destroy
!      phz.destroy
!      dF.destroy
!
!   end

!   make_residual_density_cell_m(map,nx,ny,nz)
!   ! Make the crystal residual error "map" in the unit cell with
!   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
!   ! The "map" array increments first on the x axis, then y, then z
!   ! i.e. it must be compatible with PLOT_GRID:make_points.
!   ! This routine takes advantage of the grid structure for speed.
!   ! This version uses more memory for the 1D phase arrays.
!      self :: IN
!      map :: VEC{REAL}, OUT
!      nx,ny,nz :: INT, IN
!
!   ENSURE(.xray_data.allocated, "no diffraction data")
!   ENSURE(.xray_data.reflections.allocated, "no structure factors")
!   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
!   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
!   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")
!
!      n_refl,r,p :: INT
!      hx,hy,hz :: VEC{INT}*
!      ix,iy,iz :: INT
!      xi,yi,zi :: REAL
!      fac,del  :: REAL
!      dF, phyz :: VEC{CPX}*
!      phx,phy,phz :: MAT{CPX}*
!      h_max :: VEC{INT}(3)
!      ci :: CPX
!
!      ! Constants
!      n_refl = .xray_data.reflections.dim
!      ci     = -2*PI * IMAGIFY(ONE)
!
!      ! Maximum Miller indices
!      h_max = .xray_data.reflections.h_max
!
!      ! Get phased structure factor differences
!      ! (without extinction, but with scale correction)
!      dF.create(n_refl)
!      .xray_data.make_phased_dF_a(dF)
!
!      ! Prefactor
!      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
!      fac = TWO/.unit_cell.volume
!      dF  = fac * dF
!
!      ! Get h's
!      hx.create(n_refl)
!      hy.create(n_refl)
!      hz.create(n_refl)
!
!      hx = .xray_data.reflections(:).h1
!      hy = .xray_data.reflections(:).h2
!      hz = .xray_data.reflections(:).h3
!
!      ! Make the 1D x phases
!      phx.create(n_refl,nx)
!      del = ONE/(nx-1)
!      do ix = 1,nx
!         xi = (ix-1) * del
!         do r = 1,n_refl
!            phx(r,ix) = exp(ci*hx(r)*xi)
!         end
!      end
!
!      ! Make the 1D y phases
!      phy.create(n_refl,ny)
!      del = ONE/(ny-1)
!      do iy = 1,ny
!         yi = (iy-1) * del
!         do r = 1,n_refl
!            phy(r,iy) = exp(ci*hy(r)*yi)
!         end
!      end
!
!      ! Make the 1D z phases
!      phz.create(n_refl,nz)
!      del = ONE/(nz-1)
!      do iz = 1,nz
!         zi = (iz-1) * del
!         do r = 1,n_refl
!            phz(r,iz) = exp(ci*hz(r)*zi) * dF(r) ! <--
!         end
!      end
!
!
!      ! Grid point
!      p = 0
!
!      ! Make the residual map
!      phyz.create(n_refl)
!
!      do iz = 1,nz
!      do iy = 1,ny
!
!         phyz = phy(:,iy)*phz(:,iz)
!
!         do ix = 1,nx
!        
!            p = p + 1
!            map(p) = sum( REALIFY(phx(:,ix)*phyz(:)) )
!        
!         end
!
!      end
!      end
!
!      ! Clean
!      phyz.destroy
!      phz.destroy
!      phy.destroy
!      phx.destroy
!      hz.destroy
!      hy.destroy
!      hx.destroy
!      dF.destroy
!
!   end

!   make_residual_density_cell_p(map,nx,ny,nz)
!   ! Make the crystal residual error "map" in the unit cell with
!   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
!   ! The "map" array increments first on the x axis, then y, then z
!   ! i.e. it must be compatible with PLOT_GRID:make_points.
!   ! This routine takes advantage of the grid structure for speed.
!   ! This version uses a 2D phase array and reduced multiplication.
!      self :: IN
!      map :: VEC{REAL}, OUT
!      nx,ny,nz :: INT, IN
!
!   ENSURE(.xray_data.allocated, "no diffraction data")
!   ENSURE(.xray_data.reflections.allocated, "no structure factors")
!   ENSURE(.xray_data.INQ:have_F_calc, "no calculated structure factors")
!   ENSURE(.xray_data.INQ:have_F_pred, "no predicted structure factors")
!   ENSURE(.xray_data.INQ:have_F_exp, "no experimental structure factors")
!
!      n_refl,r,p :: INT
!      hx,hy,hz :: VEC{INT}*
!      ix,iy,iz :: INT
!      xi,yi,zi :: REAL
!      fac,del  :: REAL
!      dF, phyz :: VEC{CPX}*
!      phx,phy,phz :: MAT{CPX}*
!      ph2 :: MAT3{CPX}*
!      h_max :: VEC{INT}(3)
!      ci :: CPX
!
!      ! Constants
!      n_refl = .xray_data.reflections.dim
!      ci     = -2*PI * IMAGIFY(ONE)
!
!      ! Maximum Miller indices
!      h_max = .xray_data.reflections.h_max
!
!      ! Get phased structure factor differences
!      ! (without extinction, but with scale correction)
!      dF.create(n_refl)
!      .xray_data.make_phased_dF_a(dF)
!
!      ! Prefactor
!      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
!      fac = TWO/.unit_cell.volume
!
!      ! Get h's
!      hx.create(n_refl)
!      hy.create(n_refl)
!      hz.create(n_refl)
!
!      hx = .xray_data.reflections(:).h1
!      hy = .xray_data.reflections(:).h2
!      hz = .xray_data.reflections(:).h3
!
!      ! Allocate the 2D phase array
!      ph2.create(n_refl,ny,nz)
!
!      ! Make the 1D z phases
!      phz.create(n_refl,nz)
!      del = ONE/(nz-1)
!      do iz = 1,nz
!         zi = (iz-1) * del
!         do r = 1,n_refl
!            phz(r,iz) = exp(ci*hz(r)*zi)
!         end
!      end
!
!      ! Make the 1D y phases
!      phy.create(n_refl,ny)
!      del = ONE/(ny-1)
!      do iy = 1,ny
!         yi = (iy-1) * del
!         do r = 1,n_refl
!            phy(r,iy) = exp(ci*hy(r)*yi)
!         end
!      end
!
!      ! Make the 2D array
!      do iz = 1,nz
!      do iy = 1,ny
!         do r = 1,n_refl
!            ph2(r,iy,iz) = phy(r,iy)*phz(r,iz)
!         end
!      end
!      end
!
!      ! Clean
!      phy.destroy
!      phz.destroy
!
!      ! Make the 1D x phases
!      phx.create(n_refl,nx)
!      del = ONE/(nx-1)
!      do ix = 1,nx
!         xi = (ix-1) * del
!         do r = 1,n_refl
!            phx(r,ix) = exp(ci*hx(r)*xi) * dF(r) * fac
!         end
!      end
!
!
!      ! Grid point
!      p = 0
!
!      ! Make the residual map
!      do iz = 1,nz
!      do iy = 1,ny
!
!         phyz => ph2(:,iy,iz)
!
!         do ix = 1,nx
!        
!            p = p + 1
!            map(p) = sum( REALIFY(phx(:,ix)*phyz) )
!        
!         end
!
!      end
!      end
!
!      ! Clean
!      phx.destroy
!      ph2.destroy
!      hz.destroy
!      hy.destroy
!      hx.destroy
!      dF.destroy
!
!   end

!  ===========================
!  Cluster generation routines
!  ===========================

   make_asym_unit_HS_cluster(HS_atoms,tol) ::: leaky
   ! Generating a "HS_atoms" cluster from information useful for
   ! calculating the HS of the asymmetric unit, to an accuracy "tol".
      self     :: INOUT
      HS_atoms :: VEC{ATOM}@, OUT
      tol      :: REAL, IN

      .set_generation_method("for_hirshfeld_surface")
      .set_atom_density_cutoff(tol)
      .set_defragment(FALSE)
      .make_cluster_info
      .create_atom_list(HS_atoms)

   end

!  ===========================
!  Cluster generation routines
!  ===========================

   make_cluster_info ::: leaky
   ! Make all the cluster information from an arbitrary .fragment_geometry.
   ! NOTE: .set_defaults must be called before this.
      self :: INOUT

   ENSURE(.unit_cell_connection.allocated,"no unit cell connection table")
   ENSURE(.fragment_geometry.allocated,"no fragment_geometry")

      if (.cluster_info_made) return

      ! Depending on the generation_method, make starting cluster
      .make_occupation_list

      ! Generate the cluster
      select case (.generation_method)

      case ("within_radius")
         .make_within_radius

      case ("for_hirshfeld_surface")
         .make_HS_radius     ! NOT PURE
         .make_within_radius
         .defragment = FALSE

      case ("for_unit_cell_density")
       ! .do_defragment
         .make_HS_radius     ! NOT PURE
         .make_within_radius
         .defragment = TRUE

      case ("offset_unit_cell_density")
         .make_HS_radius     ! NOT PURE
         .make_within_radius
         .defragment = FALSE

      end

      ! Defragment/find molecules in the cluster
      if (.defragment) then; .do_defragment
      else;                  .do_connectify
      end

      ! Extract cordinates from occupation list
      if (.reorder_in_mols) then
         ! In molecule order
         .extract_geometry_in_mols(.occupation_list,.geometry)
      else
         ! The fragment atoms come first ...
         .extract_geometry_no_mols(.occupation_list,.geometry)
      end

      ! Finished ...
      .cluster_info_made = TRUE

   end

   make_occupation_list ::: leaky, PURE
   ! Codify which atoms in the crystal are fragment atoms i.e. make
   ! the ".occupation_list". If atom "u" in the unit cell "(h1,h2,h3)"
   ! is occupied then the macro CLUSTER_AT_CODE(h1,h2,h3,u) appears in
   ! the array "list". The maximum value allowed for any h is
   ! CLUSTER_H_MAX i.e. we can't consider fragments atoms which lie in
   ! cells outside this range. This list allows easy comparison of
   ! which atoms are in the fragment by an integer equality test.
   ! NOTE: Also make the ".molecule_for_atom" list which tells which
   ! molecule the atom belongs to.
      self :: INOUT

   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell")
   ENSURE(.fragment_geometry.allocated,"no fragment_geometry")

      h :: VEC{INT}(3)
      pos :: VEC{REAL}(3)
      f,u,h000 :: INT
      fragment_geometry :: MAT{REAL}@

      select case (.generation_method)

      case ("within_radius","for_hirshfeld_surface","fragment")

         ENSURE(.fragment_geometry.allocated,"no fragment_geometry")
         ENSURE(.fragment_info_made,"no crystal fragment info")
         ENSURE(.unit_cell_atom_for_frag_atom.allocated,"no cell-frag_atom array")
         ENSURE(.unit_cell_shft_for_frag_atom.allocated,"no cell-frag_atom array")

         ! Get fragment offset i.e. center
         pos = .fragment_geometry.mean_column_vector
         .fragment_offset = int(pos)

         ! Create occupation list
         .occupation_list.destroy
         .occupation_list.create(.n_fragment_atoms)

         ! Loop on fragment atom
         do f = 1,.n_fragment_atoms

            ! Get unit cell atom & shift
            u = .unit_cell_atom_for_frag_atom(f)
            h = .unit_cell_shft_for_frag_atom(:,f)

            ! Shift relative to recentered unit cell
            h = h + .fragment_offset

            ! Check if we can store these h's in a bit string
            ENSURE(all(h>=-CLUSTER_H_MAX),"frag too wide, h = "//trim(h.to_concatenated_str))
            ENSURE(all(h<= CLUSTER_H_MAX),"frag too wide, h = "//trim(h.to_concatenated_str))

            ! Sanity check
            ENSURE(u/=0,"position of fragment atom "//f.to_str.trim//" not found in unit cell")
          ! if (u==0) then
          !    WARN("position of fragment atom "//f.to_str.trim//" not found in unit cell")
          !    stdout.show("fragment pos =",pos)
          !    stdout.text("unit cell geometry:")
          !    stdout.put(transpose(.unit_cell_geometry))
          !    DIE("position of fragment atom "//f.to_str.trim//" not found in unit cell")
          ! end

            ! Offset h to apply to "u" to get frag atom "f".
            ! Must reverse h. See above.
            h = -h

            ! Get occ code ...
            .occupation_list(f) = CLUSTER_AT_CODE(h(1),h(2),h(3),u)

         end

      case ("unit_cell","for_unit_cell_density")

         ! Create occupation list
         .occupation_list.destroy
         .occupation_list.create(.n_unit_cell_atoms)

         ! Temporary
         fragment_geometry.create(3,.n_unit_cell_atoms)

         ! Set central cell
         h000 = CLUSTER_H_CODE(0,0,0)

         do u = 1,.n_unit_cell_atoms

            ! Encode central cell
            .occupation_list(u) = h000 + CLUSTER_UA_CODE(u)

            ! Set fragment to unit cell
            pos = .unit_cell_geometry(:,u)
            fragment_geometry(:,u) = pos

         end

         ! Set fragment and make sure there is no offset
         .set_fragment_geometry(fragment_geometry)
         .fragment_offset = 0

         ! Clean
         fragment_geometry.destroy

    ! case ("unit_cell_plus","for_unit_cell_density")

    !    ! Create occupation list
    !    .occupation_list.destroy
    !    .occupation_list.create(.n_unit_cell_atoms)

    !    ! Temporary
    !    fragment_geometry.create(3,.n_unit_cell_atoms)

    !    ! Set central cell
    !    h000 = CLUSTER_H_CODE(0,0,0)

    !    do u = 1,.n_unit_cell_atoms

    !       ! Encode central cell
    !       .occupation_list(u) = h000 + CLUSTER_UA_CODE(u)

    !       ! Set fragment to unit cell
    !       pos = .unit_cell_geometry(:,u)
    !       fragment_geometry(:,u) = pos

    !    end

    !    ! Set fragment and make sure there is no offset
    !    .set_fragment_geometry(fragment_geometry)
    !    .fragment_offset = 0

    !    ! Clean
    !    fragment_geometry.destroy

    !    ! Go two angstrom from unit cell edges for unit cell densities
    !    ! if the setting is "for_unit_cell_density"
    !    two_angstrom = TWO
    !    two_angstrom = two_angstrom.from_units("angstrom")
    !    if (.generation_method=="unit_cell_plus") then; radius = .radius
    !    else;                                           radius = max(TWO,.radius)
    !    end

    !    ! Fractions "b" along cell axes; and complements "t"
    !    b = radius/.unit_cell.length
    !    DIE_IF(any(b>ONE),"radius around unit cell exceeds at least one cell dimension")
    !    t = ONE - b

    !    ! Unit cell code
    !    uc = 0

    !    do u = 1,.n_unit_cell_atoms

    !       pos = .unit_cell_geometry(:,u)

    !       uc = CLUSTER_UA_CODE(u)

    !       ! FIX h1
    !       if (pos(1)<b(1)) .occupation_list.append(CLUSTER_H_CODE( 1, 0, 0)+uc)
    !       if (pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE( 0, 1, 0)+uc)
    !       if (pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 0, 1)+uc)
    !       if (pos(1)>t(1)) .occupation_list.append(CLUSTER_H_CODE(-1, 0, 0)+uc)
    !       if (pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE( 0,-1, 0)+uc)
    !       if (pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 0,-1)+uc)

    !       if (pos(1)<b(1) AND pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE( 1, 1, 0)+uc)
    !       if (pos(1)<b(1) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 0, 1)+uc)
    !       if (pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 1, 1)+uc)
    !       if (pos(1)>t(1) AND pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE(-1, 1, 0)+uc)
    !       if (pos(1)>t(1) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 0, 1)+uc)
    !       if (pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0,-1, 1)+uc)
    !       if (pos(1)<b(1) AND pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE( 1,-1, 0)+uc)
    !       if (pos(1)<b(1) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 0,-1)+uc)
    !       if (pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 1,-1)+uc)
    !       if (pos(1)>t(1) AND pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE(-1,-1, 0)+uc)
    !       if (pos(1)>t(1) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 0,-1)+uc)
    !       if (pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0,-1,-1)+uc)

    !       if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 1, 1)+uc)
    !       if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 1, 1)+uc)
    !       if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1,-1, 1)+uc)
    !       if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1,-1, 1)+uc)
    !       if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 1,-1)+uc)
    !       if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 1,-1)+uc)
    !       if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1,-1,-1)+uc)
    !       if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1,-1,-1)+uc)

    !    end

    ! case ("offset_unit_cell","offset_unit_cell_density")

    !    ! Create occupation list
    !    .occupation_list.destroy
    !    .occupation_list.create(.n_unit_cell_atoms)

    !    ! Temporary
    !    fragment_geometry.create(3,.n_unit_cell_atoms)

    !    do u = 1,.n_unit_cell_atoms

    !       ! Unit cell position
    !       pos = .unit_cell_geometry(:,u)

    !       ! Set central cell
    !       h = 0

    !       ! Apply the offset
    !       if (pos(1)<    .unit_cell_offset(1)) h(1) = +1
    !       if (pos(2)<    .unit_cell_offset(2)) h(2) = +1
    !       if (pos(3)<    .unit_cell_offset(3)) h(3) = +1
    !       if (pos(1)>ONE+.unit_cell_offset(1)) h(1) = -1
    !       if (pos(2)>ONE+.unit_cell_offset(2)) h(2) = -1
    !       if (pos(3)>ONE+.unit_cell_offset(3)) h(3) = -1

    !       ! Get occ code ...
    !       .occupation_list(u) = CLUSTER_AT_CODE(h(1),h(2),h(3),u)

    !       ! Set frag geometry with offset
    !       fragment_geometry(:,u) = pos + h

    !    end

    !    ! Set fragment and make sure there is no offset
    !    .set_fragment_geometry(fragment_geometry)
    !    .fragment_offset = 0

    !    ! Clean
    !    fragment_geometry.destroy

    ! case default
    !    UNKNOWN(.generation_method)

      end

   end

   make_plot_info(pt,parent,symop,shifts) ::: leaky, PURE
   ! Make ".occupation_list" i.e. the CLUSTER_AT_CODE(h1,h2,h3,u)'s
   ! for the list of atoms in the crystal within a distance ".radius"
   ! of the set of points in "pt" (usually generated from "plot_grid"
   ! via the "make_points(pt)" routine, but not necessarily.
   ! NOTE: Also make the ".molecule_for_atom" list which tells which
   ! molecule the atom belongs to.
      self :: INOUT
      pt :: MAT{REAL}, IN
      parent :: VEC{INT}@, OUT
      symop  :: VEC{INT}@, OUT
      shifts  :: MAT{INT}@, OUT

   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell")
   ENSURE(.fragment_geometry.allocated,"no fragment_geometry")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.unit_cell_atom_for_frag_atom.allocated,"no cell-frag_atom array")
   ENSURE(.unit_cell_shft_for_frag_atom.allocated,"no cell-frag_atom array")


      dcm :: MAT{REAL}(3,3)
      ucc :: MAT{REAL}@
      h :: VEC{INT}(3)
      uc_mol :: VEC{INT}@
      pos,shift :: VEC{REAL}(3)
      vdw_radius :: VEC{REAL}@
      vdw,d2 :: REAL
      p, i,j,k,u, code, s,f :: INT
      found :: BIN

      ! Create occupation list
      .occupation_list.destroy
      .occupation_list.create(0)

      ! Set up the van der Waals radii, for the limits of
      ! interaction.
      vdw_radius.create(.n_unit_cell_atoms)
      .unit_cell_atom.get_vdw_radii_ccdc(vdw_radius)
      
      ! Have a cartesian unit cell, and add the unit cell length to
      ! each direction before each iteration.
      dcm = .unit_cell.direct_mx
      ucc = matmul(dcm,.unit_cell_geometry) ! This is (3 x N)

      ! Loop over 27 unit cells
      do k = -1,1
      do j = -1,1
      do i = -1,1
         
         h = [i,j,k]

         ! Create the unit cell molecule list for this shift
         uc_mol.create(0)
         uc_mol = ZERO

         ! Shift the unit cell geometry to a different unit cell
         ! This should shift the atomic cartesian coordinates to
         ! the relevant unit cell
         shift = matmul(dcm,h)
         do u = 1, ucc.dim2
            ucc(:,u) = ucc(:,u) + shift
         end do
         
         ! Cycle through every coordinate in the cartesian unit
         ! cell
         do u = 1, ucc.dim2

            f = .frag_parent_for_cell_atom(u)

            ! Check to see if that point has already been found
            found = FALSE

            if (any(.unit_cell_mol_for_atom(u) == uc_mol)) then
               found = TRUE
               exit
            end
            if (found) cycle

            vdw = vdw_radius(u)
            pos = ucc(:,u)

            do p = 1, pt.dim1 
               
               ! Cycle if it is outside the range of the point
               if (abs(pos(1) - pt(p,1)) > vdw) cycle 
               if (abs(pos(2) - pt(p,2)) > vdw) cycle 
               if (abs(pos(3) - pt(p,3)) > vdw) cycle 
          
               ! Final check - actual distance
               d2 = (pos(3)-pt(p,3))**2 + (pos(2)-pt(p,2))**2 + (pos(1)-pt(p,1))**2
               if (d2 > vdw*vdw) cycle 
            
               ! If you reach this point, your point should be added
               ! to the occupation list. Must first convert back to
               ! bitwise h code.  h(1) = i, h(2) = j and h(3) = k.
               ! NOTE: u should be the atom code, but it is possible
               ! this will be incorrect
            
               ! Get occ code ...
               code = CLUSTER_AT_CODE(i,j,k,u)
               .occupation_list.append(code)

               ! If it is in the occupation list, then it is done, and
               ! the next atom can be checked
               found = TRUE

               exit
          
            end do

            if (found) then
                f = .frag_parent_for_cell_atom(u)
                s = .asym_symop_for_unit_cell_atom(u)
                ! Symop type info here? Somehow?
                parent.append(f)
                symop.append(s)
                shifts.append_column(h)
                uc_mol.append(.unit_cell_mol_for_atom(u))
            end
             
         end
         
         ! Undoes the unit cell geometry to a different unit cell
         ! This should shift the atomic cartesian coordinates back
         ! to the initial unit cell coordinates
         do u = 1, ucc.dim2
            ucc(:,u) = ucc(:,u) - shift
         end

         ! Destroy the unit cell molecules, so a fresh list is
         ! available for the next cell
         uc_mol.destroy

      end
      end
      end

      ucc.destroy
      vdw_radius.destroy

   end

   make_HS_radius
   ! This routine makes an appropriate value for the cluster .radius
   ! in the case where the .generation_method is "for_hirshfeld_surface". 
   ! The radius is made so that the accuracy of any atomic term
   ! neglected is smaller than .atom_density_cutoff. The radius is
   ! defined to the nearest 0.02 bohr (or whatever is set as the
   ! default for the interpolator table spacing). Likewise, we can't
   ! cope with atom density cutoffs where the distances are larger
   ! than 30 bohr (or whatever is set as the default interpolator
   ! table length). To do this properly we'd have to solve numerical
   ! equations for exactly where the atom density equals the desired
   ! cutoff; that seems like too much effort.
      self :: INOUT

   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric cell atoms")
   ENSURE(.asymmetric_unit_atom.has_all_bases,"incomplete atom bases")
   ENSURE(.atom_density_cutoff>ZERO,"atom density cutoff must be positve")

      .radius = .asymmetric_unit_atom.max_interpolator_table_length(.atom_density_cutoff)

   end

   make_within_radius ::: leaky, PURE
   ! Make the maximum unit cell offsets so that we get all atoms within a
   ! certain radius of the fragment geometry.
      self :: INOUT

   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.fragment_geometry.allocated,"no fragment_geometry")
   ENSURE(.unit_cell_geometry.allocated,"no crystal unit_cell_geometry")

      geom0,frag :: MAT{REAL}@
      rcm :: MAT{REAL}(3,3)
      pos,off,d,frac_radius :: VEC{REAL}(3)
      hlist,ulist,match :: VEC{INT}@
      uskip :: VEC{BIN}@
      d2,radius2 :: REAL
      within_radius,has_frag_atoms,offset :: BIN
      has_atoms_to_suppress   :: BIN
      n_unit_cell_atoms, k,u  :: INT
      h0,h1,h2,h3, hcode,code :: INT

      ! Constants
      n_unit_cell_atoms = .n_unit_cell_atoms
      radius2           = .radius*.radius
      rcm               = .unit_cell.direct_mx

      ! Suppres some atoms?
      has_atoms_to_suppress = .unit_cell_atoms_to_suppress.allocated
      if (has_atoms_to_suppress) has_atoms_to_suppress = .unit_cell_atoms_to_suppress.dim > 0

      ! Cartesian fragment geometry
      frag.create(3,.n_fragment_atoms)
      frag.to_product_of(rcm,.fragment_geometry)

      ! Calculate offset to fragment
      offset = any(.fragment_offset/=0)
      if (offset) then
         off.to_product_of(rcm,REALIFY(.fragment_offset))
      end

      ! Look this many cells away for cluster atoms ...
      frac_radius = .radius/.unit_cell.length
      .h_max = ceiling( frac_radius+maxval(.fragment_geometry,dim=2) - .fragment_offset)
      .h_min =   floor(-frac_radius+minval(.fragment_geometry,dim=2) - .fragment_offset)

      ! Look at least one cell away ...
      .h_max = max(.h_max,[ 1, 1, 1])
      .h_min = min(.h_min,[-1,-1,-1])

      ! Maximum value of unit cell index
      ! and offset for unit cell coding
      h0 = CLUSTER_H_MAX
      ENSURE(all(.h_min>=-h0),"search too low,  h_min = "//trim(.h_min.to_concatenated_str))
      ENSURE(all(.h_max<= h0),"search too high, h_max = "//trim(.h_max.to_concatenated_str))

      ! Get the (0,0,0) unit cell offset by .fragment_offset in cartesians
      geom0.create(3,n_unit_cell_atoms)
      geom0.to_product_of(rcm,.unit_cell_geometry)
      if (offset) &
      geom0 = geom0 + spread(off,2,n_unit_cell_atoms)

      ! Cells which fragment occupies
      match.create(.n_fragment_atoms)
      hlist.create(.n_fragment_atoms)
      hlist = CLUSTER_HC_FROM_CODE(.occupation_list)

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_fragment_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Skip fragment atoms in a particular unit cell
      uskip.create(n_unit_cell_atoms)

      ! Loop over allowed cells
      do h1 = .h_min(1),.h_max(1)
      do h2 = .h_min(2),.h_max(2)
      do h3 = .h_min(3),.h_max(3)

         ! Get cell displacement vector if needed
         off = matmul(rcm,REALIFY(([h1,h2,h3])))

         ! Get list of atoms in "match" which are in this cell
         hcode = CLUSTER_H_CODE(h1,h2,h3)
         match = hlist.indices_of_elements_matching(hcode)

         ! Are there any fragment atoms in this cell?
         ! Set the unit cell atoms corresponding to them
         has_frag_atoms = match.dim>0
         if (has_frag_atoms) then
            uskip = FALSE
            do k = 1,match.dim
               uskip(ulist(match(k))) = TRUE
            end
         end

         ! Loop over unit cell atoms 
         do u = 1,n_unit_cell_atoms

            ! Skip fragment atoms?
            if (has_frag_atoms) then
               if (uskip(u)) cycle
            end

            if (has_atoms_to_suppress) then
              if (any(.unit_cell_atoms_to_suppress == u)) cycle
            end

            ! Position of cell atom u in [h1,h2,h3] cell
            pos = geom0(:,u) + off

            ! Test if this atom pos is within .radius
            within_radius = FALSE
            do k = 1,.n_fragment_atoms

               d = frag(:,k) - pos

               ! Sequentially eliminate far points
               if (abs(d(1))>.radius) cycle
               if (abs(d(2))>.radius) cycle
               if (abs(d(3))>.radius) cycle

               ! Don't use square root
               d2 = d(1)*d(1) + d(2)*d(2) + d(3)*d(3)
               if (d2>radius2) cycle

               within_radius = TRUE
               exit

            end

            if (NOT within_radius) cycle

            ! New atom ... add it in ...
            code = hcode + CLUSTER_UA_CODE(u)
            .occupation_list.append(code)

         end

         ! Clean
         match.destroy

      end
      end
      end

      ! Clean
      uskip.destroy
      ulist.destroy
      hlist.destroy
      geom0.destroy
      frag.destroy

   end

   do_connectify ::: leaky, PURE
   ! Find the connected molecules in the "occupation_list" from the
   ! .unit_cell_connection table.
      self :: INOUT

   ENSURE(.unit_cell_connection.allocated,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      molecule_for_atom :: VEC{INT}@
      con :: VEC{INT}@

      ! No. of atoms
      .n_atoms = .occupation_list.dim

      ! Clear info arrays
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      ! Assume every atom it's own molecule
      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
         molecule_for_atom(i) = i
      end

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Finished atoms "i"?
         if (i>.n_atoms) exit

         ! Info about atom "i"
         mi   = molecule_for_atom(i)       ! Molecule "mi" for i
         code = .occupation_list(i)        ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections? next ...
         if (.unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset for atom "i"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Find atoms which connect to u
         do c = 1,.unit_cell_connection(u).element.dim

            ! List of connections
            con = .unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = .occupation_list.index_of_value(code)

            if (old>0) then

               ! This is an old (found) atom. Replace the molecule
               ! index by the lower of  "mi" and "mo" everywhere.
               mo = molecule_for_atom(old)
               if (mo<mi) then
                  where (molecule_for_atom==mi) molecule_for_atom = mo
                  mi = mo
               else if (mo>mi) then
                  where (molecule_for_atom==mo) molecule_for_atom = mi
               end

               ! Atom "old" is connection to "i"
               .atom_connection(i).element.append(old)

            end

         end ! connections to u

      end ! atoms "i"

      ! Set (sorted) molecule index array
      .molecule_for_atom = molecule_for_atom

      ! Make molecule info
      .make_molecule_info

   end

   do_defragment ::: leaky, PURE
   ! Defragment the generated cluster and find the connected molecules
   ! using the .unit_cell_connection table.
      self :: INOUT

   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.unit_cell_connection.allocated,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      molecule_for_atom :: VEC{INT}@
      con :: VEC{INT}@

      ! Initial no. of atoms
      .n_atoms = .occupation_list.dim

      ! Clear info arrays
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      ! Assume every atom it's own molecule
      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
         molecule_for_atom(i) = i
      end

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Any more atoms to connect?
         if (i>.n_atoms) exit

         ! Info about atom "i"
         mi   = molecule_for_atom(i)       ! Molecule "mi" for i
         code = .occupation_list(i)        ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections to this atom? next ...
         if (.unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset for atom "i"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Loop on atoms "c" connected to "u"
         do c = 1,.unit_cell_connection(u).element.dim

            ! List of connections
            con = .unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = .occupation_list.index_of_value(code)

            if (old>0) then

               ! This is an old (found) atom. Replace the molecule
               ! index by the lower of  "mi" and "mo" everywhere.
               mo = molecule_for_atom(old)
               if (mo<mi) then
                  where (molecule_for_atom==mi) molecule_for_atom = mo
                  mi = mo
               else if (mo>mi) then
                  where (molecule_for_atom==mo) molecule_for_atom = mi
               end
               .atom_connection(i).element.append(old)

            else

               ! This is a new atom. Increment no. of atoms,
               ! store in the occ list and add new connection.
               .occupation_list.append(code)
               molecule_for_atom.append(mi)
               .n_atoms = .n_atoms + 1
               .atom_connection.expand(.n_atoms)
               .atom_connection(i).element.append(.n_atoms)

            end

         end

      end

      ! Set (sorted) molecule index array
      .molecule_for_atom = molecule_for_atom

      ! Make molecule info
      .make_molecule_info

   end

   do_defragment(occupation_list) ::: leaky, PURE
   ! Defragment the "occupation_list"
      self :: IN
      occupation_list :: VEC{INT}@, INOUT

   ENSURE(occupation_list.allocated,"no occupation_list")
   ENSURE(.unit_cell_connection.allocated,"no unit cell connection table")

      n_atoms,i,c,code,h1,h2,h3,u,k1,k2,k3,t,old :: INT
      con :: VEC{INT}@

      ! Initial no. of atoms
      n_atoms = occupation_list.dim

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Any more atoms to connect?
         if (i>n_atoms) exit

         ! Info for atom "i"
         code = occupation_list(i)         ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections to this atom? next ...
         if (.unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Loop on atoms "c" connected to "u"
         do c = 1,.unit_cell_connection(u).element.dim

            ! List of connections
            con = .unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = occupation_list.index_of_value(code)

            if (old>0) cycle ! if old

            ! This is a new atom. Increment no. of atoms,
            ! store in the occ list.
            occupation_list.append(code)
            n_atoms = n_atoms + 1

         end

      end

   end

   do_defragment_uc_atom(u,geometry) ::: leaky, PURE
   ! Defragment a single atom "u" in the unit cell and produce a
   ! "geometry" in crystal coordinates.
      self :: IN
      u    :: INT, IN
      geometry :: MAT{REAL}@, OUT

      occupation_list :: VEC{INT}@

      ! Creat one-atom occ list
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment and extract geometry
      .do_defragment(occupation_list)
      .extract_geometry(occupation_list,geometry)

      ! Clean
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,mass) ::: leaky, PURE
   ! Defragment a single atom "u" in the unit cell and produce the
   ! "symop" (index) which maps the asymmetric parent-atom "par" into
   ! "u", the *list* of cartesian positions in "pos",  and the list of
   ! corresponding atomic masses in "mass".  Needed for LFF refractive
   ! index calculations.
      self :: IN
      u :: INT, IN
      symop :: INT, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass   :: VEC{REAL}, OUT

      occupation_list :: VEC{INT}@

      ! Get symop for cell atom "u"
      symop = .asym_symop_for_unit_cell_atom(u)

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the info
      .do_defragment(occupation_list)
      .extract_atom_info(occupation_list,par,pos,mass)

      ! Clean up
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,pos,charge,dipole,frag_atom) ::: leaky, PURE
   ! Defragment a single atom "u" in the unit cell and extract
   ! *cartesian* atom positions "pos", the atomic charges and dipoles
   ! "charge" and "dipole" in a *flat* array, and the frag atom for
   ! the atoms.  These properties are requited for LFF refractive
   ! index calculations.
      self :: IN
      u :: INT, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, optional, OUT

      occupation_list :: VEC{INT}@

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the info
      .do_defragment(occupation_list)
      .extract_atom_info(occupation_list,pos,charge,dipole,frag_atom)

      ! Clean up
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m) ::: leaky, PURE
   ! Defragment a single atom "u" in the unit cell and for the
   ! *molecule* produce the "symop" (3x3 matrix) which maps "u" into
   ! the *last* asymmetric parent-atom "par" in the *list* of
   ! defragged cartesian positions in "pos", the atomic "charge",
   ! "mass", and "dipole", and the atomic charge and dipole
   ! polarizabilities "alpha_q" and "alpha_m".
   ! NOTE: symop matrix seems strange cf. routine above.
      self :: IN
      u :: INT, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

      occupation_list :: VEC{INT}@

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the *molecule* info
      .do_defragment(occupation_list)
      .extract_molecule_atom_info(occupation_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)

      ! Clean up
      occupation_list.destroy

   end

   make_molecule_info ::: private, leaky, PURE
   ! Sort the cluster into molecules whose indices appear in ascending
   ! order; also store the atom indices in each molecule.
      self :: INOUT

   ENSURE(.molecule_for_atom.allocated,"no molecule_for_atom")

      unique :: VEC{INT}@
      mi,mj, a,m :: INT

      ! Get molecule indices & sort ascdending
      unique.to_unique_elements_of(.molecule_for_atom)
      unique.sort

      ! Number of molecules in cluster
      .n_molecules = unique.dim

      ! Put .molecule_for_atom into ascending order
      do mi = 1,.n_molecules
         mj = unique(mi)
         if (mj==mi) cycle
         where (.molecule_for_atom==mj) .molecule_for_atom = mi
      end

      ! Clean
      unique.destroy

      ! Now make the molecule list
      .molecule.create(.n_molecules)
      do a = 1,.n_atoms
         m = .molecule_for_atom(a)
         .molecule(m).element.append(a)
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (.defragment) .make_unique_molecule_info
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   end

   make_unique_molecule_info ::: private, leaky, PURE
   ! Sort the cluster molecules so that the atom order in
   ! each is consistent. This only works for defragmented
   ! clusters.
      self :: INOUT

   ENSURE(.molecule_for_atom.allocated,"no molecule_for_atom")

      li,lj :: VEC{INT}@
      ci,cj,ui,uj,ai,aj :: VEC{INT}@
      permutation, new  :: VEC{INT}@
      mi,mj, ni, s,si,sj :: INT
      ic,i0,i1,i2,i3 :: INT
      jc,j0,j1,j2,j3 :: INT
      pi,pj,ps :: VEC{REAL}(3)
      shift :: VEC{INT}(3)
      related :: BIN

      ! Clean & get ready
      .unique_molecule_for.destroy
      .unique_molecule_for.create(.n_molecules)
      .unique_symcode_for.destroy
      .unique_symcode_for.create(.n_molecules)

      ! List of unique molecules for each cluster atom
      ! and their relating symops
      .n_unique_molecules     = 0
      .unique_molecule_for    = 0
      .unique_symcode_for     = 0

      ! Make atom-order in each molecule consistent
      do mi = 1,.n_molecules

         ! Processed?
         if (.unique_molecule_for(mi)>0) cycle

         li = .molecule(mi).element
         ni = li.dim

         ai.create(ni)
         ui.create(ni)
         ci.create(ni)

         ci  = .occupation_list(li)
         ui  = CLUSTER_UA_FROM_CODE(ci)
         ai  = .asym_atom_for_unit_cell_atom(ui)
         si  = .asym_symop_for_unit_cell_atom(ui(1))
         si  = .spacegroup.inverse_of_symops(si)

         ic  = ci(1)

         ci.destroy
         ui.destroy

         i0  = CLUSTER_UA_FROM_CODE(ic)
         i1  = CLUSTER_H1_FROM_CODE(ic)
         i2  = CLUSTER_H2_FROM_CODE(ic)
         i3  = CLUSTER_H3_FROM_CODE(ic)
         pi  = .unit_cell_geometry(:,i0) + [i1,i2,i3] + .fragment_offset

         ! Find matching molecules
         do mj = mi+1,.n_molecules

            lj = .molecule(mj).element

            ! Found?
            if (.unique_molecule_for(mj)>0) cycle

            ! Same # on atoms?
            if (lj.dim/=ni) cycle

            aj.create(ni)
            uj.create(ni)
            cj.create(ni)

            cj  = .occupation_list(lj)
            uj  = CLUSTER_UA_FROM_CODE(cj)
            aj  = .asym_atom_for_unit_cell_atom(uj)
            sj  = .asym_symop_for_unit_cell_atom(uj(1))

            cj.destroy
            uj.destroy

            ! Match asym atoms
            permutation.create(ni)
            ai.is_permutation_of(aj,related,permutation)

            if (related) then

               ! New order
               new = lj(permutation)

               ! First atom in mj (matched to mi)
               jc = .occupation_list(new(1))

               ! Position of first atom in mj
               j0 = CLUSTER_UA_FROM_CODE(jc)
               j1 = CLUSTER_H1_FROM_CODE(jc)
               j2 = CLUSTER_H2_FROM_CODE(jc)
               j3 = CLUSTER_H3_FROM_CODE(jc)
               pj = .unit_cell_geometry(:,j0) + [j1,j2,j3] + .fragment_offset

               ! Symop which maps mi->mj
               s = .spacegroup.product_of_symops(sj,si)

               ! Get shift
               ps = pi
               .spacegroup.transform_position(ps,s)

               ps    = pj - ps
               shift = nint(ps)

               ! Unique molecule
               .unique_molecule_for(mj) = mi

               ! New symcode
               .unique_symcode_for(mj) = CLUSTER_AT_CODE(shift(1),shift(2),shift(3),s)
             
               ! Reorder atoms in mj to be consistent with mi
               .occupation_list(lj) = .occupation_list(new)

               ! Reset
               .molecule(mj).element = new 

               new.destroy

            else

               ! Symmetry unique molecule
               .n_unique_molecules      = .n_unique_molecules + 1
               .unique_molecule_for(mi) = .n_unique_molecules

            end

            permutation.destroy
            aj.destroy

         end
            
         ai.destroy

      end

   end

!  ==================================================
!  Extract geometry & info from coded occupation list
!  ==================================================

   extract_geometry_in_mols(occupation_list,geometry) ::: leaky, PURE
   ! Extract the cluster "geometry" (fractional) from an "occupation
   ! list" and place atoms in order of connected molecules.
   ! . Set the .is_fragment_atom flag array
      self :: INOUT
      occupation_list :: VEC{INT}, INOUT
      geometry :: MAT{REAL}@, OUT

   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell geometry")

      a,m,i,code,h1,h2,h3,u :: INT
      atom_connection :: VEC{EVEC{INT}}@
      new_order :: VEC{INT}@
      connected :: BIN

      ! No of atoms to extract
      ! Warning
      .n_atoms = occupation_list.dim

      ! Extracted geometry
      geometry.create(3,.n_atoms)

      ! Clear flags telling if fragment atom
      .is_fragment_atom.destroy
      .is_fragment_atom.create(.n_atoms)
    ! .new_frag_atom_ind.destroy
    ! .new_frag_atom_ind.create(.n_atoms)
    ! .new_frag_atom_ind = 0
    ! .new_frag_atom_ind = [(i,i=1,.n_fragment_atoms)]

      ! New ordering
      new_order.create(.n_atoms)

      a = 0

      ! Loop over molecules
      do m = 1,.n_molecules

          ! Loop over atoms "i"
          do i = 1,.n_atoms

             if (.molecule_for_atom(i)/=m) cycle

             ! Atom index
             a = a + 1
             new_order(i) = a

             ! Get occ code for this atom
             code = occupation_list(i)

             ! Get unit cell atom "u" and cell offset "h"
             h1 = CLUSTER_H1_FROM_CODE(code)
             h2 = CLUSTER_H2_FROM_CODE(code)
             h3 = CLUSTER_H3_FROM_CODE(code)
             u  = CLUSTER_UA_FROM_CODE(code)

             ! Get the cluster atom coordinate !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
             geometry(:,i) = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

             ! Set flag if fragment atom
             if (i<=.n_fragment_atoms) then; .is_fragment_atom(i) = TRUE
             else;                           .is_fragment_atom(i) = FALSE
             end

          end

      end

    ! stdout.text("new order:") ! Kang added 
    ! stdout.put(new_order)	! Kang added ! It prints out the new order up to 169 which is > 16(=#of atoms in the unit cell
      ! Now reorder
      occupation_list(new_order)    = occupation_list
      geometry(:,new_order)         = geometry
      .molecule_for_atom(new_order) = .molecule_for_atom
      .is_fragment_atom(new_order)  = .is_fragment_atom
    ! .new_frag_atom_ind(new_order) = .new_frag_atom_ind !<< Kang's note : Bug here xxxxxxxxxxxxxx

     ! This needs to be here, we must update .molecule to
     ! be in a consistent state with the rest of the object
      .molecule.destroy
      .molecule.create(.n_molecules)
      do a = 1,.n_atoms
         m = .molecule_for_atom(a)
         .molecule(m).element.append(a)
      end

      ! Reorder connection table
      atom_connection.create(.n_atoms)
      do i = 1,.n_atoms
         connected = .atom_connection(i).element.allocated
         if (NOT connected) cycle
         atom_connection(new_order(i)).element = new_order(.atom_connection(i)[:])
      end

      .atom_connection.destroy
      .atom_connection = atom_connection

      ! Clean
      new_order.destroy

   end

   extract_geometry_no_mols(occupation_list,geometry) ::: leaky, PURE
   ! Extract the cluster "geometry" (fractional) from an "occupation
   ! list" and place atoms in order of connected molecules.
   ! . Set the .is_fragment_atom flag array
      self :: INOUT
      occupation_list :: VEC{INT}, INOUT
      geometry :: MAT{REAL}@, OUT

   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell geometry")

      a,m,i,code,h1,h2,h3,u :: INT
      atom_connection :: VEC{EVEC{INT}}@
      connected :: BIN

      ! No of atoms to extract
      .n_atoms = occupation_list.dim

      ! Extracted geometry
      geometry.create(3,.n_atoms)

      ! Clear flags telling if fragment atom
      .is_fragment_atom.destroy
      .is_fragment_atom.create(.n_atoms)

      ! Loop over atoms "i"
      do i = 1,.n_atoms

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom coordinate !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         geometry(:,i) = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

         ! Set flag if fragment atom
         if (i<=.n_fragment_atoms) then; .is_fragment_atom(i) = TRUE
         else;                           .is_fragment_atom(i) = FALSE
         end

      end

   end

   extract_geometry(occupation_list,geometry) ::: leaky, PURE
   ! Extract the geometry (fractional) from an "occupation_list".
      self :: IN
      occupation_list :: VEC{INT}, IN
      geometry :: MAT{REAL}@, OUT

   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell geometry")

      n_atoms,i,code :: INT
      h1,h2,h3,u :: INT

      ! No. of atoms to extract
      n_atoms = occupation_list.dim

      ! Extracted geometry
      geometry.create(3,n_atoms)

      ! Loop over atoms "i"
      do  i = 1,n_atoms

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom coordinate
         geometry(:,i) = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

      end

   end

   extract_atom_info(occupation_list,par,pos,mass) ::: PURE
   ! From a "occupation_list", extract the *cartesian* atom positions
   ! "pos", the index of the asymmetric-parent-atom in "par" and the
   ! atomic "mass" for each atom.
      self :: IN
      occupation_list :: VEC{INT}, IN
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass :: VEC{REAL}, OUT

   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell geometry")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated,"no asym_atom_for_unit_cell_atom")
   ENSURE(.frag_atom_for_unit_cell_atom.allocated,"no frag_atom_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_cell_atom data")
   ENSURE(mass.dim==occupation_list.dim, "mass, wrong size")
   ENSURE(pos.dim1==3 AND pos.dim2==occupation_list.dim, "pos, wrong size")

      i,code,u,h1,h2,h3,p :: INT
      q :: VEC{REAL}(3)

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position (cartesian)
         q = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_mx,q)

         ! Get parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         par(i) = p

         ! Atomic mass
         mass(i) = .asymmetric_unit_atom(p).mass

      end

   end

   extract_atom_info(occupation_list,pos,charge,dipole,frag_atom) ::: PURE
   ! From the "occupation_list", extract the *cartesian* atom
   ! positions "pos", the atomic charges and dipoles "charge" and
   ! "dipole" in a *flat* array, and the frag atom for the atoms.
   ! NOTE:
   ! . All the quantities are available and non-zero.
   ! . "pos" and "dipole" are in the cartesian frame.
   ! WARNING: the asymmetric_unit_atom's should be generated from
   ! the fragment on which the charge and dipole polarisability
   ! calculations (see below) have been done.
      self :: IN
      occupation_list :: VEC{INT}, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, optional, OUT

   ENSURE(.fragment_info_made,"no crystal fragment_info")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(pos.dim1==3 AND pos.dim2==occupation_list.dim, "pos, wrong size")
   ENSURE(charge.dim==occupation_list.dim, "charge, wrong size")
   ENSURE(dipole.dim==3*occupation_list.dim, "dipole, wrong size")

      seitz :: MAT3{REAL}@
      i,l,code,h1,h2,h3,u, p,s :: INT
      q :: VEC{REAL}(3)

      ! Symops
      seitz = .xyz_seitz_matrices

      ! Counter, dipole array
      l = 0

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position (cartesian)
         q = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_mx,q)

         ! Parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Parent and symop
         ! par(i) = p
         ! symop(i) = s

         ! Warning, the asymmetric_unit_atom's should be generated from
         ! the fragment on which the charge and dipole polarisability
         ! calculations (see below) have been done.

         ! Set the charges and dipoles
         charge(i) = .asymmetric_unit_atom(p).charge
         dipole(l+1:l+3).to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)
         l = l + 3

         ! Fragment atom list
         if (NOT present(frag_atom)) cycle
         frag_atom(i) = .frag_atom_for_unit_cell_atom(u)

      end

      ! Clean
      seitz.destroy

   end

   extract_molecule_atom_info(occupation_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m) ::: PURE
   ! From a *molecule* "occupation_list", extract the *cartesian* atom
   ! positions "pos", the indiex of the asymmetric-parent-atom in
   ! "par", the corresponding 3x3 symop matrix which maps the unit
   ! cell atom into the asymmetric-parent-atom, the atomic charges and
   ! masses "charge" and "mass", atomic dipoles "dipole", charge
   ! polarisabilities "alpha_q" and dipole polarisabilities "alpha_m".
   ! NOTE:
   ! . This assumes that the quantities are available and non-zero.
   ! . "pos" and everything else are in *cartesians*.
   ! . The symop returned is the last one for "occupation_list"
   !   This is OK for a whole molecule
   ! WARNING: the asymmetric_unit_atom's should be generated from
   ! the fragment on which the charge and dipole polarisability
   ! calculations (see below) have been done.
      self :: IN
      occupation_list :: VEC{INT}, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(.asymmetric_unit_atom.has_polarisabilities,"no atomic polarisabilities")
   ENSURE(charge.dim==occupation_list.dim, "charge, wrong size")
   ENSURE(mass.dim  ==occupation_list.dim, "mass, wrong size")
   ENSURE(all(shape(pos)    ==[3,occupation_list.dim]),"pos, wrong size")
   ENSURE(all(shape(dipole) ==[3,occupation_list.dim]),"dipole, wrong size")
   ENSURE(all(shape(alpha_q)==[3,occupation_list.dim]),"alpha_q, wrong size")
   ENSURE(all(shape(alpha_m)==[3,3,occupation_list.dim]), "alpha_m, wrong size")

      T  :: MAT{REAL}@
      inverse_seitz :: MAT3{REAL}@
      i,code,h1,h2,h3,u, p,s :: INT
      q :: VEC{REAL}(3)

      ! Transposed/Inverse symops
      inverse_seitz = .transposed_xyz_seitz_matrices

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Set the cluster atom position (cartesian)
         q = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_mx,q)

         ! Set parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)
         T = inverse_seitz(:,:,s)
         par(i) = p

         ! Set the inverse 3x3 symop
         symop = T

         ! Warning, the asymmetric_unit_atom's should be generated from
         ! the fragment on which the charge and dipole polarisability
         ! calculations (see below) have been done.

         ! Set atomic electronic charge.
         charge(i) = .asymmetric_unit_atom(p).charge &
                   - .asymmetric_unit_atom(p).atomic_number
         mass(i)   = .asymmetric_unit_atom(p).mass

         ! Set atomic dipole
         dipole(:,i).to_product_of(T,.asymmetric_unit_atom(p).dipole,transpose_a=TRUE)

         ! Set atomic charge polarisability
         alpha_q(:,i).to_product_of(T,.asymmetric_unit_atom(p).charge_polarisability,transpose_a=TRUE)

         ! Set atomic dipole polarisability
         alpha_m(:,:,i) = .asymmetric_unit_atom(p).dipole_polarisability
         alpha_m(:,:,i).change_basis_using(T)

      end

      ! Clean
      inverse_seitz.destroy

   end

!  ===================
!  Cluster information
!  ===================

   cluster_width result (res) ::: PURE
   ! Return the width "res" of the cluster in each of the 3 axis directions.
   ! NOTE: using crystal axis system.
      self :: IN
      res :: VEC{REAL}(3)

   ENSURE(.geometry.allocated,"no fragment geometry")

      res = .geometry.max_abs_column_difference

   end


   create_fragment_atom_list(fragment_atom) ::: leaky, PURE
   ! Create the "fragment_atom" list.
      self :: IN
      fragment_atom :: VEC{ATOM}@, OUT

   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.allocated,"no fragment atoms")

      fragment_atom.create(.n_fragment_atoms)
      .make_fragment_atom_list(fragment_atom)

   end

   make_fragment_atom_list(fragment_atom) ::: private, PURE
   ! Make the "fragment_atom" list, a VEC{ATOM}
   ! WARNING: set info_made to FALSE in "fragment_atom" parent
   !          molecule, if there is one.
      self :: IN
      fragment_atom :: VEC{ATOM}, OUT

   ENSURE(.n_atoms>0,"no atoms")
   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.allocated,"no is_fragment_atom")
   ENSURE(count(.is_fragment_atom)==.n_fragment_atoms,"inconsistent is_fragment_atom")
   ENSURE(.geometry.allocated,"no geometry")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_cell_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated,"no asym_atom-cell_atom")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}@
      seitz :: MAT3{REAL}@
      a,f,u,p,s :: INT

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz = .xyz_seitz_matrices

      ! Fragment atom
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (NOT .is_fragment_atom(a)) cycle

         ! Fragment atom
         f = f + 1

         ! Extract unit cell atom and asymmetric parent
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Copy the parent atom
         fragment_atom(f) = .asymmetric_unit_atom(p)

         ! Transform the pADPs (which must be in cartesians)
         fragment_atom(f).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         fragment_atom(f).set_position(.geometry(:,a))
         fragment_atom(f).set_axis_system_to("crystal")

      end

      ! Clean
      ulist.destroy

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      ! WARNING: set info_made to FALSE in parent molecule, if any
      fragment_atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

   end


   create_mol_atom_list(mol_atom,m) ::: leaky, PURE
   ! Create the "mol_atom" ATOM list for molecule "m".
      self :: INOUT
      mol_atom :: VEC{ATOM}@, OUT
      m :: INT, IN

   ENSURE(.molecule.allocated,"no molecule list")
   ENSURE(.molecule.dim>=m,"molecule m too large")
   ENSURE(.molecule(m).element.allocated,"no molecule m atom indices")

      mol_atom.create(.molecule(m).element.dim)
      .make_mol_atom_list(mol_atom,m)

   end

   make_mol_atom_list(mol_atom,m) ::: PURE
   ! Make the "fragment_atom" list, a VEC{ATOM}
      self :: IN
      mol_atom :: VEC{ATOM}, OUT
      m :: INT, IN

   ENSURE(.geometry.allocated,"no geometry")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymmetric_cell_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.allocated,"no asym_atom-cell_atom")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}@
      seitz :: MAT3{REAL}@
      f,a, u,p,s :: INT

      ! Unit cell atoms which correspond to the molecule's atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz = .xyz_seitz_matrices

      ! Loop over molecule m atoms "f"
      do f = 1,.molecule(m).element.dim

         a = .molecule(m).element(f)

         ! Extract unit cell atom and asymmetric parent
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         mol_atom(f) = .asymmetric_unit_atom(p)

         ! Transform the pADPs (which must be in cartesians)
         mol_atom(f).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         mol_atom(f).set_position(.geometry(:,a))
         mol_atom(f).set_axis_system_to("crystal")

      end

      ! Clean
      ulist.destroy

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      mol_atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

   end


   fragment_atom_indices result (res) ::: public, PURE
   ! Return the indices of the fragment atoms in the cluster.
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.allocated,"no fragment atoms")

      a,f :: INT

      ! Loop over cluster atoms "a"
      f = 0
      do a = 1,.n_atoms
         if (NOT .is_fragment_atom(a)) cycle
         ! Set the fragment atom index
         f = f + 1 ! Frag atom "f"
         res(f) = a
      end

   end

   nonfragment_atom_indices result (res) ::: public, PURE
   ! Return the indices of the nonfragment atoms in the cluster.
      self :: IN
      res :: VEC{INT}(.n_atoms-.n_fragment_atoms)

   ENSURE(.n_atoms>=.n_fragment_atoms,"no nonfragment atoms")
   ENSURE(.is_fragment_atom.allocated,"no fragment atoms")

      a,f :: INT

      ! Loop over cluster atoms "a"
      f = 0
      do a = 1,.n_atoms
         if (.is_fragment_atom(a)) cycle
         ! Set the fragment atom index
         f = f + 1 ! Frag atom "f"
         res(f) = a
      end

   end

   crystal_asym_unit_atom_indices result (res) ::: PURE
   ! Return the indices of the crystal asymmetric unit cell atoms
   ! corresponding to the fragment atoms of the *cluster*.
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,      "no fragment atoms")
   ENSURE(.is_fragment_atom.allocated,"no is_fragment_atom")
   ENSURE(.occupation_list.allocated, "no occupation_list")

      f,i,code,u,a :: INT


      ! Loop over atoms
      f = 0
      do  i = 1,.n_atoms
         if (NOT .is_fragment_atom(i)) cycle
         code = .occupation_list(i)
         u    = CLUSTER_UA_FROM_CODE(code)
         a    = .asym_atom_for_unit_cell_atom(u)
         f    = f + 1
         res(f) = a
      end

   end

   crystal_frag_atom_indices result (res) ::: PURE
   ! Return the *crystal* fragment atom indices of the fragment atoms
   ! in the *cluster* (the two are not necessarily the same!)
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,      "no fragment atoms")
   ENSURE(.is_fragment_atom.allocated,"no is_fragment_atom")
   ENSURE(.occupation_list.allocated, "no occupation_list")

      f,i,code,u,a :: INT

      ! Loop over atoms
      f = 0
      do  i = 1,.n_atoms
         if (NOT .is_fragment_atom(i)) cycle
         code = .occupation_list(i)
         u    = CLUSTER_UA_FROM_CODE(code)
         a    = .frag_atom_for_unit_cell_atom(u)
         f    = f + 1
         res(f) = a

      end

   end

!  =================
!  Cluster atom list
!  =================

   create_atom_list(atom) ::: leaky, PURE
   ! Create and make a new atom list for the cluster
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}@, OUT

   ENSURE(.fragment_geometry.allocated, "no crystal fragment geometry")
   ENSURE(.asymmetric_unit_atom.allocated, "no atom data")
   ENSURE(.n_atoms>0,"no atoms in cluster")

      atom.create(.n_atoms)
      .make_atom_list(atom)

   end

   make_atom_list(atom) ::: PURE
   ! Make a new atom list for the cluster. Note that the .asymmetric_unit_atom's
   ! must have ADP (thermal) tensors in the cartesian axis system; this will normally
   ! be the case for Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(atom.dim==.n_atoms,"wrong size, atomsr")
   ENSURE(.geometry.allocated,"no geometry")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_unit_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "asymmetric_unit_atom not in cartesian axes")
   ENSURE(.molecule_for_atom.allocated, "no molecule_for_atom info")

      ulist :: VEC{INT}@
      seitz :: MAT3{REAL}@
      a,u,p,s :: INT

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices (cartesian!)
      seitz = .xyz_seitz_matrices

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         ! Extract unit cell atom, asymmetric parent and symop
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom(a) = .asymmetric_unit_atom(p)

         ! Transform the pADPs (which must be in cartesians)
         atom(a).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom(a).set_position(.geometry(:,a))  ! Back to fractional!
         atom(a).set_axis_system_to("crystal")
         atom(a).set_group(.molecule_for_atom(a))

      end

      ! Change pos to cartesian
      ! Errors (if any) are changed straightforwardly
      atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Update labels/groups
      atom.update

      ! Free memory
      seitz.destroy
      ulist.destroy

   end

   make_atom_list(atom,list) ::: PURE
   ! Make a new atom list for the cluster from the indices in "list".
   ! Note that the .asymmetric_unit_atom's must have ADP tensors
   ! in the cartesian axis system; this will normally be the case for
   ! Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}, OUT
      list :: VEC{INT}, IN

   ENSURE(atom.dim==list.dim,"wrong size, atomsr")
   ENSURE(.geometry.allocated,"no geometry")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}@
      seitz :: MAT3{REAL}@
      a,u,p,s :: INT

      ! Unit cell atoms which correspond to the *list* fragment atoms
      ulist.create(list.dim)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list(list))

      ! Seitz matrices
      seitz = .xyz_seitz_matrices

      ! Loop over cluster atoms "a"
      do a = 1, ulist.dim

         ! Extract unit cell atom, asymmetric parent and symop
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom(a) = .asymmetric_unit_atom(p)

         ! Transform the pADPs (which must be in cartesians)
         atom(a).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         ! NOTE: .basis is a ptr copy
         atom(a).set_position(.geometry(:,a))
         atom(a).set_axis_system_to("crystal")

      end

      ! Clean
      seitz.destroy
      ulist.destroy

      ! Change pos to cartesian
      ! Errors (if any) are changed straightforwardly
      atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Update labels/groups
      atom.update

   end

!  ===============
!  Cluster charges
!  ===============

   make_non_fragment_mu_charges(pos,charge) ::: PURE
   ! Make a list of the non-fragment atom positions and point charges
   ! derived from the atomic charges and dipoles only.
      self :: IN
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==3*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}@
      dipole :: VEC{REAL}(3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT
      r :: VEC{REAL}(3)

      ! Normal XYZ symops
      seitz = .xyz_seitz_matrices

      i = -2

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! Get the occ code
         code = .occupation_list(a)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Counter for 3 charges
         i = i + 3

         ! Get the cluster atom position
         r = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_mx,r)

         ! Get parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Atomic charge
         charge(i) = .asymmetric_unit_atom(p).charge

         ! Atomic dipole
         dipole.to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

         ! Make the two charges
         ! Twice the shift along dipole direction
         d  = TOL(2)
         mu = dipole.norm
         q  = mu/d
         dipole = dipole/mu * d * HALF
         pos(:, i+1) = pos(:,i) + dipole
         pos(:, i+2) = pos(:,i) - dipole
         charge(i+1) =  q
         charge(i+2) = -q

      end

      ! Clean
      seitz.destroy

   end

   make_non_fragment_qq_charges(pos,charge) ::: PURE
   ! Make a list of the non-fragment atom positions and charges
   ! from the atomic charges, dipoles, and *quadrupoles*
      self :: IN
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==9*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.allocated, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}@
      dipole,eval :: VEC{REAL}(3)
      quadrupole,evec :: MAT{REAL}(3,3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT
      r :: VEC{REAL}(3)

      ! NOrmal XYZ symops
      seitz = .xyz_seitz_matrices

      ! Counter for charges
      i = 1

      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! The occ code
         code = .occupation_list(a)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position
         r = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_mx,r)

         ! Get parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Atomic charge
         charge(i)  = .asymmetric_unit_atom(p).charge

         ! Atomic dipole
         dipole.to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

         ! Atomic quadrupole
         .asymmetric_unit_atom(p).quadrupole.back_transform_to(quadrupole,seitz(:,:,s))

         ! Make the two charges
         d = TOL(2) ! Twice the shift along dipole direction
         mu = dipole.norm
         q = mu/d
         dipole = dipole/mu * d * HALF
         pos(:,i+1) = pos(:,i) + dipole
         pos(:,i+2) = pos(:,i) - dipole
         charge(i+1) =  q
         charge(i+2) = -q

         ! Make the diagonal quadrupoles
         ! Charge at d/2 along eigenvectors
         ! Should be x 4 for single charge
       ! quadrupole.solve_symmetric_eigenproblem(eval,evec)
         quadrupole.diagonalize_by_jacobi(eval,evec)
         evec = d*evec/TWO
         eval = eval/(d*d)

         ! Two charges on axis at +d/2 and -d/2
         pos(:, i+3)  = pos(:,i) + evec(:,1)
         pos(:, i+4)  = pos(:,i) - evec(:,1)
         pos(:, i+5)  = pos(:,i) + evec(:,2)
         pos(:, i+6)  = pos(:,i) - evec(:,2)
         pos(:, i+7)  = pos(:,i) + evec(:,3)
         pos(:, i+8)  = pos(:,i) - evec(:,3)
         charge(i+3)  = TWO*eval(1)
         charge(i+4)  = TWO*eval(1)
         charge(i+5)  = TWO*eval(2)
         charge(i+6)  = TWO*eval(2)
         charge(i+7)  = TWO*eval(3)
         charge(i+8)  = TWO*eval(3)
         charge(i  )  = charge(i) & ! correct monopole charge
                      - FOUR*eval(1) - FOUR*eval(2) - FOUR*eval(3)

!        ! Four charges in the plane at
!        ! (+d/2,+d/2), (-d/2,-d/2)
!        ! (+d/2,-d/2), (-d/2,+d/2)
!        pos(:,i+9 )  = pos(:,i) + unit(:,1) + unit(:,2)
!        pos(:,i+10)  = pos(:,i) - unit(:,1) - unit(:,2)
!        pos(:,i+11)  = pos(:,i) + unit(:,1) - unit(:,2)
!        pos(:,i+12)  = pos(:,i) - unit(:,1) + unit(:,2)
!        charge(i+9 ) =  quadrupole(1,2)
!        charge(i+10) =  quadrupole(1,2)
!        charge(i+11) = -quadrupole(1,2)
!        charge(i+12) = -quadrupole(1,2)
!        pos(:,i+13)  = pos(:,i) + unit(:,1) + unit(:,3)
!        pos(:,i+14)  = pos(:,i) - unit(:,1) - unit(:,3)
!        pos(:,i+15)  = pos(:,i) + unit(:,1) - unit(:,3)
!        pos(:,i+16)  = pos(:,i) - unit(:,1) + unit(:,3)
!        charge(i+13) =  quadrupole(1,3)
!        charge(i+14) =  quadrupole(1,3)
!        charge(i+15) = -quadrupole(1,3)
!        charge(i+16) = -quadrupole(1,3)
!        pos(:,i+17)  = pos(:,i) + unit(:,2) + unit(:,3)
!        pos(:,i+18)  = pos(:,i) - unit(:,2) - unit(:,3)
!        pos(:,i+19)  = pos(:,i) + unit(:,2) - unit(:,3)
!        pos(:,i+20)  = pos(:,i) - unit(:,2) + unit(:,3)
!        charge(i+17) =  quadrupole(2,3)
!        charge(i+18) =  quadrupole(2,3)
!        charge(i+19) = -quadrupole(2,3)
!        charge(i+20) = -quadrupole(2,3)

         ! Increment charge counter
         i = i + 9

      end

      ! Clean
      seitz.destroy

   end

!  ===========
!  Add tensors
!  ===========

   add_uc_tensors(tensor) ::: template, PURE
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
      self :: IN
      tensor :: TENSOR_TYPE, OUT

   ENSURE(.generation_method=="unit_cell","only for unit_cell clusters")
   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      ulist :: VEC{INT}@
      seitz :: MAT3{REAL}@
      tensor0,tensor1 :: TENSOR_TYPE
      m,a,u,s :: INT

      tensor0 = tensor
      tensor = ZERO

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Inverse XYZ symops
      seitz = .transposed_xyz_seitz_matrices

      ! stdout.text("Making unit cell tensor")
      ! stdout.text("original tensor")
      ! stdout.put(tensor0)

      do m = 1,.n_unit_cell_mols
      do a = 1,.n_atoms

         if (.unit_cell_mol_for_atom(a)/=m) cycle

         ! Get symop for this molecule
         u = ulist(a)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Use inverse symop  S^T to change U tensor basis
         tensor0.change_basis_to(tensor1,seitz(:,:,s))
         tensor = tensor + tensor1

         ! stdout.show("molecule =",m)
         ! stdout.show("symop    =",s)
         ! stdout.put(seitz(:,:,s))
         ! stdout.text("transformed tensor")
         ! stdout.put(tensor1)

         exit

      end
      end

      ! Clean
      seitz.destroy
      ulist.destroy

   end

   add_uc_tensors(tensor) ::: get_from(CRYSTAL, TENSOR_TYPE=>MAT{REAL}(3,3)), PURE
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

   add_uc_tensors(tensor) ::: get_from(CRYSTAL, TENSOR_TYPE=>MAT3{REAL}(3,3,3)), PURE
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

!  ==========================
!  Local field factor tensors
!  ==========================

   put_averaged_LFF_tensors
   ! Put the heavy-atom averaged local field factor dipole L tensors
   ! for the molecules in the unit cell. This uses the Reis formula.
      self :: IN

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")
   ENSURE(.asymmetric_unit_atom.allocated,"no asymetric cell atoms")

      n_mol,n_H,n,a,i1,i2,j1,j2,k1,k2,m1,m2 :: INT
      pos,pos0,com,L,L0,L1 :: MAT{REAL}@
      symop,non_H,par,mol,mol0 :: VEC{INT}@
      label0 :: VEC{STR}@

      ! Header
      stdout.flush
      stdout.text("Molecule-averaged Dipole L(1) tensor:")

      ! Get the positions, COM's for the molecules in the unit cell.
      ! By construction, the atoms in each molecule occur consecutively.
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get indices of non-Hydrogen-atom positions.
      n_mol = .n_unit_cell_mols
      n_H   = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,par.dim)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Set the non-Hydrogen-atom positions, molecules.
      label0.create(n_H)
      pos0.create(3,n_H)
      mol0.create(n_H)
      label0 = .asymmetric_unit_atom(par(non_H)).label
      pos0   = pos(:,non_H)
      mol0   = mol(non_H)

      non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Make the non-Hydrogen-atom Lorentz factor tensors
      L.create(3*n_mol,3*n_mol)
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      mol0.destroy; pos0.destroy

      ! Print monopole and dipole L tensor out
      n = n_H/n_mol
      stdout.flush
      stdout.text("Heavy-atom monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      do i1 = 1,n_mol
      do i2 = 1,n_mol
      do j1 = 1,n
      do j2 = 1,n
         k1 = n*(i1-1) + j1
         k2 = n*(i2-1) + j2
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(i1)
         stdout.put(i2)
         stdout.put(trim(j1.to_str)//" "//trim(label0(k1)),int_width=TRUE)
         stdout.put(trim(j2.to_str)//" "//trim(label0(k2)),int_width=TRUE)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      end
      end
      stdout.dash(int_fields=4,real_fields=4)

      label0.destroy

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n
         do j2 = 1,n
            k1 = 3*(n*(i1-1)+j1-1)
            k2 = 3*(n*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      L = L/real(n*n,kind=REAL_KIND)

      ! Print averaged dipole L tensor
      stdout.flush
      stdout.text("Spackman's molecule-averaged Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do k1 = 1,n_mol
      do k2 = 1,n_mol
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L(m1+1,m2+1))
         stdout.put(L(m1+1,m2+2))
         stdout.put(L(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+2,m2+1))
         stdout.put(L(m1+2,m2+2))
         stdout.put(L(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+3,m2+1))
         stdout.put(L(m1+3,m2+2))
         stdout.put(L(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=3)

      ! Clean up
      L1.destroy
      L0.destroy
      L.destroy

   end

   put_centroid_LFF_tensors
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Reis formula.
      self :: IN

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      n,i,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}@
      centroid,W :: MAT{REAL}@
      mol_for  :: VEC{INT}@

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      ! Allocate
      n = .n_unit_cell_mols
      L0.create(3*n,n)
      L1.create(3*n,3*n)

      ! Get centroids
      centroid.create(3,n)
      .get_uc_molecule_centroids(centroid)
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      W = centroid
      centroid.to_product_of(.unit_cell.direct_mx,W)
      W.destroy
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      mol_for.create(n);   mol_for = [ (i,i=1,n) ]
      .unit_cell.make_LFF_tensors(L0,L1,centroid,mol_for)
      mol_for.destroy
      centroid.destroy

      ! Print monopole and dipole L tensor out
      stdout.flush
      stdout.text("Monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=4)

      ! Clean up
      L1.destroy
      L0.destroy

   end

   put_centroid_LFF_tensors_old
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Cummins code.
      self :: IN

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      n,k,k1,k2 :: INT
      L2 :: MAT3{REAL}@
      centroid,W :: MAT{REAL}@

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      ! Allocate space
      n = .n_unit_cell_mols
      L2.create(3,3,n.triangle)
      centroid.create(3,n)

      ! Get unit cell molecule centroids
      .get_uc_molecule_centroids(centroid)
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      W = centroid
      centroid.to_product_of(.unit_cell.direct_mx,W)
      W.destroy
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      .unit_cell.make_LFF_tensors(L2,centroid)

      ! Print L tensor out
      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      k = 0
      do k1 = 1,n
      do k2 = 1,k1
         k = k + 1
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L2(1,1,k))
         stdout.put(L2(2,2,k))
         stdout.put(L2(3,3,k))
         stdout.put(L2(1,2,k))
         stdout.put(L2(1,3,k))
         stdout.put(L2(2,3,k))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      centroid.destroy
      L2.destroy

   end

   get_uc_molecule_centroids(centroid) ::: PURE
   ! Get the unit cell molecule centroids; they are transformed back
   ! into the unit cell if the defragmented molecule lies outside the
   ! unit cell.
      self :: IN
      centroid :: MAT{REAL}, OUT

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")
   ENSURE(all(shape(centroid)==[3,.n_unit_cell_mols]),"wrong shape, centroid")

      m,u :: INT
      geometry :: MAT{REAL}@

      centroid = ZERO

      do m = 1,.n_unit_cell_mols

         do u = 1,.n_unit_cell_atoms
            if (.unit_cell_mol_for_atom(u)/=m) cycle
            .do_defragment_uc_atom(u,geometry)
            exit
         end

         centroid(:,m) = geometry.sum_column_vectors/geometry.dim2
         .put_to_unit_cell(centroid(:,m))

         ! Clean
         geometry.destroy

      end

   end

   put_LFF_info
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell.
      self :: IN

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      n,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}@
      mol,par :: VEC{INT}@
      pos,coc,com,alpha_q :: MAT{REAL}@
      symop,alpha_m :: MAT3{REAL}@

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      ! Make the charge and dipole Lorentz factor tensors
      n = par.dim
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Output
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_atoms =",par.dim)
      stdout.show("n_unit_cell_mols  =",coc.dim2)
      stdout.flush
      stdout.text("Molecule atom positions:")
      stdout.flush
      stdout.put(transpose(pos))

      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      L1.destroy
      L0.destroy
      alpha_m.destroy
      alpha_q.destroy
      com.destroy
      coc.destroy
      par.destroy
      symop.destroy
      mol.destroy

   end

!  ======================
!  Susceptibility tensors
!  ======================

   make_chi1_naive(chi1,alpha_mol)
   ! Make the naive second order susceptibility from the
   ! polarisability of the molecule.
      self :: IN
      chi1 :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      alpha_mol :: MAT{REAL}(3,3), IN

      alpha_uc :: MAT{REAL}(3,3)
      D :: MAT{REAL}@
      fac :: REAL

      .make_alpha_uc(alpha_uc,alpha_mol)

      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.unit_cell.volume

      D.create(3,3)
      D.to_unit_mx
      D = D - fac*THIRD*alpha_uc
      D.to_inverse_of(D) ! NOT PURE
      chi1.to_scaled_product_of(alpha_uc,D,fac)
      D.destroy

   end

   make_alpha_uc(alpha_uc,alpha_mol) ::: PURE
   ! Make the unit cell alpha.
      self :: IN
      alpha_uc :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      alpha :: MAT{REAL}(3,3)
      mol,symop,par :: VEC{INT}@
      pos,com :: MAT{REAL}@
      inverse_seitz :: MAT3{REAL}@
      n_mol,m :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)
      com.destroy
      pos.destroy
      par.destroy
      mol.destroy

      ! No of molecules
      n_mol = symop.dim

      ! Transposed/Inverse symops
      inverse_seitz = .transposed_xyz_seitz_matrices

      ! Add up the polarisabilities
      alpha_uc = ZERO
      do m = 1,n_mol
         alpha_mol.change_basis_to(alpha,inverse_seitz(:,:,symop(m)))
         alpha_uc = alpha_uc + alpha
      end

      ! Clean
      inverse_seitz.destroy
      symop.destroy

   end


   make_chi1_ALFFA(chi1,alpha_mol)
   ! Make the ALFFA "chi1" matrix: chi = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol". The L
   ! tensors are evaluated at the molecular center-of_masses.
   ! The trace is over 3x3 blocks.
      self :: IN
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par :: VEC{INT}@
      inverse_seitz :: MAT3{REAL}@
      alpha :: MAT3{REAL}@
      pos,com, L0,L1, D,Df :: MAT{REAL}@
      alph :: MAT{REAL}(3,3)
      n_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      ! No. of molecules
      n_mol = .n_unit_cell_mols


      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get the molecule indices (they are consecutive by construction)
      mol0.create(n_mol)
      mol0 = [(m,m=1,n_mol)]

      ! Print out centroid info ... important
      stdout.flush
      stdout.text("Center of mass:")
      stdout.put(com(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      L0.create(dim,n_mol)
      L1.create(dim,dim)
      .unit_cell.make_LFF_tensors(L0,L1,com,mol0)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz = .transposed_xyz_seitz_matrices
      fac = FOUR*PI/.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the (inverse) D matrix
      D.to_unit_mx
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Invert
      D.to_inverse_of(D) ! NOT PURE

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy
      D.destroy
      alpha.destroy

   end

   make_chi1_RLFTn(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      self :: IN
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,non_H,par :: VEC{INT}@
      inverse_seitz :: MAT3{REAL}@
      alpha :: MAT3{REAL}@
      pos,pos0,com, L0,L1, D,Df :: MAT{REAL}@
      alph :: MAT{REAL}(3,3)
      n_mol,n_non_H,n_non_H_per_mol :: INT
      n,dim,a,b,i,j,m :: INT
      fac :: REAL

      n     = .n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .n_unit_cell_mols ! No. of molecules

      ! No of non-hydrogen atoms in unit cell
      n_non_H = count(.asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      ENSURE(mod(n_non_H,n_mol)==0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1
      dim = 3*n_non_H
      D.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get the reduced averaged site polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz = .transposed_xyz_seitz_matrices
      fac = FOUR*PI/.unit_cell.volume
      alph = fac*alpha_mol/n_non_H_per_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Get *indices* for non-H positions
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      D.to_unit_mx
      i = 0
      do a = 1,n_non_H
         j = 0
         do b = 1,n_non_H
            m  = (b-1)/n_non_H_per_mol + 1
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,m),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      pos0.destroy
      non_H.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Invert
      D.to_inverse_of(D) ! NOT PURE

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi1 (RLFTn) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_non_H
         m = (a-1)/n_non_H_per_mol + 1
         chi1.plus_product_of(alpha(:,:,m),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy
      D.destroy
      alpha.destroy

   end

   make_chi1_RLFTn_av_L(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      self :: IN
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}@
      inverse_seitz :: MAT3{REAL}@
      alpha :: MAT3{REAL}@
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}@
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim :: INT
      i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n     = .n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .n_unit_cell_mols ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      ENSURE(mod(n_non_H,n_mol)==0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz = .transposed_xyz_seitz_matrices
      fac = FOUR*PI/.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy; L0.destroy
      mol0.destroy; pos0.destroy; non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)
      D.to_unit_mx
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D) ! NOT PURE

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA-like) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy
      L.destroy; alpha.destroy

   end

   make_chi2_RLFTn_av_L(chi2,beta_mol,alpha_mol)
   ! Make the RLFTn "chi2" matrix:
   !   chi2_ijk = \sum_S \beta^S_abc d^S_ai d^S_bj d^S_ck
   ! where d^S are the local field factor tensors and \beta^S are the (symmetry
   ! transformed) molecular dipole site-hyperpolarisability "beta_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites, "S".
      self :: IN
      chi2      :: MAT3{REAL}(3,3,3), OUT
      beta_mol  :: MAT3{REAL}(3,3,3), IN
      alpha_mol :: MAT{REAL}(3,3), IN

      alph0 :: MAT{REAL}(3,3)
      beta0 :: MAT3{REAL}(3,3,3)
      inverse_seitz :: MAT3{REAL}@
      alpha :: MAT3{REAL}@
      beta :: MAT4{REAL}@
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}@
      mol,mol0,symop,par,non_H :: VEC{INT}@
      n,n_mol,n_non_H,n_non_H_per_mol,dim :: INT
      i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n     = .n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .n_unit_cell_mols     ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)
      beta.create(3,3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      ENSURE(mod(n_non_H,n_mol)==0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(2 eps_0 V)
      !     = (2 pi/V) ... in au since eps_0 = (4 pi)^{-1}.
      inverse_seitz = .transposed_xyz_seitz_matrices
      fac = TWO*PI/.unit_cell.volume
      alph0 = TWO*fac*alpha_mol
      beta0 =     fac*beta_mol
      do m = 1,n_mol
         alph0.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
         beta0.change_basis_to(beta(:,:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      pos0.destroy
      non_H.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)
      D.to_unit_mx
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D) ! NOT PURE

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi2 susceptibility
      chi2 = ZERO
      i = 0
      do a = 1,n_mol
         beta(:,:,:,a).change_basis_to(beta0,Df(i+1:i+3,:))
         chi2 = chi2 + beta0
         i = i + 3
      end

      ! Clean up
      Df.destroy
      D.destroy
      L.destroy
      beta.destroy
      alpha.destroy

   end

! Old distributed polarisability code
! This code does the chi2 from hyperpolarizability

   make_susceptibility2(alpha_mol,beta_mol,uc_alpha,chi1_naive,chi1_centr,chi1_nonH,chi2_nonH,chi1_nc,chi1_do,chi1)
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      self :: IN
      alpha_mol  :: MAT{REAL}(3,3), IN
      beta_mol   :: MAT3{REAL}(3,3,3), IN
      uc_alpha   :: MAT{REAL}(3,3), OUT ! Unit cell alpha
      chi1_naive :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      chi1_centr :: MAT{REAL}(3,3), OUT ! Dipoles at the COM
      chi1_nonH  :: MAT{REAL}(3,3), OUT ! Non-hydrogen model, RLFTn
      chi1_nc    :: MAT{REAL}(3,3), OUT ! No charge contributons to polarisability
      chi1_do    :: MAT{REAL}(3,3), OUT ! Atomic alpha used
      chi1       :: MAT{REAL}(3,3), OUT ! Distributed polarisability
      chi2_nonH  :: MAT3{REAL}(3,3,3)

   ENSURE(.asymmetric_unit_atom.allocated,"no asymetric cell atoms")

      r  :: VEC{REAL}(3)
      AA :: MAT{REAL}(3,3)
      alph,al :: MAT{REAL}(3,3)
      beta,be :: MAT3{REAL}(3,3,3)
      L0,L1 :: MAT{REAL}@, target
      Lq :: VEC{REAL}*
      Lm :: MAT{REAL}*
      df :: MAT{REAL}@
      D,Dnc,Ddo :: MAT{REAL}@, target
      Dd :: MAT{REAL}*
      pos,pos0,coc,com,coc0,alpha_q :: MAT{REAL}@
      mol,mol0,par,non_H :: VEC{INT}@
      symop,alpha_m,alpha :: MAT3{REAL}@
      n,n_m,n_a,n_H,nH,a,b,i,j,m :: INT
      fac :: REAL

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      ! Get no of atoms in unit cell
      n = par.dim

      ! Factor to reduce polarisabilities (in au)
      fac = FOUR*PI/.unit_cell.volume

      ! Make the charge and dipole Lorentz factor tensors
      D.create(3*n,3*n)
      Dnc.create(3*n,3*n)
      Ddo.create(3*n,3*n)
      alpha.create(3,3,n)
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Get the atomic alpha's
      alpha = ZERO
      do a = 1,n
         r = pos(:,a) - coc(:,a)
         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
         alpha(:,:,a) = alpha(:,:,a) + AA
      end

      ! Make the D matrix
      D.to_unit_mx
      Dnc.to_unit_mx
      Ddo.to_unit_mx
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Lq => L0(i+1:i+3,b)
            Lm => L1(i+1:i+3,j+1:j+3)

            Dd =>   D(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*Lq.outer_product_with(alpha_q(:,b))
            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))

            Dd => Dnc(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))

            Dd => Ddo(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))

            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      Dnc.to_inverse_of(Dnc)
      Ddo.to_inverse_of(Ddo)
      L1.destroy
      L0.destroy

      ! Make the distributed polarisability chi1
      chi1 = ZERO
      chi1_nc = ZERO
      chi1_do = ZERO
      uc_alpha = ZERO
      i = 0
      do a = 1,n
         r = pos(:,a) - coc(:,a)
         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
         uc_alpha = uc_alpha + AA
         AA = fac*AA
         j = 0
         do b = 1,n
            Dd =>   D(i+1:i+3,j+1:j+3)
            chi1 = chi1 + matmul(AA,Dd)
            Dd => Dnc(i+1:i+3,j+1:j+3)
            chi1_nc = chi1_nc + matmul(AA,Dd)
            Dd => Ddo(i+1:i+3,j+1:j+3)
            chi1_do = chi1_do + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      alpha.destroy
      Ddo.destroy; Dnc.destroy; D.destroy

      ! ================================================

      ! Make chi1_naive
      D.create(3,3)
      D.to_unit_mx
      D = D - fac*THIRD*uc_alpha
      D.to_inverse_of(D)
      chi1_naive = fac*matmul(uc_alpha,D)
      D.destroy

      ! ================================================

      ! Get the no of molecules
      n_m = maxval(mol)
      ENSURE(mod(n,n_m)==0,"no of atoms in a molecule is not integral")

      ! Get the no of atoms per molecule
      n_a = n/n_m

      ! Get the molecular alpha's
      alpha.create(3,3,n_m)
      alpha = ZERO
      a = 0
      do m = 1,n_m
         do i = 1,n_a
            a = a + 1
            r  = pos(:,a) - coc(:,a)
            AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
            alpha(:,:,m) = alpha(:,:,m) + AA
         end
      end

      ! Get the centroids, use COM
      coc0.create(3,n_m)
      mol0.create(n_m)
      coc0 = com(:,1:(n_m-1)*n_a+1:n_a)
      mol0 = mol(1:(n_m-1)*n_a+1:n_a)

      ! Print out centroid info ... important
    ! stdout.flush
    ! stdout.show("Center of mass =",coc0(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      D.create(3*n_m,3*n_m)
      L0.create(3*n_m,n_m)
      L1.create(3*n_m,3*n_m)
      .unit_cell.make_LFF_tensors(L0,L1,coc0,mol0)

      ! Make the D matrix
      D.to_unit_mx
      i = 0
      do a = 1,n_m
         j = 0
         do b = 1,n_m
            Dd => D(i+1:i+3,j+1:j+3)
            Lm => L1(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))
            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      L1.destroy
      L0.destroy

      ! Make the chi1_centr susceptibility
      chi1_centr = ZERO
      i = 0
      do a = 1,n_m
         AA = alpha(:,:,a)
         AA = fac*AA
         j = 0
         do b = 1,n_m
            Dd => D(i+1:i+3,j+1:j+3)
            chi1_centr = chi1_centr + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      D.destroy
      mol0.destroy
      coc0.destroy

      ! ================================================
      ! RLFTn
      ! ================================================

      ! Get non H positions.
      n_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non H positions, indices, molecules.
      pos0.create(3,n_H)
      mol0.create(n_H)
      pos0 = pos(:,non_H)
      mol0 = mol(non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      D.create(3*n_H,3*n_H)        ! (1 - aL)^-1
      df.create(3*n_H,3)           ! local field factor tensor
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Get number of Non-H hydrogen atoms per molecule
      ENSURE(mod(n_H,n_m)==0,"no of non-Hydrogen atoms wrong")
      nH = n_H/n_m

      ! Average alpha over non-H sites
      alpha = alpha/nH

      ! Get the reduced average molecular polarisabilities
      alph = fac*alpha_mol/nH
      beta = fac*beta_mol/nH

      ! Make the D matrix
      D.to_unit_mx
      i = 0
      do a = 1,n_H
         j = 0
         do b = 1,n_H
            Dd => D(i+1:i+3,j+1:j+3)
            Lm => L1(i+1:i+3,j+1:j+3)
            m  = (b-1)/nH + 1

            ! Old way
         !  Dd = Dd - fac*matmul(Lm,alpha(:,:,m))

            ! New way -- should be better -- check
            alph.change_basis_to(al,symop(:,:,m))
            Dd = Dd - matmul(Lm,al)

            j = j + 3

         end

         i = i + 3

      end

      D.to_inverse_of(D) ! NOT PURE
      L1.destroy
      L0.destroy

      ! Make the chi1_nonH susceptibility
      chi1_nonH = ZERO
      i = 0
      do a = 1,n_H
         m  = (a-1)/nH + 1
         AA = alpha(:,:,m)
         AA = fac*AA
         j = 0
         do b = 1,n_H
            Dd => D(i+1:i+3,j+1:j+3)
            chi1_nonH = chi1_nonH + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Local field factors
      df = ZERO
      i = 0
      do a = 1,n_H
         j = 0
         do b = 1,n_H
            df(i+1:i+3,:) = df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)
            j = j + 3
         end
         i = i + 3
      end

      ! Make the chi1_nonH and chi2_nonH susceptibility
      chi1_nonH = ZERO
      chi2_nonH = ZERO
      i = 0
      do a = 1,n_H
         m = (a-1)/nH + 1
         alph.change_basis_to(al,symop(:,:,m))
         chi1_nonH = chi1_nonH + matmul(al,df(i+1:i+3,:))
         beta.change_basis_to(be,symop(:,:,m))
         be.change_basis_using(df(i+1:i+3,:))
         chi2_nonH = chi2_nonH + be
         i = i + 3
      end
      chi2_nonH = HALF*chi2_nonH

      ! Clean up
      df.destroy; D.destroy
      mol0.destroy; pos0.destroy
      non_H.destroy
      alpha.destroy
      alpha_m.destroy; alpha_q.destroy
      com.destroy; coc.destroy; pos.destroy
      par.destroy; symop.destroy; mol.destroy

   end

   make_local_field_factors(Df,D) ::: selfless, PURE
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      Df :: MAT{REAL}, OUT
      D  :: MAT{REAL}, IN

   ENSURE(D.is_square,     "non square D")
   ENSURE(mod(D.dim1,3)==0,"D dim1 is not divisible by 3")
   ENSURE(Df.dim1==D.dim1, "wrong dim1, Df")
   ENSURE(Df.dim2==3,      "wrong dim2, Df")

      n,a,b,i,j :: INT

      n = D.dim1/3

      Df = ZERO
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Df(i+1:i+3,:) = Df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)
            j = j + 3
         end
         i = i + 3
      end

   end

! These are for more complicated calculations

   make_D_mx(D)
   ! Make the D matrix: D = (1 - L^0 a^0 - L^1 a^1)^-1
   ! where L^0 and L^1 are the monopole and dipole L tensors and
   ! where a^0 and a^1 are the monopole and dipole polarisabilities
   ! for every atom site at which the L tensors are evaluated.
      self :: IN
      D :: MAT{REAL}, OUT

   ENSURE(D.is_square, "non square D")

      mol,par :: VEC{INT}@
      symop,alpha_m :: MAT3{REAL}@
      pos,coc,com,alpha_q :: MAT{REAL}@
      L0,L1 :: MAT{REAL}@, target
      Lm :: MAT{REAL}*
      Lq :: VEC{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.unit_cell.volume

      ! Get the electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = D.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      D.to_unit_mx

      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Lq => L0(i+1:i+3,b)
            Lm => L1(i+1:i+3,j+1:j+3)
            D(i+1:i+3,j+1:j+3) = D(i+1:i+3,j+1:j+3) - fac*Lq.outer_product_with(alpha_q(:,b))
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(Lm,alpha_m(:,:,b),-fac)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      alpha_m.destroy
      alpha_q.destroy
      L1.destroy
      L0.destroy

      ! Invert
      D.to_inverse_of(D) ! NOT PURE

   end

   make_Dnc_mx(Dnc) 
   ! Make the Dnc matrix: Dnc = (1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensors and where a^1 is the dipole
   ! polarisability for every atom site at which the L tensors are
   ! evaluated.  NOTE: Dnc means "no charge dipole terms"
      self :: IN
      Dnc :: MAT{REAL}, OUT

   ENSURE(Dnc.is_square,"non square Dnc")

      mol,par :: VEC{INT}@
      symop,alpha_m :: MAT3{REAL}@
      pos,coc,com,alpha_q :: MAT{REAL}@
      L0,L1 :: MAT{REAL}@, target
      Lm :: MAT{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.unit_cell.volume

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      alpha_q.destroy
      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = Dnc.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      Dnc.to_unit_mx
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Lm => L1(i+1:i+3,j+1:j+3)
            Dnc(i+1:i+3,j+1:j+3).plus_scaled_product_of(Lm,alpha_m(:,:,b),-fac)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy

      ! Invert
      Dnc.to_inverse_of(Dnc) ! NOT PURE

   end

!  ===============
!  Electric fields
!  ===============

   make_Lorentz_fields(F,sphere_sum) ::: PURE
   ! Make the Lorentz electric fields at the unit cell atom sites.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where catomic harges and dipoles have been done.
      self :: IN
      F :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional, IN

      mol,frag_atom :: VEC{INT}@
      charge,dipole :: VEC{REAL}@
      pos,L0,L1 :: MAT{REAL}@
      fac :: REAL
      n_atom,dim, u,a, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom)

      ! Make the Lorentz factor tensors L0, L1
      n_atom = charge.dim
      dim    = dipole.dim
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)
      fac = FOUR*PI/.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign electric fields
      do a = 1,.n_fragment_atoms
         u = frag_atom.index_of_value(a) ! map to unit cell atom
         ENSURE(u/=0,"fragment atom "//trim(a.to_str)//" not found in cell")
         lu = 3*(u-1)
         fu = lu + 1
         lu = lu + 3
         F(:,a).to_product_of(L0(fu:lu,:),charge)
         F(:,a).plus_product_of(L1(fu:lu,:),dipole)
      end

      ! Clean up
      L1.destroy
      L0.destroy
      frag_atom.destroy
      dipole.destroy
      charge.destroy
      pos.destroy

   end

   make_Lorentz_interactions(I0,I1,sphere_sum) ::: PURE
   ! Make the Lorentz interactions with charges and dipoles due to
   ! dipoles ONLY at the unit cell atom sites. The charge-charge term
   ! is not calculated -- it does not affect the susceptibilities.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where atomic charges and dipoles have been done.
      self :: IN
      I0 :: VEC{REAL}, OUT
      I1 :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional, IN

      mol,frag_atom :: VEC{INT}@
      charge,dipole :: VEC{REAL}@
      pos,L0,L1 :: MAT{REAL}@
      fac :: REAL
      n_atom,dim, u,a, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom)

      ! Create L tensors
      n_atom = charge.dim        ! No of unit cell atoms
      dim    = dipole.dim        ! 3 x the above
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor

      ! Make the Lorentz factor tensors L0, L1
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)

      fac = FOUR*PI/.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign charge and dipole interactions
      ! Needs a minus sign when combined
      do a = 1,.n_fragment_atoms
         u = frag_atom.index_of_value(a) ! map to unit cell atom
         ENSURE(u/=0,"fragment atom "//trim(a.to_str)//" not found in cell")
         lu = 3*(u-1)
         fu = lu + 1
         lu = lu + 3
         I0(a) = dot_product(L0(:,u),dipole)
         I1(:,a).to_product_of(L1(:,fu:lu),dipole,transpose_a=TRUE)
      end

      ! Clean up
      L1.destroy
      L0.destroy
      frag_atom.destroy
      dipole.destroy
      charge.destroy
      pos.destroy

   end

!  =====================================================
!  Cluster positions, charges, dipoles, polarisabilities
!  =====================================================

   get_uc_molecule_info(mol,symop,par,pos,com) ::: leaky, PURE
   ! Get the unit cell molecule information for a distributed local
   ! field factor (LFF) calculation. "mol" is the molecule index for
   ! an atom in the unit cell. "pos" are the positions. "par" is the
   ! asymmetric unit atom parent. "com" are the molecular center of
   ! masses.
      self :: IN
      mol :: VEC{INT}@, OUT
      symop :: VEC{INT}@, OUT
      par :: VEC{INT}@, OUT
      pos :: MAT{REAL}@, OUT
      com :: MAT{REAL}@, OUT

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      mass :: VEC{REAL}@
      cm   :: VEC{REAL}(3)
      fac  :: REAL

      ! Create the info arrays
      n_mol  = .n_unit_cell_mols
      n_atom = .n_unit_cell_atoms

      mol.create(n_atom)
      symop.create(n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      com.create(3,n_mol)
      mass.create(n_atom)

      ! Set n_atom to the # of atoms in one molecule
      ENSURE(mod(n_atom,n_mol)==0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.n_unit_cell_atoms

            if (.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m

            .do_defragment_uc_atom( &
               u,symop(m),          &
               par(  n+1:n+n_atom), &
               pos(:,n+1:n+n_atom), &
               mass( n+1:n+n_atom))

            exit

         end

         ! Calculate the center of mass (COM)
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass(n+a)*pos(:,n+a)
         end
         fac = sum(mass(n+1:n+n_atom))
         fac = ONE/fac
         cm = fac*cm
         com(:,m) = cm

         ! Next
         n = n + n_atom

      end

      mass.destroy

   end

   get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) ::: leaky, PURE
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      self :: IN
      mol :: VEC{INT}@, OUT
      symop :: MAT3{REAL}@, OUT
      par :: VEC{INT}@, OUT
      pos :: MAT{REAL}@, OUT
      coc :: MAT{REAL}@, OUT
      com :: MAT{REAL}@, OUT
      alpha_q :: MAT{REAL}@, OUT
      alpha_m :: MAT3{REAL}@, OUT

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      charge, mass :: VEC{REAL}@
      e_dipole,cm  :: VEC{REAL}(3)
      dipole :: MAT{REAL}@
      fac :: REAL

      ! Sizes
      n_mol  = .n_unit_cell_mols
      n_atom = .n_unit_cell_atoms

      ! Create the info arrays
      mol.create(n_atom)
      symop.create(3,3,n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      coc.create(3,n_atom)
      com.create(3,n_atom)
      alpha_q.create(3,n_atom)
      alpha_m.create(3,3,n_atom)
      charge.create(n_atom)
      mass.create(n_atom)
      dipole.create(3,n_atom)

      ! Set n_atom to the # of atoms in one molecule
      ENSURE(mod(n_atom,n_mol)==0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.n_unit_cell_atoms

            if (.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m

            .do_defragment_uc_atom(       &
               u,                         &
               symop(:,:,m),              &
               par(      n+1:n+n_atom),   &
               pos(:,    n+1:n+n_atom),   &
               charge(   n+1:n+n_atom),   &
               mass(     n+1:n+n_atom),   &
               dipole(:, n+1:n+n_atom),   &
               alpha_q(:,  n+1:n+n_atom), &
               alpha_m(:,:,n+1:n+n_atom)  )

            exit

         end

         ! Calculate electronic dipole and center of charge
         e_dipole = ZERO
         do a = 1,n_atom
            e_dipole = e_dipole + dipole(:,n+a)
            e_dipole = e_dipole + charge(n+a)*pos(:,n+a)
         end
         fac = sum(charge(n+1:n+n_atom))
         fac = ONE/fac
         e_dipole = fac*e_dipole
         coc(:,n+1:n+n_atom) = spread(e_dipole,2,n_atom)

         ! Calculate the center of mass (COM): make coc the COM
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass(n+a)*pos(:,n+a)
         end
         fac = sum(mass(n+1:n+n_atom))
         fac = ONE/fac
         cm  = fac*cm
         com(:,n+1:n+n_atom) = spread(cm,2,n_atom)

         ! Next
         n = n + n_atom

      end

      dipole.destroy
      mass.destroy
      charge.destroy

   end

   get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) ::: leaky, PURE
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      self :: IN
      mol :: VEC{INT}@, OUT
      pos :: MAT{REAL}@, OUT
      charge :: VEC{REAL}@,OUT
      dipole :: VEC{REAL}@, OUT
      frag_atom :: VEC{INT}@, OUT

   ENSURE(.unit_cell_mol_for_atom.allocated,"no cell_mol_for_atom")

      n_atom,n_mol, n,n3,m,u :: INT
      occupation_list :: VEC{INT}@

      ! Sizes
      n_mol  = .n_unit_cell_mols
      n_atom = .n_unit_cell_atoms

      ! Create the info arrays
      mol.create(n_atom)
      pos.create(3,n_atom)
      charge.create(n_atom)
      dipole.create(3*n_atom)
      frag_atom.create(n_atom)

      ! Counters
      n  = 0
      n3 = 0

      ! Loop over molecules m
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.n_unit_cell_atoms

            if (.unit_cell_mol_for_atom(u)/=m) cycle

            ! Get the occ list for molecule m
            occupation_list.create(1)
            occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)
            .do_defragment(occupation_list)

            ! No of atoms in molecule m
            n_atom = occupation_list.dim

            ! Assign
            mol(n+1:n+n_atom) = m

            ! Get the info
            .extract_atom_info( &
               occupation_list, &
               pos   (:, n +1:n +  n_atom), &
               charge(   n +1:n +  n_atom), &
               dipole(   n3+1:n3+3*n_atom), &
               frag_atom(n +1:n +  n_atom)  )

            ! Clean
            occupation_list.destroy

            exit

         end

         ! Increment
         n  = n  +   n_atom
         n3 = n3 + 3*n_atom

      end

   end

!  ==============
!  Cluster output
!  ==============

   put_cluster_info
   ! Put the list of vertices for the object
      self :: IN

   ENSURE(.cluster_info_made,"call make_cluster_info first")
   ENSURE(tonto.allocated,"no tonto variable")

      stdout.flush
      stdout.text("==============================")
      stdout.text("Cluster generation information")
      stdout.text("==============================")

      stdout.flush
      stdout.show("Cluster generation method       =",.generation_method)
      stdout.show("Complete connected fragments?   =",.defragment)
      stdout.show("Radius of cluster               =",.radius)
      stdout.flush
      stdout.show("No. of molecules                =",.n_molecules)
      stdout.show("No. of atoms                    =",.n_atoms)
      stdout.show("No. of fragment atoms           =",.n_fragment_atoms)
      stdout.flush
      stdout.show("Fragment offset                 =",.fragment_offset)
      stdout.show("Minimum cell shift for search   =",.h_min)
      stdout.show("Maximum cell shift for search   =",.h_max)

      if (.fragment_geometry.allocated)    .put_central_fragment_coords
      if (.occupation_list.allocated)      .put_occupation_list
  !   if (.atom_connection.allocated)      .put_atom_connection_table

   end

   put_central_fragment_coords
   ! Put the initial fragment geometry information
      self :: IN

   ENSURE(.fragment_geometry.allocated,"no fragment_geometry")
   ENSURE(.fragment_atom.allocated,"no fragment_atom")

      ind :: VEC{INT}@
      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("=======================================")
      stdout.text("Central fragment fractional coordinates")
      stdout.text("=======================================")

      stdout.flush
      stdout.show("No. of fragment atoms =",.n_fragment_atoms)
      stdout.flush

      ! Unique ID tags
      ind = .crystal_frag_atom_indices

      ! Table
      table.create(4)
      table(1).set_heading("ID");    table(1).set_values(.fragment_atom(ind).tag)
      table(3).set_heading("Coord")
      table(2).set_subhead("- x -"); table(2).set_values(.fragment_geometry(1,:))
      table(3).set_subhead("- y -"); table(3).set_values(.fragment_geometry(2,:))
      table(4).set_subhead("- z -"); table(4).set_values(.fragment_geometry(3,:))
      table(3).set_sb3head("/frac")
      table.put

      ! Clean
      table.destroy
      ind.destroy

   end

   put_occupation_list
   ! Put the .occupation_list table
      self :: IN

   ENSURE(.occupation_list.allocated,"no occupation_list")
   ENSURE(.unit_cell_geometry.allocated,"no crystal unit cell geometry")
   ENSURE(.asym_symop_for_unit_cell_atom.allocated,"no asym_symop_for_unit_cell_atom")
   ENSURE(.asym_shift_for_unit_cell_atom.allocated,"no asym_shift_for_unit_cell_atom")

      ua,aa, h1,h2,h3, sy,s1,s2,s3,ac,ao :: VEC{INT}@
      ut,at :: VEC{STR}@
      r1,r2,r3 :: VEC{REAL}@
      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("=============")
      stdout.text("Cluster atoms")
      stdout.text("=============")

      stdout.flush
      stdout.show("No. of atoms =",.n_atoms)

      stdout.flush
      stdout.text("The table below is understood as follows:")
      stdout.flush
      stdout.text("  #          = Cluster atom index")
      stdout.text("  (xyz)      = Cluster atom coord (fractional)")
      stdout.text("  UA         = Unit cell atom index which generates (xyz)")
      stdout.text("  Mol        = Molecule index")
      stdout.flush              
      stdout.text("where")      
      stdout.flush              
      stdout.text("  (xyz)      = (UA xyz) + (h1 h2 h3)")
      stdout.text("  (UA xyz)   = Unit cell atom coord")
      stdout.text("  (h1 h2 h3) = Unit cell atom shift = US")
      stdout.flush              
      stdout.text("Also")       
      stdout.flush              
      stdout.text("  (xyz)      = Op(AA xyz) + (s1 s2 s3) + (h1 h2 h3)")
      stdout.text("  (UA xyz)   = Op(AA xyz) + (s1 s2 s3)")
      stdout.flush              
      stdout.text("where")      
      stdout.flush              
      stdout.text("  Op         = Seitz symmetry operator")
      stdout.text("  (AA xyz)   = Asym cell atom coord")
      stdout.text("  (s1 s2 s3) = Asym cell atom shift = AS")
      stdout.text("  AA         = Asym cell atom index which generates (xyz)")
      stdout.text("  AA code    = Asym atom code to make (xyz) from AA")
      stdout.text("             = Op | h1+s1+5 | h2+s2+5 | h3+s3+5")
      stdout.text("  AO code    = AA | Op")
      stdout.flush

      ! Data
      ua = CLUSTER_UA_FROM_CODE(.occupation_list)
      ut = .unit_cell_atom(ua).tag
      aa = .asym_atom_for_unit_cell_atom(ua)
      at = .asymmetric_unit_atom(aa).tag

      h1 = CLUSTER_H1_FROM_CODE(.occupation_list) + .fragment_offset(1)
      h2 = CLUSTER_H2_FROM_CODE(.occupation_list) + .fragment_offset(2)
      h3 = CLUSTER_H3_FROM_CODE(.occupation_list) + .fragment_offset(3)

      r1 = .unit_cell_geometry(1,ua) + h1
      r2 = .unit_cell_geometry(2,ua) + h2
      r3 = .unit_cell_geometry(3,ua) + h3

      sy = .asym_symop_for_unit_cell_atom(ua)
      s1 = .asym_shift_for_unit_cell_atom(1,ua)
      s2 = .asym_shift_for_unit_cell_atom(2,ua)
      s3 = .asym_shift_for_unit_cell_atom(3,ua)

      ac = 1000* sy
      ac = 100* (h1+5+s1) + ac
      ac = 10*  (h2+5+s2) + ac
      ac =      (h3+5+s3) + ac

      ao = 100* aa
      ao = sy + ao

      ! Table
      table.create(17)

      table( 1).set_heading(" UA")
      table( 1).set_values(ua)

      table( 2).set_heading(" UA")
      table( 2).set_subhead("Tag")
      table( 2).set_values(ut)

      table( 3).set_heading("Mol")
      table( 3).set_values(.molecule_for_atom)

      table( 5).set_heading("(xyz)")

      table( 4).set_subhead("- x -")
      table( 5).set_subhead("- y -")
      table( 6).set_subhead("- z -")

      table( 4).set_values(r1)
      table( 5).set_values(r2)
      table( 6).set_values(r3)

      table( 8).set_heading("US")

      table( 7).set_subhead("h1")
      table( 8).set_subhead("h2")
      table( 9).set_subhead("h3")

      table( 7).set_values(h1)
      table( 8).set_values(h2)
      table( 9).set_values(h3)

      table(10).set_heading("AA")
      table(10).set_values(aa)

      table(11).set_heading(" AA")
      table(11).set_subhead("Tag")
      table(11).set_values(at)

      table(12).set_heading("Op")
      table(14).set_heading("AS")

      table(13).set_subhead("s1")
      table(14).set_subhead("s2")
      table(15).set_subhead("s3")

      table(12).set_values(sy)
      table(13).set_values(s1)
      table(14).set_values(s2)
      table(15).set_values(s3)
             
      table(16).set_heading(" AA ")
      table(16).set_subhead("code")
      table(16).set_values(ac)
             
      table(17).set_heading(" AO ")
      table(17).set_subhead("code")
      table(17).set_values(ao)
             
      table.put

      ! Clean
      table.destroy

      ao.destroy
      ac.destroy
      r3.destroy; r2.destroy; r1.destroy
      s3.destroy; s2.destroy; s1.destroy
      sy.destroy
      h3.destroy; h2.destroy; h1.destroy
      at.destroy
      aa.destroy
      ut.destroy
      ua.destroy

   end

   put_atom_connection_table
   ! Put the .atom_connection table
      self :: IN

   ENSURE(.atom_connection.allocated,"no atom_connection")
   ENSURE(.molecule_for_atom.allocated,"no molecule_for_atom")

      m,a,i :: INT
      first :: BIN

      stdout.save
      stdout.set_int_width(5)

      stdout.flush
      stdout.text("Atom connection table:")
      stdout.flush
      stdout.show("n_molecules = ",.n_molecules)

      stdout.flush
      stdout.dash(int_fields=8)
      stdout.put("Cluster",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.flush

      stdout.put("Mol",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom(s)",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=8)

      do m = 1,.n_molecules

         ! Molecule label
         stdout.put(m)

         first = TRUE
         do a = 1,.n_atoms

            if (.molecule_for_atom(a)/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.atom_connection(a).element.allocated) then
               do i = 1,.atom_connection(a).element.dim
                  stdout.put(.atom_connection(a)[i])
               end
               stdout.flush
            else
               stdout.flush
            end

         end
      end

      stdout.dash(int_fields=8)

      stdout.unsave

   end

end
