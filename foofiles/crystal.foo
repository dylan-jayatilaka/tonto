!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id: crystal.foo 4398 2014-06-01 06:55:30Z dylan_ $
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module CRYSTAL

   implicit none

 ! saved_self :: CRYSTAL*

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========================
!  Create and destroy methods
!  ==========================

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part ::: PURE
   ! Nullify the pointer parts of the crystal object
      self :: INOUT

      .spacegroup.nullify_ptr_part

      nullify(.fragment_atom)
      nullify(.fragment_geometry)

      nullify(.asymmetric_unit_geometry)
      nullify(.asymmetric_unit_atom)

      nullify(.unit_cell_geometry)
      nullify(.unit_cell_atom)
      nullify(.unique_unit_cell_atom)
      nullify(.unique_uc_atom_offset)
      nullify(.is_asym_unit_cell_atom)
      nullify(.asym_atom_for_unit_cell_atom)
      nullify(.asym_symop_for_unit_cell_atom)
      nullify(.asym_shift_for_unit_cell_atom)
      nullify(.frag_parent_for_cell_atom)

      nullify(.frag_atom_for_unit_cell_atom)
      nullify(.unit_cell_atom_for_frag_atom)
      nullify(.unit_cell_shft_for_frag_atom)
      nullify(.frag_atom_for_asym_atom)
      nullify(.asym_atom_for_frag_atom)

      nullify(.unique_frag_atom)
      nullify(.unique_index_for_frag_atom)
      nullify(.unique_atom_for_frag_atom)
      nullify(.unique_symop_for_frag_atom)
      nullify(.asym_symop_for_frag_atom)
      nullify(.asym_shift_for_frag_atom)

      nullify(.repetition_factor)
      nullify(.asym_atom_sym_factor)
      nullify(.asym_atom_stabilizer)

      nullify(.unit_cell_connection)
      nullify(.uc_vdw_connection)
      nullify(.unit_cell_mol_for_atom)

      nullify(.stabilizer_symop)
      nullify(.str)
      nullify(.ptr)
      nullify(.dtr)
      nullify(.ftr)
      nullify(.gtr)

      nullify(.data)
      nullify(.xray_data)
      nullify(.pnd_data)
      nullify(.xray_r_free_data)
      nullify(.pnd_r_free_data)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information
      self :: INOUT

      .spacegroup.destroy_ptr_part
      .destroy_fragment_data
      .destroy_asymmetric_unit
      .destroy_data

   end

   destroy_data ::: leaky
   ! Erase all data pointer information
      self :: INOUT

      nullify(.data)
      
      .xray_data.destroy
      .pnd_data.destroy
      .xray_r_free_data.destroy
      .pnd_r_free_data.destroy

   end

   destroy_fragment_data ::: leaky
   ! Destroy the geometry and symmetry data for the fragment and unit cell.
   ! NOTE: Don't destroy asymmetric unit atom info
      self :: INOUT

      if (.destroy_fragment_atom) then; .fragment_atom.destroy
      else;                             nullify(.fragment_atom)
      end
      .fragment_geometry.destroy

      ! Never destroy .asymmetric_unit_geometry
      ! Never destroy .asymmetric_unit_atom

      .unit_cell_geometry.destroy
      .unit_cell_atom.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy
      .asym_shift_for_unit_cell_atom.destroy
      .frag_parent_for_cell_atom.destroy

      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .unit_cell_shft_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy

      .unique_frag_atom.destroy
      .unique_index_for_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      if (NOT .use_manual_repetition_factors) .repetition_factor.destroy
      .asym_atom_sym_factor.destroy
      .asym_atom_stabilizer.destroy

      .unit_cell_connection.destroy
      .uc_vdw_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .stabilizer_symop.destroy
      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      .fragment_info_made = FALSE

   end

   destroy_asymmetric_unit ::: leaky
   ! Destroy the asymmetric unit geometry. Normally this will be set
   ! by reading a CIF file. If not, it will be set from a given
   ! fragment atom list, in the "make_fragment_data" routine. Once
   ! set, it is never destroyed unless explicitly requested by a call
   ! or a keyword.
      self :: INOUT

      .asymmetric_unit_geometry.destroy ! This is nothing to do with a fragment !
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_source = "?"

   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(crystal) ::: leaky
   ! Set self to be crystal.
      crystal :: CRYSTAL, IN

      self = crystal

      .nullify_ptr_part

      .spacegroup.copy(crystal.spacegroup)
      .unit_cell.copy(crystal.unit_cell)

      if (crystal.fragment_atom.associated) then
         if (.destroy_fragment_atom) then;               .fragment_atom.create_copy(crystal.fragment_atom)
         else;                                           .fragment_atom => crystal.fragment_atom
         end
      end
      if (crystal.fragment_geometry.associated)             &
         .fragment_geometry.create_copy(crystal.fragment_geometry)

      if (crystal.asymmetric_unit_geometry.associated)      &
         .asymmetric_unit_geometry.create_copy(crystal.asymmetric_unit_geometry)
      if (crystal.asymmetric_unit_atom.associated)          &
         .asymmetric_unit_atom.create_copy(crystal.asymmetric_unit_atom)

      if (crystal.unit_cell_geometry.associated)            &
         .unit_cell_geometry.create_copy(crystal.unit_cell_geometry)
      if (crystal.unit_cell_atom.associated)                &
         .unit_cell_atom.create_copy(crystal.unit_cell_atom)
      if (crystal.unique_unit_cell_atom.associated)         &
         .unique_unit_cell_atom.create_copy(crystal.unique_unit_cell_atom)
      if (crystal.unique_uc_atom_offset.associated)         &
         .unique_uc_atom_offset.create_copy(crystal.unique_uc_atom_offset)
      if (crystal.is_asym_unit_cell_atom.associated)        &
         .is_asym_unit_cell_atom.create_copy(crystal.is_asym_unit_cell_atom)

      if (crystal.asym_atom_for_unit_cell_atom.associated)  &
         .asym_atom_for_unit_cell_atom.create_copy(crystal.asym_atom_for_unit_cell_atom)
      if (crystal.asym_symop_for_unit_cell_atom.associated) &
         .asym_symop_for_unit_cell_atom.create_copy(crystal.asym_symop_for_unit_cell_atom)
      if (crystal.asym_shift_for_unit_cell_atom.associated) &
         .asym_shift_for_unit_cell_atom.create_copy(crystal.asym_shift_for_unit_cell_atom)
      if (crystal.frag_parent_for_cell_atom.associated)     &
         .frag_parent_for_cell_atom.create_copy(crystal.frag_parent_for_cell_atom)

      if (crystal.frag_atom_for_unit_cell_atom.associated)  &
         .frag_atom_for_unit_cell_atom.create_copy(crystal.frag_atom_for_unit_cell_atom)
      if (crystal.unit_cell_atom_for_frag_atom.associated)  &
         .unit_cell_atom_for_frag_atom.create_copy(crystal.unit_cell_atom_for_frag_atom)
      if (crystal.unit_cell_shft_for_frag_atom.associated)  &
         .unit_cell_shft_for_frag_atom.create_copy(crystal.unit_cell_shft_for_frag_atom)
      if (crystal.frag_atom_for_asym_atom.associated)       &
         .frag_atom_for_asym_atom.create_copy(crystal.frag_atom_for_asym_atom)
      if (crystal.asym_atom_for_frag_atom.associated)       &
         .asym_atom_for_frag_atom.create_copy(crystal.asym_atom_for_frag_atom)

      if (crystal.unique_frag_atom.associated)              &
         .unique_frag_atom.create_copy(crystal.unique_frag_atom)
      if (crystal.unique_index_for_frag_atom.associated)              &
         .unique_index_for_frag_atom.create_copy(crystal.unique_index_for_frag_atom)
      if (crystal.unique_atom_for_frag_atom.associated)     &
         .unique_atom_for_frag_atom.create_copy(crystal.unique_atom_for_frag_atom)
      if (crystal.unique_symop_for_frag_atom.associated)    &
         .unique_symop_for_frag_atom.create_copy(crystal.unique_symop_for_frag_atom)
      if (crystal.asym_symop_for_frag_atom.associated)      &
         .asym_symop_for_frag_atom.create_copy(crystal.asym_symop_for_frag_atom)
      if (crystal.asym_shift_for_frag_atom.associated)      &
         .asym_shift_for_frag_atom.create_copy(crystal.asym_shift_for_frag_atom)

      if (crystal.repetition_factor.associated)             &
         .repetition_factor.create_copy(crystal.repetition_factor)
      if (crystal.asym_atom_sym_factor.associated)          &
         .asym_atom_sym_factor.create_copy(crystal.asym_atom_sym_factor)
      if (crystal.asym_atom_stabilizer.associated)          &
         .asym_atom_stabilizer.create_copy(crystal.asym_atom_stabilizer)

      if (crystal.unit_cell_connection.associated)          &
         .unit_cell_connection.create_copy(crystal.unit_cell_connection)
      if (crystal.uc_vdw_connection.associated)             &
         .uc_vdw_connection.create_copy(crystal.uc_vdw_connection)
      if (crystal.unit_cell_mol_for_atom.associated)        &
         .unit_cell_mol_for_atom.create_copy(crystal.unit_cell_mol_for_atom)

      if (crystal.stabilizer_symop.associated)  .stabilizer_symop.create_copy(crystal.stabilizer_symop)
      if (crystal.str.associated)               .str.create_copy(crystal.str)
      if (crystal.ptr.associated)               .ptr.create_copy(crystal.ptr)
      if (crystal.dtr.associated)               .dtr.create_copy(crystal.dtr)
      if (crystal.ftr.associated)               .ftr.create_copy(crystal.ftr)
      if (crystal.gtr.associated)               .gtr.create_copy(crystal.gtr)

      if (crystal.xray_data.associated)         .xray_data.create_copy(crystal.xray_data)
      if (crystal.pnd_data.associated)          .pnd_data.create_copy(crystal.pnd_data)

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set up a default crystal object

      .CIF_chemical_formula          = "?"

      .n_fragment_atoms              = 0
      .destroy_fragment_atom         = FALSE
      .fragment_offset               = 0

      .asymmetric_unit_source        = "?"
      .n_asymmetric_unit_atoms       = 0
      .prune_asymmetric_unit         = TRUE
      .n_unit_cell_atoms             = 0

      .fragment_info_made            = FALSE

      .n_unique_frag_atoms           = 0
      .Z                             = ZERO
      .use_manual_repetition_factors = FALSE
      .n_unit_cell_mols              = 0
      .n_stabilizer_symops           = 0

      .data_kind                     = "?"
      .r_free_percentage             = 0
      .finalize                      = TRUE

      ! Subtype defaults
      .spacegroup.set_defaults
      .unit_cell.set_defaults

      ! Set xray_data defualts
      if (.xray_data.associated) then; .xray_data.set_defaults
      else;                         nullify(.xray_data)
      end

      ! Set pnd_data defualts
      if (.pnd_data.associated) then;  .pnd_data.set_defaults
      else;                         nullify(.pnd_data)
      end

      ! Cluster-related

      .generation_method   = CLUSTER_GENERATION_METHOD
      .radius              = CLUSTER_RADIUS
      .atom_density_cutoff = CLUSTER_ATOM_DENSITY_CUTOFF
      .defragment          = CLUSTER_DEFRAGMENT
      .cluster_info_made   = FALSE
      .n_atoms             = 0
      .h_min               = 0
      .h_max               = 0
      .n_fragment_atoms    = 0
      .unit_cell_offset = ZERO

   end

   update ::: leaky
   ! Update the crystal information after setting values.
      self :: INOUT

      if (.xray_data.associated) then

        .xray_data.update(.unit_cell,.spacegroup)

        if (.r_free_percentage>0 AND .xray_data.reflections.associated) then
           .xray_r_free_data.destroy
           .xray_r_free_data.create_copy(.xray_data)
           .xray_r_free_data.reflections.destroy
           .set_r_free_reflections(.xray_data.reflections,.xray_r_free_data.reflections)
        end

      end

      if (.pnd_data.associated) then

        .pnd_data.update(.unit_cell,.spacegroup)

        if (.r_free_percentage>0 AND .pnd_data.reflections.associated) then
           .pnd_r_free_data.destroy
           .pnd_r_free_data.create_copy(.xray_data)
           .pnd_r_free_data.reflections.destroy
           .set_r_free_reflections(.pnd_data.reflections,.pnd_r_free_data.reflections)
        end

      end

   end

   set_r_free_reflections(data,free_data) ::: leaky
   ! Set the R free reflection data. "data" is destroyed and created
   ! again without those reflections in "free_data".
      self :: INOUT
      data,free_data :: VEC{REFLECTION}*

   ENSURE(data.associated,"no diffraction data")
   ENSURE(free_data.disassociated,"r_free_data exists")

      keep_data :: VEC{REFLECTION}*
      harvest :: VEC{REAL}*
      free,keep :: VEC{INT}*
      percentage :: REAL
      i,n :: INT

      if (.r_free_percentage<=0) return
      if (data.disassociated) return

      ! Set the percentage of reflections to reject
      percentage = .r_free_percentage/100.0d0

      ! Harvest random numbers
      n = data.dim
      harvest.create(n)

      if (tonto.is_master_processor) then
         call random_number(harvest)
      end
      PARALLEL_BROADCAST(harvest,0)

      ! Reflections for r_free have p<percentage
      ! Otherwise, they are kept and used for fitting
      nullify(free)
      nullify(keep)
      do i = 1,n
         if (harvest(i)<percentage) then; free.append(i)
         else;                            keep.append(i)
         end
      end
      harvest.destroy

      stdout.show("No. of reflections kept for R free =",free.dim)
      stdout.flush

      ! Set free_data
      free_data.create(free.dim)
      free_data = data(free)
      free.destroy

      ! Reset data to the kept data
      keep_data.create(keep.dim)
      keep_data = data(keep)
      keep.destroy
      data.destroy
      data => keep_data

   end

   assign_xray
   ! Assign data to the xray_data
      self :: INOUT

   ENSURE(.xray_data.associated, "No X-ray reflection data")

      nullify(.data)
      .data => .xray_data

   end

   assign_xray_r_free
   ! Assign data to the xray_r_free_data
      self :: INOUT

   ENSURE(.xray_r_free_data.associated, "No X-ray R-free reflection data")

      nullify(.data)
      .data => .xray_r_free_data

   end

   assign_pnd
   ! Assign data to the pnd_data

   ENSURE(.pnd_data.associated, "No PND reflection data")

      nullify(.data)
      .data => .pnd_data

   end

   assign_pnd_r_free
   ! Assign data to the pnd_r_free_data
      self :: INOUT

   ENSURE(.pnd_r_free_data.associated, "No PND R-free PND reflection data")

      nullify(.data)
      .data => .pnd_r_free_data

   end

   set_destroy_fragment_atom(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.destroy_fragment_atom)
   ! Generic set
   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}                             ")  ! exit read_loop
      case ("asymmetric_unit_geometry=     "); .read_asymmetric_unit_geometry
      case ("debug_on                      "); .read_debug_on
      case ("debug_off                     "); .read_debug_off
      case ("destroy                       "); .destroy_ptr_part; .set_defaults
      case ("destroy_asymmetric_unit       "); .destroy_asymmetric_unit
      case ("destroy_spacegroup            "); .spacegroup.destroy_ptr_part
      case ("expand_unique_reflections     "); .expand_unique_reflections
      case ("finalize=                     "); .read_finalize
      case ("junk=                         "); .read_junk
      case ("kind=                         "); .read_kind
      case ("merge_equivalents             "); .merge_equivalents
      case ("merge_ordered_equivalents     "); .merge_ordered_equivalents
      case ("pnd_data=                     "); .read_pnd_data
      case ("prune_asymmetric_unit=        "); .read_prune_asymmetric_unit
      case ("put                           "); .put
      case ("put_bond_info_with_errors     "); .put_bond_info_with_errors
      case ("put_bond_info_with_errors_to  "); .put_bond_info_with_errors_to
      case ("put_data_analysis             "); .put_data_analysis
      case ("put_all_reflection_data       "); .put_all_reflection_data
      case ("put_reflection_data           "); .put_reflection_data
      case ("put_reflection_intensities    "); .put_reflection_intensities
      case ("put_reflection_intensities_xd "); .put_reflection_intensities_XD
      case ("r_free_percentage=            "); .read_r_free_percentage
      case ("read_cif                      "); .read_CIF
      case ("redirect                      "); .redirect
      case ("repetition_factors=           "); .read_repetition_factors
      case ("revert                        "); .revert
      case ("same_atom_tol=                "); .read_same_atom_tol
      case ("spacegroup=                   "); .read_spacegroup
      case ("unit_cell=                    "); .read_unit_cell
      case ("unit_cell_tol=                "); .read_unit_cell_tol
      case ("units=                        "); .read_units
      case ("use_manual_repetition_factors="); .read_use_manual_rep_factors
      case ("xray_data=                    "); .read_xray_data

      case ("! Cluster keywords            ")

      case ("atom_density_cutoff=          "); .read_atom_density_cutoff
      case ("defragment=                   "); .read_defragment
      case ("fractional_fragment=          "); .read_fractional_fragment
      case ("generation_method=            "); .read_generation_method
      case ("make_cluster_info             "); .make_cluster_info
      case ("unit_cell_offset=             "); .read_unit_cell_offset
      case ("put_averaged_lff_l_tensors    "); .put_averaged_LFF_tensors
      case ("put_centroid_lff_l_tensors    "); .put_centroid_LFF_tensors
      case ("put_centroid_lff_l_tensors_old"); .put_centroid_LFF_tensors_old
      case ("put_cluster_info              "); .put_cluster_info
      case ("put_lff_info                  "); .put_LFF_info
      case ("radius=                       "); .read_radius

      case default;                       UNKNOWN(word)

      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.data_kind)
      .data_kind.to_lower_case
      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end
   end

   read_finalize
   ! Read whether to finalize the object.
      stdin.read(.finalize)
   end

   read_r_free_percentage
   ! Read the R free percentage
      stdin.read(.r_free_percentage)
      DIE_IF(.r_free_percentage<0,  "percentage must be non-negative")
      DIE_IF(.r_free_percentage>100,"percentage must be less than 100")
   end

   read_same_atom_tol
   ! Read the tolerance for deciding if two atoms are
   ! the same in fractional coordinates.
      self :: INOUT

      stdin.read(.same_atom_tol)

   end

   read_spacegroup ::: leaky
   ! Read the spacegroup
      self :: INOUT

      .spacegroup.read_keywords
      .spacegroup.analyze

   end

   read_unit_cell
   ! Read the unit cell information
      self :: INOUT

   DIE_IF(.xray_data.associated,"enter unit cell information before xray_data= !")
   DIE_IF(.pnd_data.associated, "enter unit cell information before pnd_data= !")

      .unit_cell.read_keywords
      .unit_cell.make_info

   end

   read_unit_cell_tol
   ! Read the tolerance for deciding if two atoms are
   ! the same in fractional coordinates.
      self :: INOUT

      stdin.read(.unit_cell_tol)

   end

   read_xray_data ::: leaky
   ! Read in the xray diffraction data
      self :: INOUT

   DIE_IF(NOT .unit_cell.info_made,"enter unit cell information before xray_data= !")
   DIE_IF(NOT .spacegroup.analyzed,"enter spacegroup information before xray_data= !")
   WARN_IF(.xray_data.associated,"xray diffraction data already defined!")

      ! Create?
      if (.xray_data.disassociated) .xray_data.create

      ! Read, update
      .xray_data.data_kind = "x-ray"
      .xray_data.read_keywords
      .xray_data.update(.unit_cell,.spacegroup)

      ! Use data
      .assign_xray

   end

   read_pnd_data ::: leaky
   ! Read in the pnd diffraction data

      DIE_IF(NOT .unit_cell.info_made,"enter unit cell information before pnd_data= !")
      DIE_IF(NOT .spacegroup.analyzed,"enter spacegroup information before xray_data= !")
      WARN_IF(.pnd_data.associated,"pnd diffraction data already defined!")

      ! Create?
      if (.pnd_data.disassociated) .pnd_data.create

      ! Read, update
      .pnd_data.data_kind = "pnd"
      .pnd_data.read_keywords
      .pnd_data.update(.unit_cell,.spacegroup)

      ! Use data
      .assign_pnd

   end

   read_use_manual_rep_factors ::: leaky, private
   ! Read whether to use manually entered repetition factors.
   ! If set set FALSE, the repetition factors will be destroyed.

      stdin.read(.use_manual_repetition_factors)

      if (.use_manual_repetition_factors) return

      .repetition_factor.destroy

   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
      .repetition_factor.destroy
      stdin.read_ptr(.repetition_factor)
      .use_manual_repetition_factors = TRUE
   end

   read_prune_asymmetric_unit ::: private
   ! Read whether to prune the asymmetric unit or not. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to prune the asymmetric atom list, but for crystal
   ! calculations you must do so.
      stdin.read(.prune_asymmetric_unit)
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File object, with
   ! the "name" taken from stdin.

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.destroy
      cif.create(name)
      cif.open
      cif.find_data_block(found)
      ENSURE(found,"no crystal data block found")

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif,skip_atoms) ::: leaky
   ! Read information from "cif".  If "skip_atoms" is TRUE,
   ! the fragment_atom coordinates are not processed.
      cif :: CIF
      skip_atoms :: BIN, optional, IN

      skip,found :: BIN
      itemvec :: VEC{STR}*

      skip = FALSE
      if (present(skip_atoms)) skip = skip_atoms

      .set_defaults

      ! Read the chemical formula if it is there
      nullify(itemvec)
      cif.read_item("_chemical_formula_sum",.CIF_chemical_formula,itemvec,found)
      if (NOT found) .CIF_chemical_formula = "?"
      DIE_IF(itemvec.associated,"multi line chemical formula")

      ! Read the spacegroup
      .spacegroup.read_CIF(cif)

      ! Read the unit cell
      .unit_cell.read_CIF(cif)

      ! Read the atom list (if requested)
      if (NOT skip) then
         .fragment_atom.read_CIF(cif)
      end

      ! Assume this is X-ray data
      ! BAD !!!
      if (.xray_data.disassociated) .xray_data.create
      .xray_data.data_kind = "x-ray"
      .xray_data.read_CIF(cif)
      .xray_data.update(.unit_cell,.spacegroup)
      .assign_xray

      ! Update
      .update

      ! Eventually, this will be used
      .asymmetric_unit_source = "from-cif"

   end

   read_asymmetric_unit_geometry
   ! Read in the asymmetric unit geometry in crystal coordinates.
   ! The coordinates are read in as a single vector ordered as x,y,z
   ! incrementing fastest, for the first to the last atom.
      geometry :: VEC{REAL}*

   WARN_IF(.asymmetric_unit_geometry.associated,"asymmetric_unit_geometry exists!")

      stdin.read_ptr(geometry)
      ENSURE(modulo(geometry.dim,3)==0,"number of coordinates must be divisible by 3")

      .n_asymmetric_unit_atoms = geometry.dim/3
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,.n_asymmetric_unit_atoms)
      .asymmetric_unit_geometry = reshape(geometry,[3,.n_asymmetric_unit_atoms])
      geometry.destroy

      .asymmetric_unit_source = "manual-input"

   end

! mmCIF

!  Cluster keywords

   read_atom_density_cutoff
   ! This number is used to define a cluster radius (see above). The radius is
   ! defined from it, as the *largest* distance from any atom in the
   ! asymmetric_cell_atom list where the atomic electron density becomes smaller
   ! than this number. It requires that slater or coppens bases are defined for
   ! the asymmetric_cell_atom's, and it requires that the generation method be
   ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
   ! from a fragment, which will correctly produce the Hirshfeld surface.
      self :: INOUT

      stdin.read_quantity(.atom_density_cutoff)

   end

   read_defragment
   ! Read whether to defragment the cluster at the boundaries. If set TRUE, the
   ! cluster ends are defragmented, i.e. any atoms which are bonded at the ends
   ! of the cluster are included into the cluster.
      self :: INOUT

      stdin.read(.defragment)

   end

   read_generation_method
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      self :: INOUT

      generation_method :: STR

      stdin.read(generation_method)

      .set_generation_method(generation_method)

   end

   read_fractional_fragment ::: leaky
   ! Read in the fragment geometry, in fractional coordinates.
   ! NOTE: All fragment atom positions must correspond to the
   ! positions of actual atoms in the crystal lattice.
      self :: INOUT

      fragment_geometry :: MAT{REAL}*
      tmp :: VEC{REAL}*
      n :: INT

      stdin.read_ptr(tmp)
      ENSURE(mod(tmp.dim,3)==0,"# of elements not divisible by 3")

      n = tmp.dim/3
      fragment_geometry.create(3,n)
      fragment_geometry = reshape(tmp,[3,n])
      .set_fragment_geometry(fragment_geometry)

      ! Clean
      fragment_geometry.destroy
      tmp.destroy

   end

   read_radius
   ! Read the radius of the cluster. Usually, all atoms with this distance of
   ! any atom in the fragment_geometry will appear in the cluster.
      self :: INOUT

      stdin.read_quantity(.radius)

   end

   read_unit_cell_offset
   ! Read the add criteria, whether to add atoms by whole clusters within a
   ! certain radius of the starting fragment, or by individual atoms within a
   ! certain distance of the starting fragment.
      self :: INOUT

      offset :: VEC{REAL}(3)

      stdin.read(offset)

      .set_unit_cell_offset(offset)

   end

!  ===============
!  General methods
!  ===============
 
   n_unique_SF_k_pts result (res) ::: PURE
   ! The number of unique k-points for an SF calculation
      self :: IN
      res :: INT

   ENSURE(.spacegroup.analyzed,"spacegroup not analyzed")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.reflections.associated,"no reflection data")

      res = .spacegroup.n_unique_SF_symops * .data.reflections.dim

   end
 
   n_symop_generated_SF_k_pts result (res) ::: PURE
   ! The number of symmetry generated k-points for an SF calculation
      self :: IN
      res :: INT

   ENSURE(.spacegroup.analyzed,"spacegroup not analyzed")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.reflections.associated,"no reflection data")

      res = .spacegroup.n_seitz * .data.reflections.dim

   end

!  =========================================
!  Fragment data, unique operators, Z number
!  =========================================

   make_fragment_data(atom,assign_atom,warnings) ::: leaky
   ! This routine sets the ".fragment_atom" from the "atom" list.
   ! If "assign_atom" is TRUE, ".fragment_atom" is pointed to "atom".
   !
   ! The fragment is a finite portion/model of the crystal, perhaps
   ! one molecule or a cluster of atoms.
   !
   ! In addition a slew of information arrays about the fragment and
   ! crystal are made e.g. like the asymmetric unit atoms, the unit
   ! cell atoms; mapping arrays between these atoms; the stablizer
   ! symops ! for the fragment atoms; and the unit-cell connection
   ! table.
   !
   ! This is a suped-up set_defaults routine.
   !
   ! DETAILS:
   !
   ! A. The .asymmetric_unit_geometry is defined from the symmetry
   !    unique "atoms", if it is not already defined. If it is already
   !    defined the fragment atoms must be symmetry related to these
   !    asymmetric unit atom positions. The asymmetric unit is crucial
   ! B. The .asymmetric_unit_geometry is never destroyed unless
   !    explicitly requested.
   ! 1. The .unit_cell_geometry is made from the asymmetric unit.
   !    Mapping arrays which relate the unit cell atoms to the
   !    asymmetric unit atoms are made,
   ! 2. Other mapping arrays are made which relate the fragment atoms
   !    to the unique asymmetric unit atoms, including sometimes the
   !    symops needed to generate them.
   ! 3. The .repetition factors needed for structure factor calcs on
   !    the fragment are made. The Z number is made.
   !    unchanged (the stabilizer) is made
   ! 4. The unit cell connection table is made.
   ! 5. The set of symmetry operations which leave the fragment
   !    unchanged (the stabilizer) is made
      self :: INOUT
      atom :: VEC{ATOM}*
      assign_atom :: BIN, IN
      warnings :: BIN, optional, IN

   ENSURE(atom.associated,"no atom array")

      if (NOT .spacegroup.analyzed) return

      ! Store the fragment atom list
      if (assign_atom) then
         .fragment_atom => atom ! atom must be destroyable
         .destroy_fragment_atom = FALSE
      else
         .fragment_atom.create_copy(atom)
         .destroy_fragment_atom = TRUE
      end

      if (.debugging("make_fragment_data")) then
         stdout.text(">>make_fragment_data")
         stdout.text("fragment_atom (before):")
         .fragment_atom.put_coordinates
         .fragment_atom.put_ADPs
         stdout.text("fragment_atom.pADP_vector (before):")
         .fragment_atom.put_pADPs
      end

      ! Get fragment geometry from the atom list
      .fragment_geometry.destroy
      .fragment_geometry => .fragment_atom.coordinates_ptr(skip_dummies=TRUE)
      .n_fragment_atoms  =  .fragment_geometry.dim2
      .unit_cell.change_into_fractional(.fragment_geometry)
      .fragment_offset   = int(.fragment_geometry.mean_column_vector)

      ! From fragment geometry make:
      !  .asymmetric_unit_geometry
      !  .unit_cell_geometry
      !  .asymmetric_unit_atoms
      !  .unit_cell_atom
      if (.asymmetric_unit_geometry.disassociated) then
         .make_asymmetric_unit(.prune_asymmetric_unit,warnings)
         if (.asymmetric_unit_source=="?") &
             .asymmetric_unit_source = "from-fragment"
      end

      ! Sanity check
      DIE_IF(.asymmetric_unit_atom.disassociated,"no asymmetric_unit_atom list!")

      ! Relate fragment atoms to unit cell
      .make_frag_atom_for_cell_atom

      ! Make unique fragment atoms
      .make_unique_frag_atoms

      ! Make the unit cell connection table
      .make_unit_cell_connections
      .make_uc_vdw_connections

      ! Z factors and zep. factors for SF calculations
      .make_repetition_factors
      .make_asym_atom_sym_factors
      .make_frag_atom_sym_factors
      .Z = .z_factor

      ! Symops which leave fragment_geometry unchanged
      .make_stabilizer_symops
      .make_stabilizer_xyz_matrices

      .fragment_info_made = TRUE

   end

   make_asymmetric_unit(prune_asymmetric_unit,warnings) ::: leaky, private
   ! Get the all the atom positions in the unit cell. Also make the
   ! symops associated with each unit cell atom when it is made from
   ! the asymmetric unit atoms. If "prune_asymmetric_unit" is present
   ! and true, any non-asymmetric unit atoms are eliminated from the
   ! asymmetric unit. This should always be done.
   ! NOTE: .fragment_atom is in the cartesian axis system, but
   !       .fragment_geometry is in the fractional crystal system.
      self :: INOUT
      prune_asymmetric_unit :: BIN, optional, IN
      warnings :: BIN, optional, IN

   ENSURE(.fragment_atom.associated,"no .fragment_atom")
   ENSURE(.fragment_geometry.associated,"no .fragment_geometry")
   ENSURE(.asymmetric_unit_geometry.disassociated,"asymmetric unit exists")

      pa,pos :: VEC{REAL}(3)
      offset :: VEC{INT}(3)
      seitz :: MAT3{REAL}*
      asymmetric_unit_geometry :: MAT{REAL}*
      n,a,b,s,col, i,u :: INT
      prune,warn,new,unique,frac,redundant,mess :: BIN
      pruned :: MAP{INT,INT}*
      list,cols :: VEC{INT}*
      tol :: REAL

      ! Set default options
      prune = TRUE
      warn = TRUE
      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit
      if (present(warnings)) warn = warnings

      ! Clean up from before
      .unit_cell_geometry.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy
      .asym_shift_for_unit_cell_atom.destroy

      ! List of indices of the asymmetric unit atoms to be made
      list.create(.n_fragment_atoms)
      list = [(a, a=1,.n_fragment_atoms)]

      ! Initialise .asymmetric_unit_geometry as the whole fragment
      .asymmetric_unit_geometry.create_copy(.fragment_geometry)
      .n_asymmetric_unit_atoms = .n_fragment_atoms

      ! Copy asymmetric unit & shift it to the unit cell
      asymmetric_unit_geometry.create_copy(.asymmetric_unit_geometry)
      .put_to_unit_cell(asymmetric_unit_geometry)

      ! Append new atoms "n" to unit cell
      .unit_cell_geometry.create(3,0)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = CRYSTAL_SAME_ATOM_TOL

      ! Fractional atom occupancies?
      frac = .fragment_atom.has_disorder
      WARN_IF(frac,"This structure has fractional occupancies and is disordered.")

      ! Initial loop counters
      pruned.create(0)
      redundant = FALSE
      n = 0 ! unit cell atom counter
      a = 0 ! asymmetric unit atom counter

      ! Loop: atoms "a" in
      ! the asymmetric unit
      do

         ! Next asymmetric unit atom
         a = a + 1

         ! Loop over symops
         do s = 1,.spacegroup.n_seitz

            ! Get the (unshifted) unit atom cell-offset
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,1,to_unit_cell=TRUE,unit_cell_shift=offset)

            ! Transform (shifted) asym unit atom with symop "s"
            pa = asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)

            ! Prune symmetry redundant atoms?
            if (prune) then

               do ! remove *all* redundant atoms

                  ! Is symmetry-generated atom "pa" already in the asymmetric unit?
                  col = asymmetric_unit_geometry(:,a+1:).index_for_column(pa,tol)
                  unique = col==0

                  if (unique) exit

                  ! Actual atom index to prune
                  b = col + a

                  ! If already there, are the atoms at the two sites distinct?
                  unique = .fragment_atom.are_distinct(list(a),list(b))
                  if (unique) exit

                  ! Store pruned pair
                  pruned.append_pair(list(a),list(b))

                  ! This is a symmetry-redundant structure
                  redundant = TRUE
                  frac = NOT .fragment_atom(list(b)).site_occupancy.equals(ONE)

                  ! Prune the atom
                  .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
                  .asymmetric_unit_geometry.prune_column(b)
                  asymmetric_unit_geometry.prune_column(b)
                  list.prune_element(b)

               end

            end

            ! Is generated position "pa" new in the unit cell?
            nullify(cols)
            cols => .unit_cell_geometry.indices_for_column(pa,tol)
            new  =  cols.dim==0

            ! If old, is it distinct? E.g. different occupancy?
            if (NOT new) then
               do i = 1,cols.dim
                  b = .asym_atom_for_unit_cell_atom(cols(i))
                  new = .fragment_atom.are_distinct(list(a),list(b))
                  if (NOT new) exit
               end
            end
            cols.destroy

            if (NOT new) cycle

            ! New unit cell atom here ...
            n = n + 1

            ! Append it's info ...
            .unit_cell_geometry.append_column(pa)
            .asym_atom_for_unit_cell_atom.append(a)
            .asym_symop_for_unit_cell_atom.append(s)
            .asym_shift_for_unit_cell_atom.append_column(offset)

            ! If s=1 it must be an asymmetric unit atom
            if (s==1) then
               .unique_unit_cell_atom.append(n)
               .unique_uc_atom_offset.append(offset)
               .is_asym_unit_cell_atom.append(TRUE)
            else
               .is_asym_unit_cell_atom.append(FALSE)
            end

         end

         ! Finished?
         if (a==.n_asymmetric_unit_atoms) exit

      end

      .n_unit_cell_atoms = n

      ! Sanity check and print out
      mess = warn AND redundant AND prune
    ! WARN_IF(mess,"Symmetry-redundant atoms were pruned.")

      ! Die if pruned a symmetry-redundant fractional atom.
      if (mess AND frac) then

         WARN("Symmetry-redundant pruned atom had a fractional occupancy!")

         stdout.flush
         stdout.text("Fragment atom list:")
         .fragment_atom.put_coordinates

         stdout.flush
         stdout.text("Parent and pruned fragment atoms:")
         stdout.flush
         do i = 1,pruned.n_keys
            stdout.put(pruned.keys(i))
            stdout.put(pruned.values(i))
            stdout.flush
         end
         WARN("Symmetry-redundant pruned atom had a fractional occupancy!")

      end

      ! Die if no unit cell
      DIE_IF(NOT .unit_cell_geometry.associated,"The unit_cell_geometry was not created!")

      ! >> Make the asymmetric unit atoms <<
      ! NOTE: everything in cartesian system.
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_atom.create_copy(.fragment_atom,list)

      ! >> Make the unit cell atoms <<
      .unit_cell_atom.destroy
      .unit_cell_atom.create(.n_unit_cell_atoms)
      seitz => .xyz_seitz_matrices
      do u = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)
         ! Copy the parent asymmetric atom
         .unit_cell_atom(u).copy(.asymmetric_unit_atom(a))
         ! Transform the pADPs (which must be in cartesians)
         .unit_cell_atom(u).transform_pADP_vector_with(seitz(:,:,s))
         ! Reset position manually
         pos = matmul(.unit_cell.direct_matrix,.unit_cell_geometry(:,u))
         .unit_cell_atom(u).set_position(pos)
      end
      seitz.destroy
      .unit_cell_atom.set_axis_system_to("cartesian")
      .unit_cell_atom.update

      ! Clean
      asymmetric_unit_geometry.destroy
      list.destroy
      pruned.destroy

   end

   make_frag_atom_for_cell_atom ::: leaky, private
   ! Arrays which relate the fragment atoms to the unit cell atoms.
      self :: INOUT

   ENSURE(.fragment_atom.associated,                "no .fragment_atom")
   ENSURE(.fragment_geometry.associated,            "no .fragment_geometry")
   ENSURE(.unit_cell_geometry.associated,           "no .unit_cell_geometry")
   ENSURE(.asymmetric_unit_atom.associated,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.associated, "no .asym_atom_for_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.associated,"no .asym_symop_for_cell_atom")
   ENSURE(.spacegroup.analyzed,                  "no spacegroup info")

      sh :: VEC{INT}(3)
      pu,pa,pf,pf0 :: VEC{REAL}(3)
      u,f,a,s :: INT
      found,ident :: BIN
      tol :: REAL

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = .same_atom_tol

      ! Create the arrays we want
      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .unit_cell_shft_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      .frag_atom_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .unit_cell_atom_for_frag_atom.create(.n_fragment_atoms)
      .unit_cell_shft_for_frag_atom.create(3,.n_fragment_atoms)
      .frag_atom_for_asym_atom.create(.n_asymmetric_unit_atoms)
      .asym_atom_for_frag_atom.create(.n_fragment_atoms)
      .asym_symop_for_frag_atom.create(.n_fragment_atoms)
      .asym_shift_for_frag_atom.create(3,.n_fragment_atoms)

      ! Initialise
      .frag_atom_for_unit_cell_atom = 0
      .unit_cell_atom_for_frag_atom = 0
      .unit_cell_shft_for_frag_atom = 0
      .frag_atom_for_asym_atom = 0
      .asym_atom_for_frag_atom = 0

      ! Loop over fragment atoms
      do f = 1,.n_fragment_atoms

         ! Shift fragment atom to unit cell
         pf0 = .fragment_geometry(:,f)
         pf  = pf0
         .put_to_unit_cell(pf,shift=sh)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Asymmetric atom a for unit cell atom u
            a = .asym_atom_for_unit_cell_atom(u)

            ! Unit cell position
            pu = .unit_cell_geometry(:,u)

            if (.debugging("make_frag_atom_for_cell_atom")) then
               stdout.show("f                         =",f)
               stdout.show("u                         =",u)
               stdout.show("a                         =",a)
               stdout.show("fragment position  pf0    =",pf0)
               stdout.show("fragment position  pf     =",pf)
               stdout.show("cell atom position pu     =",pu)
               stdout.show("shift sh (pf0 + sh = pu)  =",sh)
            end

            ! Is unit cell atom u the fragment atom f?
            found = pu.same_as(pf,tol)
            ident = .fragment_atom(f).is_xtal_identical_kind_to(.asymmetric_unit_atom(a))

            if (.debugging("make_frag_atom_for_cell_atom")) then
               stdout.show("same pos?                 =",found)
               stdout.show("xtal identical            =",ident)
               if (found) &
               stdout.text("SAME POS")
               stdout.text("===========================")
               stdout.text("===========================")
            end

            found = found AND ident

            ! Cycle if not the same
            if (NOT found) cycle

            ! Relate unit cell atom and fragment atom
            ! These are identical by translation.
            .frag_atom_for_unit_cell_atom(u) = f
            .unit_cell_atom_for_frag_atom(f) = u
            .unit_cell_shft_for_frag_atom(:,f) = sh

            ! Relate asym unit atom and fragent atom
            ! Maybe >1 frag atom  matching the asym atom
            .asym_atom_for_frag_atom(f) = a
            if (.frag_atom_for_asym_atom(a)==0) &
                .frag_atom_for_asym_atom(a) = f

            ! Asym symop which can generate this frag atom
            s = .asym_symop_for_unit_cell_atom(u)
            .asym_symop_for_frag_atom(f) = s

            ! Get shift for asym atom -> frag atom
            pa = .asymmetric_unit_geometry(:,a)
            pf = .fragment_geometry(:,f)
            .transform_position(pa,s,ignore_glide=TRUE)
            .asym_shift_for_frag_atom(:,f) = pf - pa

            exit

         end

         if (NOT found) then
            DIE("fragment atom "//f.to_str.trim//" was not found in the unit cell")
         end

      end

      ! Relate unit cell atom to parent frag atom
      ! These are identical by a crystal symop.
      .frag_parent_for_cell_atom.destroy
      .frag_parent_for_cell_atom.create(.n_unit_cell_atoms)
      do u = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(u)
         f = .frag_atom_for_asym_atom(a)
         .frag_parent_for_cell_atom(u) = f
      end

   end

   make_unique_frag_atoms ::: leaky, private
   ! Make the unique fragment atoms (these are those corresponding to
   ! the asymmetric unit atoms) and also make symops which relate the
   ! non-unique to the unique.
      self :: INOUT

   ENSURE(.asym_atom_for_frag_atom.associated, "no .asym_atom_for_frag_atom")
   ENSURE(.unit_cell_atom_for_frag_atom.associated, "no .unit_cell_atom_for_frag_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.associated,"no .asym_symop_for_cell_atom")

      f,a,m,u,s,t :: INT
      unique :: BIN

      ! Create the arrays we want
      .unique_frag_atom.destroy
      .unique_index_for_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy

      .unique_index_for_frag_atom.create(.n_fragment_atoms)
      .unique_atom_for_frag_atom.create(.n_fragment_atoms)
      .unique_symop_for_frag_atom.create(.n_fragment_atoms)

      .n_unique_frag_atoms = 0

      ! Loop over the fragment atoms
      do f = 1,.n_fragment_atoms

         ! Asym atom for this fragment atom
         a = .asym_atom_for_frag_atom(f)

         ! Asym symop which can generate this frag atom
         u = .unit_cell_atom_for_frag_atom(f)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Does this asym atom "a" occur before?
         ! If not, its unique.
         m = .asym_atom_for_frag_atom(1:f-1).index_of_value(a)
         unique = m==0
         if (unique) then
            .n_unique_frag_atoms = .n_unique_frag_atoms + 1
            .unique_index_for_frag_atom(f) = .n_unique_frag_atoms
            .unique_atom_for_frag_atom(f) = f
            .unique_symop_for_frag_atom(f) = 1 ! identity
            .unique_frag_atom.append(f)
         else
            .unique_index_for_frag_atom(f) = 0
            .unique_atom_for_frag_atom(f) = m
            u = .unit_cell_atom_for_frag_atom(m)
            t = .asym_symop_for_unit_cell_atom(u)
            t = .spacegroup.inverse_of_symops(t)   ! inverse of symop(t) maps m -> a
            t = .spacegroup.product_of_symops(s,t) ! s maps a -> f (except for trans)
            .unique_symop_for_frag_atom(f) = t
         end

      end

   end

   make_unit_cell_connections ::: leaky
   ! From the .asymmetric_unit_atom list make the .unit_cell_connection
   ! table and the .unit_cell_mol_for_atom list which has the list of
   ! distinct molecules in the unit cell i.e. those groups of unit
   ! cell atoms which are connected to each other (ignoring/accounting
   ! for translational symmetry). NOTE: only connections to
   ! next-neighboring unit cells are considered regardless of the size
   ! of covalent radii.
      self :: INOUT

   ENSURE(.unit_cell_geometry.associated,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.associated,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom list")

      new :: VEC{VEC_{INT}}*
      unit_cell_mol_for_atom,unique :: VEC{INT}*
      geom0,geom1 :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3, mi,mj :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .unit_cell_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .unit_cell_connection.create(.n_unit_cell_atoms,0)
      .unit_cell_mol_for_atom.create(.n_unit_cell_atoms)

      ! Set worst case scenario: all atoms on different molecules
      unit_cell_mol_for_atom.create(.n_unit_cell_atoms)
      do i = 1,.n_unit_cell_atoms
        unit_cell_mol_for_atom(i) = i
      end

      ! Define a new connected atom: its index and 3-element shift
      new.create(1)
      new(1).element.create(4)

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_matrix
      geom0.create(3,.n_unit_cell_atoms)
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0
      h2 = 0
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i)

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom0(:,j)
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              new(1)[:] = [h1,h2,h3,j]; .unit_cell_connection(i).element.append(new)
              new(1)[4] = i;            .unit_cell_connection(j).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)

              ! Replace all previous by the lowest mol
              if (mj<mi) then
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms)
      do h1 = -1,1
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) ! Atom i belongs to mol "mi"

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom1(:,j)
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              new(1)[:] = [h1,h2,h3,j]
              .unit_cell_connection(i).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)
              if (mj<mi) then        ! replace all previous by the lowest mol
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy; geom0.destroy
      new.destroy

      ! Now make the .unit_cell_mol_for_atom list consecutive
      .unit_cell_mol_for_atom = unit_cell_mol_for_atom
      unique => unit_cell_mol_for_atom.unique_elements
      unique.sort
      .n_unit_cell_mols = unique.dim
      do mi = 1,.n_unit_cell_mols
        mj = unique(mi)
        if (mj==mi) cycle
        where (unit_cell_mol_for_atom==mj) .unit_cell_mol_for_atom = mi
      end
      unique.destroy
      unit_cell_mol_for_atom.destroy

   end

   make_uc_vdw_connections ::: leaky
   ! From the .asymmetric_unit_atom list make the .uc_vdw_connection
   ! table. Essentially aame as above with different bond criteria.
      self :: INOUT

   ENSURE(.unit_cell_geometry.associated,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.associated,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom list")
   ENSURE(.unit_cell_mol_for_atom.associated,"no unit_cell_mol_for_atom list")

      vdw :: VEC{VEC_{INT}}*
      geom0,geom1 :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3 :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .uc_vdw_connection.destroy
      .uc_vdw_connection.create(.n_unit_cell_atoms,0)

      ! Define a new connected atom: its index and 3-element shift
      vdw.create(1)
      vdw(1).element.create(4)

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_matrix
      geom0.create(3,.n_unit_cell_atoms)
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0
      h2 = 0
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom0(:,j)
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              vdw(1)[:] = [h1,h2,h3,j]; .uc_vdw_connection(i).element.append(vdw)
              vdw(1)[4] = i;            .uc_vdw_connection(j).element.append(vdw)

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms)
      do h1 = -1,1
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i)
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms

              ! Gross test for closeness
              pos_j = geom1(:,j)
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j)
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              vdw(1)[:] = [h1,h2,h3,j]
              .uc_vdw_connection(i).element.append(vdw)

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy; geom0.destroy
      vdw.destroy

   end

   z_factor result (res) ::: PURE
   ! The Z crystallographic factor for ".fragment_geometry", defined
   ! as the ratio of the number of electrons in the unit cell on the
   ! number of electrons in the fragment.
      self :: IN
      res :: REAL

   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom")
   ENSURE(.fragment_atom.associated,       "no fragment_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.associated,"no asym_atom_for_unit_cell_atom")

      ue,fe :: REAL

      ! Get # of electrons in unit cell
      ue = .asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).no_of_electrons

      ! Get # of electrons in fragment
      fe = .fragment_atom.no_of_electrons

      ! Z factor is the ratio
      res = ue/fe

   end

   no_of_unit_cell_electrons result (res) ::: PURE
   ! The totl number of electrons in the unit cell aka F_000.
      self :: IN
      res :: REAL

   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom")
   ENSURE(.asym_atom_sym_factor.associated, "no .asym_atom_sym_factor")

      a, n,r :: INT

      n = .spacegroup.n_seitz

      res = 0

      do a = 1,.n_asymmetric_unit_atoms
         r   = int(.asym_atom_sym_factor(a))
         res = res + .asymmetric_unit_atom(a).atomic_number*n/r
      end

   end

!  ==================
!  Repetition factors
!  ==================

   make_repetition_factors ::: leaky, private
   ! The number of times *any* fragment atom is mapped onto a
   ! particular fragment atom with index "a" under *all* spacegroup
   ! symmetry group, is the ".repetition_factor(a)".
   ! It is used to correct structure factors for fragment geometries
   ! which are "oversampled" relative to the asymmetric cell geometry.
      self :: INOUT

   ENSURE(.fragment_geometry.associated, "no fragment_geometry!")

      pa,pb :: VEC{REAL}(3)
      a,b,n,n_same :: INT
      same :: BIN
      tol :: REAL

      if (.use_manual_repetition_factors) then

         ENSURE(.repetition_factor.associated,"no repetiton_factors entered!")

      else

         tol = CRYSTAL_SAME_ATOM_TOL

         .repetition_factor.destroy
         .repetition_factor.create(.n_fragment_atoms)

         do a = 1,.n_fragment_atoms

            pa = .fragment_geometry(:,a)
            .put_to_unit_cell(pa)

            n_same = 0
            do b = 1,.n_fragment_atoms
            do n = 1,.spacegroup.n_seitz
               pb = .fragment_geometry(:,b)
               .transform_position(pb,n,to_unit_cell=TRUE)
               same = pa.same_as(pb,tol)
               if (same) n_same = n_same + 1
            end
            end

            .repetition_factor(a) = n_same

         end

      end

   end

   make_asym_atom_sym_factors ::: leaky, private
   ! The number of times an asymmetric cell atom with index "a" is
   ! mapped into itself under the symmetry group is the
   ! ".asym_atom_sym_factor(a)". Also record the stabilizing
   ! operations in ".asym_atom_stabilizer(a)[:]". These are used in
   ! atomic-type structure factor calculations based on the asymmetric
   ! cell geometry.
      self :: INOUT

   ENSURE(.fragment_geometry.associated, "no fragment_geometry!")

      pa,pn :: VEC{REAL}(3)
      a,n,n_same :: INT
      same :: BIN
      tol :: REAL

      tol = CRYSTAL_SAME_ATOM_TOL

      .asym_atom_sym_factor.destroy
      .asym_atom_stabilizer.destroy
      .asym_atom_sym_factor.create(.n_asymmetric_unit_atoms)
      .asym_atom_stabilizer.create(.n_asymmetric_unit_atoms)

      .n_stabilizer_max = 0

      do a = 1,.n_asymmetric_unit_atoms

         pa = .asymmetric_unit_geometry(:,a)
         .put_to_unit_cell(pa)

         n_same = 0

         do n = 1,.spacegroup.n_seitz

            pn = pa
            .transform_position(pn,n,to_unit_cell=TRUE)
            same = pa.same_as(pn,tol)

            if (NOT same) cycle

            n_same = n_same + 1
            .asym_atom_stabilizer(a).element.append(n)

            .n_stabilizer_max = max(n_same,.n_stabilizer_max)

         end

         .asym_atom_sym_factor(a) = n_same

      end

   end

   make_frag_atom_sym_factors ::: leaky, private
   ! The number of times a fragment atom with index "f" is mapped into
   ! itself under the symmetry group is ".frag_atom_sym_factor(a)". 
   ! The stabilizing operations in ".frag_atom_stabilizer(a)[:]". 
   ! These are used in atomic-type structure factor calculations based
   ! on the fragment geometry.
      self :: INOUT

   ENSURE(.fragment_geometry.associated, "no fragment_geometry!")
   ENSURE(.asym_atom_sym_factor.associated, "no asym_atom_sym_factor!")
   ENSURE(.asym_atom_stabilizer.associated, "no asym_atom_sym_factor!")

      f,a :: INT

      .frag_atom_sym_factor.destroy
      .frag_atom_stabilizer.destroy
      .frag_atom_sym_factor.create(.n_fragment_atoms)
      .frag_atom_stabilizer.create(.n_fragment_atoms)

      do f = 1,.n_fragment_atoms

         a = .asym_atom_for_frag_atom(f)

         .frag_atom_sym_factor(f) = .asym_atom_sym_factor(a)
         .frag_atom_stabilizer(f).element.create_copy(.asym_atom_stabilizer(a).element)

      end

   end

!  =============================
!  Reset hydrogen atom positions
!  =============================

   reset_H_bond_lengths_in(atom,H_bond_length,reset)
   ! Resets the coordinates of the single-bonded H "atoms" so that
   ! their bond lengths have those in the "H_bond_length" array.
   ! Negative values mean no changes. If present "reset" is set
   ! TRUE if at least on the H atom positions was reset.
   ! *Multiple bonded H atom (from unit cell conn. table) *ignored*
   ! WARNING: this routine destroys all the fragment data.
      self :: PTR
      atom :: VEC{ATOM}*
      H_bond_length :: VEC{REAL}*
      reset :: BIN, optional, OUT

   ENSURE(H_bond_length.associated,"no H_bond_length array")

      lb,ub,ua,fh,fa,uh,Za,n :: INT
      hh,ph,pa,sh,ch,ca,dd,d :: VEC{REAL}(3)
      rcm,inv :: MAT{REAL}(3,3)
      done :: BIN

      done = FALSE
      if (present(reset)) reset = done

      if (all(H_bond_length<ZERO)) return

      ! Destroy all the fragment and asymmetric unit data
      .destroy_fragment_data
      .destroy_asymmetric_unit

      ! Make unit cell connection table
      .make_fragment_data(atom,assign_atom=FALSE)

      ! Elements whose bond lengths to change
      lb = lbound(H_bond_length,1)
      ub = ubound(H_bond_length,1)

      ! Cell matrices
      rcm = .unit_cell.direct_matrix
      inv = .unit_cell.inverse_matrix

      ! Loop fragment atom positions
      do fh = 1,.n_fragment_atoms

         ! If fragment atom is not H atom, cycle ...
         if (atom(fh).atomic_number/=1) cycle

         ! The H atom  must have only one bond
         uh = .unit_cell_atom_for_frag_atom(fh)
         if (.unit_cell_connection(uh).element.dim>1) then
            n = .unit_cell_connection(uh).element.dim
            WARN("Hydrogen #"//fh.to_str.trim//" is bonded to "//n.to_str.trim//" atoms")
            cycle
         end

         ! Which frag atom is the H connected to?
         ua = .unit_cell_connection(uh)[1][4]
         fa = .frag_atom_for_unit_cell_atom(ua)
         if (fa==0) cycle

         ! If it isn't one of those to be reset, cycle
         Za = atom(fa).atomic_number
         if (Za<lb OR Za>ub) cycle
         if (H_bond_length(Za)<ZERO) cycle

         done = TRUE

         ! Get the H atom pos relative to A
         hh = .fragment_geometry(:,fh)
         pa = .fragment_geometry(:,fa)
         dd = hh - pa
         d  = mod(dd,[ONE,ONE,ONE])
         where (d> HALF) d = d - ONE
         where (d<-HALF) d = d + ONE
         ph = pa + d
         sh = ph - hh

         ! Get new cartesian H atom position
         ch = matmul(rcm,ph)
         ca = matmul(rcm,pa)
         dd = ch - ca
         dd.normalise
         ch = ca + H_bond_length(Za)*dd

         ! Put H atom back
         ph = matmul(inv,ch) - sh
         ch = matmul(rcm,ph)

         ! Reset the H atom position
         atom(fh).set_position(ch)

      end

      if (present(reset)) reset = done

      ! Clean up
      .destroy_fragment_data

   end

!  ================
!  Position changes
!  ================

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      g :: MAT{REAL}
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional

   ENSURE(g.dim1==3,"incorrect size for array g")

      n :: INT

      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end

   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift)
   ! Transform the position "p" in fractional coordinates with the Seitz
   ! operator with index "op". If present, "translate" will be added to the
   ! transformed position. If present and TRUE, "ignore_glide" will not add the
   ! glide vector part of the Seitz operator.  If present and TRUE,
   ! "to_unit_cell" will translate the fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell, and "unit_cell_shift" is set to the translation
   ! vector required to do this.
      self :: IN
      p :: VEC{REAL}(3), INOUT
      op :: INT, IN
      translate :: VEC{REAL}(3), optional, IN
      ignore_glide :: BIN, optional, IN
      to_unit_cell :: BIN, optional, IN
      unit_cell_shift :: VEC{INT}(3), optional, OUT

   ENSURE(.spacegroup.seitz.associated,"Seitz matrices not initialized")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")

      ignore,to_cell :: BIN

      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide

      if (ignore) then
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p) &
                 + .spacegroup.seitz(1:3,4  ,op)
      end

      if (present(translate)) p = p + translate

      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell

      if (to_cell) &
         .put_to_unit_cell(p,unit_cell_shift)

   end

   put_to_unit_cell(g) ::: PURE
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      self :: IN
      g :: MAT{REAL}, INOUT

   ENSURE(g.dim1==3 OR g.dim2==3, "incorrect shape for array g")

      n :: INT

      if (g.dim1==3) then
         do n = 1,g.dim2
            .put_to_unit_cell(g(:,n))
         end
      else
         do n = 1,g.dim1
            .put_to_unit_cell(g(n,:))
         end
      end

   end

   put_to_unit_cell(p,shift) ::: PURE
   ! Transform the position "p" in fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell. If present, "shift" is set to the translation
   ! vector needed to effect the change to the unit cell.
      self :: IN
      p :: VEC{REAL}(3), INOUT
      shift :: VEC{INT}(3), OUT, optional

   ENSURE(size(p)==3, "p must be length 3")

      new,pi :: VEC{REAL}(3)
      tol :: REAL

      tol = .unit_cell_tol

      ! Change p to cell boundary (within tol)
      pi = REALIFY(nint(p))
      where (abs(p-pi)<tol) p = pi

      ! The new unit cell coordinate
      new = p - floor(p)

      ! The shift applied to the (corrected) p
      ! to get it into the unit cell ...
      if (present(shift)) shift = int(new - p)

      ! Set p
      p = new

   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      self :: INOUT
      g :: MAT{REAL}

   ENSURE(size(g,1)==3, "incorrect size for array g")

      n,n_atom :: INT
      center :: VEC{INT}(3)

      if (FALSE) self = self

      n_atom = g.dim2
      center = CRYSTAL::unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - center
      end

   end

   unit_cell_offset(g) result (res) ::: selfless, private
   ! Which hkl indices match the center of the fragment geometry "g" when
   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
   ! not always.
      g :: MAT{REAL}
      res :: VEC{INT}(3)
   ENSURE(g.dim1==3, "incorrect size for array g")
      res = int(g.sum_column_vectors/g.dim2)
   end

!  ===============
!  Fragment widths
!  ===============

   fragment_width result (res) ::: pure
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      self :: IN
      res :: VEC{REAL}(3)

   ENSURE(.fragment_geometry.associated,"no fragment geometry")

      res = .fragment_geometry.max_abs_column_difference

   end

!  ==============
!  Seitz matrices
!  ==============

   make_xyz_seitz_matrices(res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.associated,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end

   end

   xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system.
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.associated,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end

   end

   transposed_xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system.
      self :: IN
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.associated,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky

      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.reciprocal_matrix, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.unit_cell.direct_matrix)))
      end

   end

!  ===========
!  Stabilizers
!  ===========

   make_stabilizer_symops ::: leaky, private
   ! Make a list of the indices of the Seitz matrices,
   ! ".stabilizer_symop", which will generate the same geometries to
   ! that in ".fragment_geometry" when both the original and
   ! transformed geometries are converted to unit cell coordinates.
   ! ".n_stabilizer_symops" is set to the number of these symmetry
   ! operations.
   ! NOTE: geometries NOT whole-shifted to unit cell ... should they ! be?
      self :: INOUT

      g1,gi :: MAT{REAL}*
      i,n :: INT
      identical :: BIN

      .stabilizer_symop.destroy
      .stabilizer_symop.create(.spacegroup.n_seitz)

      g1.create(3,.n_fragment_atoms)
      gi.create(3,.n_fragment_atoms)
      g1 = .fragment_geometry

      n = 1
      .stabilizer_symop(1) = 1

      do i = 2,.spacegroup.n_seitz

         gi = .fragment_geometry
         .transform_geometry(gi,i)
         identical  = ::is_same_geometry(gi,g1)

         if (NOT identical) cycle

         n = n + 1
         .stabilizer_symop(n) = i

      end

      gi.destroy
      g1.destroy

      .n_stabilizer_symops = n
      .stabilizer_symop.shrink(n)

   end

   is_same_geometry(geom_i,geom_j) result (res) ::: selfless, private, PURE
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: MAT{REAL}, IN
      res :: BIN

   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")

      i,j,n_atom :: INT
      skip :: VEC{BIN}*
      same :: BIN
      tol :: REAL

      tol = CRYSTAL_SAME_ATOM_TOL

      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE

      do i = 1,n_atom
      do j = 1,n_atom

         same = geom_i(:,i).same_as(geom_j(:,j),tol)

         if (NOT same OR skip(j)) cycle

         skip(j) = TRUE
         exit

      end
      end

      res = all(skip) ! True if all atoms in i were matched (skipped) in j

      skip.destroy

   end

   xyz_stabilizer_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis which stabilize the fragment geometry.
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.associated,"no Seitz matrices")
   ENSURE(.stabilizer_symop.associated,"no stabilizer symop matrices")
      i,s :: INT
      res.create(3,3,.n_stabilizer_symops)
      do i = 1,.n_stabilizer_symops
         s = .stabilizer_symop(i)
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,s),.unit_cell.inverse_matrix))
      end
   end

   make_stabilizer_xyz_matrices ::: leaky, private
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is a stabilizer symop.
   ! WARNING: this routine is tied to an explicit ordering of the cartesian
   ! gaussian basis functions in a shell.
      str :: MAT3{REAL}*

      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      str.create(1,1,.n_stabilizer_symops)
      str = ONE
      .str => str                          ! 1  x 1
      .ptr => .xyz_stabilizer_matrices     ! 3  x 1
      .dtr => .ptr.gaussian_d_xyz_matrices ! 6  x 6
      .ftr => .ptr.gaussian_f_xyz_matrices ! 10 x 10
      .gtr => .ptr.gaussian_g_xyz_matrices ! 15 x 15

   end

   xyz_stabilizer_matrix(n,l) result (res)
   ! Return the "n"-th stabilizer representation matrix for xyz
   ! product found in a gaussian shell of angular momentum "l"
      n,l :: INT
      res :: MAT{REAL}*
   ENSURE(l>=0,"l must be non-negative")
   ENSURE(l<5, "l must be less than 5 (no h functions or higher)")
      select case (l)
         case(0); res => .str(:,:,n)
         case(1); res => .ptr(:,:,n)
         case(2); res => .dtr(:,:,n)
         case(3); res => .ftr(:,:,n)
         case(4); res => .gtr(:,:,n)
         case default; DIE("not implemented beyond l=4")
      end
   end

!  ===========================
!  Cluster generation routines
!  ===========================

!   read_cluster ::: leaky
!   ! Read in the crystal cluster data. NOTE: the .atom list must correspond to
!   ! the (unpruned or pruned) asymmetric unit cell geometry of the .crystal.
!      self :: INOUT
!
!   ENSURE(.atom.associated,"no atom data")
!   ENSURE(.crystal.associated,"no crystal data")
!
!      .crystal.make_fragment_data(.atom,assign_atom=TRUE)
!
!   DIE_IF(.crystal.asymmetric_unit_atom.disassociated,"atom list missing asym atoms")
!
!      .cluster.destroy
!      .cluster.create(.crystal)
!
!      .cluster.read_keywords
!
!   end
!
!   create_cluster ::: leaky
!   ! Create a new "self" by generating a cluster from information
!   ! stored in .cluster.  The original molecule replaced by the
!   ! *cluster-fragent* and stored in .saved. The new molecule is
!   ! created from the cluster geometry.
!      self :: IN
!
!   ENSURE(.crystal.associated,"no crystal data")
!   ENSURE(.cluster.associated,"no cluster data")
!   ENSURE(.cluster.info_made,"no cluster data")
!
!      cluster :: CLUSTER*
!
!      cluster.create(self)
!
!      stdout.flush
!      stdout.text("Resetting molecule to cluster fragment")
!
!      ! Reset .atom list to the *cluster-fragment*
!      .atom.destroy
!      .cluster.create_fragment_atom_list(.atom)
!
!      ! Finalize basis on new .atom list
!      .atom_info_made = FALSE
!      .BASE:set_atom_info
!      .BASE:finalize_atom_groups
!      .BASE:resolve_basis_info
!      .crystal.make_fragment_data(.atom,assign_atom=TRUE)
!
!      ! Message
!      stdout.flush
!      stdout.text("Saving old molecule; making new cluster")
!      stdout.flush
!
!      ! Save this molecule & get a clean new molecule
!      .BASE:save
!
!      ! The name for the new cluster
!      .name = trim(.saved.name) // "_cluster"
!
!      ! If a CIF exists, copy that
!      if (.saved.cif.associated) .cif.create_copy(.saved.cif)
!
!      ! Saved crystal is the same
!      .crystal.create_copy(.saved.crystal)
!
!      ! Set .atom list from (saved) cluster
!      ! Don't make a new cluster, let the user do it.
!      .saved.cluster.create_atom_list(.atom)
!
!      ! Finalize atom info
!      .BASE:set_atom_info
!      .BASE:finalize_atom_groups
!
!      ! Create basis sets
!      if (.saved.basis.associated)               .basis.create_copy(.saved.basis)
!      if (.saved.slaterbasis.associated)   .slaterbasis.create_copy(.saved.slaterbasis)
!      if (.saved.coppensbasis.associated) .coppensbasis.create_copy(.saved.coppensbasis)
!      .basis_name        = .saved.basis_name
!      .slaterbasis_name  = .saved.slaterbasis_name
!      .coppensbasis_name = .saved.coppensbasis_name
!
!      ! Finalize basis sets
!      if (.atom.associated) .atom.nullify_bases
!      .BASE:resolve_basis_info
!      .crystal.make_fragment_data(.atom,assign_atom=TRUE)
!
!      ! Set basis info
!      .BASE:set_basis_info
!
!   end

!  ===========================================
!  No. of unique reflections, pruning, merging
!  ===========================================

   make_list_of_equivalents(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
      self :: IN
      list :: VEC{VEC_{INT}}*
      n_unique :: INT, OUT
      show :: BIN, IN, optional

   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.data.reflections.associated,"no reflection data")

      i,j,g, n_refl :: INT
      p,q,r :: VEC{INT}(3)
      same,disp :: BIN

      disp = FALSE
      if (present(show)) disp = show

      n_refl = .data.reflections.n_refl
      list.create(n_refl)
      list(1).element.append(1)

      n_unique = 1

      do i = 2,n_refl

         p(1) = .data.reflections(i).h
         p(2) = .data.reflections(i).k
         p(3) = .data.reflections(i).l
        
         same = FALSE
         refl: do j = 1,i-1
         do g = 1,.spacegroup.n_seitz
        
            q(1) = .data.reflections(j).h
            q(2) = .data.reflections(j).k
            q(3) = .data.reflections(j).l
        
            r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
        
            same = p.same_as(r)
        
            if (same) exit refl
        
         end
         end do refl
        
         if (same) then
            list(i).element.append(j)
            if (disp) then
            stdout.text(trim(i.to_str)//","//trim(j.to_str)//" S")
            end
         else
            n_unique = n_unique + 1
            list(i).element.append(i)
            if (disp) then
            stdout.text(trim(i.to_str)//","//trim(j.to_str)//" U")
            end
         end

      end

   end

   merge_equivalents ::: leaky
   ! This routine will merge this list of equivalents into a single reflections
   ! with a particular sigma value associated with it. WARNING: it assumes that
   ! there are a sufficient number of equivalents so that the sigma value can be
   ! calculated by the standard formula for the standard deviation.
      self :: INOUT

   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.data.reflections.associated,"no reflection data")

      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n,i :: INT

      n_refl = .data.reflections.n_refl

      .make_list_of_equivalents(list,n_unique)

      ! Define set of new reflections
      reflections.create(n_unique)
      n = 0
      do i = 1,n_refl

         if (any(list(i)[:]<i)) cycle

         n = n + 1

         reflections(n) = .data.reflections(i)
         reflections(n).set_F_exp(.data.reflections(list(i)[:]).F_exp.mean)
         reflections(n).set_F_sigma(.data.reflections(list(i)[:]).F_sigma.mean)

      end

      ! Set new reflections
      .data.reflections.destroy
      .data.reflections => reflections

      ! Clean up
      list.destroy

   end

   make_list_of_equivalents_ord(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
      self :: IN
      list :: VEC{VEC_{INT}}*
      n_unique :: INT, OUT
      show :: BIN, IN, optional

   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.data.reflections.associated,"no reflection data")

      i,j,g,n_refl :: INT
      p,q,r :: VEC{INT}(3)
      same,disp :: BIN

      disp = FALSE
      if (present(show)) disp = show

      n_refl = .data.reflections.n_refl

      list.create(n_refl)
      list(1).element.append(1)

      n_unique = 1

      do i = 2,n_refl

        p(1) = .data.reflections(i).h
        p(2) = .data.reflections(i).k
        p(3) = .data.reflections(i).l

        same = FALSE

        j = i-1
        main: do g = 1,.spacegroup.n_seitz
           q(1) = .data.reflections(j).h
           q(2) = .data.reflections(j).k
           q(3) = .data.reflections(j).l
           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
           same = p.same_as(r) OR p.same_as(-r)
           if (NOT same) cycle
           exit main
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end

      end

   end

   merge_ordered_equivalents ::: leaky
   ! This routine will merge apartially ordered list of equivalents
   ! into a single reflections with a particular sigma value
   ! associated with it.
   ! WARNING: it assumes that there are a sufficient number of
   ! equivalents so that the sigma value can be calculated by the
   ! standard formula for the standard deviation.
      self :: INOUT

   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.data.reflections.associated,"no reflection data")

      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n,i :: INT

      n_refl = .data.reflections.n_refl

      .make_list_of_equivalents_ord(list,n_unique)

      ! Define set of new reflections
      reflections.create(n_unique)
      n = 0
      do i = 1,n_refl

         if (list(i)[1]<i) cycle

         n = n + 1
         reflections(n) = .data.reflections(i)
         reflections(n).set_F_exp(.data.reflections(list(i)[:]).F_exp.mean)
         reflections(n).set_F_sigma(.data.reflections(list(i)[:]).F_exp.standard_deviation)

      end

      ! Reset reflections
      .data.reflections.destroy
      .data.reflections => reflections

      list.destroy

   end

   expand_unique_reflections ::: leaky
   ! This routine will expand a unique list of reflections into a
   ! complete redundant list of reflections.
   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.data.reflections.associated,"no reflection data")
      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n_max,n,i,j,g :: INT
      p,q,r :: VEC{INT}(3)
      same :: BIN

      ! Store the number of reflections
      n_refl = .data.reflections.n_refl

      ! Make the list of equivalents, to detect any repetitions
      .make_list_of_equivalents(list,n_unique,show=TRUE)
      DIE_IF(n_unique/=n_refl,"the list of reflections is not unique")
      list.destroy

      ! Create the maximum possible list of total reflections
      n_max = n_refl*.spacegroup.n_seitz
      reflections.create(n_refl*.spacegroup.n_seitz)

      ! Loop over remaining reflections
      n = 0
      do i = 1,n_refl
        p(1) = .data.reflections(i).h
        p(2) = .data.reflections(i).k
        p(3) = .data.reflections(i).l

        ! Apply symmetry to this relflection
        do g = 1,.spacegroup.n_seitz
           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),p),kind=INT_KIND)

           ! Is it the same as another in the list?
           same = FALSE
           do j = 1,n-1
              q(1) = reflections(j).h
              q(2) = reflections(j).k
              q(3) = reflections(j).l
              same = q.same_as(r)
              if (same) exit
           end
           if (NOT same) then
              n = n + 1
              DIE_IF(n>n_max,"more than expected number of reflections")
              reflections(n) = .data.reflections(i)
              reflections(n).set_hkl(r)
           end
        end
      end
      reflections.shrink(n)
      .data.reflections.destroy
      .data.reflections => reflections
   end

!  =====================================
!  Service methods used by other modules
!  =====================================

! Don't delete code below just yet ...

!   make_phased_matrix_for_symop(u,phase,mask) ::: private
!   ! Return the sum of the "phase" shifts times the seitz matrices for all
!   ! symops which are equivalent to the "u"-th unique symmetry operation,
!   ! .spacegroup.unique_SF_symop(u), as determined by the "mask" array, when
!   ! mask(u)==.spacegroup.unique_SF_symop(u).
!     u :: INT, IN
!     phase :: MAT3{CPX}, OUT
!     mask :: VEC{INT}, IN
!
!   ENSURE(.spacegroup.analyzed,"no spacegroup")
!   ENSURE(u<=.spacegroup.n_unique_SF_symops,"symop index out of range")
!   ENSURE(phase.dim1==.data.reflections.n_refl,"wrong size, dim=1, phase array")
!   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
!   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
!
!     pi2,tx,ty,tz,dot :: REAL
!     s,n,n_refl,h,k,l :: INT
!     seitz :: MAT{REAL}(4,4)
!     refl :: VEC{REFLECTION}*
!
!     refl => .data.reflections
!     n_refl = refl.dim
!     pi2 = TWO*PI
!
!     phase = ZERO
!     do s = 1,.spacegroup.n_seitz
!
!       ! Sum only those which match unique symop u
!       if (mask(s)/=.spacegroup.unique_SF_symop(u)) cycle
!
!       ! Get the symop translation vector
!       seitz = .spacegroup.seitz(:,:,s)
!       tx = pi2*seitz(1,4)
!       ty = pi2*seitz(2,4)
!       tz = pi2*seitz(3,4)
!
!       ! Sum the phase here
!       ! This seems a kludge because we don't know the magnetic symmetry
!       if (seitz(3,3)>0) then                  ! M points along +z always
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       else                                    ! M points in -z direction
!         seitz(3,:3) = -seitz(3,:3)            ! Invert
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       end
!
!     end
!
!   end
!
!   sum_PND_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.associated,"no data")
!   ENSURE(.data.reflections.associated,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.translated_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              unique_ft_ints(uf+n,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.inverted_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!        end
!
!     end
!     phase.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
!   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT3{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.associated,"no data")
!   ENSURE(.data.reflections.associated,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop) ! .inverted_symop here ??????????????
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
!       end
!     end
!     phase.destroy
!
!     ! The factor of 2 to convert to Bohr magnetons cancels the factor
!     ! of 1/2 for the Bohr magneton.
!     do n = 1,n_refl
!       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_ft_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3,3].
!     ft_ints :: MAT5{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.associated,"no data")
!   ENSURE(.data.reflections.associated,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT{CPX}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:)
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     do n = 1,n_refl
!        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
!   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!     B :: VEC{REAL}(3)
!
!   ENSURE(.data.associated,"no data")
!   ENSURE(.data.reflections.associated,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT3{CPX}*
!     u,uf,n,n_refl :: INT
!     ci :: CPX
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     ci = (ZERO,ONE)
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
!   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!      ft_ints :: MAT4{CPX}
!      unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.associated,"no data")
!   ENSURE(.data.reflections.associated,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!      phase :: VEC{CPX}*
!      q :: MAT{REAL}*
!      ints :: MAT3{CPX}*
!      u,uf,n,n_refl :: INT
!
!      n_refl = .data.reflections.n_refl
!      phase.create(n_refl)
!      q.create(n_refl,3)
!      ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!      .make_k_pts(q)
!
!      ft_ints = ZERO
!      do u = 1,.spacegroup.n_unique_SF_symops
!
!         uf = n_refl*(u-1)
!
!         ! Add up translated symop contribution
!         .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!         do n = 1,n_refl
!            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!         ! Add up inverted symop contribution, if any
!         if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!         .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!         do n = 1,n_refl
!            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!      end
!      ints.destroy
!
!      ! The factor of 2 to convert to Bohr magnetons cancels the factor
!      ! of 1/2 for the Bohr magneton
!      ! Extra minus sign introduced, but not sure why ...
!      ! Reversed minus sign introduced ...
!      do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!      end
!      q.destroy
!      phase.destroy
!
!   end
!
!   sum_ft_j_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform j integrals "ft_ints", required for the PND
!   ! magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.associated,"no data")
!   ENSURE(.data.reflections.associated,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     u,uf, n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
!        end
!
!     end
!     phase.destroy
!
!   end

!  ===================
!  Tests for existence
!  ===================

   data_exists result (res) ::: pure
   ! Return TRUE if the diffraction data information exists
      self :: IN
      res :: BIN

      res = associated(.data)

   end

   asymmetric_unit_exists result (res) ::: pure
   ! Return TRUE if the asymmetric unit geometry information exists
      self :: IN
      res :: BIN

      res = associated(.asymmetric_unit_geometry)

   end

   unit_cell_geometry_exists result (res) ::: pure
   ! Return TRUE if the unit_cell_geometry information exists
      self :: IN
      res :: BIN

      res = associated(.unit_cell_geometry)

   end

   fragment_data_exists result (res) ::: pure
   ! Return TRUE if a fragment information exists
      self :: IN
      res :: BIN

      res = associated(.fragment_geometry)

   end

!  =============================
!  Wrappered reflection routines
!  =============================

   n_refl result (res) ::: PURE
   ! The number of reflections
      self :: IN
      res :: INT

   ENSURE(.data_exists, "no diffraction data")

      res = .data.n_refl

   end


   F2_exp result (res) ::: PURE
   ! The experimental structure factors squared, (F_exp)^2
      self :: IN
      res :: VEC{REAL}(.data.reflections.dim)

   ENSURE(.data_exists, "no diffraction data")

      res = .data.F2_exp

   end

   F2_exp_scaled_corrected result (res)
   ! The experimental structure factors squares, F_exp, on an absolute
   ! scale, and corrected for dispersion (if any).
   ! Method follows XD (2015) manual p. 45.
   ! See also Ibers & Hamilton (1964) ACta Cryst. 17 p781.
      self :: IN
      res :: VEC{REAL}(.data.reflections.dim)

   ENSURE(.data_exists, "no diffraction data")

      res = .F_exp_scaled_corrected
      res = res*res

   end


   F_exp result (res) ::: PURE
   ! The experimental structure factors
      self :: IN
      res :: VEC{REAL}(.data.reflections.dim)

   ENSURE(.data_exists, "no diffraction data")

      res = .data.F_exp

   end

   F_exp_scaled_corrected result (res) ! ::: PURE
   ! The experimental structure factors F_exp on an absolute scale,
   ! and corrected for dispersion (if any).
   ! Method follows XD (2015) manual p. 45.
   ! See also Ibers & Hamilton (1964) ACta Cryst. 17 p781.
      self :: IN
      res :: VEC{REAL}(.data.reflections.dim)

   ENSURE(.data_exists, "no diffraction data")

      Fc :: VEC{CPX}*

      if (.add_dispersion_to_F_calc) then

         ! Get dispersion correction
         Fc.create(.data.reflections.dim)
         .add_dispersion_correction(Fc)
        
         ! Get complex F_exp on absolute scale & remove dispersion
         Fc = .data.F_exp_on_absolute_scale - abs(Fc)

         ! Get corrected F_exp
         res = abs(Fc)

         ! Clean
         Fc.destroy

      else

         ! Get F_exp on absolute scale
         res = .data.F_exp_on_absolute_scale

      end

   end


   F2_sigma result (res) ::: PURE
   ! The structure factor errors squared
      self :: IN
      res :: VEC{REAL}(.data.reflections.dim)

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F2_sigma

   end

   F_sigma result (res) ::: PURE
   ! The structure factor errors
      self :: IN
      res :: VEC{REAL}(.data.reflections.dim)

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F_sigma

   end


   F2_calc_abs result (res) ::: PURE
   ! The calculated structure factors magnitude, squared
      self :: IN
      res :: VEC{CPX}(.data.reflections.dim)

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F2_calc_abs

   end

   F_calc result (res) ::: PURE
   ! The calculated structure factors
      self :: IN
      res :: VEC{CPX}(.data.reflections.dim)

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F_calc

   end


   F_chi2 result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.data_exists,"diffraction data not created")

      res = .data.F_chi2

   end

   F_goodness_of_fit result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F_goodness_of_fit

   end

   F_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F_r_factor

   end

   F_weighted_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F_weighted_r_factor

   end

   F2_r_factor result (res) ::: PURE
   ! Returns data
      self :: IN
      res :: REAL

   ENSURE(.data_exists,"no diffraction data")

      res = .data.F2_r_factor

   end

   n_param result (res)
   ! Returns number of independent parameters in model
      self :: IN
      res :: INT

   ENSURE(.data_exists,"diffraction data not created")

      res = .data.n_param

   end

   partition_model result (res) ::: pure
   ! Model for partitioning fragments of the molecule
      self :: IN
      res :: STR

      if (.data_exists) then; res = .data.partition_model
      else;                   res = " "
      end

   end

   thermal_smearing_model result (res) ::: pure
   ! Thermal smearing model for ft integrals.
      self :: IN
      res :: STR

      if (.data_exists) then; res = .data.thermal_smearing_model
      else;                   res = " "
      end

   end

   add_dispersion_to_F_calc result (res) ::: PURE
   ! True if dispersion is to be corrected
      self :: IN
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.add_dispersion_to_F_calc

   end

   remove_dispersion_from_F_exp result (res) ::: PURE
   ! True if dispersion is to be removed from F_exp
      self :: IN
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.remove_dispersion_from_F_exp

   end

   wavelength result (res) ::: PURE
   ! Experimental wavelength
      self :: IN
      res :: REAL

   ENSURE(.data_exists,"no diffraction data")

      res = .data.wavelength

   end

   optimize_extinction result (res) ::: PURE
   ! True if extinction is to be optimised
      self :: IN
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.optimize_extinction

   end

   optimize_scale result (res) ::: PURE
   ! True if an overall scale factor is to be optimised, for use in
   ! calculating F_pred
      self :: IN
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.optimize_scale

   end

   xyz_asymmetric_unit_geometry result (res) ::: PURE
   ! Return the asymmetric unit geometry in cartesian coordinates.
      self :: IN
      res :: MAT{REAL}(3,.n_asymmetric_unit_atoms)

   ENSURE(.asymmetric_unit_geometry.associated,"no asymmetric unit")

      res = matmul(.unit_cell.direct_matrix,.asymmetric_unit_geometry)

   end

!   simulate_new_F_exp
!   ! Simulate a new experiment by adding normally distributed experimental
!   ! errors the the F_exp.
!       self :: INOUT
!
!   ENSURE(.data_exists,"no diffraction data")
!
!      .data.simulate_new_F_exp
!
!   end

!  =================
!  Structure factors
!  =================

   make_F_predicted(sf_n)
   ! Make and set the predicted structure factors, F_pred, from
   ! "sf_n", the unique *fragment* atom structure factors for the
   ! symmetry-generated related k points
      self :: INOUT
      sf_n :: MAT{CPX}, IN

   ENSURE(.data.associated,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      ! Make F_predicted, F_calc & derivatives
      .:set_F_calc_from(sf_n)

      ! Optimise scale, extinction & set chi2(F)
      .data.make_F_predicted
        

   end

   make_F_predicted
   ! Make and set the predicted structure factors, F_pred, reading the
   ! temperature independent aspherical atomic form factors from disk.
      self :: INOUT

   ENSURE(.data.associated,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      ! Make F_predicted, F_calc & derivatives
      .:set_F_calc_from

      ! Optimise scale, extinction & set chi2(F)
      .data.make_F_predicted



   end

   set_F_calc_from(sf_n)
   ! Set the predicted structure factors, F_pred, from "sf_n", the
   ! unique *fragment* atom structure factors for the
   ! symmetry-generated related k points
      self :: INOUT
      sf_n :: MAT{CPX}, IN

   ENSURE(.data.associated,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}*

      Fc.create(.n_refl)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc(Fc,sf_n)

      ! Set the calculated SF's
      ENSURE(all(abs(Fc)>TOL(10)),"there are zero F_calc's; prune them to continue")
      .data.reflections.set_F_calc(Fc)

      Fc.destroy

   end

   set_F_calc_from
   ! Set the predicted structure factors, F_pred, reading the
   ! temperature independent structure factors from disk.
      self :: INOUT

   ENSURE(.data.associated,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}*

      Fc.create(.n_refl)



      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc(Fc)

      ! Set the calculated SF's
      ENSURE(all(abs(Fc)>TOL(10)),"there are zero F_calc's; prune them to continue")
      .data.reflections.set_F_calc(Fc)


      Fc.destroy

   end

   make_F_calc(Fc,sf_n)
   ! Make the calculated structure factors "Fc", where "sf_n" are
   ! the unique *fragment* atom structure factors for the symmetry
   ! generated related k points
      self :: INOUT
      Fc :: VEC{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(Fc.dim==.n_refl, "wrong size, Fc")
   ENSURE(.data_exists,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_e :: VEC{CPX}*
      n_k :: INT

      n_k = .n_unique_SF_k_pts

      ! Symmetry-generated T-indepedent structure factors
      sf_e.create(n_k)

      ! Make them
      .make_unique_sf(sf_e,sf_n)

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      .make_F_calc_from(sf_e,Fc)


      sf_e.destroy

   end

   make_F_calc(Fc)
   ! Make the calculated structure factors "Fc", where "sf_n" are
   ! the unique *fragment* atom structure factors for the symmetry
   ! generated related k points
      self :: INOUT
      Fc :: VEC{CPX}, OUT

   ENSURE(Fc.dim==.n_refl, "wrong size, Fc")
   ENSURE(.data_exists,   "no data")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_e :: VEC{CPX}*
      n_k :: INT

      n_k = .n_unique_SF_k_pts

      ! Symmetry-generated T-indepedent structure factors
      sf_e.create(n_k)

      ! Make them
      .make_unique_sf(sf_e)

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      .make_F_calc_from(sf_e,Fc)

      sf_e.destroy

   end


   make_F_predicted_from(sf_e)
   ! Make and set the predicted structure factors, F_pred, from
   ! "sf_e", the aspherical temperature-independent form factors for
   ! every symmetry-generated structure factor.
      self :: INOUT
      sf_e :: VEC{CPX}, IN

   ENSURE(sf_e.dim1==.n_unique_SF_k_pts, "wrong size, sf_e")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}*

      Fc.create(.n_refl)

      ! Make the calculated SF's
      .make_F_calc_from(sf_e,Fc)

      ! Set the calculated SF's
      ENSURE(all(abs(Fc)>TOL(10)),"there are zero F_calc's; prune them to continue")
      .data.reflections.set_F_calc(Fc)

      Fc.destroy

      ! Optimise scale, extinction & set chi2(F)
      .data.make_F_predicted

   end

   set_F_calc_from(sf_e)
   ! Set the predicted structure factors, F_pred, from "sf_e", the
   ! aspherical temperature-independent form factors for every
   ! symmetry-generated structure factor.
      self :: INOUT
      sf_e :: VEC{CPX}, IN

   ENSURE(sf_e.dim1==.n_unique_SF_k_pts, "wrong size, sf_e")
   ENSURE(.fragment_info_made,"no fragment info")

      Fc :: VEC{CPX}*

      Fc.create(.n_refl)

      .make_F_calc_from(sf_e,Fc)

      Fc.destroy

   end

   make_F_calc_from(sf_e,Fc)
   ! Make and set the predicted structure factors, F_pred, from
   ! "sf_e", the aspherical temperature-independent form factors for
   ! every symmetry-generated structure factor.
      self :: INOUT
      sf_e :: VEC{CPX}, IN
      Fc :: VEC{CPX}, OUT

   ENSURE(sf_e.dim1==.n_unique_SF_k_pts, "wrong size, sf_e")
   ENSURE(.fragment_info_made,"no fragment info")

      Fa :: VEC{CPX}*

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      .spacegroup.sum_unique_sf(Fc,sf_e,.data.reflections)

      ! Include dispersion?
      if (.data.correct_dispersion) then

         ! Get dispersion correction
         Fa.create(.n_refl)
         .get_dispersion_correction(Fa)
         .data.reflections.set_F_disp(Fa)

         ! Add dispersion into Fc
         Fc = Fc + Fa

         Fa.destroy

      end

      ! Set the calculated SF's
      ENSURE(all(abs(Fc)>TOL(10)),"there are zero F_calc's; prune them to continue")
      .data.reflections.set_F_calc(Fc)

   end


   make_F_calc_derivs(dFc,sf_n)
   ! Make "dFc", the derivatives of the calculated structure factors
   ! with respect to positional and ADP parameters, using "sf_n", the
   ! temperature-independent structure factors. Also set the
   ! calculated and prediected structure factors.
      self :: INOUT
      dFc :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(dFc.dim1==.n_refl, "dFc: wrong dim1")
   ENSURE(dFc.dim2==.asymmetric_unit_atom.no_of_pADPs, "dFc: wrong dim2")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_d :: MAT{CPX}*
      sf_e :: VEC{CPX}*
      n_k,n_p :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the symmetry-generated structure factors and their
      ! derivatives including ADPs but no dispersion.
      .make_unique_sf_derivs(sf_e,sf_d,sf_n)

      ! Make and set F_pred with scale & extinction.
      .data.reflections.reset_F_corr_to_F_exp ! We fit to F_corr
      .make_F_predicted_from(sf_e)            ! Always includes dispersion
  ! stdout.show("1st scale factor = ",.data.scale_factor)
  ! .data.reflections(1:20).put_F_all_data
      sf_e.destroy

      ! Remove dispersion from F_calc, and F_exp to make F_corr?
      if (.remove_dispersion_from_F_exp) then
         .data.reflections.remove_anom_from_F_exp(.data.scale_factor)
         .data.reflections.remove_anom_from_F_calc
  ! stdout.text("Removed dispersion from F_exp to get F_corr")
  ! .data.reflections(1:20).put_F_all_data
         .data.make_F_predicted(update_n_param=FALSE) ! new scale
  ! stdout.show("2nd scale factor = ",.data.scale_factor)
      end

      ! Sum the symmetry-generated SF's to get
      ! the derivative structure factors dFc
      .spacegroup.sum_unique_sf_derivs(dFc,sf_d,.data.reflections)
      sf_d.destroy

      ! Add derivative of anomalous contribution to |SF|, dFc
      ! Only if F_calc has anomalous dispersion added into it.
      if (.add_dispersion_to_F_calc) then
         .add_D_dispersion_correction(dFc)
      end

   end

   make_F_calc_derivs(dFc)
   ! Make "dFc", the derivatives of the calculated structure factors
   ! with respect to positional and ADP parameters, reading
   ! temperature-independent structure factors from disk. Also set the
   ! calculated and prediected structure factors.
      self :: INOUT
      dFc :: MAT{CPX}, OUT

   ENSURE(dFc.dim1==.n_refl, "dFc: wrong dim1")
   ENSURE(dFc.dim2==.asymmetric_unit_atom.no_of_pADPs, "dFc: wrong dim2")
   ENSURE(.fragment_info_made,"no fragment info")

      sf_d :: MAT{CPX}*
      sf_e :: VEC{CPX}*
      n_k,n_p :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the symmetry-generated structure factors and their
      ! derivatives including ADPs but no dispersion.
      .make_unique_sf_derivs(sf_e,sf_d) ! processor 1 stops here

      ! Make and set F_pred with scale & extinction.
      .data.reflections.reset_F_corr_to_F_exp ! We fit to F_corr
      .make_F_predicted_from(sf_e)            ! Always includes dispersion
      sf_e.destroy

      ! Remove dispersion from F_calc, and F_exp to make F_corr?
      if (.remove_dispersion_from_F_exp) then
         .data.reflections.remove_anom_from_F_exp(.data.scale_factor)
         .data.reflections.remove_anom_from_F_calc
         .data.make_F_predicted(update_n_param=FALSE) ! new scale
      end

      ! Sum the symmetry-generated SF's to get
      ! the derivative structure factors dFc
      .spacegroup.sum_unique_sf_derivs(dFc,sf_d,.data.reflections)
      sf_d.destroy

      ! Add derivative of anomalous contribution to |SF|, dFc
      ! Only if F_calc has anomalous dispersion added into it.
      if (.add_dispersion_to_F_calc) then
         .add_D_dispersion_correction(dFc)
      end

   end

!  ============================
!  Structure refinement methods
!  ============================

   LS_structure_fit(output,results) ::: leaky
   ! Least-squares fit the the positions and ADPs of the unique
   ! fragment atoms so that the structure factors obtained from the
   ! static *aspherical* *atomic* form factor, read from disk, match
   ! the experimental structure factors. The structure factors are for
   ! all symmetry genetrated structure factors, and only for the
   ! *unique* .fragment atom's which correspond to but are not
   ! necessarily the same as the .asymmetric_unit_atom's.
   !
   ! NOTE: this routine does only one cycle of fitting with the
   !       current density matrix i.e. this is a "rigid atom fit".
   !
   ! NOTE: It's tricky exactly which atom's pADPs are used to do the
   !       refinement:
   !
   ! * Structure factors are only for *unique* fragment atoms since
   !   the QM wavefunction refers to the fragment_atoms.
   !
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to these unique
   !   fragment atom positions and ADPs) but these parameters and
   !   shifts are later transformed back into asymmetric unit.
      self :: INOUT
      output,results :: BIN, IN

   ENSURE(.data_exists,                        "no data")
   ENSURE(.fragment_info_made,                 "no fragment info")

      dF :: MAT{REAL}*

      ! Create refinement arrays & initialize (leaky)
      ! - asymmetric atom and fragment atom pADPs are set.
      .initialize_fit_data

      ! Place asym atom position/ADPs in vector .data.X_fit
      ! - asymmetric_unit_atom keeps the pADPs
      .asymmetric_unit_atom.put_pADP_vector_to(.data.X_fit)

      ! If refining, store a copy of the pADPs in .data.X_ref
      if (.data.refine_structure) .data.X_ref = .data.X_fit

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header.
      if (output) then
         .put_fit_header_info
      end

      ! Begin rigid-atom fit loop
      do

         ! Set asym atom positions/ADPs from param vector
       ! .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)

         ! Get unique *fragment* atom shifts in .data.dX ...
         .get_parameter_shifts ! .data

         ! Change/store unique frag atom -> asym atom shifts
         ! Change/store the covariance matrix too.
         .set_asym_from_ufrag_shifts ! .data.dX now for asym atoms
         .set_asym_from_ufrag_cov_mx

         ! Stop symmetry breaking
         ! NOTE: we should apply this to the gradient *not*
         ! the shift to make sure the shift maintains symmetry
         .stabilize_asym_atom_shifts

         ! Store old asym-atom parameter vector.
         ! Add shift dA to get new .data.X_fit
         .update_fit_parameters
         .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)

         ! Set the fit errors e.g. max(dX/esd)
         ! Copy them to the asymmetric unit atoms.
         .update_fit_esds
         .asymmetric_unit_atom.set_pADP_errors_to(.data.esd,.data.refine_H_U_iso)

         ! Set ALL fragment_atom positions/ADPs from asym atoms HERE
         ! >>>fragment_atom must be the same as molecule.atom
         dF.create(3,.n_fragment_atoms)
         .set_frag_from_asym_pADPs(dF)

         ! Update structure factors, the unique (rigid) frag atom SF's.
         ! Use the frag atom position shifts "dF".
         .shift_update_sf_n(dF)
         dF.destroy

         ! Put the iteration results
         if (output) then
            .data.put_fit_table_body
         end

         ! Finished?
         if (.fit_finished) exit

      end

      ! Table footer
      if (output) then
         .data.fit_table.put_footer
      end

      ! Final results
      if (results) then
         .put_fit_results
      end

      ! Set the fragment covariances from cov matrix
      .set_fragment_esds

      ! Print out bond length, angle, torsion tables with errors
      if (output) then
         .put_bond_info_with_errors
      end

      ! Finally: remake .asymmetric_unit_atom/unit_cell geometry from
      ! .fragment_atom, which *must* be assigned since it must point
      ! to molecule.atom
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_source = "tonto-ls-structure-fit"
      .make_fragment_data(.fragment_atom,assign_atom=TRUE,warnings=FALSE)

   end

   LS_structure_fit(sf_n,output,results) ::: leaky
   ! Least-squares fit the the positions and ADPs of the unique
   ! fragment atoms so that the structure factors obtained from the
   ! static *aspherical* *atomic* form factor, in "sf_n", match the
   ! experimental structure factors. The structure factors are for all
   ! symmetry genetrated structure factors, and only for the *unique*
   ! .fragment atom's which correspond to but are not necessarily the
   ! same as the .asymmetric_unit_atom's.
   !
   ! NOTE: this routine does only one cycle of fitting with the
   !       current density matrix i.e. this is a "rigid atom fit".
   !
   ! NOTE: It's tricky exactly which atom's pADPs are used to do the
   !       refinement:
   !
   ! * Structure factors are calculated only for *unique* fragment
   !   atoms since the QM wavefunction refers to the fragment_atoms.
   !   cf. the description of "sf_n" above.
   !
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to these unique
   !   fragment atom positions and ADPs) but these parameters and
   !   shifts are later transformed back into asymmetric unit.
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT
      output,results :: BIN, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(.data_exists,                        "no data")
   ENSURE(.fragment_info_made,                 "no fragment info")

      dF :: MAT{REAL}*

      ! Create refinement arrays & initialize (leaky)
      ! - asymmetric atom and fragment atom pADPs are set.
      .initialize_fit_data

      ! Place asym atom position/ADPs in vector .data.X_fit
      ! - asymmetric_unit_atom keeps the pADPs
      ! - unique frag atoms are *refined* cf. sf_n
      .asymmetric_unit_atom.put_pADP_vector_to(.data.X_fit)

      ! If refining, store a copy of the pADPs in .data.X_ref
      if (.data.refine_structure) .data.X_ref = .data.X_fit

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header.
      if (output) then
         .put_fit_header_info
      end

      ! Begin rigid-atom fit loop
      do

         ! Set asym atom positions/ADPs from param vector
       ! .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)

         ! Get unique *fragment* atom shifts in .data.dX ...
         .get_parameter_shifts(sf_n) ! .data

         ! Change/store unique frag atom -> asym atom shifts
         ! Change/store the covariance matrix too.
         .set_asym_from_ufrag_shifts ! .data.dX now for asym atoms
         .set_asym_from_ufrag_cov_mx

         ! Stop symmetry breaking
         ! NOTE: we should apply this to the gradient *not*
         ! the shift to make sure the shift maintains symmetry
         .stabilize_asym_atom_shifts

         ! Store old asym-atom parameter vector.
         ! Add shift dA to get new .data.X_fit
         .update_fit_parameters
         .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)

         ! Set the fit errors e.g. max(dX/esd)
         ! Copy them to the asymmetric unit atoms.
         .update_fit_esds
         .asymmetric_unit_atom.set_pADP_errors_to(.data.esd,.data.refine_H_U_iso)

         ! Set ALL fragment_atom positions/ADPs from asym atoms HERE
         ! >>>fragment_atom must be the same as molecule.atom
         dF.create(3,.n_fragment_atoms)
         .set_frag_from_asym_pADPs(dF)

         ! Update "sf_n", the unique (rigid) frag atom SF's.
         ! Use the frag atom position shifts "dF".
         .shift_update_sf_n(sf_n,dF)
         dF.destroy

         ! Put the iteration results
         if (output) then
            .data.put_fit_table_body
         end

         ! Finished?
         if (.fit_finished) exit

      end

      ! Table footer
      if (output) then
         .data.fit_table.put_footer
      end

      ! Final results
      if (results) then
         .put_fit_results
      end

      ! Set the fragment covariances from cov matrix
      .set_fragment_esds

      ! Print out bond length, angle, torsion tables with errors
      if (output) then
         .put_bond_info_with_errors
      end

      ! Finally: remake .asymmetric_unit_atom/unit_cell geometry from
      ! .fragment_atom, which *must* be assigned since it must point
      ! to molecule.atom
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_source = "tonto-ls-structure-fit"
      .make_fragment_data(.fragment_atom,assign_atom=TRUE,warnings=FALSE)

   end

!  Refinement initialization

   initialize_fit_data ::: leaky
   ! Initialise a rigid-atom fit

   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.fragment_info_made,"no fragment info")

      X :: VEC{REAL}*
      labels, refine_U3,refine_U4 :: VEC{STR}*
      atom_a,atom_f :: ATOM*
      f,a, n_p,n_f :: INT
      fac :: REAL

      ! Create space for asymmetric unit atom pADPs (leaky)
      refine_U3 => .data.refine_3rd_order_for_atom
      refine_U4 => .data.refine_4th_order_for_atom
      .asymmetric_unit_atom.reset_pADPs_and_errors(refine_U3,refine_U4)

      if (.debugging("initialize_fit_data")) then
         n_p = .asymmetric_unit_atom.no_of_pADPs
         fac = STR:conversion_factor("angstrom")
         X.create(n_p)
         stdout.text(">>initialize_fit_data:")
         stdout.text("asymmetric_unit_atom.pADP_vector (before):")
         .asymmetric_unit_atom.put_pADP_vector_to(X,fac)
         stdout.put(X,by_column=TRUE)
         X.destroy
         stdout.text("fragment_atom (before):")
         .fragment_atom.put_coordinates
      end

      ! Create space for the fragment_atom pADPs (leaky)
      do f = 1,.n_fragment_atoms
         a = .asym_atom_for_frag_atom(f)
         atom_a => .asymmetric_unit_atom(a)
         atom_f =>        .fragment_atom(f)
         n_p = atom_a.no_of_pADPs
         atom_f.reset_pADPs_and_errors(n_p)
      end

      ! Set fragment_atom pADPs from asymmetric unit atom pADPs
      .set_frag_from_asym_pADPs

      ! Get labels (leaky)
      labels => .asymmetric_unit_atom.tag_pADP_labels

      ! Set the no. of parameters
      n_p = .asymmetric_unit_atom.no_of_pADPs
      n_f = .fragment_atom.no_of_pADPs

      ! Create refinement arrays & initialize (leaky)
      .data.initialize_fit_data(n_p,n_f,labels)

      ! Clean
      labels.destroy

   end

   initialize_refinement_data ::: leaky
   ! Initialise a full refinement

   ENSURE(.data_exists,"no diffraction data")

      labels, refine_U3,refine_U4 :: VEC{STR}*
      n_p :: INT

      ! Get labels
      labels => .asymmetric_unit_atom.tag_pADP_labels

      ! Create space for parameters (leaky)
      refine_U3 => .data.refine_3rd_order_for_atom
      refine_U4 => .data.refine_4th_order_for_atom
      .asymmetric_unit_atom.reset_pADPs_and_errors(refine_U3,refine_U4)

      ! Set the no. of parameters
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Create refinement arrays & initialize (leaky)
      .data.initialize_refinement_data(n_p,labels)

      ! Clean
      labels.destroy

   end

   get_parameter_shifts(sf_n)
   ! Get the param shifts -- either F or F2
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT

   ENSURE(.data.associated,"no data")

      if(.data.refine_F) then;  .get_parameter_shifts_F(sf_n)
    ! else;                     .get_parameter_shifts_I(sf_n)
      end

   end

   get_parameter_shifts
   ! Get the param shifts -- either F or F2
      self :: INOUT

   ENSURE(.data.associated,"no data")

      if(.data.refine_F) then;  .get_parameter_shifts_F
    ! else;                     .get_parameter_shifts_I
      end

   end

!  Refinement: shifts and SF update

   get_parameter_shifts_F(sf_n) ::: leaky, private
   ! Get the *asymmetric* atom shifts in ".data.dX" by solving the
   ! normal equations, where "sf_n", the unique *fragment* atom
   ! structure factors for the symmetry generated k points
      self :: INOUT
      sf_n :: MAT{CPX}, INOUT

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(.data.associated,    "no data")
   ENSURE(.fragment_info_made, "no fragment info")

      dFc :: MAT{CPX}*
      dFa  :: MAT{REAL}*
      n_k,n_p :: INT

      ! Constants
      n_k = sf_n.dim1
      n_p = .asymmetric_unit_atom.no_of_pADPs

      dFa.create(.n_refl,n_p)
      dFc.create(.n_refl,n_p)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc_derivs(dFc,sf_n)

      ! Get the derivative absolute SF's, F_abs = |F_calc|
      .d_F_abs_dX(dFa,dFc)
      dFc.destroy

      ! Get the unique atom shifts, dX (leaky)
      .solve_normal_equations(dFa)

      dFa.destroy

   end

   get_parameter_shifts_F ::: leaky, private
   ! Get the *asymmetric* atom shifts in ".data.dX" by solving the
   ! normal equations. Structure factors are read from disk.
      self :: INOUT

   ENSURE(.data.associated,                        "no data")
   ENSURE(.fragment_info_made,                  "no fragment info")

      dFc :: MAT{CPX}*
      dFa  :: MAT{REAL}*
      n_k,n_p :: INT

      ! Constants
      n_k = .n_unique_SF_k_pts
      n_p = .asymmetric_unit_atom.no_of_pADPs

      dFa.create(.n_refl,n_p)
      dFc.create(.n_refl,n_p)

      ! Make F_predicted, F_calc & derivatives
      .:make_F_calc_derivs(dFc)

      ! Get the derivative absolute SF's, F_abs = |F_calc|
      .d_F_abs_dX(dFa,dFc)
      dFc.destroy

      ! Get the unique atom shifts, dX (leaky)
      .solve_normal_equations(dFa)

      dFa.destroy

   end

   get_dispersion_correction(Fa) ::: PURE
   ! Get the anomalous dispersion correction in "Fa" for the set of
   ! symmetry-unique atoms - do not add the contribution into anything.
   ! 1/2/18 
      self :: IN
      Fa :: VEC{CPX}, OUT

   ENSURE(.data.associated,"no diffraction data!")

      Fu :: VEC{CPX}@
      k_pts :: MAT{REAL}@
      n_k, u,f :: INT
      rf :: REAL

      n_k = .n_symop_generated_SF_k_pts

      k_pts.create(n_k,3)
      Fu.create(n_k)

      ! The full list of symmetry-generated k points
      .data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      Fu = ZERO
      do u = 1,.n_unique_frag_atoms
         f  = .unique_frag_atom(u)
         rf = .frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         .fragment_atom(f).add_dispersion(Fu,k_pts,rf)
      end

      ! Add together symmetry contributions from Fu into Fa
      .spacegroup.get_full_sd(Fa,Fu,.data.reflections)

   end

   add_dispersion_correction(Fc) ! ::: PURE
   ! Add the anomalous dispersion correction in "Fc" for the set of
   ! symmetry-unique atoms.
   ! 1/2/18 
   ! Anomalous dispersion checked for the YQ28 (harmonic) IAM refined
   ! job but modified to remove refinement and calculate a molecular
   ! density with STO-3G basis, and by comparing to structure factors
   ! from the version below which was previously checked against XD:
   !    Version: 18.01.31 v. daf061c
   !    Platform: Linux-4.13.0-32-generic
   !    Build-date: 2018-01-31 14:35
      self :: IN
      Fc :: VEC{CPX}, INOUT

   ENSURE(.data.associated,"no diffraction data!")

      Fu :: VEC{CPX}@
      k_pts :: MAT{REAL}@
      n_k, u,f :: INT
      rf :: REAL

      n_k = .n_symop_generated_SF_k_pts

      k_pts.create(n_k,3)
      Fu.create(n_k)

      ! The full list of symmetry-generated k points
      .data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      Fu = ZERO
      do u = 1,.n_unique_frag_atoms
         f  = .unique_frag_atom(u)
         rf = .frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         .fragment_atom(f).add_dispersion(Fu,k_pts,rf)
      end

      ! Add together symmetry contributions
      .spacegroup.add_full_sd(Fc,Fu,.data.reflections)

   end


   add_D_dispersion_correction(dFc)
   ! Add the anomalous dispersion correction in "Fc" for the set of
   ! symmetry-unique atoms.
      self :: IN
      dFc :: MAT{CPX}, INOUT

   ENSURE(.data.associated,"no diffraction data!")

      dFa,dFb :: MAT{CPX}*
      k_pts :: MAT{REAL}*
      n_k,n_p, u,f,base :: INT
      rf :: REAL

      ! Size of symmetry generated k points
      n_k = .n_symop_generated_SF_k_pts
      k_pts.create(n_k,3)

      ! Size of anamalous Jacobian
      n_p = .asymmetric_unit_atom.no_of_pADPs
      dFa.create(n_k,n_p)
      dFb.create(.data.reflections.dim,n_p)

      ! The full list of symmetry-generated k points
      .data.reflections.make_symop_generated_SF_k_pts(k_pts,.spacegroup,.unit_cell)

      ! Note: each atom contribution scales by a site-symmetry factor
      dFa = ZERO

      do u = 1,.n_unique_frag_atoms
         f  = .unique_frag_atom(u)
         rf = .frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)
         .fragment_atom(f).add_derivative_dispn(dFa,base,k_pts,rf)
      end

      ! Add together symmetry contributions
      dFb = ZERO
      .spacegroup.add_full_sf_derivs_d(dFb,dFa,.data.reflections)

    ! stdout.text("dFc S contribution before:")
    ! stdout.put(dFc(:,18+1:18+9))

    ! stdout.text("Anomalous dFb S contribution:")
    ! stdout.put(dFb)

      dFc = dFc + dFb

      ! Clean
      dFb.destroy
      dFa.destroy
      k_pts.destroy

   end

   shift_update_sf_n(sf_n,dF) ::: private
   ! Update the unique *fragment* atom structure factors "sf_n" with
   ! the frag atom positional shifts (after stabilization) in "dF"
      self :: INOUT
      sf_n :: MAT{CPX}, target, INOUT
      dF   :: MAT{REAL}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(dF.dim1==3,                          "dF: wrong dim1")
   ENSURE(dF.dim2==.n_fragment_atoms,          "dF: wrong dim2")

      d1,d2,d3, k1,k2,k3, kr  :: REAL
      n_k, u,f, k :: INT
      sf_u :: VEC{CPX}*
      k_pt :: MAT{REAL}*

      ! Get the # of k points
      n_k = .n_unique_SF_k_pts

      ! Make k points
      k_pt.create(n_k,3)
      .data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Loop over unique *frag* atoms
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)

         ! Get the shift
         d1 = dF(1,f)
         d2 = dF(2,f)
         d3 = dF(3,f)

         ! Structure factors, unique atom "u"
         sf_u => sf_n(:,u)

         ! Update sf_u
         do k = 1,n_k

            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)

            kr = k1*d1 + k2*d2 + k3*d3

            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr),kind=CPX_KIND)

         end

      end

      ! Clean
      k_pt.destroy

   end

   shift_update_sf_n(dF) ::: private
   ! Update the unique *fragment* atom structure factors "sf_n" with
   ! the frag atom positional shifts (after stabilization) in "dF"
      self :: INOUT
      dF   :: MAT{REAL}, IN

   ENSURE(.data.associated,"no diffraction data!")
   ENSURE(dF.dim1==3,                "dF: wrong dim1")
   ENSURE(dF.dim2==.n_fragment_atoms,"dF: wrong dim2")

      d1,d2,d3, k1,k2,k3, kr  :: REAL
      n_k, u,f, k :: INT
      sf_u :: VEC{CPX}*
      k_pt :: MAT{REAL}*
      arch :: ARCHIVE*

      ! Get the # of k points
      n_k = .n_unique_SF_k_pts

      ! Space for temp-indepedent aspherical SFs
      sf_u.create(n_k)

      ! Make k points
      k_pt.create(n_k,3)
      .data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Loop over unique *frag* atoms
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)

         ! Get the shift
         d1 = dF(1,f)
         d2 = dF(2,f)
         d3 = dF(3,f)

         ! Read stored SFS
         arch.create(trim(.fragment_atom(f).tag)//"-SFs")
         if (.data.use_text_SFs) arch.set_format("ascii")
       ! arch.parallel_read(sf_u)
         arch.read(sf_u)
         arch.destroy

         ! Update sf_u
         do k = 1,n_k

            k1 = k_pt(k,1)
            k2 = k_pt(k,2)
            k3 = k_pt(k,3)

            kr = k1*d1 + k2*d2 + k3*d3

            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr),kind=CPX_KIND)

         end

         ! Write out updated SFs
         arch.create(trim(.fragment_atom(f).tag)//"-SFs")
         if (.data.use_text_SFs) arch.set_format("ascii")
         arch.parallel_write(sf_u)
         arch.destroy

      end

      ! Clean
      k_pt.destroy
      sf_u.destroy

   end

   set_fragment_esds  ::: private
   ! Set *all* the errors in the .fragment_atom positions/ADPs
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.fragment_covariance_matrix.allocated,"no data.fragment_covariance_matrix")

      esd :: VEC{REAL}*

      ! Get the fragment covariances
      .set_frag_from_asym_cov_mx

      ! Get just the positional covariance matrix
      esd.create(.data.fragment_covariance_matrix.dim1)
      .data.fragment_covariance_matrix.put_diagonal_to(esd)
      esd = sqrt(esd)

      ! Set the errors
      .fragment_atom.set_pADP_errors_to(esd,.data.refine_H_U_iso)

      ! Clean
      esd.destroy

   end

!  Refinement: unique frag <-> asym frag parameters

   set_frag_from_asym_pADPs(dF)  ::: private
   ! Set *all* .fragment_atom pADPs from the .asymmetric_unit_atom pADPs.
   ! If "dF" present, the shift in each frag atom position is returned.
      self :: target, IN
      dF :: MAT{REAL}, optional, OUT

   ENSURE(.fragment_info_made,"no fragment info")

      f,a,s :: INT
      f_atom,a_atom :: ATOM*
      seitz :: MAT3{REAL}*
      CM :: MAT{REAL}(3,3)
      shift :: VEC{REAL}(3)

      ! Debug
      if (.debugging("set_frag_from_asym_pADPs")) then
         .asymmetric_unit_atom.put_coordinates
         stdout.text("asymmetric_unit_atom.pADP_vector (before):")
         .asymmetric_unit_atom.put_pADPs
         stdout.text("fragment_atom (before):")
         .fragment_atom.put_coordinates
         stdout.text("fragment_atom.pADP_vector (before):")
         .fragment_atom.put_pADPs
      end

      ! Symmetry operators & cell matrix
      seitz => .xyz_seitz_matrices

      ! Cell matrix
      CM = .unit_cell.direct_matrix

      ! Loop on *all* fragment atom's
      ! Set the .fragment_atom positions/ADP's
      ! from the .asymmetric_unit_atom's
      do f = 1,.n_fragment_atoms

         ! Links between the atom indices & symop s
         a  = .asym_atom_for_frag_atom(f)
         s  = .asym_symop_for_frag_atom(f)

         ! Atoms (fragment, asymmetric)
         f_atom =>        .fragment_atom(f)
         a_atom => .asymmetric_unit_atom(a)

         ! Store original position
         if (present(dF)) dF(:,f) = -f_atom.position

         ! Set frag atom pADPs
         f_atom.set_pADP_vector_to(a_atom.pADP_vector)

         ! Now transform frag atom pADPs with symop
         f_atom.transform_pADP_vector_with(seitz(:,:,s))

         ! Add any fragment shift to (cartesian)  position
         shift.to_product_of(CM,.asym_shift_for_frag_atom(:,f))
         shift = f_atom.position + shift
         f_atom.set_position(shift)

         ! Store shift
         if (present(dF)) dF(:,f) = dF(:,f) + f_atom.position

      end

      ! Clean
      seitz.destroy

      ! Debug
      if (.debugging("set_frag_from_asym_pADPs")) then
         if (present(dF)) then
         stdout.text("dF:")
         stdout.put(dF)
         end
         stdout.text("asymmetric_unit_atom (after):")
         .asymmetric_unit_atom.put_coordinates
         stdout.text("asymmetric_unit_atom.pADP_vector (after):")
         .asymmetric_unit_atom.put_pADPs
         stdout.text("fragment_atom (after):")
         .fragment_atom.put_coordinates
         stdout.text("fragment_atom.pADP_vectorm (after):")
         .fragment_atom.put_pADPs
      end

   end

   set_asym_from_ufrag_shifts ::: private
   ! From "dX", the unique .fragment_atom shifts in positions and
   ! ADP's, return the *asymmetric* atom shifts in positions and
   ! ADP's; place the shifts in the same "dX" parameter vector.

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.dX.associated,"no data.dX")

      u,f,a,s, n, ub,uf,ul, ab,af,al :: INT
      dA,Apar,Xpar :: VEC{REAL}*
      seitz :: MAT3{REAL}*
      a_atom :: ATOM*
      X_atom :: ATOM

      ! Debug
      if (.debugging("set_asym_from_ufrag_shifts")) then
      stdout.text("set_asym_from_ufrag_shifts, .data.dX, before:")
      stdout.put(.data.dX)
      end

      ! Get symops
      seitz => .transposed_xyz_seitz_matrices

      ! Asym atom shift vector
      dA.create(.data.dX.dim)

      ! Base for ufrag atoms
      ub = 0

      ! Loop over unique frag atoms
      ! Order of asym atoms is the same.
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)
         a = .asym_atom_for_frag_atom(f)
         s = .asym_symop_for_frag_atom(f)

         ! Fragment atom, asym atom
         a_atom => .asymmetric_unit_atom(a)

         ! No of pADPs & a-base
         n  = a_atom.no_of_pADPs
         ab = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a)

         ! Block limits
         af = ab + 1
         al = ab + n
         uf = ub + 1
         ul = ub + n

         ! pADP blocks
         Apar =>       dA(af:al)
         Xpar => .data.dX(uf:ul)

         ! Put ufrag shifts at position f1 in "X_atom" (leaky)
         X_atom.pADP_vector.create(n)
         X_atom.set_pADP_vector_to(Xpar)

         ! Change ufrag atom shifts -> asym atom shifts
         X_atom.transform_pADP_vector_with(seitz(:,:,s))

         ! Store asym shifts in position a0 for asym atom "a"
         X_atom.put_pADP_vector_to(Apar)

         ! Clean
         X_atom.destroy_ptr_part

         ! Increment u-base
         ub = ub + n

      end

      ! Replace .dX
      .data.dX = dA

      ! Clean
      dA.destroy
      seitz.destroy

      ! Debug
      if (.debugging("set_asym_from_ufrag_shifts")) then
      stdout.text("set_asym_from_ufrag_shifts, .data.dX, after:")
      stdout.put(.data.dX)
      end

   end

   stabilize_asym_atom_shifts ::: private
   ! Stabilize ".dX", parameter vector for asymmetric atom *shifts*
   ! in positions and ADP's, removing any symmetry breaking.

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.dX.associated,"no data.dX")

      a, n,ab,af,al, n_stab,s,t :: INT
      stabilizer :: VEC{INT}*
      Xpar,par :: VEC{REAL}*
      seitz :: MAT3{REAL}*
      X_atom,Y_atom :: ATOM
      a_atom :: ATOM*
      fac :: REAL

      ! Debug
      if (.debugging("stabilize_asym_atom_shifts")) then
      stdout.text("stabilize_asym_atom_shifts, .data.dX, before:")
      stdout.put(.data.dX)
      end

      ! Get symops
      seitz => .xyz_seitz_matrices

      ! Base for asym atoms
      ab = 0

      ! Symmetrize the asym atom positions/ADP's
      ! We can use the asym atom stabilizers for the ufrag
      do a = 1,.n_asymmetric_unit_atoms

         ! List of stabilizer symops
         stabilizer => .asym_atom_stabilizer(a).element

         ! Any stabilizers?
         n_stab = stabilizer.dim
         if (n_stab<=1) cycle

         ! Fragment atom, asym atom
         a_atom => .asymmetric_unit_atom(a)

         ! Block limits
         n  = a_atom.no_of_pADPs
         af = ab + 1
         al = ab + n

         ! Asym atom a's pADPs
         Xpar => .data.dX(af:al)
         par.create_copy(Xpar)

         ! Set pADPs (leaky)
         X_atom.pADP_vector.create(n)
         Y_atom.pADP_vector.create(n)
         X_atom.set_pADP_vector_to(Xpar)
         Y_atom.set_pADP_vector_to(Xpar)

         if (.debugging("stabilize_asym_atom_shifts")) then
         if (n_stab>1) then
         stdout.text("stabilize_asym_atom_shifts:")
         stdout.show("asym_atom         = ",a)
         stdout.show("asym_atom label   = ",a_atom.label)
         stdout.show("asym_atom tag     = ",a_atom.tag)
         stdout.show("asym_atom symbol  = ",a_atom.chemical_symbol)
         stdout.text("shift:")
         stdout.put(par)
         end
         end

         ! Apply symops and accumulate
         do s = 2,n_stab
            t = stabilizer(s)

            if (.debugging("stabilize_asym_atom_shifts")) then
            stdout.show("stabilizer t      = ",t)
            stdout.text("symop t:")
            stdout.put(seitz(:,:,t))
            X_atom.put_pADP_vector_to(par)
            stdout.text("shift before:")
            stdout.put(par)
            end

            X_atom.transform_pADP_vector_with(seitz(:,:,t))

            if (.debugging("stabilize_asym_atom_shifts")) then
            X_atom.put_pADP_vector_to(par)
            stdout.text("shift after:")
            stdout.put(par)
            end

            Y_atom.set_pADP_vector_to(Y_atom.pADP_vector+X_atom.pADP_vector)

            if (.debugging("stabilize_asym_atom_shifts")) then
            Y_atom.put_pADP_vector_to(par)
            stdout.text("shift sum:")
            stdout.put(par)
            end

         end

         ! Stabilize
         fac = ONE/REALIFY(n_stab)
         Y_atom.set_pADP_vector_to(fac*Y_atom.pADP_vector)

         if (.debugging("stabilize_asym_atom_shifts")) then
         Y_atom.put_pADP_vector_to(par)
         stdout.text("stabilized shift sum:")
         stdout.put(par)
         end
         
         par.destroy

         ! Put back shifts
         Y_atom.put_pADP_vector_to(Xpar)

         if (.debugging("stabilize_asym_atom_shifts")) then
         stdout.text("stabilized shift sum:")
         stdout.put(Xpar)
         end

         ! Clean
         Y_atom.destroy_ptr_part
         X_atom.destroy_ptr_part

         ! Increment a-base
         ab = ab + n

      end

      ! Clean
      seitz.destroy

      ! Debug
      if (.debugging("stabilize_asym_atom_shifts")) then
      stdout.text("stabilize_asym_atom_shifts, .data.dX, after:")
      stdout.put(.data.dX)
      end

   end

   update_fit_esds ::: private
   ! Set the fit errors e.g. maximum shift on esd and the positional
   ! and ADP errors for the asym unit.
      self :: INOUT

   ENSURE(.data.associated,"no data")

      ! Reset the esd's and maximum shifts on esd
      .data.update_fit_esds

      ! Set asym atom par label value corresponding to the max shift/esd
      if (.data.max_shift_on_esd_ind/=DIFFRACTION_DATA_INDMAX_INIT) then
         .data.max_shift_on_esd_par = .asymmetric_unit_atom.tag_pADP_label(.data.max_shift_on_esd_ind)
      else
         .data.max_shift_on_esd_par = "--"
      end

   end

   update_refinement_ESDs
   ! Update the refinement errors e.g. maximum shift on esd and the
   ! positional and ADP errors for the asym unit.
      self :: INOUT

   ENSURE(.data.associated,"no data")

      ! Set the refinement errors
      .data.update_refinement_ESDs

      ! Set asym atom max refinement shift on easd par value
      if (.data.max_refshift_on_esd_ind/=DIFFRACTION_DATA_INDMAX_INIT) then
         .data.max_refshift_on_esd_par = .asymmetric_unit_atom.tag_pADP_label(.data.max_refshift_on_esd_ind)
      else
         .data.max_refshift_on_esd_par = "--"
      end

   end

!  Refinement: transform covariance matrix

   set_asym_from_ufrag_cov_mx ::: private
   ! Set the asymmetric atom covariance matrix from the unique
   ! fragment atom covariance_matrix (produced from refinement)
   ! Note: .covariance_matrix is over-written.
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.covariance_matrix.allocated,"no covariance matrix")

      u1,f1,a1,s1,n1, u1b,u1f,u1l, a1b,a1f,a1l :: INT
      u2,f2,a2,s2,n2, u2b,u2f,u2l, a2b,a2f,a2l :: INT
      dim  :: INT
      diag :: VEC{REAL}*
      T1,T2, asyma_covariance_matrix,acov,ucov :: MAT{REAL}*
      seitz :: MAT3{REAL}*

      ! *Inverse* symops (see below)
      seitz => .transposed_xyz_seitz_matrices

      ! Create asym atom frag covariance matrix
      dim = .data.covariance_matrix.dim1
      asyma_covariance_matrix.create(dim,dim)
      asyma_covariance_matrix = ZERO

      ! Transform the unique .fragment_atom to the asym unit covariances
      u1b = 0
      do u1 = 1,.n_unique_frag_atoms

         ! s1 maps: asym atom a1 -> frag atom f1, but use transpose
         f1 = .unique_frag_atom(u1)
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1)

         ! Block limits
         n1  = .asymmetric_unit_atom(a1).no_of_pADPs
         a1b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a1)
         a1f = a1b +  1
         a1l = a1b + n1
         u1f = u1b +  1
         u1l = u1b + n1

         ! Transformation matrix
         T1.create(n1,n1)
         GAUSSIAN_DATA:symmetric_tensor_product_mx(T1,seitz(:,:,s1))

         u2b = 0
         do u2 = 1,.n_unique_frag_atoms

            ! s2 maps: asym atom a2 -> frag atom f2, but use transpose
            f2 = .unique_frag_atom(u2)
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)

            ! Block limits
            n2  = .asymmetric_unit_atom(a2).no_of_pADPs
            a2b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a2)
            a2f = a2b +  1
            a2l = a2b + n2
            u2f = u2b +  1
            u2l = u2b + n2

            ! Transformation matrix
            T2.create(n2,n2)
            GAUSSIAN_DATA:symmetric_tensor_product_mx(T2,seitz(:,:,s2))

            ! Transform covariances: ufrag -> asym atom
            acov => asyma_covariance_matrix(a1f:a1l,a2f:a2l)
            ucov => .data.covariance_matrix(u1f:u1l,u2f:u2l)
            ucov.back_transform_to(acov,T1,T2)

            ! Increment
            u2b = u2b + n2

         end

         ! Increment
         u1b = u1b + n1

      end

      ! Debugging
      if (.debugging("set_asym_from_ufrag_cov_mx")) then

         stdout.text("acov:")
         stdout.put(acov)

         stdout.text("ucov:")
         stdout.put(ucov)

         diag.create(acov.dim1)
         acov.put_diagonal_to(diag)
         diag = sign(sqrt(abs(diag)),diag)
         stdout.text("acov esds:")
         stdout.put(diag)

         ucov.put_diagonal_to(diag)
         diag = sign(sqrt(abs(diag)),diag)
         stdout.text("ucov esds:")
         stdout.put(diag)

         diag.destroy

      end

      ! Overwrite ufrag-atom cov mx with asym-atom cov mx
      .data.covariance_matrix = asyma_covariance_matrix

      ! Clean
      asyma_covariance_matrix.destroy
      seitz.destroy

   end

   set_frag_from_asym_cov_mx
   ! Set the total frag atom covariance matrix from the asym atom
   ! covariance matrix. Seems correct 12/9/11
      self :: INOUT

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.associated,"no data")
   ENSURE(.data.covariance_matrix.allocated,"no covariance matrix")
   ENSURE(.data.fragment_covariance_matrix.allocated,"no fragment covariance matrix")

      f1,a1,s1,n1, f1b,f1f,f1l, a1b,a1f,a1l :: INT
      f2,a2,s2,n2, f2b,f2f,f2l, a2b,a2f,a2l :: INT
      T1,T2, acov,fcov :: MAT{REAL}*
      seitz :: MAT3{REAL}*

      ! Symops
      seitz => .xyz_seitz_matrices

      ! Copy the asymmetric atom covariances to *all* .fragment_atom ADPs
      f1b = 0
      do f1 = 1,.n_fragment_atoms

         ! s1 maps: asym atom a1 -> frag atom f1
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1)

         ! Block limits
         n1  = .asymmetric_unit_atom(a1).no_of_pADPs
         a1b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a1)
         a1f = a1b +  1
         a1l = a1b + n1
         f1f = f1b +  1
         f1l = f1b + n1

         ! Transformation matrix
         T1.create(n1,n1)
         GAUSSIAN_DATA:symmetric_tensor_product_mx(T1,seitz(:,:,s1))

         f2b = 0
         do f2 = 1,.n_fragment_atoms

            ! s2 maps: asym atom a2 -> frag atom f2
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)

            ! Block limits
            n2  = .asymmetric_unit_atom(a2).no_of_pADPs
            a2b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a2)
            a2f = a2b +  1
            a2l = a2b + n2
            f2f = f2b +  1
            f2l = f2b + n2

            ! Transformation matrix
            T2.create(n2,n2)
            GAUSSIAN_DATA:symmetric_tensor_product_mx(T2,seitz(:,:,s2))

            ! Transform ...
            fcov => .data.fragment_covariance_matrix(f1f:f1l,f2f:f2l)
            acov =>          .data.covariance_matrix(a1f:a1l,a2f:a2l)
            acov.back_transform_to(fcov,T1,T2)

            ! Clean, increment
            T2.destroy
            f2b = f2b + n2

         end

         ! Clean, increment
         T1.destroy
         f1b = f1b + n1

      end

      ! Clean
      seitz.destroy

      ! Debugging
      if (.debugging("set_frag_from_asym_cov_max")) then
         stdout.text("acov:")
         stdout.put(acov)
         stdout.text("fcov:")
         stdout.put(fcov)
      end

   end

!  Refinement: finished?

   update_fit_parameters
   ! Update i.e. increment the fit parameters
      self :: INOUT

   ENSURE(.data_exists,"no diffraction data")

      .data.update_fit_parameters

   end

   update_refinement_parameters
   ! Update the refinement parameters
      self :: INOUT

   ENSURE(.data_exists,"no diffraction data")

      .data.update_refinement_parameters

   end

   fit_finished result (res)
   ! Return whether the (rigid) fit has finished
      self :: IN
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.fit_finished

      ! Rewind coordinates and ADPs if chi2 increases.
      ! WARNING: errors and cox mx are not rewound.
    ! if (.data.chi2_increased) then
    !    .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)
    !    .set_frag_from_asym_pADPs
    ! end

   end

   refinement_finished result (res)
   ! Return whether the refinement has finished
      self :: IN
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.refinement_finished

   end

!  Structure factors only

   make_unique_sf(sf_e,sf_n) ::: private
   ! Make the *temperature dependent* unique structure factors and
   ! their derivatives "sf_e" corresponding to the unique_SF_k_pts
   ! from the temperature independent SFs, "sf_n" and atom parameters
   ! in .fragment_atom.
      self :: IN
      sf_e :: VEC{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.associated, "no reflection data")
   ENSURE(.xray_data.associated, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}@
      u1,u2,u3 :: VEC{REAL}@
      k1k,k2k,k3k,dot,tf :: REAL
      n_k,f,u,k :: INT
      II :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = sf_n.dim1

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! K times thermal tensors
      kU.create(n_k,3)

      ! Initialize
      sf_e = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 = kU(:,1)
         u2 = kU(:,2)
         u3 = kU(:,3)

         do k = 1,n_k

            k1k = k_pt(k,1)
            k2k = k_pt(k,2)
            k3k = k_pt(k,3)

            dot = u1(k)*k1k + u2(k)*k2k + u3(k)*k3k
            tf  = exp(-HALF*dot)

            sf_e(k) = sf_e(k) + sf_n(k,u) * tf

         end

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
      end

      ! Clean
      kU.destroy
      k_pt.destroy

   end

   make_unique_sf(sf_e) ::: private
   ! Make the *temperature dependent* unique structure factors and
   ! their derivatives "sf_e" corresponding to the unique_SF_k_pts
   ! and from atom parameters in .fragment_atom.
   ! NOTE: this version reads SFs from the disk
      self :: IN
      sf_e :: VEC{CPX}, OUT

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(.data.associated, "no reflection data")
   ENSURE(.xray_data.associated, "no x-ray reflection data")

      sf_u :: VEC{CPX}@
      k_pt,kU  :: MAT{REAL}@
      u1,u2,u3 :: VEC{REAL}@
      k1k,k2k,k3k,dot,tf :: REAL
      n_k,f,u,k :: INT
      II :: CPX
      arch :: ARCHIVE*

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! K times thermal tensors
      kU.create(n_k,3)
      sf_u.create(n_k)

      ! Initialize
      sf_e = ZERO

      ! Make the structure factors and derivatives
      do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         ! Read stored SFS
         arch.create(trim(.fragment_atom(f).tag)//"-SFs")
         if (.data.use_text_SFs) arch.set_format("ascii")
         arch.read(sf_u)
         arch.destroy

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 = kU(:,1)
         u2 = kU(:,2)
         u3 = kU(:,3)

         ! Loop over SFs
         do k = 1,n_k

            k1k = k_pt(k,1)
            k2k = k_pt(k,2)
            k3k = k_pt(k,3)

            dot = u1(k)*k1k + u2(k)*k2k + u3(k)*k3k
            tf  = exp(-HALF*dot)

            sf_e(k) = sf_e(k) + sf_u(k) * tf

         end

      end

      ! Clean
      sf_u.destroy
      kU.destroy
      k_pt.destroy

   end

!  SF derivatives 

   make_unique_sf_derivs(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from the given
   ! set of temperature-independent form factors "sf_n", 
   !   - skipping atoms in .refine_nothing_for_atom list, &
   !   - refining U_iso for atoms in .refine_U_iso_for_atom list
   !   - The rest are refined *An*isotropically unless
   !     you specify refine_H_positions or refine_H_ADPs FALSE
   ! Atom parameters are those in .fragment_atom.
      self :: IN
      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts, "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts, "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.asymmetric_unit_atom.no_of_pADPs, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts, "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,"sf_n, wrong dim2")
   ENSURE(.data.associated, "no reflection data")
   ENSURE(.xray_data.associated, "no x-ray reflection data")

      list :: VEC{STR}@
      tags :: VEC{STR}@
      sf_u :: VEC{CPX}@
      kv   :: VEC{REAL}(3)
      k_pt :: MAT{REAL}*
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      zero3 :: REAL
      n_k,f,u,k,base :: INT
      has_skip,has_Uiso,is_H_atom :: BIN
      refine_positions,refine_Uiso :: BIN
      refine_positions_only,refine_ADPs_only :: BIN
      refine_ADPs,refine_ADP4s,refine_ADP3s :: BIN
      II,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      tag :: STR

      ! Is there a nothing list?
      has_skip = .data.refine_nothing_for_atom.associated
      if (has_skip) then
         tags = .fragment_atom(:).tag
         list = .data.refine_nothing_for_atom
         DIE_IF(NOT list.has_all_elements_common_with(tags), "you try to refine nothing for an atom that is not in your list")
      end
      
      ! Are there atoms to be refined isotropically?
      has_Uiso = .data.refine_U_iso_for_atom.associated
      if (has_Uiso) then
         tags = .fragment_atom(:).tag
         list = .data.refine_U_iso_for_atom
         DIE_IF(NOT list.has_all_elements_common_with(tags), "you try to refine an atom isotropically that is not in your list")
      end

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      ! Refine only 4th's?
      zero3 = ONE
      if (.data.refine_4th_order_only) zero3 = ZERO

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         ! Fragment atom
         f = .unique_frag_atom(u)

         ! This atom's label
         tag = .fragment_atom(f).tag

         ! Structure factor, unique frag atom "u"
         sf_u = sf_n(:,u)

         ! Base index for unique frag atom
         base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)

         refine_ADPs_only = .data.refine_ADPs_only
         refine_positions_only = .data.refine_positions_only

         ! Defaults per atom
         if (NOT refine_ADPs_only) then 
            refine_positions = TRUE 
         else
            refine_positions = FALSE
         end

         if (NOT refine_positions_only) then 
            refine_ADPs      = TRUE
         else
            refine_ADPs      = FALSE
         end
         refine_Uiso      = FALSE
         refine_ADP4s     = .fragment_atom(f).has_only_ADP4s_and_errors
         refine_ADP3s     = .fragment_atom(f).has_only_ADP3s_and_errors

         ! Special cases for H atom
         is_H_atom = .fragment_atom(f).atomic_number==1
         if (is_H_atom) then
            refine_positions = .data.refine_H_positions
            refine_ADPs      = .data.refine_H_ADPs
            refine_Uiso      = .data.refine_H_U_iso
         end

         ! Final check to do U_iso this atom?
         if (NOT refine_Uiso) then
         if (has_Uiso) then
         if (any(.data.refine_U_iso_for_atom==tag)) then
            refine_Uiso = TRUE
         end
         end
         end

         ! Skip derivatives for this atom?
         if (has_skip) then
         if (any(.data.refine_nothing_for_atom==tag)) then
            refine_positions = FALSE
            refine_ADPs      = FALSE
         end
         end

         ! Get ADP2s
         .fragment_atom(f).put_ADP2_vector_to(adp2)

         ! Sanity check
         DIE_IF(refine_Uiso AND refine_ADP4s,"can't refine isotropic ADPs & ADP4s for "//trim(tag))
         DIE_IF(refine_Uiso AND refine_ADP3s,"can't refine isotropic ADPs & ADP3s for "//trim(tag))
         DIE_IF(NOT adp2.equals(.fragment_atom(f).ADP_tensor),"ADP2 not equal to ADP_tensor")

         ! ADP4's !!!!!!!!!!!!!
         if (refine_ADP4s) then
         !!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)
            .fragment_atom(f).put_ADP4_vector_to(adp4)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               sf1 = sfh * (ONE - II*c3 + c4)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               if (refine_positions) then 
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1
               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf4  = sf1 * QUARTER
                  sf6  = sf1 * SIXTH
                  sf24 = sf1 * SIXTH*QUARTER
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6*zero3
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6*zero3
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6*zero3
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2*zero3
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2*zero3
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2*zero3
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2*zero3
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2*zero3
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2*zero3
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1*zero3
                 
                  ! U4 derivatives
                  sf_d(k,base+20) = k1_k1*k1_k1*sf24
                  sf_d(k,base+21) = k2_k2*k2_k2*sf24
                  sf_d(k,base+22) = k3_k3*k3_k3*sf24
                  sf_d(k,base+23) = k1_k1*k1_k2*sf6
                  sf_d(k,base+24) = k1_k1*k1_k3*sf6
                  sf_d(k,base+25) = k2_k2*k1_k2*sf6
                  sf_d(k,base+26) = k2_k2*k2_k3*sf6
                  sf_d(k,base+27) = k3_k3*k1_k3*sf6
                  sf_d(k,base+28) = k3_k3*k2_k3*sf6
                  sf_d(k,base+29) = k1_k1*k2_k2*sf4
                  sf_d(k,base+30) = k1_k1*k3_k3*sf4
                  sf_d(k,base+31) = k2_k2*k3_k3*sf4
                  sf_d(k,base+32) = k1_k1*k2_k3*sf2
                  sf_d(k,base+33) = k2_k2*k1_k3*sf2
                  sf_d(k,base+34) = k3_k3*k1_k2*sf2

               end

            end

         ! ADP3's !!!!!!!!!!!!!!!!!!
         else if (refine_ADP3s) then
         !!!!!!!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               ! -- 3rd order only.
               sf1 = sfh * (ONE - II*c3)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               !test refine_H_positions Lorraine
               if (refine_positions) then

                  ! Pos derivatives
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1

               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic!)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf6  = sf1 * SIXTH
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1

               end

            end

         ! ADP2's !!!!!!!!!!!!!!
         else ! NO anharmonicity
         !!!!!!!!!!!!!!!!!!!!!!!

            ! This is for isotropic refinement
            if (refine_Uiso) then ! For U_iso 

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF * (k1_k1+k2_k2+k3_k3)
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U_iso derivatives
                     sf_d(k,base+ 4) = -sf2
                     sf_d(k,base+ 5) = -sf2
                     sf_d(k,base+ 6) = -sf2
                     sf_d(k,base+ 7) = ZERO
                     sf_d(k,base+ 8) = ZERO
                     sf_d(k,base+ 9) = ZERO
   
                  end
   
               end

            ! This is *AN*isotropic refinement
            else ! For ADP2s !!!!!!!!!!!!!!!!!

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U2 derivatives
                     sf_d(k,base+ 4) = -k1_k1*sf2
                     sf_d(k,base+ 5) = -k2_k2*sf2
                     sf_d(k,base+ 6) = -k3_k3*sf2
                     sf_d(k,base+ 7) = -k1_k2*sf1
                     sf_d(k,base+ 8) = -k1_k3*sf1
                     sf_d(k,base+ 9) = -k2_k3*sf1
   
                  end
   
               end

            end

         end

      end

      ! Clean
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sf_derivs(sf_e,sf_d) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from the given
   ! set of temperature-independent form factors, on disk.
   !   - skipping atoms in .refine_nothing_for_atom list, &
   !   - refining U_iso for atoms in .refine_U_iso_for_atom list
   !   - The rest are refined *An*isotropically unless
   !     you specify refine_H_positions or refine_H_ADPs FALSE
   ! Atom parameters are those in .fragment_atom.
      self :: IN
      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts, "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts, "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.asymmetric_unit_atom.no_of_pADPs, "sf_d, wrong dim2")
   ENSURE(.data.associated, "no reflection data")
   ENSURE(.xray_data.associated, "no x-ray reflection data")

      list :: VEC{STR}@
      tags :: VEC{STR}@
      sf_u :: VEC{CPX}@
      kv   :: VEC{REAL}(3)
      k_pt :: MAT{REAL}*
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      zero3 :: REAL
      n_k,f,u,k,base :: INT
      has_skip,has_Uiso,is_H_atom :: BIN
      refine_positions,refine_Uiso :: BIN
      refine_positions_only,refine_ADPs_only :: BIN
      refine_ADPs,refine_ADP4s,refine_ADP3s :: BIN
      II,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      tag :: STR
      arch :: ARCHIVE*

      print*, "LS fit 1"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

      ! Is there a nothing list?
      has_skip = .data.refine_nothing_for_atom.associated
      if (has_skip) then
         tags = .fragment_atom(:).tag
         list = .data.refine_nothing_for_atom
         DIE_IF(NOT list.has_all_elements_common_with(tags), "you try to refine nothing for an atom that is not in your list")
      end
      
      print*, "LS fit 2"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

      ! Are there atoms to be refined isotropically?
      has_Uiso = .data.refine_U_iso_for_atom.associated
      if (has_Uiso) then
         tags = .fragment_atom(:).tag
         list = .data.refine_U_iso_for_atom
         DIE_IF(NOT list.has_all_elements_common_with(tags), "you try to refine an atom isotropically that is not in your list")
      end

      print*, "LS fit 3"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Aspherical temperature independent SFs
      sf_u.create(n_k)

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .data.reflections.make_unique_SF_k_pts(k_pt,.spacegroup,.unit_cell)

      print*, "LS fit 4"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

      ! Refine only 4th's?
      zero3 = ONE
      if (.data.refine_4th_order_only) zero3 = ZERO

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      print*, "LS fit 5"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

      ! Make the structure factors and derivatives
      do u = 1,.n_unique_frag_atoms

         ! Fragment atom
         f = .unique_frag_atom(u)

         ! This atom's label
         tag = .fragment_atom(f).tag

      print*, "LS fit 6"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

         ! Read stored SFS !!!!!!!!!!!!
         arch.create(trim(tag)//"-SFs")
         if (.data.use_text_SFs) arch.set_format("ascii")
         arch.read(sf_u)
         arch.destroy
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      print*, "LS fit 7"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

         ! Base index for unique frag atom
         base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)

         refine_ADPs_only = .data.refine_ADPs_only
         refine_positions_only = .data.refine_positions_only

         ! Defaults per atom
         if (NOT refine_ADPs_only) then 
            refine_positions = TRUE 
         else
            refine_positions = FALSE
         end

         if (NOT refine_positions_only) then 
            refine_ADPs      = TRUE
         else
            refine_ADPs      = FALSE
         end
         refine_Uiso      = FALSE
         refine_ADP4s     = .fragment_atom(f).has_only_ADP4s_and_errors
         refine_ADP3s     = .fragment_atom(f).has_only_ADP3s_and_errors

         ! Special cases for H atom
         is_H_atom = .fragment_atom(f).atomic_number==1
         if (is_H_atom) then
            refine_positions = .data.refine_H_positions
            refine_ADPs      = .data.refine_H_ADPs
            refine_Uiso      = .data.refine_H_U_iso
         end

         ! Final check to do U_iso this atom?
         if (NOT refine_Uiso) then
         if (has_Uiso) then
         if (any(.data.refine_U_iso_for_atom==tag)) then
            refine_Uiso = TRUE
         end
         end
         end

         ! Skip derivatives for this atom?
         if (has_skip) then
         if (any(.data.refine_nothing_for_atom==tag)) then
            refine_positions = FALSE
            refine_ADPs      = FALSE
         end
         end

      print*, "LS fit 8"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

         ! Get ADP2s
         .fragment_atom(f).put_ADP2_vector_to(adp2)

         ! Sanity check
         DIE_IF(refine_Uiso AND refine_ADP4s,"can't refine isotropic ADPs & ADP4s for "//trim(tag))
         DIE_IF(refine_Uiso AND refine_ADP3s,"can't refine isotropic ADPs & ADP3s for "//trim(tag))
         DIE_IF(NOT adp2.equals(.fragment_atom(f).ADP_tensor),"ADP2 not equal to ADP_tensor")

         ! ADP4's !!!!!!!!!!!!!
         if (refine_ADP4s) then
         !!!!!!!!!!!!!!!!!!!!!!

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)
            .fragment_atom(f).put_ADP4_vector_to(adp4)

      print*, "LS fit 9"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               sf1 = sfh * (ONE - II*c3 + c4)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               if (refine_positions) then 
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1
               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf4  = sf1 * QUARTER
                  sf6  = sf1 * SIXTH
                  sf24 = sf1 * SIXTH*QUARTER
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6*zero3
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6*zero3
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6*zero3
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2*zero3
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2*zero3
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2*zero3
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2*zero3
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2*zero3
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2*zero3
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1*zero3
                 
                  ! U4 derivatives
                  sf_d(k,base+20) = k1_k1*k1_k1*sf24
                  sf_d(k,base+21) = k2_k2*k2_k2*sf24
                  sf_d(k,base+22) = k3_k3*k3_k3*sf24
                  sf_d(k,base+23) = k1_k1*k1_k2*sf6
                  sf_d(k,base+24) = k1_k1*k1_k3*sf6
                  sf_d(k,base+25) = k2_k2*k1_k2*sf6
                  sf_d(k,base+26) = k2_k2*k2_k3*sf6
                  sf_d(k,base+27) = k3_k3*k1_k3*sf6
                  sf_d(k,base+28) = k3_k3*k2_k3*sf6
                  sf_d(k,base+29) = k1_k1*k2_k2*sf4
                  sf_d(k,base+30) = k1_k1*k3_k3*sf4
                  sf_d(k,base+31) = k2_k2*k3_k3*sf4
                  sf_d(k,base+32) = k1_k1*k2_k3*sf2
                  sf_d(k,base+33) = k2_k2*k1_k3*sf2
                  sf_d(k,base+34) = k3_k3*k1_k2*sf2

               end

            end

      print*, "LS fit 10"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

         ! ADP3's !!!!!!!!!!!!!!!!!!
         else if (refine_ADP3s) then
         !!!!!!!!!!!!!!!!!!!!!!!!!!!

      print*, "LS fit 11"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

            ! Get ADP tensors
            .fragment_atom(f).put_ADP3_vector_to(adp3)

            do k = 1,n_k

               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH

               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               ! -- 3rd order only.
               sf1 = sfh * (ONE - II*c3)
               sf2 = sf1 * HALF

               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1

               !test refine_H_positions Lorraine
               if (refine_positions) then

                  ! Pos derivatives
                  sf_d(k,base+ 1) =  II*k1*sf1
                  sf_d(k,base+ 2) =  II*k2*sf1
                  sf_d(k,base+ 3) =  II*k3*sf1

               end

               if (refine_ADPs) then

                  ! U2 derivatives
                  sf_d(k,base+ 4) = -k1_k1*sf2
                  sf_d(k,base+ 5) = -k2_k2*sf2
                  sf_d(k,base+ 6) = -k3_k3*sf2
                  sf_d(k,base+ 7) = -k1_k2*sf1
                  sf_d(k,base+ 8) = -k1_k3*sf1
                  sf_d(k,base+ 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic!)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf6  = sf1 * SIXTH
                 
                  ! U3 derivatives
                  sf_d(k,base+10) = -II*k1_k1*k1*sf6
                  sf_d(k,base+11) = -II*k2_k2*k2*sf6
                  sf_d(k,base+12) = -II*k3_k3*k3*sf6
                  sf_d(k,base+13) = -II*k1_k1*k2*sf2
                  sf_d(k,base+14) = -II*k1_k1*k3*sf2
                  sf_d(k,base+15) = -II*k2_k2*k1*sf2
                  sf_d(k,base+16) = -II*k2_k2*k3*sf2
                  sf_d(k,base+17) = -II*k3_k3*k1*sf2
                  sf_d(k,base+18) = -II*k3_k3*k2*sf2
                  sf_d(k,base+19) = -II*k1*k2*k3*sf1

               end

            end

      print*, "LS fit 12"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

         ! ADP2's !!!!!!!!!!!!!!
         else ! NO anharmonicity
         !!!!!!!!!!!!!!!!!!!!!!!

      print*, "LS fit 13"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

            ! This is for isotropic refinement
            if (refine_Uiso) then ! For U_iso 

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF * (k1_k1+k2_k2+k3_k3)
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U_iso derivatives
                     sf_d(k,base+ 4) = -sf2
                     sf_d(k,base+ 5) = -sf2
                     sf_d(k,base+ 6) = -sf2
                     sf_d(k,base+ 7) = ZERO
                     sf_d(k,base+ 8) = ZERO
                     sf_d(k,base+ 9) = ZERO
   
                  end
   
               end

            ! This is *AN*isotropic refinement
            else ! For ADP2s !!!!!!!!!!!!!!!!!

               do k = 1,n_k
   
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
   
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
   
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
   
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
   
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF
   
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
   
                  if (refine_positions) then
   
                     ! Pos derivatives
                     sf_d(k,base+ 1) =  II*k1*sf1
                     sf_d(k,base+ 2) =  II*k2*sf1
                     sf_d(k,base+ 3) =  II*k3*sf1
   
                  end
   
                  if (refine_ADPs) then
   
                     ! U2 derivatives
                     sf_d(k,base+ 4) = -k1_k1*sf2
                     sf_d(k,base+ 5) = -k2_k2*sf2
                     sf_d(k,base+ 6) = -k3_k3*sf2
                     sf_d(k,base+ 7) = -k1_k2*sf1
                     sf_d(k,base+ 8) = -k1_k3*sf1
                     sf_d(k,base+ 9) = -k2_k3*sf1
   
                  end
   
               end

            end

      print*, "LS fit 14"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

         end

      end

      ! Clean
      k_pt.destroy
      sf_u.destroy

      print*, "LS fit 15"
      call EXECUTE_COMMAND_LINE("ps  -C tonto-3g -o pmem")

   end


   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs = |F_calc| with
   ! respect to some parameters X (e.g. thermal parameters) given
   ! "dFdX", the derivatives of the complex structure factors  w.r.t.
   ! the X parameters.
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.data_exists,"no diffraction data")

      .data.d_F_abs_dX(res,dFdX)

   end

   d_F_abs_2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors  w.r.t. the X
   ! parameters.
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_F_abs_2_dX(res,dFdX)
   end

!  Normal equations

   solve_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in the parameters by solving the normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters.
      self :: INOUT
      dFdX :: MAT{REAL}, IN

   ENSURE(.data_exists,"no diffraction data")

      .data.solve_normal_equations(dFdX)

   end

!  =================
!  Refinement output
!  =================

   put_fit_header_info ::: private
   ! Put out the fit header
      self :: IN

   ENSURE(.data_exists,"no diffraction data")

      ! Print header
      DIFFRACTION_DATA:put_fit_header

      ! Put the fit control switches
      .data.put_refinement_switches

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Initial parameter values:")
      stdout.flush
      .put_parameters(correlation_matrix=FALSE)

      ! Put the fit table header
      .data.put_fit_table_headings

   end

   put_refinement_header_info
   ! Put out the fit header
      self :: IN

   ENSURE(.data_exists,"no diffraction data")

      ! Print header
      DIFFRACTION_DATA:put_refinement_header

      ! Put the refinement control switches
      .data.put_refinement_switches
      
      ! Put the initial parameters
      stdout.flush
      stdout.text("Initial asymmetric unit parameter values:")
      stdout.flush
      .put_parameters(correlation_matrix=FALSE)
      
      ! Put the refinement header info
      .data.put_refinement_table_headings

   end

   put_parameters(correlation_matrix) ::: private
   ! Write refinement results
      self :: IN
      correlation_matrix :: BIN, optional, IN

   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.asymmetric_unit_atom.associated,"no .asymmetric_unit_atom's")

      do_corr_mx :: BIN
      n_p :: INT

      ! Put positions and ADPs
      .asymmetric_unit_atom.put_coordinates(no_header=TRUE)
      .asymmetric_unit_atom.put_ADPs(no_header=TRUE)
      
      ! Whether to print the parameter corelation matrix
      do_corr_mx = .data.display_correlation_matrix
      if (present(correlation_matrix)) do_corr_mx = correlation_matrix
      
      ! Put correlation matrix
      if (do_corr_mx) .put_correlation_matrix
      
      ! Put zero eigenvalue information
      if (.data.display_near_0_eigenvectors) then
      if (.data.fit_finished) then
         n_p = .asymmetric_unit_atom.no_of_pADPs
         .data.put_near_0_eigenvectors(n_p)
      end
      end

   end

   put_correlation_matrix ::: private
   ! Put the correlation matrix
      self :: IN

   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.data.correlation_matrix.allocated,"no data.correlation_matrix")
   ENSURE(.asymmetric_unit_atom.associated,"no .asymmetric_unit_atom's")

      val :: VEC{REAL}*
      row,col,ind :: VEC{INT}*
      label,labr,labc :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      min_corr :: REAL
      n_corr :: INT

      ! How many large correlations?
      min_corr = .data.min_correlation
      n_corr   = .data.correlation_matrix.number_in_range([min_corr,0.999d0],symmetric=TRUE)

      ! If no large correlations, return
      if (n_corr<0 AND NOT .data.display_correlation_matrix) return

      ! Create
      val.create(n_corr)
      label.create(n_corr)
      ind.create(n_corr)
      row.create(n_corr)
      col.create(n_corr)

      ! Get row and column indices
      .data.correlation_matrix.get_indices_in_range([min_corr,0.9999d0],row,col,val,symmetric=TRUE)

      ! Construct the row labels
      labr  => .asymmetric_unit_atom.tag_pADP_labels(row)
      labc  => .asymmetric_unit_atom.tag_pADP_labels(col)
      label = labr
      label.concatenate_elementwise_with("--")
      label.concatenate_elementwise_with(labc)

      ! Clean
      labc.destroy
      labr.destroy
      col.destroy
      row.destroy

      ! Sort
      val.quick_sort(ind,decreasing_order=TRUE)
      val = val(ind)
      label = label(ind)
      ind.destroy

      ! Make table
      table.create(2)
      table(1).set_heading("Param. Pair"); table(1).set_values(label)
      table(1).set_heading("Correlation"); table(2).set_values(val)

      ! Put table
      stdout.flush
      stdout.text("===============================")
      stdout.text("Correlations between parameters")
      stdout.text("===============================")
      stdout.flush
      stdout.show("Smallest correlation to show  =",min_corr)
      stdout.flush
      table.put
      table.destroy

      ! Put the array out
    ! stdout.flush
    ! stdout.text("Largest correlations:")
    ! stdout.flush
    ! stdout.put(val,row_label=label,col_label="Correlation")

      ! Clean again
      label.destroy
      val.destroy

   end

   put_fit_results ::: private
   ! Finalise fit, write results
      self :: IN

   ENSURE(.data_exists,"no diffraction data")

      ! Iteration footer
      .data.put_fit_results

      ! Put the parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      stdout.flush
      .put_parameters

   end

   put_refinement_results
   ! Finalise refinement, write results
      self :: IN

   ENSURE(.data_exists,"no diffraction data")

      ! Iteration footer
      .data.put_refinement_results

      ! Put the final parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      stdout.flush
      .put_parameters

   end

   put_bond_info_with_errors
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors in brackets
      self :: IN

   ENSURE(.data.associated,   "no data")
   ENSURE(.data.fragment_covariance_matrix.allocated,"no fragment_covariance_matrix")

      f1,n1,f1b,c1b :: INT
      f2,n2,f2b,c2b :: INT
      cm :: MAT{REAL}*

      ! Turn off printing if refining
    ! if (.data.refine_structure) return

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix (sigh)
      f1b = 0
      c1b = 0
      do f1 = 1,.n_fragment_atoms

         n1  = .fragment_atom(f1).no_of_pADPs

         f2b = 0
         c2b = 0
         do f2 = 1,.n_fragment_atoms

            n2  = .fragment_atom(f2).no_of_pADPs

            cm(c1b+1:c1b+3,c2b+1:c2b+3) = .data.fragment_covariance_matrix(f1b+1:f1b+3,f2b+1:f2b+3)

            f2b = f2b + n2
            c2b = c2b + 3

         end

         f1b = f1b + n1
         c1b = c1b + 3

      end

      ! Print out the tables with errors
      .fragment_atom.put_bond_length_table(cm)
      .fragment_atom.put_bond_angle_table(cm)
      .fragment_atom.put_torsion_angle_table(cm)

      ! Clean
      cm.destroy

   end

   put_CIF_bond_info_tables(atom,covariance_matrix) ::: selfless
   ! Put out the CIF bond lengths for an "atom" list with an
   ! associated "covariance_matrix"
      atom :: VEC{ATOM}, IN
      covariance_matrix :: MAT{REAL}, IN

      f1,n1,f1b,c1b :: INT
      f2,n2,f2b,c2b :: INT
      cm :: MAT{REAL}*

      ! Positional covariance matrix
      cm.create(3*atom.dim,3*atom.dim)

      ! Get just the positional covariance matrix (sigh)
      f1b = 0
      c1b = 0
      do f1 = 1,atom.dim

         n1  = atom(f1).no_of_pADPs

         f2b = 0
         c2b = 0
         do f2 = 1,atom.dim

            n2  = atom(f2).no_of_pADPs

            cm(c1b+1:c1b+3,c2b+1:c2b+3) = covariance_matrix(f1b+1:f1b+3,f2b+1:f2b+3)

            f2b = f2b + n2
            c2b = c2b + 3

         end

         f1b = f1b + n1
         c1b = c1b + 3

      end

      ! Print out the *CIF* tables with errors
      atom.put_CIF_bond_length_table(cm)
      atom.put_CIF_bond_angle_table(cm)

      ! Clean
      cm.destroy

   end

   make_pos_covariance_matrix(cm) ::: leaky
   ! Allocate and make the positional covarinace matrix "cm".
      cm :: MAT{REAL}*

   ENSURE(.data.associated,   "no data")
   ENSURE(.data.fragment_covariance_matrix.allocated,"no fragment_covariance_matrix")

      f1,n1,f1b,c1b :: INT
      f2,n2,f2b,c2b :: INT

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix (sigh)
      f1b = 0
      c1b = 0
      do f1 = 1,.n_fragment_atoms

         n1  = .fragment_atom(f1).no_of_pADPs

         f2b = 0
         c2b = 0
         do f2 = 1,.n_fragment_atoms

            n2  = .fragment_atom(f2).no_of_pADPs

            cm(c1b+1:c1b+3,c2b+1:c2b+3) = .data.fragment_covariance_matrix(f1b+1:f1b+3,f2b+1:f2b+3)

            f2b = f2b + n2
            c2b = c2b + 3

         end

         f1b = f1b + n1
         c1b = c1b + 3

      end

   end

   put_bond_info_with_errors_to
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors with *no* brackets to a file, name read from stdin
      self :: IN

   ENSURE(.data.associated,   "no data")
   ENSURE(.data.fragment_covariance_matrix.allocated,"no fragment_covariance_matrix")

      cm :: MAT{REAL}*
      name :: STR
      save,file :: TEXTFILE*

      ! Read the name
      stdin.read(name)

      ! Create the new file
      file.create(trim(name))
      file.open_for("write")

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix
      .data.fragment_covariance_matrix.put_sub_blocks_to(cm,9,3)

      ! Print out the tables with errors
      save   => TEXTFILE::stdout
      stdout => file
      .fragment_atom.put_bond_length_table(cm,parentheses=FALSE)
      .fragment_atom.put_bond_angle_table(cm,parentheses=FALSE)
      .fragment_atom.put_torsion_angle_table(cm,parentheses=FALSE)
      stdout => save

      ! Clean
      cm.destroy
      file.close; file.destroy

   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("CIF_chemical_formula",.CIF_chemical_formula)
      .spacegroup.dump("spacegroup")
      .unit_cell.dump("unit_cell")
      stdout.dump("n_fragment_atoms",.n_fragment_atoms)
      .fragment_atom.dmpp("fragment_atom")
      stdout.dump("destroy_fragment_atom",.destroy_fragment_atom)
      stdout.dmpp("fragment_geometry",.fragment_geometry)
      stdout.dump("fragment_offset",.fragment_offset)
      stdout.dump("asymmetric_unit_source",.asymmetric_unit_source)
      stdout.dump("n_asymmetric_unit_atoms",.n_asymmetric_unit_atoms)
      .asymmetric_unit_atom.dmpp("asymmetric_unit_atom")
      stdout.dmpp("asymmetric_unit_geometry",.asymmetric_unit_geometry)
      stdout.dump("prune_asymmetric_unit",.prune_asymmetric_unit)
      stdout.dump("n_unit_cell_atoms",.n_unit_cell_atoms)
      stdout.dmpp("unit_cell_geometry",.unit_cell_geometry)
      stdout.dmpp("unique_unit_cell_atom",.unique_unit_cell_atom)
    ! stdout.dmpp("unique_uc_atom_offset",.unique_uc_atom_offset)
      stdout.dmpp("is_asym_unit_cell_atom",.is_asym_unit_cell_atom)
      stdout.dump("fragment_info_made",.fragment_info_made)
      stdout.dmpp("asym_atom_for_unit_cell_atom",.asym_atom_for_unit_cell_atom)
      stdout.dmpp("asym_symop_for_unit_cell_atom",.asym_symop_for_unit_cell_atom)
      stdout.dmpp("frag_atom_for_unit_cell_atom",.frag_atom_for_unit_cell_atom)
      stdout.dmpp("unit_cell_atom_for_frag_atom",.unit_cell_atom_for_frag_atom)
      stdout.dmpp("unit_cell_shft_for_frag_atom",.unit_cell_shft_for_frag_atom)
      stdout.dmpp("frag_atom_for_asym_atom",.frag_atom_for_asym_atom)
      stdout.dmpp("asym_atom_for_frag_atom",.asym_atom_for_frag_atom)
      stdout.dmpp("frag_parent_for_cell_atom",.frag_parent_for_cell_atom)
      stdout.dump("n_unique_frag_atoms",.n_unique_frag_atoms)
      stdout.dmpp("unique_frag_atom",.unique_frag_atom)
      stdout.dmpp("unique_atom_for_frag_atom",.unique_atom_for_frag_atom)
      stdout.dmpp("unique_symop_for_frag_atom",.unique_symop_for_frag_atom)
      stdout.dmpp("asym_symop_for_frag_atom",.asym_symop_for_frag_atom)
      stdout.dmpp("asym_shift_for_frag_atom",.asym_shift_for_frag_atom)
      stdout.dump("Z",.Z)
      stdout.dump("use_manual_repetition_factors",.use_manual_repetition_factors)
      stdout.dmpp("repetition_factor",.repetition_factor)
      stdout.dmpp("asym_atom_sym_factor",.asym_atom_sym_factor)
    ! stdout.dmpp("asym_atom_stabilizer",.asym_atom_stabilizer)
    ! stdout.dmpp("unit_cell_connection",.unit_cell_connection)
    ! stdout.dmpp("uc_vdw_connection",.uc_vdw_connection)
      stdout.dmpp("unit_cell_mol_for_atom",.unit_cell_mol_for_atom)
      stdout.dump("n_unit_cell_mols",.n_unit_cell_mols)
      stdout.dump("n_stabilizer_symops",.n_stabilizer_symops)
    ! stdout.dmpp("stabilizer_symop",.stabilizer_symop)
      stdout.dmpp("str",.str)
      stdout.dmpp("ptr",.ptr)
      stdout.dmpp("dtr",.dtr)
      stdout.dmpp("ftr",.ftr)
      stdout.dmpp("gtr",.gtr)
      stdout.dump("data_kind",.data_kind)
    ! stdout.dmpp("data",.data)
    ! stdout.dmpp("xray_data",.xray_data)
    ! stdout.dmpp("pnd_data",.pnd_data)
      stdout.dump("r_free_percentage",.r_free_percentage)
    ! stdout.dmpp("xray_r_free_data",.xray_r_free_data)
    ! stdout.dmpp("pnd_r_free_data",.pnd_r_free_data)
      stdout.dump("finalize",.finalize)

      stdout.dump("radius",.radius)
      stdout.dump("atom_density_cutoff",.atom_density_cutoff)
      stdout.dump("generation_method",.generation_method)
      stdout.dump("defragment",.defragment)
      stdout.dump("n_atoms",.n_atoms)
      stdout.dmpp("geometry",.geometry)
      stdout.dump("unit_cell_offset",.unit_cell_offset)
      stdout.dump("h_min",.h_min)
      stdout.dump("h_max",.h_max)
      stdout.dump("n_shift",.n_shift)
      stdout.dmpp("shift",.shift)
      stdout.dmpp("shift_for_atom",.shift_for_atom)
      stdout.dmpp("is_fragment_atom",.is_fragment_atom)
      stdout.dmpp("occupation_list",.occupation_list)

      stdout.dump("n_molecules",.n_molecules)
      stdout.dmpp("molecule_for_atom",.molecule_for_atom)
    ! stdout.dmpp("molecule",.molecule)
      stdout.dmpp("molecule_centroid",.molecule_centroid)
      stdout.dmpp("unique_molecule_for",.unique_molecule_for)
      stdout.dmpp("unique_sycode_for",.unique_symcode_for)
    ! stdout.dmpp("atom_connection",.atom_connection)
      stdout.dmpp("unit_cell_atoms_to_suppress",.unit_cell_atoms_to_suppress)

      stdout.dump("cluster_info_made",.cluster_info_made)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE?=>CRYSTAL)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE?=>CRYSTAL)
   ! Dump pointer object data as text
   end

!  ===========
!  Put methods
!  ===========

   put
   ! Put out the crystal data to file "out"
      self :: INOUT

      .unit_cell.put

      .spacegroup.put
      if (NOT tonto.low_verbosity) .put_xyz_seitz_matrices

      if (.asymmetric_unit_geometry.associated) .put_asymmetric_unit_geometry

      if (tonto.low_verbosity) then
      if (.fragment_geometry.associated) then
         if (.fragment_geometry.dim>100) return
      end
      end

      if (.fragment_geometry.associated)        .put_fragment_data
      if (.unit_cell_geometry.associated)       .put_unit_cell_geometry

    ! if (.unit_cell_connection.associated)     .put_uc_connection_table
    ! if (.uc_vdw_connection.associated)        .put_uc_vdw_connection_table

    ! .put_reflection_data

   end

   put_xyz_seitz_matrices
   ! Put out the cartesian seitz matrices.
      self :: IN

      symop :: MAT3{REAL}*


      stdout.save
      stdout.set_using_array_labels(FALSE)
      stdout.set_real_precision(3)

      symop => .xyz_seitz_matrices

      stdout.flush
      stdout.text("========================")
      stdout.text("Cartesian Seitz matrices")
      stdout.text("========================")
      stdout.put(symop,auto_width=TRUE)

      ! Clean
      symop.destroy
      stdout.unsave

   end

   put_asymmetric_unit_geometry ::: private
   ! Put out the asymmetric unit geometry.

   ENSURE(.asymmetric_unit_geometry.associated,"no asymmetric unit geometry")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric unit atoms")
   ENSURE(.asym_atom_sym_factor.associated,"no asym_atom_sym_factor")
   ENSURE(.asym_atom_stabilizer.associated,"no asym_atom_stabilizer")

      ID :: VEC{STR}*
      rf :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("===============")
      stdout.text("Asymmetric unit")
      stdout.text("===============")
      stdout.flush
      stdout.show("Asymmetric unit source       =",.asymmetric_unit_source)
      stdout.show("No. of asymmetric unit atoms =",.n_asymmetric_unit_atoms)
      stdout.flush

      ! Data
      ID => .asymmetric_unit_atom.unique_tags
      rf.create(.n_asymmetric_unit_atoms)
      rf = int(.asym_atom_sym_factor)

      ! Table
      table.create(6)
      table(1).set_heading("ID");         table(1).set_values(ID)
      table(2).set_heading("x");          table(2).set_values(.asymmetric_unit_geometry(1,:))
      table(3).set_heading("y");          table(3).set_values(.asymmetric_unit_geometry(2,:))
      table(4).set_heading("z");          table(4).set_values(.asymmetric_unit_geometry(3,:))
      table(3).set_sb3head("/frac")
      table(5).set_heading("Site");       table(5).set_values(rf)
      table(5).set_subhead("symm")
      table(5).set_sb3head("fact")
      table(6).set_item_spacing(2)
      table(6).set_heading("Stabilizer"); table(6).set_values(.asym_atom_stabilizer)
      table(6).set_subhead("symops")
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      rf.destroy
      ID.destroy

   end

   put_unit_cell_geometry
   ! Put out the unit_cell_geometry.

   ENSURE(.unit_cell_geometry.associated,"no unit_cell_geometry")
   ENSURE(.asym_atom_for_unit_cell_atom.associated, "no asym-atom_for_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.associated,"no asym_symop_for_cell_atom")
   ENSURE(.frag_atom_for_unit_cell_atom.associated, "no frag_atom_for_cell_atom")
   ENSURE(.frag_parent_for_cell_atom.associated,    "no frag_parent_for_cell_atom")

      ID :: VEC{STR}*
      is_asym :: VEC{BIN}*
      asym_atom,asym_symp,frag_atom,frag_parn :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      ! Data
      ID        => .asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).unique_tags
      asym_atom => .asym_atom_for_unit_cell_atom
      asym_symp => .asym_symop_for_unit_cell_atom
      is_asym   => .is_asym_unit_cell_atom
      frag_atom => .frag_atom_for_unit_cell_atom
      frag_parn => .frag_parent_for_cell_atom

      ! Header
      stdout.flush
      stdout.flush
      stdout.text("==================")
      stdout.text("Unit cell geometry")
      stdout.text("==================")

      if (.spacegroup.n_seitz==1) then
      stdout.flush
      stdout.text(". The spacegroup is P1. The unit cell")
      stdout.text("  is the same as the asymmetric unit.")
      end

      if (any(frag_parn==0)) then
      stdout.flush
      stdout.text(". The fragment does encompass the whole")
      stdout.text("  unit cell - there are 0 indices.")
      end

      stdout.flush
      stdout.show("No. of unit cell atoms =",.n_unit_cell_atoms)
      stdout.flush

      ! Table
      table.create(9)

      table(1).set_heading("ID");        table(1).set_values(ID)

      table(3).set_heading("Coord")
      table(2).set_subhead("- x -");     table(2).set_values(.unit_cell_geometry(1,:))
      table(3).set_subhead("- y -");     table(3).set_values(.unit_cell_geometry(2,:))
      table(4).set_subhead("- z -");     table(4).set_values(.unit_cell_geometry(3,:))
      table(3).set_sb3head("/frac")

      table(5).set_heading("From");      table(5).set_values(asym_atom)
      table(5).set_subhead("asym")
      table(5).set_sb3head("atom")

      table(6).set_heading("Using");     table(6).set_values(asym_symp)
      table(6).set_subhead("symop")
      table(6).set_sb3head("    #")

      table(7).set_heading("Asym");      table(7).set_values(is_asym)
      table(7).set_subhead("atom")
      table(7).set_sb3head("   ?")

      table(8).set_heading("Made by a"); table(8).set_values(frag_atom)
      table(8).set_subhead("shift frm")
      table(8).set_sb3head("frag atom")

      table(9).set_heading("Made by a"); table(9).set_values(frag_parn)
      table(9).set_subhead("symop frm")
      table(9).set_sb3head("frag atom")

      table.put

      ! Clean
      table.clear_columns
      table.destroy
      ID.destroy

   end

   put_pdb(pdbfile)
   ! pdb file header generation
   ! Put unit cell information
   !CRYST1   31.595   32.369   24.219  90.00  90.00  90.00 P 21 21 21    8
      self :: IN
      pdbfile :: TEXTFILE*

      factor :: REAL

      pdbfile.save
      pdbfile.set_margin_width(0)
      pdbfile.put("CRYST1",width=6)
      pdbfile.set_real_precision(3)
      pdbfile.set_real_width(9)

      pdbfile.put(.unit_cell.length(1).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(2).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(3).to_units("angstrom"))

      pdbfile.set_real_precision(2)
      pdbfile.set_real_width(7)

      pdbfile.put(.unit_cell.angle(1).to_units("degree"))
      pdbfile.put(.unit_cell.angle(2).to_units("degree"))
      pdbfile.put(.unit_cell.angle(3).to_units("degree"))
      pdbfile.put(.spacegroup.HM_symbol,width=10)
      pdbfile.put(.Z,width=5)
      pdbfile.flush

      pdbfile.put("SCALE1",width=6)
      pdbfile.tab(width=6)
      pdbfile.set_real_precision(7)
      pdbfile.set_real_width(10)
      factor=1.0d0
      factor.convert_to("angstrom^-1")

      pdbfile.put(.unit_cell.inverse_matrix(1,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,3)*factor)
      pdbfile.flush

      pdbfile.put("SCALE2",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(2,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,3)*factor)
      pdbfile.flush

      pdbfile.put("SCALE3",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(3,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,3)*factor)
      pdbfile.flush

      !SCALE1     0.1053741 0.0175390 0.0172991      0.0000000
      !SCALE2     0.0000000 0.0601636 0.0076747      0.0000000
      !SCALE3     0.0000000 0.0000000 0.0321397      0.0000000
      pdbfile.unsave

   end

! CIF

   put_asymm_unit_CIF(cif)
   ! Put out an asymmetric-unit "cif" file
      self :: INOUT
      cif :: CIF, IN

   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom list")

      has_covariances :: BIN

      has_covariances = .has_covariance_matrix

      if (has_covariances) then
         .:put_CIF(cif,.asymmetric_unit_atom,.data.covariance_matrix)
      else
         .:put_CIF(cif,.asymmetric_unit_atom)
      end

   end

   put_fragment_CIF(cif)
   ! Put out a fragment_atom "cif" file
      self :: INOUT
      cif :: CIF, IN

   ENSURE(.fragment_atom.associated,"no fragment_atom list")

      has_covariances :: BIN

      has_covariances = .has_fragment_covariance_matrix

      if (has_covariances) then
         .:put_CIF(cif,.fragment_atom,.data.fragment_covariance_matrix)
      else
         .:put_CIF(cif,.fragment_atom)
      end

   end

   put_asymm_unit_CIF_bond_info 
   ! Put out an asymmetric-unit "cif" file, bond info only
      self :: INOUT

   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom list")
   ENSURE(.asymmetric_unit_atom(1).pos_axis_system=="cartesian","not cartesian axes!")

      if (NOT .has_covariance_matrix) return

      ::put_CIF_bond_info_tables(.asymmetric_unit_atom,.data.covariance_matrix)

   end

   put_fragment_CIF_bond_info
   ! Put out a fragment_atom "cif" file, bond info only
      self :: IN

   ENSURE(.fragment_atom.associated,"no fragment_atom list")
   ENSURE(.fragment_atom(1).pos_axis_system=="cartesian","not cartesian axes!")

      if (NOT .has_fragment_covariance_matrix) return

      ::put_CIF_bond_info_tables(.fragment_atom,.data.fragment_covariance_matrix)

   end


   has_covariances result (res) ::: PURE
   ! Does the covariance matrix exist?
      self :: IN
      res :: BIN

      res = .has_covariance_matrix &
        AND .has_fragment_covariance_matrix

   end

   has_covariance_matrix result (res) ::: PURE
   ! Does the covariance matrix exist?
      self :: IN
      res :: BIN

      res = FALSE

      if (.data.associated) then
      if (.data.covariance_matrix.allocated) then
         res = TRUE
      end
      end

   end

   has_fragment_covariance_matrix result (res) ::: PURE
   ! Does the fragment_covariance matrix exist?
      self :: IN
      res :: BIN

      res = FALSE

      if (.data.associated) then
      if (.data.fragment_covariance_matrix.allocated) then
         res = TRUE
      end
      end

   end


   put_CIF(cif,atom) ::: private
   ! Put an "atom" cif file without errors.
      self :: INOUT
      cif  :: CIF, IN
      atom :: VEC{ATOM}, IN

      thresh :: STR
      refine_H_U_iso,cart,har :: BIN

      ! Placeholders
      ::put_CIF_crystal_data

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      cart = atom(1).pos_axis_system == "cartesian"
      har  = FALSE
      if (.data.associated) har = .data.refine_structure OR .data.fit_structure
      .unit_cell.put_CIF(.Z,cart,har)

      ! Any data?
      refine_H_U_iso = TRUE
      if (.data.associated) refine_H_U_iso = .data.refine_H_U_iso

      ! Put the info
      atom.put_CIF_coords(refine_H_U_iso)
      atom.put_CIF_ADP2(refine_H_U_iso)
      atom.put_CIF_ADPn(cif)

      ! Put covariance matrix  
      if (cif.use_CIF2) then
      if (atom(1).pos_axis_system=="cartesian") then
      if (.data.associated) then
      if (.data.reflections.associated) then
         .data.put_CIF_covariance_matrices(cif)
      end
      end
      end
      end
      
      ! Put wavelength and other refl data
      if (.data.associated) then
      if (.data.reflections.associated) then
         thresh = .data.CIF_threshold_expression
         .data.reflections.put_CIF_refln_data(thresh)
      end
      end

      ! Put the reflection data
      if (.data.associated) then
      if (.data.reflections.associated) then
       ! .put_xd_fco
      end
      end

   end

   put_CIF(cif,atom,covariance_matrix) ::: private
   ! Put a *molecular fragment* cif file with errors, using "atom"
   ! list.  ESDs are produced from .data.fragment_covariance_matrix
   ! and NOTE: must have the correct units on entry.
      self :: INOUT
      cif  :: CIF, IN
      atom :: VEC{ATOM}, IN
      covariance_matrix :: MAT{REAL}, IN

   ENSURE(.data.associated,"no diffraction data!")

      n_pADPs :: INT
      thresh :: STR
      cart,har :: BIN
      esd :: VEC{REAL}*

      ! Placeholders
      ::put_CIF_crystal_data

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      cart = atom(1).pos_axis_system == "cartesian"
      har  = FALSE
      if (.data.associated) har = .data.refine_structure OR .data.fit_structure
      .unit_cell.put_CIF(.Z,cart,har)

      ! Put refinement special info
      .data.put_CIF_refinement

      ! Errors
      n_pADPs = atom.no_of_pADPs
      esd.create(n_pADPs)
      .::make_CIF_esds(atom,covariance_matrix,esd)
      esd = sqrt(esd)

      ! Put the info
      atom.put_CIF_coords(.data.refine_H_U_iso,esd)
      atom.put_CIF_ADP2(.data.refine_H_U_iso,esd)
      atom.put_CIF_ADPn(cif,esd)

      ! Put bond & angle info
      if (atom(1).pos_axis_system=="cartesian") then
      ::put_CIF_bond_info_tables(atom,covariance_matrix)
      end

      ! Clean
      esd.destroy

      ! Put covariance matrix  
      if (cif.use_CIF2) then
      if (NOT stdout.name.includes(".archive.cif")) then
      if (atom(1).pos_axis_system=="cartesian") then
      if (.data.associated) then
      if (.data.reflections.associated) then
         .data.put_CIF_covariance_matrices(cif)
      end
      end
      end
      end
      end


      ! Put asymmetric covariance matrix in .arch.cif CIF1 format 
      if (.data.covariance_matrix.allocated) then
      if (stdout.name.includes(".archive.cif")) then
         DIFFRACTION_DATA:put_CIF_covariance_matrix("asym_unit",.data.covariance_matrix,FALSE)
      end
      end
      
      ! Put wavelength and other refl data
      if (.data.associated) then
      if (.data.reflections.associated) then
         thresh = .data.CIF_threshold_expression
         .data.reflections.put_CIF_refln_data(thresh)
      end
      end

      ! Put the reflection data
      if (.data.associated) then
      if (.data.reflections.associated) then
       ! .put_xd_fco
      end
      end

   end

   put_CIF_crystal_data ::: selfless, private
   ! Put placeholders forCIF crystal data
      self :: IN

      stdout.flush
      stdout.text("# =======")
      stdout.text("# Crystal")
      stdout.text("# =======")

      stdout.flush
      stdout.show("_exptl_crystal_description         ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_colour              ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_size_max            ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_size_mid            ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_size_min            ","?"     ,dots=FALSE)
      stdout.show("_exptl_crystal_density_diffrn      ","?"     ,dots=FALSE)

      stdout.flush
      stdout.text("# ==============")
      stdout.text("# Absortion data")
      stdout.text("# ==============")

      stdout.flush
      stdout.show("_exptl_absorpt_coefficient_mu      ","?"     ,dots=FALSE)
      stdout.show("_exptl_absorpt_correction_type     ","'none'",dots=FALSE)
      stdout.show("_exptl_absorpt_process_details     ","?"     ,dots=FALSE)
      stdout.show("_exptl_absorpt_correction_T_min    ","?"     ,dots=FALSE)
      stdout.show("_exptl_absorpt_correction_T_max    ","?"     ,dots=FALSE)

   end

   make_CIF_esds(atom,covariance_matrix,esd)
   ! Make the "esd"s in the pADPs for the "atom" list from the
   ! "covariance_matrix", required for the "cif" file output.  if
   ! "atom.axis_system" is "cartesian", only the diagonal covariances
   ! are extracted. For "crystal" axis system, positions are unitless
   ! and ADP's are in bohr^2, and anharmonic constants are
   ! dimensionless Gram-Charlier.
      self :: IN
      atom :: VEC{ATOM}, IN
      covariance_matrix :: MAT{REAL}, IN
      esd :: VEC{REAL}, OUT

   ENSURE(.data.associated,"no data")
   ENSURE(atom(1).pos_axis_system==atom(1).ADP_axis_system, "inconsistent pos and ADP axis systems")
   ENSURE(atom(1).pos_axis_system==atom(1).ADPn_axis_system,"inconsistent pos and ADPn axis systems")

      T,C :: MAT{REAL}*
      n_pADPs :: INT
      a,n, ab,af,al :: INT

      ! No of pADPs
      n_pADPs = atom.no_of_pADPs
      DIE_IF(esd.dim/=n_pADPs,"wrong size, esd")

      ! Get standard deviations and covariances
      ! ... in crystal coordinates
      C.create(n_pADPs,n_pADPs)
      C = ZERO

      ! The covariance matrix transformation matrix
      ! This is only applied to the diagonal blocks.
      T.create(34,34)
      T = ZERO
      if (atom(1).ADP_axis_system=="cartesian") then 
         ! Do nothing
         T.to_unit_matrix
      else                         
         ! Usual ADPs & dimensionless positions and (GC) anharmonics
         T(1:3,1:3) = .unit_cell.inverse_matrix ! Reset positional transform
         GAUSSIAN_DATA:symmetric_tensor_2_product_mx(T( 4: 9, 4: 9),.unit_cell.reciprocal_U_matrix)
         GAUSSIAN_DATA:symmetric_tensor_3_product_mx(T(10:19,10:19),.unit_cell.reciprocal_matrix)
         GAUSSIAN_DATA:symmetric_tensor_4_product_mx(T(20:34,20:34),.unit_cell.reciprocal_matrix)
      end

      do a = 1,atom.dim

         ! Block limits
         n  = atom(a).no_of_pADPs
         ab = atom.no_of_pADPs_up_to_atom(a)
         af = ab +  1
         al = ab + n

         ! Transform ...
         covariance_matrix(af:al,af:al).back_transform_to(C(af:al,af:al),T(1:n,1:n))

      end

      ! Get the esd's ... only diagonal (blocks) needed
      C.put_diagonal_to(esd)

      ! Clean
      C.destroy
      T.destroy

   end

   put_CIF_reflections(threshold)
   ! Put reflection information in CIF format *on an absolute scale*
      self :: IN
      threshold :: STR, IN

   ENSURE(.data.associated,"no diffraction data!")

      table :: VEC{TABLE_COLUMN}*
      h,k,l,g :: VEC{INT}@
      stl,d,fac :: VEC{REAL}@
      F_p :: VEC{CPX}@
      F_cr,F_ci,F_ph :: VEC{REAL}@
      F_pred,F_exp,F_sigma,F_z :: VEC{REAL}@
      n_refl :: INT

      lambda :: REAL
      thmax  :: REAL
    ! fcmax  :: REAL

      ! Constants
      n_refl = .data.reflections.dim

      stdout.flush
      stdout.text("# ================")
      stdout.text("# Diffraction data")
      stdout.text("# ================")

      lambda = REFLECTION:wavelength()
      lambda.convert_to("angstrom")

      stdout.flush
      stdout.show("_diffrn_radiation_type             ","?"                     ,dots=FALSE)
      stdout.show("_diffrn_radiation_wavelength       ",lambda                  ,dots=FALSE)

      stdout.flush
      stdout.show("_diffrn_measurement_method         ","?"                     ,dots=FALSE)
      stdout.show("_diffrn_measurement_device_type    ","?"                     ,dots=FALSE)

      thmax = maxval(abs(.data.reflections(:).theta))*DEGREE_PER_RADIAN

      stdout.flush
      stdout.show("_diffrn_reflns_number              ","?"                     ,dots=FALSE)
      stdout.show("_diffrn_reflns_theta_max           ",thmax                   ,dots=FALSE)

      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Reflections")
      stdout.text("# ===========")

      stdout.flush
      stdout.show("_reflns_d_resolution_high          ",.data.reflections(:).d_max*ANGSTROM_PER_BOHR,dots=FALSE)
      stdout.show("_reflns_d_resolution_low           ",.data.reflections(:).d_min*ANGSTROM_PER_BOHR,dots=FALSE)
      stdout.show("_reflns_limit_h_max                ",maxval(.data.reflections(:).h),dots=FALSE)
      stdout.show("_reflns_limit_h_min                ",minval(.data.reflections(:).h),dots=FALSE)
      stdout.show("_reflns_limit_k_max                ",maxval(.data.reflections(:).k),dots=FALSE)
      stdout.show("_reflns_limit_k_min                ",minval(.data.reflections(:).k),dots=FALSE)
      stdout.show("_reflns_limit_l_max                ",maxval(.data.reflections(:).l),dots=FALSE)
      stdout.show("_reflns_limit_l_min                ",minval(.data.reflections(:).l),dots=FALSE)
      stdout.show("_reflns_number_gt                  ",n_refl                   ,dots=FALSE)
      stdout.show("_reflns_number_total               ",n_refl                   ,dots=FALSE)
      stdout.show("_reflns_threshold_expression       ",threshold                ,dots=FALSE)

      stdout.flush
      stdout.text("_reflns_special_details            ")
      stdout.text(";")
      stdout.text("* Specify symmetry and Friedel pair averaging *")

      stdout.flush
      stdout.text(". Only.data reflections which satisfy the threshold expression")
      stdout.text("  are listed below, and only they are considered observed,")
      stdout.text("  thus the *_gt, *_all, & *_total data are always the same")
      stdout.text(";")

    ! fcmax = maxval(abs(.data.reflections(:).F_calc))
    ! stdout.flush
    ! stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _refln_index_h")
      stdout.text("    _refln_index_k")
      stdout.text("    _refln_index_l")
      stdout.text("    _refln_index_group")
      stdout.text("    _refln_stl")
      stdout.text("    _refln_d_spacing")
      stdout.text("    _refln_A_calc")
      stdout.text("    _refln_B_calc")
      stdout.text("    _refln_phase_calc")
      stdout.text("    _refln_F_calc")
      stdout.text("    _refln_F_meas")
      stdout.text("    _refln_F_sigma")
      stdout.text("    _refln_delta_F_on_sigma")

      ! Get data
      h       = .data.reflections(:).h
      k       = .data.reflections(:).k
      l       = .data.reflections(:).l
      g       = .data.reflections(:).group
      stl     = .data.reflections(:).stl*BOHR_PER_ANGSTROM
      d       = .data.reflections(:).d  *ANGSTROM_PER_BOHR
      allocate(F_p(n_refl))
      allocate(F_cr(n_refl))
      allocate(F_ci(n_refl))
      F_p     = .data.F_pred_complex
      F_ph    = REFLECTION:F_phase_angle_in_degrees(.data.reflections(:))
      F_exp   = .F_exp_scaled_corrected
      fac     = F_exp/.data.reflections.F_exp
      F_pred  = abs(F_p) * fac
      F_cr    = RE((F_p * fac))
      F_ci    = IM((F_p * fac))
      F_sigma = .data.reflections.F_sigma*fac
      F_z     = REFLECTION:F_z(.data.reflections(:))

      ! Make table
      table.create(13)
       table(1).set_values(h)
       table(2).set_values(k)
       table(3).set_values(l)
       table(4).set_values(g)
       table(5).set_values(stl)
       table(6).set_values(d)
       table(7).set_values(F_cr)
       table(8).set_values(F_ci)
       table(9).set_values(F_ph)
      table(10).set_values(F_pred)
      table(11).set_values(F_exp)
      table(12).set_values(F_sigma)
      table(13).set_values(F_z)

      ! Body
      table.put_body

      ! Clean
      table.clear_columns
      table.destroy

   end

! fcf files

   put_tonto_fcf
   ! Put a tonto fcf file with all the info and scaled so that
   ! Olex2 can make difference density maps.
      self :: IN

      thresh :: STR

      if (.data.disassociated)             return
      if (.data.reflections.disassociated) return

      thresh = .data.CIF_threshold_expression
      .put_CIF_reflections(thresh)

   end

   put_shelx_fcf5
   ! Put shelx fcf LIST=5 reflection file.
      self :: INOUT

      F000 :: REAL
      fcmax :: REAL
      F_corr :: VEC{REAL}@
      i :: INT

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      .unit_cell.put_CIF(.Z,cart=FALSE,har=FALSE)

      ! Put the reflection data
      if (.data.associated) then
      if (.data.reflections.associated) then

         F000 = .no_of_unit_cell_electrons

         stdout.flush
         stdout.text("# The value below is just the no. of unit cell electrons")
         stdout.flush
         stdout.show("_exptl_crystal_F_000               ",F000,dots=FALSE)
         stdout.flush

         stdout.text("# ===============")
         stdout.text("# Reflection data")
         stdout.text("# ===============")
   
         stdout.flush
         stdout.show("_reflns_d_resolution_high          ",.data.reflections.d_min*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_d_resolution_low           ",.data.reflections.d_max*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_limit_h_max                ",maxval(.data.reflections(:).h),dots=FALSE)
         stdout.show("_reflns_limit_h_min                ",minval(.data.reflections(:).h),dots=FALSE)
         stdout.show("_reflns_limit_k_max                ",maxval(.data.reflections(:).k),dots=FALSE)
         stdout.show("_reflns_limit_k_min                ",minval(.data.reflections(:).k),dots=FALSE)
         stdout.show("_reflns_limit_l_max                ",maxval(.data.reflections(:).l),dots=FALSE)
         stdout.show("_reflns_limit_l_min                ",minval(.data.reflections(:).l),dots=FALSE)

         if (.data.scale_factors.disassociated) then
         fcmax = .data.scale_factor
         stdout.flush
         stdout.show("_tonto_F_scale_factor              ",fcmax,dots=FALSE)
         end
   
         fcmax = maxval(.data.reflections.F_calc_abs)

         stdout.flush
         stdout.show("_shelx_refln_list_code             ", 5,dots=FALSE)
         stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)
   
         F_corr = .F_exp_scaled_corrected
   
         stdout.flush
         stdout.text("loop_")
         stdout.text("    _refln_index_h")
         stdout.text("    _refln_index_k")
         stdout.text("    _refln_index_l")
         stdout.text("    _refln_F_meas")
         stdout.text("    _refln_F_calc")
         stdout.text("    _refln_phase_calc")
   
         do i = 1,.data.reflections.dim
            stdout.put(.data.reflections(i).h,width=4)
            stdout.put(.data.reflections(i).k,width=4)
            stdout.put(.data.reflections(i).l,width=4)
            stdout.put(F_corr(i),                              width=10,precision=2)
            stdout.put(.data.reflections(i).F_calc_abs,        width=10,precision=2)
            stdout.put(.data.reflections(i).F_phase_angle_in_degrees,width= 7,precision=2)
            stdout.flush
         end

      end
      end

   end

   put_shelx_fcf6
   ! Put shelx fcf LIST=6 reflection file
      self :: INOUT

      F000 :: REAL
      fcmax :: REAL
      F2_cor,factor :: VEC{REAL}@
      i :: INT

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      .unit_cell.put_CIF(.Z,cart=FALSE,har=FALSE)

      ! Put the reflection data
      if (.data.associated) then
      if (.data.reflections.associated) then

         F000 = .no_of_unit_cell_electrons

         stdout.flush
         stdout.text("# The value below is just the no. of unit cell electrons")
         stdout.flush
         stdout.show("_exptl_crystal_F_000               ",F000,dots=FALSE)
         stdout.flush
   
         stdout.flush
         stdout.text("# ===============")
         stdout.text("# Reflection data")
         stdout.text("# ===============")
   
         stdout.flush
         stdout.show("_reflns_d_resolution_high          ",.data.reflections.d_max*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_d_resolution_low           ",.data.reflections.d_min*ANGSTROM_PER_BOHR,dots=FALSE)
         stdout.show("_reflns_limit_h_max                ",maxval(.data.reflections(:).h),dots=FALSE)
         stdout.show("_reflns_limit_h_min                ",minval(.data.reflections(:).h),dots=FALSE)
         stdout.show("_reflns_limit_k_max                ",maxval(.data.reflections(:).k),dots=FALSE)
         stdout.show("_reflns_limit_k_min                ",minval(.data.reflections(:).k),dots=FALSE)
         stdout.show("_reflns_limit_l_max                ",maxval(.data.reflections(:).l),dots=FALSE)
         stdout.show("_reflns_limit_l_min                ",minval(.data.reflections(:).l),dots=FALSE)

         if (.data.scale_factors.disassociated) then
         fcmax = .data.scale_factor
         fcmax = fcmax*fcmax
         stdout.flush
         stdout.show("_tonto_F2_scale_factor             ",fcmax,dots=FALSE)
         end
   
         fcmax = maxval(.data.reflections.F_calc_abs)
   
         stdout.flush
         stdout.show("_shelx_refln_list_code             ", 6,dots=FALSE)
         stdout.show("_shelx_F_calc_maximum              ", fcmax,dots=FALSE)
   
         stdout.flush
         stdout.text("loop_")
         stdout.text("    _refln_index_h")
         stdout.text("    _refln_index_k")
         stdout.text("    _refln_index_l")
         stdout.text("    _refln_F_squared_meas")
         stdout.text("    _refln_F_squared_sigma")
         stdout.text("    _refln_F_squared_calc")
         stdout.text("    _refln_phase_calc")
   
         F2_cor = .F2_exp_scaled_corrected
         factor = F2_cor/.F2_exp
   
         do i = 1,.data.reflections.dim
            stdout.put(.data.reflections(i).h,width=4)
            stdout.put(.data.reflections(i).k,width=4)
            stdout.put(.data.reflections(i).l,width=4)
            stdout.put(F2_cor(i))
            stdout.put(.data.reflections(i).F2_sigma*factor(i))
            stdout.put(.data.reflections(i).F2_calc_abs       )
            stdout.put(.data.reflections(i).F_phase_angle_in_degrees)
            stdout.flush
         end

      end
      end

   end

! XD fco file

   put_xd_fco
   ! Put XD fco reflection file
      self :: INOUT

      F000,F2_cal,F2_exp,F2_sig,factor :: REAL
      F_p :: VEC{CPX}@
      F_exp :: VEC{REAL}@
      d_max,d_min :: REAL
      h_max,h_min :: VEC{INT}(3)
      ref :: REFLECTION
      i,n_refl :: INT

      !Get Number of reflections
      n_refl = .data.reflections.dim

      ! Spacegroup information
      .spacegroup.put_CIF

      ! Unit cell information; INOUT
      .unit_cell.put_CIF(.Z,cart=FALSE,har=FALSE)

      ! Put the reflection data
      if (.data.associated) then
      if (.data.reflections.associated) then

         F000 = .no_of_unit_cell_electrons
         F000 = F000*F000

         stdout.flush
         stdout.show("_exptl_crystal_F_squared_000        ",F000,dots=FALSE)
         stdout.flush

        
         stdout.flush
         stdout.text("# ======================")
         stdout.text("# XD fco reflection data")
         stdout.text("# ======================")
        
         stdout.flush
         stdout.text("# . checkCIF also accepts this as fcf format")
        
         stdout.flush
         stdout.show("_shelx_refln_list_code             ", 6,dots=FALSE)
         stdout.flush

         d_max = .data.reflections.d_max*ANGSTROM_PER_BOHR
         d_min = .data.reflections.d_min*ANGSTROM_PER_BOHR
         stdout.show("_reflns_d_resolution_high          ",d_max   ,dots=FALSE)
         stdout.show("_reflns_d_resolution_low           ",d_min   ,dots=FALSE)

         h_max = .data.reflections.h_max
         h_min = .data.reflections.h_min
         stdout.show("_reflns_limit_h_max                ",h_max(1),dots=FALSE)
         stdout.show("_reflns_limit_h_min                ",h_min(1),dots=FALSE)
         stdout.show("_reflns_limit_k_max                ",h_max(2),dots=FALSE)
         stdout.show("_reflns_limit_k_min                ",h_min(2),dots=FALSE)
         stdout.show("_reflns_limit_l_max                ",h_max(3),dots=FALSE)
         stdout.show("_reflns_limit_l_min                ",h_min(3),dots=FALSE)
        
         stdout.flush
         stdout.text("# NOTE: F_squared_meas is scaled to F_squared_calc")
         stdout.text("#       and so it is on an absolute scale")
         if (NOT .data.use_multiple_scale_factors) then
         stdout.show("_reflns_tonto_F_scale_factor       ",.data.scale_factor      ,dots=FALSE)
         end
        
        
         stdout.flush
         stdout.text("loop_")
         stdout.text("    _refln_index_h")
         stdout.text("    _refln_index_k")
         stdout.text("    _refln_index_l")
         stdout.text("    _refln_F_squared_calc")
         stdout.text("    _refln_F_squared_meas")
         stdout.text("    _refln_F_squared_sigma")
         stdout.text("    _refln_observed_status")

         F_exp = .data.F_exp_on_absolute_scale
         allocate(F_p(n_refl))
         F_p   = .data.F_pred_complex 
        
         do i = 1,.data.reflections.dim

            ! The reflection
            ref = .data.reflections(i)

            ! The numbers
!           F2_cal = ref.F2_calc_abs
            F2_exp = F_exp(i)*F_exp(i)
            factor = F_exp(i)/ref.F_exp ! scale factor
            F2_sig = factor * F_exp(i) * ref.F_sigma * TWO ! Lorraine, CHECK !!!!
            F_p(i) = F_p(i) * factor
            F2_cal = RE(F_p(i)) * RE(F_p(i)) + IM(F_p(i)) * IM(F_p(i)) 

            if(IO_IS_ALLOWED) then
               write(stdout.unit,"(3i4,2f12.2,1f10.2,1x,a1)") &
                  ref.h,ref.k,ref.l,F2_cal,F2_exp,F2_sig,"o"
            end if

         end

      end
      end

   end

 

   put_NKA_cartesian
   ! Put out the NKA information in cartesian coordinates
      self :: IN

   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom list")

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.data.NKA_T_sequence_no,width=3)
      stdout.put(.data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Coordinate information
      .asymmetric_unit_atom.put_NKA_with_errors(.data.NKA_T_sequence_no)

   end

   put_excel_crystal
   ! Put out the coordinate and ADP information in Excel format
      self :: INOUT

   ENSURE(.data.associated,"no diffraction data")
   ENSURE(.data.covariance_matrix.allocated,"no covariance_matrix")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_unit_atom list")

      esd :: VEC{REAL}*
      n_pADPs :: INT

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.data.NKA_T_sequence_no,width=3)
      stdout.put(.data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Get errors in crystal coordinates
      n_pADPs = .asymmetric_unit_atom.no_of_pADPs
      esd.create(n_pADPs)
      .make_CIF_esds(.asymmetric_unit_atom,.data.covariance_matrix,esd)
      esd = sqrt(esd)

      ! Change axis system to crystal
      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell,FALSE)

      ! Dump the data
      .asymmetric_unit_atom.put_excel_with_errors(esd,.data.temperature)

      ! Change axes back to cartesian
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Clean up
      esd.destroy

   end

   put_uc_connection_table
   ! Put the .unit_cell_connection table
      self :: IN

   ENSURE(.unit_cell_connection.associated,"no unit_cell_connection")
   ENSURE(.unit_cell_mol_for_atom.associated,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Unit cell atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)

         first = TRUE
         do a = 1,.unit_cell_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.unit_cell_connection(a).element.dim==0) then

               stdout.flush

            else

               do i = 1,.unit_cell_connection(a).element.dim

                  if (i>1) &
                  stdout.tab(int_fields=2)

                  b = .unit_cell_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.unit_cell_connection(a)[i][1])
                  stdout.put(.unit_cell_connection(a)[i][2])
                  stdout.put(.unit_cell_connection(a)[i][3])
                  stdout.flush

               end

            end
         end
      end

      stdout.dash(int_fields=6)

   end

   put_uc_vdw_connection_table
   ! Put the .unit_cell_connection table
      self :: IN

   ENSURE(.uc_vdw_connection.associated,"no uc_vdw_connection")
   ENSURE(.unit_cell_mol_for_atom.associated,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Cell VDW atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)

         first = TRUE
         do a = 1,.uc_vdw_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.uc_vdw_connection(a).element.dim==0) then

               stdout.flush

            else

               do i = 1,.uc_vdw_connection(a).element.dim

                  if (i>1) &
                  stdout.tab(int_fields=2)

                  b = .uc_vdw_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.uc_vdw_connection(a)[i][1])
                  stdout.put(.uc_vdw_connection(a)[i][2])
                  stdout.put(.uc_vdw_connection(a)[i][3])
                  stdout.flush

               end

            end
         end
      end

      stdout.dash(int_fields=6)

   end

!  ================================
!  Put Fragment related information
!  ================================

   put_fragment_data ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      self :: IN

      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Crystal fragment")
      stdout.text("================")
      stdout.flush
      stdout.text(". Ab initio calculations are performed on the fragment")
      stdout.text("  to obtain structure factors, charges, etc.")
      stdout.flush
      stdout.text(". The fragment need not be an asymmetric unit.")
      stdout.flush
      stdout.text(". Repeated atoms are assigned a 'repetition factor' which")
      stdout.text("  is used to scale the structure factor contribution from")
      stdout.text("  that atom. You can manually reset this.")
      stdout.flush
      stdout.text(". Only the unique atoms in the fragment have their ")
      stdout.text("  positions and ADPs refined.")
      stdout.flush
      stdout.text(". The Z factor for the crystal is defined with respect to")
      stdout.text("  the no. of electrons in the fragment")

      stdout.flush
      stdout.flush
      stdout.show("No. of fragment atoms        =",.n_fragment_atoms)
      stdout.show("No. of unique fragment atoms =",.n_unique_frag_atoms)
      stdout.show("Z factor                     =",.Z)

      if (.partition_model/=" " OR .thermal_smearing_model/=" ") then
      stdout.flush
      stdout.show("Fragment partition model     =",.partition_model)
      stdout.show("Thermal smearing model       =",.thermal_smearing_model)
      end

      .put_fragment_geometry
      .put_stabilizer_symops

   end

   put_stabilizer_symops ::: private
   ! Put out the stabilizer symop data
      self :: IN

   ENSURE(.stabilizer_symop.associated,"no stabilizer_symop")

      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.text("=========================")
      stdout.text("Crystal stabilizer symops")
      stdout.text("=========================")
      stdout.flush
      stdout.text(". The stablizer is the subgroup of symops which")
      stdout.text("  map the fragment_geometry into itself.")
      stdout.flush
      stdout.show("n_stabilizer_symops =",.n_stabilizer_symops)
      stdout.flush

      ! Table
      table.create(1)
      table(1).set_heading("Stablizer")
      table(1).set_subhead("symops")
      table(1).set_values(.stabilizer_symop(:))
      table.put

      ! Clean
      table.clear_columns
      table.destroy

   end

   put_fragment_geometry ::: private
   ! Put out the fragment_geometry information
      self :: IN

   ENSURE(.fragment_info_made,"no fragment info")

      ID :: VEC{STR}*
      as4f,sy4f,un4f,ui4f,rf,ssym :: VEC{INT}*
      sh4f :: MAT{REAL}*
      table :: VEC{TABLE_COLUMN}*
      f :: INT

      stdout.flush
      stdout.flush
      stdout.text("QM fragment geometry:")
      stdout.flush

      ! Data
      f = 1
      as4f => .asym_atom_for_frag_atom
      sy4f => .asym_symop_for_frag_atom
      sh4f => .asym_shift_for_frag_atom
      ID   => .fragment_atom.unique_tags
      ui4f => .unique_index_for_frag_atom
      un4f => .unique_atom_for_frag_atom
      rf.create(.n_fragment_atoms)
      rf = int(.repetition_factor)
      ssym => .frag_atom_sym_factor

      ! Table
      table.create(13)

      table( 1).set_heading("ID");     table(1).set_values(ID)

      table( 2).set_spacing(2)
      table( 2).set_heading("Rep");    table(2).set_values(rf)
      table( 2).set_subhead("fac")
      table( 2).set_sb3head("tor")

      table( 3).set_spacing(2)
      table( 3).set_heading("Site");   table(3).set_values(ssym)
      table( 3).set_subhead("symm")
      table( 3).set_sb3head("fact")

      table( 4).set_spacing(2)
      table( 4).set_heading("Uniq");   table(4).set_values(ui4f)
      table( 4).set_subhead("atom")

      table( 5).set_spacing(3)
      table( 5).set_heading("Uniq");   table(5).set_values(un4f)
      table( 5).set_subhead("atom")
      table( 5).set_sb3head("ID")

      table( 7).set_heading("Coord")
      table( 6).set_subhead("- x -");  table(6).set_values(.fragment_geometry(1,:))
      table( 7).set_subhead("- y -");  table(7).set_values(.fragment_geometry(2,:))
      table( 8).set_subhead("- z -");  table(8).set_values(.fragment_geometry(3,:))
      table( 7).set_sb3head("/frac")

      table( 9).set_heading("From");   table(9).set_values(as4f)
      table( 9).set_subhead("asym")
      table( 9).set_sb3head("atom")

      table(10).set_spacing(2)
      table(10).set_heading("Using");  table(10).set_values(sy4f)
      table(10).set_subhead("symop")

      table(11).set_spacing(2)
      table(11).set_real_precision(1)
      table(11).set_heading("     ");  table(11).set_values(sh4f(1,:))
      table(11).set_subhead("- x -")
      table(12).set_spacing(2)
      table(12).set_real_precision(1)
      table(12).set_heading("Shift");  table(12).set_values(sh4f(2,:))
      table(12).set_subhead("- y -")
      table(13).set_spacing(2)
      table(13).set_real_precision(1)
      table(13).set_heading("     ");  table(13).set_values(sh4f(3,:))
      table(13).set_subhead("- z -")
      table(12).set_sb3head("/frac")

      table.put

      ! Clean
      table.clear_columns
      table.destroy
      rf.destroy
      ID.destroy

   end

!   put_fragment_geometry_small ::: private
!   ! Put out the fragment_geometry information
!
!      ID :: VEC{STR}*
!      table :: VEC{TABLE_COLUMN}*
!
!      stdout.flush
!      stdout.flush
!      stdout.text("Fragment geometry:")
!      stdout.flush
!
!      ! Data
!      ID   => .fragment_atom.unique_tags
!
!      ! Table
!      table.create(4)
!
!      table( 1).set_heading("frag");    table(1).set_values(ID)
!      table( 1).set_subhead("ID")
!
!      table( 2).set_heading("x");       table(2).set_values(.fragment_geometry(1,:))
!      table( 3).set_heading("y");       table(3).set_values(.fragment_geometry(2,:))
!      table( 4).set_heading("z");       table(4).set_values(.fragment_geometry(3,:))
!      table( 3).set_sb3head("/frac")
!
!      table.put
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!      ID.destroy
!
!   end

!  ==================================
!  Put reflection related information
!  ==================================

   put_data_analysis(output)
   ! Put out analysis data for the reflections after a fit/refinement
      self :: INOUT
      output :: BIN, optional, IN

   ENSURE(.data.associated,"no diffraction data")

      show :: BIN

      show = TRUE
      if (present(output)) show = output

      if (NOT show) return

      .data.put_GOF_vs_STL_table
      .data.put_GOF_vs_F_exp_table

      .data.put_N_worst_reflections

      .put_fitting_plots

   end


   put_reflection_data
   ! Put out the reflection data to file "out".  Both Neutron and
   ! X-ray will be put if present.
      self :: IN

      .put_X_reflection_data
      .put_N_reflection_data

   end

   put_X_reflection_data
   ! Put out the X-ray reflection data.
      self :: IN

      if (.xray_data.associated) then
      if (.xray_data.reflections.associated) then
         .xray_data.put_reflections
      end
      end

      if (.xray_r_free_data.associated) then
      if (.xray_r_free_data.reflections.associated) then
         .xray_r_free_data.put_reflections
      end
      end

   end

   put_N_reflection_data
   ! Put out the PND reflection data
      self :: IN

      if (.pnd_data.associated) then
      if (.pnd_data.reflections.associated) then
         .pnd_data.put_reflections
      end
      end

   end

   put_all_reflection_data
   ! Put out all the X-ray reflection data.
      self :: IN

      if (.xray_data.associated) then
      if (.xray_data.reflections.associated) then
         .xray_data.reflections.put_F_all_data
      end
      end

      if (.xray_r_free_data.associated) then
      if (.xray_r_free_data.reflections.associated) then
         .xray_r_free_data.reflections.put_F_all_data
      end
      end

   end


   put_reflection_intensities
   ! Put out the reflection data to file "out".  Both Neutron and
   ! X-ray will be put if present.
      self :: IN

      .put_X_reflection_intensities

   end

   put_X_reflection_intensities
   ! Put out the X-ray reflection data.
      self :: IN

      if (.xray_data.associated) then
      if (.xray_data.reflections.associated) then
         .xray_data.put_reflection_intensities
      end
      end

      if (.xray_r_free_data.associated) then
      if (.xray_r_free_data.reflections.associated) then
         .xray_r_free_data.put_reflection_intensities
      end
      end

   end

   put_reflection_intensities_XD
   ! Put out the reflection data to file "out".  Both Neutron and
   ! X-ray will be put if present.
      self :: IN

      .put_X_reflection_intensities_XD

   end

   put_X_reflection_intensities_XD
   ! Put out the X-ray reflection data.
      self :: IN

      if (.xray_data.associated) then
      if (.xray_data.reflections.associated) then
         .xray_data.put_reflection_intensities_XD
      end
      end

      if (.xray_r_free_data.associated) then
      if (.xray_r_free_data.reflections.associated) then
         .xray_r_free_data.put_reflection_intensities_XD
      end
      end

   end


   put_PND_sf(name)
   ! outputs the polarised neutron structure factors
      self :: IN
      name :: STR, IN

   ENSURE(.data_exists, "no diffraction data")

      .data.put_PND_sf(name)

   end


   put_correction_data
   ! Output the correction data
      self :: IN

   ENSURE(.data_exists, "no diffraction data")

      .data.put_correction_data

      if (.asymmetric_unit_atom.has_any_ADP3s_and_errors) then
      stdout.flush
      stdout.show("Using ADP3's?                  =",TRUE)
      if (.asymmetric_unit_atom.has_any_ADP4s_and_errors) then
      stdout.show("Using ADP4's?                  =",TRUE)
      end
      end

   end

   put_F_statistics
   ! Output the structure factor statistics
      self :: IN

   ENSURE(.data_exists, "no diffraction data")

      .data.put_F_statistics

   end

!  ================
!  Crystal Explorer
!  ================

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
      self :: INOUT

      label,formula,spacegroup :: STR

      .unit_cell.put_CX(label,formula,spacegroup)

   end

!  ==================
!  Put plots and maps
!  ==================

   put_fitting_plots
   ! Output all the fitting plot information to "stdout.fit_analysis"
      self :: INOUT

   DIE_IF(.data.disassociated,"no reflection data")

      ! Fit analysis
      stdout.flush
      stdout.text("==================================")
      stdout.text("Analysis of the Hirshfeld atom fit")
      stdout.text("==================================")
      stdout.flush
      stdout.text("An analysis of the fit is deposited in 'stdout.fit_analysis'.")
      stdout.flush
      stdout.text("This large file includes:")
      stdout.text(". A normal QQ plot with each datum labelled by (hkl)")
      stdout.text(". A plot of F_z = (F_exp-F_pred)/F_sigma vs sin(theta)/lambda :")
      stdout.text(". A plot of F_z = (F_exp-F_pred)/F_sigma vs F_exp")
      stdout.text(". A plot of Delta F = (F_exp-F_pred) vs sin(theta)/lambda :")
      stdout.flush
      stdout.text("If you used an extinction correction, you also get:")
      stdout.text(". A plot of (F_pred(no ext)-F_pred(ext))/F_sigma vs. sin (theta/lambda)")
      stdout.text(". A plot of (F_pred(no ext)-F_pred(ext))/F_sigma vs. F_pred")
      stdout.flush
      stdout.text("All of the above plots are available for the reserved (free) data")
      stdout.text("if you made use of that option. Phew.")
      stdout.flush
      stdout.text("Use Excel or gnuplot to view these data. Do it.")

    ! stdout.flush
    ! lambda = .data.wavelength.to_units("angstrom")
    ! stdout.show("X-ray wavelength (Angstrom) = ",lambda)
    ! stdout.flush

      ! Data analysis
      if (.data.associated) then

      !  stdout.flush
      !  stdout.text("====================================")
      !  stdout.text("Plots based on data used for fitting")
      !  stdout.text("====================================")

      !  .put_GOF_vs_STL_plot(.data)
      !  .put_GOF_vs_F_exp_plot(.data)
      !  .put_ratio_vs_STL_plot(.data)
      !  .put_ratio_vs_F_exp_plot(.data)
      !  .put_qq_plot(.data)
         .put_labelled_qq_plot(.data)
         .put_fcalc_plots(.data)

      end

      ! Reserved data analysis
      if (.xray_r_free_data.associated) then

      !  stdout.flush
      !  stdout.text("===================================")
      !  stdout.text("Plots based on free (reserved) data")
      !  stdout.text("===================================")

      !  .put_GOF_vs_STL_plot(.data)
      !  .put_GOF_vs_F_exp_plot(.data)
      !  .put_ratio_vs_STL_plot(.data)
      !  .put_ratio_vs_F_exp_plot(.data)
      !  .put_qq_plot(.data)
         .put_labelled_qq_plot(.data,"free")
         .put_fcalc_plots(.data,"free")

      end

   end

   put_GOF_vs_STL_plot(data)
   ! Output the GOF vs. sin(theta)/angle bins
      self :: INOUT
      data :: DIFFRACTION_DATA*

   ENSURE(data.associated, "no diffraction data")

      if (FALSE) self = self
      data.put_GOF_vs_STL_plot

   end

   put_GOF_vs_F_exp_plot(data)
   ! Output the GOF vs. F_pred bins
      self :: INOUT
      data :: DIFFRACTION_DATA*

   ENSURE(data.associated, "no diffraction data")

      if (FALSE) self = self
      data.put_GOF_vs_F_exp_plot

   end

   put_ratio_vs_STL_plot(data)
   ! Output the mean ratio F_obs/F_pred vs. sin(theta)/angle bins
      self :: INOUT
      data :: DIFFRACTION_DATA*

   ENSURE(data.associated, "no diffraction data")

      if (FALSE) self = self
      data.put_ratio_vs_STL_plot

   end

   put_ratio_vs_F_exp_plot(data)
   ! Output the GOF vs. F_pred bins
      self :: INOUT
      data :: DIFFRACTION_DATA*

   ENSURE(data.associated, "no diffraction data")

      if (FALSE) self = self
      data.put_ratio_vs_F_exp_plot

   end

!   put_qq_plot(data)
!   ! Output a qq plot to the text file.
!   ! It is a plot of the experimental quantile vs expected quantile.
!      self :: INOUT
!      data :: DIFFRACTION_DATA*
!
!   ENSURE(data.associated, "no diffraction data")
!
!      if (FALSE) self = self
!
!      data.put_qq_plot
!
!   end

   put_labelled_qq_plot(data,tag)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
      self :: INOUT
      data :: DIFFRACTION_DATA*
      tag :: STR, optional, IN

   ENSURE(data.associated, "no diffraction data")

      if (FALSE) self = self

      data.put_labelled_qq_plot(tag)

   end

   put_fcalc_plots(data,tag)
   ! Output some different plots about the calculated structure factors.
      self :: INOUT
      data :: DIFFRACTION_DATA*
      tag :: STR, optional, IN

   ENSURE(data.associated, "no diffraction data")

      if (FALSE) self = self

      data.put_fcalc_plots(tag)

   end


!  ====================
!  Residual density map
!  ====================

   make_residual_density_map(map,pts)
   ! Make the crystal residual error "map" for the supplied points "pts" from
   ! the crystal structure factors.
      self :: IN
      map :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(.data.associated, "no diffraction data")
   ENSURE(.data.reflections.associated, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_pred, "no predicted structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")
   ENSURE(pts.dim2==3,  "incorrect dimension for points array")

      k  :: MAT{REAL}*
      dF :: VEC{CPX}*
      fac,res,kp,p1,p2,p3,k1,k2,k3 :: REAL
      ci  :: CPX
      n_refl,n,r :: INT

      ! Constants
      n_refl = .data.reflections.dim
      ci = IMAGIFY(ONE)

      ! K points
      k.create(n_refl,3)
      .data.reflections.make_k_pts(k,.unit_cell)

      ! Get phased structure factor differences
      ! (without extinction, but with scale correction)
      dF.create(n_refl)
      .data.make_phased_dF_a(dF)

      ! Prefactor
      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
      fac = TWO/.unit_cell.volume

      ! Calculate residual map
      map = ZERO

      parallel do n = 1,pts.dim1

         p1 = pts(n,1)
         p2 = pts(n,2)
         p3 = pts(n,3)

         res = ZERO

         do r = 1,n_refl

            k1  = k(r,1)
            k2  = k(r,2)
            k3  = k(r,3)

            kp  = k1*p1 + k2*p2 + k3*p3
            res = res + REALIFY(dF(r)*exp(ci*kp))

         end

         map(n) = fac*res

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(map)
      end

      ! Clean
      dF.destroy
      k.destroy

   end

   make_residual_density_cell(map,nx,ny,nz)
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version need to gather the 1D phases over miller indices.
      self :: IN
      map :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

      ! This version seems fastest
      .make_residual_density_cell_n(map,nx,ny,nz)

   end

   make_residual_density_cell_c(map)
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version uses a cube of structure factors.
      self :: IN
      map :: MAT3{REAL}, OUT

   ENSURE(.data.associated, "no diffraction data")
   ENSURE(.data.reflections.associated, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_pred, "no predicted structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")

      n_refl :: INT
      nx,ny,nz :: INT
      hx,hy,hz :: INT
      ix,iy,iz :: INT
      xi,yi,zi :: REAL
      fac,del  :: REAL
      phx,phy,phz :: MAT{CPX}*
      h_min,h_max :: VEC{INT}(3)
      dF :: MAT3{CPX}*
      ci :: CPX

      ! Constants
      nx = map.dim1
      ny = map.dim2
      nz = map.dim3
      n_refl = .data.reflections.dim
      ci     = -2*PI * IMAGIFY(ONE)

      ! Maximum Miller indices
      h_min = .data.reflections.h_min
      h_max = .data.reflections.h_max

      ! Get phased structure factor differences
      ! (without extinction, but with scale correction)
      dF.create(h_min,h_max)
      .data.make_phased_dF_b(dF)

      ! Prefactor
      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
      fac = TWO/.unit_cell.volume

      ! Make the 1D x phases
      phx.create([h_min(1),h_max(1)],[1,nx])
      del = ONE/(nx-1)
      do ix = 1,nx
      do hx = h_min(1),h_max(1)
         xi = (ix-1) * del
         phx(hx,ix) = exp(ci*hx*xi)
      end
      end

      ! Make the 1D y phases
      phy.create([h_min(2),h_max(2)],[1,ny])
      del = ONE/(ny-1)
      do iy = 1,ny
      do hy = h_min(2),h_max(2)
         yi = (iy-1) * del
         phy(hy,iy) = exp(ci*hy*yi)
      end
      end

      ! Make the 1D z phases
      phz.create([h_min(3),h_max(3)],[1,nz])
      del = ONE/(nz-1)
      do iz = 1,nz
      do hz = h_min(3),h_max(3)
         zi = (iz-1) * del
         phz(hz,iz) = exp(ci*hz*zi) * fac ! <--
      end
      end

      ! Do it
      dF.change_basis_to(map,phx,phy,phz)

      ! Clean
      phx.destroy
      phy.destroy
      phz.destroy
      dF.destroy

   end

   make_residual_density_cell_g(map,nx,ny,nz)
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version need to gather the 1D phases over miller indices.
      self :: IN
      map :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

   ENSURE(.data.associated, "no diffraction data")
   ENSURE(.data.reflections.associated, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_pred, "no predicted structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")

      n_refl,r,p :: INT
      hx,hy,hz :: INT
      ix,iy,iz :: INT
      xi,yi,zi :: REAL
      fac,del,res :: REAL
      phx,phy,phz :: MAT{CPX}*
      h_max :: VEC{INT}(3)
      dF :: VEC{CPX}*
      ci :: CPX

      ! Constants
      n_refl = .data.reflections.dim
      ci     = -2*PI * IMAGIFY(ONE)

      ! Maximum Miller indices
      h_max = .data.reflections.h_max

      ! Get phased structure factor differences
      ! (without extinction, but with scale correction)
      dF.create(n_refl)
      .data.make_phased_dF_a(dF)

      ! Prefactor
      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
      fac = TWO/.unit_cell.volume

      ! Make the 1D x phases
      phx.create([1,nx],[0,h_max(1)])
      del = ONE/(nx-1)
      do hx = 0,h_max(1)
      do ix = 1,nx
         xi = (ix-1) * del
         phx(ix,hx) = exp(ci*hx*xi)
      end
      end

      ! Make the 1D y phases
      phy.create([1,ny],[0,h_max(2)])
      del = ONE/(ny-1)
      do hy = 0,h_max(2)
      do iy = 1,ny
         yi = (iy-1) * del
         phy(iy,hy) = exp(ci*hy*yi)
      end
      end

      ! Make the 1D z phases
      phz.create([1,nz],[0,h_max(3)])
      del = ONE/(nz-1)
      do hz = 0,h_max(3)
      do iz = 1,nz
         zi = (iz-1) * del
         phz(iz,hz) = exp(ci*hz*zi)
      end
      end


      ! Grid point
      p = 0

      ! Make the residual map
      do iz = 1,nz
      do iy = 1,ny
      do ix = 1,nx

         p = p + 1

         res = ZERO
         do r = 3,n_refl
            hx = .data.reflections(r).h
            hy = .data.reflections(r).k
            hz = .data.reflections(r).l
            res = res + REALIFY(dF(r)*phx(ix,hx)*phy(iy,hy)*phz(iz,hz))
         end

         map(p) = fac*res

      end
      end
      end

      ! Clean
      phx.destroy
      phy.destroy
      phz.destroy
      dF.destroy

   end

   make_residual_density_cell_n(map,nx,ny,nz)
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version uses more memory for the 1D phase arrays.
      self :: IN
      map :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

   ENSURE(.data.associated, "no diffraction data")
   ENSURE(.data.reflections.associated, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_pred, "no predicted structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")

      n_refl,r,p :: INT
      hx,hy,hz :: VEC{INT}*
      ix,iy,iz :: INT
      xi,yi,zi :: REAL
      fac,del  :: REAL
      dF :: VEC{CPX}*
      phx,phy,phz :: MAT{CPX}*
      h_max :: VEC{INT}(3)
      ci :: CPX

      ! Constants
      n_refl = .data.reflections.dim
      ci     = -2*PI * IMAGIFY(ONE)

      ! Maximum Miller indices
      h_max = .data.reflections.h_max

      ! Get phased structure factor differences
      ! (without extinction, but with scale correction)
      dF.create(n_refl)
      .data.make_phased_dF_a(dF)

      ! Prefactor
      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
      fac = TWO/.unit_cell.volume
      dF  = fac * dF

      ! Get h's
      hx.create(n_refl)
      hy.create(n_refl)
      hz.create(n_refl)

      hx = .data.reflections(:).h
      hy = .data.reflections(:).k
      hz = .data.reflections(:).l

      ! Make the 1D x phases
      phx.create(n_refl,nx)
      del = ONE/(nx-1)
      do ix = 1,nx
         xi = (ix-1) * del
         do r = 1,n_refl
            phx(r,ix) = exp(ci*hx(r)*xi)
         end
      end

      ! Make the 1D y phases
      phy.create(n_refl,ny)
      del = ONE/(ny-1)
      do iy = 1,ny
         yi = (iy-1) * del
         do r = 1,n_refl
            phy(r,iy) = exp(ci*hy(r)*yi)
         end
      end

      ! Make the 1D z phases
      phz.create(n_refl,nz)
      del = ONE/(nz-1)
      do iz = 1,nz
         zi = (iz-1) * del
         do r = 1,n_refl
            phz(r,iz) = exp(ci*hz(r)*zi) * dF(r) ! <--
         end
      end


      ! Grid point
      p = 0

      ! Make the residual map
      do iz = 1,nz
      do iy = 1,ny
      do ix = 1,nx
      
         p = p + 1
         map(p) = sum( REALIFY(phx(:,ix)*phy(:,iy)*phz(:,iz)) )
      
      end
      end
      end

      ! Clean
      phz.destroy
      phy.destroy
      phx.destroy
      hz.destroy
      hy.destroy
      hx.destroy
      dF.destroy

   end

   make_residual_density_cell_m(map,nx,ny,nz)
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version uses more memory for the 1D phase arrays.
      self :: IN
      map :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

   ENSURE(.data.associated, "no diffraction data")
   ENSURE(.data.reflections.associated, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_pred, "no predicted structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")

      n_refl,r,p :: INT
      hx,hy,hz :: VEC{INT}*
      ix,iy,iz :: INT
      xi,yi,zi :: REAL
      fac,del  :: REAL
      dF, phyz :: VEC{CPX}*
      phx,phy,phz :: MAT{CPX}*
      h_max :: VEC{INT}(3)
      ci :: CPX

      ! Constants
      n_refl = .data.reflections.dim
      ci     = -2*PI * IMAGIFY(ONE)

      ! Maximum Miller indices
      h_max = .data.reflections.h_max

      ! Get phased structure factor differences
      ! (without extinction, but with scale correction)
      dF.create(n_refl)
      .data.make_phased_dF_a(dF)

      ! Prefactor
      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
      fac = TWO/.unit_cell.volume
      dF  = fac * dF

      ! Get h's
      hx.create(n_refl)
      hy.create(n_refl)
      hz.create(n_refl)

      hx = .data.reflections(:).h
      hy = .data.reflections(:).k
      hz = .data.reflections(:).l

      ! Make the 1D x phases
      phx.create(n_refl,nx)
      del = ONE/(nx-1)
      do ix = 1,nx
         xi = (ix-1) * del
         do r = 1,n_refl
            phx(r,ix) = exp(ci*hx(r)*xi)
         end
      end

      ! Make the 1D y phases
      phy.create(n_refl,ny)
      del = ONE/(ny-1)
      do iy = 1,ny
         yi = (iy-1) * del
         do r = 1,n_refl
            phy(r,iy) = exp(ci*hy(r)*yi)
         end
      end

      ! Make the 1D z phases
      phz.create(n_refl,nz)
      del = ONE/(nz-1)
      do iz = 1,nz
         zi = (iz-1) * del
         do r = 1,n_refl
            phz(r,iz) = exp(ci*hz(r)*zi) * dF(r) ! <--
         end
      end


      ! Grid point
      p = 0

      ! Make the residual map
      phyz.create(n_refl)

      do iz = 1,nz
      do iy = 1,ny

         phyz = phy(:,iy)*phz(:,iz)

         do ix = 1,nx
        
            p = p + 1
            map(p) = sum( REALIFY(phx(:,ix)*phyz(:)) )
        
         end

      end
      end

      ! Clean
      phyz.destroy
      phz.destroy
      phy.destroy
      phx.destroy
      hz.destroy
      hy.destroy
      hx.destroy
      dF.destroy

   end

   make_residual_density_cell_p(map,nx,ny,nz)
   ! Make the crystal residual error "map" in the unit cell with
   ! "nx", "ny" and "nz" points per cell axis. These must be odd.
   ! The "map" array increments first on the x axis, then y, then z
   ! i.e. it must be compatible with PLOT_GRID:make_points.
   ! This routine takes advantage of the grid structure for speed.
   ! This version uses a 2D phase array and reduced multiplication.
      self :: IN
      map :: VEC{REAL}, OUT
      nx,ny,nz :: INT, IN

   ENSURE(.data.associated, "no diffraction data")
   ENSURE(.data.reflections.associated, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_pred, "no predicted structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")

      n_refl,r,p :: INT
      hx,hy,hz :: VEC{INT}*
      ix,iy,iz :: INT
      xi,yi,zi :: REAL
      fac,del  :: REAL
      dF, phyz :: VEC{CPX}*
      phx,phy,phz :: MAT{CPX}*
      ph2 :: MAT3{CPX}*
      h_max :: VEC{INT}(3)
      ci :: CPX

      ! Constants
      n_refl = .data.reflections.dim
      ci     = -2*PI * IMAGIFY(ONE)

      ! Maximum Miller indices
      h_max = .data.reflections.h_max

      ! Get phased structure factor differences
      ! (without extinction, but with scale correction)
      dF.create(n_refl)
      .data.make_phased_dF_a(dF)

      ! Prefactor
      ! NOTE: Factor 2 assumes Friedel pairs merged and removed
      fac = TWO/.unit_cell.volume

      ! Get h's
      hx.create(n_refl)
      hy.create(n_refl)
      hz.create(n_refl)

      hx = .data.reflections(:).h
      hy = .data.reflections(:).k
      hz = .data.reflections(:).l

      ! Allocate the 2D phase array
      ph2.create(n_refl,ny,nz)

      ! Make the 1D z phases
      phz.create(n_refl,nz)
      del = ONE/(nz-1)
      do iz = 1,nz
         zi = (iz-1) * del
         do r = 1,n_refl
            phz(r,iz) = exp(ci*hz(r)*zi)
         end
      end

      ! Make the 1D y phases
      phy.create(n_refl,ny)
      del = ONE/(ny-1)
      do iy = 1,ny
         yi = (iy-1) * del
         do r = 1,n_refl
            phy(r,iy) = exp(ci*hy(r)*yi)
         end
      end

      ! Make the 2D array
      do iz = 1,nz
      do iy = 1,ny
         do r = 1,n_refl
            ph2(r,iy,iz) = phy(r,iy)*phz(r,iz)
         end
      end
      end

      ! Clean
      phy.destroy
      phz.destroy

      ! Make the 1D x phases
      phx.create(n_refl,nx)
      del = ONE/(nx-1)
      do ix = 1,nx
         xi = (ix-1) * del
         do r = 1,n_refl
            phx(r,ix) = exp(ci*hx(r)*xi) * dF(r) * fac
         end
      end


      ! Grid point
      p = 0

      ! Make the residual map
      do iz = 1,nz
      do iy = 1,ny

         phyz => ph2(:,iy,iz)

         do ix = 1,nx
        
            p = p + 1
            map(p) = sum( REALIFY(phx(:,ix)*phyz) )
        
         end

      end
      end

      ! Clean
      phx.destroy
      ph2.destroy
      hz.destroy
      hy.destroy
      hx.destroy
      dF.destroy

   end


!  ===================
!  Cluster set methods
!  ===================

   set_radius(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.radius), PURE
   ! Generic set
   end

   set_defragment(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.defragment), PURE
   ! Generic set
   end

   set_fragment_geometry(fragment_geometry,cartesian) ::: leaky
   ! Makes an atom list from "fragment_geometry" to which
   ! .fragment_atoms gets set. The .asymmetric_unit_atoms (which must
   ! be in cartesian system) and .unit_cell_geometry have to be
   ! defined. Set "cartesian" to TRUE if the "fragment_geometry" is in
   ! cartesians, default is fractional coordinates.
      self :: INOUT
      fragment_geometry :: MAT{REAL}, IN
      cartesian :: BIN, optional, IN

   ENSURE(.unit_cell_geometry.associated,           "no .unit_cell_geometry")
   ENSURE(.asymmetric_unit_atom.associated,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.associated, "no .asym_atom_for_unit_cell_atom")

      atom  :: VEC{ATOM}*
      list  :: VEC{INT}*
      pf,pu :: VEC{REAL}(3)
      fg :: MAT{REAL}*
      n_frag_atoms,f,u,a :: INT
      tol :: REAL
      cart,found :: BIN

      cart = FALSE
      if (present(cartesian)) cart = cartesian

      ! Transform fragment geometry to fractional
      fg.create_copy(fragment_geometry)
      if (cart) .unit_cell.change_into_fractional(fg)

      ! Create the list of atom indices -- leaky!!
      n_frag_atoms = fg.dim2
      list.create(n_frag_atoms)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = CRYSTAL_SAME_ATOM_TOL

      ! Find and create fragment atoms
      do f = 1,n_frag_atoms

         ! Shift fragment atom to unit cell
         pf = fg(:,f)
         .put_to_unit_cell(pf)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Is u the same as f?
            pu = .unit_cell_geometry(:,u)
            found = pu.same_as(pf,tol)

            if (NOT found) cycle

            ! Set asymmetric atom index for atom f
            a = .asym_atom_for_unit_cell_atom(u)
            list(f) = a

            exit

         end

         DIE_IF(NOT found,"fragment atom "//trim(f.to_str)//" was not found in the unit cell")

      end

      ! Make the atom list, cartesian coordinates
      atom.create_copy(.asymmetric_unit_atom,list)
      atom.set_axis_system_to("crystal")
      atom.set_positions_to(fg)
      atom.zero_pADP_errors
      atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      if (.debugging("make_fragment_data")) then
          stdout.put("make_fragment_data:")
          stdout.text("list:")
          stdout.put(list,by_column=TRUE)
          stdout.text("atom:")
          atom.dump("atom:VEC{ATOM}*")
      end

      ! Make the fragment data; make it destroyable
      .make_fragment_data(atom,assign_atom=TRUE,warnings=FALSE)
      .destroy_fragment_atom = TRUE

      ! Clean
      list.destroy
      fg.destroy

   end

   set_generation_method(method)
   ! Set the generation method, which tells how to generate the cluster e.g.
   ! whether to add atoms to the cluster within a certain radius of the starting
   ! fragment, or whether to use the unit cell ad the cluster, or just the
   ! initial starting fragment (i.e. the null cluster) or the initial fragment
   ! and the unit cell.
      self :: INOUT
      method :: STR, IN

      .generation_method = method
      .generation_method.to_lower_case

      select case (.generation_method)
      case("for_hirshfeld_surface     ")
      case("fragment                  ")
      case("unit_cell                 ")
      case("unit_cell_plus            ")
      case("for_unit_cell_density     ")
      case("offset_unit_cell          ")
      case("offset_unit_cell_density  ")
      case("within_radius             ")
      case default;   UNKNOWN(.generation_method)
      end

   end

   set_atom_density_cutoff(tol)
   ! Set the atom_density_cutoff used to eliminate spherical atomic
   ! density contributions less than "tol". The interpolator table
   ! will not hold values smaller than "tol".
      self :: INOUT
      tol :: REAL, IN

   ENSURE(tol>ZERO,"tol must be +ve")

      .atom_density_cutoff = tol

   end

   set_unit_cell_offset(offset)
   ! Set the unit_cell_offset to use when making an offset unit cell.
      self :: INOUT
      offset :: VEC{REAL}(3)

   DIE_IF(any(offset>HALF) OR any(offset<-HALF),"offset must be between -1/2 and +1/2")

      .unit_cell_offset = offset

   end

!  ===========================
!  Cluster generation routines
!  ===========================

   make_cluster_info ::: leaky
   ! Make all the cluster information from an arbitrary .fragment_geometry.
   ! NOTE: .set_defaults must be called before this.
      self :: INOUT

   ENSURE(.unit_cell_connection.associated,"no unit cell connection table")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")

      if (.cluster_info_made) return

      ! Depending on the generation_method, make starting cluster
      .make_occupation_list

      ! Generate the cluster
      select case (.generation_method)

      case ("within_radius")
         .make_within_radius

      case ("for_hirshfeld_surface")
         .make_HS_radius
         .make_within_radius
         .defragment = FALSE

      case ("for_unit_cell_density")
       ! .do_defragment
         .make_HS_radius
         .make_within_radius
         .defragment = TRUE

      case ("offset_unit_cell_density")
         .make_HS_radius
         .make_within_radius
         .defragment = FALSE

      end

      ! Defragment/find molecules in the cluster
      if (.defragment) then; .do_defragment
      else;                  .do_connectify
      end

      ! Extract cordinates from occupation list
      .extract_geometry

      ! Finished ...
      .cluster_info_made = TRUE

   end

   make_occupation_list ::: leaky
   ! Codify which atoms in the crystal are fragment atoms i.e. make
   ! the ".occupation_list". If atom "u" in the unit cell "(h1,h2,h3)"
   ! is occupied then the macro CLUSTER_AT_CODE(h1,h2,h3,u) appears in
   ! the array "list". The maximum value allowed for any h is
   ! CLUSTER_H_MAX i.e. we can't consider fragments atoms which lie in
   ! cells outside this range. This list allows easy comparison of
   ! which atoms are in the fragment by an integer equality test.
   ! NOTE: Also make the ".molecule_for_atom" list which tells which
   ! molecule the atom belongs to.
      self :: INOUT

   ENSURE(.unit_cell_geometry.associated,"no crystal unit cell")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")

      h :: VEC{INT}(3)
      pos :: VEC{REAL}(3)
      f,u,h000 :: INT
      fragment_geometry :: MAT{REAL}*

      select case (.generation_method)

      case ("within_radius","for_hirshfeld_surface","fragment")

         ENSURE(.fragment_geometry.associated,"no fragment_geometry")
         ENSURE(.fragment_info_made,"no crystal fragment info")
         ENSURE(.unit_cell_atom_for_frag_atom.associated,"no cell-frag_atom array")
         ENSURE(.unit_cell_shft_for_frag_atom.associated,"no cell-frag_atom array")

         ! Get fragment offset i.e. center
         pos = .fragment_geometry.mean_column_vector
         .fragment_offset = int(pos)

         ! Create occupation list
         .occupation_list.destroy
         .occupation_list.create(.n_fragment_atoms)

         ! Loop on fragment atom
         do f = 1,.n_fragment_atoms

            ! Get unit cell atom & shift
            u = .unit_cell_atom_for_frag_atom(f)
            h = .unit_cell_shft_for_frag_atom(:,f)

            ! Shift relative to recentered unit cell
            h = h + .fragment_offset

            ENSURE(all(h>=-CLUSTER_H_MAX),"frag too wide, h = "//trim(h.to_concatenated_str))
            ENSURE(all(h<= CLUSTER_H_MAX),"frag too wide, h = "//trim(h.to_concatenated_str))

            ! Sanity check
            if (u==0) then
               WARN("position of fragment atom "//f.to_str.trim//" not found in unit cell")
               stdout.show("fragment pos =",pos)
               stdout.text("unit cell geometry:")
               stdout.put(transpose(.unit_cell_geometry))
            !  DIE("position of fragment atom "//f.to_str.trim//" not found in unit cell")
            end

            ! Offset h to apply to "u" to get frag atom "f".
            ! Must reverse h. See above.
            h = -h

            ! Get occ code ...
            .occupation_list(f) = CLUSTER_AT_CODE(h(1),h(2),h(3),u)

         end

      case ("unit_cell","for_unit_cell_density")

         ! Create occupation list
         .occupation_list.destroy
         .occupation_list.create(.n_unit_cell_atoms)

         ! Temporary
         fragment_geometry.create(3,.n_unit_cell_atoms)

         ! Set central cell
         h000 = CLUSTER_H_CODE(0,0,0)

         do u = 1,.n_unit_cell_atoms

            ! Encode central cell
            .occupation_list(u) = h000 + CLUSTER_UA_CODE(u)

            ! Set fragment to unit cell
            pos = .unit_cell_geometry(:,u)
            fragment_geometry(:,u) = pos

         end

         ! Set fragment and make sure there is no offset
         .set_fragment_geometry(fragment_geometry)
         .fragment_offset = 0

         ! Clean
         fragment_geometry.destroy

    ! case ("unit_cell_plus","for_unit_cell_density")

    !    ! Create occupation list
    !    .occupation_list.destroy
    !    .occupation_list.create(.n_unit_cell_atoms)

    !    ! Temporary
    !    fragment_geometry.create(3,.n_unit_cell_atoms)

    !    ! Set central cell
    !    h000 = CLUSTER_H_CODE(0,0,0)

    !    do u = 1,.n_unit_cell_atoms

    !       ! Encode central cell
    !       .occupation_list(u) = h000 + CLUSTER_UA_CODE(u)

    !       ! Set fragment to unit cell
    !       pos = .unit_cell_geometry(:,u)
    !       fragment_geometry(:,u) = pos

    !    end

    !    ! Set fragment and make sure there is no offset
    !    .set_fragment_geometry(fragment_geometry)
    !    .fragment_offset = 0

    !    ! Clean
    !    fragment_geometry.destroy

    !    ! Go two angstrom from unit cell edges for unit cell densities
    !    ! if the setting is "for_unit_cell_density"
    !    two_angstrom = TWO
    !    two_angstrom = two_angstrom.from_units("angstrom")
    !    if (.generation_method=="unit_cell_plus") then; radius = .radius
    !    else;                                           radius = max(TWO,.radius)
    !    end

    !    ! Fractions "b" along cell axes; and complements "t"
    !    b = radius/.unit_cell.length
    !    DIE_IF(any(b>ONE),"radius around unit cell exceeds at least one cell dimension")
    !    t = ONE - b

    !    ! Unit cell code
    !    uc = 0

    !    do u = 1,.n_unit_cell_atoms

    !       pos = .unit_cell_geometry(:,u)

    !       uc = CLUSTER_UA_CODE(u)

    !       ! FIX h1
    !       if (pos(1)<b(1)) .occupation_list.append(CLUSTER_H_CODE( 1, 0, 0)+uc)
    !       if (pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE( 0, 1, 0)+uc)
    !       if (pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 0, 1)+uc)
    !       if (pos(1)>t(1)) .occupation_list.append(CLUSTER_H_CODE(-1, 0, 0)+uc)
    !       if (pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE( 0,-1, 0)+uc)
    !       if (pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 0,-1)+uc)

    !       if (pos(1)<b(1) AND pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE( 1, 1, 0)+uc)
    !       if (pos(1)<b(1) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 0, 1)+uc)
    !       if (pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 1, 1)+uc)
    !       if (pos(1)>t(1) AND pos(2)<b(2)) .occupation_list.append(CLUSTER_H_CODE(-1, 1, 0)+uc)
    !       if (pos(1)>t(1) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 0, 1)+uc)
    !       if (pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 0,-1, 1)+uc)
    !       if (pos(1)<b(1) AND pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE( 1,-1, 0)+uc)
    !       if (pos(1)<b(1) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 0,-1)+uc)
    !       if (pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0, 1,-1)+uc)
    !       if (pos(1)>t(1) AND pos(2)>t(2)) .occupation_list.append(CLUSTER_H_CODE(-1,-1, 0)+uc)
    !       if (pos(1)>t(1) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 0,-1)+uc)
    !       if (pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 0,-1,-1)+uc)

    !       if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 1, 1)+uc)
    !       if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 1, 1)+uc)
    !       if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE( 1,-1, 1)+uc)
    !       if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)<b(3)) .occupation_list.append(CLUSTER_H_CODE(-1,-1, 1)+uc)
    !       if (pos(1)<b(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1, 1,-1)+uc)
    !       if (pos(1)>t(1) AND pos(2)<b(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1, 1,-1)+uc)
    !       if (pos(1)<b(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE( 1,-1,-1)+uc)
    !       if (pos(1)>t(1) AND pos(2)>t(2) AND pos(3)>t(3)) .occupation_list.append(CLUSTER_H_CODE(-1,-1,-1)+uc)

    !    end

    ! case ("offset_unit_cell","offset_unit_cell_density")

    !    ! Create occupation list
    !    .occupation_list.destroy
    !    .occupation_list.create(.n_unit_cell_atoms)

    !    ! Temporary
    !    fragment_geometry.create(3,.n_unit_cell_atoms)

    !    do u = 1,.n_unit_cell_atoms

    !       ! Unit cell position
    !       pos = .unit_cell_geometry(:,u)

    !       ! Set central cell
    !       h = 0

    !       ! Apply the offset
    !       if (pos(1)<    .unit_cell_offset(1)) h(1) = +1
    !       if (pos(2)<    .unit_cell_offset(2)) h(2) = +1
    !       if (pos(3)<    .unit_cell_offset(3)) h(3) = +1
    !       if (pos(1)>ONE+.unit_cell_offset(1)) h(1) = -1
    !       if (pos(2)>ONE+.unit_cell_offset(2)) h(2) = -1
    !       if (pos(3)>ONE+.unit_cell_offset(3)) h(3) = -1

    !       ! Get occ code ...
    !       .occupation_list(u) = CLUSTER_AT_CODE(h(1),h(2),h(3),u)

    !       ! Set frag geometry with offset
    !       fragment_geometry(:,u) = pos + h

    !    end

    !    ! Set fragment and make sure there is no offset
    !    .set_fragment_geometry(fragment_geometry)
    !    .fragment_offset = 0

    !    ! Clean
    !    fragment_geometry.destroy

    ! case default
    !    UNKNOWN(.generation_method)

      end

   end

   make_HS_radius
   ! This routine makes an appropriate value for the cluster .radius in the
   ! case where the .generation_method is "for_hirshfeld_surface". The radius is
   ! made so that the accuracy of any atomic term neglected is smaller than
   ! .atom_density_cutoff. The radius is defined to the nearest 0.02 bohr (or
   ! whatever is set as the default for the interpolator table spacing). Likewise,
   ! we can't cope with atom density cutoffs where the distances are larger than
   ! 30 bohr (or whatever is set as the default interpolator table length). To
   ! do this properly we'd have to solve numerical equations for exactly where
   ! the atom density equals the desired cutoff; that seems like too much
   ! effort.
      self :: INOUT

   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric cell atoms")
   ENSURE(.asymmetric_unit_atom.has_all_bases,"incomplete atom bases")
   ENSURE(.atom_density_cutoff>ZERO,"atom density cutoff must be positve")

      .radius = .asymmetric_unit_atom.max_interpolator_table_length(.atom_density_cutoff)

   end

   make_within_radius ::: leaky
   ! Make the maximum unit cell offsets so that we get all atoms within a
   ! certain radius of the fragment geometry.
      self :: INOUT

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_geometry.associated,"no fragment_geometry")
   ENSURE(.unit_cell_geometry.associated,"no crystal unit_cell_geometry")

      geom0,frag :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos,off,d,frac_radius :: VEC{REAL}(3)
      hlist,ulist,match :: VEC{INT}*
      uskip :: VEC{BIN}*
      d2,radius2 :: REAL
      within_radius,has_frag_atoms,not000,offset, has_atoms_to_suppress :: BIN
      n_unit_cell_atoms, h0,h1,h2,h3, hcode,code, k,u :: INT

      ! Constants
      n_unit_cell_atoms = .n_unit_cell_atoms
      radius2           = .radius*.radius
      rcm               = .unit_cell.direct_matrix

      ! Suppres some atoms?
      has_atoms_to_suppress = .unit_cell_atoms_to_suppress.associated
      if (has_atoms_to_suppress) has_atoms_to_suppress = .unit_cell_atoms_to_suppress.dim > 0

      ! Cartesian fragment geometry
      frag.create(3,.n_fragment_atoms)
      frag.to_product_of(rcm,.fragment_geometry)

      ! Calculate offset to fragment
      offset = any(.fragment_offset/=0)
      if (offset) then
         off.to_product_of(rcm,REALIFY(.fragment_offset))
      end

      ! Look this many cells away for cluster atoms ...
      frac_radius = .radius/.unit_cell.length
      .h_max = ceiling( frac_radius+maxval(.fragment_geometry,dim=2) - .fragment_offset)
      .h_min =   floor(-frac_radius+minval(.fragment_geometry,dim=2) - .fragment_offset)

      ! Look at least one cell away ...
      .h_max = max(.h_max,[ 1, 1, 1])
      .h_min = min(.h_min,[-1,-1,-1])

      ! Maximum value of unit cell index
      ! and offset for unit cell coding
      h0 = CLUSTER_H_MAX
      ENSURE(all(.h_min>=-h0),"search too low,  h_min = "//trim(.h_min.to_concatenated_str))
      ENSURE(all(.h_max<= h0),"search too high, h_max = "//trim(.h_max.to_concatenated_str))

      ! Get the (0,0,0) unit cell offset by .fragment_offset in cartesians
      geom0.create(3,n_unit_cell_atoms)
      geom0.to_product_of(rcm,.unit_cell_geometry)
      if (offset) &
      geom0 = geom0 + spread(off,2,n_unit_cell_atoms)

      ! Cells which fragment occupies
      match.create(.n_fragment_atoms)
      hlist.create(.n_fragment_atoms)
      hlist = CLUSTER_HC_FROM_CODE(.occupation_list)

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_fragment_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Skip fragment atoms in a particular unit cell
      uskip.create(n_unit_cell_atoms)

      ! Loop over allowed cells
      do h1 = .h_min(1),.h_max(1)
      do h2 = .h_min(2),.h_max(2)
      do h3 = .h_min(3),.h_max(3)

         ! Get cell displacement vector if needed
         not000 = h1/=0 OR h2/=0 OR h3/=0
         if (not000) off.to_product_of(rcm,REALIFY(([h1,h2,h3])))

         ! Get list of atoms in "match" which are in this cell
         hcode = CLUSTER_H_CODE(h1,h2,h3)
         match => hlist.indices_of_elements_matching(hcode)

         ! Are there any fragment atoms in this cell?
         ! Set the unit cell atoms corresponding to them
         has_frag_atoms = match.dim>0
         if (has_frag_atoms) then
            uskip = FALSE
            do k = 1,match.dim
               uskip(ulist(match(k))) = TRUE
            end
         end

         ! Loop over unit cell atoms in this cell
         do u = 1,n_unit_cell_atoms

            ! If there are fragment atoms here, skip them
            if (has_frag_atoms) then
               if (uskip(u)) cycle
            end

            if (has_atoms_to_suppress) then
              if (any(.unit_cell_atoms_to_suppress == u)) cycle
            end

            pos = geom0(:,u)
            if (not000) pos = pos + off

            ! Test if this atom pos is within .radius
            within_radius = FALSE
            do k = 1,.n_fragment_atoms

               d = frag(:,k) - pos

               ! Sequentially eliminate far points
               if (abs(d(1))>.radius) cycle
               if (abs(d(2))>.radius) cycle
               if (abs(d(3))>.radius) cycle

               ! Don't use square root
               d2 = d(1)*d(1)+d(2)*d(2)+d(3)*d(3)
               if (d2>radius2) cycle

               within_radius = TRUE
               exit

            end

            if (NOT within_radius) cycle

            ! New atom ... add it in ...
            code = hcode + CLUSTER_UA_CODE(u)
            .occupation_list.append(code)

         end

         ! Clean
         match.destroy

      end
      end
      end

      ! Clean
      uskip.destroy
      ulist.destroy
      hlist.destroy
      geom0.destroy
      frag.destroy

   end

   do_connectify ::: leaky
   ! Find the connected molecules in the "occupation_list" from the
   ! .unit_cell_connection table.

   ENSURE(.unit_cell_connection.associated,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      con,molecule_for_atom :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*

      ! No. of atoms
      .n_atoms = .occupation_list.dim

      ! Connection table
      unit_cell_connection => .unit_cell_connection

      ! Clear info arrays
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      ! Assume every atom it's own molecule
      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
         molecule_for_atom(i) = i
      end

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Finished atoms "i"?
         if (i>.n_atoms) exit

         ! Info about atom "i"
         mi   = molecule_for_atom(i)       ! Molecule "mi" for i
         code = .occupation_list(i)        ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections? next ...
         if (unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset for atom "i"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Find atoms which connect to u
         do c = 1,unit_cell_connection(u).element.dim

            ! List of connections
            con => unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = .occupation_list.index_of_value(code)

            if (old>0) then

               ! This is an old (found) atom. Replace the molecule
               ! index by the lower of  "mi" and "mo" everywhere.
               mo = molecule_for_atom(old)
               if (mo<mi) then
                  where (molecule_for_atom==mi) molecule_for_atom = mo
                  mi = mo
               else if (mo>mi) then
                  where (molecule_for_atom==mo) molecule_for_atom = mi
               end

               ! Atom "old" is connection to "i"
               .atom_connection(i).element.append(old)

            end

         end ! connections to u

      end ! atoms "i"

      ! Set (sorted) molecule index array
      .molecule_for_atom => molecule_for_atom

      ! Make molecule info
      .make_molecule_info

   end

   do_defragment ::: leaky
   ! Defragment the generated cluster and find the connected molecules using the
   ! .unit_cell_connection table.
      self :: INOUT

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.unit_cell_connection.associated,"no unit cell connection table")

      i,c,code,h1,h2,h3,u,k1,k2,k3,t,old,mi,mo :: INT
      con,molecule_for_atom :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*

      ! Initial no. of atoms
      .n_atoms = .occupation_list.dim

      ! Connection table
      unit_cell_connection => .unit_cell_connection

      ! Clear info arrays
      .atom_connection.destroy
      .atom_connection.create(.n_atoms)
      .molecule_for_atom.destroy

      ! Assume every atom it's own molecule
      molecule_for_atom.create(.n_atoms)
      do i = 1,.n_atoms
         molecule_for_atom(i) = i
      end

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Any more atoms to connect?
         if (i>.n_atoms) exit

         ! Info about atom "i"
         mi   = molecule_for_atom(i)       ! Molecule "mi" for i
         code = .occupation_list(i)        ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections to this atom? next ...
         if (unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset for atom "i"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Loop on atoms "c" connected to "u"
         do c = 1,unit_cell_connection(u).element.dim

            ! List of connections
            con => unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = .occupation_list.index_of_value(code)

            if (old>0) then

               ! This is an old (found) atom. Replace the molecule
               ! index by the lower of  "mi" and "mo" everywhere.
               mo = molecule_for_atom(old)
               if (mo<mi) then
                  where (molecule_for_atom==mi) molecule_for_atom = mo
                  mi = mo
               else if (mo>mi) then
                  where (molecule_for_atom==mo) molecule_for_atom = mi
               end
               .atom_connection(i).element.append(old)

            else

               ! This is a new atom. Increment no. of atoms,
               ! store in the occ list and add new connection.
               .occupation_list.append(code)
               molecule_for_atom.append(mi)
               .n_atoms = .n_atoms + 1
               .atom_connection.expand(.n_atoms)
               .atom_connection(i).element.append(.n_atoms)

            end

         end

      end

      ! Set (sorted) molecule index array
      .molecule_for_atom => molecule_for_atom

      ! Make molecule info
      .make_molecule_info

   end

   do_defragment(occupation_list) ::: leaky
   ! Defragment the "occupation_list"
      occupation_list :: VEC{INT}*

   ENSURE(occupation_list.associated,"no occupation_list")
   ENSURE(.unit_cell_connection.associated,"no unit cell connection table")

      n_atoms,i,c,code,h1,h2,h3,u,k1,k2,k3,t,old :: INT
      con :: VEC{INT}*
      unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*

      ! Initial no. of atoms
      n_atoms = occupation_list.dim

      ! Connection table
      unit_cell_connection => .unit_cell_connection

      ! Loop on all atoms "i"
      i = 0

      do

         i = i + 1

         ! Any more atoms to connect?
         if (i>n_atoms) exit

         ! Info for atom "i"
         code = occupation_list(i)         ! Occupation code
         u    = CLUSTER_UA_FROM_CODE(code) ! Unit cell atom

         ! No connections to this atom? next ...
         if (unit_cell_connection(u).element.dim==0) cycle

         ! Get unit cell atom offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)

         ! Loop on atoms "c" connected to "u"
         do c = 1,unit_cell_connection(u).element.dim

            ! List of connections
            con => unit_cell_connection(u)[c].element

            ! Get code for connected atom
            k1 = h1 + con(1)
            k2 = h2 + con(2)
            k3 = h3 + con(3)
            t  =      con(4)
            code = CLUSTER_AT_CODE(k1,k2,k3,t)

            ! Is it new in the occupation list?
            old = occupation_list.index_of_value(code)

            if (old>0) cycle ! if old

            ! This is a new atom. Increment no. of atoms,
            ! store in the occ list.
            occupation_list.append(code)
            n_atoms = n_atoms + 1

         end

      end

   end

   do_defragment_uc_atom(u,geometry) ::: leaky
   ! Defragment a single atom "u" in the unit cell and produce a
   ! "geometry" in crystal coordinates.
      u :: INT, IN
      geometry :: MAT{REAL}*

      occupation_list :: VEC{INT}*

      ! Creat one-atom occ list
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment and extract geometry
      .do_defragment(occupation_list)
      .extract_geometry(occupation_list,geometry)

      ! Clean
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,mass) ::: leaky
   ! Defragment a single atom "u" in the unit cell and produce the
   ! "symop" (index) which maps the asymmetric parent-atom "par" into
   ! "u", the *list* of cartesian positions in "pos",  and the list of
   ! corresponding atomic masses in "mass".  Needed for LFF refractive
   ! index calculations.
      u :: INT, IN
      symop :: INT, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass   :: VEC{REAL}, OUT

      occupation_list :: VEC{INT}*

      ! Get symop for cell atom "u"
      symop = .asym_symop_for_unit_cell_atom(u)

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the info
      .do_defragment(occupation_list)
      .extract_atom_info(occupation_list,par,pos,mass)

      ! Clean up
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,pos,charge,dipole,frag_atom) ::: leaky
   ! Defragment a single atom "u" in the unit cell and extract
   ! *cartesian* atom positions "pos", the atomic charges and dipoles
   ! "charge" and "dipole" in a *flat* array, and the frag atom for
   ! the atoms.  These properties are requited for LFF refractive
   ! index calculations.
      u :: INT, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, optional

      occupation_list :: VEC{INT}*

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the info
      .do_defragment(occupation_list)
      .extract_atom_info(occupation_list,pos,charge,dipole,frag_atom)

      ! Clean up
      occupation_list.destroy

   end

   do_defragment_uc_atom(u,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m) ::: leaky
   ! Defragment a single atom "u" in the unit cell and for the
   ! *molecule* produce the "symop" (3x3 matrix) which maps "u" into
   ! the *last* asymmetric parent-atom "par" in the *list* of
   ! defragged cartesian positions in "pos", the atomic "charge",
   ! "mass", and "dipole", and the atomic charge and dipole
   ! polarizabilities "alpha_q" and "alpha_m".
   ! NOTE: symop matrix seems strange cf. routine above.
      u :: INT, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

      occupation_list :: VEC{INT}*

      ! Make the coded occupation_list for this atom
      occupation_list.create(1)
      occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)

      ! Defragment this atom and get the *molecule* info
      .do_defragment(occupation_list)
      .extract_molecule_atom_info(occupation_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)

      ! Clean up
      occupation_list.destroy

   end

   make_molecule_info ::: private, leaky
   ! Sort the cluster into molecules whose indices appear in ascending
   ! order; also store the atom indices in each molecule.

   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      unique :: VEC{INT}*
      mi,mj, a,m :: INT

      ! Get molecule indices & sort ascdending
      unique => .molecule_for_atom.unique_elements
      unique.sort

      ! Number of molecules in cluster
      .n_molecules = unique.dim

      ! Put .molecule_for_atom into ascending order
      do mi = 1,.n_molecules
         mj = unique(mi)
         if (mj==mi) cycle
         where (.molecule_for_atom==mj) .molecule_for_atom = mi
      end

      ! Clean
      unique.destroy

      ! Now make the molecule list
      .molecule.create(.n_molecules)
      do a = 1,.n_atoms
         m = .molecule_for_atom(a)
         .molecule(m).element.append(a)
      end

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (.defragment) .make_unique_molecule_info
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   end

   make_unique_molecule_info ::: private, leaky
   ! Sort the cluster molecules so that the atom order in
   ! each is consistent. This only works for defragmented
   ! clusters.

   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      li,lj :: VEC{INT}*
      ci,cj,ui,uj,ai,aj, permutation, new :: VEC{INT}*
      mi,mj, ni, s,si,sj, ic,i0,i1,i2,i3, jc,j0,j1,j2,j3 :: INT
      pi,pj,ps :: VEC{REAL}(3)
      shift :: VEC{INT}(3)
      related :: BIN

      ! Clean & get ready
      .unique_molecule_for.destroy
      .unique_molecule_for.create(.n_molecules)
      .unique_symcode_for.destroy
      .unique_symcode_for.create(.n_molecules)

      ! List of unique molecules for each cluster atom
      ! and their relating symops
      .n_unique_molecules     = 0
      .unique_molecule_for    = 0
      .unique_symcode_for     = 0

      ! Make atom-order in each molecule consistent
      do mi = 1,.n_molecules

         ! Processed?
         if (.unique_molecule_for(mi)>0) cycle

         li => .molecule(mi).element
         ni  = li.dim

         ai.create(ni)
         ui.create(ni)
         ci.create(ni)

         ci  = .occupation_list(li)
         ui  = CLUSTER_UA_FROM_CODE(ci)
         ai  = .asym_atom_for_unit_cell_atom(ui)
         si  = .asym_symop_for_unit_cell_atom(ui(1))
         si  = .spacegroup.inverse_of_symops(si)

         ic  = ci(1)

         ci.destroy
         ui.destroy

         i0  = CLUSTER_UA_FROM_CODE(ic)
         i1  = CLUSTER_H1_FROM_CODE(ic)
         i2  = CLUSTER_H2_FROM_CODE(ic)
         i3  = CLUSTER_H3_FROM_CODE(ic)
         pi  = .unit_cell_geometry(:,i0) + [i1,i2,i3] + .fragment_offset

         ! Find matching molecules
         do mj = mi+1,.n_molecules

            lj => .molecule(mj).element

            ! Found?
            if (.unique_molecule_for(mj)>0) cycle

            ! Same # on atoms?
            if (lj.dim/=ni) cycle

            aj.create(ni)
            uj.create(ni)
            cj.create(ni)

            cj  = .occupation_list(lj)
            uj  = CLUSTER_UA_FROM_CODE(cj)
            aj  = .asym_atom_for_unit_cell_atom(uj)
            sj  = .asym_symop_for_unit_cell_atom(uj(1))

            cj.destroy
            uj.destroy

            ! Match asym atoms
            permutation.create(ni)
            ai.is_permutation_of(aj,related,permutation)

            if (related) then

               ! New order
               new.create_copy(lj(permutation))

               ! First atom in mj (matched to mi)
               jc = .occupation_list(new(1))

               ! Position of first atom in mj
               j0 = CLUSTER_UA_FROM_CODE(jc)
               j1 = CLUSTER_H1_FROM_CODE(jc)
               j2 = CLUSTER_H2_FROM_CODE(jc)
               j3 = CLUSTER_H3_FROM_CODE(jc)
               pj = .unit_cell_geometry(:,j0) + [j1,j2,j3] + .fragment_offset

               ! Symop which maps mi->mj
               s = .spacegroup.product_of_symops(sj,si)

               ! Get shift
               ps = pi
               .spacegroup.transform_position(ps,s)

               ps    = pj - ps
               shift = nint(ps)

               ! Unique molecule
               .unique_molecule_for(mj) = mi

               ! New symcode
               .unique_symcode_for(mj) = CLUSTER_AT_CODE(shift(1),shift(2),shift(3),s)
             
               ! Reorder atoms in mj to be consistent with mi
               .occupation_list(lj) = .occupation_list(new)
               lj = new 

               new.destroy

            else

               ! Symmetry unique molecule
               .n_unique_molecules      = .n_unique_molecules + 1
               .unique_molecule_for(mi) = .n_unique_molecules

            end

            permutation.destroy
            aj.destroy

         end
            
         ai.destroy

      end

   end

!  ==================================================
!  Extract geometry & info from coded occupation list
!  ==================================================

   extract_geometry ::: leaky
   ! Extract the .geometry (fractional) from the final .occupation list.
   ! . Place connected molecules in order
   ! . Set the .is_fragment_atom flag array

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.unit_cell_geometry.associated,"no crystal unit cell geometry")

      a,m,i,code,h1,h2,h3,u :: INT
      atom_connection :: VEC{VEC_{INT}}*
      new_order :: VEC{INT}*
      connected :: BIN

      ! No of atoms to extract
      .n_atoms = .occupation_list.dim

      ! Extracted geometry
      .geometry.destroy
      .geometry.create(3,.n_atoms)

      ! Clear flags telling if fragment atom
      .is_fragment_atom.destroy
      .is_fragment_atom.create(.n_atoms)

      ! New ordering
      new_order.create(.n_atoms)

      a = 0

      ! Loop over molecules
      do m = 1,.n_molecules

          ! Loop over atoms "i"
          do i = 1,.n_atoms

             if (.molecule_for_atom(i)/=m) cycle

             ! Atom index
             a = a + 1
             new_order(i) = a

             ! Get occ code for this atom
             code = .occupation_list(i)

             ! Get unit cell atom "u" and cell offset "h"
             h1 = CLUSTER_H1_FROM_CODE(code)
             h2 = CLUSTER_H2_FROM_CODE(code)
             h3 = CLUSTER_H3_FROM_CODE(code)
             u  = CLUSTER_UA_FROM_CODE(code)

             ! Get the cluster atom coordinate
             .geometry(:,i) = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

             ! Set flag if fragment atom
             if (i<=.n_fragment_atoms) then; .is_fragment_atom(i) = TRUE
             else;                           .is_fragment_atom(i) = FALSE
             end

          end

      end


      ! Now reorder
      .occupation_list(new_order)   = .occupation_list
      .geometry(:,new_order)        = .geometry
      .molecule_for_atom(new_order) = .molecule_for_atom
      .is_fragment_atom(new_order)  = .is_fragment_atom

     ! This needs to be here, we must update .molecule to
     ! be in a consistent state with the rest of the object
      .molecule.destroy
      .molecule.create(.n_molecules)
      do a = 1,.n_atoms
         m = .molecule_for_atom(a)
         .molecule(m).element.append(a)
      end


      ! Reorder connection table
      atom_connection.create(.n_atoms)
      do i = 1,.n_atoms
         connected = .atom_connection(i).element.associated
         if (NOT connected) cycle
         atom_connection(new_order(i)).element.create_copy(new_order(.atom_connection(i)[:]))
      end

      .atom_connection.destroy
      .atom_connection => atom_connection

      ! Clean
      new_order.destroy

   end

   extract_geometry(occupation_list,geometry) ::: leaky
   ! Extract the geometry (fractional) from an "occupation_list".
      occupation_list :: VEC{INT}, IN
      geometry :: MAT{REAL}*

   ENSURE(.unit_cell_geometry.associated,"no crystal unit cell geometry")

      n_atoms,i,code,h1,h2,h3,u :: INT

      ! No. of atoms to extract
      n_atoms = occupation_list.dim

      ! Extracted geometry
      geometry.create(3,n_atoms)

      ! Loop over atoms "i"
      do  i = 1,n_atoms

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom coordinate
         geometry(:,i) = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset

      end

   end

   extract_atom_info(occupation_list,par,pos,mass)
   ! From a "occupation_list", extract the *cartesian* atom positions
   ! "pos", the index of the asymmetric-parent-atom in "par" and the
   ! atomic "mass" for each atom.
      occupation_list :: VEC{INT}, IN
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      mass :: VEC{REAL}, OUT

   ENSURE(.unit_cell_geometry.associated,"no crystal unit cell geometry")
   ENSURE(.asym_atom_for_unit_cell_atom.associated,"no asym_atom_for_unit_cell_atom")
   ENSURE(.frag_atom_for_unit_cell_atom.associated,"no frag_atom_for_unit_cell_atom")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(mass.dim==occupation_list.dim, "mass, wrong size")
   ENSURE(pos.dim1==3 AND pos.dim2==occupation_list.dim, "pos, wrong size")

      i,code,u,h1,h2,h3,p :: INT
      q :: VEC{REAL}(3)

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position (cartesian)
         q = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_matrix,q)

         ! Get parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         par(i) = p

         ! Atomic mass
         mass(i) = .asymmetric_unit_atom(p).mass

      end

   end

   extract_atom_info(occupation_list,pos,charge,dipole,frag_atom)
   ! From the "occupation_list", extract the *cartesian* atom
   ! positions "pos", the atomic charges and dipoles "charge" and
   ! "dipole" in a *flat* array, and the frag atom for the atoms.
   ! NOTE:
   ! . All the quantities are available and non-zero.
   ! . "pos" and "dipole" are in the cartesian frame.
   ! WARNING: the asymmetric_unit_atom's should be generated from
   ! the fragment on which the charge and dipole polarisability
   ! calculations (see below) have been done.
      occupation_list :: VEC{INT}, IN
      pos :: MAT{REAL}, OUT
      charge,dipole :: VEC{REAL}, OUT
      frag_atom :: VEC{INT}, OUT, optional

   ENSURE(.fragment_info_made,"no crystal fragment_info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(pos.dim1==3 AND pos.dim2==occupation_list.dim, "pos, wrong size")
   ENSURE(charge.dim==occupation_list.dim, "charge, wrong size")
   ENSURE(dipole.dim==3*occupation_list.dim, "dipole, wrong size")

      seitz :: MAT3{REAL}*
      i,l,code,h1,h2,h3,u, p,s :: INT
      q :: VEC{REAL}(3)

      ! Symops
      seitz => .xyz_seitz_matrices

      ! Counter, dipole array
      l = 0

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position (cartesian)
         q = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_matrix,q)

         ! Parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Parent and symop
         ! par(i) = p
         ! symop(i) = s

         ! Warning, the asymmetric_unit_atom's should be generated from
         ! the fragment on which the charge and dipole polarisability
         ! calculations (see below) have been done.

         ! Set the charges and dipoles
         charge(i) = .asymmetric_unit_atom(p).charge
         dipole(l+1:l+3).to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)
         l = l + 3

         ! Fragment atom list
         if (NOT present(frag_atom)) cycle
         frag_atom(i) = .frag_atom_for_unit_cell_atom(u)

      end

      ! Clean
      seitz.destroy

   end

   extract_molecule_atom_info(occupation_list,symop,par,pos,charge,mass,dipole,alpha_q,alpha_m)
   ! From a *molecule* "occupation_list", extract the *cartesian* atom
   ! positions "pos", the indiex of the asymmetric-parent-atom in
   ! "par", the corresponding 3x3 symop matrix which maps the unit
   ! cell atom into the asymmetric-parent-atom, the atomic charges and
   ! masses "charge" and "mass", atomic dipoles "dipole", charge
   ! polarisabilities "alpha_q" and dipole polarisabilities "alpha_m".
   ! NOTE:
   ! . This assumes that the quantities are available and non-zero.
   ! . "pos" and everything else are in *cartesians*.
   ! . The symop returned is the last one for "occupation_list"
   !   This is OK for a whole molecule
   ! WARNING: the asymmetric_unit_atom's should be generated from
   ! the fragment on which the charge and dipole polarisability
   ! calculations (see below) have been done.
      occupation_list :: VEC{INT}, IN
      symop :: MAT{REAL}, OUT
      par :: VEC{INT}, OUT
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT
      mass   :: VEC{REAL}, OUT
      dipole :: MAT{REAL}, OUT
      alpha_q :: MAT{REAL}, OUT
      alpha_m :: MAT3{REAL}, OUT

   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_dipoles,"no atomic dipoles, did you calc them?")
   ENSURE(.asymmetric_unit_atom.has_polarisabilities,"no atomic polarisabilities")
   ENSURE(charge.dim==occupation_list.dim, "charge, wrong size")
   ENSURE(mass.dim  ==occupation_list.dim, "mass, wrong size")
   ENSURE(all(shape(pos)    ==[3,occupation_list.dim]),"pos, wrong size")
   ENSURE(all(shape(dipole) ==[3,occupation_list.dim]),"dipole, wrong size")
   ENSURE(all(shape(alpha_q)==[3,occupation_list.dim]),"alpha_q, wrong size")
   ENSURE(all(shape(alpha_m)==[3,3,occupation_list.dim]), "alpha_m, wrong size")

      T  :: MAT{REAL}*
      inverse_seitz :: MAT3{REAL}*
      i,code,h1,h2,h3,u, p,s :: INT
      q :: VEC{REAL}(3)

      ! Transposed/Inverse symops
      inverse_seitz => .transposed_xyz_seitz_matrices

      ! Loop over atoms "i"
      do  i = 1,occupation_list.dim

         ! Get occ code for this atom
         code = occupation_list(i)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Set the cluster atom position (cartesian)
         q = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_matrix,q)

         ! Set parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)
         T => inverse_seitz(:,:,s)
         par(i) = p

         ! Set the inverse 3x3 symop
         symop = T

         ! Warning, the asymmetric_unit_atom's should be generated from
         ! the fragment on which the charge and dipole polarisability
         ! calculations (see below) have been done.

         ! Set atomic electronic charge.
         charge(i) = .asymmetric_unit_atom(p).charge &
                   - .asymmetric_unit_atom(p).atomic_number
         mass(i)   = .asymmetric_unit_atom(p).mass

         ! Set atomic dipole
         dipole(:,i).to_product_of(T,.asymmetric_unit_atom(p).dipole,transpose_a=TRUE)

         ! Set atomic charge polarisability
         alpha_q(:,i).to_product_of(T,.asymmetric_unit_atom(p).charge_polarisability,transpose_a=TRUE)

         ! Set atomic dipole polarisability
         alpha_m(:,:,i) = .asymmetric_unit_atom(p).dipole_polarisability
         alpha_m(:,:,i).change_basis_using(T)

      end

      ! Clean
      inverse_seitz.destroy

   end

!  ===================
!  Cluster information
!  ===================

   cluster_width result (res)
   ! Return the width "res" of the cluster in each of the 3 axis directions.
   ! NOTE: using crystal axis system.
      res :: VEC{REAL}(3)
   ENSURE(.geometry.associated,"no fragment geometry")
      res = .geometry.max_abs_column_difference
   end


   create_fragment_atom_list(fragment_atom) ::: leaky
   ! Create the "fragment_atom" list.
      fragment_atom :: VEC{ATOM}*

   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no fragment atoms")

      fragment_atom.create(.n_fragment_atoms)

      .make_fragment_atom_list(fragment_atom)

   end

   make_fragment_atom_list(fragment_atom) ::: private
   ! Make the "fragment_atom" list, a VEC{ATOM}
   ! WARNING: set info_made to FALSE in "fragment_atom" parent
   !          molecule, if there is one.
      self :: IN
      fragment_atom :: VEC{ATOM}, target, OUT

   ENSURE(.n_atoms>0,"no atoms")
   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(count(.is_fragment_atom)==.n_fragment_atoms,"inconsistent is_fragment_atom")
   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_cell_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.associated,"no asym_atom-cell_atom")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      a,f,u,p,s :: INT
      atom_f, atom_p :: ATOM*

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz => .xyz_seitz_matrices

      ! Fragment atom
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (NOT .is_fragment_atom(a)) cycle

         ! Fragment atom
         f = f + 1

         ! Extract unit cell atom and asymmetric parent
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Cluster and asymmetric atom parent
         atom_f => fragment_atom(f)
         atom_p => .asymmetric_unit_atom(p)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom_f.copy(atom_p)

         ! Transform the pADPs (which must be in cartesians)
         atom_f.transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom_f.set_position(.geometry(:,a))
         atom_f.set_axis_system_to("crystal")

      end

      ! Clean
      ulist.destroy

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      ! WARNING: set info_made to FALSE in parent molecule, if any
      fragment_atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

   end


   create_mol_atom_list(mol_atom,m) ::: leaky
   ! Create the "mol_atom" ATOM list for molecule "m".
      mol_atom :: VEC{ATOM}*
      m :: INT, IN

   ENSURE(.molecule.associated,"no molecule list")
   ENSURE(.molecule.dim>=m,"molecule m too large")
   ENSURE(.molecule(m).element.associated,"no molecule m atom indices")

      mol_atom.create(.molecule(m).element.dim)

      .make_mol_atom_list(mol_atom,m)

   end

   make_mol_atom_list(mol_atom,m)
   ! Make the "fragment_atom" list, a VEC{ATOM}
      self :: IN
      mol_atom :: VEC{ATOM}, target, OUT
      m :: INT, IN

   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.asymmetric_unit_atom.associated,"no asymmetric_cell_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.associated,"no asym_atom-cell_atom")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      f,a, u,p,s :: INT
      atom_f, atom_p :: ATOM*

      ! Unit cell atoms which correspond to the molecule's atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz => .xyz_seitz_matrices

      ! Loop over molecule m atoms "f"
      do f = 1,.molecule(m).element.dim

         a = .molecule(m).element(f)

         ! Extract unit cell atom and asymmetric parent
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Molecule and asymmetric atom parent
         atom_f => mol_atom(f)
         atom_p => .asymmetric_unit_atom(p)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom_f.copy(atom_p)

         ! Transform the pADPs (which must be in cartesians)
         atom_f.transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom_f.set_position(.geometry(:,a))
         atom_f.set_axis_system_to("crystal")

      end

      ! Clean
      ulist.destroy

      ! Change coordinates to cartesian
      ! Errors (if any) are changed straightforwardly
      mol_atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

   end


   fragment_atom_indices result (res) ::: public
   ! Return the indices of the fragment atoms in the cluster.
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,"no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no fragment atoms")

      a,f :: INT

      ! Frag atom "f"
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (NOT .is_fragment_atom(a)) cycle

         ! Set the fragment atom index
         f = f + 1
         res(f) = a

      end

   end

   nonfragment_atom_indices result (res) ::: public
   ! Return the indices of the nonfragment atoms in the cluster.
      res :: VEC{INT}(.n_atoms-.n_fragment_atoms)

   ENSURE(.n_atoms>=.n_fragment_atoms,"no nonfragment atoms")
   ENSURE(.is_fragment_atom.associated,"no fragment atoms")

      a,f :: INT

      ! Frag atom "f"
      f = 0

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! Set the fragment atom index
         f = f + 1
         res(f) = a

      end

   end

   crystal_asym_unit_atom_indices result (res)
   ! Return the indices of the crystal asymmetric unit cell atoms
   ! corresponding to the fragment atoms of the *cluster*.
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,      "no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(.occupation_list.associated, "no occupation_list")

      f,i,code,u,a :: INT

      f = 0

      ! Loop over atoms
      do  i = 1,.n_atoms

         if (NOT .is_fragment_atom(i)) cycle

         code = .occupation_list(i)
         u    = CLUSTER_UA_FROM_CODE(code)
         a    = .asym_atom_for_unit_cell_atom(u)

         f      = f + 1
         res(f) = a

      end

   end

   crystal_frag_atom_indices result (res)
   ! Return the *crystal* fragment atom indices of the fragment atoms
   ! in the *cluster* (the two are not necessarily the same!)
      self :: IN
      res :: VEC{INT}(.n_fragment_atoms)

   ENSURE(.n_fragment_atoms>0,      "no fragment atoms")
   ENSURE(.is_fragment_atom.associated,"no is_fragment_atom")
   ENSURE(.occupation_list.associated, "no occupation_list")

      f,i,code,u,a :: INT

      f = 0

      ! Loop over atoms
      do  i = 1,.n_atoms

         if (NOT .is_fragment_atom(i)) cycle

         code = .occupation_list(i)
         u    = CLUSTER_UA_FROM_CODE(code)
         a    = .frag_atom_for_unit_cell_atom(u)

         f      = f + 1
         res(f) = a

      end

   end

!  =================
!  Cluster atom list
!  =================

   create_atom_list(atom) ::: leaky
   ! Create and make a new atom list for the cluster
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}*

   ENSURE(.fragment_geometry.associated, "no crystal fragment geometry")
   ENSURE(.asymmetric_unit_atom.associated, "no atom data")
   ENSURE(.n_atoms>0,"no atoms in cluster")

      atom.create(.n_atoms)
      .make_atom_list(atom)

   end

   make_atom_list(atom)
   ! Make a new atom list for the cluster. Note that the .asymmetric_unit_atom's
   ! must have ADP (thermal) tensors in the cartesian axis system; this will normally
   ! be the case for Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(atom.dim==.n_atoms,"wrong size, atomsr")
   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_unit_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "asymmetric_unit_atom not in cartesian axes")
   ENSURE(.molecule_for_atom.associated, "no molecule_for_atom info")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      a,u,p,s :: INT

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Seitz matrices
      seitz => .xyz_seitz_matrices

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         ! Extract unit cell atom, asymmetric parent and symop
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom(a).copy(.asymmetric_unit_atom(p))

         ! Transform the pADPs (which must be in cartesians)
         atom(a).transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         atom(a).set_position(.geometry(:,a))
         atom(a).set_axis_system_to("crystal")
         atom(a).set_group(.molecule_for_atom(a))

      end

      ! Change pos to cartesian
      ! Errors (if any) are changed straightforwardly
      atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Update labels/groups
      atom.update

      ! Free memory
      seitz.destroy
      ulist.destroy

   end

   make_atom_list(atom,list)
   ! Make a new atom list for the cluster from the indices in "list".
   ! Note that the .asymmetric_unit_atom's must have ADP tensors
   ! in the cartesian axis system; this will normally be the case for
   ! Tonto's internal representation ....
   ! NOTE: basis sets are pointer copied!
      self :: IN
      atom :: VEC{ATOM}, target, OUT
      list :: VEC{INT}, IN

   ENSURE(atom.dim==list.dim,"wrong size, atomsr")
   ENSURE(.geometry.associated,"no geometry")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")
   ENSURE(.asymmetric_unit_atom.has_cartesian_axes, "pADPs must be in cartn axis system")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      a,u,p,s :: INT
      atom_p, atom_a :: ATOM*

      ! Unit cell atoms which correspond to the *list* fragment atoms
      ulist.create(list.dim)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list(list))

      ! Seitz matrices
      seitz => .xyz_seitz_matrices

      ! Loop over cluster atoms "a"
      do a = 1, ulist.dim

         ! Extract unit cell atom, asymmetric parent and symop
         u = ulist(a)
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Cluster and asymmetric atom parent
         atom_a => atom(a)
         atom_p => .asymmetric_unit_atom(p)

         ! Copy the parent atom
         ! NOTE: .basis is a ptr copy
         atom_a.copy(atom_p)

         ! Transform the pADPs (which must be in cartesians)
         atom_a.transform_pADP_vector_with(seitz(:,:,s))

         ! Reset cluster atom pos from .geometry(:,a)
         ! NOTE: .basis is a ptr copy
         atom_a.set_position(.geometry(:,a))
         atom_a.set_axis_system_to("crystal")

      end

      ! Clean
      seitz.destroy
      ulist.destroy

      ! Change pos to cartesian
      ! Errors (if any) are changed straightforwardly
      atom.change_axis_system_to("cartesian",.unit_cell,FALSE)

      ! Update labels/groups
      atom.update

   end

!  ===============
!  Cluster charges
!  ===============

   make_non_fragment_mu_charges(pos,charge)
   ! Make a list of the non-fragment atom positions and point charges
   ! derived from the atomic charges and dipoles only.
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==3*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}*
      dipole :: VEC{REAL}(3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT
      r :: VEC{REAL}(3)

      ! Normal XYZ symops
      seitz => .xyz_seitz_matrices

      i = -2

      ! Loop over cluster atoms "a"
      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! Get the occ code
         code = .occupation_list(a)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Counter for 3 charges
         i = i + 3

         ! Get the cluster atom position
         r = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_matrix,r)

         ! Get parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Atomic charge
         charge(i) = .asymmetric_unit_atom(p).charge

         ! Atomic dipole
         dipole.to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

         ! Make the two charges
         ! Twice the shift along dipole direction
         d = TOL(2)
         mu = dipole.norm
         q = mu/d
         dipole = dipole/mu * d * HALF
         pos(:,i+1) = pos(:,i) + dipole
         pos(:,i+2) = pos(:,i) - dipole
         charge(i+1) =  q
         charge(i+2) = -q

      end

      ! Clean
      seitz.destroy

   end

   make_non_fragment_qq_charges(pos,charge)
   ! Make a list of the non-fragment atom positions and charges
   ! from the atomic charges, dipoles, and *quadrupoles*
      pos :: MAT{REAL}, OUT
      charge :: VEC{REAL}, OUT

   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(pos.dim2==9*(.n_atoms-.n_fragment_atoms),"wrong dim2, pos")
   ENSURE(charge.dim==pos.dim2,"wrong dim, charge")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.asymmetric_unit_atom.associated, "no asymmetric_cell_atom data")

      seitz  :: MAT3{REAL}*
      dipole,eval :: VEC{REAL}(3)
      quadrupole,evec :: MAT{REAL}(3,3)
      d,mu,q :: REAL
      a,i,code,h1,h2,h3,u, p,s :: INT
      r :: VEC{REAL}(3)

      ! NOrmal XYZ symops
      seitz => .xyz_seitz_matrices

      ! Counter for charges
      i = 1

      do a = 1,.n_atoms

         if (.is_fragment_atom(a)) cycle

         ! The occ code
         code = .occupation_list(a)

         ! Get unit cell atom "u" and cell offset "h"
         h1 = CLUSTER_H1_FROM_CODE(code)
         h2 = CLUSTER_H2_FROM_CODE(code)
         h3 = CLUSTER_H3_FROM_CODE(code)
         u  = CLUSTER_UA_FROM_CODE(code)

         ! Get the cluster atom position
         r = .unit_cell_geometry(:,u) + [h1,h2,h3] + .fragment_offset
         pos(:,i).to_product_of(.unit_cell.direct_matrix,r)

         ! Get parent asymmetric atom and symop
         p = .asym_atom_for_unit_cell_atom(u)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Atomic charge
         charge(i)  = .asymmetric_unit_atom(p).charge

         ! Atomic dipole
         dipole.to_product_of(seitz(:,:,s),.asymmetric_unit_atom(p).dipole)

         ! Atomic quadrupole
         .asymmetric_unit_atom(p).quadrupole.back_transform_to(quadrupole,seitz(:,:,s))

         ! Make the two charges
         d = TOL(2) ! Twice the shift along dipole direction
         mu = dipole.norm
         q = mu/d
         dipole = dipole/mu * d * HALF
         pos(:,i+1) = pos(:,i) + dipole
         pos(:,i+2) = pos(:,i) - dipole
         charge(i+1) =  q
         charge(i+2) = -q

         ! Make the diagonal quadrupoles
         ! Charge at d/2 along eigenvectors
         ! Should be x 4 for single charge
         quadrupole.solve_symmetric_eigenproblem(eval,evec)
         evec = d*evec/TWO
         eval = eval/(d*d)

         ! Two charges on axis at +d/2 and -d/2
         pos(:,i+3)   = pos(:,i) + evec(:,1)
         pos(:,i+4)   = pos(:,i) - evec(:,1)
         pos(:,i+5)   = pos(:,i) + evec(:,2)
         pos(:,i+6)   = pos(:,i) - evec(:,2)
         pos(:,i+7)   = pos(:,i) + evec(:,3)
         pos(:,i+8)   = pos(:,i) - evec(:,3)
         charge(i+3)  = TWO*eval(1)
         charge(i+4)  = TWO*eval(1)
         charge(i+5)  = TWO*eval(2)
         charge(i+6)  = TWO*eval(2)
         charge(i+7)  = TWO*eval(3)
         charge(i+8)  = TWO*eval(3)
         charge(i  )  = charge(i) & ! correct monopole charge
                      - FOUR*eval(1) - FOUR*eval(2) - FOUR*eval(3)

!        ! Four charges in the plane at
!        ! (+d/2,+d/2), (-d/2,-d/2)
!        ! (+d/2,-d/2), (-d/2,+d/2)
!        pos(:,i+9 )  = pos(:,i) + unit(:,1) + unit(:,2)
!        pos(:,i+10)  = pos(:,i) - unit(:,1) - unit(:,2)
!        pos(:,i+11)  = pos(:,i) + unit(:,1) - unit(:,2)
!        pos(:,i+12)  = pos(:,i) - unit(:,1) + unit(:,2)
!        charge(i+9 ) =  quadrupole(1,2)
!        charge(i+10) =  quadrupole(1,2)
!        charge(i+11) = -quadrupole(1,2)
!        charge(i+12) = -quadrupole(1,2)
!        pos(:,i+13)  = pos(:,i) + unit(:,1) + unit(:,3)
!        pos(:,i+14)  = pos(:,i) - unit(:,1) - unit(:,3)
!        pos(:,i+15)  = pos(:,i) + unit(:,1) - unit(:,3)
!        pos(:,i+16)  = pos(:,i) - unit(:,1) + unit(:,3)
!        charge(i+13) =  quadrupole(1,3)
!        charge(i+14) =  quadrupole(1,3)
!        charge(i+15) = -quadrupole(1,3)
!        charge(i+16) = -quadrupole(1,3)
!        pos(:,i+17)  = pos(:,i) + unit(:,2) + unit(:,3)
!        pos(:,i+18)  = pos(:,i) - unit(:,2) - unit(:,3)
!        pos(:,i+19)  = pos(:,i) + unit(:,2) - unit(:,3)
!        pos(:,i+20)  = pos(:,i) - unit(:,2) + unit(:,3)
!        charge(i+17) =  quadrupole(2,3)
!        charge(i+18) =  quadrupole(2,3)
!        charge(i+19) = -quadrupole(2,3)
!        charge(i+20) = -quadrupole(2,3)

         ! Increment charge counter
         i = i + 9

      end

      ! Clean
      seitz.destroy

   end

!  ===========
!  Add tensors
!  ===========

   add_uc_tensors(tensor) ::: template
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
      tensor :: TENSOR_TYPE

   ENSURE(.generation_method=="unit_cell","only for unit_cell clusters")
   ENSURE(.n_atoms>0,"no atoms in cluster")
   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.fragment_info_made,"no crystal fragment info")
   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      ulist :: VEC{INT}*
      seitz :: MAT3{REAL}*
      tensor0,tensor1 :: TENSOR_TYPE
      m,a,u,s :: INT

      tensor0 = tensor
      tensor = ZERO

      ! Unit cell atoms which correspond to the fragment atoms
      ulist.create(.n_atoms)
      ulist = CLUSTER_UA_FROM_CODE(.occupation_list)

      ! Inverse XYZ symops
      seitz => .transposed_xyz_seitz_matrices

      ! stdout.text("Making unit cell tensor")
      ! stdout.text("original tensor")
      ! stdout.put(tensor0)

      do m = 1,.n_unit_cell_mols
      do a = 1,.n_atoms

         if (.unit_cell_mol_for_atom(a)/=m) cycle

         ! Get symop for this molecule
         u = ulist(a)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Use inverse symop  S^T to change U tensor basis
         tensor0.change_basis_to(tensor1,seitz(:,:,s))
         tensor = tensor + tensor1

         ! stdout.show("molecule =",m)
         ! stdout.show("symop    =",s)
         ! stdout.put(seitz(:,:,s))
         ! stdout.text("transformed tensor")
         ! stdout.put(tensor1)

         exit

      end
      end

      ! Clean
      seitz.destroy
      ulist.destroy

   end

   add_uc_tensors(tensor) ::: get_from(CRYSTAL, TENSOR_TYPE=>MAT{REAL}(3,3))
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

   add_uc_tensors(tensor) ::: get_from(CRYSTAL, TENSOR_TYPE=>MAT3{REAL}(3,3,3))
   ! For a unit cell, add up a "tensor" property for one molecule, assumed to be
   ! the fragment_geometry.
   end

!  ==========================
!  Local field factor tensors
!  ==========================

   put_averaged_LFF_tensors
   ! Put the heavy-atom averaged local field factor dipole L tensors
   ! for the molecules in the unit cell. This uses the Reis formula.
      self :: INOUT

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
   ENSURE(.asymmetric_unit_atom.associated,"no asymetric cell atoms")

      n_mol,n_H,n,a,i1,i2,j1,j2,k1,k2,m1,m2 :: INT
      pos,pos0,com,L,L0,L1 :: MAT{REAL}*
      symop,non_H,par,mol,mol0 :: VEC{INT}*
      label0 :: VEC{STR}*

      ! Header
      stdout.flush
      stdout.text("Molecule-averaged Dipole L(1) tensor:")

      ! Get the positions, COM's for the molecules in the unit cell.
      ! By construction, the atoms in each molecule occur consecutively.
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get indices of non-Hydrogen-atom positions.
      n_mol = .n_unit_cell_mols
      n_H   = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,par.dim)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Set the non-Hydrogen-atom positions, molecules.
      label0.create(n_H)
      pos0.create(3,n_H)
      mol0.create(n_H)
      label0 = .asymmetric_unit_atom(par(non_H)).label
      pos0   = pos(:,non_H)
      mol0   = mol(non_H)

      non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Make the non-Hydrogen-atom Lorentz factor tensors
      L.create(3*n_mol,3*n_mol)
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      mol0.destroy; pos0.destroy

      ! Print monopole and dipole L tensor out
      n = n_H/n_mol
      stdout.flush
      stdout.text("Heavy-atom monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=4,real_fields=4)
      do i1 = 1,n_mol
      do i2 = 1,n_mol
      do j1 = 1,n
      do j2 = 1,n
         k1 = n*(i1-1) + j1
         k2 = n*(i2-1) + j2
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(i1)
         stdout.put(i2)
         stdout.put(trim(j1.to_str)//" "//trim(label0(k1)),int_width=TRUE)
         stdout.put(trim(j2.to_str)//" "//trim(label0(k2)),int_width=TRUE)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=4)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      end
      end
      stdout.dash(int_fields=4,real_fields=4)

      label0.destroy

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n
         do j2 = 1,n
            k1 = 3*(n*(i1-1)+j1-1)
            k2 = 3*(n*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      L = L/real(n*n,kind=REAL_KIND)

      ! Print averaged dipole L tensor
      stdout.flush
      stdout.text("Spackman's molecule-averaged Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Mol. 1",int_width=TRUE)
      stdout.put("Mol. 2",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do k1 = 1,n_mol
      do k2 = 1,n_mol
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L(m1+1,m2+1))
         stdout.put(L(m1+1,m2+2))
         stdout.put(L(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+2,m2+1))
         stdout.put(L(m1+2,m2+2))
         stdout.put(L(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L(m1+3,m2+1))
         stdout.put(L(m1+3,m2+2))
         stdout.put(L(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=3)

      ! Clean up
      L1.destroy
      L0.destroy
      L.destroy

   end

   put_centroid_LFF_tensors
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Reis formula.
      self :: INOUT

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n,i,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}*
      centroid,W :: MAT{REAL}*
      mol_for  :: VEC{INT}*

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      ! Allocate
      n = .n_unit_cell_mols
      L0.create(3*n,n)
      L1.create(3*n,3*n)

      ! Get centroids
      centroid.create(3,n)
      .get_uc_molecule_centroids(centroid)
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      W.create_copy(centroid)
      centroid.to_product_of(.unit_cell.direct_matrix,W)
      W.destroy
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      mol_for.create(n);   mol_for = [ (i,i=1,n) ]
      .unit_cell.make_LFF_tensors(L0,L1,centroid,mol_for)
      mol_for.destroy
      centroid.destroy

      ! Print monopole and dipole L tensor out
      stdout.flush
      stdout.text("Monopole L(0) tensor and Dipole L(1) tensor:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(0)")
      stdout.tab(real_fields=1)
      stdout.put("L(1)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=4)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L0(m1+1,k2))
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+2,k2))
         stdout.put(L1(m1+2,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush; stdout.tab(int_fields=2)
         stdout.put(L0(m1+3,k2))
         stdout.put(L1(m1+3,m2+1))
         stdout.put(L1(m1+3,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=4)

      ! Clean up
      L1.destroy
      L0.destroy

   end

   put_centroid_LFF_tensors_old
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell. This uses the Cummins code.
      self :: INOUT

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n,k,k1,k2 :: INT
      L2 :: MAT3{REAL}*
      centroid,W :: MAT{REAL}*

      ! Header
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      ! Allocate space
      n = .n_unit_cell_mols
      L2.create(3,3,n.triangle)
      centroid.create(3,n)

      ! Get unit cell molecule centroids
      .get_uc_molecule_centroids(centroid)
      stdout.flush
      stdout.text("Molecule centroids (cell coordinates):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Change centroids into cartesian
      W.create_copy(centroid)
      centroid.to_product_of(.unit_cell.direct_matrix,W)
      W.destroy
      stdout.flush
      stdout.text("Molecule centroids (cartesian/Bohr):")
      stdout.flush
      stdout.put(transpose(centroid))

      ! Make L tensor
      .unit_cell.make_LFF_tensors(L2,centroid)

      ! Print L tensor out
      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      k = 0
      do k1 = 1,n
      do k2 = 1,k1
         k = k + 1
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L2(1,1,k))
         stdout.put(L2(2,2,k))
         stdout.put(L2(3,3,k))
         stdout.put(L2(1,2,k))
         stdout.put(L2(1,3,k))
         stdout.put(L2(2,3,k))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      centroid.destroy
      L2.destroy

   end

   get_uc_molecule_centroids(centroid)
   ! Get the unit cell molecule centroids; they are transformed back
   ! into the unit cell if the defragmented molecule lies outside the
   ! unit cell.
      self :: IN
      centroid :: MAT{REAL}, OUT

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")
   ENSURE(all(shape(centroid)==[3,.n_unit_cell_mols]),"wrong shape, centroid")

      m,u :: INT
      geometry :: MAT{REAL}*

      centroid = ZERO

      do m = 1,.n_unit_cell_mols

         nullify(geometry)

         do u = 1,.n_unit_cell_atoms
            if (.unit_cell_mol_for_atom(u)/=m) cycle
            .do_defragment_uc_atom(u,geometry)
            exit
         end

         centroid(:,m) = geometry.sum_column_vectors/geometry.dim2
         .put_to_unit_cell(centroid(:,m))

         ! Clean
         geometry.destroy

      end

   end

   put_LFF_info
   ! Put the local field factor L tensors at the centroids of all
   ! molecules in the unit cell.
      self :: INOUT

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n,k1,k2,m1,m2 :: INT
      L0,L1 :: MAT{REAL}*
      mol,par :: VEC{INT}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      symop,alpha_m :: MAT3{REAL}*

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      ! Make the charge and dipole Lorentz factor tensors
      n = par.dim
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Output
      stdout.flush
      stdout.text("Local Field Factor L tensors:")
      stdout.flush
      stdout.show("n_unit_cell_atoms =",par.dim)
      stdout.show("n_unit_cell_mols  =",coc.dim2)
      stdout.flush
      stdout.text("Molecule atom positions:")
      stdout.flush
      stdout.put(transpose(pos))

      stdout.flush
      stdout.text("L tensors:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("k1",int_width=TRUE)
      stdout.put("k2",int_width=TRUE)
      stdout.put("L(xx)")
      stdout.put("L(yy)")
      stdout.put("L(zz)")
      stdout.put("L(xy)")
      stdout.put("L(xz)")
      stdout.put("L(yz)")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      do k1 = 1,n
      do k2 = 1,k1
         m1 = 3*(k1-1)
         m2 = 3*(k2-1)
         stdout.put(k1)
         stdout.put(k2)
         stdout.put(L1(m1+1,m2+1))
         stdout.put(L1(m1+2,m2+2))
         stdout.put(L1(m1+3,m2+3))
         stdout.put(L1(m1+1,m2+2))
         stdout.put(L1(m1+1,m2+3))
         stdout.put(L1(m1+2,m2+3))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=6)

      ! Clean up
      L1.destroy
      L0.destroy
      alpha_m.destroy
      alpha_q.destroy
      com.destroy
      coc.destroy
      par.destroy
      symop.destroy
      mol.destroy

   end

!  ======================
!  Susceptibility tensors
!  ======================

   make_chi1_naive(chi1,alpha_mol)
   ! Make the naive second order susceptibility from the
   ! polarisability of the molecule.
      chi1 :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      alpha_mol :: MAT{REAL}(3,3), IN

      alpha_uc :: MAT{REAL}(3,3)
      D :: MAT{REAL}*
      fac :: REAL

      .make_alpha_uc(alpha_uc,alpha_mol)

      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.unit_cell.volume

      D.create(3,3)
      D.to_unit_matrix
      D = D - fac*THIRD*alpha_uc
      D.to_inverse_of(D)
      chi1.to_scaled_product_of(alpha_uc,D,fac)
      D.destroy

   end

   make_alpha_uc(alpha_uc,alpha_mol)
   ! Make the unit cell alpha.
      self :: INOUT
      alpha_uc :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      alpha :: MAT{REAL}(3,3)
      mol,symop,par :: VEC{INT}*
      pos,com :: MAT{REAL}*
      inverse_seitz :: MAT3{REAL}*
      n_mol,m :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)
      com.destroy
      pos.destroy
      par.destroy
      mol.destroy

      ! No of molecules
      n_mol = symop.dim

      ! Transposed/Inverse symops
      inverse_seitz => .transposed_xyz_seitz_matrices

      ! Add up the polarisabilities
      alpha_uc = ZERO
      do m = 1,n_mol
         alpha_mol.change_basis_to(alpha,inverse_seitz(:,:,symop(m)))
         alpha_uc = alpha_uc + alpha
      end

      ! Clean
      inverse_seitz.destroy
      symop.destroy

   end


   make_chi1_ALFFA(chi1,alpha_mol)
   ! Make the ALFFA "chi1" matrix: chi = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol". The L
   ! tensors are evaluated at the molecular center-of_masses.
   ! The trace is over 3x3 blocks.
      self :: INOUT
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par :: VEC{INT}*
      inverse_seitz :: MAT3{REAL}*
      alpha :: MAT3{REAL}*
      pos,com, L0,L1, D,Df :: MAT{REAL}*
      alph :: MAT{REAL}(3,3)
      n_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      ! No. of molecules
      n_mol = .n_unit_cell_mols


      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get the molecule indices (they are consecutive by construction)
      mol0.create(n_mol)
      mol0 = [(m,m=1,n_mol)]

      ! Print out centroid info ... important
      stdout.flush
      stdout.text("Center of mass:")
      stdout.put(com(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      L0.create(dim,n_mol)
      L1.create(dim,dim)
      .unit_cell.make_LFF_tensors(L0,L1,com,mol0)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .transposed_xyz_seitz_matrices
      fac = FOUR*PI/.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the (inverse) D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy; alpha.destroy

   end

   make_chi1_RLFTn(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      self :: INOUT
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,non_H,par :: VEC{INT}*
      inverse_seitz :: MAT3{REAL}*
      alpha :: MAT3{REAL}*
      pos,pos0,com, L0,L1, D,Df :: MAT{REAL}*
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim,a,b,i,j,m :: INT
      fac :: REAL

      n     = .n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .n_unit_cell_mols ! No. of molecules

      ! No of non-hydrogen atoms in unit cell
      n_non_H = count(.asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! D matrix: D = (1 - aL)^-1
      dim = 3*n_non_H
      D.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get the reduced averaged site polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .transposed_xyz_seitz_matrices
      fac = FOUR*PI/.unit_cell.volume
      alph = fac*alpha_mol/n_non_H_per_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Get *indices* for non-H positions
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Print out position info ...
      if (.debugging("make_chi1_RLFTn")) then
      stdout.flush
      stdout.text("Arrays for non H calculation:")
      stdout.text("non_H:")
      stdout.put(non_H)
      stdout.text("pos0:")
      stdout.put(transpose(pos0))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("symop :")
      stdout.put(symop)
      stdout.text("Alpha for each molecule:")
      stdout.put(n_non_H_per_mol*alpha/fac,by_dim3_matrices=TRUE)
      stdout.text("UC Alpha :")
      stdout.put(sum(n_non_H_per_mol*alpha/fac,dim=3))
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      D.to_unit_matrix
      i = 0
      do a = 1,n_non_H
         j = 0
         do b = 1,n_non_H
            m  = (b-1)/n_non_H_per_mol + 1
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L1(i+1:i+3,j+1:j+3),alpha(:,:,m),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      pos0.destroy
      non_H.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi1 (RLFTn) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_non_H
         m = (a-1)/n_non_H_per_mol + 1
         chi1.plus_product_of(alpha(:,:,m),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy; alpha.destroy

   end

   make_chi1_RLFTn_av_L(chi1,alpha_mol)
   ! Make the RLFTn "chi1" matrix: chi1 = Tr_block a^1(1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensor, a^1 is the (symmetry
   ! transformed) molecular dipole polarisability "alpha_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites. The trace is over 3x3 blocks
      self :: INOUT
      chi1 :: MAT{REAL}(3,3), OUT
      alpha_mol :: MAT{REAL}(3,3), IN

      mol,mol0,symop,par,non_H :: VEC{INT}*
      inverse_seitz :: MAT3{REAL}*
      alpha :: MAT3{REAL}*
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}*
      alph :: MAT{REAL}(3,3)
      n,n_mol,n_non_H,n_non_H_per_mol,dim, i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n     = .n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .n_unit_cell_mols ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      inverse_seitz => .transposed_xyz_seitz_matrices
      fac = FOUR*PI/.unit_cell.volume
      alph = fac*alpha_mol
      do m = 1,n_mol
         alph.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy; L0.destroy
      mol0.destroy; pos0.destroy; non_H.destroy
      com.destroy; pos.destroy; par.destroy; symop.destroy; mol.destroy

      ! Print out position info ... important
      if (.debugging("make_chi1_RLFTn_av_L1")) then
      stdout.text("Averaged L1 tensor:")
      stdout.put(L)
      end

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi1 (ALFFA-like) susceptibility
      chi1 = ZERO
      i = 0
      do a = 1,n_mol
         chi1.plus_product_of(alpha(:,:,a),Df(i+1:i+3,:))
         i = i + 3
      end

      ! Clean up
      Df.destroy; D.destroy
      L.destroy; alpha.destroy

   end

   make_chi2_RLFTn_av_L(chi2,beta_mol,alpha_mol)
   ! Make the RLFTn "chi2" matrix:
   !   chi2_ijk = \sum_S \beta^S_abc d^S_ai d^S_bj d^S_ck
   ! where d^S are the local field factor tensors and \beta^S are the (symmetry
   ! transformed) molecular dipole site-hyperpolarisability "beta_mol" divided
   ! by the number of non-Hydrogen atoms in a molecule.  The L tensors
   ! are evaluated at these non H atom sites, "S".
      self :: INOUT
      chi2      :: MAT3{REAL}(3,3,3), OUT
      beta_mol  :: MAT3{REAL}(3,3,3), IN
      alpha_mol :: MAT{REAL}(3,3), IN

      alph0 :: MAT{REAL}(3,3)
      beta0 :: MAT3{REAL}(3,3,3)
      inverse_seitz :: MAT3{REAL}*
      alpha :: MAT3{REAL}*
      beta :: MAT4{REAL}*
      pos,pos0,com, L,L0,L1, D,Df :: MAT{REAL}*
      mol,mol0,symop,par,non_H :: VEC{INT}*
      n,n_mol,n_non_H,n_non_H_per_mol,dim, i1,i2,j1,j2,k1,k2,m1,m2, a,b,i,j,m :: INT
      fac :: REAL

      n     = .n_unit_cell_atoms    ! No. of atoms in unit cell
      n_mol = .n_unit_cell_mols     ! No. of molecules

      ! Molecular polarisabilities
      alpha.create(3,3,n_mol)
      beta.create(3,3,3,n_mol)

      ! Molecule averaged L1
      dim = 3*n_mol
      L.create(dim,dim)

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,symop,par,pos,com)

      ! Get *indices* for non-H positions
      n_non_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_non_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! No. of non-H hydrogen atoms per molecule
      DIE_IF(mod(n_non_H,n_mol)/=0,"no of non-Hydrogen atoms wrong")
      n_non_H_per_mol = n_non_H/n_mol

      ! Get the non-H positions and molecules
      pos0.create(3,n_non_H)
      mol0.create(  n_non_H)
      pos0 = pos(:,non_H)
      mol0 = mol(  non_H)

      ! Get the reduced molecular polarisabilities
      ! fac = factor to reduce polarisabilities = 1/(2 eps_0 V)
      !     = (2 pi/V) ... in au since eps_0 = (4 pi)^{-1}.
      inverse_seitz => .transposed_xyz_seitz_matrices
      fac = TWO*PI/.unit_cell.volume
      alph0 = TWO*fac*alpha_mol
      beta0 =     fac*beta_mol
      do m = 1,n_mol
         alph0.change_basis_to(alpha(:,:,m),inverse_seitz(:,:,symop(m)))
         beta0.change_basis_to(beta(:,:,:,m),inverse_seitz(:,:,symop(m)))
      end
      inverse_seitz.destroy

      ! Make the non H charge and dipole Lorentz factor tensors
      dim = 3*n_non_H
      L0.create(dim,n_non_H)     ! charge L tensor
      L1.create(dim,dim)         ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Average the L(1) tensors over molecules
      L = ZERO
      do i1 = 1,n_mol
      do i2 = 1,n_mol
         m1 = 3*(i1-1)
         m2 = 3*(i2-1)
         do j1 = 1,n_non_H_per_mol
         do j2 = 1,n_non_H_per_mol
            k1 = 3*(n_non_H_per_mol*(i1-1)+j1-1)
            k2 = 3*(n_non_H_per_mol*(i2-1)+j2-1)
            L(m1+1:m1+3,m2+1:m2+3) = L(m1+1:m1+3,m2+1:m2+3) + L1(k1+1:k1+3,k2+1:k2+3)
         end
         end
      end
      end
      fac = ONE/(n_non_H_per_mol*n_non_H_per_mol)
      L = fac*L

      ! Mini Clean up
      L1.destroy
      L0.destroy
      mol0.destroy
      pos0.destroy
      non_H.destroy
      com.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Make the (inverse) D matrix: D = (1 - aL)^-1
      dim = 3*n_mol
      D.create(dim,dim)
      D.to_unit_matrix
      i = 0
      do a = 1,n_mol
         j = 0
         do b = 1,n_mol
            D(i+1:i+3,j+1:j+3).plus_scaled_product_of(L(i+1:i+3,j+1:j+3),alpha(:,:,b),-ONE)
            j = j + 3
         end
         i = i + 3
      end

      ! Invert
      D.to_inverse_of(D)

      ! Make the local field factors
      Df.create(dim,3)
      ::make_local_field_factors(Df,D)

      ! Make the chi2 susceptibility
      chi2 = ZERO
      i = 0
      do a = 1,n_mol
         beta(:,:,:,a).change_basis_to(beta0,Df(i+1:i+3,:))
         chi2 = chi2 + beta0
         i = i + 3
      end

      ! Clean up
      Df.destroy
      D.destroy
      L.destroy
      beta.destroy
      alpha.destroy

   end

! Old distributed polarisability code
! This code does the chi2 from hyperpolarizability

   make_susceptibility2(alpha_mol,beta_mol,uc_alpha,chi1_naive,chi1_centr,chi1_nonH,chi2_nonH,chi1_nc,chi1_do,chi1)
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      self :: INOUT
      alpha_mol  :: MAT{REAL}(3,3), IN
      beta_mol   :: MAT3{REAL}(3,3,3), IN
      uc_alpha   :: MAT{REAL}(3,3), OUT ! Unit cell alpha
      chi1_naive :: MAT{REAL}(3,3), OUT ! Clausius-Mossotti, L=1/3
      chi1_centr :: MAT{REAL}(3,3), OUT ! Dipoles at the COM
      chi1_nonH  :: MAT{REAL}(3,3), OUT ! Non-hydrogen model, RLFTn
      chi1_nc    :: MAT{REAL}(3,3), OUT ! No charge contributons to polarisability
      chi1_do    :: MAT{REAL}(3,3), OUT ! Atomic alpha used
      chi1       :: MAT{REAL}(3,3), OUT ! Distributed polarisability
      chi2_nonH  :: MAT3{REAL}(3,3,3)

   ENSURE(.asymmetric_unit_atom.associated,"no asymetric cell atoms")

      alph,al :: MAT{REAL}(3,3)
      beta,be :: MAT3{REAL}(3,3,3)
      L0,L1,Lm,D,Dnc,Ddo,Dd,AA, df :: MAT{REAL}*
      pos,pos0,coc,com,coc0,alpha_q :: MAT{REAL}*
      mol,mol0,par,non_H :: VEC{INT}*
      r,Lq :: VEC{REAL}*
      symop,alpha_m,alpha :: MAT3{REAL}*
      n,n_m,n_a,n_H,nH,a,b,i,j,m :: INT
      fac :: REAL

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      ! Get no of atoms in unit cell
      n = par.dim

      ! Factor to reduce polarisabilities (in au)
      fac = FOUR*PI/.unit_cell.volume

      ! Make the charge and dipole Lorentz factor tensors
      D.create(3*n,3*n)
      Dnc.create(3*n,3*n)
      Ddo.create(3*n,3*n)
      alpha.create(3,3,n)
      L0.create(3*n,n)
      L1.create(3*n,3*n)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Get the atomic alpha's
      alpha = ZERO
      AA.create(3,3)
      r.create(3)
      do a = 1,n
         r = pos(:,a) - coc(:,a)
         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
         alpha(:,:,a) = alpha(:,:,a) + AA
      end
      r.destroy; AA.destroy

      ! Make the D matrix
      D.to_unit_matrix
      Dnc.to_unit_matrix
      Ddo.to_unit_matrix
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Lq => L0(i+1:i+3,b)
            Lm => L1(i+1:i+3,j+1:j+3)

            Dd =>   D(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*Lq.outer_product_with(alpha_q(:,b))
            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))

            Dd => Dnc(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha_m(:,:,b))

            Dd => Ddo(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))

            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      Dnc.to_inverse_of(Dnc)
      Ddo.to_inverse_of(Ddo)
      L1.destroy
      L0.destroy

      ! Make the distributed polarisability chi1
      chi1 = ZERO
      chi1_nc = ZERO
      chi1_do = ZERO
      uc_alpha = ZERO
      AA.create(3,3)
      r.create(3)
      i = 0
      do a = 1,n
         r = pos(:,a) - coc(:,a)
         AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
         uc_alpha = uc_alpha + AA
         AA = fac*AA
         j = 0
         do b = 1,n
            Dd =>   D(i+1:i+3,j+1:j+3)
            chi1 = chi1 + matmul(AA,Dd)
            Dd => Dnc(i+1:i+3,j+1:j+3)
            chi1_nc = chi1_nc + matmul(AA,Dd)
            Dd => Ddo(i+1:i+3,j+1:j+3)
            chi1_do = chi1_do + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      r.destroy; AA.destroy
      alpha.destroy
      Ddo.destroy; Dnc.destroy; D.destroy

      ! ================================================

      ! Make chi1_naive
      D.create(3,3)
      D.to_unit_matrix
      D = D - fac*THIRD*uc_alpha
      D.to_inverse_of(D)
      chi1_naive = fac*matmul(uc_alpha,D)
      D.destroy

      ! ================================================

      ! Get the no of molecules
      n_m = maxval(mol)
      DIE_IF(mod(n,n_m)/=0,"no of atoms in a molecule is not integral")

      ! Get the no of atoms per molecule
      n_a = n/n_m

      ! Get the molecular alpha's
      alpha.create(3,3,n_m)
      alpha = ZERO
      AA.create(3,3)
      r.create(3)
      a = 0
      do m = 1,n_m
         do i = 1,n_a
            a = a + 1
            r = pos(:,a) - coc(:,a)
            AA = r.outer_product_with(alpha_q(:,a)) + alpha_m(:,:,a)
            alpha(:,:,m) = alpha(:,:,m) + AA
         end
      end
      r.destroy; AA.destroy

      ! Get the centroids, use COM
      coc0.create(3,n_m)
      mol0.create(n_m)
      coc0 = com(:,1:(n_m-1)*n_a+1:n_a)
      mol0 = mol(1:(n_m-1)*n_a+1:n_a)

      ! Print out centroid info ... important
      stdout.flush
      stdout.show("Center of mass =",coc0(:,1))

      ! Make the centroid charge and dipole Lorentz factor tensors
      D.create(3*n_m,3*n_m)
      L0.create(3*n_m,n_m)
      L1.create(3*n_m,3*n_m)
      .unit_cell.make_LFF_tensors(L0,L1,coc0,mol0)

      ! Print out centroid info ... important

      if (.debugging("make_susceptibility2")) then
      stdout.flush
      stdout.text("Arrays for centroid calculation:")
      stdout.text("coc0 (center of mass):")
      stdout.put(transpose(coc0))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      stdout.text("Alpha for each molecule:")
      stdout.put(alpha,by_dim3_matrices=TRUE)
      end

      ! Make the D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_m
         j = 0
         do b = 1,n_m
            Dd => D(i+1:i+3,j+1:j+3)
            Lm => L1(i+1:i+3,j+1:j+3)
            Dd = Dd - fac*matmul(Lm,alpha(:,:,b))
            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      L1.destroy
      L0.destroy

      ! Make the chi1_centr susceptibility
      chi1_centr = ZERO
      AA.create(3,3)
      r.create(3)
      i = 0
      do a = 1,n_m
         AA = alpha(:,:,a)
         AA = fac*AA
         j = 0
         do b = 1,n_m
            Dd => D(i+1:i+3,j+1:j+3)
            chi1_centr = chi1_centr + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Clean up
      r.destroy; AA.destroy
      D.destroy
      mol0.destroy; coc0.destroy

      ! ================================================
      ! RLFTn
      ! ================================================

      ! Get non H positions.
      n_H = count(.asymmetric_unit_atom(par).atomic_number>1)
      non_H.create(n_H)
      non_H = pack([(a,a=1,n)],.asymmetric_unit_atom(par).atomic_number>1)

      ! Get the non H positions, indices, molecules.
      pos0.create(3,n_H)
      mol0.create(n_H)
      pos0 = pos(:,non_H)
      mol0 = mol(non_H)

      ! Make the non H charge and dipole Lorentz factor tensors
      D.create(3*n_H,3*n_H)        ! (1 - aL)^-1
      df.create(3*n_H,3)           ! local field factor tensor
      L0.create(3*n_H,n_H)         ! charge L tensor
      L1.create(3*n_H,3*n_H)       ! dipole L tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos0,mol0)

      ! Print out position info ... important
      if (.debugging("make_susceptibility2")) then
      stdout.flush
      stdout.text("Arrays for non H calculation:")
      stdout.text("non_H:")
      stdout.put(non_H)
      stdout.text("pos0:")
      stdout.put(transpose(pos0))
      stdout.text("mol0:")
      stdout.put(mol0)
      stdout.text("Dipole L1 tensor:")
      stdout.put(L1)
      end

      ! Get number of Non-H hydrogen atoms per molecule
      DIE_IF(mod(n_H,n_m)/=0,"no of non-Hydrogen atoms wrong")
      nH = n_H/n_m

      ! Average alpha over non-H sites
      alpha = alpha/nH

      ! Get the reduced average molecular polarisabilities
      alph = fac*alpha_mol/nH
      beta = fac*beta_mol/nH

      ! Make the D matrix
      D.to_unit_matrix
      i = 0
      do a = 1,n_H
         j = 0
         do b = 1,n_H
            Dd => D(i+1:i+3,j+1:j+3)
            Lm => L1(i+1:i+3,j+1:j+3)
            m  = (b-1)/nH + 1

            ! Old way
         !  Dd = Dd - fac*matmul(Lm,alpha(:,:,m))

            ! New way -- should be better -- check
            alph.change_basis_to(al,symop(:,:,m))
            Dd = Dd - matmul(Lm,al)

            j = j + 3
         end
         i = i + 3
      end
      D.to_inverse_of(D)
      L1.destroy
      L0.destroy

      ! Make the chi1_nonH susceptibility
      chi1_nonH = ZERO
      AA.create(3,3)
      i = 0
      do a = 1,n_H
         m  = (a-1)/nH + 1
         AA = alpha(:,:,m)
         AA = fac*AA
         j = 0
         do b = 1,n_H
            Dd => D(i+1:i+3,j+1:j+3)
            chi1_nonH = chi1_nonH + matmul(AA,Dd)
            j = j + 3
         end
         i = i + 3
      end

      ! Local field factors
      df = ZERO
      i = 0
      do a = 1,n_H
         j = 0
         do b = 1,n_H
            df(i+1:i+3,:) = df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)
            j = j + 3
         end
         i = i + 3
      end

      ! Make the chi1_nonH and chi2_nonH susceptibility
      chi1_nonH = ZERO
      chi2_nonH = ZERO
      i = 0
      do a = 1,n_H
         m = (a-1)/nH + 1
         alph.change_basis_to(al,symop(:,:,m))
         chi1_nonH = chi1_nonH + matmul(al,df(i+1:i+3,:))
         beta.change_basis_to(be,symop(:,:,m))
         be.change_basis_using(df(i+1:i+3,:))
         chi2_nonH = chi2_nonH + be
         i = i + 3
      end
      chi2_nonH = HALF*chi2_nonH

      ! Clean up
      df.destroy; D.destroy
      mol0.destroy; pos0.destroy
      non_H.destroy
      alpha.destroy
      alpha_m.destroy; alpha_q.destroy
      com.destroy; coc.destroy; pos.destroy
      par.destroy; symop.destroy; mol.destroy

   end

   make_local_field_factors(Df,D) ::: selfless, PURE
   ! Make the second ortder susceptibility from distributed
   ! polarisabilities.
      Df :: MAT{REAL}, OUT
      D  :: MAT{REAL}, IN

   ENSURE(D.is_square,     "non square D")
   ENSURE(mod(D.dim1,3)==0,"D dim1 is not divisible by 3")
   ENSURE(Df.dim1==D.dim1, "wrong dim1, Df")
   ENSURE(Df.dim2==3,      "wrong dim2, Df")

      n,a,b,i,j :: INT

      n = D.dim1/3

      Df = ZERO
      i = 0
      do a = 1,n
         j = 0
         do b = 1,n
            Df(i+1:i+3,:) = Df(i+1:i+3,:) + D(i+1:i+3,j+1:j+3)
            j = j + 3
         end
         i = i + 3
      end

   end

! These are for more complicated calculations

   make_D_matrix(D)
   ! Make the D matrix: D = (1 - L^0 a^0 - L^1 a^1)^-1
   ! where L^0 and L^1 are the monopole and dipole L tensors and
   ! where a^0 and a^1 are the monopole and dipole polarisabilities
   ! for every atom site at which the L tensors are evaluated.
      self :: INOUT
      D :: MAT{REAL}, target, OUT

   ENSURE(D.is_square,  "non square D")

      mol,par :: VEC{INT}*
      symop,alpha_m :: MAT3{REAL}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      L0,L1,Lm, DD :: MAT{REAL}*
      Lq :: VEC{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.unit_cell.volume

      ! Get the electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = D.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      D.to_unit_matrix

      i = 0
      do a = 1,n

         j = 0
         do b = 1,n

            Lq => L0(i+1:i+3,b)
            Lm => L1(i+1:i+3,j+1:j+3)

            DD =>   D(i+1:i+3,j+1:j+3)
            DD = DD - fac*Lq.outer_product_with(alpha_q(:,b))
            DD.plus_scaled_product_of(Lm,alpha_m(:,:,b),-fac)

            j = j + 3
         end

         i = i + 3
      end

      ! Clean up
      alpha_m.destroy
      alpha_q.destroy
      L1.destroy
      L0.destroy

      ! Invert
      D.to_inverse_of(D)

   end

   make_Dnc_matrix(Dnc)
   ! Make the Dnc matrix: Dnc = (1 - L^1 a^1)^-1
   ! where L^1 is the dipole L tensors and where a^1 is the dipole
   ! polarisability for every atom site at which the L tensors are
   ! evaluated.  NOTE: Dnc means "no charge dipole terms"
      self :: INOUT
      Dnc :: MAT{REAL}, target, OUT

   ENSURE(Dnc.is_square,"non square Dnc")

      mol,par :: VEC{INT}*
      symop,alpha_m :: MAT3{REAL}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      L0,L1,Lm, DD :: MAT{REAL}*
      n,dim,a,b,i,j :: INT
      fac :: REAL

      ! Factor to reduce polarisabilities = 1/(eps_0 V) (in au)
      fac = FOUR*PI/.unit_cell.volume

      ! Get the unit cell electrical properties for each atom
      .get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m)

      alpha_q.destroy
      com.destroy
      coc.destroy
      pos.destroy
      par.destroy
      symop.destroy
      mol.destroy

      ! Get no of atoms in unit cell
      n   = par.dim
      dim = Dnc.dim1
      ENSURE(dim==3*n,"wrong size, par array")

      ! Make the charge and dipole Lorentz factor tensors
      L0.create(dim,n)
      L1.create(dim,dim)
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol)

      ! Make the (inverse) D matrix
      Dnc.to_unit_matrix

      i = 0
      do a = 1,n

         j = 0
         do b = 1,n

            Lm => L1(i+1:i+3,j+1:j+3)

            DD => Dnc(i+1:i+3,j+1:j+3)
            DD.plus_scaled_product_of(Lm,alpha_m(:,:,b),-fac)

            j = j + 3
         end

         i = i + 3
      end

      ! Clean up
      L1.destroy
      L0.destroy

      ! Invert
      Dnc.to_inverse_of(Dnc)

   end

!  ===============
!  Electric fields
!  ===============

   make_Lorentz_fields(F,sphere_sum)
   ! Make the Lorentz electric fields at the unit cell atom sites.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where catomic harges and dipoles have been done.
      self :: INOUT
      F :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional, IN

      mol,frag_atom :: VEC{INT}*
      charge,dipole :: VEC{REAL}*
      pos,L0,L1 :: MAT{REAL}*
      fac :: REAL
      n_atom,dim, u,a, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom)

      ! Make the Lorentz factor tensors L0, L1
      n_atom = charge.dim
      dim    = dipole.dim
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)
      fac = FOUR*PI/.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign electric fields
      do a = 1,.n_fragment_atoms
         u = frag_atom.index_of_value(a) ! map to unit cell atom
         DIE_IF(u==0,"fragment atom "//trim(a.to_str)//" not found in cell")
         lu = 3*(u-1)
         fu = lu + 1
         lu = lu + 3
         F(:,a).to_product_of(L0(fu:lu,:),charge)
         F(:,a).plus_product_of(L1(fu:lu,:),dipole)
      end

      ! Clean up
      L1.destroy
      L0.destroy
      frag_atom.destroy
      dipole.destroy
      charge.destroy
      pos.destroy

   end

   make_Lorentz_interactions(I0,I1,sphere_sum)
   ! Make the Lorentz interactions with charges and dipoles due to
   ! dipoles ONLY at the unit cell atom sites. The charge-charge term
   ! is not calculated -- it does not affect the susceptibilities.
   ! Warning: the asymmetric_unit_atom's should be generated from the
   ! fragment where atomic charges and dipoles have been done.
      self :: INOUT
      I0 :: VEC{REAL}, OUT
      I1 :: MAT{REAL}, OUT
      sphere_sum :: BIN, optional, IN

      mol,frag_atom :: VEC{INT}*
      charge,dipole :: VEC{REAL}*
      pos,L0,L1 :: MAT{REAL}*
      fac :: REAL
      n_atom,dim, u,a, fu,lu :: INT

      ! Get the unit cell molecule atom info
      .get_uc_molecule_info(mol,pos,charge,dipole,frag_atom)

      ! Create L tensors
      n_atom = charge.dim        ! No of unit cell atoms
      dim    = dipole.dim        ! 3 x the above
      L0.create(dim,n_atom)      ! charge L0 tensor
      L1.create(dim,dim)         ! dipole L1 tensor

      ! Make the Lorentz factor tensors L0, L1
      .unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)

      fac = FOUR*PI/.unit_cell.volume
      L0 = fac*L0
      L1 = fac*L1

      ! Assign charge and dipole interactions
      ! Needs a minus sign when combined
      do a = 1,.n_fragment_atoms
         u = frag_atom.index_of_value(a) ! map to unit cell atom
         DIE_IF(u==0,"fragment atom "//trim(a.to_str)//" not found in cell")
         lu = 3*(u-1)
         fu = lu + 1
         lu = lu + 3
         I0(a)   = dot_product(L0(:,u),dipole)
         I1(:,a).to_product_of(L1(:,fu:lu),dipole,transpose_a=TRUE)
      end

      ! Clean up
      L1.destroy
      L0.destroy
      frag_atom.destroy
      dipole.destroy
      charge.destroy
      pos.destroy

   end

!  =====================================================
!  Cluster positions, charges, dipoles, polarisabilities
!  =====================================================

   get_uc_molecule_info(mol,symop,par,pos,com) ::: leaky
   ! Get the unit cell molecule information for a distributed local
   ! field factor (LFF) calculation. "mol" is the molecule index for
   ! an atom in the unit cell. "pos" are the positions. "par" is the
   ! asymmetric unit atom parent. "com" are the molecular center of
   ! masses.
      self :: INOUT
      mol,symop,par :: VEC{INT}*
      pos,com :: MAT{REAL}*

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      mass,mass0 :: VEC{REAL}*
      cm  :: VEC{REAL}(3)
      par0 :: VEC{INT}*
      pos0 :: MAT{REAL}*
      fac :: REAL

      ! Create the info arrays
      n_mol  = .n_unit_cell_mols
      n_atom = .n_unit_cell_atoms

      mol.create(n_atom)
      symop.create(n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      com.create(3,n_mol)
      mass.create(n_atom)

      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.n_unit_cell_atoms

            if (.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            par0     => par(  n+1:n+n_atom)
            pos0     => pos(:,n+1:n+n_atom)
            mass0    => mass( n+1:n+n_atom)

            .do_defragment_uc_atom(u,symop(m),par0,pos0,mass0)

            exit

         end

         ! Calculate the center of mass (COM)
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass0(a)*pos0(:,a)
         end
         fac = VEC{REAL}:sum_elements(mass0)
         fac = ONE/fac
         cm = fac*cm
         com(:,m) = cm

         n = n + n_atom

      end

      mass.destroy

   end

   get_uc_molecule_info(mol,symop,par,pos,coc,com,alpha_q,alpha_m) ::: leaky
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      self :: INOUT
      mol,par :: VEC{INT}*
      pos,coc,com,alpha_q :: MAT{REAL}*
      symop,alpha_m :: MAT3{REAL}*

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n_atom,n_mol,n,m,u,a :: INT
      charge,charge0,mass,mass0 :: VEC{REAL}*
      e_dipole,cm  :: VEC{REAL}(3)
      par0 :: VEC{INT}*
      symop0,pos0,dipole,dipole0,alpha_q0 :: MAT{REAL}*
      alpha_m0 :: MAT3{REAL}*
      fac :: REAL

      ! Sizes
      n_mol  = .n_unit_cell_mols
      n_atom = .n_unit_cell_atoms

      ! Create the info arrays
      mol.create(n_atom)
      symop.create(3,3,n_mol)
      par.create(n_atom)
      pos.create(3,n_atom)
      coc.create(3,n_atom)
      com.create(3,n_atom)
      alpha_q.create(3,n_atom)
      alpha_m.create(3,3,n_atom)
      charge.create(n_atom)
      mass.create(n_atom)
      dipole.create(3,n_atom)

      ! Set n_atom to the # of atoms in one molecule
      DIE_IF(mod(n_atom,n_mol)/=0,"# of unit cell atoms is not divisible by number of molecules")
      n_atom = n_atom/n_mol

      n = 0
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.n_unit_cell_atoms

            if (.unit_cell_mol_for_atom(u)/=m) cycle

            mol(n+1:n+n_atom) = m
            symop0   => symop(:,:,m)
            par0     => par(n+1:n+n_atom)
            pos0     => pos(:,n+1:n+n_atom)
            charge0  => charge(n+1:n+n_atom)
            mass0    => mass(n+1:n+n_atom)
            dipole0  => dipole(:,n+1:n+n_atom)
            alpha_q0 => alpha_q(:,n+1:n+n_atom)
            alpha_m0 => alpha_m(:,:,n+1:n+n_atom)

            .do_defragment_uc_atom(u,symop0,par0,pos0,charge0,mass0,dipole0,alpha_q0,alpha_m0)

            exit

         end

         ! Calculate electronic dipole and center of charge
         e_dipole = ZERO
         do a = 1,n_atom
            e_dipole = e_dipole + dipole0(:,a)
            e_dipole = e_dipole + charge0(a)*pos0(:,a)
         end
         fac = VEC{REAL}:sum_elements(charge0)
         fac = ONE/fac
         e_dipole = fac*e_dipole
         coc(:,n+1:n+n_atom) = spread(e_dipole,2,n_atom)

         ! Calculate the center of mass (COM): make coc the COM
         cm = ZERO
         do a = 1,n_atom
            cm = cm + mass0(a)*pos0(:,a)
         end
         fac = VEC{REAL}:sum_elements(mass0)
         fac = ONE/fac
         cm  = fac*cm
         com(:,n+1:n+n_atom) = spread(cm,2,n_atom)

         n = n + n_atom

      end

         ! Debug
       ! stdout.flush
       ! stdout.text("mol:")
       ! stdout.put(mol)
       ! stdout.text("pos:")
       ! stdout.put(transpose(pos))
       ! stdout.text("coc:")
       ! stdout.put(transpose(coc))
       ! stdout.text("charge:")
       ! stdout.put(charge)
       ! stdout.text("dipole:")
       ! stdout.put(transpose(dipole))
       ! stdout.text("alpha_q:")
       ! stdout.put(transpose(alpha_q))
       ! stdout.text("alpha_m:")
       ! do a = 1,alpha_m.dim3
       ! stdout.put(alpha_m(:,:,a))
       ! end

       dipole.destroy
       mass.destroy
       charge.destroy

   end

   get_uc_molecule_info(mol,pos,charge,dipole,frag_atom) ::: leaky
   ! Get the unit cell molecule information for a distributed local field factor
   ! (LFF) calculation. "coc" are the molecular center of charges.
      self :: INOUT
      mol :: VEC{INT}*
      pos :: MAT{REAL}*
      charge,dipole :: VEC{REAL}*
      frag_atom :: VEC{INT}*

   ENSURE(.unit_cell_mol_for_atom.associated,"no cell_mol_for_atom")

      n_atom,n_mol, n,n3,m,u :: INT
      charge0,dipole0 :: VEC{REAL}*
      occupation_list,frag_atom0 :: VEC{INT}*
      pos0 :: MAT{REAL}*

      ! Sizes
      n_mol  = .n_unit_cell_mols
      n_atom = .n_unit_cell_atoms

      ! Create the info arrays
      mol.create(n_atom)
      pos.create(3,n_atom)
      charge.create(n_atom)
      dipole.create(3*n_atom)
      frag_atom.create(n_atom)

      ! Counters
      n  = 0
      n3 = 0

      ! Loop over molecules m
      do m = 1,n_mol

         ! Find atom "u" on molecule "m", defragment, get the info
         do u = 1,.n_unit_cell_atoms

            if (.unit_cell_mol_for_atom(u)/=m) cycle

            ! Get the occ list for molecule m
            occupation_list.create(1)
            occupation_list(1) = CLUSTER_AT_CODE(0,0,0,u)
            .do_defragment(occupation_list)

            ! No of atoms in molecule m
            n_atom = occupation_list.dim

            ! Assign
            mol(n+1:n+n_atom) = m
            pos0       => pos(:,n+1:n+n_atom)
            charge0    => charge(n +1:n +  n_atom)
            dipole0    => dipole(n3+1:n3+3*n_atom)
            frag_atom0 => frag_atom(n +1:n +  n_atom)

            ! Get the info
            .extract_atom_info(occupation_list,pos0,charge0,dipole0,frag_atom0)

            ! Clean
            occupation_list.destroy

            exit

         end

         ! Increment
         n  = n  +   n_atom
         n3 = n3 + 3*n_atom

      end

   end

!  ==============
!  Cluster output
!  ==============

   put_cluster_info
   ! Put the list of vertices for the object
      self :: IN

   DIE_IF(NOT .cluster_info_made,"call make_cluster_info first")
   DIE_IF(tonto.disassociated,"no tonto variable")

      stdout.flush
      stdout.text("==============================")
      stdout.text("Cluster generation information")
      stdout.text("==============================")

      stdout.flush
      stdout.show("Cluster generation method       =",.generation_method)
      stdout.show("Complete connected fragments?   =",.defragment)
      stdout.show("Radius of cluster               =",.radius)
      stdout.flush
      stdout.show("No. of molecules                =",.n_molecules)
      stdout.show("No. of atoms                    =",.n_atoms)
      stdout.show("No. of fragment atoms           =",.n_fragment_atoms)
      stdout.flush
      stdout.show("Fragment offset                 =",.fragment_offset)
      stdout.show("Minimum cell shift for search   =",.h_min)
      stdout.show("Maximum cell shift for search   =",.h_max)

      if (.fragment_geometry.associated)    .put_central_fragment_coords
      if (.occupation_list.associated)      .put_occupation_list
  !   if (.atom_connection.associated)      .put_atom_connection_table

   end

   put_central_fragment_coords
   ! Put the initial fragment geometry information
      self :: IN

   ENSURE(.fragment_geometry.associated,"no fragment_geometry")
   ENSURE(.fragment_atom.associated,"no fragment_atom")

      ID :: VEC{STR}*
      ind :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.text("=======================================")
      stdout.text("Central fragment fractional coordinates")
      stdout.text("=======================================")

      stdout.flush
      stdout.show("No. of fragment atoms =",.n_fragment_atoms)
      stdout.flush

      ! Unique ID tags
      ind.create_copy(.crystal_frag_atom_indices)
      ID => .fragment_atom(ind).unique_tags

      ! Table
      table.create(4)
      table(1).set_heading("ID");    table(1).set_values(ID)
      table(3).set_heading("Coord")
      table(2).set_subhead("- x -"); table(2).set_values(.fragment_geometry(1,:))
      table(3).set_subhead("- y -"); table(3).set_values(.fragment_geometry(2,:))
      table(4).set_subhead("- z -"); table(4).set_values(.fragment_geometry(3,:))
      table(3).set_sb3head("/frac")
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      ID.destroy
      ind.destroy

   end

   put_occupation_list
   ! Put the .occupation_list table
      self :: IN

   ENSURE(.occupation_list.associated,"no occupation_list")
   ENSURE(.unit_cell_geometry.associated,"no crystal unit cell geometry")
   ENSURE(.asym_symop_for_unit_cell_atom.associated,"no asym_symop_for_unit_cell_atom")
   ENSURE(.asym_shift_for_unit_cell_atom.associated,"no asym_shift_for_unit_cell_atom")

      ua,aa, h1,h2,h3, sy,s1,s2,s3,ac,ao :: VEC{INT}*
      r1,r2,r3 :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*
      n :: INT

      stdout.flush
      stdout.text("=============")
      stdout.text("Cluster atoms")
      stdout.text("=============")

      stdout.flush
      stdout.show("No. of atoms =",.n_atoms)

      stdout.flush
      stdout.text("The table below is understood as follows:")
      stdout.flush
      stdout.text("  #          = Cluster atom index")
      stdout.text("  (xyz)      = Cluster atom coord (fractional)")
      stdout.text("  UA         = Unit cell atom index which generates (xyz)")
      stdout.text("  Mol        = Molecule index")
      stdout.flush              
      stdout.text("where")      
      stdout.flush              
      stdout.text("  (xyz)      = (UA xyz) + (h1 h2 h3)")
      stdout.text("  (UA xyz)   = Unit cell atom coord")
      stdout.text("  (h1 h2 h3) = Unit cell atom shift = US")
      stdout.flush              
      stdout.text("Also")       
      stdout.flush              
      stdout.text("  (xyz)      = Op(AA xyz) + (s1 s2 s3) + (h1 h2 h3)")
      stdout.text("  (UA xyz)   = Op(AA xyz) + (s1 s2 s3)")
      stdout.flush              
      stdout.text("where")      
      stdout.flush              
      stdout.text("  Op         = Seitz symmetry operator")
      stdout.text("  (AA xyz)   = Asym cell atom coord")
      stdout.text("  (s1 s2 s3) = Asym cell atom shift = AS")
      stdout.text("  AA         = Asym cell atom index which generates (xyz)")
      stdout.text("  AA code    = Asym atom code to make (xyz) from AA")
      stdout.text("             = Op | h1+s1+5 | h2+s2+5 | h3+s3+5")
      stdout.text("  AO code    = AA | Op")
      stdout.flush



      ! Data
      n = .occupation_list.dim

      ua.create(n)
      aa.create(n)
      h1.create(n); h2.create(n); h3.create(n)
      sy.create(n)
      s1.create(n); s2.create(n); s3.create(n)
      r1.create(n); r2.create(n); r3.create(n)
      ac.create(n)
      ao.create(n)

      ua = CLUSTER_UA_FROM_CODE(.occupation_list)
      aa = .asym_atom_for_unit_cell_atom(ua)

      h1 = CLUSTER_H1_FROM_CODE(.occupation_list) + .fragment_offset(1)
      h2 = CLUSTER_H2_FROM_CODE(.occupation_list) + .fragment_offset(2)
      h3 = CLUSTER_H3_FROM_CODE(.occupation_list) + .fragment_offset(3)

      r1 = .unit_cell_geometry(1,ua) + h1
      r2 = .unit_cell_geometry(2,ua) + h2
      r3 = .unit_cell_geometry(3,ua) + h3

      sy = .asym_symop_for_unit_cell_atom(ua)
      s1 = .asym_shift_for_unit_cell_atom(1,ua)
      s2 = .asym_shift_for_unit_cell_atom(2,ua)
      s3 = .asym_shift_for_unit_cell_atom(3,ua)

      ac = 1000* sy
      ac = 100* (h1+5+s1) + ac
      ac = 10*  (h2+5+s2) + ac
      ac =      (h3+5+s3) + ac

      ao = 100* aa
      ao = sy + ao

      ! Table
      table.create(15)

      table( 1).set_heading(" UA")
      table( 1).set_values(ua)

      table( 2).set_heading("Mol")
      table( 2).set_values(.molecule_for_atom)

      table( 4).set_heading("(xyz)")

      table( 3).set_subhead("- x -")
      table( 4).set_subhead("- y -")
      table( 5).set_subhead("- z -")

      table( 3).set_values(r1)
      table( 4).set_values(r2)
      table( 5).set_values(r3)

      table( 7).set_heading("US")

      table( 6).set_subhead("h1")
      table( 7).set_subhead("h2")
      table( 8).set_subhead("h3")

      table( 6).set_values(h1)
      table( 7).set_values(h2)
      table( 8).set_values(h3)

      table( 9).set_heading("AA")
      table( 9).set_values(aa)

      table(10).set_heading("Op")
      table(12).set_heading("AS")

      table(11).set_subhead("s1")
      table(12).set_subhead("s2")
      table(13).set_subhead("s3")

      table(10).set_values(sy)
      table(11).set_values(s1)
      table(12).set_values(s2)
      table(13).set_values(s3)
             
      table(14).set_heading(" AA ")
      table(14).set_subhead("code")
      table(14).set_values(ac)
             
      table(15).set_heading(" AO ")
      table(15).set_subhead("code")
      table(15).set_values(ao)
             
      table.put

      ! Clean
      table.clear_columns
      table.destroy

      ao.destroy
      ac.destroy
      r3.destroy; r2.destroy; r1.destroy
      s3.destroy; s2.destroy; s1.destroy
      sy.destroy
      h3.destroy; h2.destroy; h1.destroy
      aa.destroy
      ua.destroy

   end

   put_atom_connection_table
   ! Put the .atom_connection table
      self :: IN

   ENSURE(.atom_connection.associated,"no atom_connection")
   ENSURE(.molecule_for_atom.associated,"no molecule_for_atom")

      m,a,i :: INT
      first :: BIN

      stdout.save
      stdout.set_int_width(5)

      stdout.flush
      stdout.text("Atom connection table:")
      stdout.flush
      stdout.show("n_molecules = ",.n_molecules)

      stdout.flush
      stdout.dash(int_fields=8)
      stdout.put("Cluster",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.flush

      stdout.put("Mol",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom(s)",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=8)

      do m = 1,.n_molecules

         ! Molecule label
         stdout.put(m)

         first = TRUE
         do a = 1,.n_atoms

            if (.molecule_for_atom(a)/=m) cycle

            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE

            if (.atom_connection(a).element.disassociated) then

               stdout.flush

            else

               do i = 1,.atom_connection(a).element.dim
                  stdout.put(.atom_connection(a)[i])
               end
               stdout.flush

            end
         end
      end

      stdout.dash(int_fields=8)

      stdout.unsave

   end

end
