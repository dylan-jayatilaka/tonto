!---------------------------------------------------------------------------
!
!  GAUSSIAN2 : Pairs of gaussian functions
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: gaussian2.foo 4354 2014-05-06 18:22:09Z bucinsky $
!---------------------------------------------------------------------------

module GAUSSIAN2

   implicit none

   pi212 :: REAL, private  = 1.1283791670955d+0  !2*Pi^-1/2

!  The i-th point and weight for n-point Gauss-Hermite quadrature

   first_pt :: VEC{INT}(9), private = [ 1,2,4, 7,11,16,22,29,37 ]
   last_pt  :: VEC{INT}(9), private = [ 1,3,6,10,15,21,28,36,45 ]

   gauss_hermite_pt :: VEC{REAL}(45), private

   data gauss_hermite_pt/                                                                      &
       0.000000000000000d+0,                                                                   & ! H_11
      -0.707106781186548d+0, 0.707106781186548d+0,                                             & ! H_12 H_22
      -1.224744871391590d+0, 0.000000000000000d+0, 1.224744871391590d+0,                       & ! H_13 H_23 H_33
      -1.650680123885780d+0,-0.524647623275290d+0, 0.524647623275290d+0, 1.650680123885780d+0, & ! H_*4
      -2.020182870456090d+0,-0.958572464613819d+0, 0.000000000000000d+0, 0.958572464613819d+0, & ! H_*5
       2.020182870456090d+0,                                                                   &
      -2.350604973674000d+0,-1.335849074014000d+0,-0.436077411928000d+0, 0.436077411928000d+0, & ! H_*6
       1.335849074014000d+0, 2.350604973674000d+0,                                             &
      -2.651961356835233d+0,-1.673551628767471d+0,-0.816287882858965d+0, 0.000000000000000d+0, & ! H_*7
       0.816287882858965d+0, 1.673551628767471d+0, 2.651961356835233d+0,                       &
      -2.930637420257244d+0,-1.981656756695843d+0,-1.157193712446780d+0,-0.381186990207322d+0, & ! H_*8
       0.381186990207322d+0, 1.157193712446780d+0, 1.981656756695843d+0, 2.930637420257244d+0, &
      -3.190993201781528d+0,-2.266580584531843d+0,-1.468553289216668d+0,-0.723551018752838d+0, & ! H_*9
       0.000000000000000d+0, 0.723551018752838d+0, 1.468553289216668d+0, 2.266580584531843d+0, &
       3.190993201781528d+0/

   gauss_hermite_wt :: VEC{REAL}(45), private

   data gauss_hermite_wt/                                                                      &
       1.772453850905520d+0,                                                                   & ! W_11
       0.886226925452800d+0, 0.886226925452800d+0,                                             & ! W_12 W_22
       0.295408975150900d+0, 1.181635900604000d+0, 0.295408975150900d+0,                       & ! W_13 W_23 W_33
       8.131283544725000d-2, 8.049140900055000d-1, 8.049140900055000d-1, 8.131283544725000d-2, & ! W_*4
       1.995324205905000d-2, 3.936193231522000d-1, 9.453087204829000d-1, 3.936193231522000d-1, & ! W_*5
       1.995324205905000d-2,                                                                   &
       4.530009905509000d-3, 1.570673203229000d-1, 7.246295952244000d-1, 7.246295952244000d-1, & ! W_*6
       1.570673203229000d-1, 4.530009905509000d-3,                                             &
       9.717812450995000d-4, 5.451558281913000d-2, 4.256072526101000d-1, 8.102646175568000d-1, & ! W_*7
       4.256072526101000d-1, 5.451558281913000d-2, 9.717812450995000d-4,                       &
       1.996040722114000d-4, 1.707798300741000d-2, 2.078023258149000d-1, 6.611470125582000d-1, & ! W_*8
       6.611470125582000d-1, 2.078023258149000d-1, 1.707798300741000d-2, 1.996040722114000d-4, &
       3.960697726326000d-5, 4.943624275537000d-3, 8.847452739438000d-2, 4.326515590026000d-1, & ! W_*9
       7.202352156061000d-1, 4.326515590026000d-1, 8.847452739438000d-2, 4.943624275537000d-3, &
       3.960697726326000d-5/

   gaussian_nucleus_eta :: VEC{REAL}(109), private

   data gaussian_nucleus_eta/                                                 &
      2.1248239171d+09, 1.1671538870d+09, 8.9266848806d+08, 7.8788802914d+08, &
      7.1178709563d+08, 6.8077502929d+08, 6.2865615725d+08, 5.8631436655d+08, &
      5.3546911034d+08, 5.2105715255d+08, 4.8349721509d+08, 4.7254270882d+08, &
      4.4335984491d+08, 4.3467748823d+08, 4.1117553148d+08, 4.0407992047d+08, &
      3.8463852873d+08, 3.5722217300d+08, 3.6228128110d+08, 3.5722217300d+08, &
      3.3451324570d+08, 3.2263108827d+08, 3.1181925878d+08, 3.0842641793d+08, &
      2.9881373610d+08, 2.9578406371d+08, 2.8716667270d+08, 2.8996391416d+08, &
      2.7665979354d+08, 2.7419021043d+08, 2.6267002737d+08, 2.5235613399d+08, &
      2.5042024280d+08, 2.4130163719d+08, 2.4305454351d+08, 2.3461213272d+08, &
      2.3301551109d+08, 2.2839354730d+08, 2.2690621893d+08, 2.2544431039d+08, &
      2.2120420724d+08, 2.1458511597d+08, 2.1458511597d+08, 2.0965270287d+08, &
      2.0846586999d+08, 2.0500935221d+08, 2.0389047621d+08, 1.9648639618d+08, &
      1.9548577691d+08, 1.9067718154d+08, 1.8975246242d+08, 1.8193056289d+08, &
      1.8444240538d+08, 1.8030529331d+08, 1.7950688281d+08, 1.7565009043d+08, &
      1.7490463170d+08, 1.7416744147d+08, 1.7343837120d+08, 1.7129844956d+08, &
      1.7060044589d+08, 1.6591550422d+08, 1.6527352089d+08, 1.6215880671d+08, &
      1.6155419421d+08, 1.5977529080d+08, 1.5977529080d+08, 1.5636673634d+08, &
      1.5581702004d+08, 1.5314257850d+08, 1.5262201512d+08, 1.5008710340d+08, &
      1.4959325643d+08, 1.4813689532d+08, 1.4671710337d+08, 1.4442808782d+08, &
      1.4398142103d+08, 1.4309883584d+08, 1.4223027307d+08, 1.4011788914d+08, &
      1.3888925203d+08, 1.3768840081d+08, 1.3729411599d+08, 1.3729411599d+08, &
      1.3690277000d+08, 1.3242350205d+08, 1.3206733609d+08, 1.3101367628d+08, &
      1.3066730974d+08, 1.2897067480d+08, 1.2930539512d+08, 1.2700881714d+08, &
      1.2733038109d+08, 1.2512299012d+08, 1.2543221826d+08, 1.2420711085d+08, &
      1.2420711085d+08, 1.2301273547d+08, 1.2271879740d+08, 1.2127611477d+08, &
      1.2099285491d+08, 1.2071131346d+08, 1.1987683191d+08, 1.2015331850d+08, &
      1.1987683191d+08, 1.1960199758d+08, 1.1987683191d+08, 1.1905722195d+08, &
      1.1878724932d+08/

contains

!  =================
!  Memory allocation
!  =================

   create ::: get_from(OBJECT), leaky
   ! Create an object. This does not nullify point parts or set
   ! defaults.
   end

   create(Ga,Gb) ::: leaky
   ! Create a gaussian pair, and optionally set it to "Ga" and "Gb"
      self :: PTR
      Ga,Gb :: GAUSSIAN

      .create
      .set(Ga,Gb)

   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   create_copy(G) ::: leaky
   ! Create a copy of "G"
      self :: PTR
      G :: GAUSSIAN2

      .create
      .copy(G)

   end

   copy(G)
   ! Set the gaussian pair object to "G"
      G :: GAUSSIAN2
      self = G
   end

!  ===========
!  Set methods
!  ===========

   set(Ga,Gb) ::: pure
   ! Set the gaussian pair object to "Ga" and "Gb"
      self :: INOUT
      Ga,Gb :: GAUSSIAN, IN

      .a.set(Ga)
      .b.set(Gb)

   end

   set(l_a,pos_a,ex_a,l_b,pos_b,ex_b) ::: pure
   ! Set a gaussian object
      self :: INOUT
      l_a,l_b :: INT, IN
      pos_a,pos_b :: VEC{REAL}(3), IN
      ex_a,ex_b :: REAL, IN

      .a.set_l(l_a)
      .a.set_position(pos_a)
      .a.set_exponent(ex_a)

      .b.set_l(l_b)
      .b.set_position(pos_b)
      .b.set_exponent(ex_b)

   end

   set(ex_a,ex_b) ::: pure
   ! Set the exponents of the pair
      self :: INOUT
      ex_a,ex_b :: REAL, optional, IN

      if (present(ex_a)) .a.set_exponent(ex_a)
      if (present(ex_b)) .b.set_exponent(ex_b)

   end

!  ==================
!  Fourier transforms
!  ==================

   make_e_coeff(e,comp) ::: pure
   ! Return the McMurchie-Davidson "e" coefficients for component "comp"
   ! (c) dylan jayatilaka, april 1995
   ! Checked using mathematica, may 1995
      self :: IN
      e :: MAT3{REAL}(0:,0:,0:), OUT
      comp :: INT, IN

      t,a,b,ap,am,bp,bm,abp,ab,abm,l_max,l_a,l_b :: INT
      R,gamma,g1,g2,a1,b1,e000 :: REAL

      l_a = .a.l
      l_b = .b.l
      l_max = l_a+l_b

      R = .a.position(comp) - .b.position(comp)

      gamma = .a.exponent + .b.exponent
      g1 = ONE/gamma
      b1 = .b.exponent*g1*R

      e000 = exp(-.a.exponent*b1*R)
      e(0,0,0) = e000

      ! Return for e000
      if (l_max==0) return

      g2 = HALF*g1
      a1 = .a.exponent*g1*R
      if (l_a>=1) then
         e(1,1,0) =  g2*e000
         e(0,1,0) = -b1*e000
      end
      if (l_b>=1) then
         e(1,0,1) =  g2*e000
         e(0,0,1) =  a1*e000
      end

      ! Return for eXX1
      if (l_max==1) return

      ! Consider case b=0
      do a = 1,l_a-1
         ap = a + 1
         am = a - 1
         e(ap,ap,0) =  g2*e( a,a,0)
         e( a,ap,0) =  g2*e(am,a,0) - b1*e(a,a,0)
         e( 0,ap,0) = -b1*e( 0,a,0) +    e(1,a,0)
         do t = 1,am
            e(t,ap,0) = g2*e(t-1,a,0) - b1*e(t,a,0) + (t+1)*e(t+1,a,0)
         end
      end

      ! Consider case a=0
      do b = 1,l_b-1
         bp = b + 1
         bm = b - 1
         e(bp,0,bp) =  g2*e( b,0,b)
         e( b,0,bp) =  g2*e(bm,0,b) + a1*e(b,0,b)
         e( 0,0,bp) =  a1*e( 0,0,b) +    e(1,0,b)
         do t = 1,bm
            e(t,0,bp) = g2*e(t-1,0,b) + a1*e(t,0,b) + (t+1)*e(t+1,0,b)
         end
      end

      ! Now do the rest, a/=0 & b/=0
      do b = 1,l_b
         do a = 0,l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e(abp,ap,b) =  g2*e( ab,a,b)
            e( ab,ap,b) =  g2*e(abm,a,b) - b1*e(ab,a,b)
            e(  0,ap,b) = -b1*e(  0,a,b) +    e( 1,a,b)
            do t = 1,abm
               e(t,ap,b) = g2*e(t-1,a,b) - b1*e(t,a,b) + (t+1)*e(t+1,a,b)
            end
         end
      end

   end

   make_e_coeff_derivative(e1,comp,e0) ::: pure, private
   ! Return the derivative McMurchie-Davidson "e1" coefficients for
   ! component "comp" with repect to R = .a.position - .b.position. The zero order
   ! derivative E coefficients "e0" for the same component must be supplied.
   ! This routine is based on Helgaker & Taylor, TCA 83, p. 177 (1992)
   ! (c) dylan jayatilaka, may 1998
      self :: IN
      comp :: INT, IN
      e0 :: MAT3{REAL}(0:,0:,0:), IN
      e1 :: MAT3{REAL}(0:,0:,0:), OUT ! Generic e coefficient table
      t,a,b,ap,am,bp,bm,abp,ab,abm,max :: INT
      R,gamma,g1,g2,a0,a1,b0,b1,e0000,e1000 :: REAL

      max = .a.l+.b.l
      R = .a.position(comp)-.b.position(comp)
      gamma = .a.exponent + .b.exponent
      g1 = 1/gamma

      b0 = .b.exponent*g1
      b1 = b0*R
      e0000  = e0(0,0,0)
      e1000 = -2*.a.exponent*b1*e0000
      e1(0,0,0) = e1000
      if (max==0) return                ! Return for e000

      a0 = .a.exponent*g1
      a1 = a0*R
      g2 = HALF*g1
      if (.a.l>=1) then
         e1(1,1,0) =  g2*e1000
         e1(0,1,0) = -b1*e1000 - b0*e0000
      end
      if (.b.l>=1) then
         e1(1,0,1) =  g2*e1000
         e1(0,0,1) =  a1*e1000 + a0*e0000
      end
      if (max==1) return                ! Return for eXX1

      do a = 1,.a.l-1                   ! Consider case b=0
         ap = a + 1
         am = a - 1
         e1(ap,ap,0) =  g2*e1( a,a,0)
         e1( a,ap,0) =  g2*e1(am,a,0) - b1*e1(a,a,0) - b0*e0(a,a,0)
         e1( 0,ap,0) = -b1*e1( 0,a,0) - b0*e0(0,a,0) +    e1(1,a,0)
         do t = 1,am
            e1(t,ap,0) = g2*e1(t-1,a,0) - b1*e1(t,a,0) - b0*e0(t,a,0) + (t+1)*e1(t+1,a,0)
         end
      end
      do b = 1,.b.l-1                   ! Consider case a=0
         bp = b + 1
         bm = b - 1
         e1(bp,0,bp) =  g2*e1( b,0,b)
         e1( b,0,bp) =  g2*e1(bm,0,b) + a1*e1(b,0,b) + a0*e0(b,0,b)
         e1( 0,0,bp) =  a1*e1( 0,0,b) + a0*e0(0,0,b) +    e1(1,0,b)
         do t = 1,bm
            e1(t,0,bp) = g2*e1(t-1,0,b) + a1*e1(t,0,b) + a0*e0(t,0,b) + (t+1)*e1(t+1,0,b)
         end
      end
      do b = 1,.b.l                     ! Now do the rest, a/=0 & b/=0
         do a = 0,.a.l-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e1(abp,ap,b) =  g2*e1( ab,a,b)
            e1( ab,ap,b) =  g2*e1(abm,a,b) - b1*e1(ab,a,b) - b0*e0(ab,a,b)
            e1(  0,ap,b) = -b1*e1(  0,a,b) - b0*e0( 0,a,b) +    e1( 1,a,b)
            do t = 1,abm
               e1(t,ap,b) = g2*e1(t-1,a,b) - b1*e1(t,a,b) - b0*e0(t,a,b) + (t+1)*e1(t+1,a,b)
            end
         end
      end
   end

!   make_ft_component_old(res,comp,k_pts)
!   ! Do the Fourier transform of component "comp" of the guassian pair
!   ! evaluated at the points "k_pts"
!      self :: IN
!      res :: MAT3{CPX}(1:,0:,0:), OUT
!      comp :: INT, IN
!      k_pts :: VEC{REAL}, IN
!
!      kn,kn_t :: REAL
!      a,b,t,t_max,k_max,n :: INT
!      e :: MAT3{REAL}*
!      val1,val2,k2 :: VEC{REAL}*
!      k1 :: MAT{REAL}*
!
!      k_max = k_pts.dim
!      t_max = .a.l+.b.l
!
!      ! Make the E coefficients
!      e.create([0,t_max],[0,.a.l],[0,.b.l])
!      .make_e_coeff(e,comp)
!
!      select case (t_max)
!        case (0)
!          res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!        case (1)
!          if (.a.l==1) then ! ps
!            res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!            res(:,1,0) = COMPLEXIFY(e(0,1,0),e(1,1,0)*k_pts(:))
!          else !              sp
!            res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!            res(:,0,1) = COMPLEXIFY(e(0,0,1),e(1,0,1)*k_pts(:))
!          end
!        case (2)
!          select case (.a.l)
!            case (0) ! sd
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,0,1) = COMPLEXIFY(e(0,0,1),e(1,0,1)*k_pts(:))
!              res(:,0,2) = COMPLEXIFY(e(0,0,2)-e(2,0,2)*k_pts(:)*k_pts(:),e(1,0,2)*k_pts(:))
!            case (1) ! pp
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,0,1) = COMPLEXIFY(e(0,0,1),e(1,0,1)*k_pts(:))
!              res(:,1,0) = COMPLEXIFY(e(0,1,0),e(1,1,0)*k_pts(:))
!              res(:,1,1) = COMPLEXIFY(e(0,1,1)-e(2,1,1)*k_pts(:)*k_pts(:),e(1,1,1)*k_pts(:))
!            case (2) ! ds
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,1,0) = COMPLEXIFY(e(0,1,0),e(1,1,0)*k_pts(:))
!              res(:,2,0) = COMPLEXIFY(e(0,2,0)-e(2,2,0)*k_pts(:)*k_pts(:),e(1,2,0)*k_pts(:))
!          end
!        case (3)
!          select case (.a.l)
!            case (0) ! sf
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,0,1) = COMPLEXIFY(e(0,0,1),e(1,0,1)*k_pts(:))
!              res(:,0,2) = COMPLEXIFY(e(0,0,2)-e(2,0,2)*k2(:),e(1,0,2)*k_pts(:))
!              res(:,0,3) = COMPLEXIFY(e(0,0,3)-e(2,0,3)*k2(:),(e(1,0,3)-e(3,0,3)*k2(:))*k_pts(:))
!              k2.destroy
!            case (1) ! pd
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,0,1) = COMPLEXIFY(e(0,0,1),e(1,0,1)*k_pts(:))
!              res(:,1,0) = COMPLEXIFY(e(0,1,0),e(1,1,0)*k_pts(:))
!              res(:,0,2) = COMPLEXIFY(e(0,0,2)-e(2,0,2)*k2(:),e(1,0,2)*k_pts(:))
!              res(:,1,1) = COMPLEXIFY(e(0,1,1)-e(2,1,1)*k2(:),e(1,1,1)*k_pts(:))
!              res(:,1,2) = COMPLEXIFY(e(0,1,2)-e(2,1,2)*k2(:),(e(1,1,2)-e(3,1,2)*k2(:))*k_pts(:))
!              k2.destroy
!            case (2) ! dp
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,0,1) = COMPLEXIFY(e(0,0,1),e(1,0,1)*k_pts(:))
!              res(:,1,0) = COMPLEXIFY(e(0,1,0),e(1,1,0)*k_pts(:))
!              res(:,1,1) = COMPLEXIFY(e(0,1,1)-e(2,1,1)*k2(:),e(1,1,1)*k_pts(:))
!              res(:,2,0) = COMPLEXIFY(e(0,2,0)-e(2,2,0)*k2(:),e(1,2,0)*k_pts(:))
!              res(:,2,1) = COMPLEXIFY(e(0,2,1)-e(2,2,1)*k2(:),(e(1,2,1)-e(3,2,1)*k2(:))*k_pts(:))
!              k2.destroy
!            case (3) ! fs
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!              res(:,1,0) = COMPLEXIFY(e(0,1,0),e(1,1,0)*k_pts(:))
!              res(:,2,0) = COMPLEXIFY(e(0,2,0)-e(2,2,0)*k2(:),e(1,2,0)*k_pts(:))
!              res(:,3,0) = COMPLEXIFY(e(0,3,0)-e(2,3,0)*k2(:),(e(1,3,0)-e(3,3,0)*k2(:))*k_pts(:))
!              k2.destroy
!          end
!        case default                            ! general routine
!          k1.create([1,k_max],[0,t_max])    ! Define k1 array containing
!          do n = 1,k_max                        ! powers k^n of k_pts
!            kn = k_pts(n)
!            kn_t = kn          ! t=0 is 1, has been optimised out below.
!            do t = 2,t_max     ! t=1 is k_pts(n), explicity written below.
!              kn_t = kn_t * kn
!              k1(n,t) = kn_t
!            end
!          end
!          val1.create(k_max)   ! val1 is real part
!          val2.create(k_max)   ! val2 is imaginary part
!          do a = 0,.a.l
!            do b = 0,.b.l
!              t_max = a+b
!              select case (t_max)
!                case (0)
!                  res(:,0,0) = COMPLEXIFY(e(0,0,0),ZERO)
!                case (1)
!                  res(:,a,b) = COMPLEXIFY(e(0,a,b),e(1,a,b)*k_pts(:))
!                case (2)
!                  val1(:) = e(0,a,b) - e(2,a,b)*k1(:,2)
!                  val2(:) = e(1,a,b)*k_pts(:)
!                  res(:,a,b) = COMPLEXIFY(val1(:),val2(:))
!                case default
!                  val1(:) = e(0,a,b)          - e(2,a,b)*k1(:,2)
!                  val2(:) = e(1,a,b)*k_pts(:) - e(3,a,b)*k1(:,3)
!                  do t = 3,t_max-3,4
!                    val1(:) = val1(:) + e(t,a,b)  *k1(:,t)  - e(t+2,a,b)*k1(:,t+2)
!                    val2(:) = val2(:) + e(t+1,a,b)*k1(:,t+1)- e(t+3,a,b)*k1(:,t+3)
!                  end
!                  select case (mod(t_max+1,4))
!                    case (0)
!                    case (1)
!                      val1(:) = val1(:) + e(t_max,a,b)*k1(:,t_max)
!                    case (2)
!                      val1(:) = val1(:) + e(t_max-1,a,b)*k1(:,t_max-1)
!                      val2(:) = val2(:) + e(t_max,a,b)  *k1(:,t_max)
!                    case (3)
!                      val1(:) = val1(:) + e(t_max-2,a,b)*k1(:,t_max-2) - &
!                                          e(t_max,a,b)  *k1(:,t_max)
!                      val2(:) = val2(:) + e(t_max-1,a,b)*k1(:,t_max-1)
!                  end
!                  res(:,a,b) = COMPLEXIFY(val1(:),val2(:))
!              end
!            end
!          end
!          val2.destroy
!          val1.destroy
!          k1.destroy
!      end
!      e.destroy
!   end

   make_ft_component(res,comp,k_pts) ::: PURE
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
      self :: IN
      res :: MAT3{CPX}(1:,0:,0:), OUT
      comp  :: INT, IN
      k_pts :: VEC{REAL}, IN

      e  :: MAT3{REAL}*
      kp :: MAT{REAL}*
      vr,vi :: VEC{REAL}*
      a,b,t,k_max,t_max :: INT

      k_max = k_pts.dim
      t_max = .a.l+.b.l

      ! Make the E coefficients
      e.create([0,t_max],[0,.a.l],[0,.b.l])
      .make_e_coeff(e,comp)

      ! Define kp array containing powers k_pts(n)^t
      if (t_max>0) then
         kp.create([1,k_max],[1,t_max])
         kp(:,1) = k_pts
         do t = 2,t_max
            kp(:,t) = kp(:,t-1)*k_pts
         end
         do t = 2,t_max
            if (mod(t,4)<=1) cycle
            kp(:,t) = -kp(:,t)
         end
      end

      ! Real, imaginary parts of answer: (vr,vi)
      vr.create(k_max)
      vi.create(k_max)

      do a = 0,.a.l
      do b = 0,.b.l

         t_max = a + b

         ! Real part
         vr = e(0,a,b)
         do t = 2,t_max,2
            vr = vr + e(t,a,b)*kp(:,t)
         end

         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a,b)*kp(:,t)
         end

         res(:,a,b) = COMPLEXIFY(vr,vi)

      end
      end

      vi.destroy; vr.destroy
      kp.destroy;  e.destroy

   end

   make_ft_dab_component(res,comp,k_pts,k_max) ::: private
   ! Do the Fourier transform of the derivative of component a minus b
   ! of a a pair of gaussians, for component "comp" of the guassian
   ! product pair, evaliated for the points "k_pts".
   ! Dimensions of res are [[1,size(k_pts)],[0,.a.l],[0,.b.l]].
      self :: IN
      comp,k_max :: INT, IN

      k_pts :: VEC{REAL}, IN
      res :: MAT3{CPX}(1:,0:,0:)
      kn,fac :: REAL
      a,b,t,t_max,n :: INT
      e0,e1 :: MAT3{REAL}*
      val :: VEC{REAL}*                      ! Local variables
      k1 :: MAT{REAL}*

      ! Define k1 array containing
      t_max = .a.l+.b.l
      k1.create([1,k_max],[0,t_max+1])
      do n = 1,k_max                       ! powers k^n of k_pts
         k1(n,0) = ONE
         kn = k_pts(n)
         do t = 1,t_max+1
            k1(n,t) = k1(n,t-1)*kn
         end
      end

      ! Now evaluate; use real arithmetic where possible
      val.create(k_max)
      e0.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(e0,comp)
      e1.create([0, .a.l+.b.l ],[0, .a.l ],[0, .b.l ])
      .make_e_coeff_derivative(e1,comp,e0)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the real part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            val = TWO*val
            res(:,a,b) = cmplx(val(:),ZERO,kind=CPX_KIND)
            val = ZERO                         ! Now do imaginary part ...
            do t = 1,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 3,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            val = TWO*val
            res(:,a,b) = res(:,a,b) + cmplx(ZERO,val(:),kind=CPX_KIND)
         end
      end

      fac = (.a.exponent-.b.exponent)/(.a.exponent+.b.exponent)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the imaginary part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            val = fac*val
            res(:,a,b) = res(:,a,b) + cmplx(ZERO,val(:),kind=CPX_KIND)
            val = ZERO                         ! Now do real part ...
            do t = 1,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            do t = 3,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            val = fac*val
            res(:,a,b) = res(:,a,b) + cmplx(val(:),ZERO,kind=CPX_KIND)
         end
      end

      ! Clean
      e1.destroy
      e0.destroy
      val.destroy
      k1.destroy

   end

   make_ft_da_db_component(da,db,comp,k_pts) ::: private
   ! Do the Fourier transform of the derivative w.r.t. the position of component
   ! a, "da", and the derivative w.r.t. the position of component b, "db", of
   ! the gaussian pair, for component "comp" (either x, y, z), evaluated for the
   ! points "k_pts".  Dimensions of "da", "db" are ([1,size(k_pts)],[0,.a.l],[0,.b.l]).
      self :: IN
      da,db :: MAT3{CPX}(1:,0:,0:)
      comp :: INT, IN
      k_pts :: VEC{REAL}, IN
      kn,fac_a,fac_b :: REAL
      a,b,t,t_max,k_max,n :: INT
      e0,e1 :: MAT3{REAL}*
      val :: VEC{REAL}*                      ! Local variables
      k1 :: MAT{REAL}*
      t_max = .a.l+.b.l
      k_max = da.dim1
      k1.create([1,k_max],[0,t_max+1]) ! Define k1 array containing
      do n = 1,k_max                       ! powers k^n of k_pts
         k1(n,0) = ONE
         kn = k_pts(n)
         do t = 1,t_max+1
            k1(n,t) = k1(n,t-1)*kn
         end
      end
      val.create(k_max)       ! Now evaluate; use real arithmetic where possible
      e0.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(e0,comp)
      e1.create([0, .a.l+.b.l ],[0, .a.l ],[0, .b.l ])
      .make_e_coeff_derivative(e1,comp,e0)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the real part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            da(:,a,b) =  COMPLEXIFY(val(:),ZERO)
            val = ZERO                         ! Now do imaginary part ...
            do t = 1,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 3,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            da(:,a,b) =  da(:,a,b) + COMPLEXIFY(ZERO,val(:))
            db(:,a,b) = -da(:,a,b)
         end
      end

      fac_a = .a.exponent/(.a.exponent+.b.exponent)
      fac_b = .b.exponent/(.a.exponent+.b.exponent)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the imaginary part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            da(:,a,b) = da(:,a,b) + fac_a*COMPLEXIFY(ZERO,val(:))
            db(:,a,b) = db(:,a,b) + fac_b*COMPLEXIFY(ZERO,val(:))
            val = ZERO                         ! Now do real part ...
            do t = 1,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            do t = 3,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            da(:,a,b) = da(:,a,b) + fac_a*COMPLEXIFY(val(:),ZERO)
            db(:,a,b) = db(:,a,b) + fac_b*COMPLEXIFY(val(:),ZERO)
         end
      end
      e1.destroy
      e0.destroy
      val.destroy
      k1.destroy
   end

   make_ft_dab(res,ft)
   ! Form the Fourier transform of the derivative of the product
   ! of two gaussians w.r.t. coordinates in shell b, from the zeroth
   ! derivative Fourier transform.  Dimensions of res are
   ! [[1,size(k_pts)],[0,l_a],[0,l_b]].
      self :: IN
      ft :: MAT3{CPX}(1:,0:,0:), IN
      res :: MAT3{CPX}(1:,0:,0:)
      a,b,l_a,l_b :: INT
      l_a = ubound(ft,2)-1
      l_b = ubound(ft,3)-1
      res = ZERO
      do a = 0,l_a
         do b = 0,l_b
            res(:,a,b) = res(:,a,b) - TWO*.b.exponent*ft(:,a,b+1)
            res(:,a,b) = res(:,a,b) + TWO*.a.exponent*ft(:,a+1,b)
            if (b>0) res(:,a,b) = res(:,a,b) + b*ft(:,a,b-1)
            if (a>0) res(:,a,b) = res(:,a,b) - a*ft(:,a-1,b)
         end
      end
   end

   make_ft(ft,k_pts) ::: PURE
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      self :: IN
      ft   :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, IN

   ENSURE(ft.dim1==k_pts.dim1,"inconsistent first dimension")
   ENSURE(k_pts.dim2==3,"second dimension of k_pts must be 3")

      select case (.a.l+.b.l)
      case (0);      .make_ft_00(ft(:,1,1),k_pts)
      case default;  .make_ft_XX(ft,k_pts)
      end

   end

   make_ft_00(ft,k_pts) ::: PURE
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! Specialised routine for .a.l=0 and .b.l=0.
      self :: IN
      ft   :: VEC{CPX}, OUT
      k_pts :: MAT{REAL}, IN

      pos :: VEC{REAL}(3)
      k_x,k_y,k_z :: VEC{REAL}@
      g1_exa,g1_exb, e00 :: REAL
      pifac,gamma,g1,g4,th,kk :: REAL
      k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k :: INT
      I :: CPX

      ! Constants
      I = COMPLEXIFY(ZERO,ONE)
      gamma = .a.exponent+.b.exponent
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Gaussian pair center
      g1_exa = g1*.a.exponent
      g1_exb = g1*.b.exponent
      P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
      P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
      P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)

      ! Reciprocal lattice K points
      k_x = k_pts(:,1)
      k_y = k_pts(:,2)
      k_z = k_pts(:,3)

      ! E coefficient
      pos = .a.position - .b.position
      e00 = exp(-.a.exponent*.b.exponent*dot_product(pos,pos)/gamma)
      pifac = pifac*e00

      ! Do the Fourier transform
      do k = 1,k_x.dim
         k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
         ft(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
      end

      ! Clean
      k_z.destroy
      k_y.destroy
      k_x.destroy

   end

   make_ft_XX(ft,k_pts) ::: PURE
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      self :: IN
      ft :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, target, IN

      ft_x,ft_y,ft_z       :: MAT3{CPX}@, target
      ft_xb, ft_yb, ft_zb  :: VEC{CPX}* ! pointers
      ft_xbx,ft_yby,ft_zbz :: MAT{CPX}* ! pointers
      prefac :: VEC{CPX}@
      g1_exa,g1_exb :: REAL
      pifac,gamma,g1,g4, dot1,dot2  :: REAL
      k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k_max,k :: INT
      k_x,k_y,k_z :: VEC{REAL}@
      ax,ay,az :: VEC{INT}@
      bx,by,bz :: VEC{INT}@
      a,xa,ya,za,fa,la :: INT
      b,xb,yb,zb,fb,lb :: INT
      bxlast,bylast,bzlast :: INT

      k_max = k_pts.dim1

      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
      prefac.create(k_max)

      gamma = .a.exponent+.b.exponent
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma
      g1_exa = g1*.a.exponent
      g1_exb = g1*.b.exponent

      P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
      P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
      P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)

      k_x = k_pts(:,1)
      k_y = k_pts(:,2)
      k_z = k_pts(:,3)

      ! Get the Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)
      .make_ft_component(ft_y,2,k_y)
      .make_ft_component(ft_z,3,k_z)
      do k = 1,k_max
         k1 = k_x(k)
         k2 = k_y(k)
         k3 = k_z(k)
         dot1 = k1*P1+k2*P2+k3*P3
         dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
         prefac(k) = pifac*exp(COMPLEXIFY(dot2,dot1))
      end

      ! Loop over shell pairs
      select case (.a.l)

      case (0)

         select case(.b.l)

         ! <S|S>
         case (0)
            ft(:,1,1) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,0,0)*prefac

         ! <S|P>
         case (1)
            ft(:,1,1) = ft_x(:,0,1)*ft_y(:,0,0)*ft_z(:,0,0)*prefac
            ft(:,1,2) = ft_x(:,0,0)*ft_y(:,0,1)*ft_z(:,0,0)*prefac
            ft(:,1,3) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,0,1)*prefac

         ! <S|X>
         case default
            do b = 0,.b.l ! incorporate prefac into ft_z
               ft_z(:,0,b) = ft_z(:,0,b) * prefac
            end
            fb = .b.first_gaussian
            lb = .b.last_gaussian
            bx = GAUSSIAN_DATA::px(fb:lb)
            by = GAUSSIAN_DATA::py(fb:lb)
            bz = GAUSSIAN_DATA::pz(fb:lb)
            bxlast = bx(1)
            bylast = by(1)
            bzlast = bz(1)
            ft_xb => ft_x(:,0,bxlast)
            ft_yb => ft_y(:,0,bylast)
            ft_zb => ft_z(:,0,bzlast)
            do b = 1,.b.n_comp    ! Loop over all elements and multiply prefactor
               xb = bx(b)
               yb = by(b)
               zb = bz(b)
               if (bxlast/=xb) then
                  ft_xb => ft_x(:,0,xb)
                  bxlast = xb
               end
               if (bylast/=yb) then
                  ft_yb=> ft_y(:,0,yb)
                  bylast = yb
               end
               if (bzlast/=zb) then
                  ft_zb=> ft_z(:,0,zb)
                  bzlast = zb
               end
               ft(:,1,b) = ft_xb(:)*ft_yb(:)*ft_zb(:)
            end
         end

      case (1)

         select case (.b.l)

         ! <P|S>
         case (0)
            ft(:,1,1) = ft_x(:,1,0)*ft_y(:,0,0)*ft_z(:,0,0)*prefac
            ft(:,2,1) = ft_x(:,0,0)*ft_y(:,1,0)*ft_z(:,0,0)*prefac
            ft(:,3,1) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,1,0)*prefac

         ! <P|P>
         case (1)
            ft_z(:,0,0) = ft_z(:,0,0) * prefac
            ft(:,1,1) = ft_x(:,1,1)*ft_y(:,0,0)*ft_z(:,0,0)
            ft(:,2,1) = ft_x(:,0,1)*ft_y(:,1,0)*ft_z(:,0,0)
            ft(:,3,1) = ft_x(:,0,1)*ft_y(:,0,0)*ft_z(:,1,0)*prefac
            ft(:,1,2) = ft_x(:,1,0)*ft_y(:,0,1)*ft_z(:,0,0)
            ft(:,2,2) = ft_x(:,0,0)*ft_y(:,1,1)*ft_z(:,0,0)
            ! don't change the order.
            ft_x(:,0,0) = ft_x(:,0,0) * prefac
            ft(:,3,2) = ft_x(:,0,0)*ft_y(:,0,1)*ft_z(:,1,0)
            ft(:,1,3) = ft_x(:,1,0)*ft_y(:,0,0)*ft_z(:,0,1)*prefac
            ft(:,2,3) = ft_x(:,0,0)*ft_y(:,1,0)*ft_z(:,0,1)
            ft(:,3,3) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,1,1)

         ! <P|X>
         case default
            fb = .b.first_gaussian
            lb = .b.last_gaussian
            bx = GAUSSIAN_DATA::px(fb:lb)
            by = GAUSSIAN_DATA::py(fb:lb)
            bz = GAUSSIAN_DATA::pz(fb:lb)
            do b = 0,.b.l
               ft_z(:,0,b) = ft_z(:,0,b) * prefac
            end
            do b = 1,.b.n_comp    ! Loop over all elements and multiply prefactor
               xb = bx(b)
               yb = by(b)
               zb = bz(b)
               ft_xb => ft_x(:,0,xb)
               ft_yb => ft_y(:,0,yb)
               ft_zb => ft_z(:,0,zb)
               ft(:,1,b) = ft_x(:,1,xb)*ft_yb        *ft_zb
               ft(:,2,b) = ft_xb        *ft_y(:,1,yb)*ft_zb
               ft(:,3,b) = ft_xb        *ft_yb        *ft_z(:,1,zb) * prefac(:)
            end
         end

      case default

         select case (.b.l)

         ! <X|S>
         case (0)
            do a = 0,.a.l
               ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
            end
            fa = .a.first_gaussian
            la = .a.last_gaussian
            ax = GAUSSIAN_DATA::px(fa:la)
            ay = GAUSSIAN_DATA::py(fa:la)
            az = GAUSSIAN_DATA::pz(fa:la)
            do a = 1,.a.n_comp
               xa = ax(a)
               ya = ay(a)
               za = az(a)
               ft(:,a,1) = ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
            end

         ! <X|P>
         case (1)
            do a = 0,.a.l ! incorporate prefac into ft_z
               ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
               ft_z(:,a,1) = ft_z(:,a,1) * prefac(:)
            end
            fa = .a.first_gaussian
            la = .a.last_gaussian
            ax = GAUSSIAN_DATA::px(fa:la)
            ay = GAUSSIAN_DATA::py(fa:la)
            az = GAUSSIAN_DATA::pz(fa:la)
            do a = 1,.a.n_comp
               xa = ax(a)
               ya = ay(a)
               za = az(a)
               ft(:,a,1) = ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
               ft(:,a,2) = ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
               ft(:,a,3) = ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
            end
        
         ! <X|X>
         ! This is the general routine.  It uses reduced
         ! multiplication, and pointers to minimise array finding.
         case default
            do b = 0,.b.l ! incorporate prefac into ft_z
            do a = 0,.a.l
               ft_z(:,a,b) = ft_z(:,a,b) * prefac(:)
            end
            end
            fa = .a.first_gaussian; la = .a.last_gaussian
            fb = .b.first_gaussian; lb = .b.last_gaussian
            ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
            bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)
            bxlast = bx(1)
            bylast = by(1)
            bzlast = bz(1)
            ft_xbx => ft_x(:,:,bxlast)
            ft_yby => ft_y(:,:,bylast)
            ft_zbz => ft_z(:,:,bzlast)
            do b = 1,.b.n_comp    ! Loop over all elements and multiply prefactor
               xb = bx(b)
               yb = by(b)
               zb = bz(b)
               if (bxlast/=xb) then
                  ft_xbx => ft_x(:,:,xb)
                  bxlast = xb
               end
               if (bylast/=yb) then
                  ft_yby=> ft_y(:,:,yb)
                  bylast = yb
               end
               if (bzlast/=zb) then
                  ft_zbz=> ft_z(:,:,zb)
                  bzlast = zb
               end
               do a = 1,.a.n_comp
                  xa = ax(a)
                  ya = ay(a)
                  za = az(a)
                  ft(:,a,b) = ft_xbx(:,xa+1)*ft_yby(:,ya+1)*ft_zbz(:,za+1)
               end
            end
         end
      end

      ! Clean
      k_z.destroy
      k_y.destroy
      k_x.destroy
      prefac.destroy
      ft_z.destroy
      ft_y.destroy
      ft_x.destroy

   end

   make_ft_v2(ft,k_pts)
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT3{CPX}
      k_pts :: MAT{REAL}, target

      ft_x,ft_y,ft_z :: MAT3{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      prefac :: VEC{CPX}*
      k_x,k_y,k_z :: VEC{REAL}*
      g1_exa,g1_exb :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k_max,a,b,k,fa,la,fb,lb :: INT
      I :: CPX

      ! Constants
      I = COMPLEXIFY(ZERO,ONE)
      gamma = .a.exponent+.b.exponent
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Space for fourier transform of each component
      k_max = k_pts.dim1
      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

      ! Reciprocal lattice K points
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)

      ! Gaussian pair center
      g1_exa = g1*.a.exponent
      g1_exb = g1*.b.exponent
      P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
      P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
      P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)

      ! Make prefactor
      prefac.create(k_max)
      do k = 1,k_max
         k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
         prefac(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
      end

      ! Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)
      .make_ft_component(ft_y,2,k_y)
      .make_ft_component(ft_z,3,k_z)

      ! Incorporate prefactor into ft_z
      do b = 0,.b.l
      do a = 0,.a.l
         ft_z(:,a,b) = ft_z(:,a,b) * prefac
      end
      end
      prefac.destroy

      ! Gaussian function power arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
      bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)

      ! Do the Fourier transform
      ft = ft_x(:,ax,bx)*ft_y(:,ay,by)*ft_z(:,az,bz)

      ! Clean up
      ft_z.destroy; ft_y.destroy; ft_x.destroy

   end

   make_ft_nabla(ft,k_pts)
   ! Calculates the Fourier transform of the current integrals for the product
   ! of two primitive gaussian functions, evaluated at a series of points
   ! "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft" is [k_max],[.a.l.n_comp],[.b.l.n_comp],[3
      self :: IN
      k_pts :: MAT{REAL}, IN
      ft :: MAT4{CPX}
      ci,prefac :: CPX
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3 :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      ax,ay,az,bx,by,bz :: VEC{INT}@
      ft_x,ft_y,ft_z,fd_x,fd_y,fd_z :: MAT3{CPX}*

      ! A few useful constants ...
      ci = IMAGIFY(ONE)
      k_max = k_pts.dim1
      gamma = .a.exponent+.b.exponent
      g1 = 1/gamma
      g4 = QUARTER*g1
      pifac = (PI/gamma)**(THREE/TWO)
      P1 = g1*(.a.exponent*.a.position(1)+.b.exponent*.b.position(1))
      P2 = g1*(.a.exponent*.a.position(2)+.b.exponent*.b.position(2))
      P3 = g1*(.a.exponent*.a.position(3)+.b.exponent*.b.position(3))

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
      bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)

      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
      .make_ft_component(ft_x,1,k_pts(:,1))       ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2))       ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3))
      fd_x.create([1,k_max],[0,.a.l],[0,.b.l])
      fd_y.create([1,k_max],[0,.a.l],[0,.b.l])
      fd_z.create([1,k_max],[0,.a.l],[0,.b.l])
      .make_ft_dab_component(fd_x,1,k_pts(:,1),k_max)   ! Get the Fourier transforms
      .make_ft_dab_component(fd_y,2,k_pts(:,2),k_max)   ! of the derivative of each
      .make_ft_dab_component(fd_z,3,k_pts(:,3),k_max)   ! component.
      do b = 1,.b.n_comp         ! Loop over all elements and multiply prefactor
         xb = bx(b)
         yb = by(b)
         zb = bz(b)
         do a = 1,.a.n_comp
            xa = ax(a)
            ya = ay(a)
            za = az(a)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft(k,a,b,1) = prefac*fd_x(k,xa,xb)*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft(k,a,b,2) = prefac*ft_x(k,xa,xb)*fd_y(k,ya,yb)*ft_z(k,za,zb)
               ft(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*fd_z(k,za,zb)
            end
         end
      end
      fd_z.destroy; fd_y.destroy; fd_x.destroy
      ft_z.destroy; ft_y.destroy; ft_x.destroy
   end

   make_ft_da_db(ft_da,ft_db,k_pts)
   ! Calculates the Fourier transform of the derivatives of the product
   ! of two primitive gaussian functions, w.r.t. positions of center a and b,
   ! "ft_ad", and "ft_db" respectively, evaluated at a series of points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft_da" and "ft_db" is ([k_max],[.a.l.n_comp],[.b.l.n_comp],3)
      self :: IN
      k_pts :: MAT{REAL}, IN
      ft_da,ft_db :: MAT4{CPX}
      ci,prefac :: CPX
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3 :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      ax,ay,az,bx,by,bz :: VEC{INT}@
      ft_x,ft_y,ft_z,fa_x,fa_y,fa_z,fb_x,fb_y,fb_z :: MAT3{CPX}*

      ! The imaginary constant i ...
      ci = IMAGIFY(ONE)
      k_max = k_pts.dim1
      gamma = .a.exponent+.b.exponent
      g1 = 1/gamma
      g4 = QUARTER*g1
      pifac = (PI/gamma)**(THREE/TWO)
      P1 = g1*(.a.exponent*.a.position(1)+.b.exponent*.b.position(1))
      P2 = g1*(.a.exponent*.a.position(2)+.b.exponent*.b.position(2))
      P3 = g1*(.a.exponent*.a.position(3)+.b.exponent*.b.position(3))

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
      bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)

      ft_x.create(1,k_max,0,.a.l,0,.b.l)
      ft_y.create(1,k_max,0,.a.l,0,.b.l)
      ft_z.create(1,k_max,0,.a.l,0,.b.l)
      .make_ft_component(ft_x,1,k_pts(:,1))        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2))        ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3))
      fa_x.create(1,k_max,0,.a.l,0,.b.l)
      fa_y.create(1,k_max,0,.a.l,0,.b.l)
      fa_z.create(1,k_max,0,.a.l,0,.b.l)
      fb_x.create(1,k_max,0,.a.l,0,.b.l)
      fb_y.create(1,k_max,0,.a.l,0,.b.l)
      fb_z.create(1,k_max,0,.a.l,0,.b.l)
      .make_ft_da_db_component(fa_x,fb_x,1,k_pts(:,1)) ! Get the Fourier transforms
      .make_ft_da_db_component(fa_y,fb_y,2,k_pts(:,2)) ! of the derivative of each
      .make_ft_da_db_component(fa_z,fb_z,3,k_pts(:,3)) ! component.
      do a = 1,.a.n_comp         ! Loop over all elements and multiply prefactor
         xa = ax(a)
         ya = ay(a)
         za = az(a)
         do b = 1,.b.n_comp
            xb = bx(b)
            yb = by(b)
            zb = bz(b)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft_da(k,a,b,1) = prefac*fa_x(k,xa,xb)*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft_da(k,a,b,2) = prefac*ft_x(k,xa,xb)*fa_y(k,ya,yb)*ft_z(k,za,zb)
               ft_da(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*fa_z(k,za,zb)
               ft_db(k,a,b,1) = prefac*fb_x(k,xa,xb)*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft_db(k,a,b,2) = prefac*ft_x(k,xa,xb)*fb_y(k,ya,yb)*ft_z(k,za,zb)
               ft_db(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*fb_z(k,za,zb)
            end
         end
      end
      fb_z.destroy; fb_y.destroy; fb_x.destroy
      fa_z.destroy; fa_y.destroy; fa_x.destroy
      ft_z.destroy; ft_y.destroy; ft_x.destroy
   end

   make_ft_r(ft,k_pts)
   ! Calculates the Fourier transform of the derivative of a product of two
   ! primitive gaussian functions, times vector r, evaluated at a series of
   ! points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft" is [k_max,.a.n_comp,.b.n_comp,3]
      ft :: MAT4{CPX}
      k_pts :: MAT{REAL}

      ci,prefac :: CPX
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3 :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      ax,ay,az,bx,by,bz :: VEC{INT}@
      ft_x,ft_y,ft_z :: MAT3{CPX}*

      ! A few useful constants ...
      ci = IMAGIFY(ONE)
      k_max = size(k_pts,1)
      gamma = .a.exponent+.b.exponent
      g1 = 1/gamma
      g4 = QUARTER*g1
      pifac = (PI/gamma)**(THREE/TWO)
      P1 = g1*(.a.exponent*.a.position(1)+.b.exponent*.b.position(1))
      P2 = g1*(.a.exponent*.a.position(2)+.b.exponent*.b.position(2))
      P3 = g1*(.a.exponent*.a.position(3)+.b.exponent*.b.position(3))

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
      bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)

      ft_x.create([1,k_max],[0,.a.l],[0,.b.l+1])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l+1])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l+1])

      ! Get the Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_pts(:,1))
      .make_ft_component(ft_y,2,k_pts(:,2))
      .make_ft_component(ft_z,3,k_pts(:,3))
      do a = 1,.a.n_comp         ! Loop over all elements and multiply prefactor
         xa = ax(a)
         ya = ay(a)
         za = az(a)
         do b = 1,.b.n_comp
            xb = bx(b)
            yb = by(b)
            zb = bz(b)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft(k,a,b,1) = prefac*(ft_x(k,xa,xb+1)+.b.position(1)*ft_x(k,xa,xb))*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft(k,a,b,2) = prefac*ft_x(k,xa,xb)*(ft_y(k,ya,yb+1)+.b.position(2)*ft_y(k,ya,yb))*ft_z(k,za,zb)
               ft(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*(ft_z(k,za,zb+1)+.b.position(3)*ft_z(k,za,zb))
            end
         end
      end
      ft_z.destroy
      ft_y.destroy
      ft_x.destroy
   end

   put_e_coeff(out)
   ! Put the McMurchie Davidson E coefficients to file "out"
      out :: TEXTFILE
      a,b,t :: INT
      Ex :: MAT3{REAL}*
      Ey :: MAT3{REAL}*
      Ez :: MAT3{REAL}*

      out.flush
      out.text("GAUSSIAN2 output:")
      out.flush
      out.text("Dylan Jayatilaka, University of Western Australia, March 1998")

      out.flush
      out.show("l_a   =",.a.l)
      out.show("l_b   =",.a.l)
      out.show("Ra    =",.a.position)
      out.show("Rb    =",.b.position)
      out.show("R     =",.a.position-.b.position)
      out.show("alpha =",.a.exponent)
      out.show("beta  =",.b.exponent)

      out.flush
      out.dash(int_fields=3,real_fields=3)
      out.put("a",int_width=TRUE)
      out.put("b",int_width=TRUE)
      out.put("t",int_width=TRUE)
      out.put("Ex(t,a,b)")
      out.put("Ey(t,a,b)")
      out.put("Ez(t,a,b)")

      out.flush
      Ex.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(Ex,1)
      Ey.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(Ey,2)
      Ez.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(Ez,3)
      out.dash(int_fields=3,real_fields=3)
      do a = 0,.a.l
      do b = 0,.b.l
      do t = 0,a+b
         out.put(a)
         out.put(b)
         out.put(t)
         out.put(Ex(t,a,b))
         out.put(Ey(t,a,b))
         out.put(Ez(t,a,b))
         out.flush
      end
      end
      end

      Ez.destroy
      Ey.destroy
      Ex.destroy

   end

!  ======================
!  CADPAC-style integrals
!  ======================

   normalisation_factor result (res)
   ! Return the normaliston factor assuming it is x^l
      res :: REAL
      res = .a.normalisation_factor * .b.normalisation_factor
   end

   change_to_spherical(C,S)
   ! Transform a cartesian integral block "C" to a spherical integral
   ! block "S"
      self :: IN
      C :: MAT{REAL}, IN
      S :: MAT{REAL}, OUT

      UU  :: VEC{EMAT{REAL}}@
      W,U :: MAT{REAL}@

      UU = GAUSSIAN_DATA::spherical_harmonics_for

      if ( .a.l<2 AND .b.l<2 ) then
         S = C             ! don't use this case
      else if ( .a.l>=2 AND .b.l>=2 ) then
         W.create(.a.n_comp,.b.n_sph)
         U = UU(.b.l).element
         W.to_product_of(C,U)
         U = UU(.a.l).element
         S.to_product_of(U,W,transpose_a=TRUE)
         W.destroy
      else if (.a.l<2 AND .b.l>=2) then
         U = UU(.b.l).element
         S.to_product_of(C,U)
      else if (.b.l<2 AND .a.l>=2) then
         U = UU(.a.l).element
         S.to_product_of(U,C,transpose_a=TRUE)
      end

   end

   change_to_spherical(C,S)
   ! Transform a cartesian integral block "C" to a spherical integral
   ! block "S"
      self :: IN
      C :: MAT{CPX}, IN
      S :: MAT{CPX}, OUT

      UU  :: VEC{EMAT{REAL}}@
      U :: MAT{REAL}@
      W :: MAT{CPX}@


      UU = GAUSSIAN_DATA::spherical_harmonics_for

      if ( .a.l<2 AND .b.l<2 ) then
         S = C             ! don't use this case
      else if ( .a.l>=2 AND .b.l>=2 ) then
         W.create(.a.n_comp,.b.n_sph)
         U = UU(.b.l).element
         W.to_product_of(C,U)
         U = UU(.a.l).element
         S.to_product_of(U,W,transpose_a=TRUE)
         W.destroy
      else if (.a.l<2 AND .b.l>=2) then
         U = UU(.b.l).element
         S.to_product_of(C,U)
      else if (.b.l<2 AND .a.l>=2) then
         U = UU(.a.l).element
         S.to_product_of(U,C,transpose_a=TRUE)
      end

   end


   make_normalised_overlap_ints(S,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      S :: MAT{REAL}
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_overlap_ints(S)
      elseif ( .a.l<2 AND .b.l<2 )  then
         .make_overlap_ints(S)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_overlap_ints(W)
         .change_to_spherical(W,S)
         W.destroy
      end

      S = S * .normalisation_factor

   end

   make_overlap_ints(S) ::: PURE
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      self :: IN
      S :: MAT{REAL}, OUT

      Sx,Sy,Sz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT
    ! a,b,aix,aiy,aiz,bix,biy,biz :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)

      .make_overlap_ints(Sx,1)
      .make_overlap_ints(Sy,2)
      .make_overlap_ints(Sz,3)

     ! The following loops can be simplified by the one line statement:
      S = Sx(ax,bx)*Sy(ay,by)*Sz(az,bz)

    ! do b = 1,.b.n_comp
    !   bix = bx(b)
    !   biy = by(b)
    !   biz = bz(b)
    !   do a = 1,.a.n_comp
    !     aix = ax(a)
    !     aiy = ay(a)
    !     aiz = az(a)
    !     S(a,b) = Sx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
    !   end
    ! end

      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      S = prefac*S

   end

   make_overlap_ints(Sx,x,max_a,max_b) ::: PURE
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! If present, "max_a" and "max_b" are used for the maximum angular momenta
   ! of centers (a) and (b) respectively -- for derivative integrals.
   ! Uses Gauss-Hermite quadrature.
      self :: IN
      Sx :: MAT{REAL}, OUT
      x :: INT, IN
      max_a,max_b :: INT, optional, IN

      p,t,rp,ax,bx,wt,pt,ra,rb :: REAL
      l_a,l_b, a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent
      t = sqrt(p)

      ax = .a.position(x)
      bx = .b.position(x)
      rp = (.a.exponent*ax + .b.exponent*bx)/p

      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
         end
      end
      end

   end

   make_S_1st_deriv_ints(AAx,AAy,AAz)
   ! Make the first derivative overlap integrals "AAx", "AAy" and "AAz" which are
   ! the derivatives of the overlap matrix elements with respect to position A.
   ! The derivatives with respect to position B are not evaluated. By translational
   ! invariance, they are just the negative of the derivatives w.r.t. A.
      AAx,AAy,AAz :: MAT{REAL}

      Sx,Sy,Sz, Dx,Dy,Dz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+2,.b.l+1); Sy.create(.a.l+2,.b.l+1); Sz.create(.a.l+2,.b.l+1)
      Dx.create(.a.l+1,.b.l+1); Dy.create(.a.l+1,.b.l+1); Dz.create(.a.l+1,.b.l+1)
      .make_overlap_ints(Sx,1,.a.l+1)
      .make_overlap_ints(Sy,2,.a.l+1)
      .make_overlap_ints(Sz,3,.a.l+1)

      ! Diffn. with respect to electron coordinates
      .differentiate(Sx,"left",Dx)
      .differentiate(Sy,"left",Dy)
      .differentiate(Sz,"left",Dz)

!     The following loops can be simplified by the statements:
!     AAx = -Dx(ax,bx)*Sy(ay,by)*Sz(az,bz)
!     AAy = -Sx(ax,bx)*Dy(ay,by)*Sz(az,bz)
!     AAz = -Sx(ax,bx)*Sy(ay,by)*Dz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          ! Minus sign for nuclear derivative
          AAx(a,b) = -Dx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
          AAy(a,b) = -Sx(aix,bix)*Dy(aiy,biy)*Sz(aiz,biz)
          AAz(a,b) = -Sx(aix,bix)*Sy(aiy,biy)*Dz(aiz,biz)
        end
      end

      Dz.destroy; Dy.destroy; Dx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      AAx = prefac*AAx
      AAy = prefac*AAy
      AAz = prefac*AAz

   end


   make_oscillator_overlap_ints(S,c,d,lc_min,lc_max,ld_min,ld_max)
   ! Make the oscillator overlap integral matrix "S". "c" and "d" are the centroid
   ! positions of the bra and ket. "lc_min", "lc_max", "ld_min" and "ld_max" are
   ! the corresponding minimum and maximum angular momenta for the centroid
   ! polynomials on "c" and "d".
      S :: MAT4{REAL}
      c,d :: VEC{REAL}(3)
      lc_min,lc_max,ld_min,ld_max :: INT

   ENSURE(S.dim3==(GAUSSIAN_DATA:n_comp_up_to(lc_max)-GAUSSIAN_DATA:n_comp_up_to(lc_min-1)),"S: bad dim3")
   ENSURE(S.dim4==(GAUSSIAN_DATA:n_comp_up_to(ld_max)-GAUSSIAN_DATA:n_comp_up_to(ld_min-1)),"S: bad dim4")

      Sx,Sy,Sz :: MAT4{REAL}@
      ax,ay,az :: VEC{INT}@
      bx,by,bz :: VEC{INT}@
      cx,cy,cz :: VEC{INT}@
      dx,dy,dz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb,fc,lc,fd,ld :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = GAUSSIAN_DATA:n_comp_up_to(lc_min-1)+1; lc = GAUSSIAN_DATA:n_comp_up_to(lc_max)
      fd = GAUSSIAN_DATA:n_comp_up_to(ld_min-1)+1; ld = GAUSSIAN_DATA:n_comp_up_to(ld_max)

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)
      cx = GAUSSIAN_DATA::nx(fc:lc); cy = GAUSSIAN_DATA::ny(fc:lc); cz = GAUSSIAN_DATA::nz(fc:lc)
      dx = GAUSSIAN_DATA::nx(fd:ld); dy = GAUSSIAN_DATA::ny(fd:ld); dz = GAUSSIAN_DATA::nz(fd:ld)

      Sx.create(.a.l+1,.b.l+1,lc_max+1,ld_max+1)
      Sy.create(.a.l+1,.b.l+1,lc_max+1,ld_max+1)
      Sz.create(.a.l+1,.b.l+1,lc_max+1,ld_max+1)
      .make_oscillator_overlap_ints(Sx,1,c(1),lc_max,d(1),ld_max)
      .make_oscillator_overlap_ints(Sy,2,c(2),lc_max,d(2),ld_max)
      .make_oscillator_overlap_ints(Sz,3,c(3),lc_max,d(3),ld_max)

      S = Sx(ax,bx,cx,dx)*Sy(ay,by,cy,dy)*Sz(az,bz,cz,dz)

      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      S = prefac*S

   end

   make_oscillator_overlap_ints(Sx,x,cx,l_c,dx,l_d,max_a,max_b)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! The oscillator polynomials are centered at "cx" and "dx". "l_c" and "l_d"
   ! are the corresponding maximum angular momenta of each oscillator. If
   ! present, "max_a" and "max_b" specify the maximum angular momenta on centers
   ! a and b respectively. Uses Gauss-Hermite quadrature.
      Sx :: MAT4{REAL}
      x,l_c,l_d :: INT
      cx,dx :: REAL
      max_a,max_b :: REAL, optional
      p,t,rp,ax,bx,wt,pt,ra,rb,rc,rd :: REAL
      l_a,l_b, a,b,c,d, i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = int(max_a)
      l_b = .b.l; if (present(max_b)) l_b = int(max_b)

      p = .a.exponent + .b.exponent
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      rp = (.a.exponent*ax + .b.exponent*bx)/p

      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
      do c = 1,l_c+1
      do d = 1,l_d+1
         i = (a+b+c+d)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rc = pt - cx
            rd = pt - dx
            if (a>1) wt = wt*ra**(a-1)
            if (b>1) wt = wt*rb**(b-1)
            if (c>1) wt = wt*rc**(c-1)
            if (d>1) wt = wt*rd**(d-1)
            Sx(a,b,c,d) = Sx(a,b,c,d) + wt
         end
      end
      end
      end
      end

   end


   make_normalised_kinetic_ints(T,spherical)
   ! Calculate T, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_kinetic_ints(T)
      else if (.a.l<2 AND .b.l<2)  then
         .make_kinetic_ints(T)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_kinetic_ints(W)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_kinetic_ints(T)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}

      Sx,Sy,Sz, Dx,Dy,Dz, Tx,Ty,Tz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+3); Sy.create(.a.l+1,.b.l+3); Sz.create(.a.l+1,.b.l+3)
      Tx.create(.a.l+1,.b.l+1); Ty.create(.a.l+1,.b.l+1); Tz.create(.a.l+1,.b.l+1)
      Dx.create(.a.l+1,.b.l+2); Dy.create(.a.l+1,.b.l+2); Dz.create(.a.l+1,.b.l+2)

      .make_overlap_ints(Sx,1,max_b=.b.l+2)
      .make_overlap_ints(Sy,2,max_b=.b.l+2)
      .make_overlap_ints(Sz,3,max_b=.b.l+2)

      .differentiate(Sx,"right",Dx) ! with respect to electron coordinates !
      .differentiate(Sy,"right",Dy)
      .differentiate(Sz,"right",Dz)
      .differentiate(Dx,"right",Tx) ! with respect to electron coordinates !
      .differentiate(Dy,"right",Ty)
      .differentiate(Dz,"right",Tz)

      Dz.destroy
      Dy.destroy
      Dx.destroy

      T = Tx(ax,bx)*Sy(ay,by)*Sz(az,bz) &
        + Sx(ax,bx)*Ty(ay,by)*Sz(az,bz) &
        + Sx(ax,bx)*Sy(ay,by)*Tz(az,bz)

      Tz.destroy; Ty.destroy; Tx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      T = -HALF*prefac*T

   end

   make_T_1st_deriv_ints(AAx,AAy,AAz)
   ! Make the first derivative kinetic integrals "AAx", "AAy" and "AAz" which are
   ! the derivatives of the kinetic matrix elements with respect to position A.
   ! The derivatives with respect to position B are not evaluated. By translational
   ! invariance, they are just the negative of the derivatives w.r.t. A.
   ! This includes the factor of -1/2 in T = -1/2 \nabla^2.
      AAx,AAy,AAz :: MAT{REAL}

      SSx,SSy,SSz :: MAT{REAL}@
      SAx,SAy,SAz :: MAT{REAL}@
      TTx,TTy,TTz :: MAT{REAL}@
      TAx,TAy,TAz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      SSx.create(.a.l+4,.b.l+1); SSy.create(.a.l+4,.b.l+1); SSz.create(.a.l+4,.b.l+1)
      SAx.create(.a.l+3,.b.l+1); SAy.create(.a.l+3,.b.l+1); SAz.create(.a.l+3,.b.l+1)
      TTx.create(.a.l+2,.b.l+1); TTy.create(.a.l+2,.b.l+1); TTz.create(.a.l+2,.b.l+1)
      TAx.create(.a.l+1,.b.l+1); TAy.create(.a.l+1,.b.l+1); TAz.create(.a.l+1,.b.l+1)

      .make_overlap_ints(SSx,1,.a.l+3)
      .make_overlap_ints(SSy,2,.a.l+3)
      .make_overlap_ints(SSz,3,.a.l+3)

      .differentiate(SSx,"left",SAx)   ! with respect to electron coordinates !
      .differentiate(SSy,"left",SAy)
      .differentiate(SSz,"left",SAz)
      .differentiate(SAx,"left",TTx)   ! with respect to electron coordinates !
      .differentiate(SAy,"left",TTy)
      .differentiate(SAz,"left",TTz)
      .differentiate(TTx,"left",TAx)   ! with respect to electron coordinates !
      .differentiate(TTy,"left",TAy)
      .differentiate(TTz,"left",TAz)

      AAx = TAx(ax,bx)*SSy(ay,by)*SSz(az,bz) &
          + SAx(ax,bx)*TTy(ay,by)*SSz(az,bz) &
          + SAx(ax,bx)*SSy(ay,by)*TTz(az,bz)
      AAy = TTx(ax,bx)*SAy(ay,by)*SSz(az,bz) &
          + SSx(ax,bx)*TAy(ay,by)*SSz(az,bz) &
          + SSx(ax,bx)*SAy(ay,by)*TTz(az,bz)
      AAz = TTx(ax,bx)*SSy(ay,by)*SAz(az,bz) &
          + SSx(ax,bx)*TTy(ay,by)*SAz(az,bz) &
          + SSx(ax,bx)*SSy(ay,by)*TAz(az,bz)

      TAz.destroy; TAy.destroy; TAx.destroy
      TTz.destroy; TTy.destroy; TTx.destroy
      SAz.destroy; SAy.destroy; SAx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = HALF*exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      AAx = prefac*AAx ! should be -1/2 factor on line above, but derivatives are
      AAy = prefac*AAy ! wrt electrons not nuclei so that reverses the sign
      AAz = prefac*AAz

   end

   make_dipole_ints(Dx,Dy,Dz,origin) ::: PURE
   ! Make the dipole integral matrices "Dx", "Dy", and "Dz".
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      self :: IN
      Dx,Dy,Dz :: MAT{REAL}, OUT
      origin :: VEC{REAL}(3), IN

      Sx,Sy,Sz,Rx,Ry,Rz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Rx.create(.a.l+1,.b.l+1); Ry.create(.a.l+1,.b.l+1); Rz.create(.a.l+1,.b.l+1)

      .make_dipole_ints(Sx,Rx,1,origin(1))
      .make_dipole_ints(Sy,Ry,2,origin(2))
      .make_dipole_ints(Sz,Rz,3,origin(3))

      Dx = Rx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Dy = Sx(ax,bx)*Ry(ay,by)*Sz(az,bz)
      Dz = Sx(ax,bx)*Sy(ay,by)*Rz(az,bz)

      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))

      Dx = prefac*Dx
      Dy = prefac*Dy
      Dz = prefac*Dz

   end

   make_dipole_ints(Sx,Dx,x,ox,max_a,max_b) ::: PURE
   ! Make 1-D overlap integrals "Sx" and dipole integrals "Dx" for component "x".
   ! "ox" is the origin for the dipole terms. If present, "max_a" and "max_b"
   ! override the l value for gaussian a or b. Uses Gauss-Hermite quadrature.
      self :: IN
      Sx,Dx :: MAT{REAL}, OUT
      x :: INT, IN
      ox :: REAL, IN
      max_a,max_b :: INT, optional, IN

      p,t,ax,bx,rp,wt,pt,ra,rb,rd :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      rp = (.a.exponent*ax + .b.exponent*bx)/p

      Sx = ZERO
      Dx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+1)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
         end
      end
      end

   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin) ::: PURE
   ! Make the qudrupole integral matrices "Qxx", ..., "Qyz".
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      self :: IN
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}, OUT
      origin :: VEC{REAL}(3), IN

      Sx,Sy,Sz,Rx,Ry,Rz,Qx,Qy,Qz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Rx.create(.a.l+1,.b.l+1); Ry.create(.a.l+1,.b.l+1); Rz.create(.a.l+1,.b.l+1)
      Qx.create(.a.l+1,.b.l+1); Qy.create(.a.l+1,.b.l+1); Qz.create(.a.l+1,.b.l+1)

      .make_quadrupole_ints(Sx,Rx,Qx,1,origin(1))
      .make_quadrupole_ints(Sy,Ry,Qy,2,origin(2))
      .make_quadrupole_ints(Sz,Rz,Qz,3,origin(3))

      Qxx = Qx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Qyy = Sx(ax,bx)*Qy(ay,by)*Sz(az,bz)
      Qzz = Sx(ax,bx)*Sy(ay,by)*Qz(az,bz)
      Qxy = Rx(ax,bx)*Ry(ay,by)*Sz(az,bz)
      Qxz = Rx(ax,bx)*Sy(ay,by)*Rz(az,bz)
      Qyz = Sx(ax,bx)*Ry(ay,by)*Rz(az,bz)

      Qz.destroy; Qy.destroy; Qx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))

      Qxx = prefac*Qxx
      Qyy = prefac*Qyy
      Qzz = prefac*Qzz
      Qxy = prefac*Qxy
      Qxz = prefac*Qxz
      Qyz = prefac*Qyz

   end

   make_quadrupole_ints(Sx,Dx,Qx,x,ox,max_a,max_b) ::: PURE
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx" and quadruple
   ! integrals "Qx" for component "x". "ox" is the origin for the dipole terms.
   ! If present, "max_a" and "max_b" override the l value for gaussian a or b.
   ! Uses Gauss-Hermite quadrature.
      self :: IN
      Sx,Dx,Qx :: MAT{REAL}, OUT
      x :: INT, IN
      ox :: REAL, IN
      max_a,max_b :: INT, optional, IN

      p,t,ax,bx,rp,wt,pt,ra,rb,rd :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      rp = (.a.exponent*ax + .b.exponent*bx)/p

      Sx = ZERO
      Dx = ZERO
      Qx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Qx(a,b) = Qx(a,b) + rd*rd*wt
         end
      end
      end

   end

   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin) ::: PURE
   ! Make the octupole integral matrices "Oxxx", ..., "Oxyz".
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      self :: IN
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}, OUT
      origin :: VEC{REAL}(3), IN
      Sx,Sy,Sz,Rx,Ry,Rz,Qx,Qy,Qz,Ox,Oy,Oz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Rx.create(.a.l+1,.b.l+1); Ry.create(.a.l+1,.b.l+1); Rz.create(.a.l+1,.b.l+1)
      Qx.create(.a.l+1,.b.l+1); Qy.create(.a.l+1,.b.l+1); Qz.create(.a.l+1,.b.l+1)
      Ox.create(.a.l+1,.b.l+1); Oy.create(.a.l+1,.b.l+1); Oz.create(.a.l+1,.b.l+1)

      .make_octupole_ints(Sx,Rx,Qx,Ox,1,origin(1))
      .make_octupole_ints(Sy,Ry,Qy,Oy,2,origin(2))
      .make_octupole_ints(Sz,Rz,Qz,Oz,3,origin(3))

      Oxxx = Ox(ax,bx)*Sy(ay,by)*Sz(az,bz)
      Oyyy = Sx(ax,bx)*Oy(ay,by)*Sz(az,bz)
      Ozzz = Sx(ax,bx)*Sy(ay,by)*Oz(az,bz)
      Oxxy = Qx(ax,bx)*Ry(ay,by)*Sz(az,bz)
      Oxxz = Qx(ax,bx)*Sy(ay,by)*Rz(az,bz)
      Oyyx = Rx(ax,bx)*Qy(ay,by)*Sz(az,bz)
      Oyyz = Sx(ax,bx)*Qy(ay,by)*Rz(az,bz)
      Ozzx = Rx(ax,bx)*Sy(ay,by)*Qz(az,bz)
      Ozzy = Sx(ax,bx)*Ry(ay,by)*Qz(az,bz)
      Oxyz = Rx(ax,bx)*Ry(ay,by)*Rz(az,bz)

      Oz.destroy; Oy.destroy; Ox.destroy
      Qz.destroy; Qy.destroy; Qx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      Oxxx = prefac*Oxxx
      Oyyy = prefac*Oyyy
      Ozzz = prefac*Ozzz
      Oxxy = prefac*Oxxy
      Oxxz = prefac*Oxxz
      Oyyx = prefac*Oyyx
      Oyyz = prefac*Oyyz
      Ozzx = prefac*Ozzx
      Ozzy = prefac*Ozzy
      Oxyz = prefac*Oxyz

   end

   make_octupole_ints(Sx,Dx,Qx,Ox,x,og,max_a,max_b) ::: PURE
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx", quadruple
   ! integrals "Qx", and the ocupole integrals "Ox", for component "x". "og" is
   ! the origin for the dipole terms.
   ! If present, "max_a" and "max_b" override the l value for gaussian a or b.
   ! Uses Gauss-Hermite quadrature.
      self :: IN
      Sx,Dx,Qx,Ox :: MAT{REAL}, OUT
       x :: INT, IN
      og :: REAL, IN
      max_a,max_b :: INT, optional, IN
      p,t,ax,bx,rp,wt,pt,ra,rb,rd,rd2 :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      rp = (.a.exponent*ax + .b.exponent*bx)/p

      Sx = ZERO
      Dx = ZERO
      Qx = ZERO
      Ox = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+3)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - og
            rd2 = rd*rd
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Qx(a,b) = Qx(a,b) + rd2*wt
            Ox(a,b) = Ox(a,b) + rd2*rd*wt
         end
      end
      end

   end


   make_normalised_NA_ints(NA,c,spherical)
   ! Calculate T, a cartesian or spherical block of integrals.
      NA :: MAT{REAL}
      c :: VEC{REAL}(3)
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_nuclear_attraction_ints(NA,c)
      elseif (.a.l<2 AND .b.l<2) then
         .make_nuclear_attraction_ints(NA,c)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_nuclear_attraction_ints(W,c)
         .change_to_spherical(W,NA)
         W.destroy
      end

      NA = NA * .normalisation_factor

   end

   make_nuclear_attraction_ints(NA,c)
   ! Make the nuclear attraction integral matrix "NA" for a nucleus at
   ! position "c". Uses Rys decomposition of 1/r_c and Gauss-Hermite
   ! quadrature.
      self :: INOUT
      NA :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      NAx,NAy,NAz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      n_roots = (.a.l+.b.l+2)/2
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      NAx.create(.a.l+1,.b.l+1)
      NAy.create(.a.l+1,.b.l+1)
      NAz.create(.a.l+1,.b.l+1)

      NA = ZERO
      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1))
         .make_nuclear_attraction_ints(NAy,2,uu,c(2))
         .make_nuclear_attraction_ints(NAz,3,uu,c(3))

         NAz = NAz*wt

         NA = NA + NAx(ax,bx)*NAy(ay,by)*NAz(az,bz)

      end

      rys.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      NA = prefac*NA

   end

   make_nuclear_attraction_ints(Nx,x,uu,cx,max_a,max_b)
   ! Make the 1-D nuclear attraction xyz integrals "Nx", for component "x", for
   ! a particular Rys-gaussian with exponent "uu", used in the decomposition of
   ! 1/r_c centerd at position "cx". If present, "max_a" and "max_b" override
   ! the l value for gaussian a or b.
   ! Uses Gauss-Hermite quadrature.
      Nx :: MAT{REAL}
       x :: INT
      uu,cx :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,wt,pt,ra,rb :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent + uu
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      r0 = (.a.exponent*ax + .b.exponent*bx + uu*cx)/p

      Nx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b)/2 ! should be max((a+b-1)/2,1) ?
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Nx(a,b) = Nx(a,b) + wt
         end
      end
      end

   end

   make_NA_1st_deriv_ints(DAx,DAy,DAz,DBx,DBy,DBz,c)
   ! Make the derivatives nuclear attraction integrals w.r.t. centers A and B in
   ! "DAx", "DAy" and "DAz", and "DBx", "DBy" and "DBz" for a nucleus at position
   ! "c". Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature
      self :: INOUT
      DAx,DAy,DAz,DBx,DBy,DBz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+1); AAy.create(.a.l+1,.b.l+1); AAz.create(.a.l+1,.b.l+1)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)

    ! n_roots = (.a.l+.b.l+3)/2
      n_roots = (.a.l+.b.l+1)/2 + 1
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      DAx = ZERO; DAy = ZERO; DAz = ZERO
      DBx = ZERO; DBy = ZERO; DBz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx) ! with respect to electron coordinates !
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(NAx,"left ",AAx) ! with respect to electron coordinates !
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         NAz = NAz*wt
         AAz = AAz*wt
         BBz = BBz*wt

         DAx = DAx - AAx(ax,bx)*NAy(ay,by)*NAz(az,bz)
         DAy = DAy - NAx(ax,bx)*AAy(ay,by)*NAz(az,bz)
         DAz = DAz - NAx(ax,bx)*NAy(ay,by)*AAz(az,bz)
         DBx = DBx - BBx(ax,bx)*NAy(ay,by)*NAz(az,bz)
         DBy = DBy - NAx(ax,bx)*BBy(ay,by)*NAz(az,bz)
         DBz = DBz - NAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

      end

      rys.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      DAx = prefac*DAx; DAy = prefac*DAy; DAz = prefac*DAz
      DBx = prefac*DBx; DBy = prefac*DBy; DBz = prefac*DBz

   end


   make_normalised_DKH_ints(T,SOx,SOy,SOz,c,spherical)
   ! Calculate T, a cartesian or spherical block of integrals.
      T,SOx,SOy,SOz :: MAT{REAL}
      c :: VEC{REAL}(3)
      spherical :: BIN, optional

      W,Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_DKH_ints(T,SOx,SOy,SOz,c)
      elseif ( .a.l<2 AND .b.l<2) then
         .make_DKH_ints(T,SOx,SOy,SOz,c)
      else
         W.create(.a.n_comp,.b.n_comp)
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_DKH_ints(W,Wx,Wy,Wz,c)
         .change_to_spherical(W,T)
         .change_to_spherical(Wx,SOx)
         .change_to_spherical(Wy,SOy)
         .change_to_spherical(Wz,SOz)
         Wz.destroy
         Wy.destroy
         Wx.destroy
         W.destroy
      end

      T   = T   * .normalisation_factor
      SOx = SOx * .normalisation_factor
      SOy = SOy * .normalisation_factor
      SOz = SOz * .normalisation_factor

   end

   make_DKH_ints(T,SOx,SOy,SOz,c)
   ! Make the Douglas-Kroll-Hess spin orbit integrals.
   ! "c" is a given nuclear center.
      self :: INOUT
      T,SOx,SOy,SOz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
!      NAx.create(.a.l+2,.b.l+3); NAy.create(.a.l+2,.b.l+3); NAz.create(.a.l+2,.b.l+3)
      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+2,.b.l+1); BBy.create(.a.l+2,.b.l+1); BBz.create(.a.l+2,.b.l+1)
!      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      n_roots = (.a.l+.b.l+4)/2
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      ! Assemble the integrals
      T = ZERO
      SOx = ZERO; SOy = ZERO; SOz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt = rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         NAz = NAz*wt
         AAz = AAz*wt
         BBz = BBz*wt
         ABz = ABz*wt

         T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz)

         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)

      end

      ! Clean up
      rys.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      ! Include prefactor
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      T = prefac*T
      SOx = prefac*SOx; SOy = prefac*SOy; SOz = prefac*SOz

   end

   make_normalised_DK3_ppZpp_ints(ppZpp,c,spherical)
   ! Calculate T, a cartesian or spherical block of integrals.
      ppZpp :: MAT{REAL}
      c :: VEC{REAL}(3)
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_DK3_ppZpp_ints(ppZpp,c)
      elseif (.a.l<2 AND .b.l<2) then
         .make_DK3_ppZpp_ints(ppZpp,c)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_DK3_ppZpp_ints(W,c)
         .change_to_spherical(W,ppZpp)
         W.destroy
      end

      ppZpp = ppZpp * .normalisation_factor

   end

   make_DK3_ppZpp_ints(ppZpp,c)
   ! Make the Douglas-Kroll-Hess p2Zp2 integrals for teh DK3 hamiltonian
   ! "c" is a given nuclear center.
      self :: INOUT
      ppZpp :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      AB2x,AB2y,AB2z,A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      ! the dimension ???
      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      A2x.create(.a.l+1,.b.l+3); A2y.create(.a.l+1,.b.l+3); A2z.create(.a.l+1,.b.l+3)
      BBx.create(.a.l+3,.b.l+2); BBy.create(.a.l+3,.b.l+2); BBz.create(.a.l+3,.b.l+2)
      B2x.create(.a.l+3,.b.l+1); B2y.create(.a.l+3,.b.l+1); B2z.create(.a.l+3,.b.l+1)
      ABx.create(.a.l+2,.b.l+1); ABy.create(.a.l+2,.b.l+1); ABz.create(.a.l+2,.b.l+1)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)

      ! Roots and weights
!      n_roots = (.a.l+.b.l+8)/2
      n_roots = (.a.l+.b.l+6)/2
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      ! Assemble the integrals
      ppZpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt = rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+2,.b.l+2)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+2,.b.l+2)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+2,.b.l+2)


         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
         .differentiate(AAx,"left ",A2x)
         .differentiate(AAy,"left ",A2y)
         .differentiate(AAz,"left ",A2z)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(BBx,"right",B2x)
         .differentiate(BBy,"right",B2y)
         .differentiate(BBz,"right",B2z)

         .differentiate(B2x,"left",ABx)
         .differentiate(B2y,"left",ABy)
         .differentiate(B2z,"left",ABz)

         .differentiate(ABx,"left",AB2x)
         .differentiate(ABy,"left",AB2y)
         .differentiate(ABz,"left",AB2z)

         NAz = NAz*wt
         A2z = A2z*wt
         B2z = B2z*wt
!         AAz = AAz*wt
!         BBz = BBz*wt
         AB2z = AB2z*wt

         ppZpp = ppZpp + A2x(ax,bx)*B2y(ay,by)*NAz(az,bz) &
               + B2x(ax,bx)*A2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
               + NAx(ax,bx)*B2y(ay,by)*A2z(az,bz) &
               + A2x(ax,bx)*NAy(ay,by)*B2z(az,bz) &
               + B2x(ax,bx)*NAy(ay,by)*A2z(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz)

! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)

      end

      ! Clean up
      rys.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      AB2z.destroy; AB2y.destroy; AB2x.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      A2z.destroy; A2y.destroy; A2x.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      ! Include prefactor
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      ppZpp = prefac*ppZpp
!      SOx = prefac*SOx; SOy = prefac*SOy; SOz = prefac*SOz

   end


   make_spin_orbit_ints(Lx,Ly,Lz,c)
   ! Make the spin orbit integral matrices "Lx", "Ly", and "Lz" around 
   ! nucleus "c".  This integrals is for: 
   !    (r - r_c) x nabla / |r - r_c|^3, 
   ! with no minus sign on nabla. Uses Rys decomposition of 1/r_c and
   ! Gauss-Hermite quadrature.
      self :: INOUT
      Lx,Ly,Lz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+1); AAy.create(.a.l+1,.b.l+1); AAz.create(.a.l+1,.b.l+1)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)

      n_roots = (.a.l+.b.l+3)/2
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Lx = ZERO
      Ly = ZERO
      Lz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)
         NAz = NAz*wt

         .differentiate(NAx,"right",BBx) ! with respect to electron coordinates !
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(NAx,"left ",AAx) ! with respect to electron coordinates !
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         Lx = Lx + NAx(ax,bx)*(AAy(ay,by)*BBz(az,bz)-BBy(ay,by)*AAz(az,bz))
         Ly = Ly + NAy(ay,by)*(AAz(az,bz)*BBx(ax,bx)-BBz(az,bz)*AAx(ax,bx))
         Lz = Lz + NAz(az,bz)*(AAx(ax,bx)*BBy(ay,by)-BBx(ax,bx)*AAy(ay,by))

      end

      rys.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      Lx = prefac*Lx
      Ly = prefac*Ly
      Lz = prefac*Lz

   end

   make_E_field_ints(Ex,Ey,Ez,c)
   ! Make the electric field integral matrices "Ei" at position "c". If present,
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      self :: INOUT
      Ex,Ey,Ez :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx,Sy,Sz,Fx,Fy,Fz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Fx.create(.a.l+1,.b.l+1); Fy.create(.a.l+1,.b.l+1); Fz.create(.a.l+1,.b.l+1)

      n_roots = (.a.l+.b.l+3)/2
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Ex = ZERO
      Ey = ZERO
      Ez = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_E_field_ints(Sx,Fx,1,uu,c(1))
         .make_E_field_ints(Sy,Fy,2,uu,c(2))
         .make_E_field_ints(Sz,Fz,3,uu,c(3))

         Sz = Sz*wt
         Fz = Fz*wt

         Ex = Ex + Fx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Ey = Ey + Sx(ax,bx)*Fy(ay,by)*Sz(az,bz)
         Ez = Ez + Sx(ax,bx)*Sy(ay,by)*Fz(az,bz)

      end

      rys.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      Ex = prefac*Ex
      Ey = prefac*Ey
      Ez = prefac*Ez

   end

   make_E_field_ints(Sx,Fx,x,uu,cx,max_a,max_b)
   ! Make the 1-D nuclear attraction integrals "Sx", and the electric field
   ! integrals "Fx" for component "x", for a particular Rys-gaussian
   ! with exponent "uu", used in the decomposition of (c-r)/|c-r|^3
   ! centerd at position "cx". Uses Gauss-Hermite quadrature.
   ! If present, "max_a" and "max_b" indicate the l value to be used
   ! for gaussian a or b.
      Sx,Fx :: MAT{REAL}, OUT
      x :: INT, IN
      uu,cx :: REAL, IN
      max_a,max_b :: INT, optional

      p,t,ax,bx,r0,ff,pt,wt,ra,rb,ru :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent + uu
      t = sqrt(p)

      ax = .a.position(x)
      bx = .b.position(x)
      r0 = (.a.exponent*ax + .b.exponent*bx + uu*cx)/p

      Sx = ZERO
      Fx = ZERO

      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+1)/2 ! should be max((a+b)/2,1) ?
         do k = first_pt(i),last_pt(i)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)
            ff = ONE
            if(a>1) ff = ff*ra**(a-1)
            if(b>1) ff = ff*rb**(b-1)
            wt = gauss_hermite_wt(k)
            Sx(a,b) = Sx(a,b) + ff*wt
            Fx(a,b) = Fx(a,b) + (ru*ff)*wt
         end
      end
      end

   end

   make_E_gradient_ints(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
   ! Make the electric field gradient integral matrices "Ei" at position "c".
   ! This does not contain the density contribution from the delta function.
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      self :: INOUT
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx,Sy,Sz,Fx,Fy,Fz,Gx,Gy,Gz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Fx.create(.a.l+1,.b.l+1); Fy.create(.a.l+1,.b.l+1); Fz.create(.a.l+1,.b.l+1)
      Gx.create(.a.l+1,.b.l+1); Gy.create(.a.l+1,.b.l+1); Gz.create(.a.l+1,.b.l+1)

      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      n_roots = (.a.l+.b.l+4)/2
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Exx = ZERO; Eyy = ZERO; Ezz = ZERO
      Exy = ZERO; Exz = ZERO; Eyz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_E_gradient_ints(Sx,Fx,Gx,1,uu,c(1))
         .make_E_gradient_ints(Sy,Fy,Gy,2,uu,c(2))
         .make_E_gradient_ints(Sz,Fz,Gz,3,uu,c(3))

         Sz = Sz*wt
         Fz = Fz*wt
         Gz = Gz*wt

         Exx = Exx + Gx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Eyy = Eyy + Sx(ax,bx)*Gy(ay,by)*Sz(az,bz)
         Ezz = Ezz + Sx(ax,bx)*Sy(ay,by)*Gz(az,bz)
         Exy = Exy - Fx(ax,bx)*Fy(ay,by)*Sz(az,bz) ! cancel the extra minus sign on Fy
         Exz = Exz - Fx(ax,bx)*Sy(ay,by)*Fz(az,bz)
         Eyz = Eyz - Sx(ax,bx)*Fy(ay,by)*Fz(az,bz)

      end

      rys.destroy
      Gz.destroy; Gy.destroy; Gx.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      Exx = prefac*Exx; Eyy = prefac*Eyy; Ezz = prefac*Ezz
      Exy = prefac*Exy; Exz = prefac*Exz; Eyz = prefac*Eyz

   end

   make_E_gradient_ints(Sx,Fx,Gx,x,uu,cx,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", and the electric field integrals "Fx",
   ! and the electric field gradient integral "Gx" for component "x", for a
   ! particular Rys-gaussian with exponent "uu", used in the decomposition of
   ! (c-r)/|c-r|^3 centerd at position "cx". Uses Gauss-Hermite quadrature.
   ! If present, "max_a" and "max_b" indicate the l value to be used for
   ! gaussian a or b.
      Sx,Fx,Gx :: MAT{REAL}
       x :: INT
      uu,cx :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,ff,pt,ra,rb,ru,rg :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent + uu
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      r0 = (.a.exponent*ax + .b.exponent*bx + uu*cx)/p

      Sx = ZERO; Fx = ZERO; Gx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2 ! should be max((a+b)/2,1) ?
         do k = first_pt(i),last_pt(i)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)          ! this is Ex = - d/dcx phi(c)
            rg = TWO*uu*(ONE-ru*(cx-pt)) ! this is dEx/dcx
            ff = gauss_hermite_wt(k)
            if(a>1) ff = ff*ra**(a-1)
            if(b>1) ff = ff*rb**(b-1) ! this is \int dx g(a;ax) g(b;bx) e^(-uu*(cx-r)^2)
            Sx(a,b) = Sx(a,b) + ff    ! integrand = 1
            Fx(a,b) = Fx(a,b) + ru*ff ! integrand = (cx-r)/|c-r|^3
            Gx(a,b) = Gx(a,b) + rg*ff ! integrand = 3*(cx-r)^2/|c-r|^5 - 1/|c-r|^3
         end
      end
      end

   end


   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make gauge modified (B field) spin orbit integral matrices "Qij" around
   ! nucleus "c".  using gauge origin "origin".  The integrals are:
   !    Qij(a,b) = <a| (r-o)_i (r-c)_j / |r-c|^3 |b>
   ! Uses Rys decomposition of 1/|r-c| and Gauss-Hermite quadrature.
      self :: INOUT
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}, OUT
      c,origin :: VEC{REAL}(3), IN

      Sx,Sy,Sz,Dx,Dy,Dz,Fx,Fy,Fz,Qx,Qy,Qz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Dx.create(.a.l+1,.b.l+1); Dy.create(.a.l+1,.b.l+1); Dz.create(.a.l+1,.b.l+1)
      Fx.create(.a.l+1,.b.l+1); Fy.create(.a.l+1,.b.l+1); Fz.create(.a.l+1,.b.l+1)
      Qx.create(.a.l+1,.b.l+1); Qy.create(.a.l+1,.b.l+1); Qz.create(.a.l+1,.b.l+1)

      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      n_roots = (.a.l+.b.l+3)/2
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_q_field_ints(Sx,Dx,Fx,Qx,1,uu,c(1),origin(1))
         .make_q_field_ints(Sy,Dy,Fy,Qy,2,uu,c(2),origin(2))
         .make_q_field_ints(Sz,Dz,Fz,Qz,3,uu,c(3),origin(3))

         Sz = Sz*wt
         Dz = Dz*wt
         Fz = Fz*wt
         Qz = Qz*wt

         Qxx = Qxx + Qx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Qyx = Qyx + Fx(ax,bx)*Dy(ay,by)*Sz(az,bz)
         Qzx = Qzx + Fx(ax,bx)*Sy(ay,by)*Dz(az,bz)
         Qxy = Qxy + Dx(ax,bx)*Fy(ay,by)*Sz(az,bz)
         Qyy = Qyy + Sx(ax,bx)*Qy(ay,by)*Sz(az,bz)
         Qzy = Qzy + Sx(ax,bx)*Fy(ay,by)*Dz(az,bz)
         Qxz = Qxz + Dx(ax,bx)*Sy(ay,by)*Fz(az,bz)
         Qyz = Qyz + Sx(ax,bx)*Dy(ay,by)*Fz(az,bz)
         Qzz = Qzz + Sx(ax,bx)*Sy(ay,by)*Qz(az,bz)

      end

      rys.destroy
      Qz.destroy; Qy.destroy; Qx.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Dz.destroy; Dy.destroy; Dx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      Qxx = prefac*Qxx; Qyx = prefac*Qyx; Qzx = prefac*Qzx
      Qxy = prefac*Qxy; Qyy = prefac*Qyy; Qzy = prefac*Qzy
      Qxz = prefac*Qxz; Qyz = prefac*Qyz; Qzz = prefac*Qzz

   end

   make_q_field_ints(Sx,Dx,Fx,Qx,x,uu,cx,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx", electric field
   ! integrals "Fx", and the dipole-electric field integrals "Qx" for component
   ! "x". "uu" is the Rys-gaussian exponent used in the decomposition of
   ! (c-r)/|c-r|^3 centerd at position "cx".
   ! "ox" is the origin for the dipole terms. If present, "max_a" and "max_b"
   ! override the l value for gaussian a or b. Uses Gauss-Hermite quadrature.
      Sx,Dx,Fx,Qx :: MAT{REAL}
      x :: INT
      uu,cx,ox :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,wt,pt,ra,rb,ru,rd :: REAL
      l_a,l_b,a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      p = .a.exponent + .b.exponent + uu
      t = sqrt(p)
      ax = .a.position(x)
      bx = .b.position(x)
      r0 = (.a.exponent*ax + .b.exponent*bx + uu*cx)/p

      Sx = ZERO; Dx = ZERO; Fx = ZERO; Qx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2 ! should be max((a+b+1)/2,1) ?
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Fx(a,b) = Fx(a,b) + ru*wt
            Qx(a,b) = Qx(a,b) + ru*rd*wt
         end
      end
      end
   end


   make_L_ints(Lx,Ly,Lz,origin)
   ! Make the angular momentum integral matrices "Lx", "Ly", and "Lz".
   ! The integrals are for (r x nabla) with *no* minus sign on nabla.
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      Lx,Ly,Lz :: MAT{REAL}
      origin :: VEC{REAL}(3)

      Sx,Sy,Sz,Rx,Ry,Rz,Dx,Dy,Dz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+2); Sy.create(.a.l+1,.b.l+2); Sz.create(.a.l+1,.b.l+2)
      Rx.create(.a.l+1,.b.l+2); Ry.create(.a.l+1,.b.l+2); Rz.create(.a.l+1,.b.l+2)
      Dx.create(.a.l+1,.b.l+1); Dy.create(.a.l+1,.b.l+1); Dz.create(.a.l+1,.b.l+1)

      .make_dipole_ints(Sx,Rx,1,origin(1),max_b=.b.l+1)
      .make_dipole_ints(Sy,Ry,2,origin(2),max_b=.b.l+1)
      .make_dipole_ints(Sz,Rz,3,origin(3),max_b=.b.l+1)

      .differentiate(Sx,"right",Dx)
      .differentiate(Sy,"right",Dy)
      .differentiate(Sz,"right",Dz)

      Lx = Sx(ax,bx)*(Ry(ay,by)*Dz(az,bz)-Dy(ay,by)*Rz(az,bz))
      Ly = Sy(ay,by)*(Rz(az,bz)*Dx(ax,bx)-Dz(az,bz)*Rx(ax,bx))
      Lz = Sz(az,bz)*(Rx(ax,bx)*Dy(ay,by)-Dx(ax,bx)*Ry(ay,by))

      Dz.destroy; Dy.destroy; Dx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)/(p*sqrt(p))
      Lx = prefac*Lx
      Ly = prefac*Ly
      Lz = prefac*Lz

   end


   differentiate(I,index,D)
   ! Differentiate a gaussian-integral matrix "I" with respect to the
   ! *electron* coordinate on basis function "index", which can be "left"
   ! or "right". Place the result in "D".
      I,D :: MAT{REAL}
      index :: STR

      d_a,d_b,a,b :: INT
      a2,b2 :: REAL

      d_a = ubound(D,1); d_b = ubound(D,2)

      D = ZERO
      select case (index)
         case("l","left")
            ENSURE(ubound(I,1)>1,   "I array too small to differentiate")
            ENSURE(ubound(I,1)>d_a, "I and D arrays are incompatible")
            ENSURE(ubound(I,2)>=d_b,"I and D arrays are incompatible")
            a2 = TWO*.a.exponent
            D(1,:) = -a2*I(2  ,1:d_b)
            do a = 2,d_a
            D(a,:) = -a2*I(a+1,1:d_b) + (a-1)*I(a-1,1:d_b)
            end
         case("r","right")
            ENSURE(ubound(I,2)>1,   "I array too small to differentiate")
            ENSURE(ubound(I,2)>d_b, "I and D arrays are incompatible")
            ENSURE(ubound(I,1)>=d_a,"I and D arrays are incompatible")
            b2 = TWO*.b.exponent
            D(:,1) = -b2*I(1:d_a,2  )
            do b = 2,d_b
            D(:,b) = -b2*I(1:d_a,b+1) + (b-1)*I(1:d_a,b-1)
            end
      end

   end


   make_magnetic_jp_ints(Jx,Jy,Jz,c)
   ! Make the magnetic Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = \int dr [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! These are used to get the magnetic field from the paramegnetic current
   ! density,
   !      B(c) = ( mu_o / 4 pi ) \int dr J(r) x (c - r)/|c - r|^3
   ! Note: in atomic units mu_o = 4 pi / c^2.
   ! Note: prefactor *not* inlcuded in these integrals
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      Jx,Jy,Jz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00 :: MAT{REAL}@
      Sx10,Sy10,Sz10 :: MAT{REAL}@
      Sx01,Sy01,Sz01 :: MAT{REAL}@
      Sxmm,Symm,Szmm :: MAT{REAL}@
      Fx00,Fy00,Fz00 :: MAT{REAL}@
      ax,ay,az :: VEC{INT}@
      bx,by,bz :: VEC{INT}@
      rpc,rab  :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      ! Gaussian function limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ! Guassian powers
      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! Allocate arrays
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxmm.create(.a.l+1,.b.l+1); Symm.create(.a.l+1,.b.l+1); Szmm.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)

      ! Gaussian product center
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      ! Get no of roots
      n_roots = (.a.l+.b.l+4)/2

      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      ! Initialize
      Jx = ZERO
      Jy = ZERO
      Jz = ZERO

      ! Loop over roots
      do k = 1,n_roots

         ! Roots and weights
         uu = p*rys.root(k)
         wt =   rys.weight(k)

         ! Get overlap and E-Field integrals
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)

         ! Differentiate left/right

         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)

         ! Subtract
         Sxmm = Sx01 - Sx10
         Symm = Sy01 - Sy10
         Szmm = Sz01 - Sz10

         ! Fold in weights
         Sz00 = Sz00*wt
         Fz00 = Fz00*wt
         Szmm = Szmm*wt

         ! Evaluate
         Jx = Jx + Sx00(ax,bx) * (Symm(ay,by)*Fz00(az,bz) - Fy00(ay,by)*Szmm(az,bz))
         Jy = Jy + Sy00(ay,by) * (Szmm(az,bz)*Fx00(ax,bx) - Fz00(az,bz)*Sxmm(ax,bx))
         Jz = Jz + Sz00(az,bz) * (Sxmm(ax,bx)*Fy00(ay,by) - Fx00(ax,bx)*Symm(ay,by))

      end

      ! Clean
      rys.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      ! Add prefactor
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz

   end

   make_magnetic_S_ints(M,c)
   ! Make the magnetic spin density integrals "Mij", evaluated at point "c",
   !    <a|Mij(c)|b> = \int dr grad_i ( g_a(r) g_b(r) ) (c - r)_j/ |c - r|^3
   !                 = M(a,b,i,j)
   ! These are used to get the magnetic field from the spin density,
   !      B(c) = -(g mu_b mu_o / 4 pi)
   !             \int dr curl rho_spin(r) x (c - r)/|c - r|3
   ! Note: in atomic units mu_o = 4 pi / c^2.
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      M :: MAT4{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00 :: MAT{REAL}@
      Sx10,Sy10,Sz10 :: MAT{REAL}@
      Sx01,Sy01,Sz01 :: MAT{REAL}@
      Sxpp,Sypp,Szpp :: MAT{REAL}@
      Fx00,Fy00,Fz00 :: MAT{REAL}@
      Fx10,Fy10,Fz10 :: MAT{REAL}@
      Fx01,Fy01,Fz01 :: MAT{REAL}@
      Fxpp,Fypp,Fzpp :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      ! Gaussian function limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)

      ! Gaussisn center
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      ! No of roots
      n_roots = (.a.l+.b.l+4)/2

      ! Get roots & weights
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      ! Initialize
      M = ZERO

      ! Loop over roots
      do k = 1,n_roots

         ! Roots and weights
         uu = p*rys.root(k)
         wt =   rys.weight(k)

         ! Get overlap and E-Field integrals
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)

         ! Fold in weights
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt

         ! Differentiate left/right
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)

         ! Symmetric combination
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10

         ! Evaluate
         M(:,:,1,1) = M(:,:,1,1) + Fxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz) ! x has pp
         M(:,:,1,2) = M(:,:,1,2) + Sxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)
         M(:,:,1,3) = M(:,:,1,3) + Sxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)
         M(:,:,2,1) = M(:,:,2,1) + Fx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz) ! y has pp
         M(:,:,2,2) = M(:,:,2,2) + Sx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
         M(:,:,2,3) = M(:,:,2,3) + Sx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)
         M(:,:,3,1) = M(:,:,3,1) + Fx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz) ! z has pp
         M(:,:,3,2) = M(:,:,3,2) + Sx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)
         M(:,:,3,3) = M(:,:,3,3) + Sx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)

      end

      ! Clean
      rys.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      ! Add prefactor
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      M = prefac*M

   end

   make_nabla_field_ints(M,c)
   ! Make the magnetic spin density integrals "Mij", evaluated at point "c",
   !    <a|Mij(c)|b> = \int dr g_a(r) ( grad_i g_b(r) ) (c - r)_j/ |c - r|^3
   !                 = M(a,b,i,j)
   ! These are used to get the magnetic field from the spin density,
   !      B(c) = -(g mu_b mu_o / 4 pi)
   !             \int dr curl rho_spin(r) x (c - r)/|c - r|3
   ! Note: in atomic units mu_o = 4 pi / c^2.
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      M :: MAT4{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00 :: MAT{REAL}@
      Sx01,Sy01,Sz01 :: MAT{REAL}@
      Fx00,Fy00,Fz00 :: MAT{REAL}@
      Fx01,Fy01,Fz01 :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      ! Gaussian function limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals (dimension one higher than actual l value needed)
      Sx00.create(.a.l+1,.b.l+2); Sy00.create(.a.l+1,.b.l+2); Sz00.create(.a.l+1,.b.l+2)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+1,.b.l+2); Fy00.create(.a.l+1,.b.l+2); Fz00.create(.a.l+1,.b.l+2)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)

      ! Gaussian center
      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      ! No of roots
      n_roots = (.a.l+.b.l+4)/2

      ! Get roots & weights
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      ! Initialize
      M = ZERO

      ! Loop over roots
      do k = 1,n_roots

         ! Roots and weights
         uu = p*rys.root(k)
         wt =   rys.weight(k)

         ! Get overlap and E-Field integrals
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l,.b.l+1)

         ! Fold in weights
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt

         ! Differentiate left/right
         .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"right",Fz01)

         ! Evaluate
         M(:,:,1,1) = M(:,:,1,1) + Fx01(ax,bx)*Sy00(ay,by)*Sz00(az,bz) ! x has grad
         M(:,:,1,2) = M(:,:,1,2) + Sx01(ax,bx)*Fy00(ay,by)*Sz00(az,bz)
         M(:,:,1,3) = M(:,:,1,3) + Sx01(ax,bx)*Sy00(ay,by)*Fz00(az,bz)
         M(:,:,2,1) = M(:,:,2,1) + Fx00(ax,bx)*Sy01(ay,by)*Sz00(az,bz) ! y has grad
         M(:,:,2,2) = M(:,:,2,2) + Sx00(ax,bx)*Fy01(ay,by)*Sz00(az,bz)
         M(:,:,2,3) = M(:,:,2,3) + Sx00(ax,bx)*Sy01(ay,by)*Fz00(az,bz)
         M(:,:,3,1) = M(:,:,3,1) + Fx00(ax,bx)*Sy00(ay,by)*Sz01(az,bz) ! z has grad
         M(:,:,3,2) = M(:,:,3,2) + Sx00(ax,bx)*Fy00(ay,by)*Sz01(az,bz)
         M(:,:,3,3) = M(:,:,3,3) + Sx00(ax,bx)*Sy00(ay,by)*Fz01(az,bz)

      end

      ! Clean
      rys.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      ! Add prefactor
      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/p
      M = prefac*M

   end


   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr curl [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      Jx,Jy,Jz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp,Sxmm,Symm,Szmm :: MAT{REAL}@
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp,Fxmm,Fymm,Fzmm :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Sxmm.create(.a.l+1,.b.l+1); Symm.create(.a.l+1,.b.l+1); Szmm.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      Fxmm.create(.a.l+1,.b.l+1); Fymm.create(.a.l+1,.b.l+1); Fzmm.create(.a.l+1,.b.l+1)

      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Jx = ZERO
      Jy = ZERO
      Jz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)

         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt

         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)

         Sxpp = Sx01 + Sx10; Sxmm = Sx01 - Sx10
         Sypp = Sy01 + Sy10; Symm = Sy01 - Sy10
         Szpp = Sz01 + Sz10; Szmm = Sz01 - Sz10
         Fxpp = Fx01 + Fx10; Fxmm = Fx01 - Fx10
         Fypp = Fy01 + Fy10; Fymm = Fy01 - Fy10
         Fzpp = Fz01 + Fz10; Fzmm = Fz01 - Fz10

         Jx = Jx &
            + Sxmm(ax,bx)*Sy00(ay,by)*Fzpp(az,bz) &
            - Sxpp(ax,bx)*Sy00(ay,by)*Fzmm(az,bz) &
            - Sxpp(ax,bx)*Fymm(ay,by)*Sz00(az,bz) &
            + Sxmm(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
         Jy = Jy &
            + Fxpp(ax,bx)*Symm(ay,by)*Sz00(az,bz) &
            - Fxmm(ax,bx)*Sypp(ay,by)*Sz00(az,bz) &
            - Sx00(ax,bx)*Sypp(ay,by)*Fzmm(az,bz) &
            + Sx00(ax,bx)*Symm(ay,by)*Fzpp(az,bz)
         Jz = Jz &
            + Sx00(ax,bx)*Fypp(ay,by)*Szmm(az,bz) &
            - Sx00(ax,bx)*Fymm(ay,by)*Szpp(az,bz) &
            - Fxmm(ax,bx)*Sy00(ay,by)*Szpp(az,bz) &
            + Fxpp(ax,bx)*Sy00(ay,by)*Szmm(az,bz)

      end

      rys.destroy
      Fzmm.destroy; Fymm.destroy; Fxmm.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz

   end

   make_solenoidal_jd_ints(Jx,Jy,Jz,B_field,origin,c)
   ! Make the solenoidal Jd integrals "Ji", with external magnetic field
   ! "B_field", gauge origin "origin",evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr (curl J^d_ab(r)) x (c - r)/ |c - r|^3
   !     curl J^d_ab(r) = B (2 g_a(r)g_b(r) + (r-r_o).grad g_a(r)g_b(r))
   !                      - (r-r_o)(B.grad g_a(r)g_b(r))
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      Jx,Jy,Jz :: MAT{REAL}, OUT
      B_field,origin,c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp :: MAT{REAL}@
      Dx00,Dy00,Dz00,Dx10,Dy10,Dz10,Dx01,Dy01,Dz01,Dxpp,Dypp,Dzpp :: MAT{REAL}@
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp :: MAT{REAL}@
      Qx00,Qy00,Qz00,Qx10,Qy10,Qz10,Qx01,Qy01,Qz01,Qxpp,Qypp,Qzpp :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac,B_x,B_y,B_z :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      B_x = B_field(1)
      B_y = B_field(2)
      B_z = B_field(3)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Dx00.create(.a.l+2,.b.l+2); Dy00.create(.a.l+2,.b.l+2); Dz00.create(.a.l+2,.b.l+2)
      Dx10.create(.a.l+1,.b.l+1); Dy10.create(.a.l+1,.b.l+1); Dz10.create(.a.l+1,.b.l+1)
      Dx01.create(.a.l+1,.b.l+1); Dy01.create(.a.l+1,.b.l+1); Dz01.create(.a.l+1,.b.l+1)
      Dxpp.create(.a.l+1,.b.l+1); Dypp.create(.a.l+1,.b.l+1); Dzpp.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      Qx00.create(.a.l+2,.b.l+2); Qy00.create(.a.l+2,.b.l+2); Qz00.create(.a.l+2,.b.l+2)
      Qx10.create(.a.l+1,.b.l+1); Qy10.create(.a.l+1,.b.l+1); Qz10.create(.a.l+1,.b.l+1)
      Qx01.create(.a.l+1,.b.l+1); Qy01.create(.a.l+1,.b.l+1); Qz01.create(.a.l+1,.b.l+1)
      Qxpp.create(.a.l+1,.b.l+1); Qypp.create(.a.l+1,.b.l+1); Qzpp.create(.a.l+1,.b.l+1)

      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c

      n_roots = (.a.l+.b.l+3)/2 + 1
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Jx = ZERO
      Jy = ZERO
      Jz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_q_field_ints(Sx00,Dx00,Fx00,Qx00,1,uu,c(1),origin(1),.a.l+1,.b.l+1)
         .make_q_field_ints(Sy00,Dy00,Fy00,Qy00,2,uu,c(2),origin(2),.a.l+1,.b.l+1)
         .make_q_field_ints(Sz00,Dz00,Fz00,Qz00,3,uu,c(3),origin(3),.a.l+1,.b.l+1)

         Sz00 =  Sz00*wt
         Dz00 =  Dz00*wt
         Fx00 = -Fx00     ! minus sign to give (c-r) instead of (r-c)
         Fy00 = -Fy00
         Fz00 = -Fz00*wt
         Qx00 = -Qx00
         Qy00 = -Qy00
         Qz00 = -Qz00*wt

         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Dx00,"left",Dx10); .differentiate(Dx00,"right",Dx01)
         .differentiate(Dy00,"left",Dy10); .differentiate(Dy00,"right",Dy01)
         .differentiate(Dz00,"left",Dz10); .differentiate(Dz00,"right",Dz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)
         .differentiate(Qx00,"left",Qx10); .differentiate(Qx00,"right",Qx01)
         .differentiate(Qy00,"left",Qy10); .differentiate(Qy00,"right",Qy01)
         .differentiate(Qz00,"left",Qz10); .differentiate(Qz00,"right",Qz01)

         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Dxpp = Dx01 + Dx10
         Dypp = Dy01 + Dy10
         Dzpp = Dz01 + Dz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         Qxpp = Qx01 + Qx10
         Qypp = Qy01 + Qy10
         Qzpp = Qz01 + Qz10

          Jx = Jx &
           + B_field(2)*( TWO*Sx00(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
           + Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  &
           + Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz)  &
           + Sx00(ax,bx)*Sy00(ay,by)*Qzpp(az,bz)) &
           - B_field(3)*( TWO*Sx00(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
           + Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  &
           + Sx00(ax,bx)*Qypp(ay,by)*Sz00(az,bz)  &
           + Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz)) &
           - B_field(1)*(Sxpp(ax,bx)*Dy00(ay,by)*Fz00(az,bz) - Sxpp(ax,bx)*Fy00(ay,by)*Dz00(az,bz)) &
           - B_field(2)*(Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz) - Sx00(ax,bx)*Fypp(ay,by)*Dz00(az,bz)) &
           - B_field(3)*(Sx00(ax,bx)*Dy00(ay,by)*Fzpp(az,bz) - Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz))
          Jy = Jy &
           + B_field(3)*( TWO*Fx00(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
           + Qxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)  &
           + Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)  &
           + Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz)) &
           - B_field(1)*( TWO*Sx00(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
           + Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  &
           + Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz)  &
           + Sx00(ax,bx)*Sy00(ay,by)*Qzpp(az,bz)) &
           - B_field(1)*(Fxpp(ax,bx)*Sy00(ay,by)*Dz00(az,bz) - Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)) &
           - B_field(2)*(Fx00(ax,bx)*Sypp(ay,by)*Dz00(az,bz) - Dx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)) &
           - B_field(3)*(Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz) - Dx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz))
          Jz = Jz &
           + B_field(1)*( TWO*Sx00(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
           + Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  &
           + Sx00(ax,bx)*Qypp(ay,by)*Sz00(az,bz)  &
           + Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz)) &
           - B_field(2)*( TWO*Fx00(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
           + Qxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)  &
           + Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)  &
           + Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz)) &
           - B_field(1)*(Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz) - Fxpp(ax,bx)*Dy00(ay,by)*Sz00(az,bz)) &
           - B_field(2)*(Dx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) - Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)) &
           - B_field(3)*(Dx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz) - Fx00(ax,bx)*Dy00(ay,by)*Szpp(az,bz))

      end

      rys.destroy
      Qzpp.destroy; Qypp.destroy; Qxpp.destroy
      Qz01.destroy; Qy01.destroy; Qx01.destroy
      Qz10.destroy; Qy10.destroy; Qx10.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Qzpp.destroy; Qypp.destroy; Qxpp.destroy
      Qz01.destroy; Qy01.destroy; Qx01.destroy
      Qz10.destroy; Qy10.destroy; Qx10.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz

   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr curl [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      Jx,Jy,Jz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxmm,Symm,Szmm :: MAT{REAL}@
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxmm,Fymm,Fzmm :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS@

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx00.create(.a.l+3,.b.l+3); Sy00.create(.a.l+3,.b.l+3); Sz00.create(.a.l+3,.b.l+3)
      Sx10.create(.a.l+2,.b.l+2); Sy10.create(.a.l+2,.b.l+2); Sz10.create(.a.l+2,.b.l+2)
      Sx01.create(.a.l+2,.b.l+2); Sy01.create(.a.l+2,.b.l+2); Sz01.create(.a.l+2,.b.l+2)
      Sxmm.create(.a.l+2,.b.l+2); Symm.create(.a.l+2,.b.l+2); Szmm.create(.a.l+2,.b.l+2)
      Fx00.create(.a.l+3,.b.l+3); Fy00.create(.a.l+3,.b.l+3); Fz00.create(.a.l+3,.b.l+3)
      Fx10.create(.a.l+2,.b.l+2); Fy10.create(.a.l+2,.b.l+2); Fz10.create(.a.l+2,.b.l+2)
      Fx01.create(.a.l+2,.b.l+2); Fy01.create(.a.l+2,.b.l+2); Fz01.create(.a.l+2,.b.l+2)
      Fxmm.create(.a.l+2,.b.l+2); Fymm.create(.a.l+2,.b.l+2); Fzmm.create(.a.l+2,.b.l+2)

      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      n_roots = (.a.l+.b.l+3)/2 + 1
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+2,.b.l+2)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+2,.b.l+2)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+2,.b.l+2)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt

         .differentiate(Sx00,"right",Sx01); .differentiate(Sx01,"right",Sxmm)
         .differentiate(Sx00,"left" ,Sx10); .differentiate(Sx10,"left" ,Sx01)
         .differentiate(Sy00,"right",Sy01); .differentiate(Sy01,"right",Symm)
         .differentiate(Sy00,"left" ,Sy10); .differentiate(Sy10,"left" ,Sy01)
         .differentiate(Sz00,"right",Sz01); .differentiate(Sz01,"right",Szmm)
         .differentiate(Sz00,"left" ,Sz10); .differentiate(Sz10,"left" ,Sz01)
         .differentiate(Fx00,"right",Fx01); .differentiate(Fx01,"right",Fxmm)
         .differentiate(Fx00,"left" ,Fx10); .differentiate(Fx10,"left" ,Fx01)
         .differentiate(Fy00,"right",Fy01); .differentiate(Fy01,"right",Fymm)
         .differentiate(Fy00,"left" ,Fy10); .differentiate(Fy10,"left" ,Fy01)
         .differentiate(Fz00,"right",Fz01); .differentiate(Fz01,"right",Fzmm)
         .differentiate(Fz00,"left" ,Fz10); .differentiate(Fz10,"left" ,Fz01)

         Sxmm = Sxmm - Sx01
         Symm = Symm - Sy01
         Szmm = Szmm - Sz01
         Fxmm = Fxmm - Fx01
         Fymm = Fymm - Fy01
         Fzmm = Fzmm - Fz01

         Jx = Jx + Fxmm(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
                 + Fx00(ax,bx)*Symm(ay,by)*Sz00(az,bz) &
                 + Fx00(ax,bx)*Sy00(ay,by)*Szmm(az,bz)
         Jy = Jy + Sxmm(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
                 + Sx00(ax,bx)*Fymm(ay,by)*Sz00(az,bz) &
                 + Sx00(ax,bx)*Fy00(ay,by)*Szmm(az,bz)
         Jz = Jz + Sxmm(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
                 + Sx00(ax,bx)*Symm(ay,by)*Fz00(az,bz) &
                 + Sx00(ax,bx)*Sy00(ay,by)*Fzmm(az,bz)

      end

      rys.destroy
      Fzmm.destroy; Fymm.destroy; Fxmm.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz

   end

   make_irrotational_jd_ints(Jx,Jy,Jz,B_field,origin,c)
   ! Make the solenoidal Jd integrals "Ji", with external magnetic field
   ! "B_field", gauge origin at "origin", and evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr (div J^d_ab(r)) (c - r)/|c - r|3
   !     J^d_ab(r) = B (2 g_a(r)g_b(r) + (r-r_o).grad g_a(r)g_b(r))
   !                 - (r-r_o)(B.grad g_a(r)g_b(r))
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      self :: INOUT
      Jx,Jy,Jz :: MAT{REAL}, OUT
      B_field,origin,c :: VEC{REAL}(3), IN

      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01 :: MAT{REAL}@
      Sxpp,Sypp,Szpp,Dx00,Dy00,Dz00 :: MAT{REAL}@
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01 :: MAT{REAL}@
      Fxpp,Fypp,Fzpp,Qx00,Qy00,Qz00 :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac,B_x,B_y,B_z :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      Sx00_ab,Sy00_ab,Sz00_ab,Fx00_ab,Fy00_ab,Fz00_ab :: REAL
      Dx00_ab,Dy00_ab,Dz00_ab,Qx00_ab,Qy00_ab,Qz00_ab :: REAL
      Sxpp_ab,Sypp_ab,Szpp_ab,Fxpp_ab,Fypp_ab,Fzpp_ab :: REAL
      rys :: RYS@

      B_x = B_field(1)
      B_y = B_field(2)
      B_z = B_field(3)

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Dx00.create(.a.l+2,.b.l+2); Dy00.create(.a.l+2,.b.l+2); Dz00.create(.a.l+2,.b.l+2)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      Qx00.create(.a.l+2,.b.l+2); Qy00.create(.a.l+2,.b.l+2); Qz00.create(.a.l+2,.b.l+2)

      p = .a.exponent + .b.exponent
      rpc = (.a.exponent*.a.position + .b.exponent*.b.position)/p - c
      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*rpc.dot(rpc)
      rys.get_weights_and_u_roots(xx)

      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots

         uu = p*rys.root(k)
         wt =   rys.weight(k)

         .make_q_field_ints(Sx00,Dx00,Fx00,Qx00,1,uu,c(1),origin(1),.a.l+1,.b.l+1)
         .make_q_field_ints(Sy00,Dy00,Fy00,Qy00,2,uu,c(2),origin(2),.a.l+1,.b.l+1)
         .make_q_field_ints(Sz00,Dz00,Fz00,Qz00,3,uu,c(3),origin(3),.a.l+1,.b.l+1)

         Sz00 =  Sz00*wt
         Dz00 =  Dz00*wt
         Fz00 =  Fz00*wt
         Qz00 =  Qz00*wt

         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)

         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10

         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Sx00_ab = Sx00(aix,bix)
             Sy00_ab = Sy00(aiy,biy)
             Sz00_ab = Sz00(aiz,biz)
             Fx00_ab = Fx00(aix,bix)
             Fy00_ab = Fy00(aiy,biy)
             Fz00_ab = Fz00(aiz,biz)
             Dx00_ab = Dx00(aix,bix)
             Dy00_ab = Dy00(aiy,biy)
             Dz00_ab = Dz00(aiz,biz)
             Qx00_ab = Qx00(aix,bix)
             Qy00_ab = Qy00(aiy,biy)
             Qz00_ab = Qz00(aiz,biz)
             Sxpp_ab = Sxpp(aix,bix)
             Sypp_ab = Sypp(aiy,biy)
             Szpp_ab = Szpp(aiz,biz)
             Fxpp_ab = Fxpp(aix,bix)
             Fypp_ab = Fypp(aiy,biy)
             Fzpp_ab = Fzpp(aiz,biz)
             Jx(a,b) = Jx(a,b) &
                 + B_y*Fxpp_ab*Sy00_ab*Dz00_ab - B_z*Fxpp_ab*Dy00_ab*Sz00_ab &
                 + B_z*Qx00_ab*Sypp_ab*Sz00_ab - B_x*Fx00_ab*Sypp_ab*Dz00_ab &
                 + B_x*Fx00_ab*Dy00_ab*Szpp_ab - B_y*Qx00_ab*Sy00_ab*Szpp_ab
             Jy(a,b) = Jy(a,b) &
                 + B_y*Sxpp_ab*Fy00_ab*Dz00_ab - B_z*Sxpp_ab*Qy00_ab*Sz00_ab &
                 + B_z*Dx00_ab*Fypp_ab*Sz00_ab - B_x*Sx00_ab*Fypp_ab*Dz00_ab &
                 + B_x*Sx00_ab*Qy00_ab*Szpp_ab - B_y*Dx00_ab*Fy00_ab*Szpp_ab
             Jz(a,b) = Jz(a,b) &
                 + B_y*Sxpp_ab*Sy00_ab*Qz00_ab - B_z*Sxpp_ab*Dy00_ab*Fz00_ab &
                 + B_z*Dx00_ab*Sypp_ab*Fz00_ab - B_x*Sx00_ab*Sypp_ab*Qz00_ab &
                 + B_x*Sx00_ab*Dy00_ab*Fzpp_ab - B_y*Dx00_ab*Sy00_ab*Fzpp_ab
           end
         end
!         Jx = Jx + B_field(2)*Fxpp(ax,bx)*Sy00(ay,by)*Dz00(az,bz) - B_field(3)*Fxpp(ax,bx)*Dy00(ay,by)*Sz00(az,bz) &
!                 + B_field(3)*Qx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz) - B_field(1)*Fx00(ax,bx)*Sypp(ay,by)*Dz00(az,bz) &
!                 + B_field(1)*Fx00(ax,bx)*Dy00(ay,by)*Szpp(az,bz) - B_field(2)*Qx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz)
!         Jy = Jy + B_field(2)*Sxpp(ax,bx)*Fy00(ay,by)*Dz00(az,bz) - B_field(3)*Sxpp(ax,bx)*Qy00(ay,by)*Sz00(az,bz) &
!                 + B_field(3)*Dx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) - B_field(1)*Sx00(ax,bx)*Fypp(ay,by)*Dz00(az,bz) &
!                 + B_field(1)*Sx00(ax,bx)*Qy00(ay,by)*Szpp(az,bz) - B_field(2)*Dx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)
!         Jz = Jz + B_field(2)*Sxpp(ax,bx)*Sy00(ay,by)*Qz00(az,bz) - B_field(3)*Sxpp(ax,bx)*Dy00(ay,by)*Fz00(az,bz) &
!                 + B_field(3)*Dx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz) - B_field(1)*Sx00(ax,bx)*Sypp(ay,by)*Qz00(az,bz) &
!                 + B_field(1)*Sx00(ax,bx)*Dy00(ay,by)*Fzpp(az,bz) - B_field(2)*Dx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)
      end

      rys.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Dz00.destroy; Dy00.destroy; Dx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy

      rab = .a.position - .b.position
      prefac = exp(-.a.exponent*.b.exponent*rab.dot(rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz

   end


   put
   ! Put the object to file "stdout"
      stdout.flush
      stdout.text("GAUSSIAN2:")
      stdout.flush
      stdout.show("l_a   =",.a.l)
      stdout.show("l_b   =",.b.l)
      stdout.show("pos_a =",.a.position)
      stdout.show("pos_b =",.b.position)
      stdout.show("ex_a  =",.a.exponent)
      stdout.show("ex_b  =",.b.exponent)
   end

  ! --------------------------------
  ! Finite gaussian nucleus routines
  ! --------------------------------

   nucleus_eta(c) result (eta) ::: selfless
   ! get the nucleus exponent
      c :: INT, IN
      eta :: REAL

      eta  = gaussian_nucleus_eta(c)

   end

   make_normalised_finite_NA_ints(NA,c,nc,n,spherical)
   ! Calculate finite gaussian NA integrals.
      NA :: MAT{REAL}
      c :: VEC{REAL}(3)
      nc,n :: INT
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_finite_nuclear_attraction_ints(NA,c,nc,n)
      elseif (.a.l<2 AND .b.l<2) then
         .make_finite_nuclear_attraction_ints(NA,c,nc,n)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_finite_nuclear_attraction_ints(W,c,nc,n)
         .change_to_spherical(W,NA)
         W.destroy
      end

      NA = NA * .normalisation_factor

   end

   make_finite_nuclear_attraction_ints(I,npos,nc,n)
   ! Make ERI matrix "I" using Rys decomposition of 1/r_{12}.
      self :: INOUT
      I :: MAT{REAL}, OUT
      npos :: VEC{REAL}(3), IN
      nc,n :: INT, IN

      Ix,Iy,Iz :: MAT3{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rys :: RYS@

      AB,CD,P,Q,PA,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,fac,h,r212 :: REAL
      l_e,l_f,n_roots,fa,la,fb,lb :: INT

      ! Angular momenta and # of roots
      l_e = .a.l + .b.l
      l_f = 0
!     n_roots = (l_e+l_f)/2 + 2 ! orig LBxxx
      n_roots = (l_e + l_f + 2 )/2  ! orig LBxxx
      h=5.0000000000000000000d-7  ! this is in Knecht

      ! Allocate 2D integrals
      Ix.create(n_roots,l_e+1,.b.l+1)
      Iy.create(n_roots,l_e+1,.b.l+1)
      Iz.create(n_roots,l_e+1,.b.l+1)

      ! Gaussian index arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! Exponents
      zeta = .a.exponent + .b.exponent
      eta  = gaussian_nucleus_eta(nc)
      r212=sqrt(THREE/TWO/eta)
      r212=r212+real(n)*h
      eta  = THREE/TWO/r212**2
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      ! Positions
      AB  = .a.position - .b.position
      CD  = ZERO !.a.pos - .a.pos
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = npos
      PA  = P - .a.position
   !   QC  = ZERO !Q - .a.pos
      QP  = Q - P

      ! Rys roots
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      ! Form the 2D integrals
       .form_2d_ints(Ix(:,:,1),Iy(:,:,1),Iz(:,:,1),rys.root,rys.weight,rho,zinv,PA,QP)
      .transfer_2d_ints(Ix,Iy,Iz,AB)

      ! Form the integrals
       I = sum(Ix(:,ax,bx)*Iy(:,ay,by)*Iz(:,az,bz),dim=1)

      ! Cleanup
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy

      ! Prefactor
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-.a.exponent*.b.exponent*AB2*zinv)
      fac = fac * sqrt(eta/PI)**3
      I = fac*I

   end


   transfer_2d_ints(Ix,Iy,Iz,AB,max_b) ::: pure, private
   ! A hack from the 4 center integrals to let the finite gaussian NA ints work
   ! Use the transfer relation to put momenta on centr B to get all
   ! the 2d integrals "Ix", "Iy" and "Iz". If present, "max_b" and "max_d"
   ! are the maximum l-values desired for centers b and d, respectively.
   ! You must ensure that the "Ii" arrays are big enough, in this case.
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, INOUT
      AB :: VEC{REAL}(3), IN
      max_b :: INT, IN, optional
      le1,l_a,l_b,a,b,a1,b1 :: INT

      l_a = .a.l
      l_b = .b.l

      if (present(max_b)) l_b = max_b

      if (l_b==0) return

      if (l_b/=0) then
         le1 = l_a + l_b + 1
         do b = 1,l_b
         do a = 1,le1 - b
            b1 = b + 1
            a1 = a + 1
            Ix(:,a,b1) = Ix(:,a1,b) + AB(1)*Ix(:,a,b)
            Iy(:,a,b1) = Iy(:,a1,b) + AB(2)*Iy(:,a,b)
            Iz(:,a,b1) = Iz(:,a1,b) + AB(3)*Iz(:,a,b)
         end
         end
      end

   end

   transfer_2d_ints_2(Ix,Iy,Iz,AB,max_a,max_b) ::: pure, private
   ! A hack from the 4 center integrals to let the finite gaussian DKH ints work
   ! Use the transfer relation to put momenta on centr B to get all
   ! the 2d integrals "Ix", "Iy" and "Iz". If present, "max_b" and "max_d"
   ! are the maximum l-values desired for centers b and d, respectively.
   ! You must ensure that the "Ii" arrays are big enough, in this case.
      self :: IN
      Ix,Iy,Iz :: MAT3{REAL}, INOUT
      AB :: VEC{REAL}(3), IN
      max_a,max_b :: INT, IN, optional
      le1,l_a,l_b,a,b,a1,b1 :: INT
      l_a = .a.l; l_b = .b.l
      if (present(max_a)) l_a=max_a
      if (present(max_b)) l_b=max_b
      if (l_b==0) return
      if (l_b/=0) then
         le1 = l_a + l_b + 1
         do b = 1,l_b
         do a = 1,le1 - b
            b1 = b + 1
            a1 = a + 1
            Ix(:,a,b1) = Ix(:,a1,b) + AB(1)*Ix(:,a,b)
            Iy(:,a,b1) = Iy(:,a1,b) + AB(2)*Iy(:,a,b)
            Iz(:,a,b1) = Iz(:,a1,b) + AB(3)*Iz(:,a,b)
         end
         end
      end

   end

   form_2d_ints(Ix,Iy,Iz,t2,wt,rho,zinv,PA,QP,max_e) ::: pure
   ! Forms the two dimensional integrals "Ix", "Iy" and "Iz" with momenta only
   ! on center A, using Rys roots "t2" and weights "wt".
   ! Other variables are intermediates, to avoid calculations: see make_ERI_ints.
   ! If present, "max_e" and "max_f" are used for the maximum angular momenta
   ! of centers (a+b) and (c+d) respectively -- for derivative integrals.
      self :: IN
      Ix,Iy,Iz :: MAT{REAL}, INOUT
      t2,wt :: VEC{REAL}, IN
      rho,zinv :: REAL, IN
      PA,QP :: VEC{REAL}(3), IN
      max_e :: INT, IN, optional

      rzt,ce,ce1 :: VEC{REAL}(size(t2))
      l_e,l_f,e,em1,ep1,k :: INT

      l_e = .a.l + .b.l
      l_f = 0
      if (present(max_e)) l_e = max_e

      Ix(:,1) = ONE
      Iy(:,1) = ONE
      Iz(:,1) = ONE

       if (l_e>0) then

         rzt = rho*t2*zinv
         Ix(:,2) = PA(1) + rzt(:)*QP(1)
         Iy(:,2) = PA(2) + rzt(:)*QP(2)
         Iz(:,2) = PA(3) + rzt(:)*QP(3)

         if (l_e>1) then
           ce = (ONE - rzt) * HALF * zinv
           do e = 2,l_e
             em1 = e - 1
             ep1 = e + 1
             ce1 = em1 * ce
             Ix(:,ep1) = Ix(:,2)*Ix(:,e) + ce1*Ix(:,em1)
             Iy(:,ep1) = Iy(:,2)*Iy(:,e) + ce1*Iy(:,em1)
             Iz(:,ep1) = Iz(:,2)*Iz(:,e) + ce1*Iz(:,em1)
           end
         end

       end

      ! Multiply Iz by the weight
      do k = 1,size(Iz,1)
        Iz(k,:) = Iz(k,:)*wt(k)
      end

   end

   make_normalised_finite_DKH_ints(T,SOx,SOy,SOz,c,nc,n,spherical)
   ! Calculate finite nuclues DKH integrals.
      T,SOx,SOy,SOz :: MAT{REAL}
      c :: VEC{REAL}(3)
      nc,n :: INT
      spherical :: BIN, optional

      W,Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_finite_DKH_ints(T,SOx,SOy,SOz,c,nc,n)
      elseif ( .a.l<2 AND .b.l<2) then
         .make_finite_DKH_ints(T,SOx,SOy,SOz,c,nc,n)
      else
         W.create(.a.n_comp,.b.n_comp)
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_finite_DKH_ints(W,Wx,Wy,Wz,c,nc,n)
         .change_to_spherical(W,T)
         .change_to_spherical(Wx,SOx)
         .change_to_spherical(Wy,SOy)
         .change_to_spherical(Wz,SOz)
         Wz.destroy
         Wy.destroy
         Wx.destroy
         W.destroy
      end

      T   = T   * .normalisation_factor
      SOx = SOx * .normalisation_factor
      SOy = SOy * .normalisation_factor
      SOz = SOz * .normalisation_factor

   end

   make_finite_DKH_ints(T,SOx,SOy,SOz,npos,nc,n)
   ! Make ERI matrix "I" using Rys decomposition of 1/r_{12}.
      self :: INOUT
      T,SOx,SOy,SOz :: MAT{REAL}, OUT
      npos :: VEC{REAL}(3), IN
      nc,n :: INT, IN

      NAx,NAy,NAz :: MAT3{REAL}@
      AAx,ABx,BBx,AAy,ABy,BBy,AAz,ABz,BBz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rys :: RYS@
      AB,CD,P,Q,PA,QP :: VEC{REAL}(3)
      zeta,zinv,eta,einv,zeinv,rho,xx,AB2,fac,h,r212 :: REAL
      i,l_e,l_f,n_roots,fa,la,fb,lb :: INT

      ! Angular momenta and # of roots
      l_e = .a.l + .b.l
      l_f = 0
        n_roots = (l_e + l_f + 4)/2 +1 !
      h=5.0000000000000000000d-7

      ! Gaussian index arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(n_roots,l_e+3,.b.l+2); NAy.create(n_roots,l_e+3,.b.l+2)
      NAz.create(n_roots,l_e+3,.b.l+2)
      AAx.create(l_e+2,.b.l+2); AAy.create(l_e+2,.b.l+2); AAz.create(l_e+2,.b.l+2)
      BBx.create(l_e+3,.b.l+1); BBy.create(l_e+3,.b.l+1); BBz.create(l_e+3,.b.l+1)
      ABx.create(l_e+2,.b.l+1); ABy.create(l_e+2,.b.l+1); ABz.create(l_e+2,.b.l+1)

      ! Exponents
      zeta = .a.exponent + .b.exponent
      eta  = gaussian_nucleus_eta(nc)
      r212=sqrt(THREE/TWO/eta)
      r212=r212+real(n)*h
      eta  = THREE/TWO/r212**2
      zinv = ONE/zeta
      einv = ONE/eta
      zeinv = ONE/(zeta+eta)
      rho  = zeta*eta*zeinv

      ! Positions
      AB  = .a.position - .b.position
      CD  = ZERO !.a.pos - .a.pos
      P   = (.a.exponent*.a.position + .b.exponent*.b.position)*zinv
      Q   = npos
      PA  = P - .a.position
    !  QC  = ZERO !Q - .a.pos
      QP  = Q - P

      ! Rys roots
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)

      ! Form the 2D integrals
      .form_2d_ints(NAx(:,:,1),NAy(:,:,1),NAz(:,:,1),rys.root,rys.weight,rho,zinv,PA,QP,l_e+2)
      .transfer_2d_ints_2(NAx,NAy,NAz,AB,.a.l+1,.b.l+1)

      T=ZERO
      SOx=ZERO; SOy=ZERO; SOz=ZERO

      do i = 1,n_roots

         .differentiate(NAx(i,:,:),"right",BBx)
         .differentiate(NAy(i,:,:),"right",BBy)
         .differentiate(NAz(i,:,:),"right",BBz)

         .differentiate(NAx(i,:,:),"left ",AAx)
         .differentiate(NAy(i,:,:),"left ",AAy)
         .differentiate(NAz(i,:,:),"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         T = T + ABx(ax,bx)*NAy(i,ay,by)*NAz(i,az,bz) &
               + NAx(i,ax,bx)*ABy(ay,by)*NAz(i,az,bz) &
               + NAx(i,ax,bx)*NAy(i,ay,by)*ABz(az,bz)

         SOx = SOx + NAx(i,ax,bx)*AAy(ay,by)*BBz(az,bz) &
                   - NAx(i,ax,bx)*BBy(ay,by)*AAz(az,bz)

         SOy = SOy + BBx(ax,bx)*NAy(i,ay,by)*AAz(az,bz) &
                   - AAx(ax,bx)*NAy(i,ay,by)*BBz(az,bz)

         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(i,az,bz) &
                   - BBx(ax,bx)*AAy(ay,by)*NAz(i,az,bz)

     end do

      ! Cleanup
      rys.destroy
      NAz.destroy; NAy.destroy; NAx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      ABz.destroy; ABy.destroy; ABx.destroy

      ! Prefactor
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-.a.exponent*.b.exponent*AB2*zinv)
      fac = fac * sqrt(eta/PI)**3
      T = fac*T; SOx = fac*SOx; SOy = fac*SOy; SOz = fac*SOz

   end

   make_normalised_G_overlap_ints(S,pos,nuc,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      S :: MAT{REAL}
      pos :: VEC{REAL}
      nuc :: INT
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_overlap_G_ints(S,pos,nuc)
      elseif ( .a.l<2 AND .b.l<2 )  then
         .make_overlap_G_ints(S,pos,nuc)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_overlap_G_ints(W,pos,nuc)
         .change_to_spherical(W,S)
         W.destroy
      end

      S = S * .normalisation_factor

   end

   make_overlap_G_ints(S,pos,nuc)
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      S :: MAT{REAL}
      pos :: VEC{REAL}
      nuc :: INT

      Sx,Sy,Sz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      S=ZERO
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      .make_overlap_G_ints(Sx,1,pos(1),nuc)
      .make_overlap_G_ints(Sy,2,pos(2),nuc)
      .make_overlap_G_ints(Sz,3,pos(3),nuc)
!     The following loops can be simplified by the one line statement:
!     S = Sx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          S(a,b) = Sx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
        end
      end
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
  !    prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      prefac = exp(-.a.exponent*.b.exponent*sum(rab*rab)/p)
      S = prefac*S

   end

   make_overlap_G_ints(Sx,x,Nx,nuc,max_a,max_b)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! on the Gaussian nuclues - the result is only density!
   ! If present, "max_a" and "max_b" are used for the maximum angular momenta
   ! of centers (a) and (b) respectively -- for derivative integrals.
   ! Uses Gauss-Hermite quadrature.
      Sx :: MAT{REAL}
      x,nuc :: INT
      Nx :: REAL
      max_a,max_b :: INT, optional
      p,q,t,rp,rq,ax,bx,cx,c,wt,pt,ra,rb :: REAL
      mu,nu,xab,xpc :: REAL
      l_a,l_b, a,b,i,k :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.exponent + .b.exponent

    ! t = sqrt(p) ! we will use q here
      ax = .a.position(x)
      bx = .b.position(x)
      rp = (.a.exponent*ax + .b.exponent*bx)/p

      ! seems to be normally accounted in the prefactors, but will be needed
      mu=(.a.exponent * .b.exponent)/p
      xab=ax-bx

      ! new stuff
      c= gaussian_nucleus_eta(nuc)
      cx= Nx  ! position of nucleus
      q=p+c

      t=sqrt(q) ! should be correct
!     nu=mu*c/(mu+c)
      nu=p*c/(p+c)
      rq=(p*rp+c*cx)/q
      xpc=(rp-cx)

      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
!            pt = gauss_hermite_pt(k)/t + rp
            pt = gauss_hermite_pt(k)/t + rq
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
         end
      end
      end

!      Sx=Sx/sqrt(q)*sqrt(q/PI)
      Sx=Sx/sqrt(q)*sqrt(c/PI)
!      if (x==3)then
        Sx=Sx*exp(-nu*xpc**2)
!      end if
   end

   make_normalised_pGp_overlap_ints(S,SOx,SOy,SOz,pos,nuc,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      S,SOx,SOy,SOz :: MAT{REAL}
      pos :: VEC{REAL}
      nuc :: INT
      spherical :: BIN, optional

      W,Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_overlap_pGp_ints(S,SOx,SOy,SOz,pos,nuc)
      elseif ( .a.l<2 AND .b.l<2 )  then
         .make_overlap_pGp_ints(S,SOx,SOy,SOz,pos,nuc)
      else
         W.create(.a.n_comp,.b.n_comp)
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_overlap_pGp_ints(W,Wx,Wy,Wz,pos,nuc)
         .change_to_spherical(W,S)
         .change_to_spherical(Wx,SOx)
         .change_to_spherical(Wy,SOy)
         .change_to_spherical(Wz,SOz)
         W.destroy
         Wx.destroy
         Wy.destroy
         Wz.destroy
      end

      S = S * .normalisation_factor
      SOx = SOx * .normalisation_factor
      SOy = SOy * .normalisation_factor
      SOz = SOz * .normalisation_factor

   end

   make_overlap_pGp_ints(S,SOx,SOy,SOz,pos,nuc)
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      S,SOx,SOy,SOz :: MAT{REAL}
      pos :: VEC{REAL}
      nuc :: INT

      Sx,Sy,Sz,AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      S=ZERO
      SOx=ZERO;SOy=ZERO;SOz=ZERO
      Sx.create(.a.l+2,.b.l+2); Sy.create(.a.l+2,.b.l+2); Sz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+2,.b.l+1); BBy.create(.a.l+2,.b.l+1); BBz.create(.a.l+2,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      Sx=ZERO;Sy=ZERO;Sz=ZERO
      AAx=ZERO;AAy=ZERO;AAz=ZERO
      ABx=ZERO;ABy=ZERO;ABz=ZERO
      BBx=ZERO;BBy=ZERO;BBz=ZERO

      .make_overlap_G_ints(Sx,1,pos(1),nuc,.a.l+1,.b.l+1)
      .make_overlap_G_ints(Sy,2,pos(2),nuc,.a.l+1,.b.l+1)
      .make_overlap_G_ints(Sz,3,pos(3),nuc,.a.l+1,.b.l+1)


         .differentiate(Sx,"right",BBx)
         .differentiate(Sy,"right",BBy)
         .differentiate(Sz,"right",BBz)

         .differentiate(Sx,"left ",AAx)
         .differentiate(Sy,"left ",AAy)
         .differentiate(Sz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         S = S + ABx(ax,bx)*Sy(ay,by)*Sz(az,bz) &
               + Sx(ax,bx)*ABy(ay,by)*Sz(az,bz) &
               + Sx(ax,bx)*Sy(ay,by)*ABz(az,bz)

         SOx = SOx + Sx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                   - Sx(ax,bx)*BBy(ay,by)*AAz(az,bz)

         SOy = SOy + BBx(ax,bx)*Sy(ay,by)*AAz(az,bz) &
                   - AAx(ax,bx)*Sy(ay,by)*BBz(az,bz)

         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*Sz(az,bz) &
                   - BBx(ax,bx)*AAy(ay,by)*Sz(az,bz)

      Sz.destroy; Sy.destroy; Sx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      p = .a.exponent + .b.exponent
      rab = .a.position - .b.position
  !    prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      prefac = exp(-.a.exponent*.b.exponent*sum(rab*rab)/p)
      S = prefac*S;SOx = prefac*SOx;SOy = prefac*SOy;SOz = prefac*SOz

   end


!!!!!!!!!!!!!!!!!!!!
!!! new staff on the PCE correction of visualized densities
!!!!!!!!!!!!!!!!!!!!

   make_normalised_density_gg(S,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      S :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_density_gg(S,x,y,z)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_density_gg(S,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_density_gg(W,x,y,z)
         .change_to_spherical(W,S)
         W.destroy
      end

      S = S * .normalisation_factor

   end

   make_density_gg(S,x,y,z)
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      S :: MAT{REAL}
      x,y,z :: REAL

      Sx,Sy,Sz :: MAT{REAL}@
      ax,ay,az,bx,by,bz :: VEC{INT}@
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      .make_density_part(Sx,1,x)
      .make_density_part(Sy,2,y)
      .make_density_part(Sz,3,z)

!     The following loops can be simplified by the one line statement:
!     S = Sx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          S(a,b) = Sx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
        end
      end

      Sz.destroy; Sy.destroy; Sx.destroy

   end

   make_density_part(Sx,x,pos,max_a,max_b)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! If present, "max_a" and "max_b" are used for the maximum angular momenta
   ! of centers (a) and (b) respectively -- for derivative integrals.
   ! Uses Gauss-Hermite quadrature.
      Sx :: MAT{REAL}
      x :: INT
      pos :: REAL
      max_a,max_b :: INT, optional

      rp,ax,bx :: REAL
      l_a,l_b, a,b :: INT

      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b

      ax = pos-.a.position(x)
      bx = pos-.b.position(x)

      rp = (.a.exponent*ax**2 + .b.exponent*bx**2)

      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         Sx(a,b) = exp(-rp)*ax**(a-1)*bx**(b-1)
      end
      end

   end

   make_normalised_pDp_gg(T,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_pDp_gg(T,x,y,z)
      elseif  ( .a.l<2 AND .b.l<2 )  then
         .make_pDp_gg(T,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_pDp_gg(W,x,y,z)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_pDp_gg(T,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      T = ZERO

      .make_density_part(NAx,1,x,.a.l+1,.b.l+1)
      .make_density_part(NAy,2,y,.a.l+1,.b.l+1)
      .make_density_part(NAz,3,z,.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz)

!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)


      ! Clean up
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_ppDpp_gg(T,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_ppDpp_gg(T,x,y,z)
      elseif  ( .a.l<2 AND .b.l<2 )  then
         .make_ppDpp_gg(T,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_ppDpp_gg(W,x,y,z)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_ppDpp_gg_not_ok(ppDpp,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      ppDpp :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}@
      AB2x,AB2y,AB2z :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      A2x.create(.a.l+1,.b.l+3); A2y.create(.a.l+1,.b.l+3); A2z.create(.a.l+1,.b.l+3)
      BBx.create(.a.l+3,.b.l+2); BBy.create(.a.l+3,.b.l+2); BBz.create(.a.l+3,.b.l+2)
      B2x.create(.a.l+3,.b.l+1); B2y.create(.a.l+3,.b.l+1); B2z.create(.a.l+3,.b.l+1)
      ABx.create(.a.l+2,.b.l+1); ABy.create(.a.l+2,.b.l+1); ABz.create(.a.l+2,.b.l+1)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)


      ! Assemble the integrals
      ppDpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+2,.b.l+2)
         .make_density_part(NAy,2,y,.a.l+2,.b.l+2)
         .make_density_part(NAz,3,z,.a.l+2,.b.l+2)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
         .differentiate(AAx,"left ",A2x)
         .differentiate(AAy,"left ",A2y)
         .differentiate(AAz,"left ",A2z)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(BBx,"right",B2x)
         .differentiate(BBy,"right",B2y)
         .differentiate(BBz,"right",B2z)

         .differentiate(B2x,"left",ABx)
         .differentiate(B2y,"left",ABy)
         .differentiate(B2z,"left",ABz)

         .differentiate(ABx,"left",AB2x)
         .differentiate(ABy,"left",AB2y)
         .differentiate(ABz,"left",AB2z)

         ppDpp = A2x(ax,bx)*B2y(ay,by)*NAz(az,bz) &
               + B2x(ax,bx)*A2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
               + NAx(ax,bx)*B2y(ay,by)*A2z(az,bz) &
               + A2x(ax,bx)*NAy(ay,by)*B2z(az,bz) &
               + B2x(ax,bx)*NAy(ay,by)*A2z(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz)

! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)

      AB2z.destroy; AB2y.destroy; AB2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      A2z.destroy; A2y.destroy; A2x.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_ppDpp_gg(ppDpp,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      ppDpp :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      AB2x,AB2y,AB2z :: MAT{REAL}*
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      BBx.create(.a.l+1,.b.l+2); BBy.create(.a.l+1,.b.l+2); BBz.create(.a.l+1,.b.l+2)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)


      ! Assemble the integrals
      ppDpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+2,.b.l+2)
         .make_density_part(NAy,2,y,.a.l+2,.b.l+2)
         .make_density_part(NAz,3,z,.a.l+2,.b.l+2)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         .differentiate(ABx,"left",BBx)
         .differentiate(ABy,"left",BBy)
         .differentiate(ABz,"left",BBz)

         .differentiate(BBx,"right",AB2x)
         .differentiate(BBy,"right",AB2y)
         .differentiate(BBz,"right",AB2z)

         ppDpp = TWO*ABx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + TWO*NAx(ax,bx)*ABy(ay,by)*ABz(az,bz) &
               + TWO*ABx(ax,bx)*NAy(ay,by)*ABz(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz)

! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)

      AB2z.destroy; AB2y.destroy; AB2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
!      A2z.destroy; A2y.destroy; A2x.destroy
!      B2z.destroy; B2y.destroy; B2x.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_pDp_SO_gg(Dx,Dy,Dz,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      Dx,Dy,Dz :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_pDp_SO_gg(Dx,Dy,Dz,x,y,z)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_pDp_SO_gg(Dx,Dy,Dz,x,y,z)
      else
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_pDp_SO_gg(Wx,Wy,Wz,x,y,z)
         .change_to_spherical(Wx,Dx)
         .change_to_spherical(Wy,Dy)
         .change_to_spherical(Wz,Dz)
         Wz.destroy
         Wy.destroy
         Wx.destroy
      end

      Dx = Dx * .normalisation_factor
      Dy = Dy * .normalisation_factor
      Dz = Dz * .normalisation_factor

   end

   make_pDp_SO_gg(SOx,SOy,SOz,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      SOx,SOy,SOz :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+2,.b.l+3); NAy.create(.a.l+2,.b.l+3); NAz.create(.a.l+2,.b.l+3)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      SOx = ZERO
      SOy = ZERO
      SOz = ZERO

      .make_density_part(NAx,1,x,.a.l+1,.b.l+1)
      .make_density_part(NAy,2,y,.a.l+1,.b.l+1)
      .make_density_part(NAz,3,z,.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

!        T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
!              + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
!              + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz)

         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)


      ! Clean up
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

! extra LAPLACIAN PCE stuff

   make_normalised_ppDpp_SO_gg(Dx,Dy,Dz,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      Dx,Dy,Dz :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_ppDpp_SO_gg(Dx,Dy,Dz,x,y,z)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_ppDpp_SO_gg(Dx,Dy,Dz,x,y,z)
      else
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_ppDpp_SO_gg(Wx,Wy,Wz,x,y,z)
         .change_to_spherical(Wx,Dx)
         .change_to_spherical(Wy,Dy)
         .change_to_spherical(Wz,Dz)
         Wz.destroy
         Wy.destroy
         Wx.destroy
      end

      Dx = Dx * .normalisation_factor
      Dy = Dy * .normalisation_factor
      Dz = Dz * .normalisation_factor

   end

   make_ppDpp_SO_gg(SOx,SOy,SOz,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      SOx,SOy,SOz :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}@
      ABx,ABy,ABz,BBx,BBy,BBz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      BBx.create(.a.l+3,.b.l+2); BBy.create(.a.l+3,.b.l+2); BBz.create(.a.l+3,.b.l+2)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      A2x.create(.a.l+1,.b.l+2); A2y.create(.a.l+1,.b.l+2); A2z.create(.a.l+1,.b.l+2)
      B2x.create(.a.l+2,.b.l+1); B2y.create(.a.l+2,.b.l+1); B2z.create(.a.l+2,.b.l+1)

      ! Assemble the integrals
       SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+2,.b.l+2)
         .make_density_part(NAy,2,y,.a.l+2,.b.l+2)
         .make_density_part(NAz,3,z,.a.l+2,.b.l+2)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         .differentiate(ABx,"left",A2x)
         .differentiate(ABy,"left",A2y)
         .differentiate(ABz,"left",A2z)

         .differentiate(ABx,"right",B2x)
         .differentiate(ABy,"right",B2y)
         .differentiate(ABz,"right",B2z)

!         SOx = SOx + ABx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
!                   - ABx(ax,bx)*B2y(ay,by)*A2z(az,bz)
          SOx = SOx + ABx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                    - ABx(ax,bx)*BBy(ay,by)*AAz(az,bz) &
                    + NAx(ax,bx)*A2y(ay,by)*BBz(az,bz) &
                    - NAx(ax,bx)*B2y(ay,by)*AAz(az,bz) &
                    + NAx(ax,bx)*AAy(ay,by)*B2z(az,bz) &
                    - NAx(ax,bx)*BBy(ay,by)*A2z(az,bz)

!         SOy = SOy + B2x(ax,bx)*ABy(ay,by)*A2z(az,bz) &
!                   - A2x(ax,bx)*ABy(ay,by)*B2z(az,bz)
          SOy = SOy + B2x(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                    - A2x(ax,bx)*NAy(ay,by)*BBz(az,bz) &
                    + BBx(ax,bx)*ABy(ay,by)*AAz(az,bz) &
                    - AAx(ax,bx)*ABy(ay,by)*BBz(az,bz) &
                    + BBx(ax,bx)*NAy(ay,by)*A2z(az,bz) &
                    - AAx(ax,bx)*NAy(ay,by)*B2z(az,bz)

!         SOz = SOz + A2x(ax,bx)*B2y(ay,by)*ABz(az,bz) &
!                   - B2x(ax,bx)*A2y(ay,by)*ABz(az,bz)
          SOz = SOz + A2x(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                    - B2x(ax,bx)*AAy(ay,by)*NAz(az,bz) &
                    + AAx(ax,bx)*B2y(ay,by)*NAz(az,bz) &
                    - BBx(ax,bx)*A2y(ay,by)*NAz(az,bz) &
                    + AAx(ax,bx)*BBy(ay,by)*ABz(az,bz) &
                    - BBx(ax,bx)*AAy(ay,by)*ABz(az,bz)

      A2z.destroy; A2y.destroy; A2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
!      A2z.destroy; A2y.destroy; A2x.destroy
!      B2z.destroy; B2y.destroy; B2x.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_ppD_gg(T,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_ppD_gg(T,x,y,z)
      elseif  ( .a.l<2 AND .b.l<2 )  then
         .make_ppD_gg(T,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_ppD_gg(W,x,y,z)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_ppD_gg(T,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz, AAx,AAy,AAz,ABx,ABy,ABz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+3,.b.l+1); NAy.create(.a.l+3,.b.l+1); NAz.create(.a.l+3,.b.l+1)
      AAx.create(.a.l+2,.b.l+1); AAy.create(.a.l+2,.b.l+1); AAz.create(.a.l+2,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      T = ZERO

      .make_density_part(NAx,1,x,.a.l+2,.b.l)
      .make_density_part(NAy,2,y,.a.l+2,.b.l)
      .make_density_part(NAz,3,z,.a.l+2,.b.l)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"left",ABx)
         .differentiate(AAy,"left",ABy)
         .differentiate(AAz,"left",ABz)

         T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz)

!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)


      ! Clean up
      ABz.destroy; ABy.destroy; ABx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_Dpp_gg(T,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_Dpp_gg(T,x,y,z)
      elseif  ( .a.l<2 AND .b.l<2 )  then
         .make_Dpp_gg(T,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_Dpp_gg(W,x,y,z)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_Dpp_gg(T,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient.
      T :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz, AAx,AAy,AAz,ABx,ABy,ABz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+1,.b.l+3); NAy.create(.a.l+1,.b.l+3); NAz.create(.a.l+1,.b.l+3)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      T = ZERO

      .make_density_part(NAx,1,x,.a.l,.b.l+2)
      .make_density_part(NAy,2,y,.a.l,.b.l+2)
      .make_density_part(NAz,3,z,.a.l,.b.l+2)

         .differentiate(NAx,"right",AAx)
         .differentiate(NAy,"right",AAy)
         .differentiate(NAz,"right",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz)

!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)


      ! Clean up
      ABz.destroy; ABy.destroy; ABx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_pppDp_gg(T,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_pppDp_gg(T,x,y,z)
      elseif  ( .a.l<2 AND .b.l<2 )  then
         .make_pppDp_gg(T,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_pppDp_gg(W,x,y,z)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_pppDp_gg(T,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,AXx,AXy,AXz,ABx,ABy,ABz,XXx,XXy,XXz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+4,.b.l+2); NAy.create(.a.l+4,.b.l+2); NAz.create(.a.l+4,.b.l+2)
      AAx.create(.a.l+3,.b.l+2); AAy.create(.a.l+3,.b.l+2); AAz.create(.a.l+3,.b.l+2)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      AXx.create(.a.l+2,.b.l+1); AXy.create(.a.l+2,.b.l+1); AXz.create(.a.l+2,.b.l+1)
      XXx.create(.a.l+1,.b.l+1); XXy.create(.a.l+1,.b.l+1); XXz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      T = ZERO

      .make_density_part(NAx,1,x,.a.l+3,.b.l+1)
      .make_density_part(NAy,2,y,.a.l+3,.b.l+1)
      .make_density_part(NAz,3,z,.a.l+3,.b.l+1)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"left",ABx)
         .differentiate(AAy,"left",ABy)
         .differentiate(AAz,"left",ABz)

         .differentiate(ABx,"right",AXx)
         .differentiate(ABy,"right",AXy)
         .differentiate(ABz,"right",AXz)

         .differentiate(AXx,"left",XXx)
         .differentiate(AXy,"left",XXy)
         .differentiate(AXz,"left",XXz)
      AXz.destroy; AXy.destroy; AXx.destroy
  !LBXXX AXx.create(.a.l+2,.b.l+2); AXy.create(.a.l+2,.b.l+2); AXz.create(.a.l+2,.b.l+2)
      AXx.create(.a.l+3,.b.l+1); AXy.create(.a.l+3,.b.l+1); AXz.create(.a.l+3,.b.l+1)
         .differentiate(AAx,"right",AXx)
         .differentiate(AAy,"right",AXy)
         .differentiate(AAz,"right",AXz)

         T = T + XXx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*XXy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*XXz(az,bz) &
               + ABx(ax,bx)*AXy(ay,by)*NAz(az,bz) &
               + AXx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + ABx(ax,bx)*NAy(ay,by)*AXz(az,bz) &
               + AXx(ax,bx)*NAy(ay,by)*ABz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*AXz(az,bz) &
               + NAx(ax,bx)*AXy(ay,by)*ABz(az,bz)

!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)


      ! Clean up
      XXz.destroy; XXy.destroy; XXx.destroy
      AXz.destroy; AXy.destroy; AXx.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_pDppp_gg(T,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      T :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      W :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical)then
         .make_pDppp_gg(T,x,y,z)
      elseif  ( .a.l<2 AND .b.l<2 )  then
         .make_pDppp_gg(T,x,y,z)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_pDppp_gg(W,x,y,z)
         .change_to_spherical(W,T)
         W.destroy
      end

      T = T * .normalisation_factor

   end

   make_pDppp_gg(T,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,AXx,AXy,AXz,ABx,ABy,ABz,XXx,XXy,XXz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+2,.b.l+4); NAy.create(.a.l+2,.b.l+4); NAz.create(.a.l+2,.b.l+4)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      AXx.create(.a.l+2,.b.l+1); AXy.create(.a.l+2,.b.l+1); AXz.create(.a.l+2,.b.l+1)
      XXx.create(.a.l+1,.b.l+1); XXy.create(.a.l+1,.b.l+1); XXz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      T = ZERO

      .make_density_part(NAx,1,x,.a.l+1,.b.l+3)
      .make_density_part(NAy,2,y,.a.l+1,.b.l+3)
      .make_density_part(NAz,3,z,.a.l+1,.b.l+3)

         .differentiate(NAx,"right",AAx)
         .differentiate(NAy,"right",AAy)
         .differentiate(NAz,"right",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         .differentiate(ABx,"right",AXx)
         .differentiate(ABy,"right",AXy)
         .differentiate(ABz,"right",AXz)

         .differentiate(AXx,"left",XXx)
         .differentiate(AXy,"left",XXy)
         .differentiate(AXz,"left",XXz)
      AXz.destroy; AXy.destroy; AXx.destroy
   !LBXXX   AXx.create(.a.l+2,.b.l+2); AXy.create(.a.l+2,.b.l+2); AXz.create(.a.l+2,.b.l+2)
      AXx.create(.a.l+1,.b.l+3); AXy.create(.a.l+1,.b.l+3); AXz.create(.a.l+1,.b.l+3)
         .differentiate(AAx,"left",AXx)
         .differentiate(AAy,"left",AXy)
         .differentiate(AAz,"left",AXz)

         T = T + XXx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*XXy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*XXz(az,bz) &
               + ABx(ax,bx)*AXy(ay,by)*NAz(az,bz) &
               + AXx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + ABx(ax,bx)*NAy(ay,by)*AXz(az,bz) &
               + AXx(ax,bx)*NAy(ay,by)*ABz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*AXz(az,bz) &
               + NAx(ax,bx)*AXy(ay,by)*ABz(az,bz)

!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)


      ! Clean up
      XXz.destroy; XXy.destroy; XXx.destroy
      AXz.destroy; AXy.destroy; AXx.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_pppDp_SO_gg(Dx,Dy,Dz,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      Dx,Dy,Dz :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_pppDp_SO_gg(Dx,Dy,Dz,x,y,z)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_pppDp_SO_gg(Dx,Dy,Dz,x,y,z)
      else
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_pppDp_SO_gg(Wx,Wy,Wz,x,y,z)
         .change_to_spherical(Wx,Dx)
         .change_to_spherical(Wy,Dy)
         .change_to_spherical(Wz,Dz)
         Wz.destroy
         Wy.destroy
         Wx.destroy
      end

      Dx = Dx * .normalisation_factor
      Dy = Dy * .normalisation_factor
      Dz = Dz * .normalisation_factor

   end

   make_pppDp_SO_gg(SOx,SOy,SOz,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      SOx,SOy,SOz :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}@
      ABx,ABy,ABz,BBx,BBy,BBz :: MAT{REAL}*
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+4,.b.l+2); NAy.create(.a.l+4,.b.l+2); NAz.create(.a.l+4,.b.l+2)
      AAx.create(.a.l+3,.b.l+2); AAy.create(.a.l+3,.b.l+2); AAz.create(.a.l+3,.b.l+2)
      BBx.create(.a.l+4,.b.l+1); BBy.create(.a.l+4,.b.l+1); BBz.create(.a.l+4,.b.l+1)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      A2x.create(.a.l+1,.b.l+2); A2y.create(.a.l+1,.b.l+2); A2z.create(.a.l+1,.b.l+2)
      B2x.create(.a.l+2,.b.l+1); B2y.create(.a.l+2,.b.l+1); B2z.create(.a.l+2,.b.l+1)

      ! Assemble the integrals
       SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+3,.b.l+1)
         .make_density_part(NAy,2,y,.a.l+3,.b.l+1)
         .make_density_part(NAz,3,z,.a.l+3,.b.l+1)

         .differentiate(NAx,"left",AAx)
         .differentiate(NAy,"left",AAy)
         .differentiate(NAz,"left",AAz)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(AAx,"left",ABx)
         .differentiate(AAy,"left",ABy)
         .differentiate(AAz,"left",ABz)

         .differentiate(ABx,"left",A2x)
         .differentiate(ABy,"left",A2y)
         .differentiate(ABz,"left",A2z)

         .differentiate(ABx,"right",B2x)
         .differentiate(ABy,"right",B2y)
         .differentiate(ABz,"right",B2z)

!         SOx = SOx + ABx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
!                   - ABx(ax,bx)*B2y(ay,by)*A2z(az,bz)
          SOx = SOx + ABx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                    - ABx(ax,bx)*BBy(ay,by)*AAz(az,bz) &
                    + NAx(ax,bx)*A2y(ay,by)*BBz(az,bz) &
                    - NAx(ax,bx)*B2y(ay,by)*AAz(az,bz) &
                    + NAx(ax,bx)*AAy(ay,by)*B2z(az,bz) &
                    - NAx(ax,bx)*BBy(ay,by)*A2z(az,bz)

!         SOy = SOy + B2x(ax,bx)*ABy(ay,by)*A2z(az,bz) &
!                   - A2x(ax,bx)*ABy(ay,by)*B2z(az,bz)
          SOy = SOy + B2x(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                    - A2x(ax,bx)*NAy(ay,by)*BBz(az,bz) &
                    + BBx(ax,bx)*ABy(ay,by)*AAz(az,bz) &
                    - AAx(ax,bx)*ABy(ay,by)*BBz(az,bz) &
                    + BBx(ax,bx)*NAy(ay,by)*A2z(az,bz) &
                    - AAx(ax,bx)*NAy(ay,by)*B2z(az,bz)

!         SOz = SOz + A2x(ax,bx)*B2y(ay,by)*ABz(az,bz) &
!                   - B2x(ax,bx)*A2y(ay,by)*ABz(az,bz)
          SOz = SOz + A2x(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                    - B2x(ax,bx)*AAy(ay,by)*NAz(az,bz) &
                    + AAx(ax,bx)*B2y(ay,by)*NAz(az,bz) &
                    - BBx(ax,bx)*A2y(ay,by)*NAz(az,bz) &
                    + AAx(ax,bx)*BBy(ay,by)*ABz(az,bz) &
                    - BBx(ax,bx)*AAy(ay,by)*ABz(az,bz)

      A2z.destroy; A2y.destroy; A2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_pDppp_SO_gg(Dx,Dy,Dz,x,y,z,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      Dx,Dy,Dz :: MAT{REAL}
      x,y,z :: REAL
      spherical :: BIN, optional

      Wx,Wy,Wz :: MAT{REAL}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_pDppp_SO_gg(Dx,Dy,Dz,x,y,z)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_pDppp_SO_gg(Dx,Dy,Dz,x,y,z)
      else
         Wx.create(.a.n_comp,.b.n_comp)
         Wy.create(.a.n_comp,.b.n_comp)
         Wz.create(.a.n_comp,.b.n_comp)
         .make_pDppp_SO_gg(Wx,Wy,Wz,x,y,z)
         .change_to_spherical(Wx,Dx)
         .change_to_spherical(Wy,Dy)
         .change_to_spherical(Wz,Dz)
         Wz.destroy
         Wy.destroy
         Wx.destroy
      end

      Dx = Dx * .normalisation_factor
      Dy = Dy * .normalisation_factor
      Dz = Dz * .normalisation_factor

   end

   make_pDppp_SO_gg(SOx,SOy,SOz,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      SOx,SOy,SOz :: MAT{REAL}
      x,y,z :: REAL

      ax,ay,az,bx,by,bz :: VEC{INT}@
      NAx,NAy,NAz,AAx,AAy,AAz,A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}@
      ABx,ABy,ABz,BBx,BBy,BBz :: MAT{REAL}@
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::nx(fa:la); ay = GAUSSIAN_DATA::ny(fa:la); az = GAUSSIAN_DATA::nz(fa:la)
      bx = GAUSSIAN_DATA::nx(fb:lb); by = GAUSSIAN_DATA::ny(fb:lb); bz = GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+2,.b.l+4); NAy.create(.a.l+2,.b.l+4); NAz.create(.a.l+2,.b.l+4)
      BBx.create(.a.l+2,.b.l+3); BBy.create(.a.l+2,.b.l+3); BBz.create(.a.l+2,.b.l+3)
      AAx.create(.a.l+1,.b.l+4); AAy.create(.a.l+1,.b.l+4); AAz.create(.a.l+1,.b.l+4)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      A2x.create(.a.l+1,.b.l+2); A2y.create(.a.l+1,.b.l+2); A2z.create(.a.l+1,.b.l+2)
      B2x.create(.a.l+2,.b.l+1); B2y.create(.a.l+2,.b.l+1); B2z.create(.a.l+2,.b.l+1)

      ! Assemble the integrals
       SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+1,.b.l+3)
         .make_density_part(NAy,2,y,.a.l+1,.b.l+3)
         .make_density_part(NAz,3,z,.a.l+1,.b.l+3)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left",AAx)
         .differentiate(NAy,"left",AAy)
         .differentiate(NAz,"left",AAz)

         .differentiate(BBx,"right",ABx)
         .differentiate(BBy,"right",ABy)
         .differentiate(BBz,"right",ABz)

         .differentiate(ABx,"left",A2x)
         .differentiate(ABy,"left",A2y)
         .differentiate(ABz,"left",A2z)

         .differentiate(ABx,"right",B2x)
         .differentiate(ABy,"right",B2y)
         .differentiate(ABz,"right",B2z)

!         SOx = SOx + ABx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
!                   - ABx(ax,bx)*B2y(ay,by)*A2z(az,bz)
          SOx = SOx + ABx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                    - ABx(ax,bx)*BBy(ay,by)*AAz(az,bz) &
                    + NAx(ax,bx)*A2y(ay,by)*BBz(az,bz) &
                    - NAx(ax,bx)*B2y(ay,by)*AAz(az,bz) &
                    + NAx(ax,bx)*AAy(ay,by)*B2z(az,bz) &
                    - NAx(ax,bx)*BBy(ay,by)*A2z(az,bz)

!         SOy = SOy + B2x(ax,bx)*ABy(ay,by)*A2z(az,bz) &
!                   - A2x(ax,bx)*ABy(ay,by)*B2z(az,bz)
          SOy = SOy + B2x(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                    - A2x(ax,bx)*NAy(ay,by)*BBz(az,bz) &
                    + BBx(ax,bx)*ABy(ay,by)*AAz(az,bz) &
                    - AAx(ax,bx)*ABy(ay,by)*BBz(az,bz) &
                    + BBx(ax,bx)*NAy(ay,by)*A2z(az,bz) &
                    - AAx(ax,bx)*NAy(ay,by)*B2z(az,bz)

!         SOz = SOz + A2x(ax,bx)*B2y(ay,by)*ABz(az,bz) &
!                   - B2x(ax,bx)*A2y(ay,by)*ABz(az,bz)
          SOz = SOz + A2x(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                    - B2x(ax,bx)*AAy(ay,by)*NAz(az,bz) &
                    + AAx(ax,bx)*B2y(ay,by)*NAz(az,bz) &
                    - BBx(ax,bx)*A2y(ay,by)*NAz(az,bz) &
                    + AAx(ax,bx)*BBy(ay,by)*ABz(az,bz) &
                    - BBx(ax,bx)*AAy(ay,by)*ABz(az,bz)

      A2z.destroy; A2y.destroy; A2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

!!! new stuff on ft

   normalize_ft(ft)
   ! Multiplies the ft product at a series of k points, by the normalisation
   ! factors for the two gaussian shells.
     ft :: MAT{CPX}, target

     ft_ab :: CPX*
     anorm,bnorm :: VEC{REAL}*
     a,b,i,fa,fb,la,lb :: INT

     if (.a.l<2 AND .b.l<2) return

     if (.a.l >=2 AND .b.l>=2) then

        ! Get normalising factors
        fa = .a.first_gaussian; la = .a.last_gaussian
        fb = .b.first_gaussian; lb = .b.last_gaussian
        anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
        bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)

        i = 0
        do b = 1,.b.n_comp
        do a = 1,.a.n_comp
            i = i + 1
            ft_ab => ft(a,b)
            ft_ab = ft_ab * anorm(a) * bnorm(b)
        end
        end

     end

   end

   make_normalised_ft_00(ft_ab,h,k,l)
   ! Make the normalised kinetic integrals "T".
      ft_ab :: MAT{CPX}
      h,k,l :: REAL
      .make_dkh_ft_00(ft_ab,h,k,l)
      ft_ab = ft_ab * .normalisation_factor
   end

   make_dkh_ft_00(ft,h,k,l)
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! Specialised routine for .a.l=0 and .b.l=0.
      ft :: MAT{CPX}
      h,k,l :: REAL, target

      pos :: VEC{REAL}(3)
      k_x,k_y,k_z :: REAL*
      g1_exa,g1_exb,e00 :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      I :: CPX

      ! Constants
      I = IMAGIFY(ONE)
      gamma = .a.exponent+.b.exponent
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Gaussian pair center
      g1_exa = g1*.a.exponent
      g1_exb = g1*.b.exponent
      P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
      P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
      P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)

      ! Reciprocal lattice K points
      k_x => h
      k_y => k
      k_z => l

      ! E coefficient
      pos = .a.position - .b.position
      e00 = exp(-.a.exponent*.b.exponent*dot_product(pos,pos)/gamma)
      pifac = pifac*e00

      ! Do the Fourier transform
         k1 = k_x; k2 = k_y; k3 = k_z
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
         ft(1,1) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)

   end

   make_normalised_ft_v2(ft_ab,h,k,l,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      ft_ab :: MAT{CPX}
      h,k,l :: REAL
      spherical :: BIN, optional

      W :: MAT{CPX}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_dkh_ft_v2(ft_ab,h,k,l)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_dkh_ft_v2(ft_ab,h,k,l)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_dkh_ft_v2(W,h,k,l)
         .change_to_spherical(W,ft_ab)
         W.destroy
!         .normalize_ft(ft_ab)
!         if (.a.l >=2 AND .b.l>=2) then
!            ft_ab = ft_ab * .normalisation_factor
!         end if
      end

          ft_ab = ft_ab * .normalisation_factor

   end

   make_dkh_ft_v2(ft,h1,h2,h3)
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT{CPX}
      h1,h2,h3 :: REAL, target

      ft_x,ft_y,ft_z :: MAT{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      k_x,k_y,k_z :: REAL*
      g1_exa,g1_exb :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      a,b,fa,la,fb,lb :: INT
      I,prefac :: CPX

      ! Constants
      I = IMAGIFY(ONE)
      gamma = .a.exponent+.b.exponent
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Space for fourier transform of each component
      ft_x.create([0,.a.l],[0,.b.l])
      ft_y.create([0,.a.l],[0,.b.l])
      ft_z.create([0,.a.l],[0,.b.l])

      ! Reciprocal lattice K points
      k_x => h1
      k_y => h2
      k_z => h3

      ! Gaussian pair center
      g1_exa = g1*.a.exponent
      g1_exb = g1*.b.exponent
      P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
      P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
      P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)

      ! Make prefactor
        k1 = k_x; k2 = k_y; k3 = k_z
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
        prefac = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)

      ! Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)
      .make_ft_component(ft_y,2,k_y)
      .make_ft_component(ft_z,3,k_z)

      ! Incorporate prefactor into ft_z
      do b = 0,.b.l
      do a = 0,.a.l
         ft_z(a,b) = ft_z(a,b) * prefac
      end
      end

      ! Gaussian function power arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
      bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)

      ! Do the Fourier transform
      ft = ft_x(ax,bx)*ft_y(ay,by)*ft_z(az,bz)

      ! Clean up
      ft_z.destroy; ft_y.destroy; ft_x.destroy

   end

   make_normalised_pftp_v2(ft_ab,h,k,l,spherical)
   ! Calculate S, a cartesian or spherical block of integrals.
      ft_ab :: MAT{CPX}
      h,k,l :: REAL
      spherical :: BIN, optional

      W :: MAT{CPX}*
      is_spherical :: BIN

      is_spherical = FALSE
      if (present(spherical)) is_spherical = spherical

      if (NOT is_spherical) then
         .make_dkh_ft_dadb_v2(ft_ab,h,k,l)
      elseif ( .a.l<2 AND .b.l<2 ) then
         .make_dkh_ft_dadb_v2(ft_ab,h,k,l)
      else
         W.create(.a.n_comp,.b.n_comp)
         .make_dkh_ft_dadb_v2(W,h,k,l)
         .change_to_spherical(W,ft_ab)
         W.destroy
!         if (.a.l >=2 AND .b.l>=2) then
!            ft_ab = ft_ab * .normalisation_factor
!         end if
!         .normalize_ft(ft_ab)
      end

       ft_ab = ft_ab * .normalisation_factor

   end

   make_dkh_ft_dadb_v2(ft,h1,h2,h3)
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT{CPX}
      h1,h2,h3 :: REAL, target

      ft_x,ft_y,ft_z :: MAT{CPX}*
      pftp_x,pftp_y,pftp_z :: MAT{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}@
      k_x,k_y,k_z :: REAL*
      g1_exa,g1_exb :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      a,b,fa,la,fb,lb :: INT
      I,prefac :: CPX

      ! Constants
      I = IMAGIFY(ONE)
      gamma = .a.exponent+.b.exponent
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Space for fourier transform of each component
      ft_x.create([0,.a.l],[0,.b.l])
      ft_y.create([0,.a.l],[0,.b.l])
      ft_z.create([0,.a.l],[0,.b.l])
      pftp_x.create([0,.a.l],[0,.b.l])
      pftp_y.create([0,.a.l],[0,.b.l])
      pftp_z.create([0,.a.l],[0,.b.l])

      ! Reciprocal lattice K points
      k_x => h1
      k_y => h2
      k_z => h3

      ! Gaussian pair center
      g1_exa = g1*.a.exponent
      g1_exb = g1*.b.exponent
      P1 = g1_exa*.a.position(1) + g1_exb*.b.position(1)
      P2 = g1_exa*.a.position(2) + g1_exb*.b.position(2)
      P3 = g1_exa*.a.position(3) + g1_exb*.b.position(3)

      ! Make prefactor
        k1 = k_x; k2 = k_y; k3 = k_z
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
        prefac = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)

      ! Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)
      .make_ft_component(ft_y,2,k_y)
      .make_ft_component(ft_z,3,k_z)
      .make_ft_dadb_component(pftp_x,1,k_x)
      .make_ft_dadb_component(pftp_y,2,k_y)
      .make_ft_dadb_component(pftp_z,3,k_z)

      ! Incorporate prefactor into ft_z
      do b = 0,.b.l
      do a = 0,.a.l
         ft_z(a,b) = ft_z(a,b) * prefac
         pftp_z(a,b) = pftp_z(a,b) * prefac
      end
      end

      ! Gaussian function power arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian

      ax = GAUSSIAN_DATA::px(fa:la); ay = GAUSSIAN_DATA::py(fa:la); az = GAUSSIAN_DATA::pz(fa:la)
      bx = GAUSSIAN_DATA::px(fb:lb); by = GAUSSIAN_DATA::py(fb:lb); bz = GAUSSIAN_DATA::pz(fb:lb)

      ! Do the Fourier transform
      ft = pftp_x(ax,bx)*ft_y(ay,by)*ft_z(az,bz)     &
         + ft_x(ax,bx)*pftp_y(ay,by)*ft_z(az,bz)     &
         + ft_x(ax,bx)*ft_y(ay,by)*pftp_z(az,bz)

      ! Clean up
      ft_z.destroy; ft_y.destroy; ft_x.destroy
      pftp_z.destroy; pftp_y.destroy; pftp_x.destroy

   end

   make_ft_component(res,comp,k_pts) ::: PURE
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
      self :: IN
      res  :: MAT{CPX}(0:,0:), OUT
      comp  :: INT, IN
      k_pts :: REAL, IN

      e  :: MAT3{REAL}@
      kp :: VEC{REAL}@
      vr,vi :: REAL
      a,b,t,t_max :: INT

      t_max = .a.l+.b.l

      ! Make the E coefficients
      e.create([0,t_max],[0,.a.l],[0,.b.l])
      .make_e_coeff(e,comp)

      ! Define kp array containing powers k_pts(n)^t
      kp.create([1,t_max])
      if (t_max>0) then
         kp(1) = k_pts
         do t = 2,t_max
            kp(t) = kp(t-1)*k_pts
         end
         do t = 2,t_max
            if (mod(t,4)<=1) cycle
            kp(t) = -kp(t)
         end
      end

      ! Real, imaginary parts of answer: (vr,vi)
      do a = 0,.a.l
      do b = 0,.b.l

         t_max = a + b

         ! Real part
         vr = e(0,a,b)
         do t = 2,t_max,2
            vr = vr + e(t,a,b)*kp(t)
         end

         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a,b)*kp(t)
         end

         res(a,b) = COMPLEXIFY(vr,vi)

      end
      end

      kp.destroy
      e.destroy

   end

   make_ft_dadb_component(res,comp,k_pts)
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
      res :: MAT{CPX}(0:,0:), OUT
      comp  :: INT, IN
      k_pts :: REAL, IN

      e  :: MAT3{REAL}*
      kp :: VEC{REAL}*
      vr,vi :: REAL
      a,b,t,t_max :: INT

      t_max = .a.l+.b.l+2

      ! Make the E coefficients
      e.create([0,t_max],[0,.a.l+1],[0,.b.l+1])
      .make_e_coeff_dadb(e,comp)

      ! Define kp array containing powers k_pts(n)^t
      kp.create([1,t_max])
      if (t_max>0) then
         kp(1) = k_pts
         do t = 2,t_max
            kp(t) = kp(t-1)*k_pts
         end
         do t = 2,t_max
            if (mod(t,4)<=1) cycle
            kp(t) = -kp(t)
         end
      end

      ! case build seems fine Lukas c u tommorrow kokot

      do a = 0,.a.l
      do b = 0,.b.l

         ! this part do not needs the if because it holds for all
         ! angular momentum functions
         t_max = a + b + 2

         ! Real part
         vr = e(0,a+1,b+1)*FOUR*.a.exponent*.b.exponent
         do t = 2,t_max,2
            vr = vr + e(t,a+1,b+1)*kp(t)*FOUR*.a.exponent*.b.exponent
         end

         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a+1,b+1)*kp(t)*FOUR*.a.exponent*.b.exponent
         end

         if (b>0) then
            vr = vr - e(0,a+1,b-1)*TWO*.a.exponent*b
            t_max = a + b
            ! Real part
            do t = 2,t_max,2
               vr = vr - e(t,a+1,b-1)*kp(t)*TWO*.a.exponent*b
            end
            ! Imaginary part
            do t = 1,t_max,2
               vi = vi - e(t,a+1,b-1)*kp(t)*TWO*.a.exponent*b
            end
         end if

         if (a>0) then
            t_max = a + b
            vr = vr - e(0,a-1,b+1)*TWO*.b.exponent*a
            ! Real part
            do t = 2,t_max,2
               vr = vr - e(t,a-1,b+1)*kp(t)*TWO*.b.exponent*a
            end
            ! Imaginary part
            do t = 1,t_max,2
               vi = vi - e(t,a-1,b+1)*kp(t)*TWO*.b.exponent*a
            end
         end if

         if (a>0 AND b>0) then
            vr = vr + e(0,a-1,b-1)*b*a
            t_max = a + b - 2
            ! Real part
            do t = 2,t_max,2
               vr = vr + e(t,a-1,b-1)*kp(t)*a*b
            end
            ! Imaginary part
            do t = 1,t_max,2
               vi = vi + e(t,a-1,b-1)*kp(t)*a*b
            end
         end if

         res(a,b) = COMPLEXIFY(vr,vi)

      end
      end

      kp.destroy; e.destroy

   end

   make_e_coeff_dadb(e,comp)
   ! Return the McMurchie-Davidson "e" coefficients for component "comp"
   ! (c) dylan jayatilaka, april 1995
   ! Checked using mathematica, may 1995
   ! 2008 bucinsky added +1 to l_a and l_b and +2 to max
      e :: MAT3{REAL}(0:,0:,0:), OUT
      comp :: INT, IN

      t,a,b,ap,am,bp,bm,abp,ab,abm,max,l_a,l_b :: INT
      R,gamma,g1,g2,a1,b1,e000 :: REAL

      l_a = .a.l+1
      l_b = .b.l+1
      max = l_a+l_b+2

      R = .a.position(comp) - .b.position(comp)

      gamma = .a.exponent + .b.exponent
      g1 = ONE/gamma
      b1 = .b.exponent*g1*R

      e000 = exp(-.a.exponent*b1*R)
      e(0,0,0) = e000

      ! Return for e000
      if (max==0) return

      g2 = HALF*g1
      a1 = .a.exponent*g1*R
      if (l_a>=1) then
         e(1,1,0) =  g2*e000
         e(0,1,0) = -b1*e000
      end
      if (l_b>=1) then
         e(1,0,1) =  g2*e000
         e(0,0,1) =  a1*e000
      end

      ! Return for eXX1
      if (max==1) return

      ! Consider case b=0
      do a = 1,l_a-1
         ap = a + 1
         am = a - 1
         e(ap,ap,0) =  g2*e( a,a,0)
         e( a,ap,0) =  g2*e(am,a,0) - b1*e(a,a,0)
         e( 0,ap,0) = -b1*e( 0,a,0) +    e(1,a,0)
         do t = 1,am
            e(t,ap,0) = g2*e(t-1,a,0) - b1*e(t,a,0) + (t+1)*e(t+1,a,0)
         end
      end

      ! Consider case a=0
      do b = 1,l_b-1
         bp = b + 1
         bm = b - 1
         e(bp,0,bp) =  g2*e( b,0,b)
         e( b,0,bp) =  g2*e(bm,0,b) + a1*e(b,0,b)
         e( 0,0,bp) =  a1*e( 0,0,b) +    e(1,0,b)
         do t = 1,bm
            e(t,0,bp) = g2*e(t-1,0,b) + a1*e(t,0,b) + (t+1)*e(t+1,0,b)
         end
      end

      ! Now do the rest, a/=0 & b/=0
      do b = 1,l_b
         do a = 0,l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e(abp,ap,b) =  g2*e( ab,a,b)
            e( ab,ap,b) =  g2*e(abm,a,b) - b1*e(ab,a,b)
            e(  0,ap,b) = -b1*e(  0,a,b) +    e( 1,a,b)
            do t = 1,abm
               e(t,ap,b) = g2*e(t-1,a,b) - b1*e(t,a,b) + (t+1)*e(t+1,a,b)
            end
         end
      end

   end

end

