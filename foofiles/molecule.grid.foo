!===============================================================================
!
! MOLECULE.PLOT: An object representation of a molecule, plotting procedures.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996-2012
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!===============================================================================

module MOLECULE.GRID

   implicit none

contains

!  ========
!  Do plots
!  ========

! 2D

   do_plot ::: leaky
   ! Do one of the many kinds of plot calculations. These are usually
   ! 2D plots but they can be rectilinear volumetric plots, depending
   ! on how .plot_grid was defined by the user.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")

      select case (.plot_grid.plot_kind)
         case("adp                                 "); .:make_ADP_grid
         case("adp2                                "); .:make_ADP2_exponent_grid
         case("anharmonic_adp_correction           "); .:make_AADP_correction_grid
         case("b_field                             "); .:make_B_field_grid
         case("b_l_field                           "); .:make_B_L_field_grid
         case("b_s_field                           "); .:make_B_S_field_grid
         case("binding_function_wang_peng          "); .:make_binding_function_wp_grid
         case("bond_density_atom                   "); .:make_bond_density_atom_grid
         case("bond_electron_density               "); .:make_bond_ED_grid
         case("bond_weight                         "); .:make_bond_weight_grid
         case("current_density                     "); .:make_j_grid
         case("deformation_bond_density            "); .:make_def_bond_density_grid
         case("deformation_density                 "); .:make_deformation_density_grid
         case("deformation_dft_eff_potential       "); .:make_def_dft_eff_pot_grid
         case("deformation_dft_energy              "); .:make_def_dft_energy_grid
         case("deformation_dft_xc_potential        "); .:make_def_dft_xc_pot_grid
         case("deformation_electric_potential      "); .:make_def_e_pot_grid
         case("deformation_g_kinetic_energy        "); .:make_def_G_kinetic_grid
         case("deformation_g_kirzhnits             "); .:make_def_G_Kirzhnits_grid
         case("deformation_h_dft_energy            "); .:make_def_H_dft_energy_grid
         case("deformation_h_from_virial           "); .:make_def_H_from_virial_grid
         case("deformation_h_kirzhnits             "); .:make_def_H_Kirzhnits_grid
         case("deformation_k_kinetic_energy        "); .:make_def_K_kinetic_grid
         case("deformation_laplacian               "); .:make_def_laplacian_grid
         case("deformation_v_from_virial           "); .:make_def_V_from_virial_grid
         case("deformation_v_kirzhnits             "); .:make_def_V_Kirzhnits_grid
         case("deformation_reduced_g_kinetic_energy"); .:make_def_rG_kinetic_grid
         case("deformation_reduced_h_from_virial   "); .:make_def_rH_from_virial_grid
         case("deformation_reduced_k_kinetic_energy"); .:make_def_rK_kinetic_grid
         case("deformation_reduced_v_from_virial   "); .:make_def_rV_from_virial_grid
         case("dft_eff_potential                   "); .:make_dft_eff_pot_grid
         case("dft_energy                          "); .:make_dft_energy_grid
         case("dft_xc_potential                    "); .:make_dft_xc_pot_grid
         case("div_jp                              "); .:make_div_jp_grid
         case("electric_potential                  "); .:make_electric_potential_grid
         case("electric_polarisation_density       "); .:make_e_polarization_grid
         case("electric_polarization_density       "); .:make_e_polarization_grid
         case("electron_density                    "); .:make_electron_density_grid
         case("elf                                 "); .:make_ELF_grid
         case("e_hf_density_from_rho               "); .:make_E_hf_dens_from_rho_grid
         case("eli_d                               "); .:make_ELI_D_grid
       ! case("energy_density_from_rho             "); .:make_deformation_density_grid
         case("fermi_mobility                      "); .:make_fermi_mobility_grid
         case("g_kinetic_energy                    "); .:make_G_kinetic_energy_grid
         case("g_kirzhnits                         "); .:make_G_Kirzhnits_grid
         case("grad_rho_on_rho                     "); .:make_grad_rho_on_rho_grid
         case("h_dft_energy                        "); .:make_H_dft_energy_grid
         case("h_kirzhnits                         "); .:make_H_Kirzhnits_grid
         case("h_from_virial                       "); .:make_H_from_virial_grid
         case("hirshfeld_atom_grid                 "); .:make_Hirshfeld_atom_grid
         case("hirshfeld_density                   "); .:make_Hirshfeld_density_grid
         case("hirshfeld_weight                    "); .:make_Hirshfeld_density_grid
         case("j                                   "); .:make_j_grid
         case("jd                                  "); .:make_jd_grid
         case("jp                                  "); .:make_jp_grid
         case("jp_irrotational                     "); .:make_irrotational_jp_grid
         case("jp_solenoidal                       "); .:make_solenoidal_jp_grid
         case("jayatilaka_atom_grid                "); .:make_Jayatilaka_atom_grid
         case("k_kinetic_energy                    "); .:make_K_kinetic_energy_grid
       ! case("kramers_spin_density                "); .:make_ku_spin_density_grid   
       ! cannot be used here I need stuff from higher modules
         case("laplacian                           "); .:make_laplacian_grid
         case("local_ionisation_energy             "); .:make_local_ionisation_grid
         case("local_virial_ratio                  "); .:make_local_virial_ratio_grid
         case("lol                                 "); .:make_LOL_grid
         case("negative_laplacian                  "); .:make_neg_laplacian_grid
         case("noncollinear_spin_density           "); .:make_nc_spin_density_grid
         case("normalized_g_from_virial            "); .:make_norm_G_from_virial_grid
         case("normalized_h_from_virial            "); .:make_norm_H_from_virial_grid
         case("normalized_v_from_virial            "); .:make_norm_V_from_virial_grid
       ! case("orbital_current_density             "); .:make_orbital_j_grid
         case("orbital_density                     "); .:make_orbital_density_grid
         case("orbital                             "); .:make_orbital_grid
         case("oscillator_orbital                  "); .:make_oscillator_orbital_grid
         case("promolecule_density                 "); .:make_promolecule_density_grid
         case("reduced_g_kinetic_energy            "); .:make_rG_kinetic_energy_grid
         case("reduced_h_from_virial               "); .:make_rH_from_virial_grid
         case("reduced_k_kinetic_energy            "); .:make_rK_kinetic_energy_grid
         case("reduced_v_from_virial               "); .:make_rV_from_virial_grid
         case("residual_density_map                "); .:make_residual_density_map
         case("roby_ano_density                    "); .:make_Roby_ANO_density_grid
         case("roby_nao_density                    "); .:make_Roby_NAO_density_grid
         case("roby-gould_covalent_orbital         "); .:make_RG_cov_orbital_grid
         case("roby-gould_ionic_orbital            "); .:make_RG_ion_orbital_grid
       ! case("spin_current_density                "); .:make_spin_j_grid
         case("spin_density                        "); .:make_spin_density_grid
         case("spherical_atom_density              "); .:make_spherical_atom_grid
         case("stockholder_density                 "); .:make_stockholder_density_grid
         case("stockholder_weight                  "); .:make_Hirshfeld_density_grid
         case("test_sphere_on_atom_1               "); .:make_test_sphere_on_atom_1
         case("true_fermi_mobility                 "); .:make_true_fermi_mobility_grid
         case("tsirelson_elf                       "); .:make_Tsirelson_ELF_grid
         case("v_kirzhnits                         "); .:make_V_Kirzhnits_grid
         case("v_from_virial                       "); .:make_V_from_virial_grid
         case default;                UNKNOWN(.plot_grid.plot_kind)
      end

   end

! Isosurface

   do_isosurface_plot
   ! Do one of the many kinds of isosurface plot calculations
      self :: INOUT

   ENSURE(.isosurface.associated,"no isosurface")

      select case (.isosurface.property)
      case("adp                              "); .isosurface.cubify(::ADP_exponent_grid)
      case("adp2                             "); .isosurface.cubify(::ADP2_exponent_grid)
      case("anharmonic_adp_correction        "); .isosurface.cubify(::AADP_correction_grid)
      case("bond_density_atom                "); .isosurface.cubify(::bond_density_atom_grid)
      case("bond_electron_density            "); .isosurface.cubify(::bond_ED_grid)
      case("bond_weight                      "); .isosurface.cubify(::bond_weight_grid)
      case("deformation_bond_density         "); .isosurface.cubify(::deformation_bond_density_grid)
      case("deformation_density              "); .isosurface.cubify(::deformation_density_grid)
      case("deformation_dft_eff_potential    "); .isosurface.cubify(::def_dft_eff_pot_grid)
      case("deformation_dft_energy           "); .isosurface.cubify(::def_dft_energy_grid)
      case("deformation_dft_xc_potential     "); .isosurface.cubify(::def_dft_xc_pot_grid)
      case("deformation_electric_potential   "); .isosurface.cubify(::def_e_pot_grid)
      case("deformation_g_kinetic_energy     "); .isosurface.cubify(::def_G_kinetic_grid)
      case("deformation_h_dft_energy         "); .isosurface.cubify(::def_H_dft_energy_grid)
      case("deformation_k_kinetic_energy     "); .isosurface.cubify(::def_K_kinetic_grid)
      case("deformation_laplacian            "); .isosurface.cubify(::def_laplacian_grid)
      case("dft_eff_potential                "); .isosurface.cubify(::dft_eff_pot_grid)
      case("dft_energy                       "); .isosurface.cubify(::dft_energy_grid)
      case("dft_xc_potential                 "); .isosurface.cubify(::dft_xc_pot_grid)
      case("electric_potential               "); .isosurface.cubify(::electric_potential_grid)
      case("electron_density                 "); .isosurface.cubify(::electron_density_grid)
      case("elf                              "); .isosurface.cubify(::ELF_grid)
      case("eli_d                            "); .isosurface.cubify(::ELI_D_grid)
      case("fermi_mobility                   "); .isosurface.cubify(::fermi_mobility_grid)
      case("grad_rho_on_rho                  "); .isosurface.cubify(::grad_rho_on_rho_grid)
      case("g_kinetic_energy                 "); .isosurface.cubify(::G_kinetic_energy_grid)
      case("h_dft_energy                     "); .isosurface.cubify(::H_dft_energy_grid)
      case("hirshfeld_density                "); .isosurface.cubify(::Hirshfeld_density_grid)
      case("hirshfeld_weight                 "); .isosurface.cubify(::Hirshfeld_density_grid)
      case("k_kinetic_energy                 "); .isosurface.cubify(::K_kinetic_energy_grid)
      case("laplacian                        "); .isosurface.cubify(::laplacian_grid)
      case("local_ionisation_energy          "); .isosurface.cubify(::local_ionisation_grid)
      case("lol                              "); .isosurface.cubify(::LOL_grid)
      case("orbital                          "); .isosurface.cubify(::orbital_grid)
      case("oscillator_orbital               "); .isosurface.cubify(::oscillator_orbital_grid)
      case("orbital_density                  "); .isosurface.cubify(::orbital_density_grid)
      case("promolecule_density              "); .isosurface.cubify(::promolecule_density_grid)
      case("roby_ano_density                 "); .isosurface.cubify(::Roby_ANO_density_grid)
      case("roby_nao_density                 "); .isosurface.cubify(::Roby_NAO_density_grid)
      case("roby-gould_covalent_orbital      "); .isosurface.cubify(::RG_cov_orbital_grid)
      case("roby-gould_ionic_orbital         "); .isosurface.cubify(::RG_ion_orbital_grid)
      case("spin_density                     "); .isosurface.cubify(::spin_density_grid)
      case("stockholder_density              "); .isosurface.cubify(::stockholder_density_grid)
      case("stockholder_weight               "); .isosurface.cubify(::Hirshfeld_density_grid)
      case("test_sphere_on_atom_1            "); .isosurface.cubify(::test_sphere_on_atom_1)
      case("true_fermi_mobility              "); .isosurface.cubify(::true_fermi_mobility_grid)
      case("tsirelson_elf                    "); .isosurface.cubify(::Tsirelson_ELF_grid)
      case default;                UNKNOWN(.isosurface.property)
      end

   end

   do_plot_property_on_isosurface
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface===useful for mapping properties on a surface.
      self :: INOUT

      select case (.isosurface.surface_property)
      case("adp                             "); .isosurface.plot_function(::ADP_exponent_grid)
      case("adp2                            "); .isosurface.plot_function(::ADP2_exponent_grid)
      case("anharmonic_adp_correction       "); .isosurface.plot_function(::AADP_correction_grid)
      case("bond_density_atom               "); .isosurface.plot_function(::bond_density_atom_grid)
      case("bond_electron_density           "); .isosurface.plot_function(::bond_ED_grid)
      case("deformation_bond_density        "); .isosurface.plot_function(::deformation_bond_density_grid)
      case("deformation_density             "); .isosurface.plot_function(::deformation_density_grid)
      case("deformation_dft_eff_potential   "); .isosurface.plot_function(::def_dft_eff_pot_grid)
      case("deformation_dft_energy          "); .isosurface.plot_function(::def_dft_energy_grid)
      case("deformation_dft_xc_potential    "); .isosurface.plot_function(::def_dft_xc_pot_grid)
      case("deformation_electric_potential  "); .isosurface.plot_function(::def_e_pot_grid)
      case("deformation_g_kinetic_energy    "); .isosurface.plot_function(::def_G_kinetic_grid)
      case("deformation_h_dft_energy        "); .isosurface.plot_function(::def_H_dft_energy_grid)
      case("deformation_k_kinetic_energy    "); .isosurface.plot_function(::def_K_kinetic_grid)
      case("deformation_laplacian           "); .isosurface.plot_function(::def_laplacian_grid)
      case("dft_eff_potential               "); .isosurface.plot_function(::dft_eff_pot_grid)
      case("dft_energy                      "); .isosurface.plot_function(::dft_energy_grid)
      case("dft_xc_potential                "); .isosurface.plot_function(::dft_xc_pot_grid)
      case("electric_potential              "); .isosurface.plot_function(::electric_potential_grid)
      case("electron_density                "); .isosurface.plot_function(::electron_density_grid)
      case("elf                             "); .isosurface.plot_function(::ELF_grid)
      case("eli_d                           "); .isosurface.plot_function(::ELI_D_grid)
      case("fermi_mobility                  "); .isosurface.plot_function(::fermi_mobility_grid)
      case("g_kinetic_energy                "); .isosurface.plot_function(::G_kinetic_energy_grid)
      case("group_product_e_field_grid      "); .isosurface.plot_function(::group_product_E_field_grid)
      case("group_product_esp_grid          "); .isosurface.plot_function(::group_product_ESP_grid)
      case("grad_rho_on_rho                 "); .isosurface.plot_function(::grad_rho_on_rho_grid)
      case("h_dft_energy                    "); .isosurface.plot_function(::H_dft_energy_grid)
      case("hirshfeld_density               "); .isosurface.plot_function(::Hirshfeld_density_grid)
      case("hirshfeld_weight                "); .isosurface.plot_function(::Hirshfeld_density_grid)
      case("k_kinetic_energy                "); .isosurface.plot_function(::K_kinetic_energy_grid)
      case("laplacian                       "); .isosurface.plot_function(::laplacian_grid)
      case("local_ionisation_energy         "); .isosurface.plot_function(::local_ionisation_grid)
      case("lol                             "); .isosurface.plot_function(::LOL_grid)
      case("orbital                         "); .isosurface.plot_function(::orbital_grid)
      case("oscillator_orbital              "); .isosurface.plot_function(::oscillator_orbital_grid)
      case("orbital_density                 "); .isosurface.plot_function(::orbital_density_grid)
      case("promolecule_density             "); .isosurface.plot_function(::promolecule_density_grid)
      case("product_e_field_grid            "); .isosurface.plot_function(::product_E_field_grid)
      case("product_esp_grid                "); .isosurface.plot_function(::product_ESP_grid)
      case("roby_ano_density                "); .isosurface.plot_function(::Roby_ANO_density_grid)
      case("roby_nao_density                "); .isosurface.plot_function(::Roby_NAO_density_grid)
      case("roby-gould_covalent_orbital     "); .isosurface.plot_function(::RG_cov_orbital_grid)
      case("roby-gould_ionic_orbital        "); .isosurface.plot_function(::RG_ion_orbital_grid)
      case("spin_density                    "); .isosurface.plot_function(::spin_density_grid)
      case("stockholder_density             "); .isosurface.plot_function(::stockholder_density_grid)
      case("stockholder_weight              "); .isosurface.plot_function(::Hirshfeld_density_grid)
      case("test_sphere_on_atom_1           "); .isosurface.plot_function(::test_sphere_on_atom_1)
      case("true_fermi_mobility             "); .isosurface.plot_function(::true_fermi_mobility_grid)
      case("tsirelson_elf                   "); .isosurface.plot_function(::Tsirelson_ELF_grid)
      case default;                UNKNOWN(.isosurface.surface_property)
      end

   end

!  ============================
!  Nuclear & electric potential
!  ============================

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is useful for numerical integration of nuclear attraction
   ! integrals. Dummay atom charges are included.
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      n_pts,n,i :: INT
      Z_n,r :: REAL
      pos :: VEC{REAL}(3)

      n_pts  = pts.dim1

      values = ZERO
      do n = 1,.n_atom

         Z_n = .atom(n).nuclear_charge
         pos = .atom(n).position

         do i = 1,n_pts

            r = pos.distance_to(pts(i,:))

            if (r>tiny(r)) then
              values(i) = values(i) + Z_n / r
            else
              values(i) = values(i) + huge(ONE)
            end

         end

      end

   end

   electric_potential(values,grid,charges,positions) ::: selfless
   ! Calculate the electric potential "values" at a set of "grid" points, coming
   ! from a given set "charges" located at "positions".  This is useful for
   ! numerical integration of the potential.
      values,charges :: VEC{REAL}
      grid,positions :: MAT{REAL}

   ENSURE(charges.dim==positions.dim1,"inconsistent charges and positions arrays")
   ENSURE(positions.dim2==3,"wrong 2nd dimension, positions array")
   ENSURE(values.dim==grid.dim1,"inconsistent values and grid array")

      n,i :: INT
      q,r :: REAL
      pos :: VEC{REAL}(3)

      values = ZERO
      do n = 1,charges.dim
         q = charges(n)
         pos = positions(n,:)
         do i = 1,grid.dim1
            r = pos.distance_to(grid(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + q / r
            else
              values(i) = values(i) + TEN**6 ! something very large
            end
         end
      end

   end

!  ============
!  Orbital grid
!  ============

   make_orbital_grid
   ! Evaluate the values for orbital ".plot_grid.orb" of
   ! ".natural_orbitals" and write them out to a file.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      arch :: ARCHIVE
      pt :: MAT{REAL}*
      gr,gu,gd :: VEC{REAL}*
      gcu,gcd :: VEC{CPX}*
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .natural_orbitals.spinorbital_kind

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.associated) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if

      select case (relativity)

         case ("douglas-kroll-hess","dkh")

            select case (okind)

               case("restricted")
                  WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
                  WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
                  gr.create(.plot_grid.n_pt)
                  .:make_DKH_orbital_grid_r(gr,orb,pt,square=FALSE)
                  .:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy

               case default
                  DIE("unimplemented")
            end

         case ("iotc")

            select case (okind)

               case("restricted")
                  WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
                  WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
                  gr.create(.plot_grid.n_pt)
                  .:make_IOTC_orbital_grid_r(gr,orb,pt,square=FALSE)
                  .:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy

               case default
                  DIE("unimplemented")
            end

         case ("none")

            select case (okind)

               case("restricted")
                  gr.create(.plot_grid.n_pt)
                  .:make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt)
                  .:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy

               case("general")
                  gu.create(.plot_grid.n_pt)
                  gd.create(.plot_grid.n_pt)
                  .:make_orbital_grid_g(gu,gd,.natural_orbitals.general(:,orb),pt)
                  arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid",format="ascii")
                  arch.write_orbital(gu,gd,.plot_grid.n_pt)
                  gu.destroy
                  gd.destroy

               case("general_complex")
                  gcu.create(.plot_grid.n_pt)
                  gcd.create(.plot_grid.n_pt)
                  .:make_orbital_grid_gc(gcu,gcd,.natural_orbitals.general_complex(:,orb),pt)
                  arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid",format="ascii")
                  arch.write_orbital(gcu,gcd,.plot_grid.n_pt)
                  gcu.destroy
                  gcd.destroy

               case default
                  DIE("unimplemented")
            end

         case default

            DIE("Unimplemented")

      end

      pt.destroy

   end

   orbital_grid(grid,pt) ::: selfless
   ! Work out the orbital "grid" for a series of points "pt" for using
   ! the ".natural orbitals", for orbital.isosurface.plot_grid.orbital. 
   ! NOTE: for complex orbitals, the absolute value times the sign of
   ! the complex part
      grid  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==grid.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")

      gridc :: VEC{CPX}*
      n_pt,orb :: INT
      plot_grid :: PLOT_GRID*
      self :: MOLECULE*

      ! Get back self
      .BASE:set_from_saved_self

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      n_pt = pt.dim1

      plot_grid => .isosurface.plot_grid

      ! Get orbital to plot
      orb = plot_grid.orbital

      ! Zero value indicates HOMO ...
      if (orb==0) then
         orb = .n_a
         if (plot_grid.HOMO_orbital/=0) orb = orb + plot_grid.HOMO_orbital
      end

      if (trim(.natural_orbitals.number_kind)== "real") then

         .:make_orbital_grid_r(grid,.natural_orbitals.restricted(:,orb),pt)

      else

         gridc.create(n_pt)
         .:make_orbital_grid_c(gridc,.natural_orbitals.restricted_complex(:,orb),pt)
         grid = sign(abs(gridc),IM(gridc))

         gridc.destroy

      end

   end

!  Low-level orbital-type-specific routines 

   make_orbital_grid_r(grid,orb,pt,square)
   ! Evaluate the orbital "grid" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      grid = ZERO

      do a = 1,.n_shell

         .BASE:set_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

         grid.plus_product_of(sh_grid,orb(fa:la))

         sh_grid.destroy

      end

      if (sq) grid = grid*grid

   end

   make_orbital_grid_c(grid,orb,pt,square)
   ! Evaluate the orbital "grid" for *one* AO-basis orbital
   ! coefficient vector "orb" on a set of grid points "pt"
      grid :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      grid = ZERO

      do a = 1,.n_shell

         .BASE:set_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

         grid.plus_product_of(sh_grid,orb(fa:la))

         sh_grid.destroy

      end

      if (sq) grid = conjg(grid)*grid

   end

   make_orbital_grid_g(grid,orb,pt)
   ! Evaluate the orbital density "grid" for *one* AO-basis orbital
   ! coefficient vector "orb" on a set of grid points "pt"
      grid :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      gu,gd :: VEC{REAL}*
      n_pt,np,a,fa,la,na :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu.create(n_pt)
      gd.create(n_pt)

      grid = ZERO
      gu = ZERO
      gd = ZERO

      do a = 1,.n_shell

         .BASE:set_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)

         if (norm2(orb(fa:la))      >TOL(6)) then ! a
            gu.plus_product_of(sh_grid,orb(fa   :la   )) ! a
         end if
         if (norm2(orb(fa+np:la+np))>TOL(6)) then ! a
            gd.plus_product_of(sh_grid,orb(fa+np:la+np)) ! b
         end if

         sh_grid.destroy

      end

      grid = gu*gu + gd*gd

      gu.destroy
      gd.destroy

   end

   make_orbital_grid_g(gu,gd,orb,pt)
   ! Evaluate the orbital density for the alpha "gu" or beta "gd" part
   ! of *one* AO-basis orbital coefficient vector "orb" on a set of
   ! grid points "pt"
      self :: IN
      gu,gd :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(orb.dim==2*.n_bf,  "wrong size for orb")

      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      n_pt = pt.dim1

      gu = ZERO
      gd = ZERO

      do a = 1,.n_shell

         .BASE:set_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

       ! if (norm2(orb(fa:la))>0.0001) then ! a
            gu.plus_product_of(sh_grid,orb(fa   :la   )) ! a
       ! end if
       ! if (norm2(orb(fa+np:la+np))>0.0001) then ! a
            gd.plus_product_of(sh_grid,orb(fa+.n_bf:la+.n_bf)) ! b
       ! end if

         sh_grid.destroy

      end

   end

   make_orbital_grid_gc(grid,orb,pt)
   ! Evaluate the orbital density "grid" for *one* AO-basis orbital
   ! coefficient vector "orb" on a set of grid points "pt"
      grid :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      gu,gd :: VEC{CPX}*
      n_pt,np,a,fa,la,na :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu.create(n_pt)
      gd.create(n_pt)

      grid = ZERO
      gu = ZERO
      gd = ZERO

      do a = 1,.n_shell

         .BASE:set_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)

         gu.plus_product_of(sh_grid,orb(fa   :la   )) ! aa or ba
         gd.plus_product_of(sh_grid,orb(fa+np:la+np)) !ab or bb

         sh_grid.destroy

      end

      grid = conjg(gu)*gu + conjg(gd)*gd

      gu.destroy
      gd.destroy

   end

   make_orbital_grid_gc(gu,gd,orb,pt)
   ! Evaluate the orbital density for the alpha "gu" or beta "gd" part
   ! of *one* AO-basis orbital coefficient vector "orb" on a set of
   ! grid points "pt"
      gu,gd :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,np,a,fa,la,na :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu = ZERO
      gd = ZERO

      do a = 1,.n_shell

         .BASE:set_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

         gu.plus_product_of(sh_grid,orb(fa   :la   )) ! aa or ba
         gd.plus_product_of(sh_grid,orb(fa+np:la+np)) ! ab or bb

         sh_grid.destroy

      end

   end

!  ========================
!  Roby-Gould orbital grids
!  ========================

   make_Roby_ANO_density_grid
   ! Evaluate the Roby ANO density grid for the atom with 
   ! index .roby.center_atom. Assumes double occupancy.
      self :: IN

   ENSURE(.roby.associated, "no roby data -- do one group analysis")
   ENSURE(.plot_grid.associated, "no plot_grid")
   ENSURE(.plot_grid.center_atom>0, "plot_grid center_atom not specified!")
   ENSURE(.atom(.plot_grid.center_atom).natural_orbitals.associated, "no natural orbitals!")
   ENSURE(.atom(.plot_grid.center_atom).natural_orbitals.restricted.associated, "no restricted natural orbitals!")

      pt, ANO :: MAT{REAL}*
      rho, occ :: VEC{REAL}*
      a :: INT

      ! Do this atom
      a = .plot_grid.center_atom
      ANO => .atom(a).natural_orbitals.restricted
      occ => .atom(a).occupation_numbers.restricted

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make the grid, rho
      rho.create(.plot_grid.n_pt)
      .:make_atom_density_grid_r(rho,ANO,occ,pt,a)

      ! Write grid, rho
      .:dump_plot_grid(rho,"Roby-Gould_ANO_density_atom_"//trim(a.to_str)//"_grid")

      ! Clean
      rho.destroy
      pt.destroy

   end

   Roby_ANO_density_grid(rho,pt) ::: selfless
   ! Evaluate the Roby ANO density grid "pt" for the atom with index
   ! .roby.center_atom and put in "rho". Assumes double occupancy.
      rho :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==rho.dim, "pt & rrho incompatible")
   ENSURE(pt.dim2==3,       "wrong dim2, pt")

      ANO :: MAT{REAL}*
      occ :: VEC{REAL}*
      a :: INT
      self :: MOLECULE*

      .BASE:set_from_saved_self

   ENSURE(.roby.associated, "no roby data -- do one group analysis")
   ENSURE(.plot_grid.associated, "no plot_grid")
   ENSURE(.plot_grid.center_atom>0, "plot_grid center_atom not specified!")
   ENSURE(.atom(.plot_grid.center_atom).natural_orbitals.associated, "no natural orbitals!")
   ENSURE(.atom(.plot_grid.center_atom).natural_orbitals.restricted.associated, "no restricted natural orbitals!")

      ! Do this atom
      a = .plot_grid.center_atom
      ANO => .atom(a).natural_orbitals.restricted
      occ => .atom(a).occupation_numbers.restricted

      ! Make the grid, rho
      .:make_atom_density_grid_r(rho,ANO,occ,pt,a)

   end


   make_Roby_NAO_density_grid
   ! Evaluate the Roby NAO density grid for the atom with index
   ! .roby.center_atom. Assumes double occupancy.
      self :: IN

   ENSURE(.roby.associated, "no roby data -- do one group analysis")
   ENSURE(.plot_grid.associated, "no plot_grid")
   ENSURE(.plot_grid.center_atom>0, "plot_grid center_atom not specified!")
   ENSURE(.atom(.plot_grid.center_atom).NAOs.associated, "no natural orbitals!")
   ENSURE(.atom(.plot_grid.center_atom).NAO_occupations.associated, "no restricted natural orbitals!")

      pt, NAO :: MAT{REAL}*
      rho, occ :: VEC{REAL}*
      a :: INT

      ! Do this atom
      a = .plot_grid.center_atom
      NAO => .atom(a).NAOs
      occ => .atom(a).NAO_occupations

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make the grid, rho
      rho.create(.plot_grid.n_pt)
      .:make_atom_density_grid_r(rho,NAO,occ,pt,a)

      ! Write grid, rho
      .:dump_plot_grid(rho,"Roby-Gould_NAO_density_atom_"//trim(a.to_str)//"_grid")

      ! Clean
      rho.destroy
      pt.destroy

   end

   Roby_NAO_density_grid(rho,pt) ::: selfless
   ! Evaluate the Roby ANO density grid "pt" for the atom with index
   ! .roby.center_atom and put in "rho". Assumes double occupancy.
      rho :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==rho.dim, "pt & rho incompatible")
   ENSURE(pt.dim2==3,       "wrong dim2, pt")

      NAO :: MAT{REAL}*
      occ :: VEC{REAL}*
      a :: INT
      self :: MOLECULE*

      .BASE:set_from_saved_self

   ENSURE(.roby.associated, "no roby data -- do one group analysis")
   ENSURE(.plot_grid.associated, "no plot_grid")
   ENSURE(.plot_grid.center_atom>0, "plot_grid center_atom not specified!")
   ENSURE(.atom(.plot_grid.center_atom).NAOs.associated, "no natural orbitals!")
   ENSURE(.atom(.plot_grid.center_atom).NAO_occupations.associated, "no restricted natural orbitals!")

      ! Do this atom
      a = .plot_grid.center_atom
      NAO => .atom(a).NAOs
      occ => .atom(a).NAO_occupations

      ! Make the grid, rho
      .:make_atom_density_grid_r(rho,NAO,occ,pt,a)

   end


   make_RG_cov_orbital_grid
   ! Evaluate the Roby-Gould covalent orbital ".plot_grid.orb" and
   ! write it out to a file.
      self :: IN

   DIE_IF(NOT .roby.associated, "no roby data -- do one group analysis")
   DIE_IF(NOT .roby.roby_kind=="group_bond_analysis", "must do previous group_bond_analysis")
   DIE_IF(NOT .roby.n_group==2, "must have only two groups")
   ENSURE(.roby.theta_C.associated, "no Roby-Gould covalent orbitals")
   ENSURE(.plot_grid.associated, "no plot_grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive theta orbital")
   ENSURE(.plot_grid.orbital<=.roby.theta_C.dim2, "orbital out of range, "//trim(.plot_grid.orbital.to_str))

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      orb :: INT

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      stdout.flush
      stdout.text("============================")
      stdout.text("Roby-Gould covalent orbitals")
      stdout.text("============================")
      stdout.flush
      stdout.text("For atoms:")
      stdout.put(.roby.atom_ab)
      stdout.flush
      stdout.text("Orbital coefficients:")
      stdout.put(.roby.theta_C(:,orb))

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make the grid, gr
      gr.create(.plot_grid.n_pt)
      .:make_ELMO_grid_r(gr,.roby.theta_C(:,orb),pt,.roby.atom_ab)

      ! Write grid, gr
      .:dump_plot_grid(gr,"Roby-Gould_covalent_orbital_"//trim(orb.to_str)//"_grid")

      ! Clean
      gr.destroy
      pt.destroy

   end

   RG_cov_orbital_grid(gr,pt) ::: selfless
   ! Evaluate the Roby-Gould covalent orbital ".plot_grid.orb" for the
   ! points "pt" and store in the grid "gr"
      gr :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==gr.dim, "pt & gr incompatible")
   ENSURE(pt.dim2==3,      "wrong dim2, pt")

      orb :: INT
      self :: MOLECULE*

      .BASE:set_from_saved_self

   ENSURE(.roby.associated, "no roby data -- do one group analysis")
   ENSURE(.roby.theta_C.associated, "no Roby-Gould covalent orbitals")
   ENSURE(.isosurface.plot_grid.orbital>=0, "non-positive theta orbital")
   ENSURE(.isosurface.plot_grid.orbital<=.roby.theta_C.dim2, "orbital out of range, "//trim(.plot_grid.orbital.to_str))

      ! Orbital to be plotted
      orb = .isosurface.plot_grid.orbital

      ! Make the grid, gr
      .:make_ELMO_grid_r(gr,.roby.theta_C(:,orb),pt,.roby.atom_ab)

   end


   make_RG_ion_orbital_grid
   ! Evaluate the Roby-Gould ionic orbital ".plot_grid.orb" and write
   ! it out to a file.
      self :: INOUT

   DIE_IF(NOT .roby.associated, "no roby data -- do one group analysis")
   DIE_IF(NOT .roby.roby_kind=="group_bond_analysis", "must do previous group_bond_analysis")
   DIE_IF(NOT .roby.n_group==2, "must have only two groups")
   ENSURE(.roby.theta_I.associated, "no Roby-Gould ionic orbitals")
   ENSURE(.plot_grid.associated, "no plot_grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive theta orbital")
   ENSURE(.plot_grid.orbital<=.roby.theta_I.dim2, "orbital out of range, "//trim(.plot_grid.orbital.to_str))

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      orb :: INT

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      stdout.flush
      stdout.text("=========================")
      stdout.text("Roby-Gould ionic orbitals")
      stdout.text("=========================")
      stdout.flush
      stdout.text("For atoms:")
      stdout.put(.roby.atom_ab)
      stdout.flush
      stdout.text("Orbital coefficients:")
      stdout.put(.roby.theta_I(:,orb))

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make the grid, gr
      gr.create(.plot_grid.n_pt)
      .:make_ELMO_grid_r(gr,.roby.theta_I(:,orb),pt,.roby.atom_ab)

      ! Write grid, gr
      .:dump_plot_grid(gr,"Roby-Gould_ionic_orbital_"//trim(orb.to_str)//"_grid")

      ! Clean
      gr.destroy
      pt.destroy

   end

   RG_ion_orbital_grid(gr,pt) ::: selfless
   ! Evaluate the Roby-Gould ionic orbital ".plot_grid.orb" for the
   ! points "pt" and store in the grid "gr"
      gr :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==gr.dim, "pt & gr incompatible")
   ENSURE(pt.dim2==3,      "wrong dim2, pt")

      orb :: INT
      self :: MOLECULE*

      .BASE:set_from_saved_self

   ENSURE(.roby.associated, "no roby data -- do one group analysis")
   ENSURE(.roby.theta_I.associated, "no Roby-Gould ionic orbitals")
   ENSURE(.isosurface.plot_grid.orbital>=0, "non-positive theta orbital")
   ENSURE(.isosurface.plot_grid.orbital<=.roby.theta_I.dim2, "orbital out of range, "//trim(.plot_grid.orbital.to_str))

      ! Orbital to be plotted
      orb = .isosurface.plot_grid.orbital

      ! Make the grid, gr
      .:make_ELMO_grid_r(gr,.roby.theta_C(:,orb),pt,.roby.atom_ab)

   end


   make_atom_density_grid_r(grid,NO,occ,pt,atom) ::: PURE
   ! Evaluate the atom density "grid" for all "NO"s and occupation
   ! numbers "occ" for the atom with index "atom" on a set of grid
   ! points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      NO   :: MAT{REAL}, IN
      occ  :: VEC{REAL}, IN
      pt   :: MAT{REAL}, IN
      atom :: INT, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(NO.dim2==occ.dim, "incompatible dim2, NO & occ")
   ENSURE(NO.dim1==.atom(atom).basis.no_of_basis_functions, "wrong dim1, NO")
   ENSURE(pt.dim2==3, "pt dim2 is not 3")

      n :: INT
      g :: VEC{REAL}*

      grid = ZERO

      g.create(pt.dim1)

      parallel do n = 1,NO.dim2
         .atom(atom).make_orbital_grid_r(g,NO(:,n),pt)
         grid = grid + occ(n)*g*g
      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

      ! Clean
      g.destroy

   end

   make_ELMO_grid_r(grid,orb,pt,atom_indices,square) ::: PURE
   ! Evaluate the ELMO "grid" for *one* AO-basis coefficient orbital
   ! vector "orb" on a set of grid points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      atom_indices :: VEC{INT}, IN
      square :: BIN, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(orb.dim==.atom(atom_indices).no_of_basis_functions, "wrong dim2, orbitals")

      n_pt, i,a, na,fa,la :: INT
      sq :: BIN
      ga :: VEC{REAL}*

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      la = 0
      grid = ZERO

      do i = 1,atom_indices.dim

         ! Atom index a
         a = atom_indices(i)

         ! Basis fn limits
         na = .atom(a).basis.n_bf
         fa = la + 1
         la = la + na

         ! Atom a grid, ga
         ga.create(n_pt)
         .atom(a).make_orbital_grid_r(ga,orb(fa:la),pt)

         ! Add ga to grid
         grid = grid + ga

         ! Clean
         ga.destroy

      end

      if (sq) grid = grid*grid

   end

!   ELMO_grid(grid,pt,orbitals,atom_indices) ::: selfless
!   ! Evaluate the values for ELMO ".plot_grid.orb" of "orbitals"
!   ! defined over the "atom_indices", and write out to a file.
!      grid  :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      orbitals :: MAT{REAL}, IN
!      atom_indices :: VEC{INT}, IN
!
!   ENSURE(pt.dim1==grid.dim1,"incompatible # of points, g and pt arrays")
!   ENSURE(pt.dim2==3,"wrong shape, pt array")
!
!      gridc :: VEC{CPX}*
!      n_pt,orb :: INT
!      plot_grid :: PLOT_GRID*
!      self :: MOLECULE*
!
!      ! Get back self
!      .BASE:set_from_saved_self
!
!   ENSURE(.isosurface.associated,"no isosurface")
!   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
!   ENSURE(.natural_orbitals.associated, "no natural orbitals")
!
!      n_pt = pt.dim1
!
!      plot_grid => .isosurface.plot_grid
!
!      ! Get orbital to plot
!      orb = plot_grid.orbital
!
!      ! Make the orbital grid
!      .:make_ELMO_grid_r(grid,orbitals(:,orb),pt,atom_indices)
!
!   end

!  ====================
!  Orbital density grid
!  ====================

   make_orbital_density_grid
   ! Work out the orbital on ".plot_grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gc :: VEC{CPX}*
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .natural_orbitals.spinorbital_kind

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Orbital density here
      gr.create(.plot_grid.n_pt)

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.associated) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if

      select case (relativity)

         case ("douglas-kroll-hess","dkh")

            select case (okind)

               case("restricted")
                  .:make_DKH_orbital_grid_r(gr,orb,pt,square=TRUE)

               case("unrestricted")
                  stdout.flush
                  stdout.text("NOTE:")
                  stdout.text("You can copy either alpha or beta density_matrix and molecular_orbitals")
                  stdout.text("into the appropriate restricted file(s) and plot in the rhf regime!")
                  DIE("UHF/UKS unimplemented")

               case("general_complex")
                  gc.create(.plot_grid.n_pt)
                  .:make_DKH_orb_dens_grid_gc(gc,orb,pt)
                  gr = RE(gc)
                  gc.destroy

               case default
                  DIE("unimplemented")

            end

         case ("iotc")

            select case (okind)

               case("restricted")
                  .:make_IOTC_orbital_grid_r(gr,orb,pt,square=TRUE)

               case("unrestricted")
                  stdout.flush
                  stdout.text("NOTE:")
                  stdout.text("You can copy either alpha or beta density_matrix and molecular_orbitals")
                  stdout.text("into the appropriate restricted file(s) and plot in the rhf regime!")
                  DIE("UHF/UKS unimplemented")

               case("general_complex")
                  gc.create(.plot_grid.n_pt)
                  .:make_IOTC_orb_dens_grid_gc(gc,orb,pt)
                  gr = RE(gc)
                  gc.destroy

               case default
                  DIE("unimplemented")
            end

         case ("none")

            select case (okind)

               case("restricted")
                  .:make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt,square=TRUE)

               case("unrestricted")
                  stdout.flush
                  stdout.text("NOTE:")
                  stdout.text("You can copy either alpha or beta density_matrix and molecular_orbitals")
                  stdout.text("into the appropriate restricted file(s) and plot in the rhf regime!")
                  DIE("UHF/UKS unimplemented")

               case("general")
                  .:make_orbital_grid_g(gr,.molecular_orbitals.general(:,orb),pt)
                  

               case("general_complex")
                  gc.create(.plot_grid.n_pt)
                  .:make_orbital_grid_gc(gc,.molecular_orbitals.general_complex(:,orb),pt)
                  gr = RE(gc)
                  gc.destroy

               case default
                  DIE("unimplemented")
            end

         case default

            DIE("Unimplemented")

      end

      .:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_density_grid")

      gr.destroy
      pt.destroy

   end

   orbital_density_grid(g,pt) ::: selfless
   ! Work out the orbital density grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")

      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*
      orb_kind :: STR

      ! Get back self
      .BASE:set_from_saved_self

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      n_pt = pt.dim1
      grid => .isosurface.plot_grid

      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      orb_kind = .natural_orbitals.spinorbital_kind
      select case (orb_kind)
      case ("restricted")
         .:make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt,square=TRUE)
      case ("general   ")
         ! Below *only* does the square
         .:make_orbital_grid_g(g,.natural_orbitals.general(:,orb),pt) 
      case default
         DIE("Density for orbital "//trim(orb_kind)//"not yet implemented")
      end

   end

! DKH restricted orbital grid

   make_DKH_orbital_grid_r(grid,orb,pt,square)
   ! ???
     ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
     grid :: VEC{REAL}, OUT
     orb :: INT, IN
     pt :: MAT{REAL}, IN
     square :: BIN, IN, optional

        MO :: MAT{REAL}*

        MO => .molecular_orbitals.restricted(:,1:.n_a)
        .:density_DKH_orb_r(grid,pt,MO(:,orb),square)

   end

   density_DKH_orb_r(grid,pt,MO,square)
   ! The density "grid" will be filled with the values of density
   ! given by the coordinates in the pt matrix
      grid :: VEC{REAL} , OUT
      pt :: MAT{REAL} , IN
      MO :: VEC{REAL} , IN
      square :: BIN , IN, optional

      n_gcm,n_pt :: INT
      n,i,j :: INT
      g :: REAL
      m_out :: MAT{INT}*
      YU,GG,S,R,Z,PZP,PPZPP :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      S=ZERO
      .REL:get_da_gcm_now(R,S,m_out)
      R.destroy

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(YU,Ap,Ep,P2)

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      .REL:make_DKH_mxs2(Z,PZP,YU)

      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
         PPZPP.create(n_gcm,n_gcm)
        .REL:make_DKH_mxs4(PPZPP,YU)
      end if

      GG.create(.n_bf,.n_bf)
      grid=ZERO
      parallel do n = 1,n_pt

         ! here it comes babes
         ! point for point the density will be on and on calculated
         ! I am sincerely sorry, but the code comparing to its non-relativistic
         ! counterpart is really not effective :(
         .:make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,PPZPP)

         g = ZERO

         ! This is a diangonal change-basis & sum --dylan
         do i=1,.n_bf
         do j=1,.n_bf
           g = g + MO(i)*GG(i,j)*MO(j)
         end
         end

         ! Unfortunatelly the PCE corrected orbitals lose phase :(
         if (NOT square) g = sqrt(g)

         grid(n) = g

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         PPZPP.destroy
      end if

      S.destroy
      Z.destroy
      PZP.destroy
      GG.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

   make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,PPZPP) ::: private
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN
      Ap,Ep,P2 :: VEC{REAL}, IN
      xx,yy,zz :: REAL, IN
      m_out :: MAT{INT}, IN
      n_gcm :: INT, IN
      S,sZ,sPZP :: MAT{REAL}, IN
      PPZPP :: MAT{REAL}, optional, IN

      c :: REAL
      i,j,k :: INT
      R :: MAT{REAL}*
      D,PDP,PPDPP,T,WW,W2,X,TX :: MAT{REAL}*
      SOx,SOy,SOz,sPZPx,sPZPy,sPZPz,ZXX,PZPXX :: MAT{REAL}*
      Rx,Ry,Rz :: MAT{REAL}*
      A,B,Z,PZP :: MAT{REAL}*
      M,buco :: MAT{REAL}*

      !!!  the density operator X !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_density_matrix(R,xx,yy,zz)

      ! put the potential energy matrix into the n_gcm non-redundant space
      D.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,D,m_out)

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)

      !!!  PDP MATRIX  !!!
      .REL:make_primitive_pDp_matrix(R,xx,yy,zz)

      ! put the PDP matrix into the n_gcm non-redundant space
      PDP.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,PDP,m_out)
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)

      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         .REL:make_primitive_ppDpp_matrix(R,xx,yy,zz)
         PPDPP.create(n_gcm,n_gcm)
         .REL:get_da_gcm_now(R,PPDPP,m_out)
         A.to_product_of(YU,PPDPP,transpose_a=TRUE)
         PPDPP.to_product_of(A,YU)
      end if

      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU

      do i = 1,n_gcm
      do j = 1,n_gcm
         D(i,j) = Ap(i)*D(i,j)*Ap(j)
         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))
      end
      end

      B.create(n_gcm,n_gcm)

      if (.scfdata.DK1_PCE) then

         A = ZERO
         B = ZERO

         do i = 1,n_gcm
            B(i,i) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
            A(i,i) = ONE/B(i,i)
         end do

         T.create(n_gcm,n_gcm)
         T =     matmul(sPZP, matmul(A,PDP) )
         T = T - matmul(sPZP,D)
         T = T - matmul(sZ,PDP)
         T = T + matmul(sZ, matmul(B,D) )
         T = T + matmul(D, matmul(B,sZ) )
         T = T - matmul(PDP,sZ)
         T = T - matmul(D,sPZP)
         T = T + matmul(PDP, matmul(A,sPZP) )

         if (.scfdata.using_SO_FDFF) then

            ! these are additional scalar terms due to presence of SO terms
            ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz
            ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz)

            !!!  SO MATRICES  !!!
            SOx.create(n_gcm,n_gcm)
            SOy.create(n_gcm,n_gcm)
            SOz.create(n_gcm,n_gcm)

            ! put the SO matrices into the n_gcm non-redundant space
            Rx.create(.n_prim,.n_prim)
            Ry.create(.n_prim,.n_prim)
            Rz.create(.n_prim,.n_prim)

            .REL:make_primitive_pDp_SO_matrix(Rx,Ry,Rz,xx,yy,zz)
            .REL:get_da_gcm_now(Rx,SOx,m_out)
            .REL:get_da_gcm_now(Ry,SOy,m_out)
            .REL:get_da_gcm_now(Rz,SOz,m_out)

            Rx.destroy
            Ry.destroy
            Rz.destroy

              ZXX.create(n_gcm,n_gcm)
            PZPXX.create(n_gcm,n_gcm)

            ZXX.to_product_of(YU,SOx,transpose_a=TRUE)
            SOx.to_product_of(ZXX,YU)
            ZXX.to_product_of(YU,SOy,transpose_a=TRUE)
            SOy.to_product_of(ZXX,YU)
            ZXX.to_product_of(YU,SOz,transpose_a=TRUE)
            SOz.to_product_of(ZXX,YU)

            do i = 1,n_gcm
            do j = 1,n_gcm
               SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))
               SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))
               SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))
            end
            end

            sPZPx.create(n_gcm,n_gcm)
            sPZPy.create(n_gcm,n_gcm)
            sPZPz.create(n_gcm,n_gcm)

            .:make_DKH_mxs3(ZXX,PZPXX,sPZPx,sPZPy,sPZPz,YU)

            ZXX.destroy
            PZPXX.destroy

            T = T - matmul(SOx, matmul(A,sPZPx) )
            T = T - matmul(SOy, matmul(A,sPZPy) )
            T = T - matmul(SOz, matmul(A,sPZPz) )
            T = T - matmul(sPZPx, matmul(A,SOx) )
            T = T - matmul(sPZPy, matmul(A,SOy) )
            T = T - matmul(sPZPz, matmul(A,SOz) )

            SOx.destroy
            SOy.destroy
            SOz.destroy;
            sPZPx.destroy
            sPZPy.destroy
            sPZPz.destroy;

         end if

         if (.scfdata.DK2_PCE) then

            !!! W1W1
            WW.create(n_gcm,n_gcm)
            WW =    - matmul(sZ, matmul(B,sZ) )
            WW = WW + matmul(sPZP,sZ)
            WW = WW + matmul(sZ,sPZP)
            WW = WW - matmul(sPZP, matmul(A,sPZP) )

            X.create(n_gcm,n_gcm)
            TX.create(n_gcm,n_gcm)
            X = D + PDP
            TX=HALF*(matmul(WW,X)+matmul(X,WW))
            WW.destroy

            Z.create(n_gcm,n_gcm)
            PZP.create(n_gcm,n_gcm)

            if (.scfdata.using_ppzpp) then

               ! use the second derivatives in the [W1,[W1,X(even,0)]]
               ! and [W2,X(odd,0)] terms

               do i=1,n_gcm
               do j=1,n_gcm
                  PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 )
                  Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
                  PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
               end do
               end do

               X  = PPDPP + PDP
               TX = TX - matmul(sPZP,matmul(A,matmul(X,sZ)))
               TX = TX + matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
               TX = TX + matmul(sZ,matmul(X,sZ))
               TX = TX - matmul(sZ,matmul(X, matmul(A,sPZP)))

               PPDPP.destroy
               X.destroy

               !!! The -[W2,X(odd,0)] terms
               W2.create(n_gcm,n_gcm)
               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                        &
                     + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
                     - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
                     - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)  &
                     + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )
               end do
               end do
               end do
               TX = TX + matmul(W2,PDP)

               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                        &
                     + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
                     + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )
               end do
               end do
               end do

               TX = TX + matmul(PDP,W2)

               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                        &
                     -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
                     -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )
               end do
               end do
               end do

               TX = TX + matmul(D,W2)

               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                         &
                    -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
                    +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
                    +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
                    -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)
               end do
               end do
               end do

               TX = TX + matmul(W2,D)

            else

               ! the second derivatives are not used in the
               ! [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms

               X.destroy
               do i=1,n_gcm
               do j=1,n_gcm
                  Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
                  PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
               end do
               end do

               TX = TX - matmul(sPZP,matmul(A,matmul(PDP,sZ)))
               TX = TX - matmul(sPZP,matmul(D,matmul(B,sZ)))
               TX = TX + matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
               TX = TX + matmul(sPZP, matmul(D,sPZP))
               TX = TX + matmul(sZ,matmul(PDP,sZ))
               TX = TX + matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
               TX = TX - matmul(sZ,matmul(PDP, matmul(A,sPZP)))
               TX = TX - matmul(sZ,matmul(B, matmul(D,sPZP)))

               !!!  The [W2,X(odd,0)] terms
               !   the second derivatives are not used
               W2.create(n_gcm,n_gcm)
               W2 =    matmul( sPZP, matmul(A, matmul(PZP,A) ) )
               W2 = W2 + matmul( sPZP, Z )
               W2 = W2 - matmul( sZ, ( matmul(PZP,A) ) )
               W2 = W2 - matmul( sZ, ( matmul(B,Z) ) )
               W2 = W2 - matmul( Z,  matmul(sPZP,A)  )
               W2 = W2 - matmul( PZP,  matmul(sPZP,A)  )
               W2 = W2 + matmul( Z,  sZ  )
               W2 = W2 + matmul( PZP,  sZ  )
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               end do
               end do

               TX = TX + matmul(W2,PDP)

               W2 =      matmul( sZ, Z )
               W2 = W2 + matmul( sZ, PZP )
               W2 = W2 - matmul( matmul(A,sPZP), Z )
               W2 = W2 - matmul( matmul(A,sPZP), PZP )
               W2 = W2 - matmul( matmul(A,PZP)  ,   sZ)
               W2 = W2 - matmul( matmul(Z,B)  ,   sZ)
               W2 = W2 + matmul( matmul(A,matmul(PZP,A)) , sPZP)
               W2 = W2 + matmul( Z , sPZP)
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               end do
               end do

               TX = TX + matmul(PDP,W2)

               W2 =    - matmul( matmul(B,sZ), Z )
               W2 = W2 - matmul( matmul(B,sZ), PZP )
               W2 = W2 + matmul( sPZP  ,   Z )
               W2 = W2 + matmul( sPZP  , PZP )
               W2 = W2 + matmul( PZP   ,  sZ )
               W2 = W2 + matmul( matmul(B,matmul(Z,B)) , sZ)
               W2 = W2 - matmul( matmul(PZP,A) , sPZP )
               W2 = W2 - matmul( matmul(B,Z) , sPZP )
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               end do
               end do

               TX = TX + matmul(D,W2)

               W2 =    - matmul( sPZP  , matmul(A,PZP) )
               W2 = W2 - matmul( sPZP  , matmul(Z,B) )
               W2 = W2 + matmul( sZ    , PZP)
               W2 = W2 + matmul( sZ    , matmul( B, matmul(Z,B) ) )
               W2 = W2 + matmul( Z , sPZP  )
               W2 = W2 + matmul( PZP , sPZP  )
               W2 = W2 - matmul( Z ,  matmul(sZ,B) )
               W2 = W2 - matmul( PZP ,  matmul(sZ,B) )
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               end do
               end do

               TX = TX + matmul(W2,D)

            end if

            W2.destroy
            Z.destroy
            PZP.destroy

         end if

      end if

      D = D + PDP
      PDP.destroy

      if(.scfdata.DK1_PCE)then
         D = D + T
         T.destroy
      end if

      if(.scfdata.DK2_PCE)then
         D = D + TX
         TX.destroy
      end if

      B.to_product_of(S,YU)
      A.to_product_of(B,D)
      D.to_product_of(A,B,transpose_b=TRUE)

      A.destroy
      B.destroy

      !!! moving back to tonto style primitive basis sets
      ! put the Fock matrix back to the space .n_prim space
      .REL:get_back_prim_now(D,R,m_out)
      D.destroy

      !!! moving back to contracted basis sets
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)
      buco.create(.n_bf,.n_prim)
      buco.to_product_of(M,R,transpose_a=TRUE)
      R.destroy

      GG.to_product_of(buco,M)

      M.destroy
      buco.destroy

   end

   make_DKH_mxs3(Z,PZP,Lx,Ly,Lz,YU) ::: private
   ! get the Z and PZP matrix
   ! which are in the momentum space
      self :: IN
      Z,PZP,Lx,Ly,Lz :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN

      m_out :: MAT{INT}*
      i,j,n_gcm :: INT
      c :: REAL
      R,SOx,SOy,SOz,A,X :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      !!!  Z MATRIX  !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_nuclear_matrix(R)
      .REL:get_da_gcm_now(R,Z,m_out)

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)

      !!! PZP and SO MATRICES  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      .REL:get_da_gcm_now(R,PZP,m_out)
      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)

      .REL:get_da_gcm_now(SOx,Lx,m_out)
      A.to_product_of(YU,Lx,transpose_a=TRUE)
      Lx.to_product_of(A,YU)
      .REL:get_da_gcm_now(SOy,Ly,m_out)
      A.to_product_of(YU,Ly,transpose_a=TRUE)
      Ly.to_product_of(A,YU)
      .REL:get_da_gcm_now(SOz,Lz,m_out)
      A.to_product_of(YU,Lz,transpose_a=TRUE)
      Lz.to_product_of(A,YU)

      A.destroy
      R.destroy
      SOx.destroy
      SOy.destroy
      SOx.destroy
      m_out.destroy

      c = SPEED_OF_LIGHT_AU

      X.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(X,Ap,Ep,P2)

      do i=1,n_gcm
      do j=1,n_gcm
           Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
          Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
          Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
          Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
      end
      end

      X.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy

   end

! DKH general complex orbital grid (naming problem?)

   make_DKH_orb_dens_grid_gc(grid,orb,pt)
   ! ???
      grid :: VEC{CPX}, OUT
      orb :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")

      CMO :: MAT{CPX}*

      CMO => .molecular_orbitals.general_complex(:,1:.n_e)
      .:density_DKH_orb_gc(grid,pt,CMO(:,orb))

   end

   density_DKH_orb_gc(grid,pt,MO)
   ! The density "grid" will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      grid :: VEC{CPX}, OUT
      pt :: MAT{REAL}, IN
      MO :: VEC{CPX}, IN

      n_gcm,n_pt :: INT
      n,i,j :: INT
      II,gc :: CPX
      m_out :: MAT{INT}*
      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*
      SOx,SOy,SOz :: MAT{REAL}*
      GG22,Z2,PZP2 :: MAT{CPX}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)
      R.destroy

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)
      .:make_DKH_mxs_2(YU,Ap,Ep,P2)

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      .:make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         PPZPP.create(n_gcm,n_gcm)
         .REL:make_DKH_mxs4(PPZPP,YU)
         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
      end if

      GG22.create(2*.n_bf,2*.n_bf)
        Z2.create(2*.n_bf,2*.n_bf)
      PZP2.create(2*.n_bf,2*.n_bf)

      Z2 = (ZERO,ZERO)
      Z2.alpha_alpha_plus(Z)
      Z2.beta_beta_plus(Z)

      II = (ZERO,ONE)

      PZP2 = (ZERO,ZERO)
      PZP2.alpha_alpha_plus(PZP)
      PZP2.beta_beta_plus(PZP)
      PZP2.beta_alpha_plus(SOx,II)
      PZP2.beta_alpha_plus(SOy,-ONE)
      PZP2.alpha_alpha_plus(SOz,II)
      PZP2.beta_beta_plus(SOz,-II)
      PZP2.make_hermitian

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      grid=(ZERO,ZERO)
      parallel do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to its non-relativistic counterpart is really not
         ! effective :(
         .:make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)

         gc = (ZERO,ZERO)
         do i = 1,2*.n_bf
         do j = 1,2*.n_bf
            gc = gc + conjg(MO(i))*GG22(i,j)*MO(j)
         end
         end

         grid(n) = gc

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp) PPZPP.destroy

      S.destroy
      Z2.destroy
      PZP2.destroy
      GG22.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

   make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,xx,yy,zz,n_gcm,S,sZ2,sPZP2) ::: private
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG22 :: MAT{CPX}, OUT
      YU :: MAT{REAL}, IN
      Ap,Ep,P2 :: VEC{REAL}, IN
      xx,yy,zz :: REAL, IN
      n_gcm :: INT, IN
      S :: MAT{REAL} , IN
      sZ2,sPZP2 :: MAT{CPX}, IN

      c,fac :: REAL
      i,j :: INT
      D,PDP,SOx,SOy,SOz :: MAT{REAL}*
      D2,PDP2 :: MAT{CPX}*
      WW,W2,TX,Z2,PZP2,X,T,A2,B2,M2 :: MAT{CPX}*
      A,B,M :: MAT{REAL}*
      II :: CPX

      !!!  the density X operator !!!
      D.create(n_gcm,n_gcm)
      .REL:make_primitive_density_matrix(D,xx,yy,zz)

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)

      !!!  the density PXP operator !!!
      PDP.create(n_gcm,n_gcm)
      .REL:make_primitive_pDp_matrix(PDP,xx,yy,zz)
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)

      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      SOx=ZERO; SOy=ZERO; SOz=ZERO
      .REL:make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz)
      A.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(A,YU)
      A.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(A,YU)
      A.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(A,YU)
      A.destroy

      !!! A-O LETS GO !!!

      B.create(2*n_gcm,2*n_gcm)
      A.create(2*n_gcm,2*n_gcm)

      c = SPEED_OF_LIGHT_AU

      do i=1,n_gcm
      do j=1,n_gcm
         D(i,j) = Ap(i)*D(i,j)*Ap(j)
         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))
         SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))
         SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))
         SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))
      end
      end

      D2.create(2*n_gcm,2*n_gcm)
      D2=(ZERO,ZERO)
      D2.alpha_alpha_plus(D)
      D2.beta_beta_plus(D)

      II = (ZERO,ONE)
      fac=ONE

      PDP2.create(2*n_gcm,2*n_gcm)
      PDP2=(ZERO,ZERO)
      PDP2.alpha_alpha_plus(PDP)
      PDP2.beta_beta_plus(PDP)
      PDP2.beta_alpha_plus(SOx,fac*II)
      PDP2.beta_alpha_plus(SOy,-fac)
      PDP2.alpha_alpha_plus(SOz,fac*II)
      PDP2.beta_beta_plus(SOz,-fac*II)
      PDP2.make_hermitian

      D.destroy
      PDP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy

      if (.scfdata.DK1_PCE) then

         A = ZERO
         B = ZERO

         do i = 1,n_gcm
             B(i,i)             = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
             B(i+n_gcm,i+n_gcm) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
             A(i,i)             = ONE/B(i,i)
             A(i+n_gcm,i+n_gcm) = ONE/B(i,i)
         end

         ! SO part comes first
         ! fdff am not sure if it is implemented, seems not
         T.create(2*n_gcm,2*n_gcm)
         T =        matmul(sPZP2, matmul(A,PDP2) )
         T =  T  -  matmul(sPZP2,D2)
         T =  T  -  matmul(sZ2,PDP2)
         T =  T  +  matmul(sZ2, matmul(B,D2) )
         T =  T  +  matmul(D2, matmul(B,sZ2) )
         T =  T  -  matmul(PDP2,sZ2)
         T =  T  -  matmul(D2,sPZP2)
         T =  T  +  matmul(PDP2, matmul(A,sPZP2) )

         ! only the scalar second order correction
         if (.scfdata.DK2_PCE) then

            !!! W1W1
            WW.create(2*n_gcm,2*n_gcm)
            WW =      -  matmul(sZ2, matmul(B,sZ2) )
            WW =  WW  +  matmul(sPZP2,sZ2)
            WW =  WW  +  matmul(sZ2,sPZP2)
            WW =  WW  -  matmul(sPZP2, matmul(A,sPZP2) )

            X.create(2*n_gcm,2*n_gcm)
            TX.create(2*n_gcm,2*n_gcm)

            X  = D2 + PDP2
            TX = HALF*(matmul(WW,X)+matmul(X,WW))

            WW.destroy
            X.destroy

            Z2.create(2*n_gcm,2*n_gcm)
            PZP2.create(2*n_gcm,2*n_gcm)

            Z2   = (ZERO,ZERO)
            PZP2 = (ZERO,ZERO)

            do i=1,n_gcm
            do j=1,n_gcm
                Z2(i,j)=sZ2(i,j)*(Ep(i)+Ep(j))
                Z2(i+n_gcm,j+n_gcm)=sZ2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
                PZP2(i,j)=sPZP2(i,j)*(Ep(i)+Ep(j))
                PZP2(i+n_gcm,j+n_gcm)=sPZP2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
                PZP2(i,j+n_gcm)=sPZP2(i,j+n_gcm)*(Ep(i)+Ep(j))
                PZP2(i+n_gcm,j)=sPZP2(i+n_gcm,j)*(Ep(i)+Ep(j))
            end do
            end do

            TX = TX - matmul(sPZP2,matmul(A,matmul(PDP2,sZ2)))
            TX = TX - matmul(sPZP2,matmul(D2,matmul(B,sZ2)))
            TX = TX + matmul(sPZP2,matmul(A, matmul(PDP2, matmul(A,sPZP2))))
            TX = TX + matmul(sPZP2, matmul(D2,sPZP2))
            TX = TX + matmul(sZ2,matmul(PDP2,sZ2))
            TX = TX + matmul(sZ2,matmul(B, matmul(D2, matmul(B,sZ2))))
            TX = TX - matmul(sZ2,matmul(PDP2, matmul(A,sPZP2)))
            TX = TX - matmul(sZ2,matmul(B, matmul(D2,sPZP2)))

            !!!  The [W2,X(odd,0)] terms
            !   the second derivatives are not used
            W2.create(2*n_gcm,2*n_gcm)
            W2 =      matmul( sPZP2, matmul(A, matmul(PZP2,A) ) )
            W2 = W2 + matmul( sPZP2, Z2 )
            W2 = W2 - matmul( sZ2, ( matmul(PZP2,A) ) )
            W2 = W2 - matmul( sZ2, ( matmul(B,Z2) ) )
            W2 = W2 - matmul( Z2,  matmul(sPZP2,A)  )
            W2 = W2 - matmul( PZP2,  matmul(sPZP2,A)  )
            W2 = W2 + matmul( Z2,  sZ2  )
            W2 = W2 + matmul( PZP2,  sZ2  )
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
            end do
            end do

            TX = TX + matmul(W2,PDP2)

            W2 =    matmul( sZ2, Z2 )
            W2 = W2 + matmul( sZ2, PZP2 )
            W2 = W2 - matmul( matmul(A,sPZP2), Z2 )
            W2 = W2 - matmul( matmul(A,sPZP2), PZP2 )
            W2 = W2 - matmul( matmul(A,PZP2)  ,   sZ2)
            W2 = W2 - matmul( matmul(Z2,B)  ,   sZ2)
            W2 = W2 + matmul( matmul(A,matmul(PZP2,A)) , sPZP2)
            W2 = W2 + matmul( Z2 , sPZP2)
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
            end do
            end do

            TX = TX + matmul(PDP2,W2)

            W2 =    - matmul( matmul(B,sZ2), Z2 )
            W2 = W2 - matmul( matmul(B,sZ2), PZP2 )
            W2 = W2 + matmul( sPZP2  ,   Z2 )
            W2 = W2 + matmul( sPZP2  , PZP2 )
            W2 = W2 + matmul( PZP2   ,  sZ2 )
            W2 = W2 + matmul( matmul(B,matmul(Z2,B)) , sZ2)
            W2 = W2 - matmul( matmul(PZP2,A) , sPZP2 )
            W2 = W2 - matmul( matmul(B,Z2) , sPZP2 )
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
            end do
            end do

            TX = TX + matmul(D2,W2)

            W2 =    - matmul( sPZP2  , matmul(A,PZP2) )
            W2 = W2 - matmul( sPZP2  , matmul(Z2,B) )
            W2 = W2 + matmul( sZ2    , PZP2)
            W2 = W2 + matmul( sZ2    , matmul( B, matmul(Z2,B) ) )
            W2 = W2 + matmul( Z2 , sPZP2  )
            W2 = W2 + matmul( PZP2 , sPZP2  )
            W2 = W2 - matmul( Z2 ,  matmul(sZ2,B) )
            W2 = W2 - matmul( PZP2 ,  matmul(sZ2,B) )
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
            end do
            end do

            TX = TX + matmul(W2,D2)

            W2.destroy
            Z2.destroy
            PZP2.destroy

         end if

      end if

      D2 = D2 + PDP2

      PDP2.destroy

      if(.scfdata.DK1_PCE)then
         D2 = D2 + T
         T.destroy
      end if

      if(.scfdata.DK2_PCE)then
         D2 = D2 + TX
         TX.destroy
      end if

      A.destroy
      B.destroy

      ! back to cartesian basis set
      A2.create(2*n_gcm,2*n_gcm)

      B2.create(2*n_gcm,2*n_gcm)
      B.create(n_gcm,n_gcm)

      B.to_product_of(S,YU)
      B2 = (ZERO,ZERO)
      B2.alpha_alpha_plus(B)
      B2.beta_beta_plus(B)

      A2.to_product_of(B2,D2)
      D2.to_product_of(A2,B2,dagger_b=TRUE)

      B.destroy
      B2.destroy

      !!! moving back to contracted basis sets
      M2.create(2*.n_prim,2*.n_prim)
      M.create(.n_prim,.n_prim)

      .BASE:make_normalised_contraction_mx(M)

      M2 = (ZERO,ZERO)
      M2.alpha_alpha_plus(M)
      M2.beta_beta_plus(M)
      A2.to_product_of(M2,D2,dagger_a=TRUE)
      D2.to_product_of(A2,M2)

      GG22 = D2

      .BASE:put_debug(GG22,"GG22 matrix")

      M.destroy
      M2.destroy
      A2.destroy
      D2.destroy

   end

   make_DKH_mxs_2(YU,Ap,Ep,P2) ::: private
   ! things necessary for the DKH transformation
   ! within the PCE and the dkh_norm staff
      self :: IN
      YU :: MAT{REAL}, OUT
      Ap,Ep :: VEC{REAL}, OUT
      P2 :: VEC{REAL}

      m_out :: MAT{INT}*
      i,n_gcm :: INT
      c :: REAL
      S,Y,U :: MAT{REAL}*

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      !!! OVERLAP ENERGY MATRIX  !!!
      S.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(S)
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)

      !!!  KINETIC ENERGY MATRIX  !!!
      .REL:make_primitive_kinetic_matrix(S)
      m_out.destroy

      U.create(n_gcm,n_gcm)
      U.to_product_of(Y,S)
      S.to_product_of(U,Y)
      S.solve_symmetric_eigenproblem(P2,U)
      S.destroy

      P2= TWO * P2

      c = SPEED_OF_LIGHT_AU
      do i = 1,n_gcm
         Ep(i)= c * sqrt(P2(i) + c * c)
         Ap(i)= sqrt( (Ep(i) + c * c)/(TWO * Ep(i)) )
      end

      YU.to_product_of(Y,U)

      Y.destroy
      U.destroy

   end

   make_DKH_mxs3_2(Z,PZP,Lx,Ly,Lz,YU) ::: private
   ! get the Z and PZP matrix
   ! which are in the momentum space
      self :: IN
      Z,PZP,Lx,Ly,Lz :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN

      m_out :: MAT{INT}*
      i,j,n_gcm :: INT
      c :: REAL
      A,X :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      !!!  Z MATRIX  !!!
      .REL:make_primitive_nuclear_matrix(Z)

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)

      !!!  PZP and SO MATRICES  !!!
      .REL:make_primitive_DKH_matrices(PZP,Lx,Ly,Lz)
      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)
      A.to_product_of(YU,Lx,transpose_a=TRUE)
      Lx.to_product_of(A,YU)
      A.to_product_of(YU,Ly,transpose_a=TRUE)
      Ly.to_product_of(A,YU)
      A.to_product_of(YU,Lz,transpose_a=TRUE)
      Lz.to_product_of(A,YU)

      A.destroy
      m_out.destroy

      c = SPEED_OF_LIGHT_AU

      X.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(X,Ap,Ep,P2)

      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
         Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
         Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
         Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
      end
      end

      X.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy

   end

! IOTC real orbitals

   make_IOTC_orbital_grid_r(grid,orb,pt,square)
   !  ???
      self :: IN
      grid :: VEC{REAL}, OUT
      orb :: INT, IN
      pt :: MAT{REAL}, IN
      square :: BIN, IN, optional

   ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")

      MO :: MAT{REAL}*

      MO => .molecular_orbitals.restricted(:,1:.n_a)
      .:density_IOTC_orb_r(grid,pt,MO(:,orb),square)

   end

   density_IOTC_orb_r(grid,pt,MO,square)
   ! The density "grid" will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      MO :: VEC{REAL}, IN
      square :: BIN, optional, IN

      n_gcm,n_pt :: INT
      n,i,j,k :: INT
      g,c,alpha,alpha2 :: REAL
      m_out :: MAT{INT}*
      R,Y,U,A,T,O :: MAT{REAL}*
      SOx,SOy,SOz,Yr :: MAT{REAL}*
      YU,GG,S,Z,PZP :: MAT{REAL}*
      P2,Ap,E,p,ep,bp :: VEC{REAL}*

      n_pt = pt.dim1

      !!! analysis of the primitive basis set via the overap matrix
      !!! trying to lower the problem to an general contracted basis set
      !!!  OVERLAP MATRIX !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      m_out.create(.n_prim,.n_prim)
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
      ! put the overlap matrix into the n_gcm non-redundant space
      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)

      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)

      !!!  KINETIC ENERGY MATRIX !!!
      .REL:make_primitive_kinetic_matrix(R)
      T.create(n_gcm,n_gcm)
      ! put the kinetic energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,T,m_out)

      A.create(n_gcm,n_gcm)
      A.to_product_of(Y,T)
      T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_symmetric_eigenproblem(P2,U)
      P2= TWO * P2
      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      T.destroy
      Y.destroy
      U.destroy

      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      .REL:make_primitive_nuclear_matrix(R)
      Z.create(n_gcm,n_gcm)
      ! put the potential energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,Z,m_out)

      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)

      !!!  PZP MATRIX  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy

      PZP.create(n_gcm,n_gcm)
      ! put the PZP matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,PZP,m_out)

      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)

      !!! A-O LETS GO !!!
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha

      E.create(n_gcm)
      p.create(n_gcm)
      ep.create(n_gcm)
      Ap.create(n_gcm)
      bp.create(n_gcm)

      do i = 1,n_gcm
         E(i)  = c * sqrt(P2(i) + c*c)
         p(i)  = sqrt(P2(i))
         ep(i) = sqrt(ONE+P2(i)*alpha2)
         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )
         bp(i) = ONE/(ep(i)+ONE)
      end

      P2.destroy

      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
      end
      end

      ! lets find the transforation matrix
      Yr.create(n_gcm,n_gcm)

      .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)

      ! lets make ready the normalzation matrix
      O.create(n_gcm,n_gcm)
      O = ZERO
      do i = 1,n_gcm
         O(i,i) = ONE
         do j=1,n_gcm
         do k=1,n_gcm
            O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
         end do
         end do
      end do

      A.to_inverse_sqrt_of(O)
      O = A
      Z.destroy
      PZP.destroy
      A.destroy

      GG.create(.n_bf,.n_bf)
      grid=ZERO
      parallel do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .:make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

         g = ZERO

         do i = 1,.n_bf
         do j = 1,.n_bf
            g = g + MO(i)*GG(i,j)*MO(j)
         end
         end

         ! unfortunatelly the PCE corrected orbitals lose phase :(
         if (NOT square) g = sqrt(g)

         grid(n) = g

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

      R.destroy
      S.destroy
      O.destroy
      GG.destroy
      YU.destroy
      Yr.destroy
      Ap.destroy
      E.destroy
      p.destroy
      bp.destroy
      ep.destroy
      m_out.destroy

   end

   make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O) ::: private
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG :: MAT{REAL} , OUT
      Yr,YU :: MAT{REAL} , IN
      Ap,bp,p :: VEC{REAL} , IN
      ep :: VEC{REAL}
      xx,yy,zz :: REAL , IN
      m_out :: MAT{INT} , IN
      n_gcm :: INT , IN
      S,O :: MAT{REAL} , IN

      i,j :: INT
      R :: MAT{REAL}*
      D,PDP,PPDPP :: MAT{REAL}*
      A,B :: MAT{REAL}*
      M,buco :: MAT{REAL}*

      ep = ep

      !!!  the density operator X !!!
      R.create(.n_prim,.n_prim)
      ! it do not exist in the moment
      .REL:make_primitive_density_matrix(R,xx,yy,zz)
      D.create(n_gcm,n_gcm)
      ! put the potential energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,D,m_out)

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)

      !!!  PDP MATRIX  !!!
      .REL:make_primitive_pDp_matrix(R,xx,yy,zz)

      PDP.create(n_gcm,n_gcm)
      ! put the PDP matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,PDP,m_out)
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)

      if (.scfdata.using_ppzpp) then
         .REL:make_primitive_ppDpp_matrix(R,xx,yy,zz)
         PPDPP.create(n_gcm,n_gcm)
         .REL:get_da_gcm_now(R,PPDPP,m_out)
         A.to_product_of(YU,PPDPP,transpose_a=TRUE)
         PPDPP.to_product_of(A,YU)
      end if

      !!! A-O LETS GO !!!

      do i=1,n_gcm
      do j=1,n_gcm
         D(i,j)   = Ap(i)*D(i,j)*Ap(j)
         PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
      end
      end

      if(.scfdata.using_ppzpp)then
         ! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms
         do i=1,n_gcm
         do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j)
         end do
         end do
      end if

      B.create(n_gcm,n_gcm)
      if (.scfdata.using_ppzpp) then; .:build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm,PPDPP)
      else;                           .:build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm)
      end if

      D=ZERO
      D=matmul(O,matmul(B,O))

     PDP.destroy
     if(.scfdata.using_ppzpp)then
      PPDPP.destroy
     end if

      B=ZERO
      B.to_product_of(S,YU)

      A=ZERO
      A.to_product_of(B,D)
      D.to_product_of(A,B,transpose_b=TRUE)

      A.destroy
      B.destroy

 !!! moving back to tonto style primitive basis sets
      R=ZERO
 ! put the Fock matrix back to the space .n_prim space
      .REL:get_back_prim_now(D,R,m_out)
      D.destroy

 !!! moving back to contracted basis sets
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)
      buco.create(.n_bf,.n_prim)
      buco.to_product_of(M,R,transpose_a=TRUE)
      R.destroy

      GG.to_product_of(buco,M)

      M.destroy
      buco.destroy

   end

   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,n_gcm,ppApp) ::: private
   ! build the IOTC Y matrix, real version
      self :: IN
      F :: MAT{REAL}, OUT
      Yr,PAP,A :: MAT{REAL}, IN
      p,bp :: VEC{REAL}, IN
      n_gcm :: INT, IN
      ppApp :: MAT{REAL}, optional, IN

      i,j :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{REAL}*

      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha

      F1L.create(n_gcm,n_gcm)
      F1R.create(n_gcm,n_gcm)
       F2.create(n_gcm,n_gcm)
      AAA.create(n_gcm,n_gcm)

      if( .scfdata.using_ppzpp)then
         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
         end do
         end do
      else
         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do
      end

      do i = 1,n_gcm
      do j = 1,n_gcm
          F(i,j)  = A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) = alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )
         F1R(i,j) = alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
          F2(i,j) = PAP(i,j)/p(j)/p(i) + AAA(i,j)
         end do
      end do

      F2.change_basis_using(Yr)

      F.plus_product_of( Yr,F1L,transpose_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)

      ! Remove matmuls -- dylan
    ! F=F+matmul(transpose(Yr),F1L)
    ! F=F+matmul(F1R,Yr)
    ! F=F+matmul(transpose(Yr),matmul(F2,Yr))

      AAA.destroy
       F2.destroy
      F1R.destroy
      F1L.destroy

   end

! IOTC general complex orbitals

   make_IOTC_orb_dens_grid_gc(grid,orb,pt)
   ! ???
      self :: IN
      grid :: VEC{CPX}, OUT
      orb :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")

      CMO :: MAT{CPX}*

      CMO => .molecular_orbitals.general_complex(:,1:.n_e)
      .:density_IOTC_orb_gc(grid,pt,CMO(:,orb))

   end

   density_IOTC_orb_gc(grid,pt,MO)
   ! The density "grid" will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      grid :: VEC{CPX}, OUT
      pt :: MAT{REAL} , IN
      MO :: VEC{CPX} , IN

      n_gcm,n_pt :: INT
      n,i,j :: INT
      g,c,alpha,alpha2,eps :: REAL
      II :: CPX
      m_out,mmm :: MAT{INT}*
      Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
      GG22 :: MAT{CPX}*
      SOx,SOy,SOz :: MAT{REAL}*
      A2,PAP,O,Ox,Yr :: MAT{CPX}*
      Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

      n_pt = pt.dim1

      !test
      mmm.create(.n_prim,.n_prim)
      .REL:get_n_gcm(mmm,n_gcm)
      mmm.destroy

      if ( abs(.n_prim-n_gcm)> 0 OR abs(.n_prim-.n_bf)>0) then
         DIE(" contracted gaussians do not work for IOTC at gchf level!")
      end if

      !!! n_gcm = .n_prim = .n_bf ??? --dylan

      ! this is actually not needed but I am also using n_gcm
      m_out.create(.n_prim,.n_prim)
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)

      R.create(.n_prim,.n_prim)
      S.create(n_gcm,n_gcm)
      Y.create(n_gcm,n_gcm)

      !!!  OVERLAP MATRIX + Y MX !!!
      .REL:make_primitive_overlap_matrix(S)
      Y.to_inverse_sqrt_of(S)
      !  .make_S_Y(S,Y)  !  ???

      !!!  KINETIC ENERGY MATRIX -> U & P2!!!
      T.create(n_gcm,n_gcm)
      .REL:make_primitive_kinetic_matrix(T)
      R.to_product_of(Y,T)
      T.to_product_of(R,Y)
      ! T=YTY  kinetic energy in an orthogonal basis
      P2.create(n_gcm)
      U.create(n_gcm,n_gcm)
      T.solve_symmetric_eigenproblem(P2,U)
      ! the momentum squared instead of kinetic energy
      P2= TWO * P2

      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      Y.destroy
      U.destroy
      T.destroy

      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      Z.create(n_gcm,n_gcm)
      .REL:make_primitive_nuclear_matrix(Z)
      ! put the potential energy matrix into the YU space
      R.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(R,YU)

      !!!  PZP MATRIX  !!!
      PZP.create(n_gcm,n_gcm)
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)

      R.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(R,YU)
      R.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(R,YU)
      R.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(R,YU)
      R.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(R,YU)

      !!! A-O LETS GO !!!
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha

      E.create(2*n_gcm)
      ep.create(2*n_gcm)
      p.create(2*n_gcm)
      bp.create(2*n_gcm)
      Ap.create(n_gcm)

      do i = 1,n_gcm
         E(i)       = c * sqrt(P2(i) + c * c)
         E(i+n_gcm) = c * sqrt(P2(i) + c * c)
         p(i)       = sqrt(P2(i))
         p(i+n_gcm) = sqrt(P2(i))
         ep(i)      = sqrt(ONE+P2(i)*alpha2)
         ep(i+n_gcm)= sqrt(ONE+P2(i)*alpha2)
         bp(i)      = ONE/(ep(i)+ONE)
         bp(i+n_gcm)= ONE/(ep(i)+ONE)
         Ap(i)      = sqrt( (E(i) + c * c)/(TWO * E(i)) )
      end do

      P2.destroy

      do i = 1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
      end
      end

      A2.create(2*n_gcm,2*n_gcm)
      A2 = (ZERO,ZERO)
      A2.alpha_alpha_plus(Z)
      A2.beta_beta_plus(Z)

      PAP.create(2*n_gcm,2*n_gcm)
      PAP = (ZERO,ZERO)
      PAP.alpha_alpha_plus(PZP)
      PAP.beta_beta_plus(PZP)
      II = (ZERO,ONE)
      PAP.beta_alpha_plus(SOx,II)
      PAP.beta_alpha_plus(SOy,-ONE)
      PAP.alpha_alpha_plus(SOz,II)
      PAP.beta_beta_plus(SOz,-II)
      PAP.make_hermitian

      ! lets find the transforation matrix
      Yr.create(2*n_gcm,2*n_gcm)
      Y0.create(n_gcm,n_gcm)

      .REL:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      R.destroy

      ! lets find the transforation matrix
      Yr = (ZERO,ZERO)
      Yr.alpha_alpha_plus(Y0)
      Yr.beta_beta_plus(Y0)
      Y0.destroy

      .REL:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)

      PAP.destroy
      A2.destroy

      O.create(2*n_gcm,2*n_gcm)
      Ox.create(2*n_gcm,2*n_gcm)
      Ox= (ZERO,ZERO)
      do i=1,2*n_gcm
         Ox(i,i)=ONE
      end do
      O.to_product_of(Yr,Yr,dagger_a=TRUE)
      Ox = Ox + O

      ! make ready the preconditioning
      UN.create(2*n_gcm)
      do i=1,2*n_gcm
         UN(i)=ONE/sqrt(real(Ox(i,i)))
      end

      do i=1,2*n_gcm
      do j=1,2*n_gcm
         Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
      end

      eps=TOL(15)
      O.to_power_series_inv_sqrt_of(Ox,eps)
      do i=1,2*n_gcm
      do j=1,2*n_gcm
         O(i,j) = O(i,j)*UN(j)
      end
      end

      UN.destroy
      Ox.destroy

      GG22.create(2*n_gcm,2*n_gcm)
      grid=ZERO
      parallel do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .:make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

         g = ZERO

         do i=1,2*.n_bf
         do j=1,2*.n_bf
            g = g + REALIFY(conjg(MO(i))*GG22(i,j)*MO(j))
         end
         end

         grid(n)= g

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

      S.destroy
      O.destroy
      Yr.destroy
      GG22.destroy
      YU.destroy
      Ap.destroy
      E.destroy
      bp.destroy
      ep.destroy
      p.destroy
      m_out.destroy

   end

   make_DENSITY_IOTC_PCE_SO_off(GG,Yr,YU,Ap,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O) ::: private
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG :: MAT{CPX}, OUT
      Yr :: MAT{CPX}, IN
      YU :: MAT{REAL} , IN
      Ap,bp,p :: VEC{REAL} , IN
      ep :: VEC{REAL}
      xx,yy,zz :: REAL , IN
      m_out :: MAT{INT} , IN
      n_gcm :: INT , IN
      S :: MAT{REAL} , IN
      O :: MAT{CPX}

      II :: CPX
      fac :: REAL
      i,j :: INT
      F,A2,B2,M2,buco,PAP,ppApp :: MAT{CPX}*
      R :: MAT{REAL}*
      D,PDP,SOx,SOy,SOz,PPDPP :: MAT{REAL}*
      A,B,M :: MAT{REAL}*

      ep = ep

      !!!  the density X operator !!!
      R.create(.n_prim,.n_prim)
      D.create(n_gcm,n_gcm)
      .REL:make_primitive_density_matrix(D,xx,yy,zz)

      A.create(n_gcm,n_gcm)
      A=ZERO
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)
 !!!  the density PXP operator !!!
      PDP.create(n_gcm,n_gcm)
      PDP=ZERO
      .REL:make_primitive_pDp_matrix(PDP,xx,yy,zz)
      A=ZERO
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)
 !!!  SO MATRICES  !!!
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
       SOx=ZERO; SOy=ZERO; SOz=ZERO
      .REL:make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz)
      A=ZERO
      A.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(A,YU)
      A=ZERO
      A.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(A,YU)
      A=ZERO
      A.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(A,YU)

 !!! A-O LETS GO !!!

      A=ZERO

      do i=1,n_gcm
        do j=1,n_gcm

         D(i,j) = Ap(i)*D(i,j)*Ap(j)
         PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

        end
      end

      if(.scfdata.using_ppzpp)then
        PPDPP.create(n_gcm,n_gcm)
        PPDPP=ZERO
        .REL:make_primitive_ppDpp_matrix(PPDPP,xx,yy,zz)
        .REL:get_da_gcm_now(R,PPDPP,m_out)
        A=ZERO
        A.to_product_of(YU,PPDPP,transpose_a=TRUE)
        PPDPP.to_product_of(A,YU)

         do i=1,n_gcm
           do j=1,n_gcm
             PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j)
           end do
         end do
       end if
     A.destroy

    A2.create(2*n_gcm,2*n_gcm)
    A2=(ZERO,ZERO)
      A2.alpha_alpha_plus(D)
      A2.beta_beta_plus(D)
 !   A.make_hermitian
     .BASE:put_debug(A2,"A matrix")
    PAP.create(2*n_gcm,2*n_gcm)
    PAP=(ZERO,ZERO)
      PAP.alpha_alpha_plus(PDP)
      PAP.beta_beta_plus(PDP)
      II = (ZERO,ONE)
      fac= ONE
       PAP.beta_alpha_plus(SOx,fac*II)
       PAP.beta_alpha_plus(SOy,-fac)
       PAP.alpha_alpha_plus(SOz,fac*II)
       PAP.beta_beta_plus(SOz,-fac*II)
    PAP.make_hermitian
     .BASE:put_debug(PAP,"PAP matrix")
    if( .scfdata.using_ppzpp)then
    ppApp.create(2*n_gcm,2*n_gcm)
    ppApp=(ZERO,ZERO)
      ppApp.alpha_alpha_plus(PPDPP)
      ppApp.beta_beta_plus(PPDPP)
 !  ppApp.make_hermitian
     .BASE:put_debug(ppApp,"ppApp matrix")
      PPDPP.destroy
    end if
      D.destroy
      PDP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      R.destroy

      ! the hamiltonian is gonna be built
      F.create(2*n_gcm,2*n_gcm)
      if (.scfdata.using_ppzpp) then; .:build_da_IOTC_dens(F,Yr,PAP,A2,p,bp,ppApp)
      else;                           .:build_da_IOTC_dens(F,Yr,PAP,A2,p,bp)
      end if

      PAP.destroy
      if( .scfdata.using_ppzpp)then
        ppApp.destroy
      end if

      A2=(ZERO,ZERO)
      ! normalization
      A2.to_product_of(F,O)
      F.to_product_of(O,A2,dagger_a=TRUE)

      ! back to cartesian basis set
      B2.create(2*n_gcm,2*n_gcm)
      B.create(n_gcm,n_gcm)

      B.to_product_of(S,YU)

      B2=(ZERO,ZERO)
      B2.alpha_alpha_plus(B)
      B2.beta_beta_plus(B)
      B.destroy

      A2.to_product_of(B2,F)
      F.to_product_of(A2,B2,dagger_b=TRUE)

      B2.destroy

      !!! moving back to contracted basis sets
      M.create(.n_prim,.n_bf)

      .BASE:make_normalised_contraction_mx(M)

      M2.create(2*.n_prim,2*.n_prim)
      M2 = (ZERO,ZERO)
      M2.alpha_alpha_plus(M)
      M2.beta_beta_plus(M)

      buco.create(2*.n_prim,2*.n_prim)
      buco.to_product_of(M2,F,dagger_a=TRUE)
      A2.to_product_of(buco,M2)

      M.destroy
      F.destroy
      M2.destroy
      buco.destroy

      GG = A2

      A2.destroy

      .BASE:put_debug(GG,"GG matrix")

   end

   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,ppApp) ::: private
   ! build the IOTC Y matrix, general complex version
      self :: IN
      F :: MAT{CPX}, OUT
      Yr,PAP,A :: MAT{CPX}, IN
      p,bp :: VEC{REAL}, IN
      ppApp :: MAT{CPX}, optional, IN

      i,j,n_gcm,dim :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{CPX}*

      n_gcm=.n_prim
      c = SPEED_OF_LIGHT_AU
      alpha = ONE/c
      alpha2= alpha*alpha

      dim = 2*n_gcm

      F1L.create(dim,dim)
      F1R.create(dim,dim)
       F2.create(dim,dim)
      AAA.create(dim,dim)

      if (.scfdata.using_ppzpp) then

         do i = 1,dim
         do j = 1,dim
            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
         end do
         end do

      else

         do i = 1,dim
         do j = 1,dim
            AAA(i,j) = alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do

      end

      do i = 1,dim
      do j = 1,dim
          F(i,j)  =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
          F2(i,j) =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
      end do
      end do

      F2.change_basis_using(Yr)

      F.plus_product_of( Yr,F1L,dagger_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)

      ! Remove matmuls
    ! AAA.to_product_of(Yr,F1L,dagger_a=TRUE)
    ! F=F+AAA+matmul(F1R,Yr)
    ! AAA.to_product_of(Yr,F2,dagger_a=TRUE)
    ! F=F+matmul(AAA,Yr)

      AAA.destroy
      F1L.destroy
      F1R.destroy
      F2.destroy

   end

!  ==================
!  Nabla orbital grid
!  ==================

   make_nabla_orbital_grid(grid1,grid0,orb,pt) ::: template
   ! Evaluate the nabla orbital density "grid1" as well as the orbital
   ! density "grid0" for *one* AO-basis orbital vector "orb" on a set
   ! of grid points "pt"
      grid1 :: MAT{TYPE?}
      grid0 :: VEC{TYPE?}
      orb :: VEC{TYPE?}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,"no atom list")
   ENSURE(grid1.dim1==pt.dim1,"grid1, wrong 1st dimension")
   ENSURE(grid1.dim2==3,      "grid1, wrong 2nd dimension")
   ENSURE(grid0.dim==pt.dim1, "grid0, wrong size")

      orb_a :: VEC{TYPE?}*
      sh :: SHELL1
      sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      grid1 = ZERO
      grid0 = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)

         sh.make_nabla_grid(sh_grid1,sh_grid0,pt)

         orb_a => orb(fa:la)
         grid1(:,1).plus_product_of(sh_grid1(:,:,1),orb_a)
         grid1(:,2).plus_product_of(sh_grid1(:,:,2),orb_a)
         grid1(:,3).plus_product_of(sh_grid1(:,:,3),orb_a)
         grid0.plus_product_of(sh_grid0,orb_a)

         sh_grid0.destroy
         sh_grid1.destroy
         sh.destroy_ptr_part

      end

   end

   make_nabla_orbital_grid_r(grid1,grid0,orb,pt) ::: get_from(make_nabla_orbital_grid, TYPE?=>REAL)
   ! Evaluate the nabla orbital density "grid1" as well as the orbital
   ! density "grid0" for *one* AO-basis orbital vector "orb" on a set
   ! of grid points "pt"
   end

   make_nabla_orbital_grid_c(grid1,grid0,orb,pt) ::: get_from(make_nabla_orbital_grid, TYPE?=>CPX)
   ! Evaluate the nabla orbital density "grid1" as well as the orbital
   ! density "grid0" for *one* AO-basis orbital vector "orb" on a set
   ! of grid points "pt"
   end

!  ==================
!  Nabla density grid
!  ==================

!   make_nabla_density_grid_fdm_r(nabla_grid,pts)
!   ! Work out the nabla density on ".plot_grid" using ".natural orbitals" and the
!   ! ".occupation" number vector.
!   ! This method uses the finite difference method to calculate the gradient
!   ! from the density.  It is much slower, but useful for checking.
!     nabla_grid, pts :: MAT{REAL}
!   ENSURE(pts.dim2==3,  "wrong dimension for points array")
!   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
!   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")
!     orb :: VEC{REAL}*
!     dens_1,dens_2,nabla_orb,comp :: VEC{REAL}*
!     pt1 :: MAT{REAL}*
!     alpha :: REAL
!     n_occ,n,n_pts,i :: INT
!     alpha = TOL(6)
!     n_pts = size(pts,1)
!     pt1.create(n_pts,3)
!     nabla_grid = ZERO
!     orb.create(n_pts)
!     dens_1.create(n_pts)
!     dens_2.create(n_pts)
!     nabla_orb.create(n_pts)
!     n_occ = .BASE:no_of_occupied_NOs
!     do n = 1,n_occ
!        do i = 1,3
!          comp => pt1(:,i)
!          pt1 = pts;    comp = comp + alpha
!          .:make_orbital_grid_r(dens_1,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          pt1 = pts;    comp = comp - alpha
!          .:make_orbital_grid_r(dens_2,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          nabla_orb = HALF/alpha * (dens_1 - dens_2)
!          .:make_orbital_grid_r(orb,.natural_orbitals.restricted(:,n), pts)
!          nabla_grid(:,i) = nabla_grid(:,i) + .occupation_numbers.restricted(n)*orb(:)*nabla_orb
!        end
!     end
!     nabla_grid = TWO*nabla_grid
!     nabla_orb.destroy
!     dens_2.destroy
!     dens_1.destroy
!     orb.destroy
!     pt1.destroy
!   end

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.natural_orbitals.number_kind)=="real") then
         .:make_nabla_density_grid_r(nabla_grid,pts)
      else
         DIE("not implemented")
      end

   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid, evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.natural_orbitals.number_kind)=="real") then
         .:make_nabla_density_grid_r(nabla_grid,grid,pts)
      else
         DIE("not implemented")
      end

   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = pts.dim1
      n_occ = .BASE:no_of_occupied_NOs

      nabla_grid = ZERO

      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      do n = 1,n_occ

         .:make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)

         occ = .occupation_numbers.restricted(n)

         nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
         nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
         nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)

      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = pts.dim1
      n_occ = .BASE:no_of_occupied_NOs

      nabla_grid = ZERO
      grid = ZERO

      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      do n = 1,n_occ

         .:make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)

         occ = .occupation_numbers.restricted(n)

         nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
         nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
         nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
         grid(:)         = grid(:)         + occ*orb(:)*orb(:)

      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

!  ======================
!  Laplacian orbital grid
!  ======================

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      self :: INOUT
      g,h :: MAT{REAL}, OUT 
      i :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid1,sh_grid2 :: MAT3{REAL}*
      sh_grid3 :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO
      i = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid2.create(n_pt,na,3)
         sh_grid3.create(n_pt,na)

         sh.make_laplacian_grid(sh_grid1,sh_grid2,sh_grid3,pt)

         g(:,1).plus_product_of(sh_grid1(:,:,1),orb(fa:la))
         g(:,2).plus_product_of(sh_grid1(:,:,2),orb(fa:la))
         g(:,3).plus_product_of(sh_grid1(:,:,3),orb(fa:la))
         h(:,1).plus_product_of(sh_grid2(:,:,1),orb(fa:la))
         h(:,2).plus_product_of(sh_grid2(:,:,2),orb(fa:la))
         h(:,3).plus_product_of(sh_grid2(:,:,3),orb(fa:la))
              i.plus_product_of(sh_grid3,       orb(fa:la))

         sh_grid3.destroy
         sh_grid2.destroy
         sh_grid1.destroy
         sh.destroy_ptr_part

      end

   end

   make_laplacian_orbital_grid_c(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{CPX}
      i :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid1,sh_grid2 :: MAT3{REAL}*
      sh_grid3 :: MAT{REAL}*
      orb_a :: VEC{CPX}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO
      i = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid2.create(n_pt,na,3)
         sh_grid3.create(n_pt,na)

         sh.make_laplacian_grid(sh_grid1,sh_grid2,sh_grid3,pt)

         orb_a => orb(fa:la)
         g(:,1).plus_product_of(sh_grid1(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid1(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid1(:,:,3),orb_a)
         h(:,1).plus_product_of(sh_grid2(:,:,1),orb_a)
         h(:,2).plus_product_of(sh_grid2(:,:,2),orb_a)
         h(:,3).plus_product_of(sh_grid2(:,:,3),orb_a)
              i.plus_product_of(sh_grid3,       orb_a)

         sh_grid3.destroy
         sh_grid2.destroy
         sh_grid1.destroy
         sh.destroy_ptr_part

      end

   end

! IOTC LAPLACIAN STUFF

   get_x_negative_laplacian_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.associated, "no grid")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      stdout.flush
      stdout.text("Negative laplacian from get_x_negative_laplacian_grid")
      stdout.flush
      .:make_xx_laplacian_grid(grid,pt)
      grid=-grid
      .:dump_plot_grid(grid,"negative_laplacian_grid")
      pt.destroy
      grid.destroy
   end

   get_x_laplacian_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.associated, "no grid")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      stdout.flush
      stdout.text("Laplacian from get_x_laplacian_grid")
      stdout.flush
      .:make_xx_laplacian_grid(grid,pt)
      .:dump_plot_grid(grid,"laplacian_grid")
      pt.destroy
      grid.destroy
   end

   make_xx_laplacian_grid(grid,pt)
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
   !
  grid :: VEC{REAL}
  pt :: MAT{REAL}
  MO,MOa,MOb :: MAT{REAL}*
  CMO :: MAT{CPX}*
  D,Da,Db :: MAT{REAL}*
  CD :: MAT{CPX}*
  nx :: INT

      grid=ZERO

      select case (.scfdata.scf_kind)
        case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
           ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
           ENSURE(.spin_multiplicity==1,"this is not a singlet state")
              MO => .molecular_orbitals.restricted(:,1:.n_a)
              D  => .density_matrix.restricted
              D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
              if (NOT .scfdata.PCE_CORR) then
               .:make_xx_laplacian_grid_r(grid,pt,D)
             else
               nx=1   ! PCE corr for LAPLACIAN, I am using the Density routine in the 1st step, 'cause it is da same
               .:density_IOTC_r(grid,pt,D,nx)
            end if
           case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")
              MOa => .molecular_orbitals.alpha(:,1:.n_a)
              MOb => .molecular_orbitals.beta(:,1:.n_b)
              Da => .density_matrix.alpha
              Db => .density_matrix.beta
              Da.to_product_of(MOa,MOa,transpose_b=TRUE)
              Db.to_product_of(MOb,MOb,transpose_b=TRUE)
              D.create(.n_bf,.n_bf)
              D=Da+Db
             if (NOT .scfdata.PCE_CORR) then
              .:make_xx_laplacian_grid_r(grid,pt,D)
             else
              nx=1   ! PCE corr for LAPLACIAN, I am using the Density routine in the 1st step, 'cause it is da same
              .:density_IOTC_r(grid,pt,D,nx)
            end if
             D.destroy
       case ("gchf","xray_gchf")
         ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")
         CD => .density_matrix.general_complex
         CMO => .molecular_orbitals.general_complex(:,1:.n_e)
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
         if (NOT .scfdata.PCE_CORR) then
           .:make_xx_laplacian_grid_gc(grid,pt,CD)
             else
              nx=1   ! PCE corr for LAPLACIAN, I am using the Density routine in the 1st step, 'cause it is da same
              .:density_IOTC_gc(grid,pt,CD,nx)
         end if
        case default
           DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))
        end
   end

   make_xx_laplacian_grid_r(grid,pt,D)
   ! make the PCE corrected structure factors
   !
       grid :: VEC{REAL}
       pt :: MAT{REAL}
       D :: MAT{REAL}
       n_gcm :: INT
       n,i,j,k_max :: INT
       g :: REAL
   !    c :: REAL
   !    xx,yy,zz :: REAL
        m_out :: MAT{INT}*
!       GG,ft_hkl,pftp_hkl,buco :: MAT{REAL}*
       GG,pgpg,p2gg,gp2g,buco :: MAT{REAL}*
       MM,YU,S,R,Z,PZP :: MAT{REAL}*
   !    M :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*

      k_max = size(pt,1)

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO
      .REL:get_da_gcm_now(R,S,m_out)
      R.destroy

     MM.create(.n_prim,.n_bf)
     .BASE:make_normalised_contraction_mx(MM)
!    MM.create(.n_prim,.n_bf)
!    MM=M
!    M.destroy

     pgpg.create(.n_bf,.n_bf)
     p2gg.create(.n_bf,.n_bf)
     gp2g.create(.n_bf,.n_bf)
     GG.create(.n_prim,.n_prim)
     buco.create(.n_bf,.n_prim)
!     pftp_hkl.create(.n_prim,.n_prim)
     do n = 1,k_max
        pgpg=ZERO
        p2gg=ZERO
        GG=ZERO
        buco=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to its non-relativistic/NOs
! counterpart is really not effective :(
       .REL:make_primitive_pgpg_matrix(GG,pt(n,1),pt(n,2),pt(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)
       pgpg.to_product_of(buco,MM)
       buco=ZERO
       GG=ZERO
       .REL:make_primitive_p2gg_matrix(GG,pt(n,1),pt(n,2),pt(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)
       p2gg.to_product_of(buco,MM)
       buco=ZERO
       GG=ZERO
       .REL:make_primitive_gp2g_matrix(GG,pt(n,1),pt(n,2),pt(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)
       gp2g.to_product_of(buco,MM)

        g=ZERO

        do i=1,.n_bf
           do j=1,.n_bf
               g = g + (TWO*pgpg(i,j)+p2gg(i,j)+gp2g(i,j))*D(j,i)  
               !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
           end do
        end do

      !then it seems to work what nos routines laplacian does
      ! g=g/TWO

      grid(n)=g

     end do
     MM.destroy
     buco.destroy

     .BASE:put_debug(grid,"laplacian grid from mx not nos")

       S.destroy
       Z.destroy
       PZP.destroy
       GG.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
!       c2P.destroy
!       PP.destroy
       m_out.destroy
       pgpg.destroy
       p2gg.destroy
       gp2g.destroy

   end

   make_xx_laplacian_grid_gc(grid,pt,D)
   ! make the PCE corrected structure factors
   !
       grid :: VEC{REAL}
       pt :: MAT{REAL}
       D :: MAT{CPX}
       n_gcm :: INT
       n,i,j,k_max :: INT
       g :: CPX
       m_out :: MAT{INT}*
!       GG,ft_hkl,pftp_hkl,buco :: MAT{REAL}*
       GG,GG22,pgpg,p2gg,gp2g,buco :: MAT{REAL}*
       MM,YU,S,R,Z,PZP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*

      k_max = size(pt,1)

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO
      .REL:get_da_gcm_now(R,S,m_out)
      R.destroy

     MM.create(.n_prim,.n_bf)
     .BASE:make_normalised_contraction_mx(MM)
!    MM.create(.n_prim,.n_bf)
!    MM=M
!    M.destroy

     pgpg.create(.n_bf,.n_bf)
     p2gg.create(.n_bf,.n_bf)
     gp2g.create(.n_bf,.n_bf)
     GG.create(.n_prim,.n_prim)
     GG22.create(2*.n_bf,2*.n_bf)
     buco.create(.n_bf,.n_prim)
!     pftp_hkl.create(.n_prim,.n_prim)
     do n = 1,k_max
        pgpg=ZERO
        p2gg=ZERO
        GG=ZERO
        GG22=ZERO
        buco=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to its non-relativistic/NOs
! counterpart is really not effective :(
       .REL:make_primitive_pgpg_matrix(GG,pt(n,1),pt(n,2),pt(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)
       pgpg.to_product_of(buco,MM)
       buco=ZERO
       GG=ZERO
       .REL:make_primitive_p2gg_matrix(GG,pt(n,1),pt(n,2),pt(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)
       p2gg.to_product_of(buco,MM)
       buco=ZERO
       GG=ZERO
       .REL:make_primitive_gp2g_matrix(GG,pt(n,1),pt(n,2),pt(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)
       gp2g.to_product_of(buco,MM)


       do i=1,.n_bf
           do j=1,.n_bf
               !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
               GG22(i,j) = (TWO*pgpg(i,j)+p2gg(i,j)+gp2g(i,j))  
               GG22(i+.n_bf,j+.n_bf) = (TWO*pgpg(i,j)+p2gg(i,j)+gp2g(i,j))
           end do
       end do

       g=(ZERO,ZERO)

       do i=1,2*.n_bf
           do j=1,2*.n_bf
            ! g = g + (TWO*pgpg(i,j)+p2gg(i,j)+gp2g(i,j))*D(j,i)  
              !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
              g = g + D(j,i)*GG22(i,j)
           end do
       end do

      !then it seems to work what nos routines laplacian does
      ! g=g/TWO ! this seems rubbish

      !stdout.put(g)
      !stdout.flush

      grid(n)=real(g)

     end do
     MM.destroy
     buco.destroy

     .BASE:put_debug(grid,"laplacian grid from mx not nos")

       S.destroy
       Z.destroy
       PZP.destroy
       GG.destroy
       GG22.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
!       c2P.destroy
!       PP.destroy
       m_out.destroy
       pgpg.destroy
       p2gg.destroy
       gp2g.destroy

   end

   make_LAPLACIAN_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,xx,yy,zz,m_out,n_gcm,S,O)
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine
        GG :: MAT{REAL} , OUT
        Yr,YU :: MAT{REAL} , IN
        Ap,bp,p :: VEC{REAL} , IN
        xx,yy,zz :: REAL , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S,O :: MAT{REAL} , IN

     !   c :: REAL
        i,j :: INT
        R :: MAT{REAL}*
        D,DI,PDP :: MAT{REAL}*
     !   Rx,Ry,Rz :: MAT{REAL}*
        A,B :: MAT{REAL}*
        M,buco :: MAT{REAL}*

!!!  the laplacian part pgpg
     R.create(.n_prim,.n_prim)
     R=ZERO
     ! this routine is exatlich the same as pDp one, sorry for that
     .REL:make_primitive_pgpg_matrix(R,xx,yy,zz)
     D.create(n_gcm,n_gcm)
     D=ZERO
     .REL:get_da_gcm_now(R,D,m_out)
     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)
     D=TWO*D

!!!  the laplacian part p2gg
     DI.create(n_gcm,n_gcm)
     DI=ZERO
     R=ZERO
     .REL:make_primitive_p2gg_matrix(R,xx,yy,zz)
     .REL:get_da_gcm_now(R,DI,m_out)
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     D=DI+D

!!!  the laplacian part gp2g
     DI=ZERO
     R=ZERO
     .REL:make_primitive_gp2g_matrix(R,xx,yy,zz)
     .REL:get_da_gcm_now(R,DI,m_out)
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     D=DI+D

!!!  PDP MATRIX  !!!
!!!  the laplacian part ppggpp the same as ppDpp
      R=ZERO
     .REL:make_primitive_ppDpp_matrix(R,xx,yy,zz)
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     .REL:get_da_gcm_now(R,PDP,m_out)
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
     PDP=TWO*PDP

!!!  the laplacian part pppDp
     DI=ZERO
     R=ZERO
     .REL:make_primitive_pppDp_matrix(R,xx,yy,zz)
     .REL:get_da_gcm_now(R,DI,m_out)
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     PDP=DI+PDP

!!!  the laplacian part pDppp
     DI=ZERO
     R=ZERO
     .REL:make_primitive_pDppp_matrix(R,xx,yy,zz)
     .REL:get_da_gcm_now(R,DI,m_out)
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     PDP=DI+PDP

     DI.destroy

!!! A-O LETS GO !!!

     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)

       end
     end

     B.create(n_gcm,n_gcm)
     B=ZERO
     .:build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm)

     D=ZERO
     D=matmul(O,matmul(B,O))

     PDP.destroy

     B=ZERO
     B.to_product_of(S,YU)

     A=ZERO
     A.to_product_of(B,D)
     D.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .REL:get_back_prim_now(D,R,m_out)
     D.destroy

!!! moving back to contracted basis sets
     M.create(.n_prim,.n_bf)
     .BASE:make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy

     GG.to_product_of(buco,M)

     M.destroy
     buco.destroy
   end

   make_LAPLACIAN_IOTC_PCE_SO_off(GG,Yr,YU,Ap,bp,p,xx,yy,zz,n_gcm,S,O)
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine

        GG,Yr :: MAT{CPX}
        YU :: MAT{REAL} , IN
        Ap,bp,p :: VEC{REAL} , IN
        xx,yy,zz :: REAL , IN
        n_gcm :: INT , IN
        S :: MAT{REAL} , IN
        O :: MAT{CPX}

        II :: CPX
        fac,c :: REAL
        i,j :: INT
        F,A2,B2,M2,buco,PAP :: MAT{CPX}*
        D,PDP,SOx,SOy,SOz,DI,DIx,DIy,DIz :: MAT{REAL}*
     !   WW,W2,TX,Z,PZP,X :: MAT{REAL}*
        A,B,M :: MAT{REAL}*

!!!  the density pgpg operator !!!
     D.create(n_gcm,n_gcm)
     D=ZERO
     A.create(n_gcm,n_gcm)
     A=ZERO
     .REL:make_primitive_pDp_matrix(D,xx,yy,zz)
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)
     D=TWO*D

     DI.create(n_gcm,n_gcm)
     DI=ZERO
!!!  the density ppgg operator !!!
     .REL:make_primitive_p2gg_matrix(DI,xx,yy,zz)
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     D=D+DI

     DI=ZERO
!!!  the density ppgg operator !!!
     .REL:make_primitive_gp2g_matrix(DI,xx,yy,zz)
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     D=D+DI

!!!  the density PPXPP operator !!!
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     .REL:make_primitive_ppDpp_matrix(PDP,xx,yy,zz)
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
!!!  SO MATRICES  !!!
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
      SOx=ZERO; SOy=ZERO; SOz=ZERO
     .REL:make_primitive_ppDpp_SO_matrix(SOx,SOy,SOz,xx,yy,zz)
     A=ZERO
     A.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,YU)
     ! times 2
     PDP=TWO*PDP; SOx=TWO*SOx; SOy=TWO*SOy; SOz=TWO*SOz

     DIx.create(n_gcm,n_gcm)
     DIy.create(n_gcm,n_gcm)
     DIz.create(n_gcm,n_gcm)
!!! the PPPXP part + SO
     DI=ZERO; DIx=ZERO; DIy=ZERO; DIz=ZERO
     .REL:make_primitive_pppDp_matrix(DI,xx,yy,zz)
     .REL:make_primitive_pppDp_SO_matrix(DIx,DIy,DIz,xx,yy,zz)
     A=ZERO
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,DIx,transpose_a=TRUE)
     DIx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,DIy,transpose_a=TRUE)
     DIy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,DIz,transpose_a=TRUE)
     DIz.to_product_of(A,YU)
     PDP=PDP+DI;SOx=SOx+DIx;SOy=SOy+DIy;SOz=SOz+DIz

!!! the PXPPP part + SO
     DI=ZERO; DIx=ZERO; DIy=ZERO; DIz=ZERO
     .REL:make_primitive_pDppp_matrix(DI,xx,yy,zz)
     .REL:make_primitive_pDppp_SO_matrix(DIx,DIy,DIz,xx,yy,zz)
     A=ZERO
     A.to_product_of(YU,DI,transpose_a=TRUE)
     DI.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,DIx,transpose_a=TRUE)
     DIx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,DIy,transpose_a=TRUE)
     DIy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,DIz,transpose_a=TRUE)
     DIz.to_product_of(A,YU)
     PDP=PDP+DI;SOx=SOx+DIx;SOy=SOy+DIy;SOz=SOz+DIz

     DI.destroy;DIx.destroy;DIy.destroy;DIz.destroy

!!! A-O LETS GO !!!

!     B.create(n_gcm,n_gcm)
     A=ZERO
!     B=ZERO

     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

    A.destroy

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(D)
     A2.beta_beta_plus(D)
!   A.make_hermitian
    .BASE:put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PDP)
     PAP.beta_beta_plus(PDP)
     II = (ZERO,ONE)
     fac= ONE
     PAP.beta_alpha_plus(SOx,fac*II)
     PAP.beta_alpha_plus(SOy,-fac)
     PAP.alpha_alpha_plus(SOz,fac*II)
     PAP.beta_beta_plus(SOz,-fac*II)
     PAP.make_hermitian
     .BASE:put_debug(PAP,"PAP matrix")
     D.destroy
     PDP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
!     R.destroy

     F.create(2*n_gcm,2*n_gcm)
     F=(ZERO,ZERO)
! the hamiltonian is gonna be built
     .:build_da_IOTC_dens(F,Yr,PAP,A2,p,bp)
     .BASE:put_debug(F,"F matrix")

     PAP.destroy

     A2=(ZERO,ZERO)
     ! normalization
     A2.to_product_of(F,O)
     F.to_product_of(O,A2,dagger_a=TRUE)

! back to cartesian basis set
     B.create(n_gcm,n_gcm)
     B.to_product_of(S,YU)
     B2.create(2*n_gcm,2*n_gcm)
     B2=(ZERO,ZERO)
     B2.alpha_alpha_plus(B)
     B2.beta_beta_plus(B)
     B.destroy

     A2=(ZERO,ZERO)
     A2.to_product_of(B2,F)
     F.to_product_of(A2,B2,dagger_b=TRUE)
    .BASE:put_debug(F,"U+YOFOYU matrix")

     B2.destroy

     A2=(ZERO,ZERO)

!!! moving back to contracted basis sets
     M.create(.n_prim,.n_bf)
     M=ZERO
    .BASE:make_normalised_contraction_mx(M)
    .BASE:put_debug(M,"M matrix")
!     M2.create(2*.n_prim,2*.n_bf)
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
     .BASE:put_debug(M2,"M2 matrix")
     buco.create(2*.n_prim,2*.n_prim)
     buco=(ZERO,ZERO)
!     buco.to_product_of(M2,F,transpose_a=TRUE)
     buco.to_product_of(M2,F,dagger_a=TRUE)
     A2.to_product_of(buco,M2)
     .BASE:put_debug(A2,"MU+YOFOYUM matrix")
     M.destroy
     F.destroy
     M2.destroy
     buco.destroy

     GG = A2
     A2.destroy
     .BASE:put_debug(GG,"GG matrix")

   end

!  ==========================================
!  Fast memory-intensive electron density (?)
!  ==========================================

   make_fast_ED_grid_r(rho,pt,DM) ::: leaky
   ! Get the electron density grid "rho" of a list of 3D points "pt".
   ! Set "spin_density" to TRUE if you want those.
      self :: IN
      rho  :: VEC{REAL}
      pt   :: MAT{REAL}
      DM   :: MAT{REAL}

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")
   ENSURE(pt.dim1==rho.dim,"incompatible pt and rho arrays")
   ENSURE(pt.dim2==3,"wrong dim2 for pt array")
   ENSURE(DM.is_square,"DM is not square")
   ENSURE(DM.dim1==.n_bf,"DM is not square")

      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga,gb :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida,gridb :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac, val :: REAL
      n_pt,n_keep :: INT
      c,ca,cb :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb :: INT
      sa,fa,la,na, as :: INT
      sb,fb,lb,nb :: INT
      a,b,i,j,n,p :: INT

      ! Basis function cutoff
      ! Hard-coded! Make it an option ...
      cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF

      ! Max no of becke grid points per atom
      n_pt = pt.dim1

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Make the SF's
      rho = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.atom.dim

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Basis function grid and skip list
         ! Only for the shells overlapping atom "c"
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make the "sa" basis function grida
               grida.create(n_keep,na)
               sha.make_skip_grid(grida,n_keep,xa,ya,za,a2,skipa,n_pt)

               ! Store the "sa" basis function grida
               ! This saves calculation but is a memory hog.
               bf_grid(sa).element => grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.disassociated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element
                     gridb => bf_grid(sb).element

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga => grida(:,1)
                        gb => gridb(:,1)
                        Dab = fac*DM(fa,fb)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga => grida(:,a)
                           do b = 1,nb
                              gb  => gridb(:,b)
                              Dab = fac*DM(fa+a-1,fb+b-1)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                  end
               end
            end
         end

         ! Clean up atom "c" stuff
         bf_grid.destroy
         bf_skip.destroy

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(rho)
      end

   end

!  =========================
!  Electron density routines
!  =========================

   make_density_grid(density_grid,pt,sgn)
   ! Work out the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector. If "sgn" is present and equal to -1, the
   ! spin density is produced (provided alpha and beta natural orbitals are
   ! present).
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      relativity,okind :: STR

      okind = .natural_orbitals.spinorbital_kind

      relativity = "none"
      if (.scfdata.associated) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if

      select case (relativity)

         case ("douglas-kroll-hess","dkh")
            select case (okind)
               case ("restricted");       .:make_DKH_density_grid(density_grid,pt)
               case ("unrestricted");     .:make_DKH_density_grid(density_grid,pt,sgn)
               case ("general_complex");  .:make_DKH_density_grid(density_grid,pt)
               case default; WARN("Unimplemented orbital kind! Sorry :(")
            end

         case ("iotc")
            select case (okind)
               case ("restricted");       .:make_IOTC_density_grid(density_grid,pt)
               case ("unrestricted");     .:make_IOTC_density_grid(density_grid,pt,sgn)
               case ("general_complex");  .:make_IOTC_density_grid(density_grid,pt)
               case default; WARN("Unimplemented orbital kind! Sorry :(")
            end

         case ("none")
            select case (okind)
               case ("restricted");       .:make_density_grid_r(density_grid,pt)
               case ("unrestricted");     .:make_density_grid_u(density_grid,pt,sgn)
               case ("general");          .:make_density_grid_g(density_grid,pt,sgn)
               case ("general_complex");  .:make_density_grid_gc(density_grid,pt,sgn)
               case default;   DIE("unimplemented")
            end

         case default; DIE("unimplemented")

      end

   end

   make_density_grid(p_a,p_b,pt)
   ! Make the alpha and beta density grids, "p_a" and "p_b" respectively, from
   ! the unrestricted natural orbitals.
      p_a,p_b :: VEC{REAL}
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("unrestricted"),"no natural orbitals")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
   ENSURE(.occupation_numbers.is_associated_with_genre("unrestricted"),"no occupation numbers")

      NO :: MAT{REAL}*
      occ :: VEC{REAL}*

      NO  => .natural_orbitals.restricted ! backup pointers
      occ => .occupation_numbers.restricted

      .natural_orbitals.restricted   => .natural_orbitals.alpha
      .occupation_numbers.restricted => .occupation_numbers.alpha
      .:make_density_grid(p_a,pt)

      .natural_orbitals.restricted   => .natural_orbitals.beta
      .occupation_numbers.restricted => .occupation_numbers.beta
      .:make_density_grid(p_b,pt)

      .natural_orbitals.restricted   => NO ! restore backups
      .occupation_numbers.restricted => occ

   end

   make_density_grid_r(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      .:make_density_grid_r_v1(density_grid,pt)
    ! .:make_density_grid_r_v2(density_grid,pt)

   end

   make_density_grid_r_v1(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation numbers")

      NO :: VEC{REAL}*
      occ :: REAL
      n_occ,n :: INT

      n_occ = .BASE:no_of_occupied_NOs
      NO.create(pt.dim1)

      density_grid = ZERO

      parallel do n = 1,n_occ
         .:make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n), pt)
         occ = .occupation_numbers.restricted(n)
         density_grid = density_grid + occ*NO*NO
      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SUM(density_grid)
      end

      NO.destroy

   end

   make_density_grid_r_v2(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.density_matrix.is_associated_with_genre("restricted"), "no restricted density_matrix")

      .:make_fast_ED_grid_r(density_grid,pt,.density_matrix.restricted)

   end

   make_density_grid_u(density_grid,pt,sgn)
   ! Make the "density_grid" for the supplied points "pt" from unrestricted real
   ! natural orbitals. If present "sgn" is used to determine whether the total
   ! density or spin density is to be calculated: sgn=1 means sum the alpha and
   ! beta densities to form the total density, sgn=-1 means to subtract, forming
   ! the Sz spin density.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, IN, optional

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.alpha.associated, "no alpha occupation numbers")
   ENSURE(.occupation_numbers.beta.associated, "no beta occupation numbers")

      NO :: VEC{REAL}*
      occ,fac :: REAL
      na,nb,n :: INT

      fac = ONE
      if (present(sgn)) fac = REALIFY(sgn)

      na = .BASE:no_of_occupied_NOs("alpha")
      nb = .BASE:no_of_occupied_NOs("beta")

      NO.create(pt.dim1)

      density_grid = ZERO

      do n = 1,na
         .:make_orbital_grid_r(NO,.natural_orbitals.alpha(:,n),pt)
         occ = .occupation_numbers.alpha(n)
         density_grid = density_grid + occ*NO*NO
      end

      do n = 1,nb
         .:make_orbital_grid_r(NO,.natural_orbitals.beta(:,n),pt)
         occ = .occupation_numbers.beta(n)
         density_grid = density_grid + fac*occ*NO*NO
      end

      ! Clean
      NO.destroy

   end

   make_ku_density_grid_u(density_grid,pt,KP)
   ! Make the "spin density_grid" for the supplied points "pt" from
   ! general complex natural orbitals.
   ! Kramers unrestricted algorithm
      density_grid :: VEC{REAL}
      pt,KP :: MAT{REAL}
    ENSURE(pt.dim2==3,  "incorrect dimension for points array")
    ENSURE(.natural_orbitals.is_associated_with_genre("unrestricted"), "no natural orbitals")
    ENSURE(.occupation_numbers.alpha.associated, "no alpha occupation numbers")
    ENSURE(.occupation_numbers.beta.associated, "no beta occupation numbers")
      ga,gb,ggg :: VEC{REAL}*
      na,nb,i,j :: INT
      ona,onb :: REAL

      ! density_grid = ZERO
      ga.create(pt.dim1)
      gb.create(pt.dim1)
      ggg.create(pt.dim1)
      ggg= ZERO
      na = .BASE:no_of_occupied_NOs("alpha")
      nb = .BASE:no_of_occupied_NOs("beta")
       do i=1,na
         ga= ZERO
         ona= .occupation_numbers.alpha(i); ona=sqrt(ona)
         .:make_orbital_grid_r(ga,.natural_orbitals.alpha(:,i),pt)
         do j=1,nb
            gb= ZERO
            onb= .occupation_numbers.beta(j); onb=sqrt(onb)
            .:make_orbital_grid_r(gb,.natural_orbitals.beta(:,j),pt)

            ggg(:) = ggg(:) - & ! the K operator acts on beta hence
          ! the minus sign to get a positive number
                    ona * onb * ga(:) * gb(:) * KP(i,j)
          end
          stdout.put(i) ! orbital count
          stdout.flush
       end
      WARN(" This is the Kramers unrestricted uhf spin density! ")
      density_grid(:) = density_grid(:) - ggg(:)*TWO ! a or b - should not matter hence the TWO
      ga.destroy
      gb.destroy
      ggg.destroy
   end

   make_density_grid_c(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation numbers")

      NO :: VEC{CPX}*
      occ :: REAL
      n_occ,n :: INT

      n_occ = .BASE:no_of_occupied_NOs

      density_grid = ZERO

      NO.create(pt.dim1)
      do n = 1,n_occ
         .:make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n), pt)
         occ = .occupation_numbers.restricted(n)
         density_grid = density_grid + occ * RE(conjg(NO(:))*NO(:))
      end

      NO.destroy

   end

   make_density_grid_g(density_grid,pt,sgn)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("general"), "no natural orbitals")
   ENSURE(.occupation_numbers.is_associated_with_genre("general"), "no occupation numbers")

      gd,gu :: VEC{REAL}*
      n_occ,n :: INT
      occ :: REAL
      fac :: REAL

      n_occ = .BASE:no_of_occupied_NOs
      if (present(sgn)) then
         fac = sgn*ONE
         WARN(" This is the collinear 2-comp/gchf spin density, using sz! ")
      else
         fac = ONE
      end

      gu.create(pt.dim1)
      gd.create(pt.dim1)

      density_grid = ZERO
      do n = 1,n_occ
         .:make_orbital_grid_g(gu,gd,.natural_orbitals.general(:,n),pt)
         occ = .occupation_numbers.general(n)
         density_grid = density_grid  +  occ * (gu*gu + fac*gd*gd)
      end

      gd.destroy
      gu.destroy

   end

   make_density_grid_gc(density_grid,pt,sgn)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, optional

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("general_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.is_associated_with_genre("general"), "no occupation numbers")

      gd,gu :: VEC{CPX}*
      n_occ,n :: INT
      occ :: REAL
      fac :: REAL

      n_occ = .BASE:no_of_occupied_NOs
      if (present(sgn)) then
         fac = sgn*ONE
         WARN(" This is the collinear 2-comp/gchf spin density, using sz! ")
      else
         fac = ONE
      end

      gu.create(pt.dim1)
      gd.create(pt.dim1)

      density_grid = ZERO
      do n = 1,n_occ
         .:make_orbital_grid_gc(gu,gd,.natural_orbitals.general_complex(:,n),pt)
         occ = .occupation_numbers.general(n)
         density_grid = density_grid  +  occ * REALIFY(fac*conjg(gd)*gd + conjg(gu)*gu)
      end

      gd.destroy
      gu.destroy

   end

   make_nc_density_grid_gc(density_grid,pt)
   ! Make the noncollinear spin density_grid for the supplied points "pt" from
   ! general complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("general_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.is_associated_with_genre("general"), "no occupation numbers")

      gd,gu,ggg,gtemp :: VEC{CPX}*
      n_occ,n :: INT
      occ :: REAL

      n_occ = .BASE:no_of_occupied_NOs

      gu.create(pt.dim1)
      gd.create(pt.dim1)
      ggg.create(pt.dim1)
      gtemp.create(pt.dim1)

      density_grid = ZERO
      ggg = (ZERO,ZERO)
      gtemp = (ZERO,ZERO)
      do n = 1,n_occ
        occ= .occupation_numbers.general(n)
         .:make_orbital_grid_gc(gu,gd,.natural_orbitals.general_complex(:,n),pt)
         gtemp(:)= gtemp(:) + occ*conjg(gu(:))*gd(:)
         ggg(:) = ggg(:) &
                - occ*conjg(gd(:))*gd(:) + occ*conjg(gu(:))*gu(:)
      end
      ggg(:) = ggg(:)**2 + FOUR*gtemp(:)*conjg(gtemp(:))
      gtemp.destroy
      WARN(" Non-collinear 2-comp/gchf spin density, using the length of sigma! ")
      density_grid(:)= real(ggg(:))
      density_grid(:)= sqrt(density_grid(:))

      gtemp.destroy
      ggg.destroy
      gd.destroy
      gu.destroy

   end

   make_ku_density_grid_gc(density_grid,pt,KP)
   ! Make the "spin density_grid" for the supplied points "pt" from
   ! general complex natural orbitals.
   ! Kramers unrestricted algorithm
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      KP :: MAT{CPX}
   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.is_associated_with_genre("general_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.is_associated_with_genre("general"), "no occupation numbers")
      gdi,gui,gdj,guj,ggg,gtemp :: VEC{CPX}*
      n_occ,i,j :: INT
      oni,onj :: REAL

      gui.create(pt.dim1)
      gdi.create(pt.dim1)
      guj.create(pt.dim1)
      gdj.create(pt.dim1)
      ggg.create(pt.dim1)
      gtemp.create(pt.dim1)
      ggg= (ZERO,ZERO)
      gtemp= (ZERO,ZERO)
      n_occ = .BASE:no_of_occupied_NOs
       do i=1,n_occ
         gui= (ZERO,ZERO)
         gdi= (ZERO,ZERO)
         oni= .occupation_numbers.general(i); oni=sqrt(oni)
         .:make_orbital_grid_gc(gui,gdi,.natural_orbitals.general_complex(:,i),pt)
         do j=1,n_occ
            guj= (ZERO,ZERO)
            gdj= (ZERO,ZERO)
            onj= .occupation_numbers.general(j); onj=sqrt(onj)
            .:make_orbital_grid_gc(guj,gdj,.natural_orbitals.general_complex(:,j),pt)

            gtemp(:)=(ZERO,ZERO)
            gtemp(:) = &
                    oni*onj*(conjg(guj(:))*conjg(gdi(:)) - conjg(gdj(:))*conjg(gui(:)))*conjg(KP(j,i))
             ggg(:) = ggg(:) + gtemp(:)

          end
          stdout.put(i)
          stdout.flush
       end
      WARN(" This is the Kramers unrestricted 2-comp/gchf spin density! ")
      density_grid(:) = density_grid(:) - real(ggg(:))
      gdi.destroy
      gui.destroy
      gdj.destroy
      guj.destroy
      ggg.destroy
      gtemp.destroy
   end

   make_density_grid_r(density_grid,pt,NO,occ)
   ! Make the "density_grid" for the supplied points "pt" from the
   ! natural orbitals "NO" and occupuation numbers "occ".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      NO  :: MAT{REAL}
      occ :: VEC{REAL}

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      NOn  :: VEC{REAL}*
      n  :: INT

      NOn.create(pt.dim1)

      density_grid = ZERO

      do n = 1,NO.dim2

         if (occ(n)==ZERO) cycle

         .:make_orbital_grid_r(NOn,NO(:,n),pt)
         density_grid = density_grid + occ(n)*NOn*NOn

      end

      NOn.destroy

   end

! DKH densities

   make_DKH_density_grid(density_grid,pt,sgn)
   ! this is kevin. bastard.
   ! here begins the PCE correction of density
   ! welcome
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN

      fac :: REAL
      MO,MOa,MOb :: MAT{REAL}*
      CMO :: MAT{CPX}*
      D,Da,Db :: MAT{REAL}*
      CD :: MAT{CPX}*
      grid_a,grid_b :: VEC{REAL}*

      select case (.scfdata.scf_kind)

         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")

            ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")

            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted

            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            .:density_DKH_r(grid_a,pt,D)
            density_grid = grid_a
            grid_a.destroy

         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

            ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta

            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            grid_b.create(pt.dim1)
            .:density_DKH_r(grid_a,pt,Da)
            .:density_DKH_r(grid_b,pt,Db)

            if (present(sgn)) then; fac = -ONE
            else;                   fac = ONE
            end

            density_grid = grid_a
            density_grid = density_grid + fac * grid_b

            grid_a.destroy
            grid_b.destroy

         case ("gchf","xray_gchf")

            ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")

            CD  => .density_matrix.general_complex
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)

            CD.to_product_of(CMO,CMO,dagger_b=TRUE)

            .:density_DKH_gc(density_grid,pt,CD)

         case default
            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))

      end

   end

   density_DKH_r(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL} , OUT
      pt :: MAT{REAL} , IN
      D :: MAT{REAL} , IN

      n_gcm,n_pt :: INT
      n,i,j :: INT
      g :: REAL
      m_out :: MAT{INT}*
      YU,GG,S,R,sZ,sPZP,PPZPP :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)
      R.destroy

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(YU,Ap,Ep,P2)

      sZ.create(n_gcm,n_gcm)
      sPZP.create(n_gcm,n_gcm)
      .REL:make_DKH_mxs2(sZ,sPZP,YU)

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         WARN(" The use_ppzpp seems to give larger value of density at")
         WARN(" nucleus for very large exponents in the basis set E+08")
         PPZPP.create(n_gcm,n_gcm)
         .REL:make_DKH_mxs4(PPZPP,YU)
      end if

      GG.create(.n_bf,.n_bf)
      density_grid=ZERO
      parallel do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .:make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,sZ,sPZP,PPZPP)

         g = ZERO

         do i = 1,.n_bf
         do j = 1,.n_bf
            g = g + D(i,j)*GG(i,j)
         end
         end

         density_grid(n) = g

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

      S.destroy
      sZ.destroy
      sPZP.destroy
      GG.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         PPZPP.destroy
      end if

   end

   density_DKH_gc(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL} , OUT
      pt :: MAT{REAL} , IN
      D :: MAT{CPX} , IN

      n_gcm,n_pt, n,i,j :: INT
      g :: REAL
      II :: CPX
      m_out :: MAT{INT}*
      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
      Z2,PZP2 :: MAT{CPX}*
      SOx,SOy,SOz :: MAT{REAL}*
      GG22 :: MAT{CPX}*
      P2,Ap,Ep :: VEC{REAL}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      if (abs(.n_prim-n_gcm)> 0 AND abs(.n_prim-.n_bf) > 0) then
         DIE(" contracted gaussians do not work for DKH at gchf level!")
      end if

      R.create(.n_prim,.n_prim)
      S.create(n_gcm,n_gcm)
      .REL:make_primitive_overlap_matrix(S)
      R.destroy

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)
      .:make_DKH_mxs_2(YU,Ap,Ep,P2)

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      ! actually the output matrices are the sX matrices (see DKH for the
      ! use of the s index)  -- ??? dylan
      .:make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)

        Z2.create(2*n_gcm,2*n_gcm)
      PZP2.create(2*n_gcm,2*n_gcm)

      Z2 = (ZERO,ZERO)
      Z2.alpha_alpha_plus(Z)
      Z2.beta_beta_plus(Z)

      II   = (ZERO,ONE)
      PZP2 = (ZERO,ZERO)
      PZP2.alpha_alpha_plus(PZP)
      PZP2.beta_beta_plus(PZP)
      PZP2.beta_alpha_plus(SOx,II)
      PZP2.beta_alpha_plus(SOy,-ONE)
      PZP2.alpha_alpha_plus(SOz,II)
      PZP2.beta_beta_plus(SOz,-II)
      PZP2.make_hermitian

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy

      GG22.create(2*.n_bf,2*.n_bf)

      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
         PPZPP.create(n_gcm,n_gcm)
         .REL:make_DKH_mxs4(PPZPP,YU)
      end if

      density_grid=ZERO
      parallel do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .:make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)

         g = ZERO

         do i=1,2*.n_bf
         do j=1,2*.n_bf
            g = g + REALIFY(D(j,i)*GG22(i,j))
         end
         end

         density_grid(n) = g

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         PPZPP.destroy
      end if

      S.destroy
      Z2.destroy
      PZP2.destroy
      GG22.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

! IOTC densities

   make_IOTC_density_grid(density_grid,pt,sgn)
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN

      fac :: REAL
      MO,MOa,MOb :: MAT{REAL}*
      CMO :: MAT{CPX}*
      D,Da,Db :: MAT{REAL}*
      CD :: MAT{CPX}*
      grid_a,grid_b :: VEC{REAL}*

      select case (.scfdata.scf_kind)

         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")

            ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")

            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted

            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            .:density_IOTC_r(grid_a,pt,D)

            density_grid = grid_a

            grid_a.destroy

         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

            ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta

            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            grid_b.create(pt.dim1)
            .:density_IOTC_r(grid_a,pt,Da)
            .:density_IOTC_r(grid_b,pt,Db)

            if (present(sgn)) then; fac = -ONE
            else;                   fac = ONE
            end

            density_grid = grid_a
            density_grid = density_grid + fac * grid_b
            grid_a.destroy
            grid_b.destroy

         case ("gchf","xray_gchf")

            ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")

            CD  => .density_matrix.general_complex
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)

            CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            .:density_IOTC_gc(density_grid,pt,CD)

         case default
            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))

      end

   end

   density_IOTC_r(density_grid,pt,D,ax)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      ax :: INT , optional

      n_gcm,n_pt,nx :: INT
      n,i,j,k :: INT
      g,c,alpha,alpha2 :: REAL
      m_out :: MAT{INT}*
      R,Y,U,A,T,O :: MAT{REAL}*
      SOx,SOy,SOz,Yr :: MAT{REAL}*
      YU,GG,S,Z,PZP :: MAT{REAL}*
      P2,Ap,E,p,ep,bp :: VEC{REAL}*

      n_pt = pt.dim1
      nx=0
      if(present(ax)) nx=ax


      !!! analysis of the primitive basis set via the overap matrix
      !!! trying to lower the problem to an general contracted basis set
      !!!  OVERLAP MATRIX !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      m_out.create(.n_prim,.n_prim)
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
      ! put the overlap matrix into the n_gcm non-redundant space
      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)

      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)

      !!!  KINETIC ENERGY MATRIX !!!
      .REL:make_primitive_kinetic_matrix(R)
      T.create(n_gcm,n_gcm)
      ! put the kinetic energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,T,m_out)

      A.create(n_gcm,n_gcm)
      A.to_product_of(Y,T)
      T.to_product_of(A,Y)
      ! T=YTY  kinetic energy in an orthogonal basis
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_symmetric_eigenproblem(P2,U)
      P2= TWO * P2
      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      T.destroy
      Y.destroy
      U.destroy

      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      .REL:make_primitive_nuclear_matrix(R)
      Z.create(n_gcm,n_gcm)
      ! put the potential energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,Z,m_out)

      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)

 !!!  PZP MATRIX  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy

      PZP.create(n_gcm,n_gcm)
      ! put the PZP matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,PZP,m_out)

      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)
      R.destroy

      !!! A-O LETS GO !!!
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha

      E.create(n_gcm)
      p.create(n_gcm)
      ep.create(n_gcm)
      Ap.create(n_gcm)
      bp.create(n_gcm)

      do i = 1,n_gcm
         E(i)  = c * sqrt(P2(i) + c * c)
         p(i)  = sqrt(P2(i))
         ep(i) = sqrt(ONE+P2(i)*alpha2)
         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )
         bp(i) = ONE/(ep(i)+ONE)
      end

      P2.destroy

      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
      end
      end

      ! lets find the transforation matrix
      Yr.create(n_gcm,n_gcm)

      .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)

      ! lets make ready the normalzation matrix
      O.create(n_gcm,n_gcm)
      O = ZERO
      do i = 1,n_gcm
         O(i,i) = ONE
         do j=1,n_gcm
         do k=1,n_gcm
            O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
         end do
         end do
      end do

      A.to_inverse_sqrt_of(O)
      O = A

      Z.destroy
      PZP.destroy
      A.destroy

      GG.create(.n_bf,.n_bf)

      density_grid=ZERO
      parallel do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
       if (nx==0) then
         .:make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
       else if (nx==1) then
         .:make_LAPLACIAN_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
       else
         DIE("Currently, I accept only  nx={0,1}.")
       end if

        g=ZERO

        do i=1,.n_bf
          do j=1,.n_bf
            g = g + D(i,j)*GG(i,j)
          end
        end

        density_grid(n)= g
       end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

     S.destroy
     O.destroy
     GG.destroy
     YU.destroy
     Yr.destroy
     Ap.destroy
     E.destroy
     p.destroy
     bp.destroy
     ep.destroy
     m_out.destroy

   end

   density_IOTC_gc(density_grid,pt,D,ax)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{CPX} , IN
    ax :: INT, optional

    n_gcm,n_pt,nx :: INT
    n,i,j :: INT
    g,fac,c,alpha,alpha2,eps :: REAL
    gc,II :: CPX
    m_out,mmm :: MAT{INT}*
    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    A2,PAP,O,Ox,Yr :: MAT{CPX}*
    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

    n_pt = pt.dim1
    nx=0
    if(present(ax)) nx=ax

     !test
     !!! n_gcm = .n_prim = .n_bf !!!
     mmm.create(.n_prim,.n_prim)
      .REL:get_n_gcm(mmm,n_gcm)
     mmm.destroy
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" contracted gaussians do not work for IOTC at gchf level!")
     end if

! this is actually not needed but I am also using n_gcm
     m_out.create(.n_prim,.n_prim)
     .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
     !!!  OVERLAP MATRIX + Y MX !!!
     .REL:make_primitive_overlap_matrix(S)
     Y.to_inverse_sqrt_of(S)
   !  .make_S_Y(S,Y)  !  ???

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     T.create(n_gcm,n_gcm)
     T=ZERO
     .REL:make_primitive_kinetic_matrix(T)
     R=ZERO
     R.to_product_of(Y,T)
     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     P2.create(n_gcm)
     U.create(n_gcm,n_gcm)
     P2=ZERO;U=ZERO
     T.solve_symmetric_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy
     T.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .REL:make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO

!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
         .REL:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .BASE:put_debug(PZP,"PZP matrix")
    .BASE:put_debug(SOx,"SOx matrix")
    .BASE:put_debug(SOy,"SOy matrix")
    .BASE:put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

    .BASE:put_debug(PZP,"PZP matrix YU")
    .BASE:put_debug(SOx,"SOx matrix YU")
    .BASE:put_debug(SOy,"SOy matrix YU")
    .BASE:put_debug(SOz,"SOz matrix YU")
!    .BASE:put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2)
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
     end do

     P2.destroy

     do i = 1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

    .BASE:put_debug(PZP,"PZP matrix YUAp")
    .BASE:put_debug(SOx,"SOx matrix YUAp")
    .BASE:put_debug(SOy,"SOy matrix YUAp")
    .BASE:put_debug(SOz,"SOz matrix YUAp")

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
!   A.make_hermitian
    .BASE:put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
      PAP.make_hermitian
    .BASE:put_debug(PAP,"PAP matrix")

     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
     .REL:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)

     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

!    .find_da_Y_iterative(Yr,PZP,SOx,SOy,SOz,Z,p,bp,ep)
    .REL:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .BASE:put_debug(Yr,"Y matrix")

    PAP.destroy
    A2.destroy

     O.create(2*n_gcm,2*n_gcm)
     Ox.create(2*n_gcm,2*n_gcm)
     O=(ZERO,ZERO)
!     A=(ZERO,ZERO)
     Ox=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox(i,i)=ONE
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox=Ox+O
     O=(ZERO,ZERO)
    UN.create(2*n_gcm)
    UN=ZERO

    ! make ready the preconditioning
    do i=1,2*n_gcm
      UN(i)=ONE/sqrt(real(Ox(i,i)))
    end

    do i=1,2*n_gcm
      do j=1,2*n_gcm
        Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
    end
    .BASE:put_debug(Ox,"Ox matrix")
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(Ox,eps)
    do i=1,2*n_gcm
      do j=1,2*n_gcm
        O(i,j)=O(i,j)*UN(j)
      end
    end
    UN.destroy
    Ox.destroy

    .BASE:put_debug(O,"O matrix")

    GG22.create(2*n_gcm,2*n_gcm)
    density_grid=ZERO
    parallel do n = 1,n_pt
       GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code is comparing to it's non-relativistic
! counter part really not effective :(
!     .:make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
       if (nx==0) then
         .:make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
       else if (nx==1) then
         .:make_LAPLACIAN_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,O)
       else
         DIE("Currently, I accept only  nx={0,1}.")
       end if

       gc=(ZERO,ZERO)

       do i=1,2*.n_bf
         do j=1,2*.n_bf
             gc = gc + D(j,i)*GG22(i,j)
         end
       end
       g=ZERO
       g= real(gc)
       density_grid(n)= g
    end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

    S.destroy
    O.destroy
    Yr.destroy
    GG22.destroy
    YU.destroy
    Ap.destroy
    E.destroy
    bp.destroy
    ep.destroy
    p.destroy
    m_out.destroy
   end

!  ===================================
!  Efficient electron density routines
!  ===================================

   make_rho_grid(N0,pt,D) ::: leaky
   ! Make density grid "N0" on points "pt" using density matrix "D"
   ! skipping as many points as possible. This routine will probably
   ! have to be batched over *spatially localised* points to reduce
   ! memory requirements.
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(N0.dim==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.associated,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0, DD :: MAT{REAL}*
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n  :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! Basis function cutoff
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)

         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt)

         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,xa,ya,za,a2,lga)

               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Get the "sb" basis function grid
                  lgb    => bf_lgval(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  n_keep = count(lga+lgb>=cutoff)
                  if (n_keep==0) cycle

                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=lga+lgb>=cutoff)

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     do p = 1,n_keep
                        n = sp(p)
                        ga = ga0(n)
                        gb = gb0(n)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              n = sp(p)
                              ga = ga0(n)
                              gb = gb0(n)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up

                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

   make_derivative_rho_grid(N0,pt,D) ::: leaky
   ! Make density grids "N0" on points "pt" using density matrices "D"
   ! skipping as points as possible. This routine will probably have
   ! to be batched over *spatially localised* points to reduce memory
   ! requirements.
      N0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT3{REAL}, target, IN

   ENSURE(N0.dim1==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(N0.dim2== D.dim3,"N0 and D: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.associated,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0 :: MAT{REAL}*
      DD :: MAT3{REAL}*
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n, q,n_dens :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! No of densities
      n_dens = D.dim3

      ! Basis function cutoff
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)

         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt)

         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,xa,ya,za,a2,lga)

               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

             ! if (.BASE:debugging("make_rho_grid:sa")) then
             !    stdout.text("grid0:")
             !    stdout.put(grida0,auto_width=TRUE)
             !    stdout.text("lga:")
             !    stdout.put(lga,by_column=TRUE,auto_width=TRUE)
             ! end

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Get the "sb" basis function grid
                  gridb0 => bf_grid0(sb).element
                  lgb    => bf_lgval(sb).element

                  ! How many points in common?
                  n_keep = count((lga+lgb)>=cutoff)
                  if (n_keep==0) cycle

                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=(lga+lgb)>=cutoff)

                ! if (.BASE:debugging("make_rho_grid:sb")) then
                !    stdout.show("n_keep =",n_keep)
                !    stdout.text("sp:")
                !    stdout.put(sp(1:n_keep),by_column=TRUE,auto_width=TRUE)
                ! end

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb,:)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     do q = 1,n_dens
                        Dab = fac*DD(1,1,q)
                        do p = 1,n_keep
                           n = sp(p)
                           ga = ga0(n)
                           gb = gb0(n)
                           val = ga*gb*Dab
                           N0(n,q) = N0(n,q) + val
                        end
                     end

                  else

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           do q = 1,n_dens
                              Dab = fac*DD(a,b,q)
                              do p = 1,n_keep
                                 n = sp(p)
                                 ga = ga0(n)
                                 gb = gb0(n)
                                 val = ga*gb*Dab
                                 N0(n,q) = N0(n,q) + val
                              end
                           end
                        end
                     end

                     ! Clean up

                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

      if (.BASE:debugging("make_rho_grid:n0")) then
         stdout.text("N0:")
         stdout.put(N0,auto_width=TRUE)
      end

   end

!  ======================
!  Efficient bond ED grid
!  ======================

   make_bond_ED_grid(g,pt)
   ! Work out the bond electron density grid "g" for points "pt".
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      okind :: STR

      okind = .natural_orbitals.spinorbital_kind

      select case (okind)
         case ("restricted"); .:make_bond_ED_grid_r(g,pt)
         case default;        DIE("unimplemented")
      end

   end

   make_bond_ED_grid_r(g,pt)
   ! Make the bond electron density grid "g" for points "pt" from the
   ! restricted real density matrix.
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.density_matrix.is_associated_with_genre("restricted"), "no restricted density matrix")

      .:make_bond_ED_grid(g,pt,.density_matrix.restricted)

   end

   make_bond_ED_grid(N0,pt,D) ::: leaky
   ! Make the bond electron density grid "N0" for points "pt"
   ! skipping as many points as possible.
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(N0.dim==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.associated,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra,rb,pc,pa,pb :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0, DD :: MAT{REAL}*
      sha :: SHELL1
      sh  :: SHELL2
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n  :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT
      sab :: INT

      ! Basis function cutoff
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)

         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt)

         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)

            ! Skip if atoms are equal
            if (atom_b>=atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Atom a position
            rb = .atom(atom_b).position

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,xa,ya,za,a2,lga)

               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Get shell-pair
                  .BASE:get_precomputed_shell_pair(sh,sab)

                  ! TEST: Pair-center distance
                  pc = sh.av_pair_center
                  pa = pc - ra
                  pb = pc - rb
                  pc = pc - HALF*(ra+rb)
                  if (pa.norm<pc.norm) cycle
                  if (pb.norm<pc.norm) cycle

                  ! Get the "sb" basis function grid
                  lgb    => bf_lgval(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  n_keep = count(lga+lgb>=cutoff)
                  if (n_keep==0) cycle

                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=lga+lgb>=cutoff)

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     do p = 1,n_keep
                        n = sp(p)
                        ga = ga0(n)
                        gb = gb0(n)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              n = sp(p)
                              ga = ga0(n)
                              gb = gb0(n)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                  end ! if ss or not ss

                  ! Clean
                  sh.destroy_ptr_part

               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

!  ===============
!  Hirshfeld grids
!  ===============

   make_Hirshfeld_rho_grid(N0,pt,wt,c,D) ::: leaky
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Density "N0" weighted by the
   ! grid weights and by the Hirshfeld partition weight for atom "c".
      N0 :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.associated,"no density matrix")
   ENSURE(.becke_grid.associated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DD :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Get the Becke grid for atom "c"
      .becke_grid.make_grid(pt,wt,gridc0,c)
      n_pt = pt.dim1

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Make stockholder weight function "Wc" for atom "c"
      ! If using interpolatators, then overlapping_atoms
      ! are not needed ... otherwise nothing is skipped
      .:apply_stockholder_atom_weight(wt,c,pt)

      ! Prune the grid with new "wt", get saved bf grid gridc0,
      ! and new no of points, n_pt -- leaky
      .becke_grid.prune_grid(pt,wt,gridc0)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO
      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Weight the density
      N0 = N0*wt

      ! Clean up
      bf_grid0.destroy
      bf_skip.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

!  ===================
!  Becke density grids
!  ===================

   set_up_becke_grid ::: leaky
   ! Set up the Becke grids and overlapping atoms

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")

      if (.becke_grid.disassociated) .becke_grid.create

      ! ALWAYS Set up integration grid
      ! (in case of new positions) (leaky)
      .becke_grid.set_grid_data(.atom) ! leaky

      ! ALWAYS make the overlapping atom lists
      .BASE:make_overlapping_atoms

   end

   make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,D) ::: leaky
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Also return the "bf_skip" arrays
   ! and the "bf_grid0" array used for evaluating the rho (or other
   ! density functionals) on the grid.
      N0 :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.associated,"no density matrix")
   ENSURE(.becke_grid.associated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DD :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

   make_rho_becke_atom_grid(N0,Nx,Ny,Nz,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D) ::: leaky
   ! Make the density "N0" and its derivatives "Nx", "Ny", "Nz", on
   ! the Becke grid ("pt","wt") for atom "c" given AO density matrix
   ! "D". Also return the "bf_skip" array, and the basis function and
   ! basis function derivative arrays "bf_grid0", "bf_gridx",
   ! "bf_gridy", "bf_gridz" used for evaluating the density
   ! functionals on the grid.
      N0,Nx,Ny,Nz :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.density_matrix.associated,"no density matrix")
   ENSURE(.becke_grid.associated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}*
      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      DD :: MAT{REAL}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Dab, fac, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt); N0 = ZERO
      Nx.create(n_pt); Nx = ZERO
      Ny.create(n_pt); Ny = ZERO
      Nz.create(n_pt); Nz = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)
      bf_gridx.create(.n_shell)
      bf_gridy.create(.n_shell)
      bf_gridz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            gridax.create(n_keep,na)
            griday.create(n_keep,na)
            gridaz.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+offset)
                     gridax(i,a) = gridcx(n,a+offset)
                     griday(i,a) = gridcy(n,a+offset)
                     gridaz(i,a) = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid(gridax,griday,gridaz,grida0,n_keep,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0
            bf_gridx(sa).element => gridax
            bf_gridy(sa).element => griday
            bf_gridz(sa).element => gridaz

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element
                  gridbx => bf_gridx(sb).element
                  gridby => bf_gridy(sb).element
                  gridbz => bf_gridz(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        N0(n) = N0(n) + Dab* ga*gb
                        Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                        Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                        Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              N0(n) = N0(n) + Dab* ga*gb
                              Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                              Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                              Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridcz.destroy
      gridcy.destroy
      gridcx.destroy
      gridc0.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,Da,Db) ::: leaky
   ! Make the alpha and beta densities "N0a", "N0b" on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" arrays and the "bf_grid0" array used
   ! for evaluating the density (or density functionals) on the grid.
      N0a,N0b :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      Da,Db  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.associated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DDa,DDb :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0a, N0b
      N0a.create(n_pt); N0a = ZERO
      N0b.create(n_pt); N0b = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        N0a(n) = N0a(n) + Da_ab*gab
                        N0b(n) = N0b(n) + Db_ab*gab
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              gab = ga*gb
                              N0a(n) = N0a(n) + Da_ab*gab
                              N0b(n) = N0b(n) + Db_ab*gab
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb,pt,wt,bf_skip,bf_gr0,bf_grx,bf_gry,bf_grz,c,Da,Db) ::: leaky
   ! Make the densities "N0a", "N0b" and their alpha/beta derivatives
   ! "Nxa", "Nya", "Nza", "Nxb", "Nyb", "Nzb", on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" array, and the basis function and basis
   ! function derivative arrays "bf_gr0", "bf_grx", "bf_gry",
   ! "bf_grz" for evaluating the density functionals on the grid.
      N0a,N0b :: VEC{REAL}*
      Nxa,Nya,Nza :: VEC{REAL}*
      Nxb,Nyb,Nzb :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_gr0,bf_grx,bf_gry,bf_grz :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.becke_grid.associated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}*
      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      DDa,DDb :: MAT{REAL}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab,gx,gy,gz :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0 arrays
      N0a.create(n_pt); Nxa.create(n_pt); Nya.create(n_pt); Nza.create(n_pt)
      N0b.create(n_pt); Nxb.create(n_pt); Nyb.create(n_pt); Nzb.create(n_pt)
      N0a = ZERO; Nxa = ZERO; Nya = ZERO; Nza = ZERO
      N0b = ZERO; Nxb = ZERO; Nyb = ZERO; Nzb = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_gr0.create(.n_shell)
      bf_grx.create(.n_shell)
      bf_gry.create(.n_shell)
      bf_grz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            gridax.create(n_keep,na)
            griday.create(n_keep,na)
            gridaz.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+offset)
                     gridax(i,a) = gridcx(n,a+offset)
                     griday(i,a) = gridcy(n,a+offset)
                     gridaz(i,a) = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid(gridax,griday,gridaz,grida0,n_keep,xa,ya,za,a2,skipa,n_pt)
            end
            bf_gr0(sa).element => grida0
            bf_grx(sa).element => gridax
            bf_gry(sa).element => griday
            bf_grz(sa).element => gridaz

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_gr0(sb).element
                  gridbx => bf_grx(sb).element
                  gridby => bf_gry(sb).element
                  gridbz => bf_grz(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        gx  = gax(i)*gb+ga*gbx(j)
                        gy  = gay(i)*gb+ga*gby(j)
                        gz  = gaz(i)*gb+ga*gbz(j)
                        N0a(n) = N0a(n) + Da_ab*gab
                        Nxa(n) = Nxa(n) + Da_ab*gx
                        Nya(n) = Nya(n) + Da_ab*gy
                        Nza(n) = Nza(n) + Da_ab*gz
                        N0b(n) = N0b(n) + Db_ab*gab
                        Nxb(n) = Nxb(n) + Db_ab*gx
                        Nyb(n) = Nyb(n) + Db_ab*gy
                        Nzb(n) = Nzb(n) + Db_ab*gz
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              gx  = gax(i)*gb+ga*gbx(j)
                              gy  = gay(i)*gb+ga*gby(j)
                              gz  = gaz(i)*gb+ga*gbz(j)
                              N0a(n) = N0a(n) + Da_ab*gab
                              Nxa(n) = Nxa(n) + Da_ab*gx
                              Nya(n) = Nya(n) + Da_ab*gy
                              Nza(n) = Nza(n) + Da_ab*gz
                              N0b(n) = N0b(n) + Db_ab*gab
                              Nxb(n) = Nxb(n) + Db_ab*gx
                              Nyb(n) = Nyb(n) + Db_ab*gy
                              Nzb(n) = Nzb(n) + Db_ab*gz
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridcz.destroy
      gridcy.destroy
      gridcx.destroy
      gridc0.destroy

   end

!  ===================================
!  Property/plot densities (templates)
!  ===================================

   prop_grid ::: template
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the grid values
      .GRID(grid,pt)

      ! Print out
      .:dump_plot_grid(grid,LABEL)

      ! Clean up
      pt.destroy
      grid.destroy

   end

   def_grid(grid,pt) ::: template
   ! Make a Gnuplot ascii file containing the deformation density grid.
      self :: INOUT
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.associated,"no natural orbitals")
   ENSURE(.occupation_numbers.associated,"no natural orbitals")

      promolecule_grid :: VEC{REAL}*

      ! Make the normal grid values
      .GRID(grid,pt)

      ! Make the promolecule grid values
      promolecule_grid.create(grid.dim)
      .PRO(promolecule_grid,pt)

      ! Subtract to form deformation grid
      grid = grid - promolecule_grid

      ! Clean up
      promolecule_grid.destroy

   end

   pro_grid(density_grid,pt) ::: template
   ! Work out the promolecule "density_grid" from the supplied points "pt".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")

      grid :: VEC{REAL}*
      a :: INT

      ! Create space for an atom's grid values
      grid.create(density_grid.dim)

      ! Sum up the atom grid values
      density_grid = ZERO
      parallel do a = 1,.n_atom
         .atom(a).GRID(grid,pt)
         density_grid = density_grid + grid
      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

      ! Clean up
      grid.destroy

   end

   pro_dft_grid(density_grid,pt) ::: template
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
   ENSURE(.scfdata.associated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      grid :: VEC{REAL}*
      a :: INT

      ! Create
      grid.create(density_grid.dim)

      ! Make the grid of values
      density_grid = ZERO
      do a = 1,.n_atom
        .atom(a).GRID(grid,pt &
                     ,.scfdata.dft_exchange_functional &
                     ,.scfdata.dft_correlation_functional)
        density_grid = density_grid + grid
      end

      ! Clean
      grid.destroy

   end

!  ==========================
!  Plot printing and deletion
!  ==========================

   dump_plot_grid(grid,name,form)
   ! Dump (write) out the plot "grid" to an appropriate file with
   ! "name", in various formats "form", otherwise (like most things)
   ! taken from the .plot_grid settings.
      self :: IN
      grid :: VEC{REAL}, INOUT
      name :: STR, IN
      form :: STR, optional, IN

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.atom.associated, "no atoms")

      pos :: MAT{REAL}*
      valid :: VEC{INT}*
      bonds :: VEC{VEC_{INT}}*
      arch :: ARCHIVE
      title,fmt :: STR
      fac,z_range :: REAL

      if (.plot_grid.plot_units/=" ") then
         fac = .plot_grid.plot_units.conversion_factor
         grid = fac*grid
      end

      if (.plot_grid.use_plot_max) then
         where (grid>.plot_grid.plot_max) grid = .plot_grid.plot_max
      end

      if (.plot_grid.use_plot_min) then
         where (grid<.plot_grid.plot_min) grid = .plot_grid.plot_min
      end

      ! Set title to be molecule name + sub-title from plot
      title = .name

      if (.plot_grid.plot_label/=" ") then
            title = trim(.name)//","//trim(.plot_grid.plot_label)
      end

      ! Get plot format
      fmt = .plot_grid.plot_format
      if (present(form)) fmt = form

      ! Dump all formats if none specified
      if (fmt=="all") then

         arch.set(title,name,format="contour")
         arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)
         arch.set(title,name,format="drishti.raw")
         arch.write_drishti(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="gnuplot")
         arch.write_gnuplot(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="gaussian.cube")
         arch.write_gaussian_cube(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="mathematica")
         arch.write_mathematica(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="spackman")
         arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)
         arch.set(title,name,format="vapor.raw")
         arch.write_vapor(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="vtk")
         arch.write_vtk(grid,.plot_grid,name)
         arch.set(title,name,format="xdgraph")
         arch.write_a_la_xdgraph(grid,.plot_grid,.atom)
         arch.set(title,name,format="xcrysden.xsf")
         arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="cell.cube")
         arch.write_gaussian_cell(grid,.plot_grid,.crystal.unit_cell_atom,name)

         if (.plot_grid.n_z==1) then
            arch.set(title,name,format="mathematica")
            nullify(pos)
            nullify(valid)
            nullify(bonds)
            z_range = ONE
            .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
            .atom(valid).make_connection_table(bonds)
            arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
            bonds.destroy
            pos.destroy
            valid.destroy
         end

      ! Dump specified format
      else

         select case (fmt)

         case ("contour")

            arch.set(title,name,format="contour")
            arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)

         case ("cube")

            arch.set(title,name,format="gaussian.cube")
            arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

         case ("drishti")

            arch.set(title,name,format="drishti.raw")
            arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("gaussian","gaussian.cube")

            arch.set(title,name,format="gaussian.cube")
            arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

         case ("cell.cube")

            arch.set(title,name,format="cell.cube")
            arch.write_gaussian_cell(grid,.plot_grid,.crystal.unit_cell_atom,name)

         case ("gnuplot")

            arch.set(title,name,format="gnuplot")
            arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("gnuplot.contour")

            ! Get rotated positions and data
            .atom.make_connection_table(bonds)
            .plot_grid.get_rotated_atom_positions(pos)

            ! Make the gnuplot plot archive
            ! Use all commas so that .eps can be handled by latex
            arch.set(title,name,format="gnuplot.contour")
            arch.set_use_all_commas(TRUE)
            arch.write_gnuplot_contour(grid,.plot_grid,pos,bonds)

            ! Clean
            pos.destroy
            bonds.destroy

         case ("spackman")

            arch.set(title,name,format="spackman")
            arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)

         case ("mathematica")

            arch.set(title,name,format="mathematica")
            arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            if (.plot_grid.n_z==1) then
               arch.set(title,name,format="mathematica")
               nullify(pos)
               nullify(valid)
               nullify(bonds)
               z_range = ONE
               .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
               .atom(valid).make_connection_table(bonds)
               arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
               bonds.destroy
               pos.destroy
               valid.destroy
            end

         case ("vapor")

            arch.set(title,name,format="vapor.raw")
            arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("vtk")

            arch.set(title,name,format="vtk")
            arch.write_vtk(grid,.plot_grid,name)

         case ("xcrysden")

            arch.set(title,name,format="xcrysden.xsf")
            arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)

         case ("xdgraph")

            arch.set(title,name,format="xdgraph")
            arch.write_a_la_xdgraph(grid,.plot_grid,.atom)

         case default

            UNKNOWN(fmt)

         end

      end

   end

   dump_plot_grid_XCW(grid,name,form)
   ! Dump (write) out the plot "grid" to an appropriate file with
   ! "name", in various formats "form", otherwise (like most things)
   ! taken from the .plot_grid settings.
      self :: IN
      grid :: VEC{REAL}, INOUT
      name :: STR, IN
      form :: STR, optional, IN

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.atom.associated, "no atoms")

      pos :: MAT{REAL}*
      valid :: VEC{INT}*
      bonds :: VEC{VEC_{INT}}*
      arch :: ARCHIVE
      title,fmt :: STR
      fac,z_range :: REAL

      if (.plot_grid.plot_units/=" ") then
         fac = .plot_grid.plot_units.conversion_factor
         grid = fac*grid
      end

      if (.plot_grid.use_plot_max) then
         where (grid>.plot_grid.plot_max) grid = .plot_grid.plot_max
      end

      if (.plot_grid.use_plot_min) then
         where (grid<.plot_grid.plot_min) grid = .plot_grid.plot_min
      end

      ! Set title to be molecule name + sub-title from plot
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
   !  select case (.scfdata.scf_kind)
   !  case ("xray_rhf","xray_rks","xray_uhf","xray_uks","xray_gchf", &
   !        "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            title = trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//trim(.plot_grid.plot_label)
   !        end
   !  case default
         else
            title = .name
         end
      else
         title = .name
      end

      if (.plot_grid.plot_label/=" ") then
            title = trim(.name)//","//trim(.plot_grid.plot_label)
      end

      ! Get plot format
      fmt = .plot_grid.plot_format
      if (present(form)) fmt = form

      ! Dump all formats if none specified
      if (fmt=="all") then

         arch.set(title,name,format="contour")
         arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)
         arch.set(title,name,format="drishti.raw")
         arch.write_drishti(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="gnuplot")
         arch.write_gnuplot(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="gaussian.cube")
         arch.write_gaussian_cube(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="mathematica")
         arch.write_mathematica(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="spackman")
         arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)
         arch.set(title,name,format="vapor.raw")
         arch.write_vapor(grid,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
         arch.set(title,name,format="vtk")
         arch.write_vtk(grid,.plot_grid,name)
         arch.set(title,name,format="xdgraph")
         arch.write_a_la_xdgraph(grid,.plot_grid,.atom)
         arch.set(title,name,format="xcrysden.xsf")
         arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="cell.cube")
         arch.write_gaussian_cell(grid,.plot_grid,.crystal.unit_cell_atom,name)

         if (.plot_grid.n_z==1) then
            arch.set(title,name,format="mathematica")
            nullify(pos)
            nullify(valid)
            nullify(bonds)
            z_range = ONE
            .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
            .atom(valid).make_connection_table(bonds)
            arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
            bonds.destroy
            pos.destroy
            valid.destroy
         end

      ! Dump specified format
      else

         select case (fmt)

         case ("contour")

            arch.set(title,name,format="contour")
            arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)

         case ("cube")

            arch.set(title,name,format="gaussian.cube")
            arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

         case ("drishti")

            arch.set(title,name,format="drishti.raw")
            arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("gaussian","gaussian.cube")

            arch.set(title,name,format="gaussian.cube")
            arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

         case ("cell.cube")

            arch.set(title,name,format="cell.cube")
            arch.write_gaussian_cell(grid,.plot_grid,.crystal.unit_cell_atom,name)

         case ("gnuplot")

            arch.set(title,name,format="gnuplot")
            arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("gnuplot.contour")

            ! Get rotated positions and data
            .atom.make_connection_table(bonds)
            .plot_grid.get_rotated_atom_positions(pos)

            ! Make the gnuplot plot archive
            ! Use all commas so that .eps can be handled by latex
            arch.set(title,name,format="gnuplot.contour")
            arch.set_use_all_commas(TRUE)
            arch.write_gnuplot_contour(grid,.plot_grid,pos,bonds)

            ! Clean
            pos.destroy
            bonds.destroy

         case ("spackman")

            arch.set(title,name,format="spackman")
            arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)

         case ("mathematica")

            arch.set(title,name,format="mathematica")
            arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            if (.plot_grid.n_z==1) then
               arch.set(title,name,format="mathematica")
               nullify(pos)
               nullify(valid)
               nullify(bonds)
               z_range = ONE
               .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
               .atom(valid).make_connection_table(bonds)
               arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
               bonds.destroy
               pos.destroy
               valid.destroy
            end

         case ("vapor")

            arch.set(title,name,format="vapor.raw")
            arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

         case ("vtk")

            arch.set(title,name,format="vtk")
            arch.write_vtk(grid,.plot_grid,name)

         case ("xcrysden")

            arch.set(title,name,format="xcrysden.xsf")
            arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)

         case ("xdgraph")

            arch.set(title,name,format="xdgraph")
            arch.write_a_la_xdgraph(grid,.plot_grid,.atom)

         case default

            UNKNOWN(fmt)

         end

      end

   end

   delete_plot_grid(name)
   ! Delete the plot grid called "name".
      self :: IN

      name :: STR

      title :: STR
      arch :: ARCHIVE

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      arch.set(title,name,format="gnuplot");        arch.delete_all_genres
      arch.set(title,name,format="mathematica");    arch.delete_all_genres
      arch.set(title,name,format="contour");        arch.delete_all_genres
      arch.set(title,name,format="gaussian.cube");  arch.delete_all_genres
      arch.set(title,name,format="xdgraph");        arch.delete_all_genres

   end

   delete_plot_grid
   ! Delete the plot grid whose name is specified on the input line
      self :: IN

   DIE_IF(stdin.buffer.n_items/=2,"must specify grid to delete in input")
   DIE_IF(stdin.buffer.item_index==2,"must be on the last item")

      name :: STR
      title :: STR
      arch :: ARCHIVE

      stdin.read(name)

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      arch.set(title,name,format="gnuplot");        arch.delete_all_genres
      arch.set(title,name,format="mathematica");    arch.delete_all_genres
      arch.set(title,name,format="contour");        arch.delete_all_genres
      arch.set(title,name,format="gaussian.cube");  arch.delete_all_genres
      arch.set(title,name,format="xdgraph");        arch.delete_all_genres

   end

!  ======================
!  Electron density grids
!  ======================

   make_electron_density_grid ::: get_from(prop_grid, GRID=>:make_density_grid, LABEL=>"electron_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   electron_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      self :: INOUT
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self

      .:make_density_grid(g,pt)

   end

!  =========================
!  Deformation density grids
!  =========================

   make_deformation_density_grid ::: get_from(prop_grid, GRID=>:make_deformation_density_grid, LABEL=>"deformation_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_deformation_density_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_density_grid, PRO=>:make_promolecule_density_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   deformation_density_grid(g,pt) ::: selfless
   ! Work out the electron deformation density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_deformation_density_grid(g,pt)
   end

!  =========
!  ADP grids
!  =========

   make_ADP_grid ::: get_from(prop_grid, GRID=>:make_ADP_grid, LABEL=>"ADP_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ADP_grid(g,pt)
   ! Work out the ADP density grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_ADP_grid(g,pt,.crystal.unit_cell)

   end

   ADP_grid(g,pt) ::: selfless
   ! Work out the ADP density grid "g" for points "pt".
   ! For the first atom, only
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self

      .:make_ADP_grid(g,pt)

   end


   make_ADP2_exponent_grid ::: get_from(prop_grid, GRID=>:make_ADP2_exponent_grid, LABEL=>"ADP2_exponent_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ADP2_exponent_grid(g,pt)
   ! Work out the ADP2 PDF exponent grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_ADP2_exponent_grid(g,pt)

   end

   ADP2_exponent_grid(g,pt) ::: selfless
   ! Work out the ADP2 PDF exponent grid "g" for points "pt".
   ! For the first atom, only
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self

      .:make_ADP2_exponent_grid(g,pt)

   end


   make_ADP_exponent_grid ::: get_from(prop_grid, GRID=>:make_ADP_exponent_grid, LABEL=>"ADP_exponent_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ADP_exponent_grid(g,pt)
   ! Work out the ADP density grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_ADP_exponent_grid(g,pt,.crystal.unit_cell)

   end

   ADP_exponent_grid(g,pt) ::: selfless
   ! Work out the ADP density grid "g" for points "pt".
   ! For the first atom, only
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self

      .:make_ADP_exponent_grid(g,pt)

   end


   make_AADP_correction_grid ::: get_from(prop_grid, GRID=>:make_AADP_correction_grid, LABEL=>"AADP_correction_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_AADP_correction_grid(g,pt)
   ! Work out the anharmonic ADP PDF correction density grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_AADP_PDF_correction_grid(g,pt)

   end

   AADP_correction_grid(g,pt) ::: selfless
   ! Work out the anharmonic ADP PDF correction density grid "g" for points "pt".
   ! For the first atom, only
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self

      .:make_AADP_correction_grid(g,pt)

   end

!  =============
!  Bond ED grids
!  =============

   make_bond_ED_grid ::: get_from(prop_grid, GRID=>:make_bond_ED_grid, LABEL=>"bond_ED_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   bond_ED_grid(g,pt) ::: selfless
   ! Work out the bond electron density grid "g" for points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self

      .:make_bond_ED_grid(g,pt)

   end

!  ==================
!  Spin density grids
!  ==================

   make_spin_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.

   ENSURE(.plot_grid.associated, "no grid")

      pt :: MAT{REAL}*
      grid :: VEC{REAL}*

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .:make_density_grid(grid,pt,sgn=-1)
      .:dump_plot_grid(grid,"spin_density_grid")

      pt.destroy
      grid.destroy

   end

   make_nc_spin_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.

   ENSURE(.plot_grid.associated, "no grid")

      pt :: MAT{REAL}*
      grid :: VEC{REAL}*

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .:make_nc_density_grid_gc(grid,pt)
      .:dump_plot_grid(grid,"nc_spin_density_grid")

      pt.destroy
      grid.destroy

   end

   spin_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals" and ".occupation_numbers" vector.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_density_grid(g,pt,sgn=-1)

   end


   nc_spin_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals" and ".occupation_numbers" vector.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_nc_density_grid_gc(g,pt)
   end

   make_ku_spin_density_grid_u(KP)
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      KP :: MAT{REAL}
   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*
      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      if (genre=="restricted") return

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .:make_density_grid_u(grid,pt)
      .:make_ku_density_grid_u(grid,pt,KP)
      .:dump_plot_grid(grid,"ku_spin_density_grid")

      pt.destroy
      grid.destroy
   end

   make_ku_spin_density_grid_gc(KP)
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      KP :: MAT{CPX}
   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*
      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      if (genre=="restricted") return

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .:make_density_grid_gc(grid,pt)
      .:make_ku_density_grid_gc(grid,pt,KP)
      .:dump_plot_grid(grid,"ku_spin_density_grid")

      pt.destroy
      grid.destroy
   end

!  ==================
!  Bond density grids
!  ==================

   make_def_bond_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.bond_density_atom.associated,"no bond_density_atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .:make_def_bond_density_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "deformation_bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str)
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str)
      label = trim(label) // ")_density_grid"

      ! Print out
      .:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom)
   ! Make the bond deformation "density_grid" for the points "pt".
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: INOUT
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! Make the deformation density
      .:make_deformation_density_grid(density_grid,pt)

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = density_grid(n)*exp(-(x*x+y*y+z*z))/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)
   ! Make the bond deformation "density_grid" for the points "pt".
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: INOUT
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*
      def_density_grid :: VEC{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z,r_inv :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        r_inv = ONE/r_ab.norm
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z)*r_inv)
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           r_inv = ONE/r_ab.norm
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z)*r_inv)/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

!   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)
!   ! Make the bond deformation "density_grid" for the points "pt".
!   ! If there are two atoms in .plot_grid.bond_atom then the whole
!   ! bond density is made; if there are three then the third atom
!     self :: IN
!     density_grid :: VEC{REAL}, OUT
!     pt :: MAT{REAL}, IN
!     bond_density_atom :: VEC{INT}*
!     def_density_grid :: VEC{REAL}, IN
!
!   ENSURE(.atom.associated,"no atoms")
!
!     n_atoms,n_pt,a,b,c,n :: INT
!     x,y,z :: REAL
!     r_ab :: VEC{REAL}(3)
!     rho_pr,rho_a,rho_b :: VEC{REAL}*
!
!     ! No of bond density atoms
!     n_atoms = bond_density_atom.dim
!
!     ! No of grid points
!     n_pt = density_grid.dim
!
!     ! Create space for pair density
!     rho_pr.create(n_pt)
!
!     ! Get the atom pair density for whole molecule
!     rho_pr = ZERO
!     do a = 2,.n_atom
!     do b = 1,a-1
!        if (NOT .atom.bonded(a,b)) cycle
!        r_ab = HALF*(.atom(a).position + .atom(b).position)
!        do n = 1,n_pt
!           x  = pt(n,1) - r_ab(1)
!           y  = pt(n,2) - r_ab(2)
!           z  = pt(n,3) - r_ab(3)
!           rho_pr(n) = rho_pr(n) + exp(-(x*x + y*y + z*z))
!        end
!     end
!     end
!
!     ! Indices of bonded pair
!     a = bond_density_atom(1)
!     b = bond_density_atom(2)
!
!     ! Make the deformation bond pair density
!     r_ab = HALF*(.atom(a).position + .atom(b).position)
!     do n = 1,n_pt
!        if (rho_pr(n)>epsilon(ONE)) then
!           x  = pt(n,1) - r_ab(1)
!           y  = pt(n,2) - r_ab(2)
!           z  = pt(n,3) - r_ab(3)
!           density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z))/rho_pr(n)
!        else
!           density_grid(n) = ZERO
!        end
!     end
!
!     ! Make the atom contribution === if required
!     if (n_atoms==3) then
!
!        rho_a.create(n_pt)
!        rho_b.create(n_pt)
!
!        .atom(a).make_density_grid(rho_a,pt)
!        .atom(b).make_density_grid(rho_b,pt)
!
!        rho_pr = rho_a + rho_b
!
!        c = bond_density_atom(3)
!        if (c==a) then
!           where (rho_pr>epsilon(ONE)); density_grid = (rho_a/rho_pr)*density_grid
!           elsewhere;                   density_grid = ZERO
!           end
!        else if (c==b) then
!           where (rho_pr>epsilon(ONE)); density_grid = (rho_b/rho_pr)*density_grid
!           elsewhere;                   density_grid = ZERO
!           end
!        else
!           DIE("atom is not one of those in the bond")
!        end
!
!        rho_b.destroy
!        rho_a.destroy
!
!     end
!
!     ! Clean up
!     rho_pr.destroy
!
!   end

   deformation_bond_density_grid(g,pt) ::: selfless
   ! Work out the deformation bond density grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_def_bond_density_grid(g,pt,.isosurface.plot_grid.bond_density_atom)

   end


   make_bond_weight_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.bond_density_atom.associated,"no bond_density_atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .:make_bond_weight_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str)
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str)
      label = trim(label) // ")_weight_grid"

      ! Print out
      .:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_weight_grid(density_grid,pt,bond_density_atom)
   ! Make the bond deformation "density_grid" for the points "pt".
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = exp(-(x*x+y*y+z*z))/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   bond_weight_grid(g,pt) ::: selfless
   ! Work out the bond weight grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_bond_weight_grid(g,pt,.isosurface.plot_grid.bond_density_atom)
   end


   make_bond_density_atom_grid
   ! Work out the bond density atom on ".plot_grid"
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.bond_density_atom.associated,"no bond_density_atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .:make_bond_density_atom_grid(grid,pt,.plot_grid.bond_density_atom(1))

      ! Make the plot label
      label = "bond_density_atom_"
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str)
      label = trim(label) // "_grid"

      ! Print out
      .:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_density_atom_grid(density_grid,pt,a)
   ! Make the bond density atom grid "density_grid" for the points
   ! "pt" for atom with index "a".
      self :: INOUT
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      a :: INT, IN

   ENSURE(.atom.associated,"no atoms")

      n_pt,i :: INT
      rho_bond,def_density_grid :: VEC{REAL}*
      bond_density_atom :: VEC{INT}*

      ! No of grid points
      n_pt = density_grid.dim

      ! Do only the spherical part if a<0
      if (a<0) then

        .atom(-a).make_density_grid(density_grid,pt)

      ! Do the whole BDA
      else

        ! Allocate
        def_density_grid.create(n_pt)
        rho_bond.create(n_pt)

        ! Space for bond density atoms
        bond_density_atom.create(3)
        bond_density_atom(1) = a
        bond_density_atom(3) = a

        ! Make the deformation density
        .:make_deformation_density_grid(def_density_grid,pt)

        ! Add spherical part
        .atom(a).make_density_grid(density_grid,pt)

        ! Get bond density contributions
        do i = 1,.n_atom
           if (i==a) cycle
           if (NOT .atom.bonded(i,a)) cycle
           bond_density_atom(2) = i
           .:make_def_bond_density_grid(rho_bond,pt,bond_density_atom,def_density_grid)
           density_grid = density_grid + rho_bond
        end

        ! Clean up
        bond_density_atom.destroy
        rho_bond.destroy
        def_density_grid.destroy

      end

   end

   bond_density_atom_grid(g,pt) ::: selfless
   ! Work out the bond density atom grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_bond_density_atom_grid(g,pt,.isosurface.plot_grid.bond_density_atom(1))

   end

!  ============================
!  Local ionisation energy grid
!  ============================

   make_local_ionisation_grid ::: get_from(prop_grid, GRID=>:make_local_ionisation_grid, LABEL=>"local_ionisation_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_local_ionisation_grid(grid,pt)
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.molecular_orbitals.associated, "no molecular orbitals")
   ENSURE(.molecular_orbitals.has_any_genre, "no molecular orbitals")

      if (trim(.molecular_orbitals.number_kind)=="real") then
        .:make_local_ionisation_grid_r(grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_local_ionisation_grid_r(grid,pt)
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"), "no restricted MO's")
   ENSURE(.orbital_energies.is_associated_with_genre("restricted"),"no restricted MO energies")

      rho,MO :: VEC{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      MO.create(n_pt)

      rho  = ZERO
      grid = ZERO

      parallel do n = 1,n_occ
        .:make_orbital_grid_r(MO,.molecular_orbitals.restricted(:,n),pt,square=TRUE)
        rho  = rho  + MO
        grid = grid - MO*.orbital_energies.restricted(n)
      end

      PARALLEL_SUM(rho)
      PARALLEL_SUM(grid)

      grid = grid/rho

      MO.destroy
      rho.destroy

   end

   local_ionisation_grid(g,pt) ::: selfless
   ! Work out the local ionisation grid "g" for a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_local_ionisation_grid(g,pt)
   end

!  =======================
!  Local virial ratio grid
!  =======================

   make_local_virial_ratio_grid ::: get_from(prop_grid, GRID=>:make_local_virial_ratio_grid, LABEL=>"local_virial_ratio_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_local_virial_ratio_grid(grid,pt)
   ! Work out local virial ratio "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.molecular_orbitals.associated, "no molecular orbitals")
   ENSURE(.molecular_orbitals.has_any_genre, "no molecular orbitals")

      if (trim(.molecular_orbitals.number_kind)=="real") then
        .:make_local_virial_ratio_grid_r(grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_local_virial_ratio_grid_r(grid,pt)
   ! Work out local virial ratio  "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")

      L, G :: VEC{REAL}*
      n_pt :: INT

      n_pt = pt.dim1

      L.create(n_pt)
      G.create(n_pt)

      .:make_laplacian_grid_r(L,pt)
      .:make_G_kinetic_density_grid_r(G,pt)

      grid = TWO - QUARTER*L/G

      G.destroy
      L.destroy

   end

! ==========================
! Laplacian density routines
! ==========================

   make_laplacian_grid ::: get_from(prop_grid, GRID=>:make_laplacian_grid, LABEL=>"laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      self :: INOUT
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      NO_kind :: STR

      NO_kind = .natural_orbitals.spinorbital_kind

      if (trim(.natural_orbitals.number_kind)=="real") then

        select case (NO_kind)
          case ("restricted")
           .:make_laplacian_grid_r(laplacian_grid,pt)
          case ("unrestricted")
           .:make_laplacian_grid_u(laplacian_grid,pt)
          case default
            DIE("unknown real orbital kind")
        end

      else
        select case (NO_kind)
          case ("general_complex")
            .:make_laplacian_grid_gc(laplacian_grid,pt)
          case default
            DIE("unknown complex orbital kind")
        end
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      parallel do n = 1,n_occ

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         laplacian_grid = laplacian_grid &
            + occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3))

      end
      PARALLEL_SUM(laplacian_grid)

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_grid_u(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      grida,gridb :: VEC{REAL}*
      n_pt :: INT

      n_pt = pt.dim1

      grida.create(n_pt)
      gridb.create(n_pt)

      laplacian_grid = ZERO
      grida = ZERO
      gridb = ZERO

      ! alpha part
      .:make_laplacian_grid_a(grida,pt)

      ! beta part
      .:make_laplacian_grid_b(gridb,pt)

     ! a + b
      laplacian_grid = grida + gridb

      grida.destroy
      gridb.destroy

   end

   make_laplacian_grid_a(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      na,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      na = .BASE:no_of_occupied_NOs("alpha")

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      ! alpha part
      parallel do n = 1,na

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.alpha(:,n), pt)

         occ = .occupation_numbers.alpha(n)
         laplacian_grid = laplacian_grid &
            + occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3))

      end
      PARALLEL_SUM(laplacian_grid)

      ! it seems that the factor is required
      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_grid_b(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      nb,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      nb = .BASE:no_of_occupied_NOs("beta")

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      ! beta part
      parallel do n = 1,nb

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.beta(:,n), pt)

         occ = .occupation_numbers.beta(n)
         laplacian_grid = laplacian_grid &
            + occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3))

      end
      PARALLEL_SUM(laplacian_grid)

      ! it seems that the factor is required
      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_grid_gc(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from general complex
   ! natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("general_complex"), "no gc NO's")
   ENSURE(.occupation_numbers.general.associated, "no alpha occupation #'s")

      NO :: VEC{CPX}*
      P,D :: MAT{CPX}*
      ne,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      laplacian_grid = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      ne = .BASE:no_of_occupied_NOs("general")

      ! Alpha part
      parallel do n = 1,ne
         .:make_laplacian_orbital_grid_c(D,P,NO,.natural_orbitals.general_complex(1:.n_prim,n), pt)
         occ = .occupation_numbers.general(n)
         laplacian_grid = laplacian_grid + &
            occ * ( RE(NO*(D(:,1)+D(:,2)+D(:,3))) + RE(conjg(P(:,1))*P(:,1) + conjg(P(:,2))*P(:,2) + conjg(P(:,3))*P(:,3)))
      end
      PARALLEL_SUM(laplacian_grid)

      ! Beta part
      parallel do n = 1,ne
         .:make_laplacian_orbital_grid_c(D,P,NO,.natural_orbitals.general_complex(.n_prim+1:2*.n_prim,n), pt)
         occ = .occupation_numbers.general(n)
         laplacian_grid = laplacian_grid +  &
            occ * ( RE(NO*(D(:,1)+D(:,2)+D(:,3))) + RE(conjg(P(:,1))*P(:,1) + conjg(P(:,2))*P(:,2) + conjg(P(:,3))*P(:,3)))
      end
      PARALLEL_SUM(laplacian_grid)

      ! Factor of two for derivative part
      laplacian_grid = TWO*laplacian_grid

      ! Clean
      D.destroy
      P.destroy
      NO.destroy

   end

   laplacian_grid(g,pt) ::: selfless
   ! Work out the laplacian density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_laplacian_grid(g,pt)

   end


   make_def_laplacian_grid ::: get_from(prop_grid, GRID=>:make_def_laplacian_grid, LABEL=>"deformation_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_laplacian_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_laplacian_grid, PRO=>:make_pro_laplacian_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_laplacian_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_laplacian_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

   def_laplacian_grid(g,pt) ::: selfless
   ! Work out the deformation laplacian density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_laplacian_grid(g,pt)
   end


   make_neg_laplacian_grid ::: get_from(prop_grid, GRID=>:make_neg_laplacian_grid, LABEL=>"negative_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_neg_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      NO_kind :: STR
      NO_kind = .natural_orbitals.spinorbital_kind

      if (trim(.natural_orbitals.number_kind)=="real") then
        select case (NO_kind)
          case ("restricted")
            .:make_laplacian_grid_r(laplacian_grid,pt)
            laplacian_grid = -laplacian_grid
          case ("unrestricted")
            .:make_laplacian_grid_u(laplacian_grid,pt)
            laplacian_grid = -laplacian_grid
          case default
            DIE("unknown real orbital kind")
        end
      else
        select case (NO_kind)
          case ("general_complex")
            .:make_laplacian_grid_gc(laplacian_grid,pt)
            laplacian_grid = -laplacian_grid
          case default
            DIE("unknown complex orbital kind")
        end
      end

   end


   make_rL_grid ::: get_from(prop_grid, GRID=>:make_rL_grid, LABEL=>"reduced_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
        .:make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt  = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         laplacian_grid = laplacian_grid +  &
            occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + P(:,1)*P(:,1)+P(:,2)*P(:,2)+ P(:,3)*P(:,3))
         rho = rho + occ*NO*NO

      end

      laplacian_grid = TWO*laplacian_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  ===============================
!  K-type kinetic density routines
!  ===============================

   make_K_kinetic_energy_grid ::: get_from(prop_grid, GRID=>:make_K_kinetic_energy_grid, LABEL=>"K_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_K_kinetic_density_grid_r(K_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_K_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      K_grid = ZERO

      do n = 1,n_occ

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         K_grid = K_grid  + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3))

      end

      K_grid = -HALF*K_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   K_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the K-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_K_kinetic_energy_grid(g,pt)
   end


   make_def_K_kinetic_grid ::: get_from(prop_grid, GRID=>:make_def_K_kinetic_grid, LABEL=>"deformation_K_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_K_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_K_kinetic_energy_grid, PRO=>:make_pro_K_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_K_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_K_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

   def_K_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation K-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_K_kinetic_grid(g,pt)
   end


   make_rK_kinetic_energy_grid ::: get_from(prop_grid, GRID=>:make_rK_kinetic_energy_grid, LABEL=>"reduced_K_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type reduced kinetic energy density (using the nabla^2) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_rK_kinetic_density_grid_r(K_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_rK_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type reduced kinetic energy density "K_grid" for the supplied
   ! points "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO,rho :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      K_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         K_grid = K_grid + occ*NO*(D(:,1)+D(:,2)+D(:,3))
         rho    = rho    + occ*NO*NO

      end

      K_grid = -HALF*K_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

   make_def_rK_kinetic_grid ::: get_from(prop_grid, GRID=>:make_def_rK_kinetic_grid, LABEL=>"deformation_reduced_K_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rK_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_rK_kinetic_energy_grid, PRO=>:make_pro_rK_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_rK_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rK_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

!  ===============================
!  G-type kinetic density routines
!  ===============================

   make_norm_G_from_virial_grid ::: get_from(prop_grid, GRID=>:make_norm_G_from_virial_grid, LABEL=>"normalized_G_from_virial_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_norm_G_from_virial_grid(G_grid,pt)
   ! Work out the normalized G kinetic energy density
   ! This has the scf energy subtracted.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   DIE_IF(.scfdata.disassociated,"no scfdata")
   DIE_IF(.scfdata.energy.is_zero,"no scf energy")

      .:make_G_kinetic_energy_grid(G_grid,pt)

      G_grid = G_grid + .scfdata.energy

   end

   make_G_kinetic_energy_grid ::: get_from(prop_grid, GRID=>:make_G_kinetic_energy_grid, LABEL=>"G_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_G_kinetic_density_grid_r(G_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_G_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO

      do n = 1,n_occ
         .:make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
         G_grid(:) = G_grid(:) &
                   + .occupation_numbers.restricted(n) &
                   * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end

      G_grid(:) = HALF*G_grid(:)

      P.destroy
      NO.destroy

   end

   G_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the G-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_G_kinetic_energy_grid(g,pt)
   end


   make_G_Kirzhnits_grid ::: get_from(prop_grid, GRID=>:make_G_Kirzhnits_grid, LABEL=>"G_Kirzhnits_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_G_Kirzhnits_grid_r(G_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
      G,L,nab_rho :: MAT{REAL}*
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT

      n_pt =  pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      lap_rho.create(n_pt)
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3)
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)

      rho     = ZERO
      lap_rho = ZERO
      nab_rho = ZERO

      do n = 1,n_occ

         .:make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)

         occ  = .occupation_numbers.restricted(n)
         occ2 = TWO*occ

         rho          = rho          + occ *NO*NO
         nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
         nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,2)
         nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,3)
         lap_rho      = lap_rho      + occ2*(NO*(L(:,1)+L(:,2)+L(:,3))) &
                                     + occ2*(G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3))
      end

      L.destroy
      G.destroy
      NO.destroy

      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy

      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRD)
      G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho

      nab_ro2.destroy
      lap_rho.destroy
      rho.destroy

   end


   make_def_G_kinetic_grid ::: get_from(prop_grid, GRID=>:make_def_G_kinetic_grid, LABEL=>"deformation_G_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_G_kinetic_energy_grid, PRO=>:make_pro_G_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_G_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_G_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

   def_G_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation G-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_G_kinetic_grid(g,pt)
   end


   make_def_G_Kirzhnits_grid ::: get_from(prop_grid, GRID=>:make_def_G_Kirzhnits_grid, LABEL=>"deformation_G_Kirzhnits_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_G_Kirzhnits_grid, PRO=>:make_pro_G_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_G_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_G_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end


   make_rG_kinetic_energy_grid ::: get_from(prop_grid, GRID=>:make_rG_kinetic_energy_grid, LABEL=>"reduced_G_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_rG_kinetic_density_grid_r(G_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_rG_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         .:make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         rho    = rho    + occ*NO*NO

      end

      G_grid = HALF*G_grid/rho

      P.destroy
      NO.destroy
      rho.destroy

   end

   make_def_rG_kinetic_grid ::: get_from(prop_grid, GRID=>:make_def_rG_kinetic_grid, LABEL=>"deformation_reduced_G_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rG_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_rG_kinetic_energy_grid, PRO=>:make_pro_rG_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_rG_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rG_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

!  ===============================
!  G and K-type kinetic densities
!  ===============================

   make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
   ! Work out the G and K-type kinetic energy density on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid,K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
   ! Make the G and K-type kinetic energy grids for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid,K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_occ = .BASE:no_of_occupied_NOs
      n_pt = pt.dim1

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      G_grid = ZERO
      K_grid = ZERO

      do n = 1,n_occ

         .:make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         K_grid = K_grid + occ * NO * (D(:,1)+D(:,2)+D(:,3))

      end

      G_grid =  HALF*G_grid
      K_grid = -HALF*K_grid

      D.destroy
      P.destroy
      NO.destroy

   end

!  =================
!  LOL from Schmider
!  =================

   make_LOL_grid ::: get_from(prop_grid, GRID=>:make_LOL_grid, LABEL=>"LOL_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_LOL_grid(LOL_grid,pt)
   ! Work out the LOL density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      LOL_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .:make_LOL_grid_r(LOL_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_LOL_grid_r(LOL_grid,pt)
   ! Make the "LOL_grid" for the supplied points
   ! "pt" from restricted real natural orbitals.
   ! See Schmider & Becke (2000) J. Mol. STruct 527 p. 51-61.
      self :: INOUT
      LOL_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      tau,tau0 :: VEC{REAL}*
      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      tau0.create(n_pt)
      tau.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)

      LOL_grid = ZERO

      do n = 1,n_occ
         .:make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
         occ =  .occupation_numbers.restricted(n)
         if (occ.is_zero(TOL(8))) cycle
         tau  = tau  + occ*(P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         tau0 = tau0 + occ*NO*NO
      end

      tau  = HALF*tau
      tau0 = HALF*tau0

      ! Make tau0
      tau0 = 0.6d0*(SIX*PI*PI)**(TWO/THREE) * (tau0)**(FIVE/THREE)

      ! Make t(sigma)
      where (abs(tau0)<TOL(8))
         tau = tau/tau0
      elsewhere
         tau = ZERO
      end

      ! Make LOL
      LOL_grid = tau/(ONE+tau)

      ! Clean
      P.destroy
      NO.destroy
      tau.destroy
      tau0.destroy

   end

   LOL_grid(g,pt) ::: selfless
   ! Work out the LOL grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_LOL_grid(g,pt)
   end

!  =============================
!  Energy density from rho grids
!  =============================

   make_E_hf_dens_from_rho_grid ::: get_from(prop_grid, GRID=>:make_E_hf_dens_from_rho_grid, LABEL=>"E_hf_density_from_rho_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.scfdata.scf_kind.is_one_of(["rhf","uhf"]),"scf is not RHF/UHF")

      fac :: REAL

      .:make_density_grid(E_grid,pt)
      fac = .scfdata.energy/.n_e
      E_grid = fac*E_grid

   end

   make_def_E_hf_from_rho_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_E_hf_dens_from_rho_grid, PRO=>:make_E_hf_dens_from_rho_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

!  ========================================================
!  H-type total energy density obtained from virial theorem
!  ========================================================

   make_norm_H_from_virial_grid ::: get_from(prop_grid, GRID=>:make_norm_H_from_virial_grid, LABEL=>"normalized_H_from_virial_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_norm_H_from_virial_grid(H_grid,pt)
   ! Work out the normalized energy density using the virial
   ! relationsip 2G + V = (1/4) L, or H = G + V = (1/4)L - G
   ! This has the scf energy subtracted.
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

   DIE_IF(.scfdata.disassociated,"no scfdata")
   DIE_IF(.scfdata.energy.is_zero,"no scf energy")

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .:make_G_kinetic_energy_grid(G_grid,pt)
      .:make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid - .scfdata.energy

      G_grid.destroy

   end

   make_H_from_virial_grid ::: get_from(prop_grid, GRID=>:make_H_from_virial_grid, LABEL=>"H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .:make_G_kinetic_energy_grid(G_grid,pt)
      .:make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_H_from_virial_grid ::: get_from(prop_grid, GRID=>:make_def_H_from_virial_grid, LABEL=>"deformation_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_H_from_virial_grid, PRO=>:make_pro_H_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_H_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_H_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end


   make_H_Kirzhnits_grid ::: get_from(prop_grid, GRID=>:make_H_Kirzhnits_grid, LABEL=>"H_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .:make_G_Kirzhnits_grid(G_grid,pt)
      .:make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_H_Kirzhnits_grid ::: get_from(prop_grid, GRID=>:make_def_H_Kirzhnits_grid, LABEL=>"deformation_H_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_H_Kirzhnits_grid, PRO=>:make_pro_H_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_H_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_H_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end


   make_rH_from_virial_grid ::: get_from(prop_grid, GRID=>:make_rH_from_virial_grid, LABEL=>"reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .:make_rG_kinetic_energy_grid(G_grid,pt)
      .:make_rL_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_rH_from_virial_grid ::: get_from(prop_grid, GRID=>:make_def_rH_from_virial_grid, LABEL=>"deformation_reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rH_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_rH_from_virial_grid, PRO=>:make_pro_rH_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_rH_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rH_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

!  =====================================================
!  Potential energy density obtained from virial theorem
!  =====================================================

   make_V_from_virial_grid ::: get_from(prop_grid, GRID=>:make_V_from_virial_grid, LABEL=>"V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(.plot_grid.n_pt)

      .:make_G_kinetic_energy_grid(G,pt)
      .:make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_V_from_virial_grid ::: get_from(prop_grid, GRID=>:make_def_V_from_virial_grid, LABEL=>"deformation_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_V_from_virial_grid, PRO=>:make_pro_V_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_V_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_V_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end


   make_V_Kirzhnits_grid ::: get_from(prop_grid, GRID=>:make_V_Kirzhnits_grid, LABEL=>"V_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the energy density from usiang the Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*
      G.create(.plot_grid.n_pt)

      .:make_G_Kirzhnits_grid(G,pt)
      .:make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_V_Kirzhnits_grid ::: get_from(prop_grid, GRID=>:make_def_V_Kirzhnits_grid, LABEL=>"deformation_V_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_V_Kirzhnits_grid, PRO=>:make_pro_V_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_V_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_V_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end


   make_rV_from_virial_grid ::: get_from(prop_grid, GRID=>:make_rV_from_virial_grid, LABEL=>"reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*

      G.create(.plot_grid.n_pt)

      .:make_rG_kinetic_energy_grid(G,pt)
      .:make_rL_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_rV_from_virial_grid ::: get_from(prop_grid, GRID=>:make_def_rV_from_virial_grid, LABEL=>"deformation_reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rV_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_rV_from_virial_grid, PRO=>:make_pro_rV_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_rV_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rV_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

   make_norm_V_from_virial_grid ::: get_from(prop_grid, GRID=>:make_norm_V_from_virial_grid, LABEL=>"normalized_V_from_virial_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_norm_V_from_virial_grid(V,pt)
   ! Work out the Wang and Peng's generalization of Berlin's binding
   ! energy density
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scfdata!")
   ENSURE(NOT .scfdata.energy.is_zero,"no scf energy!")


      G :: VEC{REAL}*

      G.create(.plot_grid.n_pt)

      .:make_G_kinetic_energy_grid(G,pt)
      .:make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G - TWO*.scfdata.energy

      G.destroy

   end

   make_binding_function_wp_grid ::: get_from(prop_grid, GRID=>:make_binding_function_wp_grid, LABEL=>"binding_function_wp_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_binding_function_wp_grid(V,pt)
   ! Work out the Wang and Peng's generalization of Berlin's binding
   ! energy density using *their* formula (47)
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scfdata!")
   ENSURE(NOT .scfdata.energy.is_zero,"no scf energy!")


      Ra,r,center :: VEC{REAL}(3)
      l,d :: REAL
      a,i,Za :: INT

      V = ZERO

      center  = .atom.center_of_atoms

      do a = 1,.n_atom

         Ra = .atom(a).position - center
         Za = .atom(a).atomic_number

         do i = 1,V.dim

            r(1) = pt(i,1) - center(1) - Ra(1)
            r(2) = pt(i,2) - center(2) - Ra(2)
            r(3) = pt(i,3) - center(3) - Ra(3)

            l = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))
            d = Ra(1)*r(1) + Ra(2)*r(2) + Ra(3)*r(3)

            V(i) = V(i) - Za*d/(l*l*l)

         end

      end

   end

!  ==================
!  Electric potential
!  ==================

   make_electric_potential_grid ::: get_from(prop_grid, GRID=>:make_electric_potential_grid, LABEL=>"electric_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
      method :: STR
      method = "exact"
    ! avoid crashing if we are making an isosurface and .plot_grid is not created
    ! .isosurface.plot_grid will be automatically created if we are doing an
    ! isosurface. This is an ugly hack, hopefully temporary
      if(.isosurface.associated) then
         method = .isosurface.plot_grid.electric_potential_method
      else if(.plot_grid.associated) then
         method = .plot_grid.electric_potential_method
      end if

      select case(method)
      case("exact");
         .BASE:make_ao_density_matrix
         if (trim(.density_matrix.number_kind)=="real") then
            .:make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
         else
            .:make_electric_potential_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
         end

      case("multipole")
         .:make_multipole_electric_potential_grid(pot_grid,pt)

      case("mixed")
         .:make_mixed_electric_potential_grid(pot_grid,pt)

      case("scm")
         .:make_scm_electric_potential_grid(pot_grid,pt)

      case default;  UNKNOWN(.plot_grid.electric_potential_method)

      end

   end

   make_multipole_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      self :: INOUT
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      ESP_grid :: VEC{REAL}*

      ESP_grid.create(pot_grid.dim)

      .BASE:make_ao_density_matrix

      .:nuclear_potential(pot_grid,pt)
      .:make_multipole_ESP_grid_r(ESP_grid,pt)

      pot_grid = pot_grid + ESP_grid

      ESP_grid.destroy

   end

   make_mixed_electric_potential_grid(grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      self :: INOUT
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(trim(.density_matrix.number_kind)=="real", "must be a real density matrix")

      ESP_grid :: VEC{REAL}*

      ESP_grid.create(grid.dim)

      .BASE:make_ao_density_matrix
      .:nuclear_potential(grid,pt)
      .:make_mixed_ESP_grid_r(ESP_grid,pt,.density_matrix.restricted)

      grid = grid + ESP_grid

      ESP_grid.destroy

   end

   make_scm_electric_potential_grid(grid,pt)
   ! Make the electric potential "grid" on a series of points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(trim(.density_matrix.number_kind)=="real", "must be a real density matrix")

      ESP_grid :: VEC{REAL}*

      ESP_grid.create(grid.dim)

      .:nuclear_potential(grid,pt)

      .BASE:make_ao_density_matrix
      .:make_scm_ESP_grid_r(ESP_grid,pt,.density_matrix.restricted)

      grid = grid + ESP_grid

      ESP_grid.destroy

   end


   make_electric_potential_grid_r(grid,pt,dens)
   ! Make the total electric potential "grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, IN

      ESP_grid :: VEC{REAL}*

      ESP_grid.create(grid.dim)

      .:nuclear_potential(grid,pt)
      .:make_electronic_pot_grid_r(ESP_grid,pt,dens)

      grid = grid + ESP_grid

      ESP_grid.destroy

   end

   make_electric_potential_grid_c(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}

      elec_grid :: VEC{REAL}*

      elec_grid.create(size(pot_grid))

      .:nuclear_potential(pot_grid,pt)
      .:make_electronic_pot_grid_c(elec_grid,pt,dens)

      pot_grid = pot_grid + elec_grid

      elec_grid.destroy

   end

   electric_potential_grid(g,pt) ::: selfless
   ! Make the electric potential grid "g" on a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_electric_potential_grid(g,pt)

   end

   multipole_electric_potential_grid(g,pt) ::: selfless
   ! Make the electric potential grid "g" on a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_multipole_electric_potential_grid(g,pt)

   end


   make_electronic_pot_grid(pot_grid,pt)
   ! Make the electronic potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")

      .BASE:make_ao_density_matrix

      if (trim(.density_matrix.number_kind)=="real") then
         .:make_electronic_pot_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         .:make_electronic_pot_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
      end

   end

   make_electronic_pot_grid_r(grid,pt,dens)
   ! Make the electronic potential "grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      Vab,Dba :: MAT{REAL}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      grid = ZERO

      parallel do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Dba => dens(fa:la,fb:lb)
         Vab.create(na,nb)

         if (fa/=fb) then

           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             grid(k) = grid(k) - MAT{REAL}:sum_elements(Vab*Dba)*TWO
           end

         else

           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             grid(k) = grid(k) - MAT{REAL}:sum_elements(Vab*Dba)
           end

         end

         Vab.destroy

         if (DO_IN_PARALLEL) then
            PARALLEL_SUM(grid)
         end

         sh.destroy_ptr_part

      end

   end

   make_electronic_pot_grid_c(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      Vab :: MAT{REAL}*
      Dba :: MAT{CPX}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      pot_grid = ZERO

      do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Dba => dens(fa:la,fb:lb)
         Vab.create(na,nb)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*MAT{REAL}:sum_elements(Vab*RE(Dba))
           end
         else
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*MAT{REAL}:sum_elements(Vab*RE(Dba))
           end
         end
         Vab.destroy

         sh.destroy_ptr_part

      end

   end

   make_multipole_ESP_grid_r(grid,pt)
   ! Make the multipole ESP grid 
   ! potential "grid" on a series of grid points "pt" using AO density
   ! matrix "dens"
      self :: INOUT
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      q :: INT
      T :: T_TENSOR
      charges :: VEC{REAL}*
      dipoles, quadrupoles, octupoles :: MAT{REAL}*

      grid = ZERO

      charges.create(.n_atom)
      dipoles.create(.n_atom, 3)
      quadrupoles.create(.n_atom, 6)
      octupoles.create(.n_atom, 10)

      .BASE:make_atomic_multipoles(charges,dipoles,quadrupoles,octupoles,od=FALSE)

      parallel do q = 1, .n_atom
         T.electrostatic_potential_grid(charges(q),dipoles(q,:),quadrupoles(q,:),octupoles(q,:),&
                                       .atom(q).position,pt,grid)
      end

   end

   make_mixed_ESP_grid_r(grid,pt,dens)
   ! Make the multipole ESP grid (off diagonal) using the exact
   ! for the one center terms
   ! potential "grid" on a series of grid points "pt" using AO density
   ! matrix "dens"
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      Vab,Dba :: MAT{REAL}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2
      T :: T_TENSOR
      charges :: VEC{REAL}*
      dipoles, quadrupoles, octupoles :: MAT{REAL}*
      V :: VEC{REAL}(4)

      n_pt = pt.dim1

      grid = ZERO
      charges.create(.n_atom)
      dipoles.create(.n_atom, 3)
      quadrupoles.create(.n_atom, 6)
      octupoles.create(.n_atom, 10)
      .atom.make_connection_table
      .BASE:make_atomic_multipoles(charges,dipoles,quadrupoles,octupoles,oc=TRUE)

      do q = 1, .n_atom
         do k = 1, n_pt
             T.create_fast(.atom(q).position, pt(k,:))
             V = T.electrostatic_potential(charges(q),dipoles(q,:),quadrupoles(q,:),octupoles(q,:))
             grid(k) = grid(k) - sum(V)
         end do
      end do

     parallel do q = 1,.n_shell_pairs

        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

        if (.atom.has_a_connection(atom_a,atom_b) OR (atom_a == atom_b)) then
           Dba => dens(fa:la,fb:lb)
           Vab.create(na,nb)

           if (fa/=fb) then

             do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)*TWO
             end

           else

             do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)
             end

           end

           Vab.destroy

           if (DO_IN_PARALLEL) then
              PARALLEL_SUM(grid)
           end

           sh.destroy_ptr_part

       end

     end

   end

   make_scm_ESP_grid_r(grid,pt,dens)
   ! Make the multipole ESP grid (off diagonal) using the exact
   ! for the one center terms
   ! potential "grid" on a series of grid points "pt" using AO density
   ! matrix "dens"
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      Vab,Dba :: MAT{REAL}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2
      T :: T_TENSOR
      charges :: VEC{REAL}*
      dipoles, quadrupoles, octupoles :: MAT{REAL}*
      V :: VEC{REAL}(4)

      n_pt = pt.dim1

      grid = ZERO
      charges.create(.n_atom)
      dipoles.create(.n_atom, 3)
      quadrupoles.create(.n_atom, 6)
      octupoles.create(.n_atom, 10)
      .atom.make_connection_table
      .BASE:make_atomic_multipoles(charges,dipoles,quadrupoles,octupoles,no_s=TRUE)

      do q = 1, .n_atom
         charges(q) = charges(q)
         do k = 1, n_pt
             T.create_fast(.atom(q).position, pt(k,:))
             V = T.electrostatic_potential(charges(q),dipoles(q,:),quadrupoles(q,:),octupoles(q,:))
             grid(k) = grid(k) - sum(V)
         end do
      end do

     parallel do q = 1,.n_shell_pairs

        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

        if ((sh.a.l == 0) AND (sh.b.l == 0) AND atom_a == atom_b) then
           Dba => dens(fa:la,fb:lb)
           Vab.create(na,nb)

           if (fa/=fb) then
             do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)*TWO
             end
           else
             do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)
             end
           end

           Vab.destroy

           if (DO_IN_PARALLEL) then
              PARALLEL_SUM(grid)
           end

           sh.destroy_ptr_part
       end

     end

   end


   make_mixed_ESP_grid_r_v2(grid,pt,P)
   ! Make the multipole ESP grid (off diagonal) using the exact for
   ! the one center terms potential "grid" on a series of grid points
   ! "pt" using AO density matrix "P"
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      P :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      VD :: VEC{MAT3_{REAL}}*
      Vab :: MAT{REAL}@
      Pba :: MAT{REAL}@
      P_max,tol, Va,Vb :: REAL
      n_pt,q,a,b,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2
    ! pole0 :: VEC{REAL}*
    ! pole2,pole4,pole8 :: MAT{REAL}*
    ! V :: VEC{REAL}(4)
    ! T :: T_TENSOR

      n_pt = pt.dim1

      grid = ZERO

      ! Make atomic multipoles
    ! pole0.create(.n_atom)
    ! pole2.create(.n_atom, 3)
    ! pole4.create(.n_atom, 6)
    ! pole8.create(.n_atom, 10)

    ! .BASE:make_atomic_multipoles(pole0,pole2,pole4,pole8,oc=TRUE)

    ! ! Make mutipole potential
    ! do q = 1, .n_atom
    ! do k = 1, n_pt
    !    T.create_fast(.atom(q).position, pt(k,:))
    !    V = T.electrostatic_potential(pole0(q),pole2(q,:),pole4(q,:),pole8(q,:))
    !    grid(k) = grid(k) - sum(V)
    ! end do
    ! end do

    ! pole8.destroy
    ! pole4.destroy
    ! pole2.destroy
    ! pole0.destroy

      ! Diagonal blocks for schwarz test
      .:make_diagonal_block_V_ints(VD,pt)

      ! Schwarz test tolerance
      tol = TOL(6)

      ! Make exact potential
      parallel do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,a,fa,la,na,b,fb,lb,nb,atom_a,atom_b)

         ! Density matrix
         Pba = P(fa:la,fb:lb)
         P_max = maxval(abs(Pba))

         if (fa==fb) then

            ! Do basis-fn diagonal exactly
            do k = 1,n_pt
               grid(k) = grid(k) - sum(VD(a).element(:,:,k)*Pba)
            end

         else if (P_max>tol) then
            
            ! Schwarz test for off diagonals & large P's
            allocate(Vab(na,nb))
            do k = 1,n_pt
               Va = sqrt(maxval(abs(VD(a).element(:,:,k))))
               Vb = sqrt(maxval(abs(VD(b).element(:,:,k))))
               if (P_max*Va*Vb > tol) then
                  sh.get_nuc(Vab,ZERO,pt(k,:))
                  grid(k) = grid(k) - sum(Vab*Pba)*TWO
               end
            end
            deallocate(Vab)

         end

         sh.destroy_ptr_part

      end
            
      ! Clean
      VD.destroy

      ! Reduce
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

   end

   make_diagonal_block_V_ints(V,pt) ::: private, leaky
   ! Make "V" the diagonal block nuclear attraction integrals 
   ! (a| |r_k - r|^-1 |a) over a shell q, a in q, for each 
   ! point r_k = "pt(k,1:3)".
      V :: VEC{MAT3_{REAL}}*, OUT
      pt :: MAT{REAL}, IN

   ENSURE(3==pt.dim2,"wrong dim2, pt")

      n_pt,q,a,b,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      V.create(.n_shell)

      parallel do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,a,fa,la,na,b,fb,lb,nb,atom_a,atom_b)

         if (a==b) then

            V(a).element.create(na,na,n_pt)
            do k = 1,n_pt
               sh.get_nuc(V(a).element(:,:,k),ZERO,pt(k,:))
            end

         end

         sh.destroy_ptr_part

      end

   end



   make_def_e_pot_grid ::: get_from(prop_grid, GRID=>:make_def_e_pot_grid, LABEL=>"deformation_electric_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_e_pot_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_electric_potential_grid, PRO=>:make_pro_e_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_e_pot_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_electric_potential_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

   def_e_pot_grid(g,pt) ::: selfless
   ! Work out the deformation electric potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_e_pot_grid(g,pt)
   end

!  ==========================================
!  ESPs from center and surrounding molecules
!  ===========================================

   make_the_center_ESP_grid ::: get_from(prop_grid, GRID=>:make_the_center_ESP_grid, LABEL=>"the_center_ESP_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_the_center_ESP_grid(grid,pt)
   ! Make the central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      if (trim(.density_matrix.number_kind)=="real") then
         .:make_the_center_ESP_grid_r(grid,pt)
      end

   end

   make_the_center_ESP_grid_r(grid,pt)
   ! Make the central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.associated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.associated ,"no mol 2 DM!")

      mol :: MOLECULE*

      mol => .atom_group(1).mol

      ! ESP for central molecule
      mol.:make_electric_potential_grid(grid,pt)

   end

   the_center_ESP_grid(g,pt) ::: selfless
   ! Make the central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_the_center_ESP_grid(g,pt)

   end


   make_non_center_ESP_grid ::: get_from(prop_grid, GRID=>:make_non_center_ESP_grid, LABEL=>"non_center_ESP_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_non_center_ESP_grid(grid,pt)
   ! Make the non-central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      if (trim(.density_matrix.number_kind)=="real") then
         .:make_non_center_ESP_grid_r(grid,pt)
      end

   end

   make_non_center_ESP_grid_r(grid,pt)
   ! Make the non-central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.associated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.associated ,"no mol 2 DM!")

      ESP :: VEC{REAL}*
      mol :: MOLECULE*
      m :: INT

      ESP.create(grid.dim)

      grid = ZERO

      ! Loop over non-central molecules
      do m = 2,.atom_group.dim

         ! Make ESP for molecule m
         mol => .atom_group(m).mol
         mol.:make_electric_potential_grid(ESP,pt)

         grid = grid + ESP

      end

      ESP.destroy

   end

   non_center_ESP_grid(g,pt) ::: selfless
   ! Make the non-central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_non_center_ESP_grid(g,pt)

   end

!  ==========================================
!  Product of ESPs from surrounding molecules
!  ==========================================

   make_product_ESP_grid ::: get_from(prop_grid, GRID=>:make_product_ESP_grid, LABEL=>"product_ESP_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_product_ESP_grid(grid,pt)
   ! Make the product of the central and  neighboring-molecule
   ! ESP "grid", on a series of points "pt".
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .:make_product_ESP_grid_r(grid,pt)

   end

   make_product_ESP_grid_r(grid,pt)
   ! Make the product of the central and  neighboring-molecule
   ! ESP "grid", on a series of points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.associated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.associated ,"no mol 2 DM!")

      ESP :: VEC{REAL}*
      mol :: MOLECULE*
      m :: INT

      ESP.create(grid.dim)

      grid = ZERO

      ! Loop over non-central molecules
      do m = 2,.atom_group.dim

         ! Make ESP for molecule m
         mol => .atom_group(m).mol
         mol.:make_electric_potential_grid(ESP,pt)

         grid = grid + ESP

      end

      ! Central molecule ESP
      mol => .atom_group(1).mol
      mol.:make_electric_potential_grid(ESP,pt)

      ! Make product
      grid = grid*ESP

      ESP.destroy

   end

   product_ESP_grid(g,pt) ::: selfless
   ! Make the product of the central and  neighboring-molecule
   ! ESP "grid", on a series of points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_product_ESP_grid(g,pt)

   end


   make_group_product_ESP_grid ::: get_from(prop_grid, GRID=>:make_group_product_ESP_grid, LABEL=>"group_product_ESP_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_group_product_ESP_grid(grid,pt)
   ! Make the product of the central and all neighboring-molecule
   ! ESP "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .:make_group_product_ESP_grid_r(grid,pt)

   end

   make_group_product_ESP_grid_r(grid,pt)
   ! Make the product of the central and all neighboring-molecule
   ! ESP "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
   ! This is for surface properties only, not isosurfaces!
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.isosurface.associated,"no isosurface")

      list :: VEC{VEC_{INT}}*
      ESP :: VEC{REAL}*
      ptg :: MAT{REAL}*
      mol :: MOLECULE*
      g :: INT


      list.create(pt.dim2)
      .isosurface.make_pts_list_for_group(list)

      grid = ZERO

      ! Loop over non-central molecules
      do g = 2,.atom_group.dim

      ! DEBUG !!!!!!!!!!!!!!!!!
      stdout.show("length of list "//trim(g.to_str),size(list(g).element))

         if (list(g).element.dim==0) cycle

         ! Get the fragment g patch
         ptg.create_copy(pt(list(g).element,:))

         ! Make ESP on patch g for molecule m
         allocate(ESP(list(g).element.dim))
         mol => .atom_group(g).mol
         mol.:make_electric_potential_grid(ESP,ptg)
         grid(list(g)[:]) = ESP

         ! Clean
         deallocate(ESP)
         ptg.destroy

      end

      ! Central molecule ESP; use all points pt
      allocate(ESP(pt.dim))
      mol => .atom_group(1).mol
      mol.:make_electric_potential_grid(ESP,pt)

      ! Make product
      grid = grid*ESP

      ! Clean
      deallocate(ESP)
      list.destroy

   end

   group_product_ESP_grid(g,pt) ::: selfless
   ! Make the product of the central and all neighboring-molecule
   ! ESP "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
   ! This is for surface properties only, not isosurfaces!
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_group_product_ESP_grid(g,pt)

   end

!  ==========================================
!  Product E field grid surrounding molecules
!  ==========================================

   make_product_E_field_grid ::: get_from(prop_grid, GRID=>:make_product_E_field_grid, LABEL=>"product_E_field_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_product_E_field_grid(grid,pt)
   ! Make the product of the central and neighboring-molecule
   ! E fields in "grid", on a series of points "pt".
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .:make_product_E_field_grid_r(grid,pt)

   end

   make_product_E_field_grid_r(grid,pt)
   ! Make the product of the central and neighboring-molecule
   ! densities and ESPs on "grid", on a series of points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.atom_group(1).mol.density_matrix.associated ,"no mol 1 DM!")
   ENSURE(.atom_group(2).mol.density_matrix.associated ,"no mol 2 DM!")

      E1,E2 :: MAT{REAL}*
      mol :: MOLECULE*
      m,n_pt :: INT

      n_pt = grid.dim

      ! E fields for first and surrounding molecules
      E1.create(n_pt,3)
      E2.create(n_pt,3)

      E2 = ZERO

      ! Loop over non-central molecules
      do m = 2,.atom_group.dim

         ! Make E field for molecules m>2
         mol => .atom_group(m).mol
         mol.:make_E_field_grid(E1,pt)
         E2 = E2 + E1

      end

      ! Central molecule E-field
      mol => .atom_group(1).mol
      mol.:make_E_field_grid(E1,pt)

      ! Product of E fields
      grid = E1(:,1)*E2(:,1) + E1(:,2)*E2(:,2) + E1(:,3)*E2(:,3)

      ! Clean
      E2.destroy
      E1.destroy

   end

   product_E_field_grid(g,pt) ::: selfless
   ! Make the product of the central and neighboring-molecule
   ! densities and ESPs on "grid", on a series of points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_product_E_field_grid(g,pt)

   end


   make_group_product_E_field_grid ::: get_from(prop_grid, GRID=>:make_product_E_field_grid, LABEL=>"group_product_E_field_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_group_product_E_field_grid(grid,pt)
   ! Make the product of the central and neighboring-molecule
   ! E fields in "grid", on a series of points "pt".
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .:make_group_product_E_field_grid_r(grid,pt)

   end

   make_group_product_E_field_grid_r(grid,pt)
   ! Make the product of the central and all neighboring-molecule
   ! E-field "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
   ! This is for surface properties only, not isosurfaces!
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(.isosurface.associated,"no isosurface")

      list :: VEC{VEC_{INT}}*
      E1,E2 :: MAT{REAL}*
      ptg :: MAT{REAL}*
      mol :: MOLECULE*
      g,n_pt :: INT

      n_pt = grid.dim

      list.create(n_pt)
      .isosurface.make_pts_list_for_group(list)

      ! E fields for surrounding molecules
      allocate(E2(n_pt,3))
      E2 = ZERO

      ! Loop over non-central molecules
      do g = 2,.atom_group.dim

         ! Get the fragment g patch
         ptg.create_copy(pt(:,list(g).element))

         ! Make ESP on patch g for molecule m
         allocate(E1(list(g).element.dim,3))
         mol => .atom_group(g).mol
         mol.:make_E_field_grid(E1,ptg)
         E2(list(g)[:],:) = E1

         ! Clean
         deallocate(E1)
         ptg.destroy

      end

      ! Central molecule E-field; use all points pt
      allocate(E1(n_pt,3))
      mol => .atom_group(1).mol
      mol.:make_E_field_grid(E1,pt)

      ! Product of E fields
      grid = E1(:,1)*E2(:,1) + E1(:,2)*E2(:,2) + E1(:,3)*E2(:,3)

      ! Clean
      deallocate(E1)
      deallocate(E2)
      list.destroy

   end

   group_product_E_field_grid(g,pt) ::: selfless
   ! Make the product of the central and all neighboring-molecule
   ! ESP "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
   ! This is for surface properties only, not isosurfaces!
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      self :: MOLECULE*

      .BASE:set_from_saved_self
      .:make_group_product_E_field_grid(g,pt)

   end

!  ================
!  DFT xc potential
!  ================

   make_dft_xc_pot_grid ::: get_from(prop_grid, GRID=>:make_dft_xc_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_xc_pot_grid(V,pt)
   ! Work out the DFT potential on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*

      rho.create(V.dim)

      .:make_density_grid(rho,pt)

      V = ZERO
      dft.set_defaults
      dft.new_r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_potential(.scfdata.dft_correlation_functional,V,rho)

      rho.destroy

   end

   dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_dft_xc_pot_grid(g,pt)
   end


   make_def_dft_xc_pot_grid ::: get_from(prop_grid, GRID=>:make_def_dft_xc_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_xc_pot_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_dft_xc_pot_grid, PRO=>:make_pro_dft_xc_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_dft_xc_pot_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_dft_xc_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".
   end

   def_dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_dft_xc_pot_grid(g,pt)
   end

!  =======================
!  DFT effective potential
!  =======================

! The effective potential includes the classical electrostatic potential

   make_dft_eff_pot_grid ::: get_from(prop_grid, GRID=>:make_dft_eff_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_eff_pot_grid(V,pt)
   ! Work out the Slater DFT potential "V" (i.e. the Slater potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
   ENSURE(NOT .scfdata.using_GGA_functional,"so far, must not be a GGA functional")

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*

      rho.create(V.dim)

      .:make_electric_potential_grid(V,pt)
      .:make_density_grid(rho,pt)

      dft.set_defaults
      dft.new_r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_potential(.scfdata.dft_correlation_functional,V,rho)

      rho.destroy

   end

   dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_dft_eff_pot_grid(g,pt)
   end


   make_def_dft_eff_pot_grid ::: get_from(prop_grid, GRID=>:make_def_dft_eff_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_eff_pot_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_dft_eff_pot_grid, PRO=>:make_pro_dft_eff_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_dft_eff_pot_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_dft_eff_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".
   end

   def_dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_dft_eff_pot_grid(g,pt)
   end

!  ==================
!  DFT energy density
!  ==================

! The energy density includes the classical electrostatic potential, but no
! kinetic energy density terms

   make_dft_energy_grid ::: get_from(prop_grid, GRID=>:make_dft_energy_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_energy_grid(V,pt)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      dft :: DFT_FUNCTIONAL
      Ve,rho :: VEC{REAL}*

      Ve.create(V.dim)
      rho.create(V.dim)

      .:nuclear_potential(V,pt)
      .:make_electronic_pot_grid(Ve,pt)
      V = -V - HALF*Ve
      .:make_density_grid(rho,pt)

      dft.set_defaults
      dft.new_r_energy_density(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_energy_density(.scfdata.dft_correlation_functional,V,rho)
      V = V*rho

      Ve.destroy
      rho.destroy

   end

   dft_energy_grid(g,pt) ::: selfless
   ! Work out the DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_dft_energy_grid(g,pt)
   end


   make_def_dft_energy_grid ::: get_from(prop_grid, GRID=>:make_def_dft_energy_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_energy_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_dft_energy_grid, PRO=>:make_pro_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_dft_energy_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".
   end

   def_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_dft_energy_grid(g,pt)
   end

!  =========================
!  H-type DFT energy density
!  =========================

! H = G + V(DFT)

   make_H_dft_energy_grid ::: get_from(prop_grid, GRID=>:make_H_dft_energy_grid, LABEL=>"H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_dft_energy_grid(H_grid,pt)
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"must be a DFT calculation")

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .:make_G_kinetic_energy_grid(G_grid,pt)
      .:make_dft_energy_grid(H_grid,pt)

      H_grid = H_grid + G_grid

      G_grid.destroy

   end

   H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the H-type DFT energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_H_dft_energy_grid(g,pt)
   end


   make_def_H_dft_energy_grid ::: get_from(prop_grid, GRID=>:make_def_H_dft_energy_grid, LABEL=>"deformation_H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_dft_energy_grid(grid,pt) ::: get_from(def_grid, GRID=>:make_H_dft_energy_grid, PRO=>:make_pro_H_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
   end

   make_pro_H_dft_energy_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_H_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".
   end

   def_H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation slater H energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_def_H_dft_energy_grid(g,pt)
   end

!  =======================
!  Hirshfeld (slater) grid
!  =======================

   make_Hirshfeld_density_grid ::: get_from(prop_grid, GRID=>:make_Hirshfeld_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_Hirshfeld_density_grid(density_grid,pt)
   ! WARNING: this version calls directly the interpolated slaterbasis routine.
   ! Make the Hirshfeld stockholder "density_grid" for the supplied
   ! points "pt". The promolecule electron density used to define the
   ! Hirshfeld surface is calculated using a tabulated slater basis
   ! set.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

!  ENSURE(.saved.associated, "no saved molecule")
!  ENSURE(.saved.cluster.associated, "no saved cluster data")
!  ENSURE(.saved.cluster.info_made, "no saved cluster info")
!  ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
!  ENSURE(.saved.cluster.n_atoms==.atom.dim,"inconsistent saved cluster and atom list")
!  ENSURE(.atom.associated,"no atoms")
!  ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}*
      is_fragment_atom :: VEC{BIN}*
      n_atoms,n_pt,a :: INT

      n_pt = density_grid.dim
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      n_atoms = .atom.dim
      is_fragment_atom => .saved.cluster.is_fragment_atom

      if (NOT .atom.has_disorder) then

         do a = 1,n_atoms
            if (NOT is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(rho_fragment,pt,.atom(a).position)
         end
         density_grid = rho_fragment

         do a = 1,n_atoms
            if (is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(density_grid,pt,.atom(a).position)
         end

      else

         do a = 1,n_atoms
            if (NOT is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(rho_fragment,pt,.atom(a).position,.atom(a).site_occupancy)
         end
         density_grid = rho_fragment

         do a = 1,n_atoms
            if (is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(density_grid,pt,.atom(a).position,.atom(a).site_occupancy)
         end

      end

      where (density_grid>ZERO)
         density_grid = rho_fragment/density_grid
      elsewhere
         density_grid = ZERO
      end

      rho_fragment.destroy

   end

   Hirshfeld_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld density grid "g" for a series of points.
   ! WARNING: this version cuts corners.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_Hirshfeld_density_grid(g,pt)
   end

!  ===========
!  Stockholder
!  ===========

   make_stockholder_density_grid ::: get_from(prop_grid, GRID=>:make_stockholder_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_stockholder_density_grid(density_grid,pt)
   ! Make the Hirschfeld stockholder "density_grid" for the supplied points
   ! "pt". The promolecule electron density used to define the Hirshfeld surface
   ! is calculated as follows: if a slater basis set is available, then that is
   ! used to calculate the promolecule electron density; if a coppens basis set
   ! is available, then that is used to get the promolecule density; otherwise,
   ! if restricted real natural orbitals are available for all atoms (in terms
   ! of gaussian basis functions), then those are used to calculate the
   ! promolecule densisties. In principle, we can caculate Hirshfeld surfaces
   ! for *molecular* fragment densities, rather than promolecule densities as
   ! done here. That would require a different keyword and different code.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.saved.associated, "no saved molecule")
   ENSURE(.saved.cluster.associated, "no saved cluster data")
   ENSURE(.saved.cluster.info_made, "no saved cluster info")
   ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
   ENSURE(.saved.cluster.n_atoms==.atom.dim,"saved cluster/=atom list")
   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}*
      is_fragment_atom :: VEC{BIN}*
      n_atoms,n_pt,a :: INT

      ! No. of fragment atoms
      n_atoms = .atom.dim

      ! Locate fragment atoms in cluster
      is_fragment_atom => .saved.cluster.is_fragment_atom

      ! Fragment density grid
      n_pt = density_grid.dim
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      ! Make fragment density
      do a = 1,n_atoms
         if (NOT is_fragment_atom(a)) cycle
         .atom(a).add_density_grid(rho_fragment,pt)
      end

      density_grid = rho_fragment
      do a = 1,n_atoms
         if (is_fragment_atom(a)) cycle
         .atom(a).add_density_grid(density_grid,pt)
      end

      ! density_grid = rho_fragment/density_grid
      do a = 1,size(density_grid)
         if (density_grid(a)>epsilon(ONE)) then
            density_grid(a) = rho_fragment(a)/density_grid(a)
         else
            density_grid(a) = ZERO
         end
      end

      ! Clean up
      rho_fragment.destroy

   end

!   make_stockholder_weight_d_grid(w0,w1,w2,pt)
!   ! Make the Hirschfeld stockholder derivative density grid "d1_grid"
!   ! for the supplied points "pt". The promolecule electron density
!   ! used to define the Hirshfeld surface is calculated as follows: if
!   ! a slater basis set is available, then that is used to calculate
!   ! the promolecule electron density; if a coppens basis set is
!   ! available, then that is used to get the promolecule density;
!   ! otherwise, if restricted real natural orbitals are available for
!   ! all atoms (in terms of gaussian basis functions), then those are
!   ! used to calculate the promolecule densisties. In principle, we
!   ! can caculate Hirshfeld surfaces for *molecular* fragment
!   ! densities, rather than promolecule densities as done here. That
!   ! would require a different keyword and different code.
!     self :: IN
!     w0 :: VEC{REAL}, OUT
!     w1 :: MAT{REAL}, OUT
!     w2 :: MAT3{REAL}, OUT
!     pt :: MAT{REAL}, IN
!   ENSURE(w1.dim1==3, "wrong size w1")
!   ENSURE(w2.dim1==3, "wrong size w2")
!   ENSURE(w2.dim2==3, "wrong size w2")
!   ENSURE(w0.dim1==w1.dim2, "incompatible w0 and w1")
!   ENSURE(w0.dim1==w2.dim3, "incompatible w0 and w2")
!   ENSURE(.cluster.associated, "no cluster data")
!   ENSURE(.cluster.info_made, "no cluster info")
!   ENSURE(.cluster.radius>ZERO, "cluster radius is zero")
!   ENSURE(.atom.associated,"no atoms")
!   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
!     d0,rho0f,rho0a :: VEC{REAL}*
!     d1,rho1f,rho1a :: MAT{REAL}*
!     d2,rho2f,rho2a :: MAT3{REAL}*
!     f1,a1 :: VEC{REAL}(3)
!     f0,bot,bot2,bot3,fac :: REAL
!     n_pt,a,b,i :: INT
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     n_pt = w0.dim1
!     d0.create(n_pt);     rho0f.create(n_pt);     rho0a.create(n_pt)
!     d1.create(3,n_pt);   rho1f.create(3,n_pt);   rho1a.create(3,n_pt)
!     d2.create(3,3,n_pt); rho2f.create(3,3,n_pt); rho2a.create(3,3,n_pt)
!     rho0f = ZERO; rho0a = ZERO
!     rho1f = ZERO; rho1a = ZERO
!     rho2f = ZERO; rho2a = ZERO
!     do a = 1,.cluster.n_atoms
!        if (NOT .cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0f = rho0f + d0
!        rho1f = rho1f + d1
!        rho2f = rho2f + d2
!     end
!     rho0a = rho0f
!     rho1a = rho1f
!     rho2a = rho2f
!     do a = 1,.cluster.n_atoms
!        if (.cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0a = rho0a + d0
!        rho1a = rho1a + d1
!        rho2a = rho2a + d2
!     end
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     do i = 1,rho0a.dim
!       if (rho0a(a)>epsilon(ONE)) then
!         bot = ONE/rho0a(i)
!         bot2 = bot*bot
!         bot3 = TWO*bot2*bot
!         f0   = rho0f(i)
!         w0(i) = f0*bot
!         f1 = rho1f(:,i)
!         a1 = rho1a(:,i)
!         fac = f0*bot2
!         w1(:,i) = f1*bot - a1*fac
!         do a = 1,3
!         do b = 1,a
!            w2(a,b,i) = rho2f(a,b,i)*bot &
!                      - (f1(a)*a1(b)+f1(b)*a1(a))*bot2 &
!                      - f0*rho2a(a,b,i)*bot2 &
!                      + f0*a1(a)*a1(b)*bot3
!            if (a==b) cycle
!            w2(b,a,i) = w2(a,b,i)
!         end
!         end
!       else
!         w0(i) = ZERO
!         w1(:,i) = ZERO
!         w2(:,:,i) = ZERO
!       end
!     end
!     rho2a.destroy; rho2f.destroy; d2.destroy
!     rho1a.destroy; rho1f.destroy; d1.destroy
!     rho0a.destroy; rho0f.destroy; d0.destroy
!   end

   stockholder_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld stockholder density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_stockholder_density_grid(g,pt)
   end

!  ===================
!  Hirshfeld atom grid
!  ===================

   make_Hirshfeld_atom_grid
   ! Work out the Hirshfeld atom density density on ".plot_grid" 
   ! for ".plot_grid.center_atom"
      self :: IN

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.center_atom>0, "no center_atom to plot")
   ENSURE(.density_matrix.is_associated_with_genre("restricted"), "no restricted density matrix")

      grid :: VEC{REAL}*
      pt,D :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the hirshfeld atom density
      D => .density_matrix.restricted
      .:make_Hirshfeld_atom_grid(grid,pt,.plot_grid.center_atom,D)

      ! Make the plot label
      label = "hirshfeld_atom_"
      label = trim(label) // trim(.plot_grid.center_atom.to_str)
      label = trim(label) // "_density_grid"

      ! Print out
      .:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_Hirshfeld_atom_grid(N0,pt,c,D) ::: PURE
   ! Make the hirshfeld atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". Density "N0" weighted by
   ! Hirshfeld partition weight for atom "c".
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      ! Overlapping atom electron density
      .:make_overlapping_atom_density(N0,pt,c,D)

      ! Apply stockholder weight function for atom "c" to "N0".
      ! If using interpolatators, then overlapping_atoms
      ! are not needed ... otherwise nothing is skipped
      .:apply_stockholder_atom_weight(N0,c,pt)

   end

   make_overlapping_atom_density(N0,pt,c,D) ::: PURE
   ! Make the overlapping atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". 
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0 :: MAT{REAL}*
      DD :: MAT{REAL}@
      sha :: SHELL1*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Grid size
      n_pt = pt.dim1

      ! Initialise N0
      N0 = ZERO

      ! Basis function cutoff
      cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,.overlapping_atoms_for_atom(c).element.dim

         oa  = .overlapping_atoms_for_atom(c)[ca]
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Create shell "sa"
            sha.create_copy(.precomputed_basis_shellpair(ba,1).a,pos=ra)

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            sha.make_skip_grid(grida0,n_keep,xa,ya,za,a2,skipa,n_pt)
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = .overlapping_atoms_for_atom(c)[cb]
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.disassociated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element
                  gridb0 => bf_grid0(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end

            sha.destroy

         end       ! -- lops ca,cb
      end

      ! Clean up
      bf_grid0.destroy
      bf_skip.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy

   end

!  =====================
!  Stockholder atom grid
!  =====================

   apply_stockholder_atom_weight(grid,a,pt) ::: PURE
   ! Apply i.e. multiply the "grid" by the stockholder weight function
   ! for the atom with index "a" using supplied points "pt".
   ! * If .use_interpolators is TRUE then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom (however the
   !   overlapping_atoms array will not be used to eliminate work).
   !   More likely the density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      Wa :: VEC{REAL}*
      n_pt :: INT

      ! Only needed for more than one atom
      if (.n_atom>1) then

         ! Get weights
         n_pt = pt.dim1
         Wa.create(n_pt)
         if (.use_interpolators) then
            ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")
            .:make_stockholder_atom_grid_int(Wa,a,pt,.overlapping_atoms_for_atom(a).element)
         else
            .:make_stockholder_atom_grid_acc(Wa,a,pt)
         end

         ! Apply them
         grid = grid*Wa

         ! Clean
         Wa.destroy

      end

   end

   make_stockholder_atom_grid(grid,a,pt,overlapping_atom) ::: PURE
   ! Make the Hirshfeld stockholder density "grid" for the atom with
   ! index "a" using supplied points "pt".
   ! * If .use_interpolators is TRUE and "overlapping_atoms" is
   !   supplised then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom. More likely the
   !   density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, optional, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      if (.n_atom>1) then

         if (.use_interpolators) then
            ENSURE(present(overlapping_atom),"no overlapping_atom")
            .:make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom)
         else
            .:make_stockholder_atom_grid_acc(grid,a,pt)
         end

      else

         grid = ONE

      end

   end

   make_stockholder_atom_grid_acc(grid,a,pt) ::: private, PURE
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt".
   ! NOTE: This DOES NOT USE an interpolated density for each atom
   ! UNLESS use_interpolators is explicitly set. In this case you
   ! should probably use the next routine which uses the
   ! overlapping_atoms.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}*
      n_pt,i :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_density_grid(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do i = 1,.n_atom
         if (i==a) cycle
         .atom(i).add_density_grid(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

   make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom) ::: private, PURE
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt" and given a list of
   ! "overlapping_atom". This makes use of a previously calculated
   ! interpolated density for each atom.
   ! NOTE: the CLUSTER_ATOM_DENSITY_CUTOFF must be the same as the
   ! BECKE_GRID_BASIS_FUNCTION_CUTOFF
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}*
      n_pt,i,j :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_interpolated_density(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do j = 1,overlapping_atom.dim
         i = overlapping_atom(j)
         if (i==a) cycle
         .atom(i).add_interpolated_density(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

!  ====================
!  Jayatilaka atom grid
!  ====================

   make_Jayatilaka_atom_grid
   ! Work out the Jayatilaka atom density density on ".plot_grid" 
   ! for ".plot_grid.center_atom"
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.center_atom>0, "no center_atom to plot")
   ENSURE(.density_matrix.is_associated_with_genre("restricted"), "no restricted density matrix")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the hirshfeld atom density
      .:make_Jayatilaka_atom_grid(grid,pt,.plot_grid.center_atom,.density_matrix.restricted)

      ! Make the plot label
      label = "jayatilaka_atom_"
      label = trim(label) // trim(.plot_grid.center_atom.to_str)
      label = trim(label) // "_density_grid"

      ! Print out
      .:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_Jayatilaka_atom_grid(N0,pt,c,D)
   ! Make the Jayatilaka atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". Density "N0" weighted by
   ! Jayatilaka partition weight for atom "c" which is
   !    w(r)   = y_c(r)/sum_a y_a
   !    y_c(r) = [rho_c(r) - rho_c(0)]^{-1}
   !  rho_c(r) = rho(0) exp(- 2 Z_c r)
   ! where rho(0) is the molecular density at the position of atom c.
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.associated,"no overlapping_atoms")

      ! Overlapping atom electron density
      .:make_overlapping_atom_density(N0,pt,c,D)

      ! Apply weight
      .:apply_Jayatilaka_atom_weight(N0,c,pt)

   end

   apply_Jayatilaka_atom_weight(grid,a,pt)
   ! Apply i.e. multiply the Jayatilaka weight to "grid" for the atom
   ! with index "a" using supplied points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      Wa :: VEC{REAL}*
      n_pt :: INT

      ! Only needed for more than one atom
      if (.n_atom>1) then

         ! Get weights
         n_pt = pt.dim1
         Wa.create(n_pt)
         .:make_Jayatilaka_atom_weight(Wa,a,pt)

         ! Apply them
         grid = grid*Wa

         ! Clean
         Wa.destroy

      end

   end

   make_Jayatilaka_atom_weight(wt,a,pt) ::: private
   ! Make the Jayatilaka grid "g" for the atom with index "a" using
   ! supplied points "pt".
   !    w(r)   = y_c(r)/sum_a y_a
   !    y_c(r) = [rho_c(r) - rho_c(0)]^{-1}
   !  rho_c(r) = rho(0) exp(- 2 Z_c r)
   ! where rho(0) is the molecular density at the position of atom c.
   ! NOTE: This DOES NOT USE an interpolated density for each atom
   ! UNLESS use_interpolators is explicitly set. In this case you
   ! should probably use the next routine which uses the
   ! overlapping_atoms.
      self :: IN
      wt :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(wt.dim==pt.dim1,"wrong size, wt")


      pos :: MAT{REAL}*
      rho_0,rho_a :: VEC{REAL}*
      n_pt,i :: INT

      ! No. of points
      n_pt = wt.dim

      ! Get electron densities at each atom nucleus
      rho_0.create(n_pt)
      pos.create(.atom.dim,3)
      .atom.put_coordinates_to(pos,positions_as_rows=TRUE)
      .:make_density_grid(rho_0,pos)
      pos.destroy

      ! Make density "rho_a" for atom "a"
      rho_a.create(n_pt)
      .atom(a).make_exponential_densities(rho_a,pt,rho_0(a))

      ! Sum remaining into "wt"
      wt = rho_a
      do i = 1,.n_atom
         if (i==a) cycle
         .atom(i).add_exponential_densities(wt,pt,rho_0(i))
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (wt(i)>epsilon(ONE)) then; wt(i) = rho_a(i)/wt(i)
         else;                         wt(i) = ZERO
         end
      end
      rho_a.destroy
      rho_0.destroy

   end

!  ================
!  Promolecule grid
!  ================

   make_promolecule_density_grid ::: get_from(prop_grid, GRID=>:make_promolecule_density_grid, LABEL=>"promolecule_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_promolecule_density_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_density_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
   end

   promolecule_density_grid(g,pt) ::: selfless
   ! Work out the promolecule density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_promolecule_density_grid(g,pt)
   end


   make_spherical_atom_grid ::: get_from(prop_grid, GRID=>:make_spherical_atom_grid, LABEL=>"spherical_atom_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_spherical_atom_grid(density_grid,pt)
   ! Work out the promolecule "density_grid" from the supplied points "pt".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.plot_grid.associated,"no plot_grid")
   ENSURE(.plot_grid.center_atom>0,"no plot_grid center atom")

      .atom(.plot_grid.center_atom).make_density_grid(density_grid,pt)

   end

!  =======================
!  Grad rho on rho density
!  =======================

   make_grad_rho_on_rho_grid ::: get_from(prop_grid, GRID=>:make_grad_rho_on_rho_grid, LABEL=>"grad_rho_on_rho_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_grad_rho_on_rho_grid(grid,pt)
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim1==grid.dim,"array dimensions do not match")

      rho :: VEC{REAL}*
      grad_rho :: MAT{REAL}*
      n_pt,i :: INT

      n_pt = pt.dim1

      rho.create(n_pt)
      grad_rho.create(n_pt,3)

      rho = ZERO
      grid=ZERO

      .:make_density_grid(rho,pt)
      .:make_nabla_density_grid(grad_rho,pt)

      do i=1,n_pt
         if (rho(i)>ZERO) then
            grid(i)=sqrt(dot_product(grad_rho(i,:),grad_rho(i,:)))/rho(i)
         else
            grid(i)=ZERO
         end
      end

      grad_rho.destroy
      rho.destroy

   end

   grad_rho_on_rho_grid(g,pt) ::: selfless
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_grad_rho_on_rho_grid(g,pt)
   end

!  =============
!  ELI-D density
!  =============

   make_ELI_D_grid ::: get_from(prop_grid, GRID=>:make_ELI_D_grid, LABEL=>"ELI_D_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ELI_D_grid(ELI_grid,pt)
   ! Work out the Electron Localisation Indicator (D) (ELI) density "ELI_grid"
   ! on a set of grid points "pt", using ".natural orbitals" and the ".occupation"
   ! number vector.
     ELI_grid :: VEC{REAL}
     pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

     if (trim(.natural_orbitals.number_kind)=="real") then
        .:make_ELI_D_grid_r(ELI_grid,pt)
     else
        DIE("no complex implementation")
     end

   end

   make_ELI_D_grid_r(ELI_grid,pt)
   ! Work out the Electron Localisation Indicator (D) grid (ELI_D) density
   ! on a set of grid points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
   ! Reference: Wagner et al (2007), Chem Eur. J. 13, p. 5724
   ! (Look at appendix for definition of g!)
      ELI_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "natural orbitals must be restricted")

      DD :: MAT{REAL}*
      g,gx,gy,gz,rho_s,rhox,rhoy,rhoz,tau,NO :: VEC{REAL}*
      i,n_pt :: INT

      ! No of grid points
      n_pt = pt.dim1

      rho_s.create(n_pt)
      rho_s  = ZERO

      ! Make the density of alpha electrons
      .:make_density_grid(rho_s,pt)
      rho_s = HALF*rho_s

      ! Temporaries
      g.create(n_pt);     g     = ZERO
      tau.create(n_pt);   tau   = ZERO
      rhox.create(n_pt);  rhox  = ZERO
      rhoy.create(n_pt);  rhoy  = ZERO
      rhoz.create(n_pt);  rhoz  = ZERO

      NO.create(n_pt)
      DD.create(n_pt,3)

      ! Sum the orbital gradient and density gradient bit
      parallel do i = 1,.BASE:no_of_occupied_NOs

         .:make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)

         ! Orbital gradients
         gx => DD(:,1)
         gy => DD(:,2)
         gz => DD(:,3)

         ! Fermi hole curvature
         g = g + rho_s * (gx*gx + gy*gy + gz*gz)

         ! This is only the orbital gradient part
         rhox = rhox + gx*NO
         rhoy = rhoy + gy*NO
         rhoz = rhoz + gz*NO

      end

      DD.destroy
      NO.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(g)
         PARALLEL_SUM(tau)
         PARALLEL_SUM(rhox)
         PARALLEL_SUM(rhoy)
         PARALLEL_SUM(rhoz)
      end

      g = g - rhox*rhox - rhoy*rhoy - rhoz*rhoz

      ELI_grid = rho_s * (12.0d0/g)**(THREE/EIGHT)

      ! Clean up
      rhoz.destroy
      rhoy.destroy
      rhox.destroy
      tau.destroy
      g.destroy
      rho_s.destroy

   end

   ELI_D_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Indicator (ELI-D) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_ELI_D_grid(g,pt)
   end

!  ===========
!  ELF density
!  ===========

   make_ELF_grid ::: get_from(prop_grid, GRID=>:make_ELF_grid, LABEL=>"ELF_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ELF_grid(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density "g" on a set of
   ! grid points "pt", using ".natural orbitals" and the ".occupation" number
   ! vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .:make_ELF_grid_r(ELF_grid,pt)
      else
         .:make_ELF_grid_c(ELF_grid,pt)
      end

   end

   make_ELF_grid_r(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "natural orbitals must be restricted")

      DD :: MAT{REAL}*
      mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do i = 1,n_occ

         .:make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation_numbers.restricted(i)

         do n = 1,n_pt
           mo_val_n  = mo_val(n)
           gx_n      = gx(n)
           gy_n      = gy(n)
           gz_n      = gz(n)
           occ_mo    = occu*mo_val_n
           rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
           tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
           rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
           rho_sy(n) = rho_sy(n) + occ_mo*gy_n
           rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end

      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy
      rho_sy.destroy
      rho_sx.destroy
      tau.destroy

      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      ! this could be more efficient if the d0_s*d0_s is written
      ! factor2*rho_s**(TWO+FIVE/THREE)
      d0_s.destroy; d_s.destroy

   end

   make_ELF_grid_c(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      mo_val,gx,gy,gz,NO :: VEC{CPX}*
      DD :: MAT{CPX}*
      rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s :: VEC{REAL}*
      occu,factor :: REAL
      n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do n = 1,n_occ

         .:make_nabla_orbital_grid_c(DD,NO,.natural_orbitals.restricted_complex(:,n), pt)

         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)

         occu   = HALF*.occupation_numbers.restricted(n)
         rho_s  = rho_s  + occu * RE(conjg(mo_val)*mo_val)
         tau    = tau    + occu * RE(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
         rho_sx = rho_sx + occu * RE(conjg(gx)*mo_val) ! this is half grad_x rho_s
         rho_sy = rho_sy + occu * RE(conjg(gy)*mo_val)
         rho_sz = rho_sz + occu * RE(conjg(gz)*mo_val)

      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy
      rho_sy.destroy
      rho_sx.destroy
      tau.destroy

      d0_s.create(n_pt)

      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      d0_s.destroy; d_s.destroy

   end

   ELF_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Function (ELF) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_ELF_grid(g,pt)
   end

!  =====================
!  Tsirelson ELF density
!  =====================

   make_Tsirelson_ELF_grid ::: get_from(prop_grid, GRID=>:make_Tsirelson_ELF_grid, LABEL=>"Tsirelson-Stash_ELF_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_Tsirelson_ELF_grid(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
         .:make_Tsirelson_ELF_grid_r(ELF_grid,pt)
      else
         .:make_Tsirelson_ELF_grid_c(ELF_grid,pt)
      end

   end

   make_Tsirelson_ELF_grid_r(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      DD,LL :: MAT{REAL}*
      mo_val,gx,gy,gz,lx,ly,lz,rho,rho_x,rho_y,rho_z,lap,d_p,d_0,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO

      n_pt = pt.dim1
      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do i = 1,n_occ

         .:make_laplacian_orbital_grid_r(LL,DD,NO,.natural_orbitals.restricted(:,i), pt)

         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)

         occu = .occupation_numbers.restricted(i)

         do n = 1,n_pt

            mo_val_n = mo_val(n)
            gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
            lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)

            occ_mo   = occu*mo_val_n                        ! this is n_i phi_i
            rho(n)   = rho(n)   + occ_mo*mo_val_n           ! this is rho
            rho_x(n) = rho_x(n) + occ_mo*gx_n               ! this is half grad_x rho
            rho_y(n) = rho_y(n) + occ_mo*gy_n
            rho_z(n) = rho_z(n) + occ_mo*gz_n
            lap(n)   = lap(n)   + occ_mo*(lx_n+ly_n+lz_n) & ! this is half nabla^2 rho
                                + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
         end

      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE

      lap.destroy

      rho_z.destroy
      rho_y.destroy
      rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

   make_Tsirelson_ELF_grid_c(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      mo_val,gx,gy,gz,lx,ly,lz,NO :: VEC{CPX}*
      DD,LL :: MAT{CPX}*
      rho,rho_x,rho_y,rho_z,lap,d_0,d_p :: VEC{REAL}*
      occu,factor :: REAL
      mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: CPX
      n_occ,n_pt,n,i :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1

      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do i = 1,n_occ

         .:make_laplacian_orbital_grid_c(LL,DD,NO,.natural_orbitals.restricted_complex(:,i), pt)

         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)

         occu = .occupation_numbers.restricted(i)

         do n = 1,n_pt

           mo_val_n = mo_val(n)
           gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
           lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)

           occ_mo   = occu*mo_val_n                                          ! this is n_i phi_i
           rho(n)   = rho(n)   + RE(occ_mo*conjg(mo_val_n)) ! this is rho
           rho_x(n) = rho_x(n) + RE(occ_mo*conjg(gx_n))     ! this is half grad_x rho
           rho_y(n) = rho_y(n) + RE(occ_mo*conjg(gy_n))
           rho_z(n) = rho_z(n) + RE(occ_mo*conjg(gz_n))
                                                        ! this is half nabla^2 rho
           lap(n)   = lap(n) + RE(occ_mo*(conjg(lx_n)+conjg(ly_n)+conjg(lz_n))) &
                        + occu*RE(conjg(gx_n)*gx_n+conjg(gy_n)*gy_n+conjg(gz_n)*gz_n)
         end

      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE

      lap.destroy
      rho_z.destroy
      rho_y.destroy
      rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

   Tsirelson_ELF_grid(g,pt) ::: selfless
   ! Work out the Tsirelson-Stash version of the Electron Localisation Function
   ! (ELF) density "g" for a series of points "pt" for using the ".natural
   ! orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_Tsirelson_ELF_grid(g,pt)
   end

!  ======================
!  Fermi mobility density
!  ======================

   make_fermi_mobility_grid ::: get_from(prop_grid, GRID=>:make_fermi_mobility_grid, LABEL=>"fermi_mobility_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_fermi_mobility_grid(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      f :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .:make_fermi_mobility_grid_r(f,pt)
      else
         DIE("code not written yet")
      end

   end

   make_fermi_mobility_grid_r(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      del_gi :: MAT{REAL}*
      dg,gi,rho,dgx,dgy,dgz,orb :: VEC{REAL}*
      n,n_pt,i,n_occ :: INT
      delx,dely,delz,fac :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      gi.create(n_pt)
      del_gi.create(n_pt,3)

      do i = 1,n_occ

         orb => .natural_orbitals.restricted(:,i)

         .:make_nabla_orbital_grid_r(del_gi,gi,orb,pt)

         do n = 1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end

      end

      del_gi.destroy
      gi.destroy

      rho.create(n_pt)
      .:make_density_grid(rho,pt)

      fac = (THREE*PI/FOUR) * HALF**TWOTHIRD
      f = ONE/rho * (dg - TWO*(dgx*dgx + dgy*dgy + dgz*dgz)/rho) - fac * rho**TWOTHIRD

      rho.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

   fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's fermi mobility density on a series of grid points "g"
   ! using ".natural orbitals" and the ".occupation_numbers" vector. A Gnuplot
   ! ascii file is generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_fermi_mobility_grid(g,pt)
   end

!  ===========================
!  True Fermi mobility density
!  ===========================

   make_true_fermi_mobility_grid ::: get_from(prop_grid, GRID=>:make_true_fermi_mobility_grid, LABEL=>"true_fermi_mobility_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_true_fermi_mobility_grid(f,pt)
   ! Work out the the true fermi mobility density "f" on a series of grid points
   ! "pt" using ".natural orbitals" and the ".occupation_numbers" vector. The
   ! true function differs from that above in that the kinetic energy density is
   ! evaluated exactly.
      f :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .:make_true_fermi_mobil_grid_r(f,pt)
      else
         DIE("code not written yet")
      end

   end

   make_true_fermi_mobil_grid_r(f,pt)
   ! Evaluate the true Fermi hole mobility grid "f" on a set of grid points
   ! "pt".  The true function differs from that above in that the kinetic energy
   ! density is evaluated exactly.
   ! NOTE: this routine is only valid for single determinant wavefunctions.
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.kinetic_energy_matrix.associated, "no kinetic energy matrix")

      dg,rho,NO,K,gj,Tj :: VEC{REAL}*
      dgx,dgy,dgz,gi :: VEC{REAL}*
      n,n_pt,i,j,n_occ :: INT
      delx,dely,delz :: REAL
      del_gi,g,T :: MAT{REAL}*

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      g.create(n_pt,n_occ)
      del_gi.create(n_pt,3)

      ! Assemble intermediate terms
      do i = 1,n_occ

         NO => .natural_orbitals.restricted(:,i)
         gi => g(:,i)

         .:make_nabla_orbital_grid_r(del_gi,gi,NO,pt)

         do n = 1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end

      end

      del_gi.destroy

      ! Make kinetic energy matrix part
      K.create(n_pt)
      K = ZERO
      T.create(.n_bf,.n_bf)
      T = .kinetic_energy_matrix.restricted
      T.change_basis_using(.natural_orbitals.restricted)

      do j = 1,n_occ
         gj => g(:,j)
         Tj => T(:,j)
         do i = 1,n_occ
            K = K + g(:,i)*gj(:)*Tj(i)
         end
      end
      T.destroy

      ! Now do the final assembly
      rho.create(n_pt)
      .:make_density_grid(rho,pt)
      f = ONE/rho * (dg - TWO*(dgx*dgx+dgy*dgy+dgz*dgz)/rho - TWO*K)

      ! Clean
      rho.destroy
      K.destroy
      g.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

   true_fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's true fermi mobility density (the one using kinetic
   ! energy matrix elements) on a series of grid points "g" using ".natural
   ! orbitals" and the ".occupation_numbers" vector. A Gnuplot ascii file is
   ! generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_true_fermi_mobility_grid(g,pt)
   end

!  ==============
!  Electric Field
!  ==============

   field_grid ::: template
   ! Work out the field density on ".plot_grid" and dump output

   ENSURE(.plot_grid.associated, "no grid")

      field :: MAT{REAL}*
      fx,fy,fz :: VEC{REAL}*
      pt :: MAT{REAL}*

      ! Make space for the field and grid points
      field.create(.plot_grid.n_pt,3)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the grid of field values
      .FIELD(field,pt)

      ! Assign field components
      fx => field(:,1)
      fy => field(:,2)
      fz => field(:,3)

      ! Print out
      .:dump_plot_grid(fx,LABEL//".x")
      .:dump_plot_grid(fy,LABEL//".y")
      .:dump_plot_grid(fz,LABEL//".z")

      ! Get the magnitude
      fx = sqrt(fx*fx+fy*fy+fz*fz)

      ! Print out
      .:dump_plot_grid(fx,LABEL//".magnitude")

      ! Clean up
      pt.destroy
      field.destroy

   end

   make_E_field_grid ::: get_from(field_grid, FIELD=>:make_E_field_grid, LABEL=>"E_field")
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_E_field_grid(E,pt)
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      self :: IN
      E :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.has_any_genre,"no density matrix")
   ENSURE(E.dim1==pt.dim1,"wrong dim1, E & pt")
   ENSURE(E.dim2==3,      "wrong dim2, E")

      D,Dba,Ex,Ey,Ez :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! The imaginary part of AO density matrix
      D.create(.n_bf,.n_bf)
      .BASE:make_ao_density_matrix(D)

      ! Initialize
      E = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the density matrix
        Dba.create(nb,na)
        Dba = D(fb:lb,fa:lb)

        ! Electric field integrals
        Ex.create(na,nb)
        Ey.create(na,nb)
        Ez.create(na,nb)

        ! Loop over points
        do p = 1,n_pt

           sh.make_E_field_ints(Ex,Ey,Ez,pt(p,:))

           fac = TWO
           if (fa==fb) FAC = ONE

           E(p,1) = E(p,1) + Ex.trace_product_with(Dba)
           E(p,2) = E(p,2) + Ey.trace_product_with(Dba)
           E(p,3) = E(p,3) + Ez.trace_product_with(Dba)

        end

        ! Clean
        Ez.destroy
        Ey.destroy
        Ex.destroy
        Dba.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      D.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(E)
      end

   end

!  ==============
!  Magnetic Field
!  ==============

   make_B_field_grid
   ! Work out the field density on ".plot_grid" and dump output
   ENSURE(.plot_grid.associated, "no grid")

      B_L,B_S :: MAT{REAL}*
      fx,fy,fz,mag :: VEC{REAL}*
      pt :: MAT{REAL}*

      if(.plot_grid.points_filename/="no_made-up_points") then

         stdout.text("=====================================")
         stdout.text("use of read-in grid to be implemented")
         stdout.text("TONTO will stop here ...")
         stdout.text("=====================================")
         DIE("die")

      else

      ! Make space for the field and grid points
      B_L.create(.plot_grid.n_pt,3)
      B_S.create(.plot_grid.n_pt,3)
      mag.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

        ! Make the grid of field values
  !      .:make_B_field_grid(B_L,B_S,pt)
        .:make_B_L_field_grid(B_L,pt)
        .:make_B_S_field_grid(B_S,pt)

        ! Print B_L field components
        fx => B_L(:,1)
        fy => B_L(:,2)
        fz => B_L(:,3)
        .:dump_plot_grid(fx,"B_L_field.x")
        .:dump_plot_grid(fy,"B_L_field.y")
        .:dump_plot_grid(fz,"B_L_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .:dump_plot_grid(mag,"B_L_field.magnitude")

        ! Print B_S field components
        fx => B_S(:,1)
        fy => B_S(:,2)
        fz => B_S(:,3)
        .:dump_plot_grid(fx,"B_S_field.x")
        .:dump_plot_grid(fy,"B_S_field.y")
        .:dump_plot_grid(fz,"B_S_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .:dump_plot_grid(mag,"B_S_field.magnitude")

        ! Print B field components
        B_L = B_L + B_S
        fx => B_L(:,1)
        fy => B_L(:,2)
        fz => B_L(:,3)
        .:dump_plot_grid(fx,"B_field.x")
        .:dump_plot_grid(fy,"B_field.y")
        .:dump_plot_grid(fz,"B_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .:dump_plot_grid(mag,"B_field.magnitude")

      end

      ! Clean up
      pt.destroy
      B_S.destroy
      B_L.destroy

   end

!   make_B_field_grid(B_L,B_S,pt)
!   ! Make the magnetic field "B" field due to the linear current and
!   ! the spin current on a series of points "pt"
!      B_L,B_S :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.has_any_genre,"no density matrix")
!
!      M :: MAT4{REAL}*
!      S :: MAT3{REAL}*
!      D,DD,S1,S2,S3,J1,J2,J3 :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! The imaginary part of AO density matrix
!      D.create(.n_bf,.n_bf)
!      .BASE:make_ao_IM_density_matrix(D)
!
!      ! Make the real part of AO spin density matrix
!      S.create(.n_bf,.n_bf,3)
!      .BASE:make_ao_RE_spin_densities(S)
!
!      ! Initialize
!      B_L = ZERO
!      B_S = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
!
!        ! Get the density matrix
!        DD.create(nb,na); DD = D(fb:lb,fa:la)
!
!        ! Get the spin density matrix
!        S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
!        S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
!        S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
!
!        ! Space for integrals
!        M.create(na,nb,3,3)
!        J1 => M(:,:,1,1)
!        J2 => M(:,:,2,2)
!        J3 => M(:,:,3,3)
!
!        ! Loop over points
!        do p = 1,n_pt
!
!           ! Make the B-field integrals for point k
!           sh.make_nabla_field_ints(M,pt(p,:))
!
!           ! Factor
!           fac =TWO
!           if (fa==fb) fac = ONE
!
!           ! Sum over the spin density matrices
!           ! Factor 2 should be put here, since S ints are symmetric so it
!           ! is introduced once at the end
!           B_S(p,2) = B_S(p,2) + fac*M(:,:,2,1).trace_product_with(S1)
!           B_S(p,3) = B_S(p,3) + fac*M(:,:,3,1).trace_product_with(S1)
!           B_S(p,1) = B_S(p,1) - fac*M(:,:,2,2).trace_product_with(S1)
!           B_S(p,1) = B_S(p,1) - fac*M(:,:,3,3).trace_product_with(S1)
!
!           B_S(p,1) = B_S(p,1) + fac*M(:,:,1,2).trace_product_with(S2)
!           B_S(p,3) = B_S(p,3) + fac*M(:,:,3,2).trace_product_with(S2)
!           B_S(p,2) = B_S(p,2) - fac*M(:,:,1,1).trace_product_with(S2)
!           B_S(p,2) = B_S(p,2) - fac*M(:,:,3,3).trace_product_with(S2)
!
!           B_S(p,1) = B_S(p,1) + fac*M(:,:,1,3).trace_product_with(S3)
!           B_S(p,2) = B_S(p,2) + fac*M(:,:,2,3).trace_product_with(S3)
!           B_S(p,3) = B_S(p,3) - fac*M(:,:,1,1).trace_product_with(S3)
!           B_S(p,3) = B_S(p,3) - fac*M(:,:,2,2).trace_product_with(S3)
!
!           ! Cross product part
!           J1 = M(:,:,2,3) - M(:,:,3,2)
!           J2 = M(:,:,3,1) - M(:,:,1,3)
!           J3 = M(:,:,1,2) - M(:,:,2,1)
!
!           ! Get magnetic field contribution
!           ! Extra factor 2 needed from left derivative in M
!           ! is deferred to end.
!           B_L(p,1) = B_L(p,1) + fac*J1.trace_product_with(DD)
!           B_L(p,2) = B_L(p,2) + fac*J2.trace_product_with(DD)
!           B_L(p,3) = B_L(p,3) + fac*J3.trace_product_with(DD)
!
!        end
!
!        ! Clean
!        M.destroy
!        S3.destroy; S2.destroy; S1.destroy
!        DD.destroy
!        sh.destroy_ptr_part
!
!      end
!
!      ! Clean
!      S.destroy
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B_S)
!         PARALLEL_SUM(B_L)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B_L = fac*B_L
!
!      ! Spin Factor
!  !    fac = -G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!  ! minus sign is cancelled by that of the Bohr magneton,
!  ! the 1/2 of the bohr magneton is cancelled from a factor 2
!  ! arising in simplification by symmetry of the formula
!      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B_S = fac*B_S
!
!   end

   make_B_L_field_grid ::: get_from(field_grid, FIELD=>:make_B_L_field_grid, LABEL=>"B_L_field")
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_B_L_field_grid(B,pt)
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.has_any_genre,"no density matrix")

      Mleft,Mright :: MAT4{REAL}*
      D,Dba,J1,J2,J3 :: MAT{REAL}*
      Dab,J4,J5,J6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! The imaginary part of AO density matrix
      D.create(.n_bf,.n_bf)
      .BASE:make_ao_IM_density_matrix(D)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the density matrix
        Dab.create(na,nb)
        Dab = D(fa:la,fb:lb)
        Dba.create(nb,na)
        Dba = D(fb:lb,fa:la)

        ! Space for integrals
        Mleft.create(nb,na,3,3)
        Mright.create(na,nb,3,3)
        J1 => Mright(:,:,1,1)
        J2 => Mright(:,:,2,2)
        J3 => Mright(:,:,3,3)
        J4 => Mleft(:,:,1,1)
        J5 => Mleft(:,:,2,2)
        J6 => Mleft(:,:,3,3)

        ! Loop over points
        do p = 1,n_pt

           if (fa==fb) then

             ! Make the B-field integrals for point k
             sh.make_nabla_field_ints(Mright,pt(p,:))

             ! Cross product part
             J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
             J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
             J3 = Mright(:,:,1,2) - Mright(:,:,2,1)

             ! Get magnetic field contribution
             B(p,1) = B(p,1) + J1.trace_product_with(Dba)
             B(p,2) = B(p,2) + J2.trace_product_with(Dba)
             B(p,3) = B(p,3) + J3.trace_product_with(Dba)

           else

             ! Make the B-field integrals for point k
             sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

             ! Cross product part
             J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
             J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
             J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
             J4 = Mleft(:,:,2,3) - Mleft(:,:,3,2)
             J5 = Mleft(:,:,3,1) - Mleft(:,:,1,3)
             J6 = Mleft(:,:,1,2) - Mleft(:,:,2,1)

             ! Get magnetic field contribution
             B(p,1) = B(p,1) + J1.trace_product_with(Dba)
             B(p,2) = B(p,2) + J2.trace_product_with(Dba)
             B(p,3) = B(p,3) + J3.trace_product_with(Dba)
             B(p,1) = B(p,1) + J4.trace_product_with(Dab)
             B(p,2) = B(p,2) + J5.trace_product_with(Dab)
             B(p,3) = B(p,3) + J6.trace_product_with(Dab)

           end

        end

        ! Clean
        Mleft.destroy
        Mright.destroy
        Dba.destroy
        Dab.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      D.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Minus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end

!   make_B_L_field_grid_checked(B,pt)
!   ! Make the magnetic field "B" field due to the linear current on a
!   ! series of points "pt"
!      B :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.has_any_genre,"no density matrix")
!
!      D :: MAT{REAL}*
!      Dba :: MAT{REAL}*
!      Jx,Jy,Jz :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, k,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! Make the AO density matrix
!      D.create(.n_bf,.n_bf)
!      .BASEmake_ao_IM_density_matrix(D)
!
!      ! Initialize
!      B = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
!        fac = TWO
!        if (fa==fb) fac = ONE
!
!        ! Get the density matrix
!        Dba.create(nb,na)
!        Dba = D(fb:lb,fa:la)
!
!        ! Space for integrals
!        Jx.create(na,nb)
!        Jy.create(na,nb)
!        Jz.create(na,nb)
!
!        ! Loop over points
!        do k = 1,n_pt
!
!           ! Make the integrals for point k
!           sh.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
!
!           ! Get magnetic field contribution
!           B(k,1) = B(k,1) + fac*Jx.trace_product_with(Dba)
!           B(k,2) = B(k,2) + fac*Jy.trace_product_with(Dba)
!           B(k,3) = B(k,3) + fac*Jz.trace_product_with(Dba)
!
!        end
!
!        ! Clean
!        Jz.destroy; Jy.destroy; Jx.destroy
!        Dba.destroy
!        sh.destroy_ptr_part
!
!      end
!
!      ! Clean
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -HALF/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B   = fac*B
!
!   end

   make_B_S_field_grid ::: get_from(field_grid, FIELD=>:make_B_S_field_grid, LABEL=>"B_S_field")
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_B_S_field_grid(B,pt)
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.has_any_genre,"no density matrix")

      ! Not the most efficient, but should work ...
      if (.density_matrix.alpha.associated) then; .:make_B_S_field_grid_u(B,pt)
      else;                                    .:make_B_S_field_grid_gc(B,pt)
      end

   end

   make_B_S_field_grid_u(B,pt)
   ! Make the magnetic field "B" field due to the spin current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.alpha.associated,"no alpha density matrix")
   ENSURE(.density_matrix.beta.associated,"no beta density matrix")

      Mright,Mleft :: MAT4{REAL}*
      S,S3,S6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO Sz density matrix
      S.create(.n_bf,.n_bf)
      .BASE:make_ao_sz_density_matrix(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the z spin density matrix block
        S3.create(nb,na); S3 = S(fb:lb,fa:la)
        S6.create(na,nb); S6 = S(fa:la,fb:lb)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt

          if (fa==fb) then

            ! Make the B-field integrals for point k
            sh.make_nabla_field_ints(Mright,pt(p,:))


            ! Sum over the spin density matrices
            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)

          else
          ! Make the B-field integrals for point k
          !
            sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)

            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)

          ! To add to make it work even if S is not Hermitian
          ! (useful to test a single matrix element)
          ! but then a factor HALF should be inserted

!
!            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
!
!
!            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)


          end

        end

        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S6.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end

   make_B_S_field_grid_gc(B,pt)
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")

      Mleft,Mright :: MAT4{REAL}*
      S :: MAT3{REAL}*
      S1,S2,S3 :: MAT{REAL}*
      S4,S5,S6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO density matrix
      S.create(.n_bf,.n_bf,3)
      .BASE:make_ao_RE_spin_densities(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the spin density matrix
        S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
        S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
        S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
        S4.create(na,nb); S4 = S(fa:la,fb:lb,1)
        S5.create(na,nb); S5 = S(fa:la,fb:lb,2)
        S6.create(na,nb); S6 = S(fa:la,fb:lb,3)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt


          if (fa==fb) then

          ! Make the B-field integrals for point k
            sh.make_nabla_field_ints(Mright,pt(p,:))


            ! Sum over the spin density matrices
            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)

            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)

            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)

          else
          ! Make the B-field integrals for point k
          !
            sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)

            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)

            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)


            B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S4)
            B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S4)
            B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S4)
            B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S4)

            B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S5)
            B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S5)
            B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S5)
            B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S5)

            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)

          ! To add to make it work even if S is not Hermitian
          ! (useful to test a single matrix element)
          ! but then a factor HALF should be inserted

!            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S4,TRUE)
!            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S4,TRUE)
!            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S4,TRUE)
!            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S4,TRUE)
!
!            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S5,TRUE)
!            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S5,TRUE)
!            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S5,TRUE)
!            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S5,TRUE)
!
!            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
!
!
!            B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S1,TRUE)
!            B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S1,TRUE)
!            B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S1,TRUE)
!            B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S1,TRUE)
!
!            B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S2,TRUE)
!            B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S2,TRUE)
!            B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S2,TRUE)
!            B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S2,TRUE)
!
!            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)
          end
        end

        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S2.destroy
        S1.destroy
        S6.destroy
        S5.destroy
        S4.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B
  !   stdout.text("Bs")
  !   stdout.put(B)
   end

   make_B_L_matrices(Bx,By,Bz,c)
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      Bx,By,Bz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      q,fa,fb,la,lb,na,nb :: INT
      sh :: SHELL2

      ! Initialize
      Bx = ZERO
      By = ZERO
      Bz = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Make the integrals, point c
        sh.make_magnetic_jp_ints(Bx(fa:la,fb:lb),By(fa:la,fb:lb),Bz(fa:la,fb:lb),c)

        ! Clean
        sh.destroy_ptr_part

      end

      ! Symmetrize
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(Bx)
         PARALLEL_SYMMETRIC_SUM(By)
         PARALLEL_SYMMETRIC_SUM(Bz)
      else
         Bx.symmetric_reflect
         By.symmetric_reflect
         Bz.symmetric_reflect
      end

   end

!  ======================================
!  Crystal structure factor residual maps
!  ======================================

   make_residual_density_map ::: leaky
   ! Work out the residual density map on ".plot_grid". A Gnuplot
   ! ascii file is generated. zc
   ENSURE(.plot_grid.associated, "no grid")

      map :: VEC{REAL}*

      map.create(.plot_grid.n_pt)
      .:make_residual_density_map(map)
      .:dump_plot_grid(map,"residual_density_map")
      map.destroy

   end

   make_residual_density_map(map)
   ! Make the crystal error "map".
      map :: VEC{REAL}, OUT

   ENSURE(.plot_grid.associated, "no grid")

      pt :: MAT{REAL}*
      n_pt :: INT

      ! Make pts array
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3)
      .plot_grid.make_points(pt)

      ! Make residual error map
!     .crystal.make_residual_density_map(map,pt)
      .crystal.make_residual_density_cell(map,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)

      ! Clean
      pt.destroy

   end

   make_residual_density_cell ::: leaky
   ! Work out the residual map on the unit cell with divisions as
   ! specified in the ".plot_grid" and write to a file.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")

      map :: VEC{REAL}*

      map.create(.plot_grid.n_pt)

      .:make_residual_density_cell(map)
      .:dump_plot_grid(map,"residual_density_map")

      map.destroy

   end

   make_residual_density_cell(map)
   ! Work out the residual "map" on the unit cell with divisions as
   ! specified in the ".plot_grid".
      self :: IN
      map :: VEC{REAL}, OUT

   ENSURE(.plot_grid.associated, "no grid")

      nx,ny,nz :: INT

      ! Points per axis
      nx = .plot_grid.n_x
      ny = .plot_grid.n_y
      nz = .plot_grid.n_z

      ! Make residual error map
      .crystal.make_residual_density_cell(map,nx,ny,nz)

   end

!  ===========
!  Test sphere
!  ===========

   make_test_sphere_on_atom_1 ::: get_from(prop_grid, GRID=>:make_test_sphere_on_atom_1, LABEL=>"test_sphere_on_atom_1")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_test_sphere_on_atom_1(f,pt)
   ! Work out the test sphere on atom 1 with value 1 at radius 1 bohr
   ! increasing linearly with distance. Can use to check units if you
   ! know bond distances. Results in "f" for points "pts".
      self :: IN
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_info_made, "no atoms")

      i :: INT
      pos,r :: VEC{REAL}(3)

      pos = .atom(1).position

      ! Do it
      do i = 1,pt.dim1

         r = pt(i,:)
         r = r - pos
         f(i) = r.norm

      end

   end

   test_sphere_on_atom_1(f,pt) ::: selfless
   ! Work out the test sphere on atom 1 with value 1 at radius 1 bohr
   ! increasing linearly with distance. Can use to check units if you
   ! know bond distances. Results in "f" for points "pts".
      f  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .:make_test_sphere_on_atom_1(f,pt)
   end

!  ======================
!  Polarizability density
!  ======================

   make_e_polarization_grid
   ! Work out the electric polarization grid, either along a
   ! projection or all three directions and magnitude.

   ENSURE(.plot_grid.associated, "no grid")

      if (.plot_grid.projection_direction.is_zero) then
         .:make_e_polarization_vgrid
      else
         .:make_e_polarization_pgrid
      end

   end

   make_e_polarization_vgrid ::: get_from(field_grid, FIELD=>:make_e_polarization_vgrid, LABEL=>"electric_polarization_density")
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_e_polarization_vgrid(E,pt)
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      E :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.molecular_orbitals.restricted.associated,"no MO's")
   ENSURE(.U_electric_dipole.associated,"no U matrices?")
   ENSURE(E.dim1==pt.dim1, "E and pt: inconsistent no. of points")
   ENSURE(E.dim2==3      , "E : wrong dim2")

      D :: MAT3{REAL}*
      MO :: MAT{REAL}*
      n_occ, i :: INT

      ! Dimensions
      n_occ = .n_a

      ! Get derivative density matrices (restricted only)
      D.create(.n_bf,.n_bf,3)
      MO => .molecular_orbitals.restricted
      do i = 1,3 ! x,y,z electric fields
         .U_electric_dipole(:,:,1).back_transform_to(D(:,:,1),MO(:,n_occ+1:),MO(:,:n_occ))
         D(:,:,i).symmetrize
      end
      D = FOUR*D

      ! Debug
      if (.BASE:debugging("make_e_polarization_grid")) then
         stdout.flush
         stdout.text("Derivative density matrices")
         stdout.put(D)
      end

      ! Make the derivative rho grid
      .:make_derivative_rho_grid(E,pt,D)

      ! Clean
      D.destroy

   end

   make_e_polarization_pgrid ::: get_from(prop_grid, GRID=>:make_e_polarization_pgrid, LABEL=>"electric_polarization_density.projected")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_e_polarization_pgrid(grid,pt)
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}, IN

   ENSURE(grid.dim==pt.dim1, "grid and pt: inconsistent no. of points")

      E :: MAT{REAL}*
      n_pt :: INT

      ! Dimensions
      n_pt  = pt.dim1

      ! Space
      E.create(n_pt,3)

      ! Make electric polarization density
      .:make_e_polarization_vgrid(E,pt)

      ! Do the projection
      grid = E(:,1)*.plot_grid.projection_direction(1) &
           + E(:,2)*.plot_grid.projection_direction(2) &
           + E(:,3)*.plot_grid.projection_direction(3)

      ! Clean
      E.destroy

   end

!  ======================
!  Set interpolator grids
!  ======================

   make_ANO_interpolators ::: leaky
   ! Get the gaussian ANO interpolators
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.BASE:has_all_ANOs_made,"no ANOs")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      template :: INTERPOLATOR*
      a,b :: INT

      ! Skip if already done ...
      if (.atom(1).ANO_interpolators_made) return
      if (.atom(1).interpolators_made) return

      stdout.flush
      stdout.text("Making gaussian ANO interpolators ...")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Make the interpolator
         if (.interpolator.associated) then

            .atom(a).make_interpolator(.interpolator)

         else

            .:make_interpolator_sqrt_x1x(template)
            .atom(a).make_interpolator(template)
            template.destroy

         end

        ! Copy to the other atoms
        do b = a+1,.n_atom

           if (.atom(b).kind/=.atom(a).kind) cycle

           .atom(b).interpolator => .atom(a).interpolator

        end

      end

      .atom.set_ANO_interpolators_made(TRUE)

   end

   make_general_ANO_interpolators ::: leaky
   ! Get the gaussian ANO interpolators
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.BASE:has_all_ANOs_made,"no ANOs")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      template :: INTERPOLATOR*
      a,b :: INT

      ! Skip if already done ...
      if (.atom(1).ANO_interpolators_made) return
      if (.atom(1).interpolators_made) return

      stdout.flush
      stdout.text("Making gaussian ANO interpolators ...")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Make the interpolator
         if (.interpolator.associated) then

            .atom(a).make_general_interpolator(.interpolator)

         else

            .:make_interpolator_sqrt_x1x(template)
            .atom(a).make_general_interpolator(template)
            template.destroy

         end

        ! Copy to the other atoms
        do b = a+1,.n_atom

           if (.atom(b).kind/=.atom(a).kind) cycle

           .atom(b).interpolator => .atom(a).interpolator

        end

      end

      .atom.set_ANO_interpolators_made(TRUE)

   end

   make_slater_interpolators ::: leaky
   ! Make the slaterbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
      self :: INOUT

   ENSURE(.slaterbasis.associated,"no slaterbasis")

      template :: INTERPOLATOR*
      i :: INT

      stdout.flush
      stdout.text("Making slater interpolators ...")

      ! Make the interpolators
      if (.interpolator.associated) then

         ! User defined interpolator
         do i = 1,.slaterbasis.dim
            .slaterbasis(i).make_interpolator(.interpolator)
         end

      else

         ! Default interpolator
         .:make_interpolator_sqrt(template)

         do i = 1,.slaterbasis.dim
           .slaterbasis(i).make_interpolator(template)
         end

         template.destroy

      end

      ! Set .atom to use this interpolator
      if (.atom.associated) .atom.set_basis_kind("slater")

   end

   make_coppens_interpolators ::: leaky
   ! Make the coppensbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ! Otherwise use an atom density cutoff "tol".
   ! NOTE: any existing interpolators are destroyed first
      self :: INOUT

   ENSURE(.coppensbasis.associated,"no slaterbasis")

      template :: INTERPOLATOR*
      i :: INT

      stdout.flush
      stdout.text("Making coppens interpolators ...")

      ! Make the interpolators
      if (.interpolator.associated) then

         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(.interpolator)
         end

      else

         .:make_interpolator_sqrt(template)
         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(template)
         end
         template.destroy

      end

      ! Set .atom to use this interpolator
      if (.atom.associated) .atom.set_basis_kind("coppens")

   end

   make_interpolator_sqrt(interpolator) ::: leaky
   ! Make a non-gaussian interpolator. These typically used for
   ! stockholder weight functions.
      self :: IN
      interpolator :: INTERPOLATOR*

      ! Create default interpolator
      interpolator.create

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.associated) then
      if (.saved.cluster.associated) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt")
      interpolator.set_table_length(900d0)
      interpolator.set_table_spacing(0.1d0)

   end

   make_interpolator_sqrt_x1x(interpolator) ::: leaky
   ! Make a gaussian interpolator.
      self :: IN
      interpolator :: INTERPOLATOR*

      ! Create default interpolator
      interpolator.create

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.associated) then
      if (.saved.cluster.associated) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("cubic_spline")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
      interpolator.set_table_length(ONE)
      interpolator.set_spacing(0.0001d0)

   end

!  ============================
!  Angyan's oscillator orbitals
!  ============================

   make_oscillator_orbital_grid
   ! Work out the oscillator orbital on ".plot_grid" using ".natural orbitals" for
   ! orbital "orb".

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")
   ENSURE(.localiser.associated, "no localiser orbject created")

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      orb :: INT

      orb = .plot_grid.orbital
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      if (trim(.natural_orbitals.number_kind)=="real") then

         gr.create(.plot_grid.n_pt)
         .:make_oscillator_orbital_grid_r(gr,orb,pt)
         .:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
         gr.destroy

      else

         DIE("complex case not yet implemented")

      end

      pt.destroy

   end

   make_oscillator_orbital_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the localised orbital
   ! with index "ind" on a set of grid points "pt". You must supply on the input
   ! line the angular momentum "l" and component "n" of the oscillator orbital,
   ! which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.localiser.associated, "no localiser orbject created")

      os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      l,n :: INT
      sh :: SHELL1

      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)

      stdin.read(l)
      stdin.read(n)

      sh.make_oscillator_orbital_mask(os,c,l,n,pt)
      .:make_orbital_grid_r(g,.localiser.MO(:,ind),pt,square)
      g = g*os

      os.destroy

   end

   make_p_oscillator_orb_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the projected
   ! localised orbital with index "ind" on a set of grid points "pt". You must
   ! supply on the input line the angular momentum "l" and component "n" of the
   ! oscillator orbital, which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.localiser.associated, "no localiser orbject created")

      gg,os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      maxl,l,n,ln, i,j :: INT
      coeff :: REAL
      sh :: SHELL1

      gg.create(pt.dim1)
      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)

      stdin.read(maxl)
      stdin.read(l)
      stdin.read(n)

      .:make_orbital_grid_r(gg,.localiser.MO(:,ind),pt,square)

      ln = GAUSSIAN_DATA:n_comp_up_to(l-1)*.n_a + (ind-1)*GAUSSIAN_DATA:n_comp(l) + n
      g = ZERO
      i = 0
      do l = 0,maxl
      do n = 1,GAUSSIAN_DATA:n_comp(l)
      do j = 1,.n_a
         i = i + 1
         coeff = .localiser.TM(i,ln)
         if (coeff.is_zero) cycle
         sh.make_oscillator_orbital_mask(os,c,l,n,pt)
         g = g + coeff*gg*os
      end
      end
      end

      os.destroy
      gg.destroy

   end

   oscillator_orbital_grid(g,pt) ::: selfless
   ! Work out the oscillator orbital grid "g" for a series of points "pt" for
   ! using the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")

      orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*

      ! Get back self
      .BASE:set_from_saved_self

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.localiser.associated, "no localiser orbject created")

      grid => .isosurface.plot_grid

      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .:make_oscillator_orbital_grid_r(g,orb,pt)
      else
         DIE("complex case not yet implemented")
      end

   end

!  ===============
!  Current density
!  ===============

   make_j_grid
   ! Make the current density on ".plot_grid" using ".natural orbitals"
   ! and the ".occupation_numbers" vector.
   !    J(r) = J_p(r) + J_d(r)
   ENSURE(.plot_grid.associated, "no grid")

      title :: STR
      arch :: ARCHIVE
      j,jd,jp :: MAT{REAL}*

      ! Make jd
      jd.create(.plot_grid.n_pt,3)
      .:make_jd_grid(jd)

      ! Make jp
      jp.create(.plot_grid.n_pt,3)
      .:make_jp_grid(jp)

      ! Add
      jd = jd + jp

      ! Dump?
      j => jd

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      arch.set(title,"current_density")
      arch.write(j)
      arch.set(title,"current_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(title,"current_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(title,"current_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy
      jd.destroy

   end

   make_jd_grid
   ! Work out the diamagnetic current density on ".plot_grid" using ".natural
   ! orbitals" and the ".occupation_numbers" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)

   ENSURE(.plot_grid.associated, "no grid")

      title :: STR
      arch :: ARCHIVE
      jd :: MAT{REAL}*

      ! Make grid
      jd.create(.plot_grid.n_pt,3)
      .:make_jd_grid(jd)

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      ! Dump
      arch.set(title,"jd_density")
      arch.write(jd)
      arch.set(title,"jd_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(title,"jd_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(title,"jd_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jd.destroy

   end

   make_jd_grid(jd)
   ! Work out the diamagnetic current density on ".plot_grid" using ".natural
   ! orbitals" and the ".occupation_numbers" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
      jd :: MAT{REAL}, OUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(jd.dim1==.plot_grid.n_pt, "wrong dim1, jd")
   ENSURE(jd.dim2==3, "wrong dim2, jd")

      r :: MAT{REAL}*
      rho :: VEC{REAL}*

      if (.B_field.norm<TOL(10)) then
         jd = ZERO
         return
      end

      rho.create(.plot_grid.n_pt)
      r.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(r)

      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)

      .GRID:make_density_grid(rho,r)

      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho

      r.destroy
      rho.destroy

   end

   make_jp_grid
   ! Work out the paramagnetic current density on ".plot_grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"), "no restricted complex NOs")

      arch :: ARCHIVE
      jp :: MAT{REAL}*


      ! Make grid
      jp.create(.plot_grid.n_pt,3)
      .:make_jp_grid(jp)

      ! Dump
      arch.set(.name,"jp_density_grid")
      arch.write(jp)
      arch.set(.name,"jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_jp_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".plot_grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r)
      jp :: MAT{REAL}

   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"), "no restricted complex NOs")

      pt :: MAT{REAL}*
      P :: MAT{CPX}*
      D :: VEC{CPX}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      ! Make plot points
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3)
      .plot_grid.make_points(pt)

      ! Temporaries
      D.create(n_pt)
      P.create(n_pt,3)
      n_occ = .BASE:no_of_occupied_NOs

      ! Initialize
      jp = ZERO

      ! Loop over NO's
      do n = 1,n_occ

         .GRID:make_nabla_orbital_grid_c(P,D,.natural_orbitals.restricted_complex(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         jp(:,1) = jp(:,1) - occ*aimag(conjg(D(:))*P(:,1))
         jp(:,2) = jp(:,2) - occ*aimag(conjg(D(:))*P(:,2))
         jp(:,3) = jp(:,3) - occ*aimag(conjg(D(:))*P(:,3))

      end

      ! Clean
      P.destroy
      D.destroy
      pt.destroy

   end

   make_div_jp_grid
   ! Work out the divergence of the paramagnetic current density on ".plot_grid"
   ! using ".natural orbitals".  A Gnuplot ascii file is generated.

   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(trim(.natural_orbitals.number_kind)=="complex", "NO's not complex")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"), "no restricted complex NOs")

      arch :: ARCHIVE
      div_jp :: VEC{REAL}*

      ! Make
      div_jp.create(.plot_grid.n_pt)
      .:make_div_jp_grid(div_jp)

      ! Dump
      arch.set(.name,"div_jp_density_grid")
      arch.write(div_jp)
      arch.set(.name,"div_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(div_jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

      ! Clean
      div_jp.destroy

   end

   make_div_jp_grid(div_jp)
   ! Work out the divergence of the paramagnetic current density "jp" on ".plot_grid"
   ! using ".natural orbitals" .
   !  \nabla .  J_p(r) = - (eh/m) \sum_i n_i Im[ \phi^*_i(r) \nabla^2 \phi^_i(r) ]
      div_jp :: VEC{REAL}

   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"), "no restricted complex NOs")

      pt :: MAT{REAL}*
      L :: MAT{CPX}*
      P :: MAT{CPX}*
      D :: VEC{CPX}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = .plot_grid.n_pt
      n_occ = .BASE:no_of_occupied_NOs

      pt.create(n_pt,3)
      D.create(n_pt)
      P.create(n_pt,3)
      L.create(n_pt,3)

      .plot_grid.make_points(pt)

      div_jp = ZERO

      do n = 1,n_occ
         .GRID:make_laplacian_orbital_grid_c(L,P,D,.natural_orbitals.restricted_complex(:,n), pt)
         occ = .occupation_numbers.restricted(n)
         div_jp = div_jp - occ*aimag(conjg(D(:))*(L(:,1)+L(:,2)+L(:,3)))
      end

      L.destroy
      P.destroy
      D.destroy
      pt.destroy

   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".plot_grid"

   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.is_associated_with_genre("restricted_complex"),"no restricted cmplx DM")

      arch :: ARCHIVE
      jp :: MAT{REAL}*

      ! Make
      jp.create(.plot_grid.n_pt,3)
      .:make_solenoidal_jp_grid(jp,.density_matrix.restricted_complex)

      ! Dump
      arch.set(.name,"solenoidal_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"solenoidal_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"solenoidal_jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"solenoidal_jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".plot_grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb,k :: INT
      fac :: REAL
      sh :: SHELL2

      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)

      jp = ZERO

      do q = 1,.n_shell_pairs

        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE

        Jxab.create(na,nb)
        Jyab.create(na,nb)
        Jzab.create(na,nb)

        do k = 1,.plot_grid.n_pt
          sh.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(aimag(Dba))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(aimag(Dba))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(aimag(Dba))
        end

        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part

      end

      pt.destroy

      jp.zero_small_values(TOL(10))

   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".plot_grid"

   ENSURE(.plot_grid.disassociated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.is_associated_with_genre("restricted_complex"),"no restricted cmplx DM")

      arch :: ARCHIVE
      jp :: MAT{REAL}*

      ! Make
      jp.create(.plot_grid.n_pt,3)
      .:make_irrotational_jp_grid(jp,.density_matrix.restricted_complex)

      ! Dump
      arch.set(.name,"irrotational_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"irrotational_jp_density_grid",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"irrotational_jp_norm_density_grid",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"irrotational_jp_density_grid,normalized",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".plot_grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.plot_grid.associated,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,  "no atom list")

      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb,k :: INT
      fac :: REAL
      sh :: SHELL2

      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)

      jp = ZERO

      do q = 1,.n_shell_pairs

        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE

        Jxab.create(na,nb)
        Jyab.create(na,nb)
        Jzab.create(na,nb)

        do k = 1,.plot_grid.n_pt
          sh.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(aimag(Dba))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(aimag(Dba))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(aimag(Dba))
        end

        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part

      end

      pt.destroy

      jp.zero_small_values(TOL(10))

   end

end

