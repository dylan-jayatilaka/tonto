!==================================================================
!
! MOLECULE.GRID: 
! 
! An object representation of a molecule, plotting procedures.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996-2012
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================

module MOLECULE.GRID

   implicit none

contains

   do_isosurface_plot
   ! Do one of the many kinds of isosurface plot calculations
   ! NOTE: cubify_m passes MOLECULE "self" !
      self :: INOUT

   ENSURE(.isosurface.allocated,"no isosurface")

      select case (.isosurface.property)
      case("adp                              "); .isosurface.cubify_m(self,::make_ADP_exponent_grid)
      case("adp2                             "); .isosurface.cubify_m(self,::make_ADP2_exponent_grid)
      case("anharmonic_adp_correction        "); .isosurface.cubify_m(self,::make_AADP_correction_grid)
    ! case("bond_density_atom                "); .isosurface.cubify_m(self,::make_bond_density_atom_grid)
    ! case("bond_electron_density            "); .isosurface.cubify_m(self,::make_bond_ED_grid)
    ! case("bond_weight                      "); .isosurface.cubify_m(self,::make_bond_weight_grid)
    ! case("deformation_bond_density         "); .isosurface.cubify_m(self,::make_deformation_bond_density_grid)
      case("deformation_density              "); .isosurface.cubify_m(self,::make_def_ED_grid)
      case("deformation_ed                   "); .isosurface.cubify_m(self,::make_def_ED_grid)
      case("deformation_electron_density     "); .isosurface.cubify_m(self,::make_def_ED_grid)
      case("deformation_dft_eff_potential    "); .isosurface.cubify_m(self,::make_def_DFT_eff_pot_grid)
      case("deformation_dft_energy           "); .isosurface.cubify_m(self,::make_def_DFT_energy_grid)
      case("deformation_dft_xc_potential     "); .isosurface.cubify_m(self,::make_def_DFT_xc_pot_grid)
      case("deformation_electric_potential   "); .isosurface.cubify_m(self,::make_def_e_pot_grid)
      case("deformation_g_kinetic_energy     "); .isosurface.cubify_m(self,::make_def_G_kinetic_grid)
      case("deformation_h_dft_energy         "); .isosurface.cubify_m(self,::make_def_H_DFT_energy_grid)
      case("deformation_k_kinetic_energy     "); .isosurface.cubify_m(self,::make_def_K_kinetic_grid)
      case("deformation_laplacian            "); .isosurface.cubify_m(self,::make_def_laplacian_grid)
      case("dft_eff_potential                "); .isosurface.cubify_m(self,::make_dft_eff_pot_grid)
      case("dft_energy                       "); .isosurface.cubify_m(self,::make_dft_energy_grid)
      case("dft_xc_potential                 "); .isosurface.cubify_m(self,::make_dft_xc_pot_grid)
      case("e_field_magnitude                "); .isosurface.cubify_m(self,::make_E_field_magnitude)
      case("electric_potential               "); .isosurface.cubify_m(self,::make_EP_grid)
      case("electron_density                 "); .isosurface.cubify_m(self,::make_ED_grid)
      case("elf                              "); .isosurface.cubify_m(self,::make_ELF_grid)
      case("eli_d                            "); .isosurface.cubify_m(self,::make_ELI_D_grid)
      case("fermi_mobility                   "); .isosurface.cubify_m(self,::make_fermi_mobility_grid)
      case("grad_rho_on_rho                  "); .isosurface.cubify_m(self,::make_grad_rho_on_rho_grid)
      case("g_kinetic_energy                 "); .isosurface.cubify_m(self,::make_G_kinetic_energy_grid)
      case("h_dft_energy                     "); .isosurface.cubify_m(self,::make_H_DFT_energy_grid)
      case("hirshfeld_density                "); .isosurface.cubify_m(self,::make_Hirshfeld_density_grid)
      case("hirshfeld_weight                 "); .isosurface.cubify_m(self,::make_Hirshfeld_density_grid)
      case("k_kinetic_energy                 "); .isosurface.cubify_m(self,::make_K_kinetic_energy_grid)
      case("laplacian                        "); .isosurface.cubify_m(self,::make_laplacian_grid)
      case("local_ionisation_energy          "); .isosurface.cubify_m(self,::make_local_ionisation_grid)
      case("lol                              "); .isosurface.cubify_m(self,::make_LOL_grid)
      case("orbital                          "); .isosurface.cubify_m(self,::make_orbital_grid)
    ! case("oscillator_orbital               "); .isosurface.cubify_m(self,::make_oscillator_orbital_grid)
      case("orbital_density                  "); .isosurface.cubify_m(self,::make_orbital_density_grid)
      case("promolecule_density              "); .isosurface.cubify_m(self,::make_promolecule_density_grid)
    ! case("roby_ano_density                 "); .isosurface.cubify_m(self,::make_Roby_ANO_density_grid)
    ! case("roby_nao_density                 "); .isosurface.cubify_m(self,::make_Roby_NAO_density_grid)
      case("roby-gould_covalent_orbital      "); .isosurface.cubify_m(self,::make_RG_cov_orbital_grid)
      case("roby-gould_ionic_orbital         "); .isosurface.cubify_m(self,::make_RG_ion_orbital_grid)
      case("spin_density                     "); .isosurface.cubify_m(self,::make_SD_grid)
      case("stockholder_density              "); .isosurface.cubify_m(self,::make_stockholder_density_grid)
      case("stockholder_weight               "); .isosurface.cubify_m(self,::make_Hirshfeld_density_grid)
      case("test_sphere_on_atom_1            "); .isosurface.cubify_m(self,::make_test_sphere_on_atom_1)
      case("true_fermi_mobility              "); .isosurface.cubify_m(self,::make_true_fermi_mobility_grid)
      case("tsirelson_elf                    "); .isosurface.cubify_m(self,::make_Tsirelson_ELF_grid)
      case default;                UNKNOWN(.isosurface.property)
      end

   end

   do_plot_property_on_isosurface
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface --- useful for mapping properties on a surface.
   ! NOTE: plot_function_m passes MOLECULE "self" !
      self :: INOUT

      select case (.isosurface.surface_property)
      case("adp                             "); .isosurface.plot_function_m(self,::make_ADP_exponent_grid)
      case("adp2                            "); .isosurface.plot_function_m(self,::make_ADP2_exponent_grid)
      case("anharmonic_adp_correction       "); .isosurface.plot_function_m(self,::make_AADP_correction_grid)
    ! case("bond_density_atom               "); .isosurface.plot_function_m(self,::make_bond_density_atom_grid)
    ! case("bond_electron_density           "); .isosurface.plot_function_m(self,::make_bond_ED_grid)
    ! case("deformation_bond_density        "); .isosurface.plot_function_m(self,::make_deformation_bond_density_grid)
      case("deformation_density             "); .isosurface.plot_function_m(self,::make_def_ED_grid)
      case("deformation_ed                  "); .isosurface.plot_function_m(self,::make_def_ED_grid)
      case("deformation_electron_density    "); .isosurface.plot_function_m(self,::make_def_ED_grid)
      case("deformation_dft_eff_potential   "); .isosurface.plot_function_m(self,::make_def_DFT_eff_pot_grid)
      case("deformation_dft_energy          "); .isosurface.plot_function_m(self,::make_def_DFT_energy_grid)
      case("deformation_dft_xc_potential    "); .isosurface.plot_function_m(self,::make_def_DFT_xc_pot_grid)
      case("deformation_electric_potential  "); .isosurface.plot_function_m(self,::make_def_e_pot_grid)
      case("deformation_g_kinetic_energy    "); .isosurface.plot_function_m(self,::make_def_G_kinetic_grid)
      case("deformation_h_dft_energy        "); .isosurface.plot_function_m(self,::make_def_H_DFT_energy_grid)
      case("deformation_k_kinetic_energy    "); .isosurface.plot_function_m(self,::make_def_K_kinetic_grid)
      case("deformation_laplacian           "); .isosurface.plot_function_m(self,::make_def_laplacian_grid)
      case("dft_eff_potential               "); .isosurface.plot_function_m(self,::make_dft_eff_pot_grid)
      case("dft_energy                      "); .isosurface.plot_function_m(self,::make_dft_energy_grid)
      case("dft_xc_potential                "); .isosurface.plot_function_m(self,::make_dft_xc_pot_grid)
      case("e_field_magnitude               "); .isosurface.plot_function_m(self,::make_E_field_magnitude)
      case("electric_potential              "); .isosurface.plot_function_m(self,::make_EP_grid)
      case("electron_density                "); .isosurface.plot_function_m(self,::make_ED_grid)
      case("elf                             "); .isosurface.plot_function_m(self,::make_ELF_grid)
      case("eli_d                           "); .isosurface.plot_function_m(self,::make_ELI_D_grid)
      case("fermi_mobility                  "); .isosurface.plot_function_m(self,::make_fermi_mobility_grid)
      case("g_kinetic_energy                "); .isosurface.plot_function_m(self,::make_G_kinetic_energy_grid)
      case("group_product_e_field_grid      "); .isosurface.plot_function_m(self,::make_group_product_E_field_grid)
      case("group_product_esp_grid          "); .isosurface.plot_function_m(self,::make_group_product_ESP_grid)
      case("grad_rho_on_rho                 "); .isosurface.plot_function_m(self,::make_grad_rho_on_rho_grid)
      case("h_dft_energy                    "); .isosurface.plot_function_m(self,::make_H_DFT_energy_grid)
      case("hirshfeld_density               "); .isosurface.plot_function_m(self,::make_Hirshfeld_density_grid)
      case("hirshfeld_weight                "); .isosurface.plot_function_m(self,::make_Hirshfeld_density_grid)
      case("k_kinetic_energy                "); .isosurface.plot_function_m(self,::make_K_kinetic_energy_grid)
      case("laplacian                       "); .isosurface.plot_function_m(self,::make_laplacian_grid)
      case("local_ionisation_energy         "); .isosurface.plot_function_m(self,::make_local_ionisation_grid)
      case("lol                             "); .isosurface.plot_function_m(self,::make_LOL_grid)
      case("orbital                         "); .isosurface.plot_function_m(self,::make_orbital_grid)
    ! case("oscillator_orbital              "); .isosurface.plot_function_m(self,::make_oscillator_orbital_grid)
      case("orbital_density                 "); .isosurface.plot_function_m(self,::make_orbital_density_grid)
      case("promolecule_density             "); .isosurface.plot_function_m(self,::make_promolecule_density_grid)
      case("product_e_field_grid            "); .isosurface.plot_function_m(self,::make_product_E_field_grid)
      case("product_esp_grid                "); .isosurface.plot_function_m(self,::make_product_ESP_grid)
    ! case("roby_ano_density                "); .isosurface.plot_function_m(self,::make_Roby_ANO_density_grid)
    ! case("roby_nao_density                "); .isosurface.plot_function_m(self,::make_Roby_NAO_density_grid)
      case("roby-gould_covalent_orbital     "); .isosurface.plot_function_m(self,::make_RG_cov_orbital_grid)
      case("roby-gould_ionic_orbital        "); .isosurface.plot_function_m(self,::make_RG_ion_orbital_grid)
      case("spin_density                    "); .isosurface.plot_function_m(self,::make_SD_grid)
      case("stockholder_density             "); .isosurface.plot_function_m(self,::make_stockholder_density_grid)
      case("stockholder_weight              "); .isosurface.plot_function_m(self,::make_Hirshfeld_density_grid)
      case("test_sphere_on_atom_1           "); .isosurface.plot_function_m(self,::make_test_sphere_on_atom_1)
      case("true_fermi_mobility             "); .isosurface.plot_function_m(self,::make_true_fermi_mobility_grid)
      case("tsirelson_elf                   "); .isosurface.plot_function_m(self,::make_Tsirelson_ELF_grid)
      case default;                UNKNOWN(.isosurface.surface_property)
      end

   end

   make_prop_values(grid,pt) ::: leaky
   ! Make the plot values in "grid" for a given set of points "pt" for
   ! the ".plot.plot_kind" of property. These are usually 2D plot, but
   ! they can be rectilinear volumetric plots, depending on how
   ! .plot_grid was defined by the user.
      self :: INOUT
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   ENSURE(.plot_grid.allocated, "no grid")

      ! NOTE: Some of these were commented out during a major change
      ! and need to be reinstated using the new calling method
      ! pattern.

      ! Do the plot
      select case (.plot_grid.plot_kind)
      case("adp                                 "); .GRID:make_ADP_grid(grid,pt)
      case("adp2                                "); .GRID:make_ADP2_exponent_grid(grid,pt)
      case("anharmonic_adp_correction           "); .GRID:make_AADP_correction_grid(grid,pt)
      case("b_field                             "); .GRID:make_B_field_grid(grid,pt)
    ! case("b_l_field                           "); .GRID:make_B_L_field_grid(grid,pt)
    ! case("b_s_field                           "); .GRID:make_B_S_field_grid(grid,pt)
      case("binding_function_wang_peng          "); .GRID:make_binding_function_WP_grid(grid,pt)
    ! case("bond_density_atom                   "); .GRID:make_bond_density_atom_grid(grid,pt)
    ! case("bond_electron_density               "); .GRID:make_bond_ED_grid(grid,pt)
    ! case("bond_weight                         "); .GRID:make_bond_weight_grid(grid,pt)
    ! case("current_density                     "); .GRID:make_j_grid(grid,pt)
    ! case("deformation_bond_density            "); .GRID:make_def_bond_density_grid(grid,pt)
      case("crystal23_ed                        "); .GRID:make_CRYSTAL23_ED_grid(grid,pt)
      case("crystal23_ed_v1                     "); .GRID:make_CRYSTAL23_ED_grid_v1(grid,pt)
      case("crystal23_electorn_density          "); .GRID:make_CRYSTAL23_ED_grid_v1(grid,pt)
      case("deformation_density                 "); .GRID:make_def_ED_grid(grid,pt)
      case("deformation_ed                      "); .GRID:make_def_ED_grid(grid,pt)
      case("deformation_electron_density        "); .GRID:make_def_ED_grid(grid,pt)
      case("deformation_dft_eff_potential       "); .GRID:make_def_DFT_eff_pot_grid(grid,pt)
      case("deformation_dft_energy              "); .GRID:make_def_DFT_energy_grid(grid,pt)
      case("deformation_dft_xc_potential        "); .GRID:make_def_DFT_xc_pot_grid(grid,pt)
      case("deformation_electric_potential      "); .GRID:make_def_e_pot_grid(grid,pt)
      case("deformation_g_kinetic_energy        "); .GRID:make_def_G_kinetic_grid(grid,pt)
      case("deformation_g_kirzhnits             "); .GRID:make_def_G_Kirzhnits_grid(grid,pt)
      case("deformation_h_dft_energy            "); .GRID:make_def_H_DFT_energy_grid(grid,pt)
      case("deformation_h_from_virial           "); .GRID:make_def_H_from_virial_grid(grid,pt)
      case("deformation_h_kirzhnits             "); .GRID:make_def_H_Kirzhnits_grid(grid,pt)
      case("deformation_k_kinetic_energy        "); .GRID:make_def_K_kinetic_grid(grid,pt)
      case("deformation_laplacian               "); .GRID:make_def_laplacian_grid(grid,pt)
      case("deformation_v_from_virial           "); .GRID:make_def_V_from_virial_grid(grid,pt)
      case("deformation_v_kirzhnits             "); .GRID:make_def_V_Kirzhnits_grid(grid,pt)
      case("deformation_reduced_g_kinetic_energy"); .GRID:make_def_rG_kinetic_grid(grid,pt)
      case("deformation_reduced_h_from_virial   "); .GRID:make_def_rH_from_virial_grid(grid,pt)
      case("deformation_reduced_k_kinetic_energy"); .GRID:make_def_rK_kinetic_grid(grid,pt)
      case("deformation_reduced_v_from_virial   "); .GRID:make_def_rV_from_virial_grid(grid,pt)
      case("dft_eff_potential                   "); .GRID:make_DFT_eff_pot_grid(grid,pt)
      case("dft_energy                          "); .GRID:make_DFT_energy_grid(grid,pt)
      case("dft_xc_potential                    "); .GRID:make_DFT_xc_pot_grid(grid,pt)
    ! case("div_jp                              "); .GRID:make_div_jp_grid(grid,pt)
      case("e_field_magnitude                   "); .GRID:make_E_field_magnitude(grid,pt)
      case("electric_potential                  "); .GRID:make_EP_grid(grid,pt)
      case("electric_polarisation_density       "); .GRID:make_E_polarization_grid(grid,pt)
      case("electric_polarization_density       "); .GRID:make_E_polarization_grid(grid,pt)
      case("electron_density                    "); .GRID:make_ED_grid(grid,pt)
      case("elf                                 "); .GRID:make_ELF_grid(grid,pt)
      case("e_hf_density_from_rho               "); .GRID:make_E_hf_dens_from_rho_grid(grid,pt)
      case("eli_d                               "); .GRID:make_ELI_D_grid(grid,pt)
    ! case("energy_density_from_rho             "); .GRID:make_def_ED_grid(grid,pt)
      case("fermi_mobility                      "); .GRID:make_fermi_mobility_grid(grid,pt)
      case("g_kinetic_energy                    "); .GRID:make_G_kinetic_energy_grid(grid,pt)
      case("g_kirzhnits                         "); .GRID:make_G_Kirzhnits_grid(grid,pt)
      case("grad_rho_on_rho                     "); .GRID:make_grad_rho_on_rho_grid(grid,pt)
      case("h_dft_energy                        "); .GRID:make_H_DFT_energy_grid(grid,pt)
      case("h_kirzhnits                         "); .GRID:make_H_Kirzhnits_grid(grid,pt)
      case("h_from_virial                       "); .GRID:make_H_from_virial_grid(grid,pt)
    ! case("hirshfeld_atom_grid                 "); .GRID:make_Hirshfeld_atom_grid(grid,pt)
      case("hirshfeld_density                   "); .GRID:make_Hirshfeld_density_grid(grid,pt)
      case("hirshfeld_weight                    "); .GRID:make_Hirshfeld_density_grid(grid,pt)
      case("interaction_density                 "); .GRID:make_interaction_density_grid(grid,pt)
    ! case("j                                   "); .GRID:make_j_grid(grid,pt)
    ! case("jd                                  "); .GRID:make_jd_grid(grid,pt)
    ! case("jp                                  "); .GRID:make_jp_grid(grid,pt)
    ! case("jp_irrotational                     "); .GRID:make_irrotational_jp_grid(grid,pt)
    ! case("jp_solenoidal                       "); .GRID:make_solenoidal_jp_grid(grid,pt)
    ! case("jayatilaka_atom_grid                "); .GRID:make_Jayatilaka_atom_grid(grid,pt)
      case("k_kinetic_energy                    "); .GRID:make_K_kinetic_energy_grid(grid,pt)
      case("laplacian                           "); .GRID:make_laplacian_grid(grid,pt)
      case("local_ionisation_energy             "); .GRID:make_local_ionisation_grid(grid,pt)
      case("local_virial_ratio                  "); .GRID:make_local_virial_ratio_grid(grid,pt)
      case("lol                                 "); .GRID:make_LOL_grid(grid,pt)
      case("negative_laplacian                  "); .GRID:make_neg_laplacian_grid(grid,pt)
      case("noncollinear_spin_density           "); .GRID:make_nc_spin_density_grid(grid,pt)
      case("normalized_g_from_virial            "); .GRID:make_norm_G_from_virial_grid(grid,pt)
      case("normalized_h_from_virial            "); .GRID:make_norm_H_from_virial_grid(grid,pt)
      case("normalized_v_from_virial            "); .GRID:make_norm_V_from_virial_grid(grid,pt)
    ! case("orbital_current_density             "); .GRID:make_orbital_j_grid(grid,pt)
      case("orbital_density                     "); .GRID:make_orbital_density_grid(grid,pt)
    ! case("orbital                             "); .GRID:make_orbital_grid(grid,pt)
    ! case("oscillator_orbital                  "); .GRID:make_oscillator_orbital_grid(grid,pt)
      case("promolecule_density                 "); .GRID:make_promolecule_density_grid(grid,pt)
      case("reduced_g_kinetic_energy            "); .GRID:make_rG_kinetic_energy_grid(grid,pt)
      case("reduced_h_from_virial               "); .GRID:make_rH_from_virial_grid(grid,pt)
      case("reduced_k_kinetic_energy            "); .GRID:make_rK_kinetic_energy_grid(grid,pt)
      case("reduced_v_from_virial               "); .GRID:make_rV_from_virial_grid(grid,pt)
      case("residual_density                    "); .GRID:make_residual_density_grid(grid,pt)
    ! case("roby_ano_density                    "); .GRID:make_Roby_ANO_density_grid(grid,pt)
    ! case("roby_nao_density                    "); .GRID:make_Roby_NAO_density_grid(grid,pt)
      case("roby-gould_covalent_orbital         "); .GRID:make_RG_cov_orbital_grid(grid,pt)
      case("roby-gould_ionic_orbital            "); .GRID:make_RG_ion_orbital_grid(grid,pt)
    ! case("spin_current_density                "); .GRID:make_spin_j_grid(grid,pt)
      case("spin_density                        "); .GRID:make_SD_grid(grid,pt)
      case("spherical_atom_density              "); .GRID:make_spherical_atom_grid(grid,pt)
      case("stockholder_density                 "); .GRID:make_stockholder_density_grid(grid,pt)
      case("stockholder_weight                  "); .GRID:make_Hirshfeld_density_grid(grid,pt)
      case("test_sphere_on_atom_1               "); .GRID:make_test_sphere_on_atom_1(grid,pt)
      case("true_fermi_mobility                 "); .GRID:make_true_fermi_mobility_grid(grid,pt)
      case("tsirelson_elf                       "); .GRID:make_Tsirelson_ELF_grid(grid,pt)
      case("v_kirzhnits                         "); .GRID:make_V_Kirzhnits_grid(grid,pt)
      case("v_from_virial                       "); .GRID:make_V_from_virial_grid(grid,pt)
      case default;                UNKNOWN(.plot_grid.plot_kind)
      end

   end

!  ============================
!  Standard ED refinement plots
!  ============================

   put_ED_refinement_plots
   ! Evaluate the min and max residual density from the
   ! fitted structure factors, evaluated on a grid 0.1 A
   ! per side. Also evaluate the residuals at the atom
   ! centers and report the worst one.
      self :: INOUT

   DIE_IF(NOT .atom.allocated, "no atoms to fit")
   DIE_IF(NOT .crystal.allocated, "no crystal")
   DIE_IF(NOT .crystal.fragment_info_made, "no crystal fragment info")
   DIE_IF(NOT .crystal.xray_data.allocated,"no crystal xray data")

      map :: VEC{REAL}@
      pt  :: MAT{REAL}@
      n_pt :: INT

      ! Set up
      if (.plot_grid.deallocated) .plot_grid.create

      ! Use unit cell as bbox if requested
      .plot_grid.set_box_scale_factor(ONE)
      if (.plot_grid.desired_separation.is_zero) &
      .plot_grid.set_desired_separation(0.1*BOHR_PER_ANGSTROM)
      .plot_grid.set_center_to_center_of(.atom)
      .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell,midpt_is_center=FALSE)

      ! Make the residual map
      n_pt = .plot_grid.n_pt
      map.create(n_pt)
      .plot_grid.set_plot_kind("residual_density")
      .plot_grid.make_points(pt)
      .GRID:make_residual_density_cell(map)

      ! Write cube file
      .PUT:dump_plot_grid(map,"residual_density",form="gaussian.cube")

      ! Clean
      map.destroy

   end


!  ==================================
!  Property density plots (templates)
!  ==================================

   def_grid(grid,pt) ::: template
   ! Make deformation density "grid" on a set of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated,"no natural orbitals")
   ENSURE(.NO_occ_nos.allocated,"no natural orbitals")

      promol_grid :: VEC{REAL}@

      ! Make the normal grid values
      .GRID?(grid,pt)

      ! Make the promolecule grid values
      promol_grid.create(grid.dim)
      .PRO?(promol_grid,pt)

      ! Subtract to form deformation grid
      grid = grid - promol_grid

      ! Clean up
      promol_grid.destroy

   end

   int_grid(grid,pt) ::: template
   ! Make the interaction density grid.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated,"no natural orbitals")
   ENSURE(.NO_occ_nos.allocated,"no natural orbitals")
   ENSURE(.atom_group.allocated,"no atom_group")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"no .mol")

      prop,prop_grid :: VEC{REAL}@
      g :: INT

      ! Make the normal grid values
      .GRID?(grid,pt)

      ! Allocate grids
      prop_grid.create(grid.dim)
      prop.create(grid.dim)
      prop_grid = ZERO

      ! Add up sub grid values
      do g = 1,.atom_group.dim
         .mol(g).GRID?(prop,pt)
         prop_grid = prop_grid + prop
      end

      ! Subtract to form deformation grid
      grid = grid - prop_grid

   end

   pro_grid(density_grid,pt) ::: template
   ! Return promolecule "density_grid" from supplied points "pt".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")

      grid :: VEC{REAL}@
      a :: INT

      ! Create space for an atom's grid values
      grid.create(density_grid.dim)

      ! Sum up the atom grid values
      density_grid = ZERO
      parallel do a = 1,.n_atom
         .atom(a).GRID?(grid,pt)
         density_grid = density_grid + grid
      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

      ! Clean up
      grid.destroy

   end

   pro_DFT_grid(density_grid,pt) ::: template
   ! Return promolecule DFT "density_grid" from supplied points "pt".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
   ENSURE(.scfdata.allocated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      grid :: VEC{REAL}@
      exch,corr :: STR
      a :: INT

      ! Create
      grid.create(density_grid.dim)

      ! Make the grid of values
      exch = .scfdata.DFT_exchange_functional
      corr = .scfdata.DFT_correlation_functional
      density_grid = ZERO
      do a = 1,.n_atom
        .atom(a).GRID?(grid,pt,exch,corr)
        density_grid = density_grid + grid
      end

      ! Clean
      grid.destroy

   end

   field_grid(grid,pt) ::: template
   ! Work out the field density on ".plot_grid" and dump output
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.plot_grid.allocated, "no grid")

      field :: MAT{REAL}@
      name :: STR

      ! Make space for the field and grid points
      field.create(.plot_grid.n_pt,3)

      ! Make the grid of field values
      .FIELD?(field,pt)

      ! Print out components as well
      name = .plot_grid.plot_file_name(.n_a)
      .PUT:dump_plot_grid(field(:,1),trim(name)//".x") ! NOT PURE
      .PUT:dump_plot_grid(field(:,2),trim(name)//".y")
      .PUT:dump_plot_grid(field(:,3),trim(name)//".z")

      ! Get the magnitude
      grid = sqrt( field(:,1)*field(:,1) &
                 + field(:,2)*field(:,2) &
                 + field(:,3)*field(:,3) )

      ! Clean up
      field.destroy

   end

!  ============
!  Orbital grid
!  ============

   dump_orbital_grid
   ! Evaluate the values for orbital ".plot_grid.orb" of
   ! ".NOs" and write them out to a file.
      self :: IN

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      arch :: ARCHIVE
      pt  :: MAT{REAL}@
      gr  :: VEC{REAL}@
      gcu :: VEC{CPX}@
      gcd :: VEC{CPX}@
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .NOs.genre

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Kind of relativity to use
      relativity = "none"
    ! if (.scfdata.allocated) then
    !    relativity = .scfdata.relativity_kind
    !    if (NOT .scfdata.PCE_CORR) relativity = "none"
    ! end if

      select case (relativity)

    ! case ("douglas-kroll-hess","dkh")
    !
    !    select case (okind)
    !
    !    case("r ")
    !       WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
    !       WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
    !       gr.create(.plot_grid.n_pt)
    !       .GRID:make_DKH_orbital_grid_r(gr,orb,pt,square=FALSE)
    !       .PUT:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
    !       gr.destroy
    !
    !    case default
    !       DIE("unimplemented")
    !
    !    end
    !
    ! case ("iotc")
    !
    !    select case (okind)
    !
    !    case("r ")
    !       WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
    !       WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
    !       gr.create(.plot_grid.n_pt)
    !       .GRID:make_IOTC_orbital_grid_r(gr,orb,pt,square=FALSE)
    !       .PUT:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
    !       gr.destroy
    !
    !    case default
    !       DIE("unimplemented")
    !
    !    end

      case ("none")

         select case (okind)

         case("r ")
            gr.create(.plot_grid.n_pt)
            .GRID:make_orbital_grid_r(gr,.NOs.r(:,orb),pt)
            .PUT:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
            gr.destroy

         case("gc")
            gcu.create(.plot_grid.n_pt)
            gcd.create(.plot_grid.n_pt)
            .GRID:make_orbital_grid_gc(gcu,gcd,.NOs.gc(:,orb),pt)
            arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid",format="ascii")
            arch.write_orbital(gcu,gcd,.plot_grid.n_pt)
            gcu.destroy
            gcd.destroy

         case default
            DIE("unimplemented")

         end

      case default

         DIE("Unimplemented")

      end

      pt.destroy

   end

   make_orbital_grid(grid,pt)
   ! Work out the orbital "grid" for a series of points "pt" for using
   ! the ".natural orbitals", for orbital.isosurface.plot_grid.orbital. 
   ! NOTE: for complex orbitals, the absolute value times the sign of
   ! the complex part
      self :: IN
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   ENSURE(pt.dim1==grid.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(.NOs.allocated, "no natural orbitals")

      n_pt, orb :: INT


      n_pt = pt.dim1

      ! Get orbital to plot
      orb = .isosurface.plot_grid.orbital

      ! Zero value indicates HOMO ...
      if (orb==0) then
         orb = .n_a
         if (.isosurface.plot_grid.HOMO_orbital/=0) then
            orb = orb + .isosurface.plot_grid.HOMO_orbital
         end
      end

      if (trim(.NOs.number_kind)== "real") then
         .GRID:make_orbital_grid_r(grid,.NOs.r(:,orb),pt)
      end

   end

   orbital_grid(grid,pt) ::: selfless
   ! Work out the orbital "grid" for a series of points "pt" for using
   ! the ".natural orbitals", for orbital.isosurface.plot_grid.orbital. 
   ! NOTE: for complex orbitals, the absolute value times the sign of
   ! the complex part
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN
      self :: MOLECULE@
      .GRID:make_orbital_grid(grid,pt)
   end

!  Low-level orbital-type-specific routines 

   make_orbital_grid_r(grid,orb,pt,square) ::: PURE
   ! Evaluate the orbital "grid" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}@
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      grid = ZERO
      do a = 1,.n_shell
         .SET:set_shell1_from(a,sh,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         grid = grid + matmul(sh_grid,orb(fa:la))
         sh_grid.destroy
      end

      if (sq) grid = grid*grid

   end

   make_orbital_grid_gc(grid,orb,pt) ::: PURE
   ! Evaluate the orbital density "grid" for *one* AO-basis orbital
   ! coefficient vector "orb" on a set of grid points "pt"
      self :: IN
      grid :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}@
      gu,gd :: VEC{CPX}@
      n_pt,np,a,fa,la,na :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu.create(n_pt)
      gd.create(n_pt)

      grid = ZERO
      gu   = ZERO
      gd   = ZERO
      do a = 1,.n_shell
         .SET:set_shell1_from(a,sh,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         gu = gu + matmul(sh_grid,orb(fa   :la   )) ! aa or ba
         gd = gd + matmul(sh_grid,orb(fa+np:la+np)) ! ab or bb
         sh_grid.destroy
      end

      grid = conjg(gu)*gu + conjg(gd)*gd

      gu.destroy
      gd.destroy

   end

   make_orbital_grid_gc(gu,gd,orb,pt) ::: PURE
   ! Evaluate the orbital density for the alpha "gu" or beta "gd" part
   ! of *one* AO-basis orbital coefficient vector "orb" on a set of
   ! grid points "pt"
      self :: IN
      gu,gd :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}@
      n_pt,np,a,fa,la,na :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu = ZERO
      gd = ZERO
      do a = 1,.n_shell
         .SET:set_shell1_from(a,sh,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         gu = gu + matmul(sh_grid,orb(fa   :la   )) ! aa or ba
         gd = gd + matmul(sh_grid,orb(fa+np:la+np)) ! ab or bb
         sh_grid.destroy
      end

   end

!  ========================
!  Roby-Gould orbital grids
!  ========================

!   make_Roby_ANO_density_grid
!   ! Evaluate the Roby ANO density grid for the atom with 
!   ! index .roby.center_atom. Assumes double occupancy.
!      self :: IN
!
!   ENSURE(.roby.allocated, "no roby data -- do one group analysis")
!   ENSURE(.plot_grid.allocated, "no plot_grid")
!   ENSURE(.plot_grid.center_atom>0, "plot_grid center_atom not specified!")
!   ENSURE(.atom(.plot_grid.center_atom).NOs.allocated, "no natural orbitals!")
!   ENSURE(.atom(.plot_grid.center_atom).NOs.r.allocated, "no restricted natural orbitals!")
!
!      pt, NO :: MAT{REAL}@
!      rho, occ :: VEC{REAL}@
!      a :: INT
!
!      ! Do this atom
!      a = .plot_grid.center_atom
!
!      ! Points to plot
!      pt.create(.plot_grid.n_pt,3)
!      .plot_grid.make_points(pt)
!
!      ! Make the grid, rho
!      rho.create(.plot_grid.n_pt)  
!      NO  = .atom(a).NOs.r
!      occ = .atom(a).NO_occ_nos.r
!      .GRID:make_atom_density_grid_r(rho,NO,occ,pt,a)
!
!      ! Write grid, rho
!      .PUT:dump_plot_grid(rho,"Roby-Gould_ANO_density_atom_"//trim(a.to_str)//"_grid")
!
!      ! Clean
!      rho.destroy
!      pt.destroy
!
!   end


!   make_Roby_NAO_density_grid
!   ! Evaluate the Roby NAO density grid for the atom with index
!   ! .roby.center_atom. Assumes double occupancy.
!      self :: IN
!
!   ENSURE(.roby.allocated, "no roby data -- do one group analysis")
!   ENSURE(.plot_grid.allocated, "no plot_grid")
!   ENSURE(.plot_grid.center_atom>0, "plot_grid center_atom not specified!")
!   ENSURE(.atom(.plot_grid.center_atom).NAOs.allocated, "no natural orbitals!")
!   ENSURE(.atom(.plot_grid.center_atom).NAO_occupations.allocated, "no restricted natural orbitals!")
!
!      pt :: MAT{REAL}@
!      rho :: VEC{REAL}@
!      a :: INT
!
!      ! Do this atom
!      a = .plot_grid.center_atom
!
!      ! Points to plot
!      pt.create(.plot_grid.n_pt,3)
!      .plot_grid.make_points(pt)
!
!      ! Make the grid, rho
!      rho.create(.plot_grid.n_pt)
!      .GRID:make_atom_density_grid_r(rho,.atom(a).NAOs,.atom(a).NAO_occupations,pt,a)
!
!      ! Write grid, rho
!      .PUT:dump_plot_grid(rho,"Roby-Gould_NAO_density_atom_"//trim(a.to_str)//"_grid")
!
!      ! Clean
!      rho.destroy
!      pt.destroy
!
!   end


   make_RG_cov_orbital_grid(gr,pt)
   ! Evaluate the Roby-Gould covalent orbital ".plot_grid.orb" and
   ! write it out to a file.
      self :: IN
      gr   :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   DIE_IF(NOT .roby.allocated, "no roby data -- do one group analysis")
   DIE_IF(NOT .roby.roby_kind=="group_bond_analysis", "must do previous group_bond_analysis")
   DIE_IF(NOT .roby.n_group==2, "must have only two groups")
   ENSURE(.roby.theta_C.allocated, "no Roby-Gould covalent orbitals")
   ENSURE(.plot_grid.allocated, "no plot_grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive theta orbital")
   ENSURE(.plot_grid.orbital<=.roby.theta_C.dim2, "orbital out of range, "//trim(.plot_grid.orbital.to_str))

      orb :: INT

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      stdout.flush
      stdout.text("============================")
      stdout.text("Roby-Gould covalent orbitals")
      stdout.text("============================")
      stdout.flush
      stdout.text("For atoms:")
      stdout.put(.roby.atom_ab)
      stdout.flush
      stdout.text("Orbital coefficients:")
      stdout.put(.roby.theta_C(:,orb))

      ! Make the grid, gr
      .GRID:make_ELMO_grid_r(gr,.roby.theta_C(:,orb),pt,.roby.atom_ab)

      ! Write grid, gr
    ! .PUT:dump_plot_grid(gr,"Roby-Gould_covalent_orbital_"//trim(orb.to_str)//"_grid")

   end


   make_RG_ion_orbital_grid(gr,pt)
   ! Evaluate the Roby-Gould ionic orbital ".plot_grid.orb" and write
   ! it out to a file.
      self :: IN
      gr :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   DIE_IF(NOT .roby.allocated, "no roby data -- do one group analysis")
   DIE_IF(NOT .roby.roby_kind=="group_bond_analysis", "must do previous group_bond_analysis")
   DIE_IF(NOT .roby.n_group==2, "must have only two groups")
   ENSURE(.roby.theta_I.allocated, "no Roby-Gould ionic orbitals")
   ENSURE(.plot_grid.allocated, "no plot_grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive theta orbital")
   ENSURE(.plot_grid.orbital<=.roby.theta_I.dim2, "orbital out of range, "//trim(.plot_grid.orbital.to_str))

      orb :: INT

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      stdout.flush
      stdout.text("=========================")
      stdout.text("Roby-Gould ionic orbitals")
      stdout.text("=========================")
      stdout.flush
      stdout.text("For atoms:")
      stdout.put(.roby.atom_ab)
      stdout.flush
      stdout.text("Orbital coefficients:")
      stdout.put(.roby.theta_I(:,orb))

      ! Make the grid, gr
      .GRID:make_ELMO_grid_r(gr,.roby.theta_I(:,orb),pt,.roby.atom_ab)

      ! Write grid, gr
      .PUT:dump_plot_grid(gr,"Roby-Gould_ionic_orbital_"//trim(orb.to_str)//"_grid")

   end


   make_atom_density_grid_r(grid,NO,occ,pt,atom) ::: PURE
   ! Evaluate the atom density "grid" for all "NO"s and occupation
   ! numbers "occ" for the atom with index "atom" on a set of grid
   ! points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      NO   :: MAT{REAL}, IN
      occ  :: VEC{REAL}, IN
      pt   :: MAT{REAL}, IN
      atom :: INT, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(NO.dim2==occ.dim, "incompatible dim2, NO & occ")
   ENSURE(NO.dim1==.atom(atom).basis.no_of_basis_functions, "wrong dim1, NO")
   ENSURE(pt.dim2==3, "pt dim2 is not 3")

      n :: INT
      g :: VEC{REAL}@

      grid = ZERO

      g.create(pt.dim1)

      parallel do n = 1,NO.dim2
         .atom(atom).make_orbital_grid_r(g,NO(:,n),pt)
         grid = grid + occ(n)*g*g
      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

      ! Clean
      g.destroy

   end

   make_ELMO_grid_r(grid,orb,pt,atom_indices,square) ::: PURE
   ! Evaluate the ELMO "grid" for *one* AO-basis coefficient orbital
   ! vector "orb" on a set of grid points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      atom_indices :: VEC{INT}, IN
      square :: BIN, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(orb.dim==.atom(atom_indices).no_of_basis_functions, "wrong dim2, orbitals")

      n_pt, i,a, na,fa,la :: INT
      sq :: BIN
      ga :: VEC{REAL}@

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      la = 0
      grid = ZERO

      do i = 1,atom_indices.dim

         ! Atom index a
         a = atom_indices(i)

         ! Basis fn limits
         na = .atom(a).basis.n_bf
         fa = la + 1
         la = la + na

         ! Atom a grid, ga
         ga.create(n_pt)
         .atom(a).make_orbital_grid_r(ga,orb(fa:la),pt)

         ! Add ga to grid
         grid = grid + ga

         ! Clean
         ga.destroy

      end

      if (sq) grid = grid*grid

   end

!  ====================
!  Orbital density grid
!  ====================

   make_orbital_density_grid(gr,pt)
   ! Work out the orbital on ".plot_grid.orbital" of ".NOs" 
   ! on a set of points "pt" returning the values in "gr".
      self :: IN
      gr :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      gc :: VEC{CPX}@
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .NOs.genre

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.allocated) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if

      select case (relativity)

    ! case ("douglas-kroll-hess","dkh")

    !    select case (okind)

    !    case("r ")
    !       .GRID:make_DKH_orbital_grid_r(gr,orb,pt,square=TRUE)

    !    case("u ")
    !       stdout.flush
    !       stdout.text("NOTE:")
    !       stdout.text("You can copy either alpha or beta density_mx and MOs")
    !       stdout.text("into the appropriate restricted file(s) and plot in the rhf regime!")
    !       DIE("UHF/UKS unimplemented")

    !    case("gc")
    !       gc.create(.plot_grid.n_pt)
    !       .GRID:make_DKH_orb_dens_grid_gc(gc,orb,pt)
    !       gr = RE(gc)
    !       gc.destroy

    !    case default
    !       DIE("unimplemented")

    !    end

    ! case ("iotc")

    !    select case (okind)

    !    case("r ")
    !       .GRID:make_IOTC_orbital_grid_r(gr,orb,pt,square=TRUE)

    !    case("u ")
    !       stdout.flush
    !       stdout.text("NOTE:")
    !       stdout.text("You can copy either alpha or beta density_mx and MOs")
    !       stdout.text("into the appropriate restricted file(s) and plot in the rhf regime!")
    !       DIE("UHF/UKS unimplemented")

    !    case("gc")
    !       gc.create(.plot_grid.n_pt)
    !       .GRID:make_IOTC_orb_dens_grid_gc(gc,orb,pt)
    !       gr = RE(gc)
    !       gc.destroy

    !    case default
    !       DIE("unimplemented")

    !    end

      case ("none")

         select case (okind)

         case("r ")
            .GRID:make_orbital_grid_r(gr,.NOs.r(:,orb),pt,square=TRUE)

         case("u ")
            stdout.flush
            stdout.text("NOTE:")
            stdout.text("You can copy either alpha or beta density_mx and MOs")
            stdout.text("into the appropriate restricted file(s) and plot in the rhf regime!")
            DIE("UHF/UKS unimplemented")

         case("gc")
            gc.create(.plot_grid.n_pt)
            .GRID:make_orbital_grid_gc(gc,.MOs.gc(:,orb),pt)
            gr = RE(gc)
            gc.destroy

         case default
            DIE("unimplemented")

         end

      case default

         DIE("Unimplemented")

      end

   end

! DKH restricted orbital grid

!   make_DKH_orbital_grid_r(grid,orb,pt,square)
!   ! ???
!     grid :: VEC{REAL}, OUT
!     orb :: INT, IN
!     pt :: MAT{REAL}, IN
!     square :: BIN, optional, IN
!
!   ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
!
!        MO :: MAT{REAL}@
!
!        MO = .MOs.r(:,1:.n_a)
!        .GRID:density_DKH_orb_r(grid,pt,MO(:,orb),square)
!
!   end

!   density_DKH_orb_r(grid,pt,MO,square)
!   ! The density "grid" will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      grid :: VEC{REAL} , OUT
!      pt :: MAT{REAL} , IN
!      MO :: VEC{REAL} , IN
!      square :: BIN , IN, optional
!
!      n_gcm,n_pt :: INT
!      n,i,j :: INT
!      g :: REAL
!      m_out :: MAT{INT}*
!      YU,GG,S,R,Z,PZP,PPZPP :: MAT{REAL}*
!      P2,Ap,Ep :: VEC{REAL}*
!
!      n_pt = pt.dim1
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      S.create(n_gcm,n_gcm)
!      S=ZERO
!      .REL:get_da_gcm_now(R,S,m_out)
!      R.destroy
!
!      YU.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!
!      .REL:make_DKH_mxs(YU,Ap,Ep,P2)
!
!      Z.create(n_gcm,n_gcm)
!      PZP.create(n_gcm,n_gcm)
!      .REL:make_DKH_mxs2(Z,PZP,YU)
!
!      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
!         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
!         PPZPP.create(n_gcm,n_gcm)
!        .REL:make_DKH_mxs4(PPZPP,YU)
!      end if
!
!      GG.create(.n_bf,.n_bf)
!      grid=ZERO
!      parallel do n = 1,n_pt
!
!         ! here it comes babes
!         ! point for point the density will be on and on calculated
!         ! I am sincerely sorry, but the code comparing to its non-relativistic
!         ! counterpart is really not effective :(
!         .GRID:make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,PPZPP)
!
!         g = ZERO
!
!         ! This is a diangonal change-basis & sum --dylan
!         do i=1,.n_bf
!         do j=1,.n_bf
!           g = g + MO(i)*GG(i,j)*MO(j)
!         end
!         end
!
!         ! Unfortunatelly the PCE corrected orbitals lose phase :(
!         if (NOT square) g = sqrt(g)
!
!         grid(n) = g
!
!      end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(grid)
!      end
!
!      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
!         PPZPP.destroy
!      end if
!
!      S.destroy
!      Z.destroy
!      PZP.destroy
!      GG.destroy
!      YU.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!      m_out.destroy
!
!   end

!   make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,PPZPP) ::: private
!   ! correct the picture change
!   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
!   ! this routine is based on the make_r_DKH_core_mx(H) routine
!      self :: INOUT
!      GG :: MAT{REAL}, OUT
!      YU :: MAT{REAL}, IN
!      Ap,Ep,P2 :: VEC{REAL}, IN
!      xx,yy,zz :: REAL, IN
!      m_out :: MAT{INT}, IN
!      n_gcm :: INT, IN
!      S,sZ,sPZP :: MAT{REAL}, IN
!      PPZPP :: MAT{REAL}, optional, IN
!
!      c :: REAL
!      i,j,k :: INT
!      R :: MAT{REAL}*
!      D,PDP,PPDPP,T,WW,W2,X,TX :: MAT{REAL}*
!      SOx,SOy,SOz,sPZPx,sPZPy,sPZPz,ZXX,PZPXX :: MAT{REAL}*
!      Rx,Ry,Rz :: MAT{REAL}*
!      A,B,Z,PZP :: MAT{REAL}*
!      M,buco :: MAT{REAL}*
!
!      !!!  the density operator X !!!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_density_mx(R,xx,yy,zz)
!
!      ! put the potential energy matrix into the n_gcm non-redundant space
!      D.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,D,m_out)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(YU,D,transpose_a=TRUE)
!      D.to_product_of(A,YU)
!
!      !!!  PDP MATRIX  !!!
!      .REL:make_primitive_pDp_mx(R,xx,yy,zz)
!
!      ! put the PDP matrix into the n_gcm non-redundant space
!      PDP.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,PDP,m_out)
!      A.to_product_of(YU,PDP,transpose_a=TRUE)
!      PDP.to_product_of(A,YU)
!
!      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
!         .REL:make_primitive_ppDpp_mx(R,xx,yy,zz)
!         PPDPP.create(n_gcm,n_gcm)
!         .REL:get_da_gcm_now(R,PPDPP,m_out)
!         A.to_product_of(YU,PPDPP,transpose_a=TRUE)
!         PPDPP.to_product_of(A,YU)
!      end if
!
!      !!! A-O LETS GO !!!
!      c = SPEED_OF_LIGHT_AU
!
!      do i = 1,n_gcm
!      do j = 1,n_gcm
!         D(i,j) = Ap(i)*D(i,j)*Ap(j)
!         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))
!      end
!      end
!
!      B.create(n_gcm,n_gcm)
!
!      if (.scfdata.DK1_PCE) then
!
!         A = ZERO
!         B = ZERO
!
!         do i = 1,n_gcm
!            B(i,i) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
!            A(i,i) = ONE/B(i,i)
!         end do
!
!         T.create(n_gcm,n_gcm)
!         T =     matmul(sPZP, matmul(A,PDP) )
!         T = T - matmul(sPZP,D)
!         T = T - matmul(sZ,PDP)
!         T = T + matmul(sZ, matmul(B,D) )
!         T = T + matmul(D, matmul(B,sZ) )
!         T = T - matmul(PDP,sZ)
!         T = T - matmul(D,sPZP)
!         T = T + matmul(PDP, matmul(A,sPZP) )
!
!         if (.scfdata.using_SO_FDFF) then
!
!            ! these are additional scalar terms due to presence of SO terms
!            ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz
!            ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz)
!
!            !!!  SO MATRICES  !!!
!            SOx.create(n_gcm,n_gcm)
!            SOy.create(n_gcm,n_gcm)
!            SOz.create(n_gcm,n_gcm)
!
!            ! put the SO matrices into the n_gcm non-redundant space
!            Rx.create(.n_prim,.n_prim)
!            Ry.create(.n_prim,.n_prim)
!            Rz.create(.n_prim,.n_prim)
!
!            .REL:make_primitive_pDp_SO_mx(Rx,Ry,Rz,xx,yy,zz)
!            .REL:get_da_gcm_now(Rx,SOx,m_out)
!            .REL:get_da_gcm_now(Ry,SOy,m_out)
!            .REL:get_da_gcm_now(Rz,SOz,m_out)
!
!            Rx.destroy
!            Ry.destroy
!            Rz.destroy
!
!              ZXX.create(n_gcm,n_gcm)
!            PZPXX.create(n_gcm,n_gcm)
!
!            ZXX.to_product_of(YU,SOx,transpose_a=TRUE)
!            SOx.to_product_of(ZXX,YU)
!            ZXX.to_product_of(YU,SOy,transpose_a=TRUE)
!            SOy.to_product_of(ZXX,YU)
!            ZXX.to_product_of(YU,SOz,transpose_a=TRUE)
!            SOz.to_product_of(ZXX,YU)
!
!            do i = 1,n_gcm
!            do j = 1,n_gcm
!               SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))
!               SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))
!               SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))
!            end
!            end
!
!            sPZPx.create(n_gcm,n_gcm)
!            sPZPy.create(n_gcm,n_gcm)
!            sPZPz.create(n_gcm,n_gcm)
!
!            .GRID:make_DKH_mxs3(ZXX,PZPXX,sPZPx,sPZPy,sPZPz,YU)
!
!            ZXX.destroy
!            PZPXX.destroy
!
!            T = T - matmul(SOx, matmul(A,sPZPx) )
!            T = T - matmul(SOy, matmul(A,sPZPy) )
!            T = T - matmul(SOz, matmul(A,sPZPz) )
!            T = T - matmul(sPZPx, matmul(A,SOx) )
!            T = T - matmul(sPZPy, matmul(A,SOy) )
!            T = T - matmul(sPZPz, matmul(A,SOz) )
!
!            SOx.destroy
!            SOy.destroy
!            SOz.destroy;
!            sPZPx.destroy
!            sPZPy.destroy
!            sPZPz.destroy;
!
!         end if
!
!         if (.scfdata.DK2_PCE) then
!
!            !!! W1W1
!            WW.create(n_gcm,n_gcm)
!            WW =    - matmul(sZ, matmul(B,sZ) )
!            WW = WW + matmul(sPZP,sZ)
!            WW = WW + matmul(sZ,sPZP)
!            WW = WW - matmul(sPZP, matmul(A,sPZP) )
!
!            X.create(n_gcm,n_gcm)
!            TX.create(n_gcm,n_gcm)
!            X = D + PDP
!            TX=HALF*(matmul(WW,X)+matmul(X,WW))
!            WW.destroy
!
!            Z.create(n_gcm,n_gcm)
!            PZP.create(n_gcm,n_gcm)
!
!            if (.scfdata.using_ppzpp) then
!
!               ! use the second derivatives in the [W1,[W1,X(even,0)]]
!               ! and [W2,X(odd,0)] terms
!
!               do i=1,n_gcm
!               do j=1,n_gcm
!                  PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 )
!                  Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
!                  PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
!               end do
!               end do
!
!               X  = PPDPP + PDP
!               TX = TX - matmul(sPZP,matmul(A,matmul(X,sZ)))
!               TX = TX + matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
!               TX = TX + matmul(sZ,matmul(X,sZ))
!               TX = TX - matmul(sZ,matmul(X, matmul(A,sPZP)))
!
!               PPDPP.destroy
!               X.destroy
!
!               !!! The -[W2,X(odd,0)] terms
!               W2.create(n_gcm,n_gcm)
!               W2 = ZERO
!               do i=1,n_gcm
!               do j=1,n_gcm
!               do k=1,n_gcm
!                  W2(i,j) = W2(i,j)                        &
!                     + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
!                     - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
!                     - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)  &
!                     + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!               end do
!               TX = TX + matmul(W2,PDP)
!
!               W2 = ZERO
!               do i=1,n_gcm
!               do j=1,n_gcm
!               do k=1,n_gcm
!                  W2(i,j) = W2(i,j)                        &
!                     + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                     - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                     - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
!                     + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!               end do
!
!               TX = TX + matmul(PDP,W2)
!
!               W2 = ZERO
!               do i=1,n_gcm
!               do j=1,n_gcm
!               do k=1,n_gcm
!                  W2(i,j) = W2(i,j)                        &
!                     -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                     +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                     +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
!                     -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!               end do
!
!               TX = TX + matmul(D,W2)
!
!               W2 = ZERO
!               do i=1,n_gcm
!               do j=1,n_gcm
!               do k=1,n_gcm
!                  W2(i,j) = W2(i,j)                         &
!                    -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
!                    +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
!                    +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
!                    -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)
!               end do
!               end do
!               end do
!
!               TX = TX + matmul(W2,D)
!
!            else
!
!               ! the second derivatives are not used in the
!               ! [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms
!
!               X.destroy
!               do i=1,n_gcm
!               do j=1,n_gcm
!                  Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
!                  PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
!               end do
!               end do
!
!               TX = TX - matmul(sPZP,matmul(A,matmul(PDP,sZ)))
!               TX = TX - matmul(sPZP,matmul(D,matmul(B,sZ)))
!               TX = TX + matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
!               TX = TX + matmul(sPZP, matmul(D,sPZP))
!               TX = TX + matmul(sZ,matmul(PDP,sZ))
!               TX = TX + matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
!               TX = TX - matmul(sZ,matmul(PDP, matmul(A,sPZP)))
!               TX = TX - matmul(sZ,matmul(B, matmul(D,sPZP)))
!
!               !!!  The [W2,X(odd,0)] terms
!               !   the second derivatives are not used
!               W2.create(n_gcm,n_gcm)
!               W2 =    matmul( sPZP, matmul(A, matmul(PZP,A) ) )
!               W2 = W2 + matmul( sPZP, Z )
!               W2 = W2 - matmul( sZ, ( matmul(PZP,A) ) )
!               W2 = W2 - matmul( sZ, ( matmul(B,Z) ) )
!               W2 = W2 - matmul( Z,  matmul(sPZP,A)  )
!               W2 = W2 - matmul( PZP,  matmul(sPZP,A)  )
!               W2 = W2 + matmul( Z,  sZ  )
!               W2 = W2 + matmul( PZP,  sZ  )
!               do i=1,n_gcm
!               do j=1,n_gcm
!                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!
!               TX = TX + matmul(W2,PDP)
!
!               W2 =      matmul( sZ, Z )
!               W2 = W2 + matmul( sZ, PZP )
!               W2 = W2 - matmul( matmul(A,sPZP), Z )
!               W2 = W2 - matmul( matmul(A,sPZP), PZP )
!               W2 = W2 - matmul( matmul(A,PZP)  ,   sZ)
!               W2 = W2 - matmul( matmul(Z,B)  ,   sZ)
!               W2 = W2 + matmul( matmul(A,matmul(PZP,A)) , sPZP)
!               W2 = W2 + matmul( Z , sPZP)
!               do i=1,n_gcm
!               do j=1,n_gcm
!                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!
!               TX = TX + matmul(PDP,W2)
!
!               W2 =    - matmul( matmul(B,sZ), Z )
!               W2 = W2 - matmul( matmul(B,sZ), PZP )
!               W2 = W2 + matmul( sPZP  ,   Z )
!               W2 = W2 + matmul( sPZP  , PZP )
!               W2 = W2 + matmul( PZP   ,  sZ )
!               W2 = W2 + matmul( matmul(B,matmul(Z,B)) , sZ)
!               W2 = W2 - matmul( matmul(PZP,A) , sPZP )
!               W2 = W2 - matmul( matmul(B,Z) , sPZP )
!               do i=1,n_gcm
!               do j=1,n_gcm
!                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!
!               TX = TX + matmul(D,W2)
!
!               W2 =    - matmul( sPZP  , matmul(A,PZP) )
!               W2 = W2 - matmul( sPZP  , matmul(Z,B) )
!               W2 = W2 + matmul( sZ    , PZP)
!               W2 = W2 + matmul( sZ    , matmul( B, matmul(Z,B) ) )
!               W2 = W2 + matmul( Z , sPZP  )
!               W2 = W2 + matmul( PZP , sPZP  )
!               W2 = W2 - matmul( Z ,  matmul(sZ,B) )
!               W2 = W2 - matmul( PZP ,  matmul(sZ,B) )
!               do i=1,n_gcm
!               do j=1,n_gcm
!                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               end do
!               end do
!
!               TX = TX + matmul(W2,D)
!
!            end if
!
!            W2.destroy
!            Z.destroy
!            PZP.destroy
!
!         end if
!
!      end if
!
!      D = D + PDP
!      PDP.destroy
!
!      if(.scfdata.DK1_PCE)then
!         D = D + T
!         T.destroy
!      end if
!
!      if(.scfdata.DK2_PCE)then
!         D = D + TX
!         TX.destroy
!      end if
!
!      B.to_product_of(S,YU)
!      A.to_product_of(B,D)
!      D.to_product_of(A,B,transpose_b=TRUE)
!
!      A.destroy
!      B.destroy
!
!      !!! moving back to tonto style primitive basis sets
!      ! put the Fock matrix back to the space .n_prim space
!      .REL:get_back_prim_now(D,R,m_out)
!      D.destroy
!
!      !!! moving back to contracted basis sets
!      M.create(.n_prim,.n_bf)
!      .BASE:make_normalized_contraction_mx(M)
!      buco.create(.n_bf,.n_prim)
!      buco.to_product_of(M,R,transpose_a=TRUE)
!      R.destroy
!
!      GG.to_product_of(buco,M)
!
!      M.destroy
!      buco.destroy
!
!   end

!   make_DKH_mxs3(Z,PZP,Lx,Ly,Lz,YU) ::: private
!   ! get the Z and PZP matrix
!   ! which are in the momentum space
!      self :: IN
!      Z,PZP,Lx,Ly,Lz :: MAT{REAL}, OUT
!      YU :: MAT{REAL}, IN
!
!      m_out :: MAT{INT}*
!      i,j,n_gcm :: INT
!      c :: REAL
!      R,SOx,SOy,SOz,A,X :: MAT{REAL}*
!      Ep,Ap,P2 :: VEC{REAL}*
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      !!!  Z MATRIX  !!!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_nuclear_mx(R)
!      .REL:get_da_gcm_now(R,Z,m_out)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(YU,Z,transpose_a=TRUE)
!      Z.to_product_of(A,YU)
!
!      !!! PZP and SO MATRICES  !!!
!      SOx.create(.n_prim,.n_prim)
!      SOy.create(.n_prim,.n_prim)
!      SOz.create(.n_prim,.n_prim)
!      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
!      .REL:get_da_gcm_now(R,PZP,m_out)
!      A.to_product_of(YU,PZP,transpose_a=TRUE)
!      PZP.to_product_of(A,YU)
!
!      .REL:get_da_gcm_now(SOx,Lx,m_out)
!      A.to_product_of(YU,Lx,transpose_a=TRUE)
!      Lx.to_product_of(A,YU)
!      .REL:get_da_gcm_now(SOy,Ly,m_out)
!      A.to_product_of(YU,Ly,transpose_a=TRUE)
!      Ly.to_product_of(A,YU)
!      .REL:get_da_gcm_now(SOz,Lz,m_out)
!      A.to_product_of(YU,Lz,transpose_a=TRUE)
!      Lz.to_product_of(A,YU)
!
!      A.destroy
!      R.destroy
!      SOx.destroy
!      SOy.destroy
!      SOx.destroy
!      m_out.destroy
!
!      c = SPEED_OF_LIGHT_AU
!
!      X.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!
!      .REL:make_DKH_mxs(X,Ap,Ep,P2)
!
!      do i=1,n_gcm
!      do j=1,n_gcm
!           Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
!         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!          Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!          Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!          Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!      end
!      end
!
!      X.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!
!   end

! DKH general complex orbital grid (naming problem?)

!   make_DKH_orb_dens_grid_gc(grid,orb,pt)
!   ! ???
!      grid :: VEC{CPX}, OUT
!      orb :: INT, IN
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.MOs.is_allocated_with_genre("gc"),"no MO's")
!
!      CMO :: MAT{CPX}@
!
!      CMO = .MOs.gc(:,1:.n_e)
!
!      .GRID:density_DKH_orb_gc(grid,pt,CMO(:,orb))
!
!   end

!   density_DKH_orb_gc(grid,pt,MO)
!   ! The density "grid" will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      self :: INOUT
!      grid :: VEC{CPX}, OUT
!      pt :: MAT{REAL}, IN
!      MO :: VEC{CPX}, IN
!
!      n_gcm,n_pt :: INT
!      n,i,j :: INT
!      II,gc :: CPX
!      m_out :: MAT{INT}*
!      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
!      P2,Ap,Ep :: VEC{REAL}*
!      SOx,SOy,SOz :: MAT{REAL}*
!      GG22,Z2,PZP2 :: MAT{CPX}*
!
!      n_pt = pt.dim1
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!      R.destroy
!
!      YU.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!      .GRID:make_DKH_mxs_2(YU,Ap,Ep,P2)
!
!      Z.create(n_gcm,n_gcm)
!      PZP.create(n_gcm,n_gcm)
!      SOx.create(n_gcm,n_gcm)
!      SOy.create(n_gcm,n_gcm)
!      SOz.create(n_gcm,n_gcm)
!      .GRID:make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)
!
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!         PPZPP.create(n_gcm,n_gcm)
!         .REL:make_DKH_mxs4(PPZPP,YU)
!         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
!      end if
!
!      GG22.create(2*.n_bf,2*.n_bf)
!        Z2.create(2*.n_bf,2*.n_bf)
!      PZP2.create(2*.n_bf,2*.n_bf)
!
!      Z2 = (ZERO,ZERO)
!      Z2.a_alpha_plus(Z)
!      Z2.b_beta_plus(Z)
!
!      II = (ZERO,ONE)
!
!      PZP2 = (ZERO,ZERO)
!      PZP2.a_alpha_plus(PZP)
!      PZP2.b_beta_plus(PZP)
!      PZP2.b_alpha_plus(SOx,II)
!      PZP2.b_alpha_plus(SOy,-ONE)
!      PZP2.a_alpha_plus(SOz,II)
!      PZP2.b_beta_plus(SOz,-II)
!      PZP2.make_hermitian
!
!      Z.destroy
!      PZP.destroy
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!
!      grid = (ZERO,ZERO)
!
!      parallel do n = 1,n_pt
!
!         ! here it comes babes point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to its non-relativistic counterpart is really not
!         ! effective :(
!         .GRID:make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)
!
!         gc = (ZERO,ZERO)
!         do i = 1,2*.n_bf
!         do j = 1,2*.n_bf
!            gc = gc + conjg(MO(i))*GG22(i,j)*MO(j)
!         end
!         end
!
!         grid(n) = gc
!
!      end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(grid)
!      end
!
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp) PPZPP.destroy
!
!      S.destroy
!      Z2.destroy
!      PZP2.destroy
!      GG22.destroy
!      YU.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!      m_out.destroy
!
!   end

!   make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,xx,yy,zz,n_gcm,S,sZ2,sPZP2) ::: private
!   ! correct the  picture change
!   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
!   ! this routine is based on the make_r_DKH_core_mx(H) routine
!      self :: INOUT
!      GG22 :: MAT{CPX}, OUT
!      YU :: MAT{REAL}, IN
!      Ap,Ep,P2 :: VEC{REAL}, IN
!      xx,yy,zz :: REAL, IN
!      n_gcm :: INT, IN
!      S :: MAT{REAL} , IN
!      sZ2,sPZP2 :: MAT{CPX}, IN
!
!      c,fac :: REAL
!      i,j :: INT
!      D,PDP,SOx,SOy,SOz :: MAT{REAL}*
!      D2,PDP2 :: MAT{CPX}*
!      WW,W2,TX,Z2,PZP2,X,T,A2,B2,M2 :: MAT{CPX}*
!      A,B,M :: MAT{REAL}*
!      II :: CPX
!
!      !!!  the density X operator !!!
!      D.create(n_gcm,n_gcm)
!      .REL:make_primitive_density_mx(D,xx,yy,zz)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(YU,D,transpose_a=TRUE)
!      D.to_product_of(A,YU)
!
!      !!!  the density PXP operator !!!
!      PDP.create(n_gcm,n_gcm)
!      .REL:make_primitive_pDp_mx(PDP,xx,yy,zz)
!      A.to_product_of(YU,PDP,transpose_a=TRUE)
!      PDP.to_product_of(A,YU)
!
!      SOx.create(n_gcm,n_gcm)
!      SOy.create(n_gcm,n_gcm)
!      SOz.create(n_gcm,n_gcm)
!      SOx=ZERO; SOy=ZERO; SOz=ZERO
!      .REL:make_primitive_pDp_SO_mx(SOx,SOy,SOz,xx,yy,zz)
!      A.to_product_of(YU,SOx,transpose_a=TRUE)
!      SOx.to_product_of(A,YU)
!      A.to_product_of(YU,SOy,transpose_a=TRUE)
!      SOy.to_product_of(A,YU)
!      A.to_product_of(YU,SOz,transpose_a=TRUE)
!      SOz.to_product_of(A,YU)
!      A.destroy
!
!      !!! A-O LETS GO !!!
!
!      B.create(2*n_gcm,2*n_gcm)
!      A.create(2*n_gcm,2*n_gcm)
!
!      c = SPEED_OF_LIGHT_AU
!
!      do i=1,n_gcm
!      do j=1,n_gcm
!         D(i,j) = Ap(i)*D(i,j)*Ap(j)
!         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))
!         SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))
!         SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))
!         SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))
!      end
!      end
!
!      D2.create(2*n_gcm,2*n_gcm)
!      D2=(ZERO,ZERO)
!      D2.a_alpha_plus(D)
!      D2.b_beta_plus(D)
!
!      II = (ZERO,ONE)
!      fac=ONE
!
!      PDP2.create(2*n_gcm,2*n_gcm)
!      PDP2=(ZERO,ZERO)
!      PDP2.a_alpha_plus(PDP)
!      PDP2.b_beta_plus(PDP)
!      PDP2.b_alpha_plus(SOx,fac*II)
!      PDP2.b_alpha_plus(SOy,-fac)
!      PDP2.a_alpha_plus(SOz,fac*II)
!      PDP2.b_beta_plus(SOz,-fac*II)
!      PDP2.make_hermitian
!
!      D.destroy
!      PDP.destroy
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!
!      if (.scfdata.DK1_PCE) then
!
!         A = ZERO
!         B = ZERO
!
!         do i = 1,n_gcm
!             B(i,i)             = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
!             B(i+n_gcm,i+n_gcm) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
!             A(i,i)             = ONE/B(i,i)
!             A(i+n_gcm,i+n_gcm) = ONE/B(i,i)
!         end
!
!         ! SO part comes first
!         ! fdff am not sure if it is implemented, seems not
!         T.create(2*n_gcm,2*n_gcm)
!         T =        matmul(sPZP2, matmul(A,PDP2) )
!         T =  T  -  matmul(sPZP2,D2)
!         T =  T  -  matmul(sZ2,PDP2)
!         T =  T  +  matmul(sZ2, matmul(B,D2) )
!         T =  T  +  matmul(D2, matmul(B,sZ2) )
!         T =  T  -  matmul(PDP2,sZ2)
!         T =  T  -  matmul(D2,sPZP2)
!         T =  T  +  matmul(PDP2, matmul(A,sPZP2) )
!
!         ! only the scalar second order correction
!         if (.scfdata.DK2_PCE) then
!
!            !!! W1W1
!            WW.create(2*n_gcm,2*n_gcm)
!            WW =      -  matmul(sZ2, matmul(B,sZ2) )
!            WW =  WW  +  matmul(sPZP2,sZ2)
!            WW =  WW  +  matmul(sZ2,sPZP2)
!            WW =  WW  -  matmul(sPZP2, matmul(A,sPZP2) )
!
!            X.create(2*n_gcm,2*n_gcm)
!            TX.create(2*n_gcm,2*n_gcm)
!
!            X  = D2 + PDP2
!            TX = HALF*(matmul(WW,X)+matmul(X,WW))
!
!            WW.destroy
!            X.destroy
!
!            Z2.create(2*n_gcm,2*n_gcm)
!            PZP2.create(2*n_gcm,2*n_gcm)
!
!            Z2   = (ZERO,ZERO)
!            PZP2 = (ZERO,ZERO)
!
!            do i=1,n_gcm
!            do j=1,n_gcm
!                Z2(i,j)=sZ2(i,j)*(Ep(i)+Ep(j))
!                Z2(i+n_gcm,j+n_gcm)=sZ2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
!                PZP2(i,j)=sPZP2(i,j)*(Ep(i)+Ep(j))
!                PZP2(i+n_gcm,j+n_gcm)=sPZP2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
!                PZP2(i,j+n_gcm)=sPZP2(i,j+n_gcm)*(Ep(i)+Ep(j))
!                PZP2(i+n_gcm,j)=sPZP2(i+n_gcm,j)*(Ep(i)+Ep(j))
!            end do
!            end do
!
!            TX = TX - matmul(sPZP2,matmul(A,matmul(PDP2,sZ2)))
!            TX = TX - matmul(sPZP2,matmul(D2,matmul(B,sZ2)))
!            TX = TX + matmul(sPZP2,matmul(A, matmul(PDP2, matmul(A,sPZP2))))
!            TX = TX + matmul(sPZP2, matmul(D2,sPZP2))
!            TX = TX + matmul(sZ2,matmul(PDP2,sZ2))
!            TX = TX + matmul(sZ2,matmul(B, matmul(D2, matmul(B,sZ2))))
!            TX = TX - matmul(sZ2,matmul(PDP2, matmul(A,sPZP2)))
!            TX = TX - matmul(sZ2,matmul(B, matmul(D2,sPZP2)))
!
!            !!!  The [W2,X(odd,0)] terms
!            !   the second derivatives are not used
!            W2.create(2*n_gcm,2*n_gcm)
!            W2 =      matmul( sPZP2, matmul(A, matmul(PZP2,A) ) )
!            W2 = W2 + matmul( sPZP2, Z2 )
!            W2 = W2 - matmul( sZ2, ( matmul(PZP2,A) ) )
!            W2 = W2 - matmul( sZ2, ( matmul(B,Z2) ) )
!            W2 = W2 - matmul( Z2,  matmul(sPZP2,A)  )
!            W2 = W2 - matmul( PZP2,  matmul(sPZP2,A)  )
!            W2 = W2 + matmul( Z2,  sZ2  )
!            W2 = W2 + matmul( PZP2,  sZ2  )
!            do i=1,n_gcm
!            do j=1,n_gcm
!               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
!               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
!            end do
!            end do
!
!            TX = TX + matmul(W2,PDP2)
!
!            W2 =    matmul( sZ2, Z2 )
!            W2 = W2 + matmul( sZ2, PZP2 )
!            W2 = W2 - matmul( matmul(A,sPZP2), Z2 )
!            W2 = W2 - matmul( matmul(A,sPZP2), PZP2 )
!            W2 = W2 - matmul( matmul(A,PZP2)  ,   sZ2)
!            W2 = W2 - matmul( matmul(Z2,B)  ,   sZ2)
!            W2 = W2 + matmul( matmul(A,matmul(PZP2,A)) , sPZP2)
!            W2 = W2 + matmul( Z2 , sPZP2)
!            do i=1,n_gcm
!            do j=1,n_gcm
!               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
!               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
!            end do
!            end do
!
!            TX = TX + matmul(PDP2,W2)
!
!            W2 =    - matmul( matmul(B,sZ2), Z2 )
!            W2 = W2 - matmul( matmul(B,sZ2), PZP2 )
!            W2 = W2 + matmul( sPZP2  ,   Z2 )
!            W2 = W2 + matmul( sPZP2  , PZP2 )
!            W2 = W2 + matmul( PZP2   ,  sZ2 )
!            W2 = W2 + matmul( matmul(B,matmul(Z2,B)) , sZ2)
!            W2 = W2 - matmul( matmul(PZP2,A) , sPZP2 )
!            W2 = W2 - matmul( matmul(B,Z2) , sPZP2 )
!            do i=1,n_gcm
!            do j=1,n_gcm
!               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
!               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
!            end do
!            end do
!
!            TX = TX + matmul(D2,W2)
!
!            W2 =    - matmul( sPZP2  , matmul(A,PZP2) )
!            W2 = W2 - matmul( sPZP2  , matmul(Z2,B) )
!            W2 = W2 + matmul( sZ2    , PZP2)
!            W2 = W2 + matmul( sZ2    , matmul( B, matmul(Z2,B) ) )
!            W2 = W2 + matmul( Z2 , sPZP2  )
!            W2 = W2 + matmul( PZP2 , sPZP2  )
!            W2 = W2 - matmul( Z2 ,  matmul(sZ2,B) )
!            W2 = W2 - matmul( PZP2 ,  matmul(sZ2,B) )
!            do i=1,n_gcm
!            do j=1,n_gcm
!               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) )
!               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) )
!               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) )
!            end do
!            end do
!
!            TX = TX + matmul(W2,D2)
!
!            W2.destroy
!            Z2.destroy
!            PZP2.destroy
!
!         end if
!
!      end if
!
!      D2 = D2 + PDP2
!
!      PDP2.destroy
!
!      if(.scfdata.DK1_PCE)then
!         D2 = D2 + T
!         T.destroy
!      end if
!
!      if(.scfdata.DK2_PCE)then
!         D2 = D2 + TX
!         TX.destroy
!      end if
!
!      A.destroy
!      B.destroy
!
!      ! back to cartesian basis set
!      A2.create(2*n_gcm,2*n_gcm)
!
!      B2.create(2*n_gcm,2*n_gcm)
!      B.create(n_gcm,n_gcm)
!
!      B.to_product_of(S,YU)
!      B2 = (ZERO,ZERO)
!      B2.a_alpha_plus(B)
!      B2.b_beta_plus(B)
!
!      A2.to_product_of(B2,D2)
!      D2.to_product_of(A2,B2,dagger_b=TRUE)
!
!      B.destroy
!      B2.destroy
!
!      !!! moving back to contracted basis sets
!      M2.create(2*.n_prim,2*.n_prim)
!      M.create(.n_prim,.n_prim)
!
!      .BASE:make_normalized_contraction_mx(M)
!
!      M2 = (ZERO,ZERO)
!      M2.a_alpha_plus(M)
!      M2.b_beta_plus(M)
!      A2.to_product_of(M2,D2,dagger_a=TRUE)
!      D2.to_product_of(A2,M2)
!
!      GG22 = D2
!
!      M.destroy
!      M2.destroy
!      A2.destroy
!      D2.destroy
!
!   end

!   make_DKH_mxs_2(YU,Ap,Ep,P2) ::: private
!   ! things necessary for the DKH transformation
!   ! within the PCE and the dkh_norm staff
!      self :: IN
!      YU :: MAT{REAL}, OUT
!      Ap,Ep :: VEC{REAL}, OUT
!      P2 :: VEC{REAL}
!
!      m_out :: MAT{INT}*
!      i,n_gcm :: INT
!      c :: REAL
!      S,Y,U :: MAT{REAL}*
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      !!! OVERLAP ENERGY MATRIX  !!!
!      S.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(S)
!      Y.create(n_gcm,n_gcm)
!      Y.to_inverse_sqrt_of(S)
!
!      !!!  KINETIC ENERGY MATRIX  !!!
!      .REL:make_primitive_kinetic_mx(S)
!      m_out.destroy
!
!      U.create(n_gcm,n_gcm)
!      U.to_product_of(Y,S)
!      S.to_product_of(U,Y)
!      S.solve_symmetric_eigenproblem(P2,U)
!      S.destroy
!
!      P2= TWO * P2
!
!      c = SPEED_OF_LIGHT_AU
!      do i = 1,n_gcm
!         Ep(i)= c * sqrt(P2(i) + c * c)
!         Ap(i)= sqrt( (Ep(i) + c * c)/(TWO * Ep(i)) )
!      end
!
!      YU.to_product_of(Y,U)
!
!      Y.destroy
!      U.destroy
!
!   end

!   make_DKH_mxs3_2(Z,PZP,Lx,Ly,Lz,YU) ::: private
!   ! get the Z and PZP matrix
!   ! which are in the momentum space
!      self :: IN
!      Z,PZP,Lx,Ly,Lz :: MAT{REAL}, OUT
!      YU :: MAT{REAL}, IN
!
!      m_out :: MAT{INT}*
!      i,j,n_gcm :: INT
!      c :: REAL
!      A,X :: MAT{REAL}*
!      Ep,Ap,P2 :: VEC{REAL}*
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      !!!  Z MATRIX  !!!
!      .REL:make_primitive_nuclear_mx(Z)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(YU,Z,transpose_a=TRUE)
!      Z.to_product_of(A,YU)
!
!      !!!  PZP and SO MATRICES  !!!
!      .REL:make_primitive_DKH_matrices(PZP,Lx,Ly,Lz)
!      A.to_product_of(YU,PZP,transpose_a=TRUE)
!      PZP.to_product_of(A,YU)
!      A.to_product_of(YU,Lx,transpose_a=TRUE)
!      Lx.to_product_of(A,YU)
!      A.to_product_of(YU,Ly,transpose_a=TRUE)
!      Ly.to_product_of(A,YU)
!      A.to_product_of(YU,Lz,transpose_a=TRUE)
!      Lz.to_product_of(A,YU)
!
!      A.destroy
!      m_out.destroy
!
!      c = SPEED_OF_LIGHT_AU
!
!      X.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!
!      .REL:make_DKH_mxs(X,Ap,Ep,P2)
!
!      do i=1,n_gcm
!      do j=1,n_gcm
!         Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
!         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!         Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!         Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!         Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
!      end
!      end
!
!      X.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!
!   end

! IOTC real orbitals

!   make_IOTC_orbital_grid_r(grid,orb,pt,square)
!   !  ???
!      self :: INOUT
!      grid :: VEC{REAL}, OUT
!      orb :: INT, IN
!      pt :: MAT{REAL}, IN
!      square :: BIN, IN, optional
!
!   ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
!
!      MO :: MAT{REAL}@
!
!      MO = .MOs.r(:,1:.n_a)
!      .GRID:density_IOTC_orb_r(grid,pt,MO(:,orb),square)
!
!   end

!   density_IOTC_orb_r(grid,pt,MO,square)
!   ! The density "grid" will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      self :: INOUT
!      grid :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      MO :: VEC{REAL}, IN
!      square :: BIN, optional, IN
!
!      n_gcm,n_pt :: INT
!      n,i,j,k :: INT
!      g,c,alpha,alpha2 :: REAL
!      m_out :: MAT{INT}*
!      R,Y,U,A,T,O :: MAT{REAL}*
!      SOx,SOy,SOz,Yr :: MAT{REAL}*
!      YU,GG,S,Z,PZP :: MAT{REAL}*
!      P2,Ap,E,p,ep,bp :: VEC{REAL}*
!
!      n_pt = pt.dim1
!
!      !!! analysis of the primitive basis set via the overap matrix
!      !!! trying to lower the problem to an general contracted basis set
!      !!!  OVERLAP MATRIX !!!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
!      ! put the overlap matrix into the n_gcm non-redundant space
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!
!      Y.create(n_gcm,n_gcm)
!      Y.to_inverse_sqrt_of(S)
!
!      !!!  KINETIC ENERGY MATRIX !!!
!      .REL:make_primitive_kinetic_mx(R)
!      T.create(n_gcm,n_gcm)
!      ! put the kinetic energy matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,T,m_out)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(Y,T)
!      T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
!      U.create(n_gcm,n_gcm)
!      P2.create(n_gcm)
!      T.solve_symmetric_eigenproblem(P2,U)
!      P2= TWO * P2
!      YU.create(n_gcm,n_gcm)
!      YU.to_product_of(Y,U)
!      T.destroy
!      Y.destroy
!      U.destroy
!
!      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
!      .REL:make_primitive_nuclear_mx(R)
!      Z.create(n_gcm,n_gcm)
!      ! put the potential energy matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,Z,m_out)
!
!      A.to_product_of(YU,Z,transpose_a=TRUE)
!      Z.to_product_of(A,YU)
!
!      !!!  PZP MATRIX  !!!
!      SOx.create(.n_prim,.n_prim)
!      SOy.create(.n_prim,.n_prim)
!      SOz.create(.n_prim,.n_prim)
!      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!
!      PZP.create(n_gcm,n_gcm)
!      ! put the PZP matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,PZP,m_out)
!
!      A.to_product_of(YU,PZP,transpose_a=TRUE)
!      PZP.to_product_of(A,YU)
!
!      !!! A-O LETS GO !!!
!      c      = SPEED_OF_LIGHT_AU
!      alpha  = ONE/c
!      alpha2 = alpha*alpha
!
!      E.create(n_gcm)
!      p.create(n_gcm)
!      ep.create(n_gcm)
!      Ap.create(n_gcm)
!      bp.create(n_gcm)
!
!      do i = 1,n_gcm
!         E(i)  = c * sqrt(P2(i) + c*c)
!         p(i)  = sqrt(P2(i))
!         ep(i) = sqrt(ONE+P2(i)*alpha2)
!         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )
!         bp(i) = ONE/(ep(i)+ONE)
!      end
!
!      P2.destroy
!
!      do i=1,n_gcm
!      do j=1,n_gcm
!         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
!         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
!      end
!      end
!
!      ! lets find the transforation matrix
!      Yr.create(n_gcm,n_gcm)
!
!      .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
!
!      ! lets make ready the normalzation matrix
!      O.create(n_gcm,n_gcm)
!      O = ZERO
!      do i = 1,n_gcm
!         O(i,i) = ONE
!         do j=1,n_gcm
!         do k=1,n_gcm
!            O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
!         end do
!         end do
!      end do
!
!      A.to_inverse_sqrt_of(O)
!      O = A
!      Z.destroy
!      PZP.destroy
!      A.destroy
!
!      GG.create(.n_bf,.n_bf)
!      grid=ZERO
!      parallel do n = 1,n_pt
!
!         ! here it comes babes point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to it's non-relativistic counter part really not
!         ! effective :(
!         .GRID:make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
!
!         g = ZERO
!
!         do i = 1,.n_bf
!         do j = 1,.n_bf
!            g = g + MO(i)*GG(i,j)*MO(j)
!         end
!         end
!
!         ! unfortunatelly the PCE corrected orbitals lose phase :(
!         if (NOT square) g = sqrt(g)
!
!         grid(n) = g
!
!      end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(grid)
!      end
!
!      R.destroy
!      S.destroy
!      O.destroy
!      GG.destroy
!      YU.destroy
!      Yr.destroy
!      Ap.destroy
!      E.destroy
!      p.destroy
!      bp.destroy
!      ep.destroy
!      m_out.destroy
!
!   end

!   make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O) ::: private
!   ! correct the picture change
!   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
!   ! this routine is based on the make_r_DKH_core_mx(H) routine
!      self :: INOUT
!      GG :: MAT{REAL} , OUT
!      Yr,YU :: MAT{REAL} , IN
!      Ap,bp,p :: VEC{REAL} , IN
!      ep :: VEC{REAL}
!      xx,yy,zz :: REAL , IN
!      m_out :: MAT{INT} , IN
!      n_gcm :: INT , IN
!      S,O :: MAT{REAL} , IN
!
!      i,j :: INT
!      R :: MAT{REAL}*
!      D,PDP,PPDPP :: MAT{REAL}*
!      A,B :: MAT{REAL}*
!      M,buco :: MAT{REAL}*
!
!      ep = ep
!
!      !!!  the density operator X !!!
!      R.create(.n_prim,.n_prim)
!      ! it do not exist in the moment
!      .REL:make_primitive_density_mx(R,xx,yy,zz)
!      D.create(n_gcm,n_gcm)
!      ! put the potential energy matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,D,m_out)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(YU,D,transpose_a=TRUE)
!      D.to_product_of(A,YU)
!
!      !!!  PDP MATRIX  !!!
!      .REL:make_primitive_pDp_mx(R,xx,yy,zz)
!
!      PDP.create(n_gcm,n_gcm)
!      ! put the PDP matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,PDP,m_out)
!      A.to_product_of(YU,PDP,transpose_a=TRUE)
!      PDP.to_product_of(A,YU)
!
!      if (.scfdata.using_ppzpp) then
!         .REL:make_primitive_ppDpp_mx(R,xx,yy,zz)
!         PPDPP.create(n_gcm,n_gcm)
!         .REL:get_da_gcm_now(R,PPDPP,m_out)
!         A.to_product_of(YU,PPDPP,transpose_a=TRUE)
!         PPDPP.to_product_of(A,YU)
!      end if
!
!      !!! A-O LETS GO !!!
!
!      do i=1,n_gcm
!      do j=1,n_gcm
!         D(i,j)   = Ap(i)*D(i,j)*Ap(j)
!         PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
!      end
!      end
!
!      if(.scfdata.using_ppzpp)then
!         ! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms
!         do i=1,n_gcm
!         do j=1,n_gcm
!            PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j)
!         end do
!         end do
!      end if
!
!      B.create(n_gcm,n_gcm)
!      if (.scfdata.using_ppzpp) then; .GRID:build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm,PPDPP)
!      else;                           .GRID:build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm)
!      end if
!
!      D=ZERO
!      D=matmul(O,matmul(B,O))
!
!     PDP.destroy
!     if(.scfdata.using_ppzpp)then
!      PPDPP.destroy
!     end if
!
!      B=ZERO
!      B.to_product_of(S,YU)
!
!      A=ZERO
!      A.to_product_of(B,D)
!      D.to_product_of(A,B,transpose_b=TRUE)
!
!      A.destroy
!      B.destroy
!
! !!! moving back to tonto style primitive basis sets
!      R=ZERO
! ! put the Fock matrix back to the space .n_prim space
!      .REL:get_back_prim_now(D,R,m_out)
!      D.destroy
!
! !!! moving back to contracted basis sets
!      M.create(.n_prim,.n_bf)
!      .BASE:make_normalized_contraction_mx(M)
!      buco.create(.n_bf,.n_prim)
!      buco.to_product_of(M,R,transpose_a=TRUE)
!      R.destroy
!
!      GG.to_product_of(buco,M)
!
!      M.destroy
!      buco.destroy
!
!   end

!   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,n_gcm,ppApp) ::: private
!   ! build the IOTC Y matrix, real version
!      self :: INOUT
!      F :: MAT{REAL}, OUT
!      Yr,PAP,A :: MAT{REAL}, IN
!      p,bp :: VEC{REAL}, IN
!      n_gcm :: INT, IN
!      ppApp :: MAT{REAL}, optional, IN
!
!      i,j :: INT
!      c,alpha,alpha2 :: REAL
!      AAA,F1R,F1L,F2 :: MAT{REAL}*
!
!      c      = SPEED_OF_LIGHT_AU
!      alpha  = ONE/c
!      alpha2 = alpha*alpha
!
!      F1L.create(n_gcm,n_gcm)
!      F1R.create(n_gcm,n_gcm)
!       F2.create(n_gcm,n_gcm)
!      AAA.create(n_gcm,n_gcm)
!
!      if( .scfdata.using_ppzpp)then
!         do i = 1,n_gcm
!         do j = 1,n_gcm
!            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
!         end do
!         end do
!      else
!         do i = 1,n_gcm
!         do j = 1,n_gcm
!            AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
!         end do
!         end do
!      end
!
!      do i = 1,n_gcm
!      do j = 1,n_gcm
!          F(i,j)  = A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
!         F1L(i,j) = alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )
!         F1R(i,j) = alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
!          F2(i,j) = PAP(i,j)/p(j)/p(i) + AAA(i,j)
!         end do
!      end do
!
!      F2.change_basis_using(Yr)
!
!      F.plus_product_of( Yr,F1L,transpose_a=TRUE)
!      F.plus_product_of(F1R,Yr)
!      F.plus(F2)
!
!      ! Remove matmuls -- dylan
!    ! F=F+matmul(transpose(Yr),F1L)
!    ! F=F+matmul(F1R,Yr)
!    ! F=F+matmul(transpose(Yr),matmul(F2,Yr))
!
!      AAA.destroy
!       F2.destroy
!      F1R.destroy
!      F1L.destroy
!
!   end

! IOTC general complex orbitals

!   make_IOTC_orb_dens_grid_gc(grid,orb,pt)
!   ! ???
!      self :: INOUT
!      grid :: VEC{CPX}, OUT
!      orb :: INT, IN
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.MOs.is_allocated_with_genre("gc"),"no MO's")
!
!      CMO :: MAT{CPX}@
!
!      CMO = .MOs.gc(:,1:.n_e)
!      .GRID:density_IOTC_orb_gc(grid,pt,CMO(:,orb))
!
!   end

!   density_IOTC_orb_gc(grid,pt,MO)
!   ! The density "grid" will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      self :: INOUT
!      grid :: VEC{CPX}, OUT
!      pt :: MAT{REAL} , IN
!      MO :: VEC{CPX} , IN
!
!      n_gcm,n_pt :: INT
!      n,i,j :: INT
!      g,c,alpha,alpha2,eps :: REAL
!      II :: CPX
!      m_out,mmm :: MAT{INT}*
!      Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
!      GG22 :: MAT{CPX}*
!      SOx,SOy,SOz :: MAT{REAL}*
!      A2,PAP,O,Ox,Yr :: MAT{CPX}*
!      Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*
!
!      n_pt = pt.dim1
!
!      !test
!      mmm.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(mmm,n_gcm)
!      mmm.destroy
!
!      if ( abs(.n_prim-n_gcm)> 0 OR abs(.n_prim-.n_bf)>0) then
!         DIE(" contracted gaussians do not work for IOTC at gchf level!")
!      end if
!
!      !!! n_gcm = .n_prim = .n_bf ??? --dylan
!
!      ! this is actually not needed but I am also using n_gcm
!      m_out.create(.n_prim,.n_prim)
!      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      S.create(n_gcm,n_gcm)
!      Y.create(n_gcm,n_gcm)
!
!      !!!  OVERLAP MATRIX + Y MX !!!
!      .REL:make_primitive_overlap_mx(S)
!      Y.to_inverse_sqrt_of(S)
!      !  .make_S_Y(S,Y)  !  ???
!
!      !!!  KINETIC ENERGY MATRIX -> U & P2!!!
!      T.create(n_gcm,n_gcm)
!      .REL:make_primitive_kinetic_mx(T)
!      R.to_product_of(Y,T)
!      T.to_product_of(R,Y)
!      ! T=YTY  kinetic energy in an orthogonal basis
!      P2.create(n_gcm)
!      U.create(n_gcm,n_gcm)
!      T.solve_symmetric_eigenproblem(P2,U)
!      ! the momentum squared instead of kinetic energy
!      P2= TWO * P2
!
!      YU.create(n_gcm,n_gcm)
!      YU.to_product_of(Y,U)
!      Y.destroy
!      U.destroy
!      T.destroy
!
!      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
!      Z.create(n_gcm,n_gcm)
!      .REL:make_primitive_nuclear_mx(Z)
!      ! put the potential energy matrix into the YU space
!      R.to_product_of(YU,Z,transpose_a=TRUE)
!      Z.to_product_of(R,YU)
!
!      !!!  PZP MATRIX  !!!
!      PZP.create(n_gcm,n_gcm)
!      SOx.create(.n_prim,.n_prim)
!      SOy.create(.n_prim,.n_prim)
!      SOz.create(.n_prim,.n_prim)
!      .REL:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
!
!      R.to_product_of(YU,PZP,transpose_a=TRUE)
!      PZP.to_product_of(R,YU)
!      R.to_product_of(YU,SOx,transpose_a=TRUE)
!      SOx.to_product_of(R,YU)
!      R.to_product_of(YU,SOy,transpose_a=TRUE)
!      SOy.to_product_of(R,YU)
!      R.to_product_of(YU,SOz,transpose_a=TRUE)
!      SOz.to_product_of(R,YU)
!
!      !!! A-O LETS GO !!!
!      c      = SPEED_OF_LIGHT_AU
!      alpha  = ONE/c
!      alpha2 = alpha*alpha
!
!      E.create(2*n_gcm)
!      ep.create(2*n_gcm)
!      p.create(2*n_gcm)
!      bp.create(2*n_gcm)
!      Ap.create(n_gcm)
!
!      do i = 1,n_gcm
!         E(i)       = c * sqrt(P2(i) + c * c)
!         E(i+n_gcm) = c * sqrt(P2(i) + c * c)
!         p(i)       = sqrt(P2(i))
!         p(i+n_gcm) = sqrt(P2(i))
!         ep(i)      = sqrt(ONE+P2(i)*alpha2)
!         ep(i+n_gcm)= sqrt(ONE+P2(i)*alpha2)
!         bp(i)      = ONE/(ep(i)+ONE)
!         bp(i+n_gcm)= ONE/(ep(i)+ONE)
!         Ap(i)      = sqrt( (E(i) + c * c)/(TWO * E(i)) )
!      end do
!
!      P2.destroy
!
!      do i = 1,n_gcm
!      do j=1,n_gcm
!         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
!         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
!         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
!         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
!         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
!      end
!      end
!
!      A2.create(2*n_gcm,2*n_gcm)
!      A2 = (ZERO,ZERO)
!      A2.a_alpha_plus(Z)
!      A2.b_beta_plus(Z)
!
!      PAP.create(2*n_gcm,2*n_gcm)
!      PAP = (ZERO,ZERO)
!      PAP.a_alpha_plus(PZP)
!      PAP.b_beta_plus(PZP)
!      II = (ZERO,ONE)
!      PAP.b_alpha_plus(SOx,II)
!      PAP.b_alpha_plus(SOy,-ONE)
!      PAP.a_alpha_plus(SOz,II)
!      PAP.b_beta_plus(SOz,-II)
!      PAP.make_hermitian
!
!      ! lets find the transforation matrix
!      Yr.create(2*n_gcm,2*n_gcm)
!      Y0.create(n_gcm,n_gcm)
!
!      .REL:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
!
!      Z.destroy
!      PZP.destroy
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!      R.destroy
!
!      ! lets find the transforation matrix
!      Yr = (ZERO,ZERO)
!      Yr.a_alpha_plus(Y0)
!      Yr.b_beta_plus(Y0)
!      Y0.destroy
!
!      .REL:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
!
!      PAP.destroy
!      A2.destroy
!
!      O.create(2*n_gcm,2*n_gcm)
!      Ox.create(2*n_gcm,2*n_gcm)
!      Ox= (ZERO,ZERO)
!      do i=1,2*n_gcm
!         Ox(i,i)=ONE
!      end do
!      O.to_product_of(Yr,Yr,dagger_a=TRUE)
!      Ox = Ox + O
!
!      ! make ready the preconditioning
!      UN.create(2*n_gcm)
!      do i=1,2*n_gcm
!         UN(i)=ONE/sqrt(real(Ox(i,i)))
!      end
!
!      do i=1,2*n_gcm
!      do j=1,2*n_gcm
!         Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
!      end
!      end
!
!      eps=TOL(15)
!      O.to_power_series_inv_sqrt_of(Ox,eps)
!      do i=1,2*n_gcm
!      do j=1,2*n_gcm
!         O(i,j) = O(i,j)*UN(j)
!      end
!      end
!
!      UN.destroy
!      Ox.destroy
!
!      GG22.create(2*n_gcm,2*n_gcm)
!      grid=ZERO
!      parallel do n = 1,n_pt
!
!         ! here it comes babes point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to it's non-relativistic counter part really not
!         ! effective :(
!         .GRID:make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
!
!         g = ZERO
!
!         do i=1,2*.n_bf
!         do j=1,2*.n_bf
!            g = g + REALIFY(conjg(MO(i))*GG22(i,j)*MO(j))
!         end
!         end
!
!         grid(n)= g
!
!      end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(grid)
!      end
!
!      S.destroy
!      O.destroy
!      Yr.destroy
!      GG22.destroy
!      YU.destroy
!      Ap.destroy
!      E.destroy
!      bp.destroy
!      ep.destroy
!      p.destroy
!      m_out.destroy
!
!   end

!   make_DENSITY_IOTC_PCE_SO_off(GG,Yr,YU,Ap,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O) ::: private
!   ! correct the  picture change
!   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
!   ! this routine is based on the make_r_DKH_core_mx(H) routine
!      self :: INOUT
!      GG :: MAT{CPX}, OUT
!      Yr :: MAT{CPX}, IN
!      YU :: MAT{REAL} , IN
!      Ap,bp,p :: VEC{REAL} , IN
!      ep :: VEC{REAL}
!      xx,yy,zz :: REAL , IN
!      m_out :: MAT{INT} , IN
!      n_gcm :: INT , IN
!      S :: MAT{REAL} , IN
!      O :: MAT{CPX}
!
!      II :: CPX
!      fac :: REAL
!      i,j :: INT
!      F,A2,B2,M2,buco,PAP,ppApp :: MAT{CPX}*
!      R :: MAT{REAL}*
!      D,PDP,SOx,SOy,SOz,PPDPP :: MAT{REAL}*
!      A,B,M :: MAT{REAL}*
!
!      ep = ep
!
!      !!!  the density X operator !!!
!      R.create(.n_prim,.n_prim)
!      D.create(n_gcm,n_gcm)
!      .REL:make_primitive_density_mx(D,xx,yy,zz)
!
!      A.create(n_gcm,n_gcm)
!      A=ZERO
!      A.to_product_of(YU,D,transpose_a=TRUE)
!      D.to_product_of(A,YU)
! !!!  the density PXP operator !!!
!      PDP.create(n_gcm,n_gcm)
!      PDP=ZERO
!      .REL:make_primitive_pDp_mx(PDP,xx,yy,zz)
!      A=ZERO
!      A.to_product_of(YU,PDP,transpose_a=TRUE)
!      PDP.to_product_of(A,YU)
! !!!  SO MATRICES  !!!
!      SOx.create(n_gcm,n_gcm)
!      SOy.create(n_gcm,n_gcm)
!      SOz.create(n_gcm,n_gcm)
!       SOx=ZERO; SOy=ZERO; SOz=ZERO
!      .REL:make_primitive_pDp_SO_mx(SOx,SOy,SOz,xx,yy,zz)
!      A=ZERO
!      A.to_product_of(YU,SOx,transpose_a=TRUE)
!      SOx.to_product_of(A,YU)
!      A=ZERO
!      A.to_product_of(YU,SOy,transpose_a=TRUE)
!      SOy.to_product_of(A,YU)
!      A=ZERO
!      A.to_product_of(YU,SOz,transpose_a=TRUE)
!      SOz.to_product_of(A,YU)
!
! !!! A-O LETS GO !!!
!
!      A=ZERO
!
!      do i=1,n_gcm
!        do j=1,n_gcm
!
!         D(i,j) = Ap(i)*D(i,j)*Ap(j)
!         PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
!         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
!         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
!         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
!
!        end
!      end
!
!      if(.scfdata.using_ppzpp)then
!        PPDPP.create(n_gcm,n_gcm)
!        PPDPP=ZERO
!        .REL:make_primitive_ppDpp_mx(PPDPP,xx,yy,zz)
!        .REL:get_da_gcm_now(R,PPDPP,m_out)
!        A=ZERO
!        A.to_product_of(YU,PPDPP,transpose_a=TRUE)
!        PPDPP.to_product_of(A,YU)
!
!         do i=1,n_gcm
!           do j=1,n_gcm
!             PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j)
!           end do
!         end do
!       end if
!     A.destroy
!
!    A2.create(2*n_gcm,2*n_gcm)
!    A2=(ZERO,ZERO)
!      A2.a_alpha_plus(D)
!      A2.b_beta_plus(D)
! !   A.make_hermitian
!    PAP.create(2*n_gcm,2*n_gcm)
!    PAP=(ZERO,ZERO)
!      PAP.a_alpha_plus(PDP)
!      PAP.b_beta_plus(PDP)
!      II = (ZERO,ONE)
!      fac= ONE
!       PAP.b_alpha_plus(SOx,fac*II)
!       PAP.b_alpha_plus(SOy,-fac)
!       PAP.a_alpha_plus(SOz,fac*II)
!       PAP.b_beta_plus(SOz,-fac*II)
!    PAP.make_hermitian
!    if( .scfdata.using_ppzpp)then
!    ppApp.create(2*n_gcm,2*n_gcm)
!    ppApp=(ZERO,ZERO)
!      ppApp.a_alpha_plus(PPDPP)
!      ppApp.b_beta_plus(PPDPP)
! !  ppApp.make_hermitian
!      PPDPP.destroy
!    end if
!      D.destroy
!      PDP.destroy
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!      R.destroy
!
!      ! the hamiltonian is gonna be built
!      F.create(2*n_gcm,2*n_gcm)
!      if (.scfdata.using_ppzpp) then; .GRID:build_da_IOTC_dens(F,Yr,PAP,A2,p,bp,ppApp)
!      else;                           .GRID:build_da_IOTC_dens(F,Yr,PAP,A2,p,bp)
!      end if
!
!      PAP.destroy
!      if( .scfdata.using_ppzpp)then
!        ppApp.destroy
!      end if
!
!      A2=(ZERO,ZERO)
!      ! normalization
!      A2.to_product_of(F,O)
!      F.to_product_of(O,A2,dagger_a=TRUE)
!
!      ! back to cartesian basis set
!      B2.create(2*n_gcm,2*n_gcm)
!      B.create(n_gcm,n_gcm)
!
!      B.to_product_of(S,YU)
!
!      B2=(ZERO,ZERO)
!      B2.a_alpha_plus(B)
!      B2.b_beta_plus(B)
!      B.destroy
!
!      A2.to_product_of(B2,F)
!      F.to_product_of(A2,B2,dagger_b=TRUE)
!
!      B2.destroy
!
!      !!! moving back to contracted basis sets
!      M.create(.n_prim,.n_bf)
!
!      .BASE:make_normalized_contraction_mx(M)
!
!      M2.create(2*.n_prim,2*.n_prim)
!      M2 = (ZERO,ZERO)
!      M2.a_alpha_plus(M)
!      M2.b_beta_plus(M)
!
!      buco.create(2*.n_prim,2*.n_prim)
!      buco.to_product_of(M2,F,dagger_a=TRUE)
!      A2.to_product_of(buco,M2)
!
!      M.destroy
!      F.destroy
!      M2.destroy
!      buco.destroy
!
!      GG = A2
!
!      A2.destroy
!
!   end

!   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,ppApp) ::: private
!   ! build the IOTC Y matrix, general complex version
!      self :: INOUT
!      F :: MAT{CPX}, OUT
!      Yr,PAP,A :: MAT{CPX}, IN
!      p,bp :: VEC{REAL}, IN
!      ppApp :: MAT{CPX}, optional, IN
!
!      i,j,n_gcm,dim :: INT
!      c,alpha,alpha2 :: REAL
!      AAA,F1R,F1L,F2 :: MAT{CPX}*
!
!      n_gcm=.n_prim
!      c = SPEED_OF_LIGHT_AU
!      alpha = ONE/c
!      alpha2= alpha*alpha
!
!      dim = 2*n_gcm
!
!      F1L.create(dim,dim)
!      F1R.create(dim,dim)
!       F2.create(dim,dim)
!      AAA.create(dim,dim)
!
!      if (.scfdata.using_ppzpp) then
!
!         do i = 1,dim
!         do j = 1,dim
!            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
!         end do
!         end do
!
!      else
!
!         do i = 1,dim
!         do j = 1,dim
!            AAA(i,j) = alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
!         end do
!         end do
!
!      end
!
!      do i = 1,dim
!      do j = 1,dim
!          F(i,j)  =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
!         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )
!         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
!          F2(i,j) =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
!      end do
!      end do
!
!      F2.change_basis_using(Yr)
!
!      F.plus_product_of( Yr,F1L,dagger_a=TRUE)
!      F.plus_product_of(F1R,Yr)
!      F.plus(F2)
!
!      ! Remove matmuls
!    ! AAA.to_product_of(Yr,F1L,dagger_a=TRUE)
!    ! F=F+AAA+matmul(F1R,Yr)
!    ! AAA.to_product_of(Yr,F2,dagger_a=TRUE)
!    ! F=F+matmul(AAA,Yr)
!
!      AAA.destroy
!      F1L.destroy
!      F1R.destroy
!      F2.destroy
!
!   end

!  ==================
!  Nabla orbital grid
!  ==================

   make_nabla_orbital_grid(grid1,grid0,orb,pt) ::: template
   ! Evaluate the nabla orbital density "grid1" as well as the orbital
   ! density "grid0" for *one* AO-basis orbital vector "orb" on a set
   ! of grid points "pt"
      self :: IN
      grid1 :: MAT{TYPE?}, OUT
      grid0 :: VEC{TYPE?}, OUT
      orb :: VEC{TYPE?}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(grid1.dim1==pt.dim1,"grid1, wrong 1st dimension")
   ENSURE(grid1.dim2==3,      "grid1, wrong 2nd dimension")
   ENSURE(grid0.dim==pt.dim1, "grid0, wrong size")

      sh :: SHELL1
      sh_grid1 :: MAT3{REAL}@
      sh_grid0 :: MAT{REAL}@
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      grid1 = ZERO
      grid0 = ZERO

      do a = 1,.n_shell

         .SET:set_shell1_from(a,sh,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)

         sh.make_nabla_grid(sh_grid1,sh_grid0,pt)

         grid1(:,1).plus_product_of(sh_grid1(:,:,1),orb(fa:la))
         grid1(:,2).plus_product_of(sh_grid1(:,:,2),orb(fa:la))
         grid1(:,3).plus_product_of(sh_grid1(:,:,3),orb(fa:la))
         grid0.plus_product_of(sh_grid0,orb(fa:la))

         sh_grid0.destroy
         sh_grid1.destroy

      end

   end

   make_nabla_orbital_grid_r(grid1,grid0,orb,pt) ::: get_from(make_nabla_orbital_grid, TYPE?=>REAL), PURE
   ! Evaluate the nabla orbital density "grid1" as well as the orbital
   ! density "grid0" for *one* AO-basis orbital vector "orb" on a set
   ! of grid points "pt"
   end

!  ==================
!  Nabla density grid
!  ==================

!   make_nabla_density_grid_fdm_r(nabla_grid,pts)
!   ! Work out the nabla density on ".plot_grid" using ".natural orbitals" and the
!   ! ".occupation" number vector.
!   ! This method uses the finite difference method to calculate the gradient
!   ! from the density.  It is much slower, but useful for checking.
!     nabla_grid, pts :: MAT{REAL}
!   ENSURE(pts.dim2==3,  "wrong dimension for points array")
!   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
!   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
!   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")
!     orb :: VEC{REAL}*
!     dens_1,dens_2,nabla_orb,comp :: VEC{REAL}*
!     pt1 :: MAT{REAL}*
!     alpha :: REAL
!     n_occ,n,n_pts,i :: INT
!     alpha = TOL(6)
!     n_pts = size(pts,1)
!     pt1.create(n_pts,3)
!     nabla_grid = ZERO
!     orb.create(n_pts)
!     dens_1.create(n_pts)
!     dens_2.create(n_pts)
!     nabla_orb.create(n_pts)
!     n_occ = .INQ:no_of_occupied_NOs
!     do n = 1,n_occ
!        do i = 1,3
!          comp => pt1(:,i)
!          pt1 = pts;    comp = comp + alpha
!          .GRID:make_orbital_grid_r(dens_1,.NOs.r(:,n),pt1,square=TRUE)
!          pt1 = pts;    comp = comp - alpha
!          .GRID:make_orbital_grid_r(dens_2,.NOs.r(:,n),pt1,square=TRUE)
!          nabla_orb = HALF/alpha * (dens_1 - dens_2)
!          .GRID:make_orbital_grid_r(orb,.NOs.r(:,n), pts)
!          nabla_grid(:,i) = nabla_grid(:,i) + .NO_occ_nos.r(n)*orb(:)*nabla_orb
!        end
!     end
!     nabla_grid = TWO*nabla_grid
!     nabla_orb.destroy
!     dens_2.destroy
!     dens_1.destroy
!     orb.destroy
!     pt1.destroy
!   end

   make_nabla_density_grid(nabla_grid,pts) ::: PURE
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      self :: IN
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.NOs.number_kind)=="real") then
         .GRID:make_nabla_density_grid_r(nabla_grid,pts)
    ! else
    !    DIE("not implemented")
      end

   end

   make_nabla_density_grid(nabla_grid,grid,pts) ::: PURE
   ! Work nabla of the density, "nabla_grid", and the density, "grid, evaluated
   ! on the set of points "pts".
      self :: IN
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.NOs.number_kind)=="real") then
         .GRID:make_nabla_density_grid_r(nabla_grid,grid,pts)
    ! else
    !    DIE("not implemented")
      end

   end

   make_nabla_density_grid_r(nabla_grid,pts) ::: PURE
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".NOs" and the ".occupation" number vector.
      self :: IN
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")
   ENSURE(.NO_occ_nos.is_allocated_with_genre("r "),"no occupation numbers")

      orb :: VEC{REAL}@
      nabla_orb :: MAT{REAL}@
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = pts.dim1
      n_occ = .INQ:no_of_occupied_NOs

      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      nabla_grid = ZERO

      do n = 1,n_occ

         .GRID:make_nabla_orbital_grid_r(nabla_orb,orb,.NOs.r(:,n), pts)

         occ = .NO_occ_nos.r(n)

         nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
         nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
         nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)

      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_density_grid_r(nabla_grid,grid,pts) ::: PURE
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".NOs" and the ".occupation"   ! number vector.      se;lf
      self :: IN
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")
   ENSURE(.NO_occ_nos.is_allocated_with_genre("r "),"no occupation numbers")

      orb :: VEC{REAL}@
      nabla_orb :: MAT{REAL}@
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = pts.dim1
      n_occ = .INQ:no_of_occupied_NOs

      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      nabla_grid = ZERO
      grid       = ZERO

      do n = 1,n_occ

         .GRID:make_nabla_orbital_grid_r(nabla_orb,orb,.NOs.r(:,n), pts)

         occ = .NO_occ_nos.r(n)

         nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
         nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
         nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
         grid(:)         = grid(:)         + occ*orb(:)*orb(:)

      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

!  ======================
!  Laplacian orbital grid
!  ======================

   make_laplacian_orbital_grid_r(g,h,i,orb,pt) ::: PURE
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      self :: IN
      g,h  :: MAT{REAL}, OUT 
      i :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid1 :: MAT3{REAL}@
      sh_grid2 :: MAT3{REAL}@
      sh_grid3 :: MAT{REAL}@
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO
      i = ZERO

      do a = 1,.n_shell

         .SET:set_shell1_from(a,sh,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid2.create(n_pt,na,3)
         sh_grid3.create(n_pt,na)

         sh.make_laplacian_grid(sh_grid1,sh_grid2,sh_grid3,pt)

         g(:,1) = g(:,1) + matmul(sh_grid1(:,:,1),orb(fa:la))
         g(:,2) = g(:,2) + matmul(sh_grid1(:,:,2),orb(fa:la))
         g(:,3) = g(:,3) + matmul(sh_grid1(:,:,3),orb(fa:la))
         h(:,1) = h(:,1) + matmul(sh_grid2(:,:,1),orb(fa:la))
         h(:,2) = h(:,2) + matmul(sh_grid2(:,:,2),orb(fa:la))
         h(:,3) = h(:,3) + matmul(sh_grid2(:,:,3),orb(fa:la))
              i = i      + matmul(sh_grid3,       orb(fa:la))

         sh_grid3.destroy
         sh_grid2.destroy
         sh_grid1.destroy

      end

   end

!  ==========================================
!  Fast memory-intensive electron density (?)
!  ==========================================

! Below deprecated in favour of Kan's version

   make_fast_ED_grid_r(rho,pt,DM) ::: leaky, PURE
   ! Get the electron density grid "rho" of a list of 3D points "pt".
   ! Set "spin_density" to TRUE if you want those.
      self :: IN
      rho  :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN
      DM   :: MAT{REAL}, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(pt.dim1==rho.dim,"incompatible pt and rho arrays")
   ENSURE(pt.dim2==3,"wrong dim2 for pt array")
   ENSURE(DM.is_square,"DM is not square")
   ENSURE(DM.dim1==.n_bf,"DM is not square")

      ra :: VEC{REAL}(3)
      xa,ya,za,a2 :: VEC{REAL}@
      ga,gb :: VEC{REAL}@
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab, skipa,skipb :: VEC{BIN}@
      sha :: SHELL1
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      cutoff, Dab, fac, val :: REAL
      n_pt,n_keep :: INT
      c,ca,cb :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb :: INT
      sa,fa,la,na, as :: INT
      sb,fb,lb,nb :: INT
      a,b,i,j,n,p :: INT

      ! Basis function cutoff
      ! Hard-coded! Make it an option ...
      cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF

      ! Max no of becke grid points per atom
      n_pt = pt.dim1

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Make the SF's
      rho = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.atom.dim

         ! Overlapping atoms
         overlapping_atom = .overlapping_atoms_for_atom(c).element

         ! Basis function grid and skip list
         ! Only for the shells overlapping atom "c"
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell "sa"
               as  = .basis_shell_for_shell(sa)
               sha = .basis_shell1pair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element.create(skipa.dim)
               bf_skip(sa).element = skipa

               ! Make the "sa" basis function grida
               bf_grid(sa).element.create(n_keep,na)
               sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.deallocated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga = bf_grid(sa)[:,1]
                        gb = bf_grid(sb)[:,1]
                        Dab = fac*DM(fa,fb)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga = bf_grid(sa)[:,a]
                           do b = 1,nb
                              gb = bf_grid(sb)[:,b]
                              Dab = fac*DM(fa+a-1,fb+b-1)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                  end
               end
            end
         end

         ! Clean up atom "c" stuff
         bf_grid.destroy
         bf_skip.destroy

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(rho)
      end

   end

   add_ED_grid(grid,pt,DM,lshft,rshft) ::: PURE
   ! Update the "rho" grid for the supplied points "pt" using density
   ! matrix "DM". If present, translate the left (right) basis
   ! functions by "lshft" ("rshft") when evaluating DM sum; this is
   ! for basis functions in different unit cells than the central
   ! (reference) cell. 
      self  :: IN
      grid  :: VEC{REAL}, INOUT
      pt    :: MAT{REAL}, IN
      DM    :: MAT{REAL}, IN
      lshft :: VEC{REAL}(3), IN
      rshft :: VEC{REAL}(3), IN

   ENSURE(grid.dim==pt.dim1,  "grid and pt are incomptabile")
   ENSURE(pt.dim2==3,  "wrong dimension for pt array")
   ENSURE(DM.is_square,"DM is not square")
   ENSURE(DM.dim1==.n_bf,"DM is not square")

      bf   :: MAT{REAL}@
      bfDM :: MAT{REAL}@
      n_pt, s,fs,ls,ns :: INT
      sh :: SHELL1

    ! n_pt = pt.dim1
    ! bf.create(n_pt,.n_bf)
    ! do s = 1,.n_shell
    !    .SET:set_shell1_from(s,sh,fs,ls,ns)
    !    sh.position = sh.position + lshft
    !    sh.make_grid_s(bf(:,fs:ls),pt(:,1),pt(:,2),pt(:,3))
    ! end
    ! stdout.text("bf:")
    ! stdout.put(bf)
    ! bf.destroy

    ! stop

      ! Make the product of the basis function at the i-th grid point
      ! sumed with the density matrix i.e. 
      !  bfDM(i,n) = sum_s sum_{m=fs,ls}^n_bf bf(i,m) DM(m,n)
      n_pt = pt.dim1
      bfDM.create(n_pt,.n_bf) ! <=== BIG// bfDM :: n_pt x n_bf
      bfDM = ZERO
      do s = 1,.n_shell
         .SET:set_shell1_from(s,sh,fs,ls,ns)
         sh.position = sh.position + lshft
         bf.create(n_pt,ns)
         sh.make_grid_s(bf,pt(:,1),pt(:,2),pt(:,3))
         bfDM = bfDM + matmul(bf,DM(fs:ls,:)) 
            ! ( n_pt x (ls-fs+1) )*( (ls-fs+1)x n_bf )
            !  ls-fs+1 = ns
         bf.destroy
      end

      ! Product with matrix of basis fn values on grid
      ! i.e. grid(i) = sum_n^n_bf (sum_m^n_bf bf(i,m) DM(m,n)) bf(i,n)
      !              = sum_n^n_bf             bfDM(i,n)        bf(i,n)
      ! // i: grid point index // n: basis func. index
      do s = 1,.n_shell
         .SET:set_shell1_from(s,sh,fs,ls,ns)
         sh.position = sh.position + rshft
         bf.create(n_pt,ns)
         sh.make_grid_s(bf,pt(:,1),pt(:,2),pt(:,3)) !
         grid = grid + sum(bfDM(:,fs:ls)*bf(:,:),dim=2) ! grid :: n_pt
             ! (n_pt x (ls-fs+1) ) .* (n_pt x ns )
         bf.destroy
      end

      ! Clean
      bfDM.destroy

   end

! This is Kanghyun's version

   make_ED_grid_v1(grid,pt,DM,tol) ::: PURE
   ! Make "grid", the electron density values at the the points "pt",
   ! for density matrix "DM". Only those terms bigger than "tol" are
   ! considered.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN
      DM   :: MAT{REAL}, IN
      tol  :: REAL, IN

      grid = ZERO
      .GRID:add_ED_grid_v1(grid,pt,DM,tol)

   end

   add_ED_grid_v1(grid,pt,DM,tol) ::: PURE
   ! Add to "grid" the electron density values at the the points "pt",
   ! for density matrix "DM". Only those terms bigger than "tol" are
   ! considered.
      self :: IN
      grid :: VEC{REAL}, INOUT
      pt   :: MAT{REAL}, IN
      DM   :: MAT{REAL}, IN
      tol  :: REAL, IN

   ENSURE(grid.dim==pt.dim1, "inconsistent size, grid & pt")
   ENSURE(pt.dim2==3, "wrong dim2, pt")
   ENSURE(DM.is_square,   "wrong shape, DM")
   ENSURE(DM.dim1==.n_bf, "wrong size, DM")

      psi  :: VEC{EVEC{REAL}}@
      ind  :: VEC{EVEC{INT}}@
      mask :: VEC{BIN}@
      bf   :: MAT{REAL}@
      same,pi,pj :: VEC{INT}@
      n_pt, s,fs,ls,ns, i,j :: INT
      Dij :: REAL
      sh  :: SHELL1

      ! Sparse storage of significant b.f. values on grid:
      ! placed in "psi", corresponding indices in "ind".
      psi.create(.n_bf)
      ind.create(.n_bf)

      ! Loop over shells "s"
      mask.create(n_pt)
      do s = 1,.n_shell 
         .SET:set_shell1_from(s,sh,fs,ls,ns)
         bf.create(n_pt,ns)
         sh.make_grid_s(bf,pt(:,1),pt(:,2),pt(:,3))
         ! Basis fn. "i"
         do i = fs,ls
            mask = abs(bf(:,i-fs+1))>tol
            ! Store large values for each b.f.
            psi(i).element = pack(bf(:,i-fs+1)  ,mask)
            ind(i).element = pack([(j,j=1,n_pt)],mask)
         end
         bf.destroy
      end
      mask.destroy

      ! psi*psi product
      grid = ZERO 
      do i = 1,.n_bf 
      do j = 1,i
         ! DM is symmetric
         Dij = DM(i,j)
         if (j<i) Dij = Dij + Dij
         ! DM value large enough?
         if (abs(Dij)>tol) then
            VEC{INT}:common_indices_in(ind(i)[:],ind(j)[:],pi,pj,same)
            ! Common indices?
            if (same.dim>0) then
               grid(same) = grid(same) + Dij*psi(i)[pi]*psi(j)[pj]
            end
            pi.destroy
            pj.destroy
            same.destroy
         end
      end
      end

      ind.destroy
      psi.destroy

   end

!  Make the CRYSTAL23 density from density matrices

   make_CRYSTAL23_ED_grid(grid,pt)
   ! Make the "grid" for the supplied points "pt" using the CRYSTAL23
   ! density marices which have been read in.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   ENSURE(.crystal23.allocated , "no crystal23 info")
   ENSURE(.crystal23.density_mx.allocated , "no crystal23 density_mx info")

      cm :: MAT{REAL}(3,3)
      lt,rt    :: VEC{REAL}(3)
      lv,rv,dv :: VEC{INT}(3)
      l, r, d :: INT

      GAUSSIAN_DATA:set_CRYSTAL23_ordering(TRUE)

      ! Unit cell matrix
      cm = .crystal.unit_cell.direct_mx

      ! Values on grid
      grid = ZERO

      ! Left b.f. unit cell "l"
      ! This is translated back to the first unit cell
      do l = .crystal23.n_g,1,-1

         ! Left UC translational vector
         lv = .crystal23.g_latt(:,l) ! l-th IVDL
         lt = matmul(cm,lv)          ! This is l-th CVDL

         ! Diagonal contribution from DM^{l l}
         .GRID:add_ED_grid(grid, pt, .crystal23.density_mx(:,:,1), lshft=lt , rshft=lt )

         ! Right b.f. unit cell
         do r = .crystal23.n_g,1,-1 ! Check from here! off-diagonal
                                    ! density matrix contributions xxxxxxxxxx 

            ! Done diagonal case, above?
            if (r==l) cycle 

            ! Right UC translational vector
            rv = .crystal23.g_latt(:,r)
            rt = matmul(cm,rv)         ! This is g-th CVDL

            ! Difference between left & right cell vectors
            ! "d" depends on how DM^{l r}_{a b} is defined when it
            ! mutiplies the basis functions.
            dv = rv - lv 
            d  = .crystal23.g_latt.index_for_column(dv)

            ! Do we have DM^d ?
            if (d==0) cycle

            ! Add contribution from shifted central unit cell
            ! DYLAN: I think the P's are not read in correct?
            .GRID:add_ED_grid(grid,pt,.crystal23.density_mx(:,:,d),lshft=lt,rshft=rt)

         end

      end

   end

   make_CRYSTAL23_ED_grid_v1(grid,pt)
   ! Make the "grid" for the supplied points "pt" using the CRYSTAL23
   ! density marices which have been read in.
   ! This version from Kanghyun Chu, tested in  Matlab for NH3
   ! 7/12/23
      self :: IN
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   ENSURE(.crystal23.allocated , "no crystal23 info")
   ENSURE(.crystal23.density_mx.allocated , "no crystal23 density_mx info")

      psi  :: MAT{EVEC{REAL}}@
      ind  :: MAT{EVEC{INT}}@
      bf   :: MAT{REAL}@
      l_ind :: MAT{INT}@
      PSIPSI :: VEC{REAL}@
      common, posA, posB :: VEC{INT}@
      mask :: VEC{BIN}@
      cm :: MAT{REAL}(3,3)
      mt :: VEC{REAL}(3)
      mv,lv,rv,dv :: VEC{INT}(3)
      n_pt,n_g, s,fs,ls,ns :: INT
      n,l,r, m,i,j, l1,l2  :: INT
      tol :: REAL
      sh :: SHELL1

      ! Strange p basis function ordering
      GAUSSIAN_DATA:set_CRYSTAL23_ordering(TRUE)

      ! Array sizes
      n_g  = .crystal23.n_g
      n_pt = pt.dim1
      tol  = exp(-20.00)

      ! Unit cell matrix
      cm = .crystal.unit_cell.direct_mx

      ! DO this for silly reason



      ! <<Kang's memo>>
      ! The "psi" and "ind" objects should have 2+1 indices.
      ! Former "2" dimensions have fixed sized: 
      !            (# of basis) X (# of cells)
      ! Last   "1" dimension has varying size:
      !        (of # of grid points where Basis_Func(r) > tolerance) 
      ! Sparse storage of significant b.f. values on grid 
      ! in "psi" and corresponding indices in "ind".
      psi.create(n_g,.n_bf)
      ind.create(n_g,.n_bf)
      mask.create(n_pt)
      do m = 1,n_g

         ! Left UC translational vector
         mv = .crystal23.g_latt(:,m) ! m-th IVDL 
         mt = matmul(cm,mv)          ! This is m-th CVDL

         do s = 1,.n_shell ! s: for every shell
            .SET:set_shell1_from(s,sh,fs,ls,ns)
            sh.position = sh.position + mt ! either +mt or -mt
            bf.create(n_pt,ns)  ! bf:2D array: n_pt X ns
            sh.make_grid_s(bf,pt(:,1),pt(:,2),pt(:,3))
            do i = fs,ls
               mask = abs(bf(:,i-fs+1))>tol
               psi(m,i).element = pack(bf(:,i-fs+1)  ,mask)
               ind(m,i).element = pack([(j,j=1,n_pt)],mask)
            end
            bf.destroy
         end
      end

      mask.destroy

      ! Values on grid & psi*psi product
      grid = ZERO 
      PSIPSI.create(n_pt) 

      ! m-cell loop
      do m = 1,n_g

         mv = .crystal23.g_latt(:,m)
         mt = matmul(cm,mv)          ! This is m-th CVDL

         ! List of allowed pairs
         l_ind.create(n_g,2) 
         n = 0
         do l = 1,n_g
            lv = .crystal23.g_latt(:,l)
            dv = lv + mv
            do r = 1,n_g
               rv = .crystal23.g_latt(:,r)
               if (dv.same_as(rv)) then 
                  n = n + 1
                  l_ind(n,1) = l 
                  l_ind(n,2) = r 
               end
            end 
         end
         l_ind.shrink(n,2)

         do i = 1,.n_bf ! psi(i, cell1)
         do j = 1,.n_bf ! psi(j, cell2)
        
            if (abs(.crystal23.density_mx(i,j,m)) < tol)  cycle        
         
            PSIPSI = ZERO 
            ! dim: (# Grid pointd)
            ! psi(i,m) , i:1..n_ba; m:1..n_g
            ! ind(i,m)
        
            do l = 1,l_ind.dim1

               l1 = l_ind(l,1)
               l2 = l_ind(l,2)
               VEC{INT}:common_indices_in(ind(l1,i)[:],ind(l2,j)[:],posA,posB,common)

             ! stdout.show("m  = ",m)
             ! stdout.show("i  = ",i)
             ! stdout.show("j  = ",j)
             ! stdout.show("l1 = ",l1)
             ! stdout.show("l2 = ",l2)
             ! stdout.show("n  = ",common.dim)

               if (common.dim>0) then
             ! stdout.text("ind1:")
             ! stdout.put(ind(l1,i)[:],by_column=TRUE)
             ! stdout.text("ind2:")
             ! stdout.put(ind(l2,j)[:],by_column=TRUE)
             ! stdout.text("posA:")
             ! stdout.put(posA,by_column=TRUE)
             ! stdout.text("posB")
             ! stdout.put(posB,by_column=TRUE)
             ! stdout.text("common:")
             ! stdout.put(common,by_column=TRUE)
                  PSIPSI(common) = PSIPSI(common) &
                                 + psi(l1,i)[posA]*psi(l2,j)[posB]
               end

               posA.destroy
               posB.destroy
               common.destroy

            end
        
            ! Add up signinifcant parts
            grid = grid + .crystal23.density_mx(i,j,m) * PSIPSI
        
         end
         end

      end

      ! Clean
      PSIPSI.destroy

   end

!  =========================
!  Electron density routines
!  =========================

   make_ED_grid(density_grid,pt) ::: PURE
   ! Work out the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".NO_occ_nos" vector. 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      relativity,okind :: STR

      okind = .NOs.genre

      relativity = "none"
      if (.scfdata.allocated) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if

      select case (relativity)

    ! case ("douglas-kroll-hess","dkh")
    !    select case (okind)
    !       case ("r ");  .GRID:make_DKH_density_grid(density_grid,pt)
    !       case ("u ");  .GRID:make_DKH_density_grid(density_grid,pt,sgn)
    !       case ("gc");  .GRID:make_DKH_density_grid(density_grid,pt)
    !       case default; WARN("Unimplemented orbital kind! Sorry :(")
    !    end

    ! case ("iotc")
    !    select case (okind)
    !       case ("r ");  .GRID:make_IOTC_density_grid(density_grid,pt)
    !       case ("u ");  .GRID:make_IOTC_density_grid(density_grid,pt,sgn)
    !       case ("gc");  .GRID:make_IOTC_density_grid(density_grid,pt)
    !       case default; WARN("Unimplemented orbital kind! Sorry :(")
    !    end

      case ("none")
         select case (okind)
            case ("r "); .GRID:make_ED_grid_r(density_grid,pt)
            case ("u "); .GRID:make_ED_grid_u(density_grid,pt)
            case ("gc"); .GRID:make_ED_grid_gc(density_grid,pt)
          ! case default;   DIE("unimplemented")
         end

    ! case default; DIE("unimplemented")

      end

   end

   make_ED_grid_r(density_grid,pt) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      .GRID:make_ED_grid_r_v1(density_grid,pt)
    ! .GRID:make_ED_grid_r_v2(density_grid,pt)

   end

   make_ED_grid_r_v1(density_grid,pt) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation numbers")

      NO :: VEC{REAL}@
      occ :: REAL
      n_occ,n :: INT

      n_occ = .INQ:no_of_occupied_NOs
      NO.create(pt.dim1)

      density_grid = ZERO

      parallel do n = 1,n_occ
         .GRID:make_orbital_grid_r(NO,.NOs.r(:,n), pt)
         occ = .NO_occ_nos.r(n)
         density_grid = density_grid + occ*NO*NO
      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SUM(density_grid)
      end

      NO.destroy

   end

   make_ED_grid_r_v2(density_grid,pt) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.density_mx.is_allocated_with_genre("r "), "no restricted density_mx")

      .GRID:make_ED_grid_v1(density_grid,pt,.density_mx.r,TOL(9))

   end

   make_ED_grid_r(density_grid,pt,NO,occ) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from the
   ! natural orbitals "NO" and occupuation numbers "occ".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt  :: MAT{REAL}, IN
      NO  :: MAT{REAL}, IN
      occ :: VEC{REAL}, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      NOn :: VEC{REAL}@
      n :: INT

      NOn.create(pt.dim1)

      density_grid = ZERO
      do n = 1,NO.dim2
         if (occ(n)==ZERO) cycle
         .GRID:make_orbital_grid_r(NOn,NO(:,n),pt)
         density_grid = density_grid + occ(n)*NOn*NOn
      end

      NOn.destroy

   end

   make_ED_grid_u(density_grid,pt,sgn) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from unrestricted real
   ! natural orbitals. If present "sgn" is used to determine whether the total
   ! density or spin density is to be calculated: sgn=1 means sum the alpha and
   ! beta densities to form the total density, sgn=-1 means to subtract, forming
   ! the Sz spin density.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.NOs.is_allocated_with_genre("u "), "no unrestricted NO's")
   ENSURE(.NO_occ_nos.a.allocated, "no alpha occupation numbers")
   ENSURE(.NO_occ_nos.b.allocated, "no beta occupation numbers")

      NO :: VEC{REAL}@
      occ,fac :: REAL
      na,nb,n :: INT

      fac = ONE
      if (present(sgn)) fac = REALIFY(sgn)

      na = .INQ:no_of_occupied_NOs("alpha")
      nb = .INQ:no_of_occupied_NOs("beta")

      NO.create(pt.dim1)

      density_grid = ZERO

      do n = 1,na
         .GRID:make_orbital_grid_r(NO,.NOs.a(:,n),pt)
         occ = .NO_occ_nos.a(n)
         density_grid = density_grid + occ*NO*NO
      end

      do n = 1,nb
         .GRID:make_orbital_grid_r(NO,.NOs.b(:,n),pt)
         occ = .NO_occ_nos.b(n)
         density_grid = density_grid + fac*occ*NO*NO
      end

      ! Clean
      NO.destroy

   end

   make_ED_grid_ab(p_a,p_b,pt) ::: PURE
   ! Make the alpha and beta density grids, "p_a" and "p_b"
   ! respectively, from the unrestricted natural orbitals.
      self :: INOUT
      p_a,p_b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.is_allocated_with_genre("u "),"no natural orbitals")
   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")
   ENSURE(.NO_occ_nos.is_allocated_with_genre("u "),"no occupation numbers")

      NO :: MAT{REAL}@
      occ :: VEC{REAL}@

      NO  = .NOs.r ! backup pointers
      occ = .NO_occ_nos.r

      ! Alpha
      .NOs.r   = .NOs.a
      .NO_occ_nos.r = .NO_occ_nos.a
      .GRID:make_ED_grid(p_a,pt)

      ! Beta
      .NOs.r   = .NOs.b
      .NO_occ_nos.r = .NO_occ_nos.b
      .GRID:make_ED_grid(p_b,pt)

      .NOs.r   = NO ! restore backups
      .NO_occ_nos.r = occ

      occ.destroy
      NO.destroy

   end

   make_ED_grid_gc(density_grid,pt,sgn) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.NOs.is_allocated_with_genre("gc"), "no natural orbitals")
   ENSURE(.NO_occ_nos.is_allocated_with_genre("general"), "no occupation numbers")

      gd,gu :: VEC{CPX}@
      n_occ,n :: INT
      occ :: REAL
      fac :: REAL

      n_occ = .INQ:no_of_occupied_NOs
      if (present(sgn)) then
         fac = sgn*ONE
         ! WARN(" This is the collinear 2-comp/gchf spin density, using sz! ")
      else
         fac = ONE
      end

      gu.create(pt.dim1)
      gd.create(pt.dim1)

      density_grid = ZERO
      do n = 1,n_occ
         .GRID:make_orbital_grid_gc(gu,gd,.NOs.gc(:,n),pt)
         occ = .NO_occ_nos.g(n)
         density_grid = density_grid  +  occ * REALIFY(fac*conjg(gd)*gd + conjg(gu)*gu)
      end

      gd.destroy
      gu.destroy

   end

   make_ku_density_grid_u(density_grid,pt,KP) ::: PURE
   ! Make the "spin density_grid" for the supplied points "pt" from
   ! general complex natural orbitals.
   ! Kramers unrestricted algorithm
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      KP :: MAT{REAL}, IN

    ENSURE(pt.dim2==3,  "incorrect dimension for points array")
    ENSURE(.NOs.is_allocated_with_genre("u "), "no natural orbitals")
    ENSURE(.NO_occ_nos.a.allocated, "no alpha occupation numbers")
    ENSURE(.NO_occ_nos.b.allocated, "no beta occupation numbers")

      ga,gb,ggg :: VEC{REAL}@
      na,nb,i,j :: INT
      ona,onb :: REAL

      ! density_grid = ZERO
      ga.create(pt.dim1)
      gb.create(pt.dim1)
      ggg.create(pt.dim1)

      ggg = ZERO
      na = .INQ:no_of_occupied_NOs("alpha")
      nb = .INQ:no_of_occupied_NOs("beta")

      do i = 1,na
         ga = ZERO
         ona = .NO_occ_nos.a(i); ona=sqrt(ona)
         .GRID:make_orbital_grid_r(ga,.NOs.a(:,i),pt)
         do j = 1,nb
            gb = ZERO
            onb = .NO_occ_nos.b(j); onb=sqrt(onb)
            .GRID:make_orbital_grid_r(gb,.NOs.b(:,j),pt)
            ggg(:) = ggg(:) &
                   - ona * onb * ga * gb * KP(i,j)
         ! the K operator acts on beta hence
         ! the minus sign to get a positive number
         end
       ! stdout.put(i) ! orbital count
       ! stdout.flush
      end
      
      ! " This is the Kramers unrestricted uhf spin density! "
      ! a or b - should not matter hence the TWO
      density_grid(:) = density_grid(:) - ggg(:)*TWO 

      ga.destroy
      gb.destroy
      ggg.destroy

   end

   make_nc_density_grid_gc(density_grid,pt) ::: PURE
   ! Make the noncollinear spin density_grid for the supplied points "pt" from
   ! general complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.NOs.is_allocated_with_genre("gc"), "no natural orbitals")
   ENSURE(.NO_occ_nos.is_allocated_with_genre("general"), "no occupation numbers")

      gd,gu,ggg,gtemp :: VEC{CPX}@
      n_occ,n :: INT
      occ :: REAL

      n_occ = .INQ:no_of_occupied_NOs

      gu.create(pt.dim1)
      gd.create(pt.dim1)
      ggg.create(pt.dim1)
      gtemp.create(pt.dim1)

      density_grid = ZERO
      ggg = (ZERO,ZERO)
      gtemp = (ZERO,ZERO)
      do n = 1,n_occ
         occ= .NO_occ_nos.g(n)
         .GRID:make_orbital_grid_gc(gu,gd,.NOs.gc(:,n),pt)
         gtemp(:)= gtemp(:) + occ*conjg(gu(:))*gd(:)
         ggg(:) = ggg(:) &
                - occ*conjg(gd(:))*gd(:) + occ*conjg(gu(:))*gu(:)
      end
      ggg(:) = ggg(:)**2 + FOUR*gtemp(:)*conjg(gtemp(:))
      gtemp.destroy
      ! WARN(" Non-collinear 2-comp/gchf spin density, using the length of sigma! ")
      density_grid(:)= real(ggg(:))
      density_grid(:)= sqrt(density_grid(:))

      gtemp.destroy
      ggg.destroy
      gd.destroy
      gu.destroy

   end

   make_ku_density_grid_gc(density_grid,pt,KP) ::: PURE
   ! Make the "spin density_grid" for the supplied points "pt" from
   ! general complex natural orbitals. Kramers unrestricted algorithm
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      KP :: MAT{CPX}, IN

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.NOs.is_allocated_with_genre("gc"), "no natural orbitals")
   ENSURE(.NO_occ_nos.is_allocated_with_genre("general"), "no occupation numbers")

      gdi,gui,gdj,guj,ggg,gtemp :: VEC{CPX}@
      n_occ,i,j :: INT
      oni,onj :: REAL

      gui.create(pt.dim1)
      gdi.create(pt.dim1)
      guj.create(pt.dim1)
      gdj.create(pt.dim1)
      ggg.create(pt.dim1)
      gtemp.create(pt.dim1)

      ggg = (ZERO,ZERO)
      gtemp = (ZERO,ZERO)
      n_occ = .INQ:no_of_occupied_NOs

       do i=1,n_occ
          gui= (ZERO,ZERO)
          gdi= (ZERO,ZERO)
          oni= .NO_occ_nos.g(i); oni=sqrt(oni)
          .GRID:make_orbital_grid_gc(gui,gdi,.NOs.gc(:,i),pt)
          do j=1,n_occ
             guj= (ZERO,ZERO)
             gdj= (ZERO,ZERO)
             onj= .NO_occ_nos.g(j); onj=sqrt(onj)
             .GRID:make_orbital_grid_gc(guj,gdj,.NOs.gc(:,j),pt)
             
             gtemp(:) = (ZERO,ZERO)
             gtemp(:) = oni*onj*(conjg(guj(:))*conjg(gdi(:)) &
                      - conjg(gdj(:))*conjg(gui(:)))*conjg(KP(j,i))
              ggg(:)  = ggg(:) + gtemp(:)
          end
        ! stdout.put(i)
        ! stdout.flush
       end

      ! WARN(" This is the Kramers unrestricted 2-comp/gchf spin density! ")

      density_grid(:) = density_grid(:) - real(ggg(:))

      gdi.destroy
      gui.destroy
      gdj.destroy
      guj.destroy
      ggg.destroy
      gtemp.destroy

   end

!  ==================
!  Spin density grids
!  ==================

   make_SD_grid(density_grid,pt) ::: PURE
   ! Work out the electron spin "density_grid" on "pt" using the
   ! ".NOs" and the ".NO_occ_nos" vector. 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      relativity,okind :: STR

      okind = .NOs.genre

      relativity = "none"
      if (.scfdata.allocated) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if

      select case (relativity)

    ! case ("douglas-kroll-hess","dkh")
    !    select case (okind)
    !       case ("r ");  .GRID:make_DKH_density_grid(density_grid,pt)
    !       case ("u ");  .GRID:make_DKH_density_grid(density_grid,pt,sgn)
    !       case ("gc");  .GRID:make_DKH_density_grid(density_grid,pt)
    !       case default; WARN("Unimplemented orbital kind! Sorry :(")
    !    end

    ! case ("iotc")
    !    select case (okind)
    !       case ("r ");  .GRID:make_IOTC_density_grid(density_grid,pt)
    !       case ("u ");  .GRID:make_IOTC_density_grid(density_grid,pt,sgn)
    !       case ("gc");  .GRID:make_IOTC_density_grid(density_grid,pt)
    !       case default; WARN("Unimplemented orbital kind! Sorry :(")
    !    end

       case ("none")
          select case (okind)
             case ("u ");  .GRID:make_ED_grid_u(density_grid,pt,sgn=-1)
             case ("gc"); .GRID:make_ED_grid_gc(density_grid,pt,sgn=-1)
    !        case default;   DIE("unimplemented")
          end

    ! case default; DIE("unimplemented")

      end

   end

   make_nc_spin_density_grid(grid,pt)
   ! Work out the property density on ".plot_grid" using ".natural
   ! orbitals" and the ".NO_occ_nos" vector. A Gnuplot ascii
   ! file is generated.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.plot_grid.allocated, "no grid")

      .GRID:make_nc_density_grid_gc(grid,pt)
      .PUT:dump_plot_grid(grid,"nc_spin_density_grid")

   end

   make_ku_spin_density_grid_u(KP)
   ! Work out the property density on ".plot_grid" using ".natural
   ! orbitals" and the ".NO_occ_nos" vector. A Gnuplot ascii
   ! file is generated.
      self :: IN
      KP :: MAT{REAL}, OUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")

      pt :: MAT{REAL}@
      grid :: VEC{REAL}@
      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      if (genre=="r ") return

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .GRID:make_ED_grid_u(grid,pt)
      .GRID:make_ku_density_grid_u(grid,pt,KP)
      .PUT:dump_plot_grid(grid,"ku_spin_density_grid")

      pt.destroy
      grid.destroy
   end

   make_ku_spin_density_grid_gc(KP)
   ! Work out the property density on ".plot_grid" using ".natural
   ! orbitals" and the ".NO_occ_nos" vector. A Gnuplot ascii
   ! file is generated.
      self :: IN
      KP :: MAT{CPX}, OUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")

      pt :: MAT{REAL}@
      grid :: VEC{REAL}@
      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      if (genre=="r ") return

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .GRID:make_ED_grid_gc(grid,pt)
      .GRID:make_ku_density_grid_gc(grid,pt,KP)
      .PUT:dump_plot_grid(grid,"ku_spin_density_grid")

      pt.destroy
      grid.destroy

   end

! DKH densities

!   make_DKH_density_grid(density_grid,pt,sgn)
!   ! this is kevin. bastard.
!   ! here begins the PCE correction of density
!   ! welcome
!      self :: INOUT
!      density_grid :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      sgn :: INT, optional, IN
!
!      fac :: REAL
!      MO,MOa,MOb :: MAT{REAL}@
!      CMO :: MAT{CPX}@
!      D,Da,Db :: MAT{REAL}@
!      CD :: MAT{CPX}@
!      grid_a,grid_b :: VEC{REAL}*
!
!      select case (.scfdata.SCF_kind)
!
!         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
!
!            ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
!            ENSURE(.spin_multiplicity==1,"this is not a singlet state")
!
!            MO = .MOs.r(:,1:.n_a)
!            D  = .density_mx.r
!
!            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
!
!            grid_a.create(pt.dim1)
!            .GRID:density_DKH_r(grid_a,pt,D)
!            density_grid = grid_a
!            grid_a.destroy
!
!         case ("uhf","uks","xray_uhf","xray_uks", &
!               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
!
!            ENSURE(.MOs.is_allocated_with_genre("u "),"no MO's")
!
!            MOa = .MOs.a(:,1:.n_a)
!            MOb = .MOs.b(:,1:.n_b)
!            Da  = .density_mx.a
!            Db  = .density_mx.b
!
!            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
!            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
!
!            grid_a.create(pt.dim1)
!            grid_b.create(pt.dim1)
!            .GRID:density_DKH_r(grid_a,pt,Da)
!            .GRID:density_DKH_r(grid_b,pt,Db)
!
!            if (present(sgn)) then; fac = -ONE
!            else;                   fac = ONE
!            end
!
!            density_grid = grid_a
!            density_grid = density_grid + fac * grid_b
!
!            grid_a.destroy
!            grid_b.destroy
!
!         case ("gchf","xray_gchf")
!
!            ENSURE(.MOs.is_allocated_with_genre("gc"),"no MO's")
!
!            CD  = .density_mx.gc
!            CMO = .MOs.gc(:,1:.n_e)
!
!            CD.to_product_of(CMO,CMO,dagger_b=TRUE)
!
!            .GRID:density_DKH_gc(density_grid,pt,CD)
!
!         case default
!            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.SCF_kind))
!
!      end
!
!   end

!   density_DKH_r(density_grid,pt,D)
!   ! the density_grid will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      self :: INOUT
!      density_grid :: VEC{REAL} , OUT
!      pt :: MAT{REAL} , IN
!      D :: MAT{REAL} , IN
!
!      n_gcm,n_pt :: INT
!      n,i,j :: INT
!      g :: REAL
!      m_out :: MAT{INT}*
!      YU,GG,S,R,sZ,sPZP,PPZPP :: MAT{REAL}*
!      P2,Ap,Ep :: VEC{REAL}*
!
!      n_pt = pt.dim1
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!      R.destroy
!
!      YU.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!
!      .REL:make_DKH_mxs(YU,Ap,Ep,P2)
!
!      sZ.create(n_gcm,n_gcm)
!      sPZP.create(n_gcm,n_gcm)
!      .REL:make_DKH_mxs2(sZ,sPZP,YU)
!
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!         WARN(" The use_ppzpp seems to give larger value of density at")
!         WARN(" nucleus for very large exponents in the basis set E+08")
!         PPZPP.create(n_gcm,n_gcm)
!         .REL:make_DKH_mxs4(PPZPP,YU)
!      end if
!
!      GG.create(.n_bf,.n_bf)
!      density_grid=ZERO
!      parallel do n = 1,n_pt
!
!         ! here it comes babes point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to it's non-relativistic counter part really not
!         ! effective :(
!         .GRID:make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,sZ,sPZP,PPZPP)
!
!         g = ZERO
!
!         do i = 1,.n_bf
!         do j = 1,.n_bf
!            g = g + D(i,j)*GG(i,j)
!         end
!         end
!
!         density_grid(n) = g
!
!      end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(density_grid)
!      end
!
!      S.destroy
!      sZ.destroy
!      sPZP.destroy
!      GG.destroy
!      YU.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!      m_out.destroy
!
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!         PPZPP.destroy
!      end if
!
!   end

!   density_DKH_gc(density_grid,pt,D)
!   ! the density_grid will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      self :: INOUT
!      density_grid :: VEC{REAL} , OUT
!      pt :: MAT{REAL} , IN
!      D :: MAT{CPX} , IN
!
!      n_gcm,n_pt, n,i,j :: INT
!      g :: REAL
!      II :: CPX
!      m_out :: MAT{INT}*
!      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
!      Z2,PZP2 :: MAT{CPX}*
!      SOx,SOy,SOz :: MAT{REAL}*
!      GG22 :: MAT{CPX}*
!      P2,Ap,Ep :: VEC{REAL}*
!
!      n_pt = pt.dim1
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      if (abs(.n_prim-n_gcm)> 0 AND abs(.n_prim-.n_bf) > 0) then
!         DIE(" contracted gaussians do not work for DKH at gchf level!")
!      end if
!
!      R.create(.n_prim,.n_prim)
!      S.create(n_gcm,n_gcm)
!      .REL:make_primitive_overlap_mx(S)
!      R.destroy
!
!      YU.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!      .GRID:make_DKH_mxs_2(YU,Ap,Ep,P2)
!
!      Z.create(n_gcm,n_gcm)
!      PZP.create(n_gcm,n_gcm)
!      SOx.create(n_gcm,n_gcm)
!      SOy.create(n_gcm,n_gcm)
!      SOz.create(n_gcm,n_gcm)
!      ! actually the output matrices are the sX matrices (see DKH for the
!      ! use of the s index)  -- ??? dylan
!      .GRID:make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)
!
!        Z2.create(2*n_gcm,2*n_gcm)
!      PZP2.create(2*n_gcm,2*n_gcm)
!
!      Z2 = (ZERO,ZERO)
!      Z2.a_alpha_plus(Z)
!      Z2.b_beta_plus(Z)
!
!      II   = (ZERO,ONE)
!      PZP2 = (ZERO,ZERO)
!      PZP2.a_alpha_plus(PZP)
!      PZP2.b_beta_plus(PZP)
!      PZP2.b_alpha_plus(SOx,II)
!      PZP2.b_alpha_plus(SOy,-ONE)
!      PZP2.a_alpha_plus(SOz,II)
!      PZP2.b_beta_plus(SOz,-II)
!      PZP2.make_hermitian
!
!      Z.destroy
!      PZP.destroy
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!
!      GG22.create(2*.n_bf,2*.n_bf)
!
!      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
!         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
!         PPZPP.create(n_gcm,n_gcm)
!         .REL:make_DKH_mxs4(PPZPP,YU)
!      end if
!
!      density_grid=ZERO
!      parallel do n = 1,n_pt
!
!         ! here it comes babes point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to it's non-relativistic counter part really not
!         ! effective :(
!         .GRID:make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)
!
!         g = ZERO
!
!         do i=1,2*.n_bf
!         do j=1,2*.n_bf
!            g = g + REALIFY(D(j,i)*GG22(i,j))
!         end
!         end
!
!         density_grid(n) = g
!
!      end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(density_grid)
!      end
!
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!         PPZPP.destroy
!      end if
!
!      S.destroy
!      Z2.destroy
!      PZP2.destroy
!      GG22.destroy
!      YU.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!      m_out.destroy
!
!   end

! IOTC densities

!   make_IOTC_density_grid(density_grid,pt,sgn)
!   ! this is kevin
!   ! here begins the PCE correction of density
!   ! welcome
!      self :: INOUT
!      density_grid :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      sgn :: INT, optional, IN
!
!      fac :: REAL
!      MO,MOa,MOb :: MAT{REAL}@
!      CMO :: MAT{CPX}@
!      D,Da,Db :: MAT{REAL}@
!      CD :: MAT{CPX}@
!      grid_a,grid_b :: VEC{REAL}*
!
!      select case (.scfdata.SCF_kind)
!
!         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
!
!            ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
!            ENSURE(.spin_multiplicity==1,"this is not a singlet state")
!
!            MO = .MOs.r(:,1:.n_a)
!            D  = .density_mx.r
!
!            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
!
!            grid_a.create(pt.dim1)
!            .GRID:density_IOTC_r(grid_a,pt,D)
!
!            density_grid = grid_a
!
!            grid_a.destroy
!
!         case ("uhf","uks","xray_uhf","xray_uks", &
!               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
!
!            ENSURE(.MOs.is_allocated_with_genre("u "),"no MO's")
!
!            MOa = .MOs.a(:,1:.n_a)
!            MOb = .MOs.b(:,1:.n_b)
!            Da  = .density_mx.a
!            Db  = .density_mx.b
!
!            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
!            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
!
!            grid_a.create(pt.dim1)
!            grid_b.create(pt.dim1)
!            .GRID:density_IOTC_r(grid_a,pt,Da)
!            .GRID:density_IOTC_r(grid_b,pt,Db)
!
!            if (present(sgn)) then; fac = -ONE
!            else;                   fac = ONE
!            end
!
!            density_grid = grid_a
!            density_grid = density_grid + fac * grid_b
!            grid_a.destroy
!            grid_b.destroy
!
!         case ("gchf","xray_gchf")
!
!            ENSURE(.MOs.is_allocated_with_genre("gc"),"no MO's")
!
!            CD  = .density_mx.gc
!            CMO = .MOs.gc(:,1:.n_e)
!
!            CD.to_product_of(CMO,CMO,dagger_b=TRUE)
!            .GRID:density_IOTC_gc(density_grid,pt,CD)
!
!         case default
!            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.SCF_kind))
!
!      end
!
!   end

!   density_IOTC_r(density_grid,pt,D,ax)
!   ! the density_grid will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!      self :: INOUT
!      density_grid :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      D :: MAT{REAL}, IN
!      ax :: INT , optional
!
!      n_gcm,n_pt,nx :: INT
!      n,i,j,k :: INT
!      g,c,alpha,alpha2 :: REAL
!      m_out :: MAT{INT}*
!      R,Y,U,A,T,O :: MAT{REAL}*
!      SOx,SOy,SOz,Yr :: MAT{REAL}*
!      YU,GG,S,Z,PZP :: MAT{REAL}*
!      P2,Ap,E,p,ep,bp :: VEC{REAL}*
!
!      n_pt = pt.dim1
!      nx=0
!      if(present(ax)) nx=ax
!
!
!      !!! analysis of the primitive basis set via the overap matrix
!      !!! trying to lower the problem to an general contracted basis set
!      !!!  OVERLAP MATRIX !!!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
!      ! put the overlap matrix into the n_gcm non-redundant space
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!
!      Y.create(n_gcm,n_gcm)
!      Y.to_inverse_sqrt_of(S)
!
!      !!!  KINETIC ENERGY MATRIX !!!
!      .REL:make_primitive_kinetic_mx(R)
!      T.create(n_gcm,n_gcm)
!      ! put the kinetic energy matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,T,m_out)
!
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(Y,T)
!      T.to_product_of(A,Y)
!      ! T=YTY  kinetic energy in an orthogonal basis
!      U.create(n_gcm,n_gcm)
!      P2.create(n_gcm)
!      T.solve_symmetric_eigenproblem(P2,U)
!      P2= TWO * P2
!      YU.create(n_gcm,n_gcm)
!      YU.to_product_of(Y,U)
!      T.destroy
!      Y.destroy
!      U.destroy
!
!      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
!      .REL:make_primitive_nuclear_mx(R)
!      Z.create(n_gcm,n_gcm)
!      ! put the potential energy matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,Z,m_out)
!
!      A.to_product_of(YU,Z,transpose_a=TRUE)
!      Z.to_product_of(A,YU)
!
! !!!  PZP MATRIX  !!!
!      SOx.create(.n_prim,.n_prim)
!      SOy.create(.n_prim,.n_prim)
!      SOz.create(.n_prim,.n_prim)
!      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
!      SOx.destroy
!      SOy.destroy
!      SOz.destroy
!
!      PZP.create(n_gcm,n_gcm)
!      ! put the PZP matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,PZP,m_out)
!
!      A.to_product_of(YU,PZP,transpose_a=TRUE)
!      PZP.to_product_of(A,YU)
!      R.destroy
!
!      !!! A-O LETS GO !!!
!      c      = SPEED_OF_LIGHT_AU
!      alpha  = ONE/c
!      alpha2 = alpha*alpha
!
!      E.create(n_gcm)
!      p.create(n_gcm)
!      ep.create(n_gcm)
!      Ap.create(n_gcm)
!      bp.create(n_gcm)
!
!      do i = 1,n_gcm
!         E(i)  = c * sqrt(P2(i) + c * c)
!         p(i)  = sqrt(P2(i))
!         ep(i) = sqrt(ONE+P2(i)*alpha2)
!         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )
!         bp(i) = ONE/(ep(i)+ONE)
!      end
!
!      P2.destroy
!
!      do i=1,n_gcm
!      do j=1,n_gcm
!         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
!         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
!      end
!      end
!
!      ! lets find the transforation matrix
!      Yr.create(n_gcm,n_gcm)
!
!      .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
!
!      ! lets make ready the normalzation matrix
!      O.create(n_gcm,n_gcm)
!      O = ZERO
!      do i = 1,n_gcm
!         O(i,i) = ONE
!         do j=1,n_gcm
!         do k=1,n_gcm
!            O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
!         end do
!         end do
!      end do
!
!      A.to_inverse_sqrt_of(O)
!      O = A
!
!      Z.destroy
!      PZP.destroy
!      A.destroy
!
!      GG.create(.n_bf,.n_bf)
!
!      density_grid=ZERO
!      parallel do n = 1,n_pt
!
!         ! here it comes babes point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to it's non-relativistic counter part really not
!         ! effective :(
!       if (nx==0) then
!         .GRID:make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
!       else if (nx==1) then
!         .GRID:make_LAPLACIAN_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
!       else
!         DIE("Currently, I accept only  nx={0,1}.")
!       end if
!
!        g=ZERO
!
!        do i=1,.n_bf
!          do j=1,.n_bf
!            g = g + D(i,j)*GG(i,j)
!          end
!        end
!
!        density_grid(n)= g
!       end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(density_grid)
!      end
!
!     S.destroy
!     O.destroy
!     GG.destroy
!     YU.destroy
!     Yr.destroy
!     Ap.destroy
!     E.destroy
!     p.destroy
!     bp.destroy
!     ep.destroy
!     m_out.destroy
!
!   end

!   density_IOTC_gc(density_grid,pt,D,ax)
!   ! the density_grid will be filled with the values of density
!   ! given by the coordinates in the pt matrix
!    self :: INOUT
!    density_grid :: VEC{REAL} , OUT
!    pt :: MAT{REAL} , IN
!    D :: MAT{CPX} , IN
!    ax :: INT, optional
!
!    n_gcm,n_pt,nx :: INT
!    n,i,j :: INT
!    g,fac,c,alpha,alpha2,eps :: REAL
!    gc,II :: CPX
!    m_out,mmm :: MAT{INT}*
!    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
!    GG22 :: MAT{CPX}*
!    SOx,SOy,SOz :: MAT{REAL}*
!    A2,PAP,O,Ox,Yr :: MAT{CPX}*
!    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*
!
!    n_pt = pt.dim1
!    nx=0
!    if(present(ax)) nx=ax
!
!     !test
!     !!! n_gcm = .n_prim = .n_bf !!!
!     mmm.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(mmm,n_gcm)
!     mmm.destroy
!     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
!       DIE(" contracted gaussians do not work for IOTC at gchf level!")
!     end if
!
!! this is actually not needed but I am also using n_gcm
!     m_out.create(.n_prim,.n_prim)
!     .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
!     R.create(.n_prim,.n_prim)
!     S.create(n_gcm,n_gcm)
!     Y.create(n_gcm,n_gcm)
!     !!!  OVERLAP MATRIX + Y MX !!!
!     .REL:make_primitive_overlap_mx(S)
!     Y.to_inverse_sqrt_of(S)
!   !  .make_S_Y(S,Y)  !  ???
!
!!!!  KINETIC ENERGY MATRIX -> U & P2!!!
!     T.create(n_gcm,n_gcm)
!     T=ZERO
!     .REL:make_primitive_kinetic_mx(T)
!     R=ZERO
!     R.to_product_of(Y,T)
!     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
!     P2.create(n_gcm)
!     U.create(n_gcm,n_gcm)
!     P2=ZERO;U=ZERO
!     T.solve_symmetric_eigenproblem(P2,U)
!     ! the momentum squared instead of kinetic energy
!     P2= TWO * P2
!
!     YU.create(n_gcm,n_gcm)
!     YU.to_product_of(Y,U)
!     Y.destroy
!     U.destroy
!     T.destroy
!
!!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
!     R=ZERO
!     Z.create(n_gcm,n_gcm)
!    .REL:make_primitive_nuclear_mx(Z)
!! put the potential energy matrix into the YU space
!     R.to_product_of(YU,Z,transpose_a=TRUE)
!     Z.to_product_of(R,YU)
!     R=ZERO
!
!!!!  PZP MATRIX  !!!
!     PZP.create(n_gcm,n_gcm)
!     SOx.create(.n_prim,.n_prim)
!     SOy.create(.n_prim,.n_prim)
!     SOz.create(.n_prim,.n_prim)
!         .REL:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
!
!     R.to_product_of(YU,PZP,transpose_a=TRUE)
!     PZP.to_product_of(R,YU)
!     R=ZERO
!     R.to_product_of(YU,SOx,transpose_a=TRUE)
!     SOx.to_product_of(R,YU)
!     R=ZERO
!     R.to_product_of(YU,SOy,transpose_a=TRUE)
!     SOy.to_product_of(R,YU)
!     R=ZERO
!     R.to_product_of(YU,SOz,transpose_a=TRUE)
!     SOz.to_product_of(R,YU)
!     R=ZERO
!
!!!! A-O LETS GO !!!
!     c = SPEED_OF_LIGHT_AU
!     alpha = ONE/c
!     alpha2= alpha*alpha
!
!     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
!     Ap.create(n_gcm)
!
!     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO
!
!     do i = 1,n_gcm
!
!       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
!       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
!       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2)
!       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )
!       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
!     end do
!
!     P2.destroy
!
!     do i = 1,n_gcm
!       do j=1,n_gcm
!
!        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
!        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
!        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
!        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
!        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
!
!       end
!     end
!
!   A2.create(2*n_gcm,2*n_gcm)
!   A2=(ZERO,ZERO)
!     A2.a_alpha_plus(Z)
!     A2.b_beta_plus(Z)
!!   A.make_hermitian
!   PAP.create(2*n_gcm,2*n_gcm)
!   PAP=(ZERO,ZERO)
!     PAP.a_alpha_plus(PZP)
!     PAP.b_beta_plus(PZP)
!     II = (ZERO,ONE)
!     fac= ONE
!      PAP.b_alpha_plus(SOx,fac*II)
!      PAP.b_alpha_plus(SOy,-fac)
!      PAP.a_alpha_plus(SOz,fac*II)
!      PAP.b_beta_plus(SOz,-fac*II)
!      PAP.make_hermitian
!
!     Y0.create(n_gcm,n_gcm)
!     Y0=ZERO
!     .REL:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
!
!     Z.destroy
!     PZP.destroy
!     SOx.destroy
!     SOy.destroy
!     SOz.destroy
!     R.destroy
!
!! lets find the transforation matrix
!     Yr.create(2*n_gcm,2*n_gcm)
!     Yr=(ZERO,ZERO)
!     Yr.a_alpha_plus(Y0)
!     Yr.b_beta_plus(Y0)
!     Y0.destroy
!
!!    .find_da_Y_iterative(Yr,PZP,SOx,SOy,SOz,Z,p,bp,ep)
!    .REL:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
!
!    PAP.destroy
!    A2.destroy
!
!     O.create(2*n_gcm,2*n_gcm)
!     Ox.create(2*n_gcm,2*n_gcm)
!     O=(ZERO,ZERO)
!!     A=(ZERO,ZERO)
!     Ox=(ZERO,ZERO)
!     do i=1,2*n_gcm
!       Ox(i,i)=ONE
!     end do
!     O.to_product_of(Yr,Yr,dagger_a=TRUE)
!     Ox=Ox+O
!     O=(ZERO,ZERO)
!    UN.create(2*n_gcm)
!    UN=ZERO
!
!    ! make ready the preconditioning
!    do i=1,2*n_gcm
!      UN(i)=ONE/sqrt(real(Ox(i,i)))
!    end
!
!    do i=1,2*n_gcm
!      do j=1,2*n_gcm
!        Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
!      end
!    end
!     eps=TOL(15)
!     O.to_power_series_inv_sqrt_of(Ox,eps)
!    do i=1,2*n_gcm
!      do j=1,2*n_gcm
!        O(i,j)=O(i,j)*UN(j)
!      end
!    end
!    UN.destroy
!    Ox.destroy
!
!    GG22.create(2*n_gcm,2*n_gcm)
!    density_grid=ZERO
!    parallel do n = 1,n_pt
!       GG22=(ZERO,ZERO)
!! here it comes babes
!! point for point the density will be on and on calculated
!! I am sincerely sorry, but the code is comparing to it's non-relativistic
!! counter part really not effective :(
!!     .GRID:make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
!       if (nx==0) then
!         .GRID:make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
!       else if (nx==1) then
!         .GRID:make_LAPLACIAN_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,O)
!       else
!         DIE("Currently, I accept only  nx={0,1}.")
!       end if
!
!       gc=(ZERO,ZERO)
!
!       do i=1,2*.n_bf
!         do j=1,2*.n_bf
!             gc = gc + D(j,i)*GG22(i,j)
!         end
!       end
!       g=ZERO
!       g= real(gc)
!       density_grid(n)= g
!    end
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(density_grid)
!      end
!
!    S.destroy
!    O.destroy
!    Yr.destroy
!    GG22.destroy
!    YU.destroy
!    Ap.destroy
!    E.destroy
!    bp.destroy
!    ep.destroy
!    p.destroy
!    m_out.destroy
!   end

!  ===================================
!  Efficient electron density routines
!  ===================================

   make_rho_grid(N0,pt,D) ::: leaky, PURE
   ! Make density grid "N0" on points "pt" using density matrix "D"
   ! skipping as many points as possible. This routine will probably
   ! have to be batched over *spatially localised* points to reduce
   ! memory requirements.
      self :: INOUT
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT{REAL}, IN

   ENSURE(N0.dim==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.becke_grid.allocated,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      bf_lgval :: VEC{EVEC{INT}}@
      bf_grid0 :: VEC{EMAT{REAL}}@
      ra :: VEC{REAL}(3)
      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gb0 :: VEC{REAL}@
      overlapping_atom, lga,lgb, sp :: VEC{INT}@
      DD :: MAT{REAL}@
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n  :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! Basis function cutoff
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)

         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt)

         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom = .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell for index "sa"
               bs  = .basis_shell_for_shell(sa)
               sha = .basis_shell1pair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grid and lga values
               bf_grid0(sa).element.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(bf_grid0(sa).element,n_pt,xa,ya,za,a2,lga)

               ! Save the values
               bf_lgval(sa).element = lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Get the "sb" basis function grid
                  lgb = bf_lgval(sb).element

                  ! How many points in common?
                  n_keep = count(lga+lgb>=cutoff)
                  if (n_keep==0) cycle

                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=lga+lgb>=cutoff)

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sb)[:,1]
                     Dab = fac*DD(1,1)
                     do p = 1,n_keep
                        n = sp(p)
                        ga = ga0(n)
                        gb = gb0(n)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              n = sp(p)
                              ga = ga0(n)
                              gb = gb0(n)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up

                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

   make_derivative_rho_grid(N0,pt,D) ::: leaky, PURE
   ! Make density grids "N0" on points "pt" using density matrices "D"
   ! skipping as points as possible. This routine will probably have
   ! to be batched over *spatially localised* points to reduce memory
   ! requirements.
      self :: IN
      N0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT3{REAL}, IN

   ENSURE(N0.dim1==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(N0.dim2== D.dim3,"N0 and D: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.becke_grid.allocated,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      bf_lgval :: VEC{EVEC{INT}}@
      bf_grid0 :: VEC{EMAT{REAL}}@
      ra :: VEC{REAL}(3)
      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gb0 :: VEC{REAL}@
      overlapping_atom, lga,lgb, sp :: VEC{INT}@
      DD :: MAT3{REAL}@
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n, q,n_dens :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! No of densities
      n_dens = D.dim3

      ! Basis function cutoff
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)

         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt)

         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom = .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell for index "sa"
               bs  = .basis_shell_for_shell(sa)
               sha = .basis_shell1pair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grid and lga values
               bf_grid0(sa).element.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(bf_grid0(sa).element,n_pt,xa,ya,za,a2,lga)

               ! Save the values
               bf_lgval(sa).element = lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Get the "sb" basis function grid
                  lgb = bf_lgval(sb).element

                  ! How many points in common?
                  n_keep = count((lga+lgb)>=cutoff)
                  if (n_keep==0) cycle

                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=(lga+lgb)>=cutoff)

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb,:)

                  if (na*nb==1) then

                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sa)[:,1]
                     do q = 1,n_dens
                        Dab = fac*DD(1,1,q)
                        do p = 1,n_keep
                           n = sp(p)
                           ga = ga0(n)
                           gb = gb0(n)
                           val = ga*gb*Dab
                           N0(n,q) = N0(n,q) + val
                        end
                     end

                  else

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           do q = 1,n_dens
                              Dab = fac*DD(a,b,q)
                              do p = 1,n_keep
                                 n = sp(p)
                                 ga = ga0(n)
                                 gb = gb0(n)
                                 val = ga*gb*Dab
                                 N0(n,q) = N0(n,q) + val
                              end
                           end
                        end
                     end

                     ! Clean up

                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

!  ======================
!  Efficient bond ED grid
!  ======================

   make_bond_ED_grid(g,pt) ::: PURE
   ! Work out the bond electron density grid "g" for points "pt".
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      okind :: STR

      okind = .NOs.genre

      select case (okind)
      case ("r "); .GRID:make_bond_ED_grid_r(g,pt)
    ! case default;        DIE("unimplemented")
      end

   end

   make_bond_ED_grid_r(g,pt) ::: PURE
   ! Make the bond electron density grid "g" for points "pt" from the
   ! restricted real density matrix.
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.density_mx.is_allocated_with_genre("r "), "no restricted density matrix")

      .GRID:make_bond_ED_grid(g,pt,.density_mx.r)

   end

   make_bond_ED_grid(N0,pt,D) ::: leaky, PURE
   ! Make the bond electron density grid "N0" for points "pt"
   ! skipping as many points as possible.
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT{REAL}, IN

   ENSURE(N0.dim==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.becke_grid.allocated,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      bf_lgval :: VEC{EVEC{INT}}@
      bf_grid0 :: VEC{EMAT{REAL}}@
      ra,rb,pc,pa,pb :: VEC{REAL}(3)
      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gb0 :: VEC{REAL}@
      overlapping_atom, lga,lgb, sp :: VEC{INT}@
      DD :: MAT{REAL}@
      sha :: SHELL1
      sh  :: SHELL2
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n  :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT
      sab :: INT

      ! Basis function cutoff
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)

         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt)

         ! Atom a position
         ra = .atom(atom_a).position

         ! Overlapping atoms
         overlapping_atom = .overlapping_atoms_for_atom(atom_a).element

         ! Loop overlapping atom_b
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)

            ! Skip if atoms are equal
            if (atom_b>=atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Atom a position
            rb = .atom(atom_b).position

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1

               ! Set shell for index "sa"
               bs  = .basis_shell_for_shell(sa)
               sha = .basis_shell1pair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grid and lga values
               bf_grid0(sa).element.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(bf_grid0(sa).element,n_pt,xa,ya,za,a2,lga)

               ! Save the values
               bf_lgval(sa).element = lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Get shell-pair
                  .SET:set_shell2_from(sab,sh)

                  ! TEST: Pair-center distance
                  pc = sh.av_pair_center
                  pa = pc - ra
                  pb = pc - rb
                  pc = pc - HALF*(ra+rb)
                  if (pa.norm<pc.norm) cycle
                  if (pb.norm<pc.norm) cycle

                  ! Get the "sb" basis function grid
                  lgb = bf_lgval(sb).element

                  ! How many points in common?
                  n_keep = count(lga+lgb>=cutoff)
                  if (n_keep==0) cycle

                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=lga+lgb>=cutoff)

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sb)[:,1]
                     Dab = fac*DD(1,1)
                     do p = 1,n_keep
                        n = sp(p)
                        ga = ga0(n)
                        gb = gb0(n)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              n = sp(p)
                              ga = ga0(n)
                              gb = gb0(n)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                  end ! if ss or not ss

               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

!  ===============
!  Hirshfeld grids
!  ===============

   make_Hirshfeld_rho_grid(N0,pt,wt,c,D) ::: leaky, PURE
   ! Make the Becke- and Hirshfeld-weighted electron density "N0" on
   ! Becke grid ("pt","wt") for atom "c" given AO density matrix "D". 
      self :: INOUT
      N0 :: VEC{REAL}@, OUT
      pt :: MAT{REAL}@, OUT
      wt :: VEC{REAL}@, OUT
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      xa,ya,za,a2  :: VEC{REAL}@
      ga0,gb0, ra  :: VEC{REAL}@
      near_atom    :: VEC{INT}@
      pi,pj,pn     :: VEC{INT}@
      skipa0,skipa :: VEC{BIN}@
      skipab,skipb :: VEC{BIN}@
      gridc0, DD   :: MAT{REAL}@
      bf_skip      :: VEC{EVEC{BIN}}@
      bf_grid0     :: VEC{EMAT{REAL}}@
      ca,oa,fsa,lsa   :: INT
      cb,ob,fsb,lsb   :: INT
      sa,fa,la,na,fba :: INT
      sb,fb,lb,nb, ba :: INT
      a,b,i,j,p,n     :: INT
      n_pt, n_keep    :: INT
      val,ga,gb :: REAL
      Dab, fac  :: REAL
      cutoff    :: REAL
      sha :: SHELL1

      ! Get the Becke grid for atom "c"
      .becke_grid.make_grid(pt,wt,gridc0,c)
      n_pt = pt.dim1

      ! Overlapping atoms
      near_atom = .overlapping_atoms_for_atom(c).element

      ! Make stockholder weight function "Wc" for atom "c"
      ! If using interpolatators, then overlapping_atoms
      ! are not needed ... otherwise nothing is skipped
      .GRID:apply_stockholder_atom_weight(wt,c,pt)

      ! Prune the grid with new "wt", get saved bf grid gridc0,
      ! and new no of points, n_pt -- leaky
      .becke_grid.prune_grid(pt,wt,gridc0)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO
      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,near_atom.dim

         oa  = near_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set shell "sa"
            ba  = .basis_shell_for_shell(sa)
            sha = .basis_shell1pair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element.create(skipa.dim)
            bf_skip(sa).element = skipa

            ! Make/copy the "sa" basis function grid
            ! This must be copied since skipa could be TRUE
            bf_grid0(sa).element.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     bf_grid0(sa)[i,a] = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(bf_grid0(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
            end

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = near_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.deallocated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb = bf_skip(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  ! s-s gaussian case
                  if (na*nb==1) then
                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sb)[:,1]
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end
                  else
                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)
                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end
                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end
                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy
                  end

               end ! -- loops sa,sb
            end
         end       ! -- loops ca,cb
      end

      ! Weight the density
      N0 = N0*wt

      ! Clean up
      bf_grid0.destroy
      bf_skip.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

!  ===================
!  Becke density grids
!  ===================

   set_up_becke_grid ::: leaky
   ! Set up the Becke grids and overlapping atoms
      self :: INOUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")

      if (.becke_grid.deallocated) .becke_grid.create

      ! ALWAYS Set up integration grid
      ! (in case of new positions) (leaky)
      .becke_grid.set_atom_info(.atom) ! NOT PURE
      .becke_grid.set_grid_data

      ! ALWAYS make the overlapping atom lists
      .SET:set_overlapping_atoms

   end

   make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,D) ::: leaky, PURE
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Also return the "bf_skip" arrays
   ! and the "bf_grid0" array used for evaluating the rho (or other
   ! density functionals) on the grid.
      self :: INOUT
      N0 :: VEC{REAL}@, OUT
      pt :: MAT{REAL}@, OUT
      wt :: VEC{REAL}@, OUT
      bf_skip :: VEC{EVEC{BIN}}@, OUT
      bf_grid0 :: VEC{EMAT{REAL}}@, OUT
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gb0 :: VEC{REAL}@
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab, skipa,skipb :: VEC{BIN}@
      gridc0 :: MAT{REAL}@
      DD     :: MAT{REAL}@
      sha :: SHELL1
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom = .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set shell "sa"
            ba  = .basis_shell_for_shell(sa)
            sha = .basis_shell1pair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element.create(skipa.dim)
            bf_skip(sa).element = skipa

            ! Make/copy the "sa" basis function grid
            ! This must be copied since skipa could be TRUE
            bf_grid0(sa).element.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     bf_grid0(sa)[i,a] = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid( &
                  bf_grid0(sa).element, &
                  n_keep,xa,ya,za,a2,skipa,n_pt)
            end

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.deallocated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb = bf_skip(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sb)[:,1]
                     Dab = fac*DD(1,1)

                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

   make_rho_becke_atom_grid(N0,Nx,Ny,Nz,pt,wt,bf_skip,bf_gr0,bf_grx,bf_gry,bf_grz,c,D) ::: leaky, PURE
   ! Make the density "N0" and its derivatives "Nx", "Ny", "Nz", on
   ! the Becke grid ("pt","wt") for atom "c" given AO density matrix
   ! "D". Also return the "bf_skip" array, and the basis function and
   ! basis function derivative arrays "bf_gr0", "bf_grx", "bf_gry", 
   ! "bf_grz" used for evaluating the density functionals on the grid.
      self :: INOUT
      N0,Nx,Ny,Nz :: VEC{REAL}@, OUT
      pt :: MAT{REAL}@, OUT
      wt :: VEC{REAL}@, OUT
      bf_skip :: VEC{EVEC{BIN}}@, OUT
      bf_gr0 :: VEC{EMAT{REAL}}@, OUT
      bf_grx,bf_gry,bf_grz :: VEC{EMAT{REAL}}@, OUT
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gax,gay,gaz :: VEC{REAL}@
      gb0,gbx,gby,gbz :: VEC{REAL}@
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab, skipa,skipb :: VEC{BIN}@
      DD :: MAT{REAL}@
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}@
      sha :: SHELL1
      cutoff, Dab, fac, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom = .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt); N0 = ZERO
      Nx.create(n_pt); Nx = ZERO
      Ny.create(n_pt); Ny = ZERO
      Nz.create(n_pt); Nz = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_gr0.create(.n_shell)
      bf_grx.create(.n_shell)
      bf_gry.create(.n_shell)
      bf_grz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set shell "sa"
            ba  = .basis_shell_for_shell(sa)
            sha = .basis_shell1pair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element.create(skipa.dim)
            bf_skip(sa).element = skipa

            ! Make/copy the "sa" basis function grid
            ! This must be copied since skipa could be TRUE
            bf_gr0(sa).element.create(n_keep,na)
            bf_grx(sa).element.create(n_keep,na)
            bf_gry(sa).element.create(n_keep,na)
            bf_grz(sa).element.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     bf_gr0(sa)[i,a] = gridc0(n,a+offset)
                     bf_grx(sa)[i,a] = gridcx(n,a+offset)
                     bf_gry(sa)[i,a] = gridcy(n,a+offset)
                     bf_grz(sa)[i,a] = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid( &
                  bf_grx(sa).element,  &
                  bf_gry(sa).element,  &
                  bf_grz(sa).element,  &
                  bf_gr0(sa).element,  &
                  n_keep,xa,ya,za,a2,skipa,n_pt)
            end

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.deallocated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb = bf_skip(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_gr0(sa)[:,1]
                     gax = bf_grx(sa)[:,1]
                     gay = bf_gry(sa)[:,1]
                     gaz = bf_grz(sa)[:,1]

                     gb0 = bf_gr0(sb)[:,1]
                     gbx = bf_grx(sb)[:,1]
                     gby = bf_gry(sb)[:,1]
                     gbz = bf_grz(sb)[:,1]

                     Dab = fac*DD(1,1)

                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        N0(n) = N0(n) + Dab* ga*gb
                        Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                        Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                        Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_gr0(sa)[:,a]
                        gax = bf_grx(sa)[:,a]
                        gay = bf_gry(sa)[:,a]
                        gaz = bf_grz(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_gr0(sb)[:,b]
                           gbx = bf_grx(sb)[:,b]
                           gby = bf_gry(sb)[:,b]
                           gbz = bf_grz(sb)[:,b]
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              N0(n) = N0(n) + Dab* ga*gb
                              Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                              Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                              Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridcz.destroy
      gridcy.destroy
      gridcx.destroy
      gridc0.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,Da,Db) ::: leaky, PURE
   ! Make the alpha and beta densities "N0a", "N0b" on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" arrays and the "bf_grid0" array used
   ! for evaluating the density (or density functionals) on the grid.
      self :: INOUT
      N0a,N0b :: VEC{REAL}@, OUT
      pt :: MAT{REAL}@, OUT
      wt :: VEC{REAL}@, OUT
      bf_skip :: VEC{EVEC{BIN}}@, OUT
      bf_grid0 :: VEC{EMAT{REAL}}@, OUT
      c  :: INT, IN
      Da,Db  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gb0 :: VEC{REAL}@
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab, skipa,skipb :: VEC{BIN}@
      gridc0  :: MAT{REAL}@
      DDa,DDb :: MAT{REAL}@
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom = .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0a, N0b
      N0a.create(n_pt); N0a = ZERO
      N0b.create(n_pt); N0b = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set shell "sa"
            ba  = .basis_shell_for_shell(sa)
            sha = .basis_shell1pair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element.create(skipa.dim)
            bf_skip(sa).element = skipa

            ! Make/copy the "sa" basis function grid
            ! This must be copied since skipa could be TRUE
            bf_grid0(sa).element.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     bf_grid0(sa)[i,a] = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(bf_grid0(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
            end

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.deallocated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb = bf_skip(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa = Da(fa:la,fb:lb)
                  DDb = Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sb)[:,1]

                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)

                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        N0a(n) = N0a(n) + Da_ab*gab
                        N0b(n) = N0b(n) + Db_ab*gab
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              gab = ga*gb
                              N0a(n) = N0a(n) + Da_ab*gab
                              N0b(n) = N0b(n) + Db_ab*gab
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb,pt,wt,bf_skip,bf_gr0,bf_grx,bf_gry,bf_grz,c,Da,Db) ::: leaky, PURE
   ! Make the densities "N0a", "N0b" and their alpha/beta derivatives
   ! "Nxa", "Nya", "Nza", "Nxb", "Nyb", "Nzb", on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" array, and the basis function and basis
   ! function derivative arrays "bf_gr0", "bf_grx", "bf_gry",
   ! "bf_grz" for evaluating the density functionals on the grid.
      self :: INOUT
      N0a,N0b :: VEC{REAL}@, OUT
      Nxa,Nya,Nza :: VEC{REAL}@, OUT
      Nxb,Nyb,Nzb :: VEC{REAL}@, OUT
      pt :: MAT{REAL}@, OUT
      wt :: VEC{REAL}@, OUT
      bf_skip :: VEC{EVEC{BIN}}@, OUT
      bf_gr0,bf_grx,bf_gry,bf_grz :: VEC{EMAT{REAL}}@, OUT
      c  :: INT, IN
      Da,Db :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gax,gay,gaz :: VEC{REAL}@
      gb0,gbx,gby,gbz :: VEC{REAL}@
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab, skipa,skipb :: VEC{BIN}@
      DDa,DDb :: MAT{REAL}@
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}@
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab,gx,gy,gz :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom = .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom)
      n_pt = pt.dim1

      ! Create N0 arrays
      N0a.create(n_pt); Nxa.create(n_pt); Nya.create(n_pt); Nza.create(n_pt)
      N0b.create(n_pt); Nxb.create(n_pt); Nyb.create(n_pt); Nzb.create(n_pt)
      N0a = ZERO; Nxa = ZERO; Nya = ZERO; Nza = ZERO
      N0b = ZERO; Nxb = ZERO; Nyb = ZERO; Nzb = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_gr0.create(.n_shell)
      bf_grx.create(.n_shell)
      bf_gry.create(.n_shell)
      bf_grz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set shell "sa"
            ba  = .basis_shell_for_shell(sa)
            sha = .basis_shell1pair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element.create(skipa.dim)
            bf_skip(sa).element = skipa

            ! Make/copy the "sa" basis function grid
            ! This must be copied since skipa could be TRUE
            bf_gr0(sa).element.create(n_keep,na)
            bf_grx(sa).element.create(n_keep,na)
            bf_gry(sa).element.create(n_keep,na)
            bf_grz(sa).element.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     bf_gr0(sa)[i,a] = gridc0(n,a+offset)
                     bf_grx(sa)[i,a] = gridcx(n,a+offset)
                     bf_gry(sa)[i,a] = gridcy(n,a+offset)
                     bf_grz(sa)[i,a] = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid( &
                  bf_grx(sa).element,  &
                  bf_gry(sa).element,  &
                  bf_grz(sa).element,  &
                  bf_gr0(sa).element,  &
                  n_keep,xa,ya,za,a2,skipa,n_pt)
            end

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.deallocated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb = bf_skip(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa = Da(fa:la,fb:lb)
                  DDb = Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_gr0(sa)[:,1]
                     gax = bf_grx(sa)[:,1]
                     gay = bf_gry(sa)[:,1]
                     gaz = bf_grz(sa)[:,1]

                     gb0 = bf_gr0(sb)[:,1]
                     gbx = bf_grx(sb)[:,1]
                     gby = bf_gry(sb)[:,1]
                     gbz = bf_grz(sb)[:,1]

                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)

                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        gx  = gax(i)*gb+ga*gbx(j)
                        gy  = gay(i)*gb+ga*gby(j)
                        gz  = gaz(i)*gb+ga*gbz(j)

                        N0a(n) = N0a(n) + Da_ab*gab
                        Nxa(n) = Nxa(n) + Da_ab*gx
                        Nya(n) = Nya(n) + Da_ab*gy
                        Nza(n) = Nza(n) + Da_ab*gz

                        N0b(n) = N0b(n) + Db_ab*gab
                        Nxb(n) = Nxb(n) + Db_ab*gx
                        Nyb(n) = Nyb(n) + Db_ab*gy
                        Nzb(n) = Nzb(n) + Db_ab*gz

                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_gr0(sa)[:,a]
                        gax = bf_grx(sa)[:,a]
                        gay = bf_gry(sa)[:,a]
                        gaz = bf_grz(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_gr0(sb)[:,b]
                           gbx = bf_grx(sb)[:,b]
                           gby = bf_gry(sb)[:,b]
                           gbz = bf_grz(sb)[:,b]
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)

                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)

                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              gx  = gax(i)*gb+ga*gbx(j)
                              gy  = gay(i)*gb+ga*gby(j)
                              gz  = gaz(i)*gb+ga*gbz(j)

                              N0a(n) = N0a(n) + Da_ab*gab
                              Nxa(n) = Nxa(n) + Da_ab*gx
                              Nya(n) = Nya(n) + Da_ab*gy
                              Nza(n) = Nza(n) + Da_ab*gz

                              N0b(n) = N0b(n) + Db_ab*gab
                              Nxb(n) = Nxb(n) + Db_ab*gx
                              Nyb(n) = Nyb(n) + Db_ab*gy
                              Nzb(n) = Nzb(n) + Db_ab*gz

                           end

                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridcz.destroy
      gridcy.destroy
      gridcx.destroy
      gridc0.destroy

   end

!  ======================
!  Residual density grids
!  ======================

   make_residual_density_grid(grid,pt) ::: PURE
   ! Make the residual density grid from experimental and calculated
   ! structure factors. Needs crystal & those to exist already!
   ! NOTE: unusually, this always returns values in Anstrom^-3
      self :: INOUT
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   ENSURE(pt.dim1==grid.dim, "wrong dim1, pt array")
   ENSURE(pt.dim2==3,        "wrong dim2, for pt array")
   ENSURE(.atom.allocated, "no atoms to fit")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")
   ENSURE(.crystal.xray_data.allocated,"no crystal xray data")

      fac,fac3 :: REAL

      ! Make the residual map
      .crystal.make_residual_density_grid(grid,pt)

      ! Change to /A3
      fac    = ANGSTROM_PER_BOHR
      fac3   = BOHR_PER_ANGSTROM**3
      grid   = fac3*grid

   end

!  =========================
!  Interaction density grids
!  =========================

   make_interaction_density_grid(grid,pt) ::: get_from(int_grid, GRID?=>:make_ED_grid), PURE
   ! Make the interaction density grid.
   end

!  =========================
!  Deformation density grids
!  =========================

   make_def_ED_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_ED_grid, PRO?=>:make_promolecule_density_grid), PURE
   ! Make deformation density "grid" on a set of points "pt".
   end

!  =========
!  ADP grids
!  =========

   make_ADP_grid(g,pt)
   ! Work out the ADP density grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_ADP_grid(g,pt,.crystal.unit_cell)

   end


   make_ADP2_exponent_grid(g,pt)
   ! Work out the ADP2 PDF exponent grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_ADP2_exponent_grid(g,pt)

   end


   make_ADP_exponent_grid(g,pt)
   ! Work out the ADP density grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_ADP_exponent_grid(g,pt,.crystal.unit_cell)

   end


   make_AADP_correction_grid(g,pt)
   ! Work out the anharmonic ADP PDF correction density grid "g" for points "pt".
   ! For the first atom, only
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.plot_grid.center_atom>0,"no center_atom")

      .atom(1).make_AADP_PDF_correction_grid(g,pt)

   end

!  ==================
!  Bond density grids
!  ==================

   make_def_bond_density_grid
   ! Work out the property density on ".plot_grid" using ".natural
   ! orbitals" and the ".NO_occ_nos" vector. A Gnuplot ascii
   ! file is generated.
      self :: IN

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.bond_density_atom.allocated,"no bond_density_atoms")

      grid :: VEC{REAL}@
      pt :: MAT{REAL}@
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .GRID:make_def_bond_density_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "deformation_bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str)
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str)
      label = trim(label) // ")_density_grid"

      ! Print out
      .PUT:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom) ::: PURE
   ! Make the bond deformation "density_grid" for the points "pt".
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt           :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}@

      ! Make the deformation ED grid
      .GRID:make_def_ED_grid(density_grid,pt)

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
         if (NOT .atom.bonded(a,b)) cycle
         r_ab = HALF*(.atom(a).position + .atom(b).position)
         do n = 1,n_pt
            x  = pt(n,1) - r_ab(1)
            y  = pt(n,2) - r_ab(2)
            z  = pt(n,3) - r_ab(3)
            rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
         end
      end
      end

      ! Make the density grid

      select case (n_atoms)

      case (2:3) ! Two or three atoms in the list

         ! Indices of bonded pair
         a = bond_density_atom(1)
         b = bond_density_atom(2)

         ! Make the deformation bond pair density
         r_ab = HALF*(.atom(a).position + .atom(b).position)
         do n = 1,n_pt
            if (rho(n)>epsilon(ONE)) then
               x  = pt(n,1) - r_ab(1)
               y  = pt(n,2) - r_ab(2)
               z  = pt(n,3) - r_ab(3)
               density_grid(n) = density_grid(n)*exp(-(x*x+y*y+z*z))/rho(n)
            else
               density_grid(n) = ZERO
            end
         end

         ! Make the (third) atom contribution === if required
         if (n_atoms==3) then

            rho_a.create(n_pt)
            rho_b.create(n_pt)

            .atom(a).make_ED_grid(rho_a,pt)
            .atom(b).make_ED_grid(rho_b,pt)

            rho = rho_a + rho_b

            c = bond_density_atom(3)
            if (c==a) then
               where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
               elsewhere;                density_grid = ZERO
               end
            else if (c==b) then
               where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
               elsewhere;                density_grid = ZERO
               end
          ! else
          !    DIE("atom is not one of those in the bond")
            end

            rho_b.destroy
            rho_a.destroy

         end

    ! case default
    !    DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid) ::: PURE
   ! Make the bond deformation "density_grid" for the points "pt".
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}, IN
      def_density_grid :: VEC{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z,r_inv :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}@

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
         if (NOT .atom.bonded(a,b)) cycle
         r_ab = HALF*(.atom(a).position + .atom(b).position)
         r_inv = ONE/r_ab.norm
         do n = 1,n_pt
            x  = pt(n,1) - r_ab(1)
            y  = pt(n,2) - r_ab(2)
            z  = pt(n,3) - r_ab(3)
            rho(n) = rho(n) + exp(-(x*x + y*y + z*z)*r_inv)
         end
      end
      end

      ! Make the density grid

      select case (n_atoms)

      case (2:3) ! Two or three atoms in the list

         ! Indices of bonded pair
         a = bond_density_atom(1)
         b = bond_density_atom(2)

         ! Make the deformation bond pair density
         r_ab = HALF*(.atom(a).position + .atom(b).position)
         r_inv = ONE/r_ab.norm
         do n = 1,n_pt
            if (rho(n)>epsilon(ONE)) then
               x  = pt(n,1) - r_ab(1)
               y  = pt(n,2) - r_ab(2)
               z  = pt(n,3) - r_ab(3)
               density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z)*r_inv)/rho(n)
            else
               density_grid(n) = ZERO
            end
         end

         ! Make the (third) atom contribution === if required
         if (n_atoms==3) then

            rho_a.create(n_pt)
            rho_b.create(n_pt)

            .atom(a).make_ED_grid(rho_a,pt)
            .atom(b).make_ED_grid(rho_b,pt)

            rho = rho_a + rho_b

            c = bond_density_atom(3)
            if (c==a) then
               where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
               elsewhere;                density_grid = ZERO
               end
            else if (c==b) then
               where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
               elsewhere;                density_grid = ZERO
               end
          ! else
          !    DIE("atom is not one of those in the bond")
            end

            rho_b.destroy
            rho_a.destroy

         end

    ! case default
    !    DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end


   make_bond_weight_grid
   ! Work out the property density on ".plot_grid" using ".natural
   ! orbitals" and the ".NO_occ_nos" vector. A Gnuplot ascii
   ! file is generated.
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.bond_density_atom.allocated,"no bond_density_atoms")

      grid :: VEC{REAL}@
      pt :: MAT{REAL}@
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .GRID:make_bond_weight_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str)
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str)
      label = trim(label) // ")_weight_grid"

      ! Print out
      .PUT:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_weight_grid(density_grid,pt,bond_density_atom) ::: PURE
   ! Make the bond deformation "density_grid" for the points "pt".
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}@

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
         if (NOT .atom.bonded(a,b)) cycle
         r_ab = HALF*(.atom(a).position + .atom(b).position)
         do n = 1,n_pt
            x  = pt(n,1) - r_ab(1)
            y  = pt(n,2) - r_ab(2)
            z  = pt(n,3) - r_ab(3)
            rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
         end
      end
      end

      ! Make the density grid

      select case (n_atoms)

      case (2:3) ! Two or three atoms in the list

         ! Indices of bonded pair
         a = bond_density_atom(1)
         b = bond_density_atom(2)

         ! Make the deformation bond pair density
         r_ab = HALF*(.atom(a).position + .atom(b).position)
         do n = 1,n_pt
            if (rho(n)>epsilon(ONE)) then
               x  = pt(n,1) - r_ab(1)
               y  = pt(n,2) - r_ab(2)
               z  = pt(n,3) - r_ab(3)
               density_grid(n) = exp(-(x*x+y*y+z*z))/rho(n)
            else
               density_grid(n) = ZERO
            end
         end

         ! Make the (third) atom contribution === if required
         if (n_atoms==3) then

            rho_a.create(n_pt)
            rho_b.create(n_pt)

            .atom(a).make_ED_grid(rho_a,pt)
            .atom(b).make_ED_grid(rho_b,pt)

            rho = rho_a + rho_b

            c = bond_density_atom(3)
            if (c==a) then
               where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
               elsewhere;                density_grid = ZERO
               end
            else if (c==b) then
               where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
               elsewhere;                density_grid = ZERO
               end
          ! else
          !    DIE("atom is not one of those in the bond")
            end

            rho_b.destroy
            rho_a.destroy

         end

    ! case default
    !    DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end


   make_bond_density_atom_grid
   ! Work out the bond density atom on ".plot_grid"
      self :: IN

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.bond_density_atom.allocated,"no bond_density_atoms")

      grid :: VEC{REAL}@
      pt :: MAT{REAL}@
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .GRID:make_bond_density_atom_grid(grid,pt,.plot_grid.bond_density_atom(1))

      ! Make the plot label
      label = "bond_density_atom_"
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str)
      label = trim(label) // "_grid"

      ! Print out
      .PUT:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_density_atom_grid(density_grid,pt,a) ::: PURE
   ! Make the bond density atom grid "density_grid" for the points
   ! "pt" for atom with index "a".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      a :: INT, IN

   ENSURE(.atom.allocated,"no atoms")

      n_pt,i :: INT
      rho_bond,def_density_grid :: VEC{REAL}@
      bond_density_atom :: VEC{INT}@

      ! No of grid points
      n_pt = density_grid.dim

      ! Do only the spherical part if a<0
      if (a<0) then

        .atom(-a).make_ED_grid(density_grid,pt)

      ! Do the whole BDA
      else

        ! Allocate
        def_density_grid.create(n_pt)
        rho_bond.create(n_pt)

        ! Space for bond density atoms
        bond_density_atom.create(3)
        bond_density_atom(1) = a
        bond_density_atom(3) = a

        ! Make the deformation density
        .GRID:make_def_ED_grid(def_density_grid,pt)

        ! Add spherical part
        .atom(a).make_ED_grid(density_grid,pt)

        ! Get bond density contributions
        do i = 1,.n_atom
           if (i==a) cycle
           if (NOT .atom.bonded(i,a)) cycle
           bond_density_atom(2) = i
           .GRID:make_def_bond_density_grid(rho_bond,pt,bond_density_atom,def_density_grid)
           density_grid = density_grid + rho_bond
        end

        ! Clean up
        bond_density_atom.destroy
        rho_bond.destroy
        def_density_grid.destroy

      end

   end

!  ============================
!  Local ionisation energy grid
!  ============================

   make_local_ionisation_grid(grid,pt) ::: PURE
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")

      if (trim(.MOs.number_kind)=="real") then
         .GRID:make_local_ionisation_grid_r(grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_local_ionisation_grid_r(grid,pt) ::: PURE
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.MOs.is_allocated_with_genre("r "), "no restricted MO's")
   ENSURE(.MO_energies.is_allocated_with_genre("r "),"no restricted MO energies")

      rho,MO :: VEC{REAL}@
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      rho.create(n_pt)
      MO.create(n_pt)

      rho  = ZERO
      grid = ZERO

      parallel do n = 1,n_occ
        .GRID:make_orbital_grid_r(MO,.MOs.r(:,n),pt,square=TRUE)
        rho  = rho  + MO
        grid = grid - MO*.MO_energies.r(n)
      end

      PARALLEL_SUM(rho)
      PARALLEL_SUM(grid)

      grid = grid/rho

      MO.destroy
      rho.destroy

   end

!  =======================
!  Local virial ratio grid
!  =======================

   make_local_virial_ratio_grid(grid,pt) ::: PURE
   ! Work out local virial ratio "grid" using points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")

      if (trim(.MOs.number_kind)=="real") then
         .GRID:make_local_virial_ratio_grid_r(grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_local_virial_ratio_grid_r(grid,pt) ::: PURE
   ! Work out local virial ratio  "grid" using points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")

      L, G :: VEC{REAL}@
      n_pt :: INT

      n_pt = pt.dim1

      L.create(n_pt)
      G.create(n_pt)

      .GRID:make_laplacian_grid_r(L,pt)
      .GRID:make_G_kinetic_density_grid_r(G,pt)

      grid = TWO - QUARTER*L/G

      G.destroy
      L.destroy

   end

! ==========================
! Laplacian density routines
! ==========================

   make_laplacian_grid(laplacian_grid,pt) ::: PURE
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".NO_occ_nos" vector.
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      NO_kind :: STR

      NO_kind = .NOs.genre

      if (trim(.NOs.number_kind)=="real") then
         select case (NO_kind)
         case ("r ")
            .GRID:make_laplacian_grid_r(laplacian_grid,pt)
         case ("u ")
            .GRID:make_laplacian_grid_u(laplacian_grid,pt)
         end
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt) ::: PURE
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO :: VEC{REAL}@
      P,D :: MAT{REAL}@
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      parallel do n = 1,n_occ

         .GRID:make_laplacian_orbital_grid_r(D,P,NO,.NOs.r(:,n), pt)

         occ = .NO_occ_nos.r(n)

         laplacian_grid = laplacian_grid + occ * (  &
                          NO*(D(:,1)+D(:,2)+D(:,3)) &
                        + P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3) )

      end
      PARALLEL_SUM(laplacian_grid)

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_grid_u(laplacian_grid,pt) ::: PURE
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      grida,gridb :: VEC{REAL}@
      n_pt :: INT

      n_pt = pt.dim1

      grida.create(n_pt)
      gridb.create(n_pt)

      laplacian_grid = ZERO
      grida = ZERO
      gridb = ZERO

      ! alpha part
      .GRID:make_laplacian_grid_a(grida,pt)

      ! beta part
      .GRID:make_laplacian_grid_b(gridb,pt)

      ! a + b
      laplacian_grid = grida + gridb

      grida.destroy
      gridb.destroy

   end

   make_laplacian_grid_a(laplacian_grid,pt) ::: PURE
   ! Make the "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO :: VEC{REAL}@
      P,D :: MAT{REAL}@
      na,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      na = .INQ:no_of_occupied_NOs("alpha")

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      ! alpha part
      parallel do n = 1,na

         .GRID:make_laplacian_orbital_grid_r(D,P,NO,.NOs.a(:,n), pt)

         occ = .NO_occ_nos.a(n)
         laplacian_grid = laplacian_grid + occ * ( &
                          NO*(D(:,1)       +D(:,2)       + D(:,3)) &
                        +     P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3) )

      end
      PARALLEL_SUM(laplacian_grid)

      ! it seems that the factor is required
      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_grid_b(laplacian_grid,pt) ::: PURE
   ! Make the "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO :: VEC{REAL}@
      P,D :: MAT{REAL}@
      nb,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      nb = .INQ:no_of_occupied_NOs("beta")

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      ! beta part
      parallel do n = 1,nb

         .GRID:make_laplacian_orbital_grid_r(D,P,NO,.NOs.b(:,n), pt)

         occ = .NO_occ_nos.b(n)
         laplacian_grid = laplacian_grid + occ * ( &
                          NO*(D(:,1)       +D(:,2)       +D(:,3)) &
                        +     P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3) )

      end
      PARALLEL_SUM(laplacian_grid)

      ! it seems that the factor is required
      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end


   make_def_laplacian_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_laplacian_grid, PRO?=>:make_pro_laplacian_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_laplacian_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_laplacian_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_neg_laplacian_grid(laplacian_grid,pt) ::: PURE
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".NO_occ_nos" vector.
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      NO_kind :: STR
      NO_kind = .NOs.genre

      if (trim(.NOs.number_kind)=="real") then

         select case (NO_kind)
         case ("r ")
           .GRID:make_laplacian_grid_r(laplacian_grid,pt)
           laplacian_grid = -laplacian_grid
         case ("u ")
           .GRID:make_laplacian_grid_u(laplacian_grid,pt)
           laplacian_grid = -laplacian_grid
       ! case default
       !   DIE("unknown real orbital kind")
         end

      end

   end


   make_rL_grid(laplacian_grid,pt) ::: PURE
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural
   ! orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (trim(.NOs.number_kind)== "real") then
         .GRID:make_rL_grid_r(laplacian_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_rL_grid_r(laplacian_grid,pt) ::: PURE
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      self :: IN
      laplacian_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      rho,NO :: VEC{REAL}@
      P,D :: MAT{REAL}@
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt  = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO
      rho = ZERO

      do n = 1,n_occ
         .GRID:make_laplacian_orbital_grid_r(D,P,NO,.NOs.r(:,n), pt)
         occ = .NO_occ_nos.r(n)
         laplacian_grid = laplacian_grid + occ * ( &
              NO*(D(:,1)       +D(:,2)       + D(:,3) )  &
            +     P(:,1)*P(:,1)+P(:,2)*P(:,2)+ P(:,3)*P(:,3) )
         rho = rho + occ*NO*NO

      end

      laplacian_grid = TWO*laplacian_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  ===============================
!  K-type kinetic density routines
!  ===============================

   make_K_kinetic_energy_grid(K_grid,pt) ::: PURE
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt" using
   ! ".natural orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      K_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_K_kinetic_density_grid_r(K_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end
 
   make_K_kinetic_density_grid_r(K_grid,pt) ::: PURE
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      self :: IN
      K_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO :: VEC{REAL}@
      P,D :: MAT{REAL}@
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      K_grid = ZERO

      do n = 1,n_occ
         .GRID:make_laplacian_orbital_grid_r(D,P,NO,.NOs.r(:,n), pt)
         K_grid = K_grid &
                + .NO_occ_nos.r(n) * NO * (D(:,1)+D(:,2)+D(:,3))

      end

      K_grid = -HALF*K_grid

      D.destroy
      P.destroy
      NO.destroy

   end


   make_def_K_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_K_kinetic_energy_grid, PRO?=>:make_pro_K_kinetic_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_K_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_K_kinetic_energy_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_rK_kinetic_energy_grid(K_grid,pt) ::: PURE
   ! Work out the K-type reduced kinetic energy density (using the nabla^2) on
   ! "pt" using ".natural orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      K_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_rK_kinetic_density_grid_r(K_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_rK_kinetic_density_grid_r(K_grid,pt) ::: PURE
   ! Make the K-type reduced kinetic energy density "K_grid" for the supplied
   ! points "pt" from restricted real natural orbitals
      self :: IN
      K_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO,rho :: VEC{REAL}@
      P,D :: MAT{REAL}@
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      K_grid = ZERO
      rho    = ZERO

      do n = 1,n_occ

         .GRID:make_laplacian_orbital_grid_r(D,P,NO,.NOs.r(:,n), pt)

         occ = .NO_occ_nos.r(n)

         K_grid = K_grid + occ*NO*(D(:,1)+D(:,2)+D(:,3))
         rho    = rho    + occ*NO*NO

      end

      K_grid = -HALF*K_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

   make_def_rK_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_rK_kinetic_energy_grid, PRO?=>:make_pro_rK_kinetic_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_rK_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_rK_kinetic_energy_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end

!  ===============================
!  G-type kinetic density routines
!  ===============================

   make_norm_G_from_virial_grid(G_grid,pt) ::: PURE
   ! Work out the normalized G kinetic energy density
   ! This has the scf energy subtracted.
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      .GRID:make_G_kinetic_energy_grid(G_grid,pt)

      G_grid = G_grid + .scfdata.energy

   end

   make_G_kinetic_energy_grid(G_grid,pt) ::: PURE
   ! Work out the G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_G_kinetic_density_grid_r(G_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_G_kinetic_density_grid_r(G_grid,pt) ::: PURE
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO, orb :: VEC{REAL}@
      P :: MAT{REAL}@
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO

      do n = 1,n_occ
         orb = .NOs.r(:,n)
         .GRID:make_nabla_orbital_grid_r(P,NO,orb, pt)
         G_grid(:) = G_grid(:) &
                   + .NO_occ_nos.r(n) &
                   * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end

      G_grid(:) = HALF*G_grid(:)

      P.destroy
      NO.destroy

   end


   make_G_Kirzhnits_grid(G_grid,pt) ::: PURE
   ! Work out the G-type Kirzhnits kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_G_Kirzhnits_grid_r(G_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_G_Kirzhnits_grid_r(G_grid,pt) ::: PURE
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO,rho,nab_ro2,lap_rho, orb :: VEC{REAL}@
      G,L,nab_rho :: MAT{REAL}@
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT

      n_pt =  pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      rho.create(n_pt)
      lap_rho.create(n_pt)
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3)
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)

      rho     = ZERO
      lap_rho = ZERO
      nab_rho = ZERO

      do n = 1,n_occ

         orb = .NOs.r(:,n)
         .GRID:make_laplacian_orbital_grid_r(L,G,NO,orb, pt)

         occ  = .NO_occ_nos.r(n)
         occ2 = TWO*occ

         rho          = rho          + occ *NO*NO
         nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
         nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,2)
         nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,3)
         lap_rho      = lap_rho      + occ2*(NO*(L(:,1)+L(:,2)+L(:,3))) &
                                     + occ2*(G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3))
      end

      L.destroy
      G.destroy
      NO.destroy

      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) &
              + nab_rho(:,2)*nab_rho(:,2) &
              + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy

      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRD)
      G_grid = fac*rho**(FIVE/THREE) &
             + lambda*nab_ro2/rho + k2*lap_rho

      nab_ro2.destroy
      lap_rho.destroy
      rho.destroy

   end


   make_def_G_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_G_kinetic_energy_grid, PRO?=>:make_pro_G_kinetic_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_G_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_G_kinetic_energy_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_def_G_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_G_Kirzhnits_grid, PRO?=>:make_pro_G_Kirzhnits_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_G_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_G_Kirzhnits_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_rG_kinetic_energy_grid(G_grid,pt) ::: PURE
   ! Work out the reduced G-type kinetic density (using nabla
   ! phi.nabla phi) on "pt" using ".natural orbitals" and  the
   ! ".NO_occ_nos" vector.
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_rG_kinetic_density_grid_r(G_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_rG_kinetic_density_grid_r(G_grid,pt) ::: PURE
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      self :: IN
      G_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      rho,NO, orb :: VEC{REAL}@
      P :: MAT{REAL}@
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         orb = .NOs.r(:,n)
         .GRID:make_nabla_orbital_grid_r(P,NO,orb, pt)

         occ = .NO_occ_nos.r(n)

         G_grid = G_grid + occ * ( &
                  P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3) )
         rho    = rho    + occ*NO*NO

      end

      G_grid = HALF*G_grid/rho

      P.destroy
      NO.destroy
      rho.destroy

   end

   make_def_rG_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_rG_kinetic_energy_grid, PRO?=>:make_pro_rG_kinetic_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_rG_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_rG_kinetic_energy_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end

!  ===============================
!  G and K-type kinetic densities
!  ===============================

   make_G_and_K_kinetic_grids(G_grid,K_grid,pt) ::: PURE
   ! Work out the G and K-type kinetic energy density on "pt" using
   ! ".natural orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      G_grid :: VEC{REAL}, OUT
      K_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt) ::: PURE
   ! Make the G and K-type kinetic energy grids for the supplied points
   ! "pt" from restricted real natural orbitals
      self :: IN
      G_grid :: VEC{REAL}, OUT
      K_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      NO, orb :: VEC{REAL}@
      P,D :: MAT{REAL}@
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_occ = .INQ:no_of_occupied_NOs
      n_pt = pt.dim1

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      G_grid = ZERO
      K_grid = ZERO

      do n = 1,n_occ

         orb = .NOs.r(:,n)
         .GRID:make_laplacian_orbital_grid_r(D,P,NO,orb, pt)

         occ = .NO_occ_nos.r(n)

         G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         K_grid = K_grid + occ * NO * (D(:,1)+D(:,2)+D(:,3))

      end

      G_grid =  HALF*G_grid
      K_grid = -HALF*K_grid

      D.destroy
      P.destroy
      NO.destroy

   end

!  =================
!  LOL from Schmider
!  =================

   make_LOL_grid(LOL_grid,pt) ::: PURE
   ! Work out the LOL density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".NO_occ_nos" vector.
      self :: IN
      LOL_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (.NOs.number_kind=="real") then
         .GRID:make_LOL_grid_r(LOL_grid,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_LOL_grid_r(LOL_grid,pt) ::: PURE
   ! Make the "LOL_grid" for the supplied points
   ! "pt" from restricted real natural orbitals.
   ! See Schmider & Becke (2000) J. Mol. STruct 527 p. 51-61.
      self :: IN
      LOL_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.NOs.is_allocated_with_genre("r "), "no restricted NO's")
   ENSURE(.NO_occ_nos.r.allocated, "no occupation #'s")

      tau,tau0 :: VEC{REAL}@
      NO, orb :: VEC{REAL}@
      P :: MAT{REAL}@
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      tau0.create(n_pt)
      tau.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)

      LOL_grid = ZERO

      do n = 1,n_occ
         orb = .NOs.r(:,n)
         .GRID:make_nabla_orbital_grid_r(P,NO,orb, pt)
         occ =  .NO_occ_nos.r(n)
         if (occ.is_zero(TOL(8))) cycle
         tau  = tau  + occ*(P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         tau0 = tau0 + occ*NO*NO
      end

      tau  = HALF*tau
      tau0 = HALF*tau0

      ! Make tau0
      tau0 = 0.6d0*(SIX*PI*PI)**(TWO/THREE) * (tau0)**(FIVE/THREE)

      ! Make t(sigma)
      where (abs(tau0)<TOL(8))
         tau = tau/tau0
      elsewhere
         tau = ZERO
      end

      ! Make LOL
      LOL_grid = tau/(ONE+tau)

      ! Clean
      P.destroy
      NO.destroy
      tau.destroy
      tau0.destroy

   end

!  =============================
!  Energy density from rho grids
!  =============================

   make_E_hf_dens_from_rho_grid(E_grid,pt) ::: PURE
   ! Work out the energy density as the scaled electron density.
      self :: IN
      E_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.scfdata.SCF_kind.is_one_of(["rhf","uhf"]),"scf is not RHF/UHF")

      fac :: REAL

      .GRID:make_ED_grid(E_grid,pt)
      fac = .scfdata.energy/.n_e
      E_grid = fac*E_grid

   end

   make_def_E_hf_from_rho_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_E_hf_dens_from_rho_grid, PRO?=>:make_E_hf_dens_from_rho_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

!  ========================================================
!  H-type total energy density obtained from virial theorem
!  ========================================================

   make_norm_H_from_virial_grid(H_grid,pt) ::: PURE
   ! Work out the normalized energy density using the virial
   ! relationsip 2G + V = (1/4) L, or H = G + V = (1/4)L - G
   ! This has the scf energy subtracted.
      self :: IN
      H_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G_grid :: VEC{REAL}@

      G_grid.create(.plot_grid.n_pt)

      .GRID:make_G_kinetic_energy_grid(G_grid,pt)
      .GRID:make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid - .scfdata.energy

      G_grid.destroy

   end

   make_H_from_virial_grid(H_grid,pt) ::: PURE
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      self :: IN
      H_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G_grid :: VEC{REAL}@

      G_grid.create(.plot_grid.n_pt)

      .GRID:make_G_kinetic_energy_grid(G_grid,pt)
      .GRID:make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_H_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_H_from_virial_grid, PRO?=>:make_pro_H_from_virial_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_H_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_H_from_virial_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_H_Kirzhnits_grid(H_grid,pt) ::: PURE
   ! Work out the energy density using the Kirzhnits relationsip 2G +
   ! V = (1/4) L, or H = G + V = (1/4)L - G
      self :: IN
      H_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G_grid :: VEC{REAL}@

      G_grid.create(.plot_grid.n_pt)

      .GRID:make_G_Kirzhnits_grid(G_grid,pt)
      .GRID:make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_H_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_H_Kirzhnits_grid, PRO?=>:make_pro_H_Kirzhnits_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_H_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_H_Kirzhnits_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_rH_from_virial_grid(H_grid,pt) ::: PURE
   ! Work out the reduced energy density using the virial relationsip
   ! 2G + V = (1/4) L, or H = G + V = (1/4)L - G
      self :: IN
      H_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G_grid :: VEC{REAL}@

      G_grid.create(.plot_grid.n_pt)

      .GRID:make_rG_kinetic_energy_grid(G_grid,pt)
      .GRID:make_rL_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_rH_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_rH_from_virial_grid, PRO?=>:make_pro_rH_from_virial_grid), PURE
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_rH_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_rH_from_virial_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end

!  =====================================================
!  Potential energy density obtained from virial theorem
!  =====================================================

   make_V_from_virial_grid(V,pt) ::: PURE
   ! Work out the energy density from usiang the virial theorem: 
   ! V = (1/4) L - 2G
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G :: VEC{REAL}@

      G.create(.plot_grid.n_pt)

      .GRID:make_G_kinetic_energy_grid(G,pt)
      .GRID:make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_V_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_V_from_virial_grid, PRO?=>:make_pro_V_from_virial_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_V_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_V_from_virial_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_V_Kirzhnits_grid(V,pt) ::: PURE
   ! Work out the energy density from usiang the Kirzhnits theorem: 
   ! V = (1/4) L - 2G
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G :: VEC{REAL}@

      G.create(.plot_grid.n_pt)

      .GRID:make_G_Kirzhnits_grid(G,pt)
      .GRID:make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_V_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_V_Kirzhnits_grid, PRO?=>:make_pro_V_Kirzhnits_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_V_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_V_Kirzhnits_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end


   make_rV_from_virial_grid(V,pt) ::: PURE
   ! Work out the energy density from usiang the virial theorem: 
   ! V = (1/4) L - 2G
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      G :: VEC{REAL}@

      G.create(.plot_grid.n_pt)

      .GRID:make_rG_kinetic_energy_grid(G,pt)
      .GRID:make_rL_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_rV_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_rV_from_virial_grid, PRO?=>:make_pro_rV_from_virial_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_rV_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_rV_from_virial_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end

   make_norm_V_from_virial_grid(V,pt) ::: PURE
   ! Work out the Wang and Peng's generalization of Berlin's 
   ! binding energy density
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scfdata!")
   ENSURE(NOT .scfdata.energy.is_zero,"no scf energy!")

      G :: VEC{REAL}@

      G.create(.plot_grid.n_pt)

      .GRID:make_G_kinetic_energy_grid(G,pt)
      .GRID:make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G - TWO*.scfdata.energy

      G.destroy

   end

   make_binding_function_WP_grid(V,pt) ::: PURE
   ! Work out the Wang and Peng's generalization of Berlin's binding
   ! energy density using *their* formula (47)
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scfdata!")
   ENSURE(NOT .scfdata.energy.is_zero,"no scf energy!")

      Ra,r,center :: VEC{REAL}(3)
      l,d :: REAL
      a,i,Za :: INT

      V = ZERO

      center  = .atom.center_of_atoms

      do a = 1,.n_atom

         Ra = .atom(a).position - center
         Za = .atom(a).atomic_number

         do i = 1,V.dim

            r(1) = pt(i,1) - center(1) - Ra(1)
            r(2) = pt(i,2) - center(2) - Ra(2)
            r(3) = pt(i,3) - center(3) - Ra(3)

            l = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))
            d = Ra(1)*r(1) + Ra(2)*r(2) + Ra(3)*r(3)

            V(i) = V(i) - Za*d/(l*l*l)

         end

      end

   end

!  ==================
!  Electric potential
!  ==================

   make_EP_grid(pot_grid,pt) ::: PURE
   ! Make the electric potential "pot_grid" on a series of points "pt"
      self :: IN
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      method :: STR

      method = "exact"

      ! The below is to avoid crashing if we are making an isosurface
      ! and .plot_grid is not created; then .isosurface.plot_grid will
      ! be automatically created if we are doing an isosurface. This
      ! is an ugly hack, hopefully temporary
      if(.isosurface.allocated) then
         method = .isosurface.plot_grid.electric_potential_method
      else if (.plot_grid.allocated) then
         method = .plot_grid.electric_potential_method
      end 

      select case (method)

      case("exact");
         if (trim(.density_mx.number_kind)=="real") then
            .GRID:make_EP_grid_r(pot_grid,pt,.density_mx.r)
         end

      ! These below are NOT PURE - dylan - fix!
    ! case("multipole")
    !    .GRID:make_multipole_EP_grid(pot_grid,pt)

    ! case("mixed")
    !    .GRID:make_mixed_EP_grid(pot_grid,pt)

    ! case("scm")
    !    .GRID:make_scm_EP_grid(pot_grid,pt)

    ! case default
    !    UNKNOWN(.plot_grid.electric_potential_method)

      end

   end


   make_multipole_EP_grid(pot_grid,pt) ::: PURE
   ! Make the electric potential "pot_grid" on a series of points "pt"
      self :: IN
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      ESP_grid :: VEC{REAL}@

      ESP_grid.create(pot_grid.dim)

      .INQ:nuclear_potential(pot_grid,pt)
      .GRID:make_multipole_ESP_grid_r(ESP_grid,pt)

      pot_grid = pot_grid + ESP_grid

      ESP_grid.destroy

   end


   make_mixed_EP_grid(grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(trim(.density_mx.number_kind)=="real", "must be a real density matrix")

      ESP_grid :: VEC{REAL}@

      ESP_grid.create(grid.dim)

      .INQ:nuclear_potential(grid,pt)
      .GRID:make_mixed_ESP_grid_r(ESP_grid,pt,.density_mx.r)

      grid = grid + ESP_grid

      ESP_grid.destroy

   end

   make_scm_EP_grid(grid,pt)
   ! Make the electric potential "grid" on a series of points "pt"
      self :: INOUT
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(trim(.density_mx.number_kind)=="real", "must be a real density matrix")

      ESP_grid :: VEC{REAL}@

      ESP_grid.create(grid.dim)

      .INQ:nuclear_potential(grid,pt)
      .GRID:make_scm_ESP_grid_r(ESP_grid,pt,.density_mx.r)

      grid = grid + ESP_grid

      ESP_grid.destroy

   end

   make_EP_grid_r(grid,pt,dens) ::: PURE
   ! Make the total electric potential "grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, IN

      ESP_grid :: VEC{REAL}@

      ESP_grid.create(grid.dim)

      .INQ:nuclear_potential(grid,pt)
      .GRID:make_electronic_pot_grid_r(ESP_grid,pt,dens)

      grid = grid + ESP_grid

      ESP_grid.destroy

   end


!  This is written twice!
!  As make_EP_grid

   make_electronic_pot_grid(pot_grid,pt) ::: PURE
   ! Make the electronic potential "pot_grid" on a series of points "pt"
      self :: IN
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      if (trim(.density_mx.number_kind)=="real") then
         .GRID:make_electronic_pot_grid_r(pot_grid,pt,.density_mx.r)
      end

   end

   make_electronic_pot_grid_r(grid,pt,dens) ::: PURE
   ! Make the electronic potential "grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      self :: IN
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      Vab :: MAT{REAL}@
      Dba :: MAT{REAL}@
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      grid = ZERO
      parallel do q = 1,.n_shell_pairs
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)
         Dba = dens(fa:la,fb:lb)
         Vab.create(na,nb)
         if (fa/=fb) then
            do k = 1,n_pt
                sh.get_nuc(Vab,ONE,pt(k,:))
                grid(k) = grid(k) - sum(Vab*Dba)*TWO
            end
         else
            do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)
            end
         end
         Vab.destroy
         if (DO_IN_PARALLEL) then
            PARALLEL_SUM(grid)
         end
      end

   end

!  ===============
!  Multipole stuff
!  ===============

   make_multipole_ESP_grid_r(grid,pt) ::: PURE
   ! Make the multipole ESP grid 
   ! potential "grid" on a series of grid points "pt" using AO density
   ! matrix "dens"
      self :: IN
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      q :: INT
      T :: T_TENSOR
      charges :: VEC{REAL}@
      dipoles, quadrupoles, octupoles :: MAT{REAL}@

      grid = ZERO

      charges.create(.n_atom)
      dipoles.create(.n_atom, 3)
      quadrupoles.create(.n_atom, 6)
      octupoles.create(.n_atom, 10)

      .GRID:make_atomic_multipoles(charges,dipoles,quadrupoles,octupoles,od=FALSE)

      parallel do q = 1, .n_atom
          T.electrostatic_potential_grid(charges(q),dipoles(q,:),quadrupoles(q,:),octupoles(q,:),&
                                         .atom(q).position,pt,grid)
      end

   end

   make_mixed_ESP_grid_r(grid,pt,dens)
   ! Make the multipole ESP grid (off diagonal) using the exact for
   ! the one center terms potential "grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      self :: IN
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      Vab :: MAT{REAL}@
      Dba :: MAT{REAL}@
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2
      T :: T_TENSOR
      charges :: VEC{REAL}@
      dipoles, quadrupoles, octupoles :: MAT{REAL}@
      V :: VEC{REAL}(4)

      n_pt = pt.dim1

      grid = ZERO
      charges.create(.n_atom)
      dipoles.create(.n_atom, 3)
      quadrupoles.create(.n_atom, 6)
      octupoles.create(.n_atom, 10)
      .atom.make_connection_table

      .GRID:make_atomic_multipoles(charges,dipoles,quadrupoles,octupoles,oc=TRUE)

      do q = 1, .n_atom
         do k = 1, n_pt
             T.create_fast(.atom(q).position, pt(k,:))
             V = T.electrostatic_potential(charges(q),dipoles(q,:),quadrupoles(q,:),octupoles(q,:))
             grid(k) = grid(k) - sum(V)
         end do
      end do

      parallel do q = 1,.n_shell_pairs

        .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

        if (VEC{ATOM}:has_a_connection(atom_a,atom_b) OR (atom_a == atom_b)) then

           Dba = dens(fa:la,fb:lb)
           Vab.create(na,nb)
           if (fa/=fb) then
              do k = 1,n_pt
                 sh.get_nuc(Vab,ONE,pt(k,:))
                 grid(k) = grid(k) - sum(Vab*Dba)*TWO
              end
           else
              do k = 1,n_pt
                 sh.get_nuc(Vab,ONE,pt(k,:))
                 grid(k) = grid(k) - sum(Vab*Dba)
              end
           end

           Vab.destroy

           if (DO_IN_PARALLEL) then
              PARALLEL_SUM(grid)
           end

        end

      end

   end

   make_scm_ESP_grid_r(grid,pt,dens)
   ! Make the multipole ESP grid (off diagonal) using the exact
   ! for the one center terms
   ! potential "grid" on a series of grid points "pt" using AO density
   ! matrix "dens"
      self :: INOUT
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      Vab :: MAT{REAL}@
      Dba :: MAT{REAL}@
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2
      T :: T_TENSOR
      charges :: VEC{REAL}@
      dipoles, quadrupoles, octupoles :: MAT{REAL}@
      V :: VEC{REAL}(4)

      n_pt = pt.dim1

      grid = ZERO
      charges.create(.n_atom)
      dipoles.create(.n_atom, 3)
      quadrupoles.create(.n_atom, 6)
      octupoles.create(.n_atom, 10)
      .atom.make_connection_table

      .GRID:make_atomic_multipoles(charges,dipoles,quadrupoles,octupoles,no_s=TRUE)

      do q = 1, .n_atom
         charges(q) = charges(q)
         do k = 1, n_pt
             T.create_fast(.atom(q).position, pt(k,:))
             V = T.electrostatic_potential(charges(q),dipoles(q,:),quadrupoles(q,:),octupoles(q,:))
             grid(k) = grid(k) - sum(V)
         end do
      end do

     parallel do q = 1,.n_shell_pairs

        .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

        if ((sh.a.l == 0) AND (sh.b.l == 0) AND atom_a == atom_b) then
           Dba = dens(fa:la,fb:lb)
           Vab.create(na,nb)
           if (fa/=fb) then
             do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)*TWO
             end
           else
             do k = 1,n_pt
               sh.get_nuc(Vab,ONE,pt(k,:))
               grid(k) = grid(k) - sum(Vab*Dba)
             end
           end
           Vab.destroy
           if (DO_IN_PARALLEL) then
              PARALLEL_SUM(grid)
           end
        end

     end

   end

   make_mixed_ESP_grid_r_v2(grid,pt,P) ::: PURE
   ! Make the multipole ESP grid (off diagonal) using the exact for
   ! the one center terms potential "grid" on a series of grid points
   ! "pt" using AO density matrix "P"
      self :: IN
      grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      P :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      VD :: VEC{EMAT3{REAL}}@
      Vab :: MAT{REAL}@
      Pba :: MAT{REAL}@
      P_max,tol, Va,Vb :: REAL
      n_pt,q,a,b,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2
    ! pole0 :: VEC{REAL}@
    ! pole2,pole4,pole8 :: MAT{REAL}@
    ! V :: VEC{REAL}(4)
    ! T :: T_TENSOR

      n_pt = pt.dim1

      grid = ZERO

      ! Make atomic multipoles
    ! pole0.create(.n_atom)
    ! pole2.create(.n_atom, 3)
    ! pole4.create(.n_atom, 6)
    ! pole8.create(.n_atom, 10)

    ! .GRID:make_atomic_multipoles(pole0,pole2,pole4,pole8,oc=TRUE)

    ! ! Make mutipole potential
    ! do q = 1, .n_atom
    ! do k = 1, n_pt
    !    T.create_fast(.atom(q).position, pt(k,:))
    !    V = T.electrostatic_potential(pole0(q),pole2(q,:),pole4(q,:),pole8(q,:))
    !    grid(k) = grid(k) - sum(V)
    ! end do
    ! end do

    ! pole8.destroy
    ! pole4.destroy
    ! pole2.destroy
    ! pole0.destroy

      ! Diagonal blocks for schwarz test
      .GRID:make_diagonal_block_V_ints(VD,pt)

      ! Schwarz test tolerance
      tol = TOL(6)

      ! Make exact potential
      parallel do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,a,fa,la,na,b,fb,lb,nb,atom_a,atom_b)

         ! Density matrix
         Pba = P(fa:la,fb:lb)
         P_max = maxval(abs(Pba))

         if (fa==fb) then

            ! Do basis-fn diagonal exactly
            do k = 1,n_pt
               grid(k) = grid(k) - sum(VD(a).element(:,:,k)*Pba)
            end

         else if (P_max>tol) then
            
            ! Schwarz test for off diagonals & large P's
            allocate(Vab(na,nb))
            do k = 1,n_pt
               Va = sqrt(maxval(abs(VD(a).element(:,:,k))))
               Vb = sqrt(maxval(abs(VD(b).element(:,:,k))))
               if (P_max*Va*Vb > tol) then
                  sh.get_nuc(Vab,ZERO,pt(k,:))
                  grid(k) = grid(k) - sum(Vab*Pba)*TWO
               end
            end
            deallocate(Vab)

         end

      end
            
      ! Clean
      VD.destroy

      ! Reduce
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(grid)
      end

   end

   make_diagonal_block_V_ints(V,pt) ::: private, leaky, PURE
   ! Make "V" the diagonal block nuclear attraction integrals 
   ! (a| |r_k - r|^-1 |a) over a shell q, a in q, for each 
   ! point r_k = "pt(k,1:3)".
      self :: IN
      V :: VEC{EMAT3{REAL}}@, OUT
      pt :: MAT{REAL}, IN

   ENSURE(3==pt.dim2,"wrong dim2, pt")

      n_pt,q,a,b,fa,fb,la,lb,na,nb,k :: INT
      atom_a,atom_b :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      V.create(.n_shell)

      parallel do q = 1,.n_shell_pairs
         .SET:set_shell2_from(q,sh,a,fa,la,na,b,fb,lb,nb,atom_a,atom_b)
         if (a==b) then
            V(a).element.create(na,na,n_pt)
            do k = 1,n_pt
               sh.get_nuc(V(a).element(:,:,k),ZERO,pt(k,:))
            end
         end
      end

   end

   make_atomic_multipoles(od,oc,no_s) ::: leaky
   ! Make the atomic multipoles using the tanaka partitioing
      self :: INOUT
      od, oc, no_s :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no restricted density_mx")
   ENSURE(NOT .use_spherical_basis,"not implememnted for spherical")

      off_diagonal,only_disconnected, no_s_functions :: BIN
      S,Sa,Sb,part :: MAT{REAL}@
      Ax,Ay,Az :: MAT{REAL}@
      Bx,By,Bz :: MAT{REAL}@
      Axx, Ayy, Azz, Axy, Axz, Ayz :: MAT{REAL}@
      Bxx, Byy, Bzz, Bxy, Bxz, Byz :: MAT{REAL}@
      Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz :: MAT{REAL}@
      Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz :: MAT{REAL}@
      q,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT
      sh :: SHELL2
      fac :: REAL

      off_diagonal = FALSE
      only_disconnected = FALSE
      no_s_functions = FALSE
      if (present(od)) off_diagonal = od
      if (present(oc)) only_disconnected = oc
      if (present(no_s)) no_s_functions = no_s

      .charges.create(.n_atom)
      .dipoles.create(.n_atom, 3)
      .quadrupoles.create(.n_atom, 6)
      .octupoles.create(.n_atom, 10)
  
      .charges     = ZERO
      .dipoles     = ZERO
      .quadrupoles = ZERO
      .octupoles   = ZERO

      do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (atom_a==atom_b) then

            if (no_s_functions AND sh.a.l == 0 AND sh.b.l == 0) cycle
            if (off_diagonal) cycle
            if (only_disconnected) cycle

            fac = TWO
            if (fa==fb) fac=ONE

            S.create(na,nb)
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)

            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 

            sh.make_overlap_ints(S)
            sh.make_dipole_ints(Ax,Ay,Az,sh.a.position)
            sh.make_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz,sh.a.position)
            sh.make_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz,sh.a.position)

            .charges(atom_a)       = .charges(atom_a)       + fac*sum(S*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,1)     = .dipoles(atom_a,1)     + fac*sum(Ax*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,2)     = .dipoles(atom_a,2)     + fac*sum(Ay*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,3)     = .dipoles(atom_a,3)     + fac*sum(Az*.density_mx.r(fa:la,fb:lb))

            .quadrupoles(atom_a,1) = .quadrupoles(atom_a,1) + fac*sum(Axx*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,2) = .quadrupoles(atom_a,2) + fac*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,3) = .quadrupoles(atom_a,3) + fac*sum(Azz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,4) = .quadrupoles(atom_a,4) + fac*sum(Axy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,5) = .quadrupoles(atom_a,5) + fac*sum(Axz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,6) = .quadrupoles(atom_a,6) + fac*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            .octupoles(atom_a, 1)  = .octupoles(atom_a, 1)  + fac*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 2)  = .octupoles(atom_a, 2)  + fac*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 3)  = .octupoles(atom_a, 3)  + fac*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 4)  = .octupoles(atom_a, 4)  + fac*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 5)  = .octupoles(atom_a, 5)  + fac*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 6)  = .octupoles(atom_a, 6)  + fac*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 7)  = .octupoles(atom_a, 7)  + fac*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 8)  = .octupoles(atom_a, 8)  + fac*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 9)  = .octupoles(atom_a, 9)  + fac*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a,10)  = .octupoles(atom_a,10)  + fac*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            S.destroy
            Ax.destroy; Ay.destroy; Az.destroy
            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 

         else

            if (only_disconnected) then
               if (VEC{ATOM}:has_a_connection(atom_a,atom_b)) cycle
            end

            ! Partition factors
            part.create(sh.a.n_cc,sh.b.n_cc)
            sh.make_KM_partition(part)

            ! Get weighted overlap integrals
            Sa.create(na,nb); Sb.create(na,nb)

            sh.make_weighted_overlap_ints(Sa,Sb,part)

            .charges(atom_a) = .charges(atom_a) + TWO*sum(Sa*.density_mx.r(fa:la,fb:lb))
            .charges(atom_b) = .charges(atom_b) + TWO*sum(Sb*.density_mx.r(fa:la,fb:lb))

            Sb.destroy; Sa.destroy

            ! .dipoless
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Bx.create(na,nb); By.create(na,nb); Bz.create(na,nb)

            sh.make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz,part)

            .dipoles(atom_a,1) = .dipoles(atom_a,1) + TWO*sum(Ax*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,2) = .dipoles(atom_a,2) + TWO*sum(Ay*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,3) = .dipoles(atom_a,3) + TWO*sum(Az*.density_mx.r(fa:la,fb:lb))

            .dipoles(atom_b,1) = .dipoles(atom_b,1) + TWO*sum(Bx*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_b,2) = .dipoles(atom_b,2) + TWO*sum(By*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_b,3) = .dipoles(atom_b,3) + TWO*sum(Bz*.density_mx.r(fa:la,fb:lb))

            Ax.destroy; Ay.destroy; Az.destroy
            Bx.destroy; By.destroy; Bz.destroy

            ! .quadrupoless
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)
            Bxx.create(na,nb); Byy.create(na,nb); Bzz.create(na,nb)
            Bxy.create(na,nb); Bxz.create(na,nb); Byz.create(na,nb)

            sh.make_weighted_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz &
                                            ,Bxx,Byy,Bzz,Bxy,Bxz,Byz, part)

            .quadrupoles(atom_a,1) = .quadrupoles(atom_a,1) + TWO*sum(Axx*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,2) = .quadrupoles(atom_a,2) + TWO*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,3) = .quadrupoles(atom_a,3) + TWO*sum(Azz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,4) = .quadrupoles(atom_a,4) + TWO*sum(Axy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,5) = .quadrupoles(atom_a,5) + TWO*sum(Axz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,6) = .quadrupoles(atom_a,6) + TWO*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            .quadrupoles(atom_b,1) = .quadrupoles(atom_b,1) + TWO*sum(Bxx*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,2) = .quadrupoles(atom_b,2) + TWO*sum(Byy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,3) = .quadrupoles(atom_b,3) + TWO*sum(Bzz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,4) = .quadrupoles(atom_b,4) + TWO*sum(Bxy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,5) = .quadrupoles(atom_b,5) + TWO*sum(Bxz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,6) = .quadrupoles(atom_b,6) + TWO*sum(Byz*.density_mx.r(fa:la,fb:lb))

            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy
            Bxx.destroy; Byy.destroy; Bzz.destroy
            Bxy.destroy; Bxz.destroy; Byz.destroy

            ! .octupoless
            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 
            Bxxx.create(na,nb); Byyy.create(na,nb); Bzzz.create(na,nb)
            Bxxy.create(na,nb); Bxxz.create(na,nb); Byyx.create(na,nb)
            Byyz.create(na,nb); Bzzx.create(na,nb); Bzzy.create(na,nb)
            Bxyz.create(na,nb); 

            sh.make_weighted_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz & 
                                          ,Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz,part)

            .octupoles(atom_a, 1) = .octupoles(atom_a, 1) + TWO*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 2) = .octupoles(atom_a, 2) + TWO*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 3) = .octupoles(atom_a, 3) + TWO*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 4) = .octupoles(atom_a, 4) + TWO*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 5) = .octupoles(atom_a, 5) + TWO*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 6) = .octupoles(atom_a, 6) + TWO*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 7) = .octupoles(atom_a, 7) + TWO*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 8) = .octupoles(atom_a, 8) + TWO*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 9) = .octupoles(atom_a, 9) + TWO*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a,10) = .octupoles(atom_a,10) + TWO*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            .octupoles(atom_b, 1) = .octupoles(atom_b, 1) + TWO*sum(Bxxx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 2) = .octupoles(atom_b, 2) + TWO*sum(Byyy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 3) = .octupoles(atom_b, 3) + TWO*sum(Bzzz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 4) = .octupoles(atom_b, 4) + TWO*sum(Bxxy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 5) = .octupoles(atom_b, 5) + TWO*sum(Bxxz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 6) = .octupoles(atom_b, 6) + TWO*sum(Byyx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 7) = .octupoles(atom_b, 7) + TWO*sum(Byyz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 8) = .octupoles(atom_b, 8) + TWO*sum(Bzzx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 9) = .octupoles(atom_b, 9) + TWO*sum(Bzzy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b,10) = .octupoles(atom_b,10) + TWO*sum(Bxyz*.density_mx.r(fa:la,fb:lb))

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 
            Bxxx.destroy; Byyy.destroy; Bzzz.destroy
            Bxxy.destroy; Bxxz.destroy; Byyx.destroy
            Byyz.destroy; Bzzx.destroy; Bzzy.destroy
            Bxyz.destroy; 

            part.destroy

         end

      end

      ! Electron .charges
      .dipoles     = -ONE * .dipoles
      .quadrupoles = -ONE * .quadrupoles
      .octupoles   = -ONE * .octupoles

   end

   make_atomic_multipoles(charge,dipole,quadrupole,octupole,od,oc,no_s) ::: PURE
   ! Make the atomic multipoles using the tanaka partitioing
      self :: IN
      charge :: VEC{REAL}, OUT
      dipole, quadrupole, octupole :: MAT{REAL}, OUT
      od, oc, no_s :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no restricted density_mx")
   ENSURE(NOT .use_spherical_basis,"not implememnted for spherical")

      off_diagonal,only_disconnected, no_s_functions :: BIN
      S,Sa,Sb,part :: MAT{REAL}@
      Ax,Ay,Az :: MAT{REAL}@
      Bx,By,Bz :: MAT{REAL}@
      Axx,Ayy,Azz,Axy,Axz,Ayz :: MAT{REAL}@
      Bxx,Byy,Bzz,Bxy,Bxz,Byz :: MAT{REAL}@
      Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz :: MAT{REAL}@
      Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz :: MAT{REAL}@
      q,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT
      sh :: SHELL2
      fac :: REAL

      off_diagonal = FALSE
      only_disconnected = FALSE
      no_s_functions = FALSE
      if (present(od)) off_diagonal = od
      if (present(oc)) only_disconnected = oc
      if (present(no_s)) no_s_functions = no_s

      
      charge     = ZERO
      dipole     = ZERO
      quadrupole = ZERO
      octupole   = ZERO

      do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (atom_a==atom_b) then

            if (no_s_functions AND sh.a.l == 0 AND sh.b.l == 0) cycle
            if (off_diagonal) cycle
            if (only_disconnected) cycle

            fac = TWO
            if (fa==fb) fac=ONE

            S.create(na,nb)
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)

            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 

            sh.make_overlap_ints(S)
            sh.make_dipole_ints(Ax,Ay,Az,sh.a.position)
            sh.make_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz,sh.a.position)
            sh.make_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz,sh.a.position)

            charge(atom_a)       = charge(atom_a)       + fac*sum(S*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,1)     = dipole(atom_a,1)     + fac*sum(Ax*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,2)     = dipole(atom_a,2)     + fac*sum(Ay*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,3)     = dipole(atom_a,3)     + fac*sum(Az*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,1) = quadrupole(atom_a,1) + fac*sum(Axx*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,2) = quadrupole(atom_a,2) + fac*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,3) = quadrupole(atom_a,3) + fac*sum(Azz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,4) = quadrupole(atom_a,4) + fac*sum(Axy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,5) = quadrupole(atom_a,5) + fac*sum(Axz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,6) = quadrupole(atom_a,6) + fac*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            octupole(atom_a, 1)  = octupole(atom_a, 1)  + fac*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 2)  = octupole(atom_a, 2)  + fac*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 3)  = octupole(atom_a, 3)  + fac*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 4)  = octupole(atom_a, 4)  + fac*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 5)  = octupole(atom_a, 5)  + fac*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 6)  = octupole(atom_a, 6)  + fac*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 7)  = octupole(atom_a, 7)  + fac*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 8)  = octupole(atom_a, 8)  + fac*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 9)  = octupole(atom_a, 9)  + fac*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a,10)  = octupole(atom_a,10)  + fac*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            S.destroy
            Ax.destroy; Ay.destroy; Az.destroy
            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy

         else

            if (only_disconnected) then
               if (VEC{ATOM}:has_a_connection(atom_a,atom_b)) cycle
            end

            ! Partition factors
            part.create(sh.a.n_cc,sh.b.n_cc)
            sh.make_KM_partition(part)

            ! Get weighted overlap integrals
            Sa.create(na,nb); Sb.create(na,nb)

            sh.make_weighted_overlap_ints(Sa,Sb,part)

            charge(atom_a) = charge(atom_a) + TWO*sum(Sa*.density_mx.r(fa:la,fb:lb))
            charge(atom_b) = charge(atom_b) + TWO*sum(Sb*.density_mx.r(fa:la,fb:lb))

            Sb.destroy; Sa.destroy

            ! Dipoles
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Bx.create(na,nb); By.create(na,nb); Bz.create(na,nb)

            sh.make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz,part)

            dipole(atom_a,1) = dipole(atom_a,1) + TWO*sum(Ax*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,2) = dipole(atom_a,2) + TWO*sum(Ay*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,3) = dipole(atom_a,3) + TWO*sum(Az*.density_mx.r(fa:la,fb:lb))

            dipole(atom_b,1) = dipole(atom_b,1) + TWO*sum(Bx*.density_mx.r(fa:la,fb:lb))
            dipole(atom_b,2) = dipole(atom_b,2) + TWO*sum(By*.density_mx.r(fa:la,fb:lb))
            dipole(atom_b,3) = dipole(atom_b,3) + TWO*sum(Bz*.density_mx.r(fa:la,fb:lb))

            Ax.destroy; Ay.destroy; Az.destroy
            Bx.destroy; By.destroy; Bz.destroy

            ! Quadrupoles
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)
            Bxx.create(na,nb); Byy.create(na,nb); Bzz.create(na,nb)
            Bxy.create(na,nb); Bxz.create(na,nb); Byz.create(na,nb)

            sh.make_weighted_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz &
                                            ,Bxx,Byy,Bzz,Bxy,Bxz,Byz, part)

            quadrupole(atom_a,1) = quadrupole(atom_a,1) + TWO*sum(Axx*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,2) = quadrupole(atom_a,2) + TWO*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,3) = quadrupole(atom_a,3) + TWO*sum(Azz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,4) = quadrupole(atom_a,4) + TWO*sum(Axy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,5) = quadrupole(atom_a,5) + TWO*sum(Axz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,6) = quadrupole(atom_a,6) + TWO*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            quadrupole(atom_b,1) = quadrupole(atom_b,1) + TWO*sum(Bxx*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,2) = quadrupole(atom_b,2) + TWO*sum(Byy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,3) = quadrupole(atom_b,3) + TWO*sum(Bzz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,4) = quadrupole(atom_b,4) + TWO*sum(Bxy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,5) = quadrupole(atom_b,5) + TWO*sum(Bxz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,6) = quadrupole(atom_b,6) + TWO*sum(Byz*.density_mx.r(fa:la,fb:lb))

            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy
            Bxx.destroy; Byy.destroy; Bzz.destroy
            Bxy.destroy; Bxz.destroy; Byz.destroy

            ! Octupoles
            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 
            Bxxx.create(na,nb); Byyy.create(na,nb); Bzzz.create(na,nb)
            Bxxy.create(na,nb); Bxxz.create(na,nb); Byyx.create(na,nb)
            Byyz.create(na,nb); Bzzx.create(na,nb); Bzzy.create(na,nb)
            Bxyz.create(na,nb); 

            sh.make_weighted_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz & 
                                          ,Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz,part)

            octupole(atom_a, 1) = octupole(atom_a, 1) + TWO*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 2) = octupole(atom_a, 2) + TWO*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 3) = octupole(atom_a, 3) + TWO*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 4) = octupole(atom_a, 4) + TWO*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 5) = octupole(atom_a, 5) + TWO*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 6) = octupole(atom_a, 6) + TWO*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 7) = octupole(atom_a, 7) + TWO*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 8) = octupole(atom_a, 8) + TWO*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 9) = octupole(atom_a, 9) + TWO*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a,10) = octupole(atom_a,10) + TWO*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            octupole(atom_b, 1) = octupole(atom_b, 1) + TWO*sum(Bxxx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 2) = octupole(atom_b, 2) + TWO*sum(Byyy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 3) = octupole(atom_b, 3) + TWO*sum(Bzzz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 4) = octupole(atom_b, 4) + TWO*sum(Bxxy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 5) = octupole(atom_b, 5) + TWO*sum(Bxxz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 6) = octupole(atom_b, 6) + TWO*sum(Byyx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 7) = octupole(atom_b, 7) + TWO*sum(Byyz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 8) = octupole(atom_b, 8) + TWO*sum(Bzzx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 9) = octupole(atom_b, 9) + TWO*sum(Bzzy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b,10) = octupole(atom_b,10) + TWO*sum(Bxyz*.density_mx.r(fa:la,fb:lb))

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 
            Bxxx.destroy; Byyy.destroy; Bzzz.destroy
            Bxxy.destroy; Bxxz.destroy; Byyx.destroy
            Byyz.destroy; Bzzx.destroy; Bzzy.destroy
            Bxyz.destroy; 

            part.destroy

         end

      end

      ! Electron charge
      dipole     = -ONE * dipole
      quadrupole = -ONE * quadrupole
      octupole   = -ONE * octupole

   end



   make_def_e_pot_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_EP_grid, PRO?=>:make_pro_e_pot_grid)
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_e_pot_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_EP_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end

!  ==========================================
!  ESPs from center and surrounding molecules
!  ===========================================

   make_the_center_ESP_grid(grid,pt) ::: PURE
   ! Make the central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      if (trim(.density_mx.number_kind)=="real") then
         .GRID:make_the_center_ESP_grid_r(grid,pt)
      end

   end

   make_the_center_ESP_grid_r(grid,pt) ::: PURE
   ! Make the central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.mol(1).density_mx.allocated ,"no mol 1 DM!")
   ENSURE(.mol(2).density_mx.allocated ,"no mol 2 DM!")

      ! ESP for central molecule
      .mol(1).GRID:make_EP_grid(grid,pt)

   end


   make_non_center_ESP_grid(grid,pt) ::: PURE
   ! Make the non-central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      if (trim(.density_mx.number_kind)=="real") then
         .GRID:make_non_center_ESP_grid_r(grid,pt)
      end

   end

   make_non_center_ESP_grid_r(grid,pt) ::: PURE
   ! Make the non-central neighboring-molecule ESP "grid",
   ! i.e. for atom groups>1, on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.mol(1).density_mx.allocated ,"no mol 1 DM!")
   ENSURE(.mol(2).density_mx.allocated ,"no mol 2 DM!")

      ESP :: VEC{REAL}@
      m :: INT

      ESP.create(grid.dim)
      grid = ZERO

      ! Loop over non-central molecules
      do m = 2,.atom_group.dim
         ! Make ESP for molecule m
         .mol(m).GRID:make_EP_grid(ESP,pt)
         grid = grid + ESP
      end

      ESP.destroy

   end

!  ==========================================
!  Product of ESPs from surrounding molecules
!  ==========================================

   make_product_ESP_grid(grid,pt) ::: PURE
   ! Make the product of the central and  neighboring-molecule
   ! ESP "grid", on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .GRID:make_product_ESP_grid_r(grid,pt)

   end

   make_product_ESP_grid_r(grid,pt) ::: PURE
   ! Make the product of the central and  neighboring-molecule
   ! ESP "grid", on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.mol(1).density_mx.allocated ,"no mol 1 DM!")
   ENSURE(.mol(2).density_mx.allocated ,"no mol 2 DM!")

      ESP :: VEC{REAL}@
      m :: INT

      ESP.create(grid.dim)

      ! Loop over non-central molecules
      grid = ZERO
      do m = 2,.atom_group.dim
         ! Make ESP for molecule m
         .mol(m).GRID:make_EP_grid(ESP,pt)
         grid = grid + ESP
      end

      ! Central molecule ESP
      .mol(1).GRID:make_EP_grid(ESP,pt)

      ! Make product
      grid = grid*ESP

      ESP.destroy

   end


   make_group_product_ESP_grid(grid,pt) ::: PURE
   ! Make the product of the central and all neighboring-molecule
   ! ESP "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .GRID:make_group_product_ESP_grid_r(grid,pt)

   end

   make_group_product_ESP_grid_r(grid,pt) ::: PURE
   ! Make the product of the central and all neighboring-molecule
   ! ESP "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
   ! This is for surface properties only, not isosurfaces!
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(.isosurface.allocated,"no isosurface")

      list :: VEC{EVEC{INT}}@
      ESP :: VEC{REAL}@
      ptg :: MAT{REAL}@
      g :: INT

      list.create(pt.dim2)
      .isosurface.make_pts_list_for_group(list)

      grid = ZERO

      ! Loop over non-central molecules
      do g = 2,.atom_group.dim

         if (list(g).element.dim==0) cycle

         ! Get the fragment g patch
         ptg = pt(list(g).element,:)

         ! Make ESP on patch g for molecule m
         ESP.create(list(g).element.dim)
         .mol(g).GRID:make_EP_grid(ESP,ptg)
         grid(list(g)[:]) = ESP

         ! Clean
         ESP.destroy
         ptg.destroy

      end

      ! Central molecule ESP; use all points pt
      ESP.create(pt.dim)
      .mol(1).GRID:make_EP_grid(ESP,pt)

      ! Make product
      grid = grid*ESP

      ! Clean
      ESP.destroy
      list.destroy

   end

!  ==========================================
!  Product E field grid surrounding molecules
!  ==========================================

   make_product_E_field_grid(grid,pt) ::: PURE
   ! Make the product of the central and neighboring-molecule
   ! E fields in "grid", on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt   :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .GRID:make_product_E_field_grid_r(grid,pt)

   end

   make_product_E_field_grid_r(grid,pt) ::: PURE
   ! Make the product of the central and neighboring-molecule
   ! densities and ESPs on "grid", on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(.atom_group.dim>=2 ,"must have more than 2 groups")
   ENSURE(.mol(1).density_mx.allocated ,"no mol 1 DM!")
   ENSURE(.mol(2).density_mx.allocated ,"no mol 2 DM!")

      E1,E2 :: MAT{REAL}@
      m,n_pt :: INT

      n_pt = grid.dim

      ! E fields for first and surrounding molecules
      E1.create(n_pt,3)
      E2.create(n_pt,3)

      ! Loop over non-central molecules
      E2 = ZERO
      do m = 2,.atom_group.dim
         ! Make E field for molecules m>2
         .mol(m).GRID:make_E_field_grid(E1,pt)
         E2 = E2 + E1
      end

      ! Central molecule E-field
      .mol(1).GRID:make_E_field_grid(E1,pt)

      ! Product of E fields
      grid = E1(:,1)*E2(:,1) + E1(:,2)*E2(:,2) + E1(:,3)*E2(:,3)

      ! Clean
      E2.destroy
      E1.destroy

   end


   make_group_product_E_field_grid(grid,pt) ::: PURE
   ! Make the product of the central and neighboring-molecule
   ! E fields in "grid", on a series of points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")

      .GRID:make_group_product_E_field_grid_r(grid,pt)

   end

   make_group_product_E_field_grid_r(grid,pt) ::: PURE
   ! Make the product of the central and all neighboring-molecule
   ! E-field "grid"s, pairwise on each fragment patch, on a series of
   ! points "pt". The points are divided into fragment patches first.
   ! This is for surface properties only, not isosurfaces!
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(.isosurface.allocated,"no isosurface")

      list :: VEC{EVEC{INT}}@
      E1,E2 :: MAT{REAL}@
      ptg :: MAT{REAL}@
      g,n_pt :: INT

      n_pt = grid.dim

      list.create(n_pt)
      .isosurface.make_pts_list_for_group(list)

      ! E fields for surrounding molecules
      allocate(E2(n_pt,3))
      E2 = ZERO

      ! Loop over non-central molecules
      do g = 2,.atom_group.dim

         ! Get the fragment g patch
         ptg = pt(:,list(g).element)

         ! Make ESP on patch g for molecule m
         allocate(E1(list(g).element.dim,3))
         .mol(g).GRID:make_E_field_grid(E1,ptg)
         E2(list(g)[:],:) = E1

         ! Clean
         deallocate(E1)
         ptg.destroy

      end

      ! Central molecule E-field; use all points pt
      allocate(E1(n_pt,3))
      .mol(1).GRID:make_E_field_grid(E1,pt)

      ! Product of E fields
      grid = E1(:,1)*E2(:,1) + E1(:,2)*E2(:,2) + E1(:,3)*E2(:,3)

      ! Clean
      deallocate(E1)
      deallocate(E2)
      list.destroy

   end

!  ================
!  DFT xc potential
!  ================

   make_DFT_xc_pot_grid(V,pt) ::: PURE
   ! Work out the DFT potential on ".plot_grid" using ".natural orbitals" and the
   ! ".NO_occ_nos" vector.
      self :: IN
      V  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}@
      grad_rho :: MAT{REAL}@
      Vx, Vy, Vz :: VEC{REAL}@
      exch, corr :: STR
      is_GGA :: BIN

      rho.create(V.dim)
      grad_rho.create(V.dim, 3)

      .GRID:make_ED_grid(rho,pt)

      V = ZERO
      dft.set_defaults

      exch = .scfdata.DFT_exchange_functional
      corr = .scfdata.DFT_correlation_functional
      is_GGA = dft.is_GGA_functional(exch)
      is_GGA = is_GGA OR dft.is_GGA_functional(corr)

      if (is_GGA) then
         .GRID:make_nabla_density_grid(grad_rho,pt)
         Vx.create(V.dim)
         Vy.create(V.dim)
         Vz.create(V.dim)
         dft.new_r_potential(exch,V,rho,Vx,Vy,Vz,grad_rho(:,1),grad_rho(:,2),grad_rho(:, 3))
         dft.new_r_potential(corr,V,rho,Vx,Vy,Vz,grad_rho(:,1),grad_rho(:,2),grad_rho(:, 3))
         grad_rho.destroy
         Vx.destroy
         Vy.destroy
         Vz.destroy
      else
         dft.new_r_potential(exch,V,rho)
         dft.new_r_potential(corr,V,rho)
      end

      
      rho.destroy

   end


   make_def_DFT_xc_pot_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_DFT_xc_pot_grid, PRO?=>:make_pro_DFT_xc_pot_grid), PURE
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_DFT_xc_pot_grid(density_grid,pt) ::: get_from(pro_DFT_grid, GRID?=>make_DFT_xc_pot_grid), PURE
   ! Return promolecule DFT "density_grid" from supplied points "pt".
   end

!  =======================
!  DFT effective potential
!  =======================

! The effective potential includes the classical electrostatic potential

   make_DFT_eff_pot_grid(V,pt) ::: PURE
   ! Work out the Slater DFT potential "V" (i.e. the Slater potential plus the
   ! classical electric potential) on a grid of points "pt".
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
   ENSURE(NOT .scfdata.using_GGA_functional,"so far, must not be a GGA functional")

      dft :: DFT_FUNCTIONAL
      exch,corr :: STR
      rho :: VEC{REAL}@

      rho.create(V.dim)

      .GRID:make_EP_grid(V,pt)
      .GRID:make_ED_grid(rho,pt)

      exch = .scfdata.DFT_exchange_functional
      corr = .scfdata.DFT_correlation_functional

      dft.set_defaults
      dft.new_r_potential(exch,V,rho)
      dft.new_r_potential(corr,V,rho)

      rho.destroy

   end


   make_def_DFT_eff_pot_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_DFT_eff_pot_grid, PRO?=>:make_pro_DFT_eff_pot_grid), PURE
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_DFT_eff_pot_grid(density_grid,pt) ::: get_from(pro_DFT_grid, GRID?=>make_DFT_eff_pot_grid), PURE
   ! Return promolecule DFT "density_grid" from supplied points "pt".
   end

!  ==================
!  DFT energy density
!  ==================

! The energy density includes the classical electrostatic potential, but no
! kinetic energy density terms

   make_DFT_energy_grid(V,pt) ::: PURE
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      self :: IN
      V :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      dft :: DFT_FUNCTIONAL
      exch,corr :: STR
      Ve,rho :: VEC{REAL}@

      Ve.create(V.dim)
      rho.create(V.dim)

      .INQ:nuclear_potential(V,pt)
      .GRID:make_electronic_pot_grid(Ve,pt)
      V = -V - HALF*Ve
      .GRID:make_ED_grid(rho,pt)

      exch = .scfdata.DFT_exchange_functional
      corr = .scfdata.DFT_correlation_functional

      dft.set_defaults
      dft.new_r_energy_density(exch,V,rho)
      dft.new_r_energy_density(corr,V,rho)
      V = V*rho

      Ve.destroy
      rho.destroy

   end


   make_def_DFT_energy_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_DFT_energy_grid, PRO?=>:make_pro_DFT_energy_grid), PURE
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_DFT_energy_grid(density_grid,pt) ::: get_from(pro_DFT_grid, GRID?=>make_DFT_energy_grid), PURE
   ! Return promolecule DFT "density_grid" from supplied points "pt".
   end


!  =========================
!  H-type DFT energy density
!  =========================

! H = G + V(DFT)

   make_H_DFT_energy_grid(H_grid,pt) ::: PURE
   ! Work out the property density on ".plot_grid" using ".natural
   ! orbitals" and the ".NO_occ_nos" vector. A Gnuplot ascii
   ! file is generated.
      self :: IN
      H_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"must be a DFT calculation")

      G_grid :: VEC{REAL}@

      G_grid.create(.plot_grid.n_pt)

      .GRID:make_G_kinetic_energy_grid(G_grid,pt)
      .GRID:make_DFT_energy_grid(H_grid,pt)

      H_grid = H_grid + G_grid

      G_grid.destroy

   end



   make_def_H_DFT_energy_grid(grid,pt) ::: get_from(def_grid, GRID?=>:make_H_DFT_energy_grid, PRO?=>:make_pro_H_DFT_energy_grid), PURE
   ! Make deformation density "grid" on a set of points "pt".
   end

   make_pro_H_DFT_energy_grid(density_grid,pt) ::: get_from(pro_DFT_grid, GRID?=>make_H_DFT_energy_grid), PURE
   ! Return promolecule DFT "density_grid" from supplied points "pt".
   end

!  =======================
!  Hirshfeld (slater) grid
!  =======================

! This is the fast one

   make_Hirshfeld_density_grid(density_grid,pt) ::: PURE
   ! WARNING: this version calls directly the interpolated slaterbasis
   ! routine.  Make the Hirshfeld stockholder "density_grid" for the
   ! supplied points "pt". The promolecule electron density used to
   ! define the Hirshfeld surface is calculated using a tabulated
   ! slater basis set.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

!  ENSURE(.saved.allocated, "no saved molecule")
!  ENSURE(.saved.cluster.allocated, "no saved cluster data")
!  ENSURE(.saved.cluster.info_made, "no saved cluster info")
!  ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
!  ENSURE(.saved.cluster.n_atoms==.atom.dim,"inconsistent saved cluster and atom list")
!  ENSURE(.atom.allocated,"no atoms")
!  ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}@
      is_fragment_atom :: VEC{BIN}@
      n_atoms,n_pt,a :: INT

      n_pt = density_grid.dim
      n_atoms = .atom.dim

      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      is_fragment_atom = .saved.cluster.is_fragment_atom
      
      if (NOT .atom.has_disorder) then
         do a = 1,n_atoms
            if (NOT is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_ED_grid(rho_fragment,pt,.atom(a).position)
         end
         density_grid = rho_fragment
         do a = 1,n_atoms
            if (is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_ED_grid(density_grid,pt,.atom(a).position)
         end
      else
         do a = 1,n_atoms
            if (NOT is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_ED_grid(rho_fragment,pt,.atom(a).position,.atom(a).site_occupancy)
         end
         density_grid = rho_fragment
         do a = 1,n_atoms
            if (is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_ED_grid(density_grid,pt,.atom(a).position,.atom(a).site_occupancy)
         end
      end

      where (density_grid>ZERO)
         density_grid = rho_fragment/density_grid
      elsewhere
         density_grid = ZERO
      end

      rho_fragment.destroy

   end

!  ===========
!  Stockholder
!  ===========

   make_stockholder_density_grid(density_grid,pt) ::: PURE
   ! Make the Hirschfeld stockholder "density_grid" for the supplied
   ! points "pt". The promolecule electron density used to define the
   ! Hirshfeld surface is calculated as follows: if a slater basis set
   ! is available, then that is used to calculate the promolecule
   ! electron density; if a coppens basis set is available, then that
   ! is used to get the promolecule density; otherwise, if restricted
   ! real natural orbitals are available for all atoms (in terms of
   ! gaussian basis functions), then those are used to calculate the
   ! promolecule densisties. In principle, we can caculate Hirshfeld
   ! surfaces for *molecular* fragment densities, rather than
   ! promolecule densities as done here. That would require a
   ! different keyword and different code.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.saved.allocated, "no saved molecule")
   ENSURE(.saved.cluster.allocated, "no saved cluster data")
   ENSURE(.saved.cluster.info_made, "no saved cluster info")
   ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
   ENSURE(.saved.cluster.n_atoms==.atom.dim,"saved cluster/=atom list")
   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}@
      is_fragment_atom :: VEC{BIN}@
      n_atoms,n_pt,a :: INT

      n_atoms = .atom.dim
      n_pt = density_grid.dim

      ! Locate fragment atoms in cluster
      is_fragment_atom = .saved.cluster.is_fragment_atom

      ! Fragment density grid
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      ! Make fragment density
      do a = 1,n_atoms
         if (NOT is_fragment_atom(a)) cycle
         .atom(a).add_ED_grid(rho_fragment,pt)
      end

      density_grid = rho_fragment
      do a = 1,n_atoms
         if (is_fragment_atom(a)) cycle
         .atom(a).add_ED_grid(density_grid,pt)
      end

      ! density_grid = rho_fragment/density_grid
      do a = 1,size(density_grid)
         if (density_grid(a)>epsilon(ONE)) then
            density_grid(a) = rho_fragment(a)/density_grid(a)
         else
            density_grid(a) = ZERO
         end
      end

      ! Clean up
      rho_fragment.destroy

   end

!   make_stockholder_weight_d_grid(w0,w1,w2,pt)
!   ! Make the Hirschfeld stockholder derivative density grid "d1_grid"
!   ! for the supplied points "pt". The promolecule electron density
!   ! used to define the Hirshfeld surface is calculated as follows: if
!   ! a slater basis set is available, then that is used to calculate
!   ! the promolecule electron density; if a coppens basis set is
!   ! available, then that is used to get the promolecule density;
!   ! otherwise, if restricted real natural orbitals are available for
!   ! all atoms (in terms of gaussian basis functions), then those are
!   ! used to calculate the promolecule densisties. In principle, we
!   ! can caculate Hirshfeld surfaces for *molecular* fragment
!   ! densities, rather than promolecule densities as done here. That
!   ! would require a different keyword and different code.
!     self :: IN
!     w0 :: VEC{REAL}, OUT
!     w1 :: MAT{REAL}, OUT
!     w2 :: MAT3{REAL}, OUT
!     pt :: MAT{REAL}, IN
!   ENSURE(w1.dim1==3, "wrong size w1")
!   ENSURE(w2.dim1==3, "wrong size w2")
!   ENSURE(w2.dim2==3, "wrong size w2")
!   ENSURE(w0.dim1==w1.dim2, "incompatible w0 and w1")
!   ENSURE(w0.dim1==w2.dim3, "incompatible w0 and w2")
!   ENSURE(.cluster.allocated, "no cluster data")
!   ENSURE(.cluster.info_made, "no cluster info")
!   ENSURE(.cluster.radius>ZERO, "cluster radius is zero")
!   ENSURE(.atom.allocated,"no atoms")
!   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
!     d0,rho0f,rho0a :: VEC{REAL}@
!     d1,rho1f,rho1a :: MAT{REAL}@
!     d2,rho2f,rho2a :: MAT3{REAL}@
!     f1,a1 :: VEC{REAL}(3)
!     f0,bot,bot2,bot3,fac :: REAL
!     n_pt,a,b,i :: INT
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     n_pt = w0.dim1
!     d0.create(n_pt);     rho0f.create(n_pt);     rho0a.create(n_pt)
!     d1.create(3,n_pt);   rho1f.create(3,n_pt);   rho1a.create(3,n_pt)
!     d2.create(3,3,n_pt); rho2f.create(3,3,n_pt); rho2a.create(3,3,n_pt)
!     rho0f = ZERO; rho0a = ZERO
!     rho1f = ZERO; rho1a = ZERO
!     rho2f = ZERO; rho2a = ZERO
!     do a = 1,.cluster.n_atoms
!        if (NOT .cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0f = rho0f + d0
!        rho1f = rho1f + d1
!        rho2f = rho2f + d2
!     end
!     rho0a = rho0f
!     rho1a = rho1f
!     rho2a = rho2f
!     do a = 1,.cluster.n_atoms
!        if (.cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0a = rho0a + d0
!        rho1a = rho1a + d1
!        rho2a = rho2a + d2
!     end
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     do i = 1,rho0a.dim
!       if (rho0a(a)>epsilon(ONE)) then
!         bot = ONE/rho0a(i)
!         bot2 = bot*bot
!         bot3 = TWO*bot2*bot
!         f0   = rho0f(i)
!         w0(i) = f0*bot
!         f1 = rho1f(:,i)
!         a1 = rho1a(:,i)
!         fac = f0*bot2
!         w1(:,i) = f1*bot - a1*fac
!         do a = 1,3
!         do b = 1,a
!            w2(a,b,i) = rho2f(a,b,i)*bot &
!                      - (f1(a)*a1(b)+f1(b)*a1(a))*bot2 &
!                      - f0*rho2a(a,b,i)*bot2 &
!                      + f0*a1(a)*a1(b)*bot3
!            if (a==b) cycle
!            w2(b,a,i) = w2(a,b,i)
!         end
!         end
!       else
!         w0(i) = ZERO
!         w1(:,i) = ZERO
!         w2(:,:,i) = ZERO
!       end
!     end
!     rho2a.destroy; rho2f.destroy; d2.destroy
!     rho1a.destroy; rho1f.destroy; d1.destroy
!     rho0a.destroy; rho0f.destroy; d0.destroy
!   end

!  =====================
!  Stockholder atom grid
!  =====================

   apply_stockholder_atom_weight(grid,a,pt) ::: PURE
   ! Apply i.e. multiply the "grid" by the stockholder weight function
   ! for the atom with index "a" using supplied points "pt".
   ! * If .use_interpolators is TRUE then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom (however the
   !   overlapping_atoms array will not be used to eliminate work).
   !   More likely the density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      Wa :: VEC{REAL}@
      n_pt :: INT

      ! Only needed for more than one atom
      if (.n_atom>1) then

         ! Get weights
         n_pt = pt.dim1
         Wa.create(n_pt)
         if (.use_interpolators) then
            ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")
            .GRID:make_stockholder_atom_grid_int(Wa,a,pt,.overlapping_atoms_for_atom(a).element)
         else
            .GRID:make_stockholder_atom_grid_acc(Wa,a,pt)
         end

         ! Apply them
         grid = grid*Wa

         ! Clean
         Wa.destroy

      end

   end

   make_stockholder_atom_grid(grid,a,pt,overlapping_atom) ::: PURE
   ! Make the Hirshfeld stockholder density "grid" for the atom with
   ! index "a" using supplied points "pt".
   ! * If .use_interpolators is TRUE and "overlapping_atoms" is
   !   supplised then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom. More likely the
   !   density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, optional, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      if (.n_atom>1) then

         if (.use_interpolators) then
            ENSURE(present(overlapping_atom),"no overlapping_atom")
            .GRID:make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom)
         else
            .GRID:make_stockholder_atom_grid_acc(grid,a,pt)
         end

      else

         grid = ONE

      end

   end

   make_stockholder_atom_grid_acc(grid,a,pt) ::: private, PURE
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt".
   ! NOTE: This DOES NOT USE an interpolated density for each atom
   ! UNLESS use_interpolators is explicitly set. In this case you
   ! should probably use the next routine which uses the
   ! overlapping_atoms.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}@
      n_pt,i :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a" in "rho_a"
      .atom(a).make_ED_grid(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do i = 1,.n_atom
         if (i==a) cycle
         .atom(i).add_ED_grid(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

   make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom) ::: private, PURE
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt" and given a list of
   ! "overlapping_atom". This makes use of a previously calculated
   ! interpolated density for each atom.
   ! NOTE: the CLUSTER_ATOM_DENSITY_CUTOFF must be the same as the
   ! BECKE_GRID_BASIS_FUNCTION_CUTOFF
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}@
      n_pt,i,j :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_interpolated_density(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do j = 1,overlapping_atom.dim
         i = overlapping_atom(j)
         if (i==a) cycle
         .atom(i).add_interpolated_density(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

!  ===================
!  Hirshfeld atom grid
!  ===================

   make_Hirshfeld_atom_grid
   ! Work out the Hirshfeld atom density density on ".plot_grid" 
   ! for ".plot_grid.center_atom"
      self :: IN

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.center_atom>0, "no center_atom to plot")
   ENSURE(.density_mx.is_allocated_with_genre("r "), "no restricted density matrix")

      grid :: VEC{REAL}@
      pt :: MAT{REAL}@
      D :: MAT{REAL}@
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the hirshfeld atom density
      D = .density_mx.r
      .GRID:make_Hirshfeld_atom_grid(grid,pt,.plot_grid.center_atom,D)

      ! Make the plot label
      label = "hirshfeld_atom_"
      label = trim(label) // trim(.plot_grid.center_atom.to_str)
      label = trim(label) // "_density_grid"

      ! Print out
      .PUT:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_Hirshfeld_atom_grid(N0,pt,c,D) ::: PURE
   ! Make the hirshfeld atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". Density "N0" weighted by
   ! Hirshfeld partition weight for atom "c".
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      ! Overlapping atom electron density
      .GRID:make_overlapping_atom_density(N0,pt,c,D)

      ! Apply stockholder weight function for atom "c" to "N0".
      ! If using interpolatators, then overlapping_atoms
      ! are not needed ... otherwise nothing is skipped
      .GRID:apply_stockholder_atom_weight(N0,c,pt)

   end

   make_overlapping_atom_density(N0,pt,c,D) ::: PURE
   ! Make the overlapping atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". 
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      xa,ya,za,a2 :: VEC{REAL}@
      ga0,gb0 :: VEC{REAL}@
      ra :: VEC{REAL}(3)
      pi,pj,pn :: VEC{INT}@
      skipa0,skipab, skipa,skipb :: VEC{BIN}@
      DD :: MAT{REAL}@
      sha :: SHELL1
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid0 :: VEC{EMAT{REAL}}@
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Grid size
      n_pt = pt.dim1

      ! Initialise N0
      N0 = ZERO

      ! Basis function cutoff
      cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,.overlapping_atoms_for_atom(c).element.dim

         oa  = .overlapping_atoms_for_atom(c)[ca]
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa"
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Create shell "sa"
            ba  = .basis_shell_for_shell(sa)
            sha = .basis_shell1pair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element = skipa

            ! Make/copy the "sa" basis function grid
            ! This must be copied since skipa could be TRUE
            bf_grid0(sa).element.create(n_keep,na)
            sha.make_skip_grid(bf_grid0(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = .overlapping_atoms_for_atom(c)[cb]
               fsb = .first_shell_for_atom(ob)
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.deallocated) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb = bf_skip(sb).element

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD = D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 = bf_grid0(sa)[:,1]
                     gb0 = bf_grid0(sb)[:,1]

                     Dab = fac*DD(1,1)

                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0
                     i = 0
                     j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 = bf_grid0(sa)[:,a]
                        do b = 1,nb
                           gb0 = bf_grid0(sb)[:,b]
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end

         end       ! -- lops ca,cb
      end

      ! Clean up
      bf_grid0.destroy
      bf_skip.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy

   end

!  ====================
!  Jayatilaka atom grid
!  ====================

   make_Jayatilaka_atom_grid
   ! Work out the Jayatilaka atom density density on ".plot_grid" 
   ! for ".plot_grid.center_atom"
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.center_atom>0, "no center_atom to plot")
   ENSURE(.density_mx.is_allocated_with_genre("r "), "no restricted density matrix")

      grid :: VEC{REAL}@
      pt :: MAT{REAL}@
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the hirshfeld atom density
      .GRID:make_Jayatilaka_atom_grid(grid,pt,.plot_grid.center_atom,.density_mx.r)

      ! Make the plot label
      label = "jayatilaka_atom_"
      label = trim(label) // trim(.plot_grid.center_atom.to_str)
      label = trim(label) // "_density_grid"

      ! Print out
      .PUT:dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_Jayatilaka_atom_grid(N0,pt,c,D) ::: PURE
   ! Make the Jayatilaka atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". Density "N0" weighted by
   ! Jayatilaka partition weight for atom "c" which is
   !    w(r)   = y_c(r)/sum_a y_a
   !    y_c(r) = [rho_c(r) - rho_c(0)]^{-1}
   !  rho_c(r) = rho(0) exp(- 2 Z_c r)
   ! where rho(0) is the molecular density at the position of atom c.
      self :: IN
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      c  :: INT, IN
      D  :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      ! Overlapping atom electron density
      .GRID:make_overlapping_atom_density(N0,pt,c,D)

      ! Apply weight
      .GRID:apply_Jayatilaka_atom_weight(N0,c,pt)

   end

   apply_Jayatilaka_atom_weight(grid,a,pt) ::: PURE
   ! Apply i.e. multiply the Jayatilaka weight to "grid" for the atom
   ! with index "a" using supplied points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      Wa :: VEC{REAL}@
      n_pt :: INT

      ! Only needed for more than one atom
      if (.n_atom>1) then

         ! Get weights
         n_pt = pt.dim1
         Wa.create(n_pt)
         .GRID:make_Jayatilaka_atom_weight(Wa,a,pt)

         ! Apply them
         grid = grid*Wa

         ! Clean
         Wa.destroy

      end

   end

   make_Jayatilaka_atom_weight(wt,a,pt) ::: private, PURE
   ! Make the Jayatilaka grid "g" for the atom with index "a" using
   ! supplied points "pt".
   !    w(r)   = y_c(r)/sum_a y_a
   !    y_c(r) = [rho_c(r) - rho_c(0)]^{-1}
   !  rho_c(r) = rho(0) exp(- 2 Z_c r)
   ! where rho(0) is the molecular density at the position of atom c.
   ! NOTE: This DOES NOT USE an interpolated density for each atom
   ! UNLESS use_interpolators is explicitly set. In this case you
   ! should probably use the next routine which uses the
   ! overlapping_atoms.
      self :: IN
      wt :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(wt.dim==pt.dim1,"wrong size, wt")


      pos :: MAT{REAL}@
      rho_0,rho_a :: VEC{REAL}@
      n_pt,i :: INT

      ! No. of points
      n_pt = wt.dim

      ! Get electron densities at each atom nucleus
      rho_0.create(n_pt)
      pos.create(.atom.dim,3)
      .atom.put_coordinates_to(pos,positions_as_rows=TRUE)
      .GRID:make_ED_grid(rho_0,pos)
      pos.destroy

      ! Make density "rho_a" for atom "a"
      rho_a.create(n_pt)
      .atom(a).make_exponential_densities(rho_a,pt,rho_0(a))

      ! Sum remaining into "wt"
      wt = rho_a
      do i = 1,.n_atom
         if (i==a) cycle
         .atom(i).add_exponential_densities(wt,pt,rho_0(i))
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (wt(i)>epsilon(ONE)) then; wt(i) = rho_a(i)/wt(i)
         else;                         wt(i) = ZERO
         end
      end
      rho_a.destroy
      rho_0.destroy

   end

!  ================
!  Promolecule grid
!  ================

   make_promolecule_density_grid(density_grid,pt) ::: get_from(pro_grid, GRID?=>make_ED_grid), PURE
   ! Return promolecule "density_grid" from supplied points "pt".
   end

   make_spherical_atom_grid(density_grid,pt) ::: PURE
   ! Return the promolecule "density_grid" from the supplied points "pt".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.plot_grid.allocated,"no plot_grid")
   ENSURE(.plot_grid.center_atom>0,"no plot_grid center atom")

      .atom(.plot_grid.center_atom).make_ED_grid(density_grid,pt)

   end

!  =======================
!  Grad rho on rho density
!  =======================

   make_grad_rho_on_rho_grid(grid,pt) ::: PURE
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(pt.dim1==grid.dim,"array dimensions do not match")

      rho :: VEC{REAL}@
      grad_rho :: MAT{REAL}@
      n_pt,i :: INT

      n_pt = pt.dim1

      rho.create(n_pt)
      grad_rho.create(n_pt,3)

      rho = ZERO
      grid=ZERO

      .GRID:make_ED_grid(rho,pt)
      .GRID:make_nabla_density_grid(grad_rho,pt)

      do i=1,n_pt
         if (rho(i)>ZERO) then
            grid(i)=sqrt(dot_product(grad_rho(i,:),grad_rho(i,:)))/rho(i)
         else
            grid(i)=ZERO
         end
      end

      grad_rho.destroy
      rho.destroy

   end

!  =============
!  ELI-D density
!  =============

   make_ELI_D_grid(ELI_grid,pt) ::: PURE
   ! Work out the Electron Localisation Indicator (D) (ELI) density
   ! "ELI_grid" on a set of grid points "pt", using ".natural
   ! orbitals" and the ".occupation" number vector.
     self :: IN
     ELI_grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

     if (trim(.NOs.number_kind)=="real") then
        .GRID:make_ELI_D_grid_r(ELI_grid,pt)
   ! else
   !    DIE("no complex implementation")
     end

   end

   make_ELI_D_grid_r(ELI_grid,pt) ::: PURE
   ! Work out the Electron Localisation Indicator (D) grid (ELI_D)
   ! density on a set of grid points "pt", using ".natural orbitals"
   ! and the ".NO_occ_nos" vector.  Grid, basis set, and
   ! natural orbitals are required to exist.  Reference: Wagner et al
   ! (2007), Chem Eur. J. 13, p. 5724 (Look at appendix for definition
   ! of g!)
      self :: IN
      ELI_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.is_allocated_with_genre("r "), "natural orbitals must be restricted")

      DD :: MAT{REAL}@
      gx,gy,gz :: VEC{REAL}@
      g :: VEC{REAL}@
      rho_s, tau, NO :: VEC{REAL}@
      rhox,rhoy,rhoz :: VEC{REAL}@
      i,n_pt :: INT

      ! No of grid points
      n_pt = pt.dim1

      rho_s.create(n_pt)
      rho_s  = ZERO

      ! Make the density of alpha electrons
      .GRID:make_ED_grid(rho_s,pt)
      rho_s = HALF*rho_s

      ! Temporaries
      g.create(n_pt);     g     = ZERO
      tau.create(n_pt);   tau   = ZERO
      rhox.create(n_pt);  rhox  = ZERO
      rhoy.create(n_pt);  rhoy  = ZERO
      rhoz.create(n_pt);  rhoz  = ZERO

      NO.create(n_pt)
      DD.create(n_pt,3)

      ! Sum the orbital gradient and density gradient bit
      parallel do i = 1,.INQ:no_of_occupied_NOs

         .GRID:make_nabla_orbital_grid_r(DD,NO,.NOs.r(:,i), pt)

         ! Orbital gradients
         gx = DD(:,1)
         gy = DD(:,2)
         gz = DD(:,3)

         ! Fermi hole curvature
         g = g + rho_s * (gx*gx + gy*gy + gz*gz)

         ! This is only the orbital gradient part
         rhox = rhox + gx*NO
         rhoy = rhoy + gy*NO
         rhoz = rhoz + gz*NO

      end

      DD.destroy
      NO.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(g)
         PARALLEL_SUM(tau)
         PARALLEL_SUM(rhox)
         PARALLEL_SUM(rhoy)
         PARALLEL_SUM(rhoz)
      end

      g = g - rhox*rhox - rhoy*rhoy - rhoz*rhoz

      ELI_grid = rho_s * (12.0d0/g)**(THREE/EIGHT)

      ! Clean up
      rhoz.destroy
      rhoy.destroy
      rhox.destroy
      tau.destroy
      g.destroy
      rho_s.destroy

   end

!  ===========
!  ELF density
!  ===========

   make_ELF_grid(ELF_grid,pt) ::: PURE
   ! Work out the Electron Localisation Function (ELF) density "g" on
   ! a set of grid points "pt", using ".natural orbitals" and the
   ! ".occupation" number vector.
      self :: IN
      ELF_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (trim(.NOs.number_kind)== "real") then
         .GRID:make_ELF_grid_r(ELF_grid,pt)
      end

   end

   make_ELF_grid_r(ELF_grid,pt) ::: PURE
   ! Work out the Electron Localisation Function (ELF) density on a
   ! set of grid points "pt", using ".natural orbitals" and the
   ! ".NO_occ_nos" vector.  Grid, basis set, and natural
   ! orbitals are required to exist.
      self :: IN
      ELF_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.is_allocated_with_genre("r "), "natural orbitals must be restricted")

      DD :: MAT{REAL}@
      NO :: VEC{REAL}@
      gx,gy,gz, mo_val :: VEC{REAL}@
      rho_sx,rho_sy,rho_sz :: VEC{REAL}@
      rho_s,tau, d_s, d0_s :: VEC{REAL}@
      occu,factor, mo_val_n :: REAL
      gx_n,gy_n,gz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .INQ:no_of_occupied_NOs

      do i = 1,n_occ

         .GRID:make_nabla_orbital_grid_r(DD,NO,.NOs.r(:,i), pt)
         mo_val = NO(:)
         gx   = DD(:,1)
         gy   = DD(:,2)
         gz   = DD(:,3)
         occu = HALF*.NO_occ_nos.r(i)

         do n = 1,n_pt
            mo_val_n  = mo_val(n)
            gx_n      = gx(n)
            gy_n      = gy(n)
            gz_n      = gz(n)
            occ_mo    = occu*mo_val_n
            rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
            tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
            rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
            rho_sy(n) = rho_sy(n) + occ_mo*gy_n
            rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end

      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy
      rho_sy.destroy
      rho_sx.destroy
      tau.destroy

      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      ! this could be more efficient if the d0_s*d0_s is written
      ! factor2*rho_s**(TWO+FIVE/THREE)
      d0_s.destroy; d_s.destroy

   end

!  =====================
!  Tsirelson ELF density
!  =====================

   make_Tsirelson_ELF_grid(ELF_grid,pt) ::: PURE
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF)
   ! density on a series of grid points "pt" ".natural orbitals" and
   ! the ".NO_occ_nos" vector.
      self :: IN
      ELF_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (trim(.NOs.number_kind)=="real") then
         .GRID:make_Tsirelson_ELF_grid_r(ELF_grid,pt)
      end

   end

   make_Tsirelson_ELF_grid_r(ELF_grid,pt) ::: PURE
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF)
   ! density on a series of grid points "pt" ".natural orbitals" and
   ! the ".NO_occ_nos" vector.
      self :: IN
      ELF_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.NOs.allocated, "no natural orbitals")

      NO :: VEC{REAL}@
      DD,LL :: MAT{REAL}@
      mo_val,gx,gy,gz,lx,ly,lz :: VEC{REAL}@
      rho,rho_x,rho_y,rho_z :: VEC{REAL}@
      lap,d_p,d_0 :: VEC{REAL}@
      occu,factor,mo_val_n,occ_mo :: REAL
      gx_n,gy_n,gz_n :: REAL
      lx_n,ly_n,lz_n :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO

      n_pt = pt.dim1
      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .INQ:no_of_occupied_NOs

      do i = 1,n_occ

         .GRID:make_laplacian_orbital_grid_r(LL,DD,NO,.NOs.r(:,i), pt)

         mo_val = NO(:)
         gx = DD(:,1); gy = DD(:,2); gz = DD(:,3)
         lx = LL(:,1); ly = LL(:,2); lz = LL(:,3)

         occu = .NO_occ_nos.r(i)

         do n = 1,n_pt

            mo_val_n = mo_val(n)
            gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
            lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)

            occ_mo   = occu*mo_val_n                        ! this is n_i phi_i
            rho(n)   = rho(n)   + occ_mo*mo_val_n           ! this is rho
            rho_x(n) = rho_x(n) + occ_mo*gx_n               ! this is half grad_x rho
            rho_y(n) = rho_y(n) + occ_mo*gy_n
            rho_z(n) = rho_z(n) + occ_mo*gz_n
            lap(n)   = lap(n)   + occ_mo*(lx_n+ly_n+lz_n) & ! this is half nabla^2 rho
                                + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
         end

      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 &
          - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
          + lap/THREE

      lap.destroy

      rho_z.destroy
      rho_y.destroy
      rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

!  ======================
!  Fermi mobility density
!  ======================

   make_fermi_mobility_grid(f,pt) ::: PURE
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      self :: IN
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (trim(.NOs.number_kind)== "real") then
         .GRID:make_fermi_mobility_grid_r(f,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_fermi_mobility_grid_r(f,pt) ::: PURE
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      self :: IN
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.NOs.allocated, "no natural orbitals")

      del_gi :: MAT{REAL}@
      dg,gi, rho  :: VEC{REAL}@
      dgx,dgy,dgz :: VEC{REAL}@
      orb :: VEC{REAL}@
      n,n_pt,i,n_occ :: INT
      delx,dely,delz,fac :: REAL

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      gi.create(n_pt)

      del_gi.create(n_pt,3)

      do i = 1,n_occ
         orb = .NOs.r(:,i)
         .GRID:make_nabla_orbital_grid_r(del_gi,gi,orb,pt)
         do n = 1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end
      end

      del_gi.destroy
      gi.destroy

      rho.create(n_pt)
      .GRID:make_ED_grid(rho,pt)

      fac = (THREE*PI/FOUR) * HALF**TWOTHIRD
      f = ONE/rho * (dg - TWO*(dgx*dgx + dgy*dgy + dgz*dgz)/rho) - fac * rho**TWOTHIRD

      rho.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

!  ===========================
!  True Fermi mobility density
!  ===========================

   make_true_fermi_mobility_grid(f,pt) ::: PURE
   ! Work out the the true fermi mobility density "f" on a series of
   ! grid points "pt" using ".natural orbitals" and the
   ! ".NO_occ_nos" vector. The true function differs from that
   ! above in that the kinetic energy density is evaluated exactly.
      self :: IN
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.NOs.has_any_genre, "no natural orbitals")

      if (trim(.NOs.number_kind)== "real") then
         .GRID:make_true_fermi_mobil_grid_r(f,pt)
    ! else
    !    DIE("code not written yet")
      end

   end

   make_true_fermi_mobil_grid_r(f,pt) ::: PURE
   ! Evaluate the true Fermi hole mobility grid "f" on a set of grid points
   ! "pt".  The true function differs from that above in that the kinetic energy
   ! density is evaluated exactly.
   ! NOTE: this routine is only valid for single determinant wavefunctions.
      self :: IN
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.NOs.allocated, "no natural orbitals")
   ENSURE(.kinetic_energy_mx.allocated, "no kinetic energy matrix")

      dg,rho,K :: VEC{REAL}@
      dgx,dgy,dgz :: VEC{REAL}@
      n,n_pt,i,j,n_occ :: INT
      delx,dely,delz :: REAL
      del_gi,g,T :: MAT{REAL}@

      n_pt = pt.dim1
      n_occ = .INQ:no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      g.create(n_pt,n_occ)
      del_gi.create(n_pt,3)

      ! Assemble intermediate terms
      do i = 1,n_occ

         .GRID:make_nabla_orbital_grid_r(del_gi,g(:,i),.NOs.r(:,i),pt)

         do n = 1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*g(n,i)
            dgy(n) = dgy(n) + dely*g(n,i)
            dgz(n) = dgz(n) + delz*g(n,i)
         end

      end

      del_gi.destroy

      ! Make kinetic energy matrix part
      K.create(n_pt)
      K = ZERO
      T.create(.n_bf,.n_bf)
      T = .kinetic_energy_mx.r
      T.change_basis_using(.NOs.r)

      do j = 1,n_occ
         do i = 1,n_occ
            K = K + g(:,i)*g(:,j)*T(i,j)
         end
      end
      T.destroy

      ! Now do the final assembly
      rho.create(n_pt)
      .GRID:make_ED_grid(rho,pt)
      f = ONE/rho * (dg - TWO*(dgx*dgx+dgy*dgy+dgz*dgz)/rho - TWO*K)

      ! Clean
      rho.destroy
      K.destroy
      g.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

!  ==============
!  Electric Field
!  ==============

   make_E_field_grid(grid,pt) ::: get_from(field_grid, FIELD?=>:make_E_field_grid)
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_E_field_grid(E,pt) ::: PURE
   ! Make the electric field "E" at a series of points "pt"
      self :: IN
      E :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_mx.has_any_genre,"no density matrix")
   ENSURE(E.dim1==pt.dim1,"wrong dim1, E & pt")
   ENSURE(E.dim2==3,      "wrong dim2, E")

      D,Dba,Ex,Ey,Ez :: MAT{REAL}@
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! The imaginary part of AO density matrix
      D.create(.n_bf,.n_bf)

      ! Initialize
      E = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

         ! Get shell indices (leaky)
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)
        
         ! Get the density matrix
         Dba.create(nb,na)
         Dba = D(fb:lb,fa:lb)
        
         ! Electric field integrals
         Ex.create(na,nb)
         Ey.create(na,nb)
         Ez.create(na,nb)
        
         ! Loop over points
         do p = 1,n_pt
        
            sh.make_E_field_ints(Ex,Ey,Ez,pt(p,:))
        
            fac = TWO
            if (fa==fb) FAC = ONE
        
            E(p,1) = E(p,1) + Ex.trace_product_with(Dba)
            E(p,2) = E(p,2) + Ey.trace_product_with(Dba)
            E(p,3) = E(p,3) + Ez.trace_product_with(Dba)
        
         end
        
         ! Add nuclear contribution
         .atom.add_nuclear_E_field_at_points_to(E,pt)
        
         ! Clean
         Ez.destroy
         Ey.destroy
         Ex.destroy
         Dba.destroy

      end

      ! Clean
      D.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(E)
      end

   end


   make_E_field_magnitude(grid,pt) ::: PURE
   ! Evaluate the E field magnitude on a set of grid points "pt". 
   ! Includes the atom nuclear charge contribution.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

      field :: MAT{REAL}@
      fx,fy,fz :: VEC{REAL}@

      ! Make the grid of field values
      field.create(.plot_grid.n_pt,3)
      .GRID:make_E_field_grid(field,pt)

      ! Assign field components
      fx = field(:,1)
      fy = field(:,2)
      fz = field(:,3)

      ! Get the magnitude
      grid = sqrt(fx*fx+fy*fy+fz*fz)

      ! Clean up
      field.destroy

   end

!  ==============
!  Magnetic Field
!  ==============

   make_B_field_grid(grid,pt)
   ! Work out the field density magnitude on ".plot_grid" and dump output
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.plot_grid.allocated, "no grid")

      B,B_L,B_S :: MAT{REAL}@
      mag :: VEC{REAL}@

      if (.plot_grid.points_filename/="no_made-up_points") then

         stdout.text("=====================================")
         stdout.text("use of read-in grid to be implemented")
         stdout.text("TONTO will stop here ...")
         stdout.text("=====================================")
         DIE("die")

      else

         ! Make space for the field and grid points
         B.create(.plot_grid.n_pt,3)
         B_L.create(.plot_grid.n_pt,3)
         B_S.create(.plot_grid.n_pt,3)
         mag.create(.plot_grid.n_pt)

         ! Make the grid of field values
         .GRID:make_B_L_field_grid(B_L,pt)
         .GRID:make_B_S_field_grid(B_S,pt)
         
         ! Print B_L field components
         .PUT:dump_plot_grid(B_L(:,1),"B_L_field.x")
         .PUT:dump_plot_grid(B_L(:,2),"B_L_field.y")
         .PUT:dump_plot_grid(B_L(:,3),"B_L_field.z")
         
         mag = sqrt( B_L(:,1)*B_L(:,1) + B_L(:,2)*B_L(:,2) + B_L(:,3)*B_L(:,3) )
         .PUT:dump_plot_grid(mag,"B_L_field.magnitude")
         
         ! Print B_S field components
         .PUT:dump_plot_grid(B_S(:,1),"B_S_field.x")
         .PUT:dump_plot_grid(B_S(:,2),"B_S_field.y")
         .PUT:dump_plot_grid(B_S(:,3),"B_S_field.z")
         
         mag = sqrt( B_S(:,1)*B_S(:,1) + B_S(:,2)*B_S(:,2) + B_S(:,3)*B_S(:,3) )
         .PUT:dump_plot_grid(mag,"B_S_field.magnitude")
         
         ! Print B field components
         B = B_L + B_S
         .PUT:dump_plot_grid(B(:,1),"B_field.x")
         .PUT:dump_plot_grid(B(:,2),"B_field.y")
         .PUT:dump_plot_grid(B(:,3),"B_field.z")
         
         ! Magnitude (returned)
         grid = sqrt( B(:,1)*B(:,1) + B(:,2)*B(:,2) + B(:,3)*B(:,3) )
         .PUT:dump_plot_grid(grid,"B_field.magnitude")

      end

      ! Clean up
      mag.destroy
      B_S.destroy
      B_L.destroy
      B.destroy

   end

   make_B_L_field_grid(grid,pt) ::: get_from(field_grid, FIELD?=>:make_B_L_field_grid)
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_B_L_field_grid(B,pt) ::: PURE
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      self :: IN
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_mx.has_any_genre,"no density matrix")

      Mleft,Mright :: MAT4{REAL}@, target
      J1,J2,J3 :: MAT{REAL}*
      J4,J5,J6 :: MAT{REAL}*
      D,Dba,Dab :: MAT{REAL}@
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! The imaginary part of AO density matrix
      D.create(.n_bf,.n_bf)
      .BASE:make_ao_IM_density_mx(D)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)

        ! Get the density matrix
        Dab.create(na,nb)
        Dab = D(fa:la,fb:lb)

        Dba.create(nb,na)
        Dba = D(fb:lb,fa:la)

        ! Space for integrals
        Mleft.create(nb,na,3,3)
        Mright.create(na,nb,3,3)
        J1 => Mright(:,:,1,1)
        J2 => Mright(:,:,2,2)
        J3 => Mright(:,:,3,3)
        J4 =>  Mleft(:,:,1,1)
        J5 =>  Mleft(:,:,2,2)
        J6 =>  Mleft(:,:,3,3)

        ! Loop over points
        do p = 1,n_pt

           if (fa==fb) then

              ! Make the B-field integrals for point k
              sh.make_nabla_field_ints(Mright,pt(p,:))
             
              ! Cross product part
              J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
              J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
              J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
             
              ! Get magnetic field contribution
              B(p,1) = B(p,1) + J1.trace_product_with(Dba)
              B(p,2) = B(p,2) + J2.trace_product_with(Dba)
              B(p,3) = B(p,3) + J3.trace_product_with(Dba)

           else

              ! Make the B-field integrals for point k
              sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))
             
              ! Cross product part
              J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
              J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
              J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
              J4 = Mleft(:,:,2,3) - Mleft(:,:,3,2)
              J5 = Mleft(:,:,3,1) - Mleft(:,:,1,3)
              J6 = Mleft(:,:,1,2) - Mleft(:,:,2,1)
             
              ! Get magnetic field contribution
              B(p,1) = B(p,1) + J1.trace_product_with(Dba)
              B(p,2) = B(p,2) + J2.trace_product_with(Dba)
              B(p,3) = B(p,3) + J3.trace_product_with(Dba)
              B(p,1) = B(p,1) + J4.trace_product_with(Dab)
              B(p,2) = B(p,2) + J5.trace_product_with(Dab)
              B(p,3) = B(p,3) + J6.trace_product_with(Dab)

           end

        end

        ! Clean
        Mleft.destroy
        Mright.destroy
        Dba.destroy
        Dab.destroy

      end

      ! Clean
      D.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Minus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end

!   make_B_L_field_grid_checked(B,pt)
!   ! Make the magnetic field "B" field due to the linear current on a
!   ! series of points "pt"
!      B :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_mx.has_any_genre,"no density matrix")
!
!      D :: MAT{REAL}*
!      Dba :: MAT{REAL}*
!      Jx,Jy,Jz :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, k,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! Make the AO density matrix
!      D.create(.n_bf,.n_bf)
!      .BASEmake_ao_IM_density_mx(D)
!
!      ! Initialize
!      B = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)
!        fac = TWO
!        if (fa==fb) fac = ONE
!
!        ! Get the density matrix
!        Dba.create(nb,na)
!        Dba = D(fb:lb,fa:la)
!
!        ! Space for integrals
!        Jx.create(na,nb)
!        Jy.create(na,nb)
!        Jz.create(na,nb)
!
!        ! Loop over points
!        do k = 1,n_pt
!
!           ! Make the integrals for point k
!           sh.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
!
!           ! Get magnetic field contribution
!           B(k,1) = B(k,1) + fac*Jx.trace_product_with(Dba)
!           B(k,2) = B(k,2) + fac*Jy.trace_product_with(Dba)
!           B(k,3) = B(k,3) + fac*Jz.trace_product_with(Dba)
!
!        end
!
!        ! Clean
!        Jz.destroy; Jy.destroy; Jx.destroy
!        Dba.destroy
!
!      end
!
!      ! Clean
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -HALF/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B   = fac*B
!
!   end


   make_B_S_field_grid(grid,pt) ::: get_from(field_grid, FIELD?=>:make_B_S_field_grid)
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_B_S_field_grid(B,pt) ::: PURE
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      self :: IN
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_mx.has_any_genre,"no density matrix")

      ! Not the most efficient, but should work ...
      if (.density_mx.a.allocated) then; .GRID:make_B_S_field_grid_u(B,pt)
      else;                              .GRID:make_B_S_field_grid_gc(B,pt)
      end

   end

   make_B_S_field_grid_u(B,pt) ::: PURE
   ! Make the magnetic field "B" field due to the spin current on a
   ! series of points "pt"
      self :: IN
      B  :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_mx.a.allocated,"no alpha density matrix")
   ENSURE(.density_mx.b.allocated,"no beta density matrix")

      Mright,Mleft :: MAT4{REAL}@
      Sz, S3, S6   :: MAT{REAL}@
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO Sz density matrix
      Sz.create(.n_bf,.n_bf)
      .BASE:make_r_Sz_density_mx(Sz)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)

        ! Get the z spin density matrix block
        S3.create(nb,na); S3 = Sz(fb:lb,fa:la)
        S6.create(na,nb); S6 = Sz(fa:la,fb:lb)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt

           if (fa==fb) then
          
              ! Make the B-field integrals for point k
              sh.make_nabla_field_ints(Mright,pt(p,:))
              
              
              ! Sum over the spin density matrices
              B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
              B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
          
           else
          
              ! Make the B-field integrals for point k
              sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))
              
              B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
              B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
              
              B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
              B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
              B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
              B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)
          
           ! To add to make it work even if S is not Hermitian
           ! (useful to test a single matrix element)
           ! but then a factor HALF should be inserted
          
          
!             B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!             B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!             B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!             B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
!         
!             B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!             B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!             B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!             B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)
          
          
           end

        end

        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S6.destroy

      end

      ! Clean
      Sz.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end

   make_B_S_field_grid_gc(B,pt) ::: PURE
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      self :: IN
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")

      S :: MAT3{REAL}@
      Mleft  :: MAT4{REAL}@
      Mright :: MAT4{REAL}@
      S1,S2,S3 :: MAT{REAL}@
      S4,S5,S6 :: MAT{REAL}@
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO density matrix
      S.create(.n_bf,.n_bf,3)
      .BASE:make_RE_c_S_densities(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

         ! Get shell indices (leaky)
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)
         
         ! Get the spin density matrix
         S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
         S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
         S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
         S4.create(na,nb); S4 = S(fa:la,fb:lb,1)
         S5.create(na,nb); S5 = S(fa:la,fb:lb,2)
         S6.create(na,nb); S6 = S(fa:la,fb:lb,3)
         
         ! Space for integrals
         Mright.create(na,nb,3,3)
         Mleft.create(nb,na,3,3)
         
         ! Loop over points
         do p = 1,n_pt
         
           if (fa==fb) then
         
              ! Make the B-field integrals for point k
              sh.make_nabla_field_ints(Mright,pt(p,:))
              
              
              ! Sum over the spin density matrices
              B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
              B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
              B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
              B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)
              
              B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
              B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
              B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
              B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)
              
              B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
              B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
         
           else

              ! Make the B-field integrals for point k
              sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))
              
              B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
              B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
              B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
              B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)
              
              B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
              B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
              B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
              B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)
              
              B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
              B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
              B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
              
              
              B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S4)
              B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S4)
              B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S4)
              B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S4)
              
              B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S5)
              B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S5)
              B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S5)
              B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S5)
              
              B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
              B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
              B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
              B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)
         
           ! To add to make it work even if S is not Hermitian
           ! (useful to test a single matrix element)
           ! but then a factor HALF should be inserted
         
!             B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S4,TRUE)
!             B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S4,TRUE)
!             B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S4,TRUE)
!             B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S4,TRUE)
!        
!             B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S5,TRUE)
!             B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S5,TRUE)
!             B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S5,TRUE)
!             B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S5,TRUE)
!        
!             B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!             B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!             B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!             B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
!        
!        
!             B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S1,TRUE)
!             B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S1,TRUE)
!             B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S1,TRUE)
!             B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S1,TRUE)
!        
!             B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S2,TRUE)
!             B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S2,TRUE)
!             B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S2,TRUE)
!             B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S2,TRUE)
!        
!             B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!             B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!             B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!             B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)
           end
        end

        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S2.destroy
        S1.destroy
        S6.destroy
        S5.destroy
        S4.destroy

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor.
      ! Plus sign because the nabla field ints in the code are 
      ! defined as minus the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end


   make_B_L_matrices(Bx,By,Bz,c) ::: PURE
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      self :: IN
      Bx,By,Bz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      q,fa,fb,la,lb,na,nb :: INT
      sh :: SHELL2

      ! Initialize
      Bx = ZERO
      By = ZERO
      Bz = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

         ! shell indices (leaky)
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)
         
         ! Make the integrals, point c
         sh.make_magnetic_jp_ints(Bx(fa:la,fb:lb),By(fa:la,fb:lb),Bz(fa:la,fb:lb),c)
         
      end

      ! Symmetrize
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(Bx)
         PARALLEL_SYMMETRIC_SUM(By)
         PARALLEL_SYMMETRIC_SUM(Bz)
      else
         Bx.symmetric_reflect
         By.symmetric_reflect
         Bz.symmetric_reflect
      end

   end

!  ======================================
!  Crystal structure factor residual maps
!  ======================================

!   make_residual_density_map ::: leaky
!   ! Work out the residual density map on ".plot_grid". A Gnuplot
!   ! ascii file is generated. zc
!   ENSURE(.plot_grid.allocated, "no grid")
!
!      map :: VEC{REAL}@
!
!      map.create(.plot_grid.n_pt)
!      .GRID:make_residual_density_map(map)
!      .PUT:dump_plot_grid(map,"residual_density")
!      map.destroy
!
!   end

!   make_residual_density_map(map)
!   ! Make the crystal error "map".
!      map :: VEC{REAL}, OUT
!
!   ENSURE(.plot_grid.allocated, "no grid")
!
!      pt :: MAT{REAL}@
!      n_pt :: INT
!
!      ! Make pts array
!      n_pt = .plot_grid.n_pt
!      pt.create(n_pt,3)
!      .plot_grid.make_points(pt)
!
!      ! Make residual error map
!      .crystal.make_residual_density_cell(map,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)
!
!      ! Clean
!      pt.destroy
!
!   end

   make_residual_density_cell ::: leaky
   ! Work out the residual map on the unit cell with divisions as
   ! specified in the ".plot_grid" and write to a file.
      self :: IN

   ENSURE(.plot_grid.allocated, "no grid")

      map :: VEC{REAL}@

      map.create(.plot_grid.n_pt)

      .GRID:make_residual_density_cell(map)
      .PUT:dump_plot_grid(map,"residual_density")

      map.destroy

   end

   make_residual_density_cell(map) ::: PURE
   ! Work out the residual "map" on the unit cell with divisions as
   ! specified in the ".plot_grid".
      self :: IN
      map :: VEC{REAL}, OUT

   ENSURE(.plot_grid.allocated, "no grid")

      nx,ny,nz :: INT

      ! Points per axis
      nx = .plot_grid.n_x
      ny = .plot_grid.n_y
      nz = .plot_grid.n_z

      ! Make residual error map
      .crystal.make_residual_density_cell(map,nx,ny,nz)

   end

!  ===========
!  Test sphere
!  ===========

   make_test_sphere_on_atom_1(f,pt) ::: PURE
   ! Work out the test sphere on atom 1 with value 1 at radius 1 bohr
   ! increasing linearly with distance. Can use to check units if you
   ! know bond distances. Results in "f" for points "pts".
      self :: IN
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom_info_made, "no atoms")

      i :: INT
      pos,r :: VEC{REAL}(3)

      pos = .atom(1).position

      ! Do it
      do i = 1,pt.dim1
         r = pt(i,:)
         r = r - pos
         f(i) = r.norm
      end

   end

!  ======================
!  Polarizability density
!  ======================

   make_E_polarization_grid(grid,pt)
   ! Work out the electric polarization grid, either along a
   ! projection or all three directions and magnitude.
      self :: IN
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.plot_grid.allocated, "no grid")

      if (.plot_grid.projection_direction.is_zero) then
         .GRID:make_E_polarization_vgrid(grid,pt)
      else
         .GRID:make_E_polarization_pgrid(grid,pt)
      end

   end

   make_E_polarization_vgrid(grid,pt) ::: get_from(field_grid, FIELD?=>:make_E_polarization_vgrid)
   ! Work out the field density on ".plot_grid" and dump output
   end

   make_E_polarization_vgrid(E,pt) ::: PURE
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      self :: IN
      E :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.U_electric_dipole.allocated,"no U matrices?")
   ENSURE(E.dim1==pt.dim1, "E and pt: inconsistent no. of points")
   ENSURE(E.dim2==3      , "E : wrong dim2")

      D :: MAT3{REAL}@
      MO :: MAT{REAL}@
      n_occ, i :: INT

      ! Dimensions
      n_occ = .n_a

      ! Get derivative density matrices (restricted only)
      D.create(.n_bf,.n_bf,3)
      MO = .MOs.r
      do i = 1,3 ! x,y,z electric fields
         .U_electric_dipole(:,:,1).back_transform_to(D(:,:,1),MO(:,n_occ+1:),MO(:,1:n_occ))
         D(:,:,i).symmetrize
      end
      D = FOUR*D

      ! Make the derivative rho grid
      .GRID:make_derivative_rho_grid(E,pt,D)

      ! Clean
      D.destroy

   end

   make_E_polarization_pgrid(grid,pt) ::: PURE
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      self :: IN
      grid :: VEC{REAL}, OUT
      pt  :: MAT{REAL}, IN

   ENSURE(grid.dim==pt.dim1, "grid and pt: inconsistent no. of points")

      E :: MAT{REAL}@
      n :: VEC{REAL}(3)
      n_pt :: INT

      ! Dimensions
      n_pt  = pt.dim1

      ! Space
      E.create(n_pt,3)

      ! Make electric polarization density
      .GRID:make_e_polarization_vgrid(E,pt)

      ! Do the projection
      n = .plot_grid.projection_direction
      grid = E(:,1)*n(1) + E(:,2)*n(2) + E(:,3)*n(3)

      ! Clean
      E.destroy

   end

!  ======================
!  Set interpolator grids
!  ======================

   make_ANO_interpolators ::: leaky
   ! Get the gaussian ANO interpolators
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      template :: INTERPOLATOR@
      a,b :: INT
      done :: VEC{BIN}@
      first :: BIN

      if (.INQ:has_all_interpolators) return

      done.create(.n_atom)
      done = FALSE

      do a = 1,.n_atom

         ! Skip?
         if (done(a)) cycle

         ! Make the interpolator
         if (.atom(a).interpolator.deallocated) then
            if (.interpolator.allocated) then
               .atom(a).make_interpolator(.interpolator)
            else
               .GRID:make_interpolator_sqrt_x1x(template)
               .atom(a).make_interpolator(template)
               template.destroy
            end

            if (first) then
               stdout.flush
               stdout.text("Making gaussian ANO interpolators ...")
               first = FALSE
            end

         end

         done(a) = TRUE

         ! Copy to the other atoms
         do b = a+1,.n_atom
        
            ! Skip?
            if (done(b)) cycle
            if (NOT .atom(b).is_same_kind_as(.atom(a))) cycle
        
            .atom(b).interpolator = .atom(a).interpolator

            done(b) = TRUE
        
         end

      end

      done.destroy 

   end

   make_slater_interpolators ::: leaky
   ! Make the slaterbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
      self :: INOUT

   ENSURE(.slaterbasis.allocated,"no slaterbasis")

      template :: INTERPOLATOR@
      i :: INT

    ! stdout.flush
    ! stdout.text("Making slater interpolators ...")

      ! Make the interpolators
      if (.interpolator.allocated) then

         ! User defined interpolator
         do i = 1,.slaterbasis.dim
            .slaterbasis(i).make_interpolator(.interpolator)
         end

      else

         ! Default interpolator
         .GRID:make_interpolator_sqrt(template)
         do i = 1,.slaterbasis.dim
           .slaterbasis(i).make_interpolator(template)
         end
         template.destroy

      end

      ! Set .atom to use this interpolator
      if (.atom.allocated) .atom.set_basis_kind("slater")

   end

   make_coppens_interpolators ::: leaky
   ! Make the coppensbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ! Otherwise use an atom density cutoff "tol".
   ! NOTE: any existing interpolators are destroyed first
      self :: INOUT

   ENSURE(.coppensbasis.allocated,"no slaterbasis")

      template :: INTERPOLATOR@
      i :: INT

      stdout.flush
      stdout.text("Making coppens interpolators ...")

      ! Make the interpolators
      if (.interpolator.allocated) then

         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(.interpolator)
         end

      else

         .GRID:make_interpolator_sqrt(template)
         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(template)
         end
         template.destroy

      end

      ! Set .atom to use this interpolator
      if (.atom.allocated) .atom.set_basis_kind("coppens")

   end

   make_interpolator_sqrt(interpolator) ::: leaky
   ! Make a non-gaussian interpolator. These typically used for
   ! stockholder weight functions.
      self :: IN
      interpolator :: INTERPOLATOR@

      ! Create default interpolator
      interpolator.create

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.allocated) then
      if (.saved.cluster.allocated) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt")
      interpolator.set_table_length(900d0)
      interpolator.set_table_spacing(0.1d0)

   end

   make_interpolator_sqrt_x1x(interpolator) ::: leaky
   ! Make a gaussian interpolator.
      self :: IN
      interpolator :: INTERPOLATOR@

      ! Create default interpolator
      interpolator.create

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.allocated) then
      if (.saved.cluster.allocated) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("cubic_spline")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
      interpolator.set_table_length(ONE)
      interpolator.set_spacing(0.0001d0)

   end

!  ============================
!  Angyan's oscillator orbitals
!  ============================

!   make_oscillator_orbital_grid ::: PURE
!   ! Work out the oscillator orbital on ".plot_grid" using ".natural
!   ! orbitals" for orbital "orb".
!      self :: IN
!
!   ENSURE(.plot_grid.allocated, "no grid")
!   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
!   ENSURE(.NOs.allocated, "no natural orbitals")
!   ENSURE(.NOs.has_any_genre, "no natural orbitals")
!   ENSURE(.localiser.allocated, "no localiser orbject created")
!
!      pt :: MAT{REAL}@
!      gr :: VEC{REAL}@
!      orb :: INT
!
!      orb = .plot_grid.orbital
!      pt.create(.plot_grid.n_pt,3)
!      .plot_grid.make_points(pt)
!
!      if (trim(.NOs.number_kind)=="real") then
!
!         gr.create(.plot_grid.n_pt)
!         .GRID:make_oscillator_orbital_grid_r(gr,orb,pt)
!         .PUT:dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
!         gr.destroy
!
!    ! else
!    !    DIE("complex case not yet implemented")
!
!      end
!
!      pt.destroy
!
!   end

!   make_oscillator_orbital_grid_r(g,ind,pt,square)
!   ! Evaluate the oscillator orbital density grid "g" for the localised orbital
!   ! with index "ind" on a set of grid points "pt". You must supply on the input
!   ! line the angular momentum "l" and component "n" of the oscillator orbital,
!   ! which is an awful hack for the moment.
!      self :: IN
!      g :: VEC{REAL}, OUT
!      ind :: INT, IN
!      pt :: MAT{REAL}, IN
!      square :: BIN, optional, IN
!
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.allocated,  "no atom list")
!   ENSURE(.localiser.allocated, "no localiser orbject created")
!
!      os :: VEC{REAL}@
!      c  :: VEC{REAL}(3)
!      sh :: SHELL1
!      l,n :: INT
!
!      os.create(pt.dim1)
!      c = .localiser.dipole(ind,ind,:)
!
!      stdin.read(l)
!      stdin.read(n)
!
!      sh.make_oscillator_orbital_mask(os,c,l,n,pt)
!      .GRID:make_orbital_grid_r(g,.localiser.MO(:,ind),pt,square)
!      g = g*os
!
!      os.destroy
!
!   end

!   make_p_oscillator_orb_grid_r(g,ind,pt,square) ::: PURE
!   ! Evaluate the oscillator orbital density grid "g" for the
!   ! projected localised orbital with index "ind" on a set of grid
!   ! points "pt". You must supply on the input line the angular
!   ! momentum "l" and component "n" of the oscillator orbital, which
!   ! is an awful hack for the moment.
!      self :: IN
!      g :: VEC{REAL}, OUT
!      ind :: INT, IN
!      pt :: MAT{REAL}, IN
!      square :: BIN, optional, IN
!
!   ENSURE(NOT .use_spherical_basis,"not implemented")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.allocated,  "no atom list")
!   ENSURE(.localiser.allocated, "no localiser orbject created")
!
!      gg,os :: VEC{REAL}@
!      c  :: VEC{REAL}(3)
!      maxl,l,n,ln, i,j :: INT
!      coeff :: REAL
!      sh :: SHELL1
!
!      gg.create(pt.dim1)
!      os.create(pt.dim1)
!      c = .localiser.dipole(ind,ind,:)
!
!      stdin.read(maxl)
!      stdin.read(l)
!      stdin.read(n)
!
!      .GRID:make_orbital_grid_r(gg,.localiser.MO(:,ind),pt,square)
!
!      ln = GAUSSIAN_DATA:n_comp_up_to(l-1)*.n_a &
!         + (ind-1)*GAUSSIAN_DATA:n_comp(l) + n
!      g = ZERO
!      i = 0
!      do l = 0,maxl
!      do n = 1,GAUSSIAN_DATA:n_comp(l)
!      do j = 1,.n_a
!         i = i + 1
!         coeff = .localiser.TM(i,ln)
!         if (coeff.is_zero) cycle
!         sh.make_oscillator_orbital_mask(os,c,l,n,pt)
!         g = g + coeff*gg*os
!      end
!      end
!      end
!
!      os.destroy
!      gg.destroy
!
!   end

end

