!===================================================================
!
! OPMATRIX: Operator matrices.
!
! Provide a basis set (matrix) representation of a one-electron
! quantum mechanical operator. Can cope with polymorphic types of
! basis representations, including restricted, unrestricted, and
! general basis orbital matrices.  Also, complex types for all these
! matrices.
!
! Basically, its a polymorphic matrix type.
!
! Copyright (C) Dylan Jayatilaka 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module OPMATRIX

   implicit none

   allowed_genres :: VEC{STR}(len=2,3)

   data allowed_genres/"r ","u ","gc"/

contains

! ==========
! Allocation
! ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   create(n_bf) ::: leaky, PURE
   ! Create an opmatrix object, in a basis set with "n_bf" spatial orbitals
      self :: allocatable, OUT
      n_bf :: INT, IN
      .create
      .n_bf = n_bf
      .n_mo = n_bf
   end

   create(genre) ::: leaky, PURE
   ! Create the "genre" of the opmatrix
      self :: INOUT
      genre :: STR, IN

   ENSURE(.n_bf>0, "bad number of basis functions.")
   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      select case (genre)
      case ("r "); .r.create(.n_bf,.n_bf)
      case ("u "); .a.create(.n_bf,.n_bf)
                   .b.create(.n_bf,.n_bf)
      case ("gc"); .gc.create(2*.n_bf,2*.n_bf)
      end

   end

   create(n_bf,genre) ::: leaky, PURE
   ! Create an opmatrix object, set with "n_bf" spatial orbitals
   ! and with "genre".
      self :: allocatable, OUT
      n_bf :: INT, IN
      genre :: STR, IN
      .create(n_bf)
      .create(genre)
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy(genre) ::: leaky, PURE
   ! Destroy the appropriate spinorbital kind of the opmatrix
      self :: INOUT
      genre :: STR, IN

   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      select case (genre)
      case ("r ");  .r.destroy
      case ("u ");  .a.destroy; .b.destroy
      case ("gc"); .gc.destroy
      end

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of the opmatrix object
      self :: INOUT
      .r.destroy
      .a.destroy
      .b.destroy
      .gc.destroy
      .tri.destroy
      .sqr.destroy
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: pure
   ! Set defaults
      self :: INOUT
      .n_bf = 0
      .n_mo = 0
   end

   set(n_bf) ::: pure
   ! Set with "n_bf" spatial orbitals
      self :: INOUT
      n_bf :: INT, IN
      .n_bf = n_bf
   end

   set_to(mx) ::: leaky, pure
   ! Set "self" to "mx".
      self :: INOUT
      mx :: OPMATRIX, IN
      self = mx
   end

   set_to_zero ::: pure
   ! Set self to zero
      self :: INOUT
      if ( .r.allocated) .r  = ZERO
      if ( .a.allocated) .a  = ZERO
      if ( .b.allocated) .b  = ZERO
      if (.gc.allocated) .gc = (ZERO,ZERO)
   end

!  ===============
!  Inquiry methods
!  ===============

   genre result (res) ::: pure
   ! Return genre as a string length 2.
      self :: IN
      res :: STR(len=2)
      res = " "
      if      ( .r.allocated)                  then; res = "r "
      else if ( .a.allocated AND .b.allocated) then; res = "u "
      else if (.gc.allocated)                 then; res = "gc"
      end
   end

   has_any_genre result (res) ::: pure
   ! Returns true if any component of self has been created
   ! NOTE: the beta parts are NOT tested for creation.
      self :: IN
      res :: BIN

      c :: VEC{BIN}(3)

      c(1) =  .r.allocated
      c(2) =  .a.allocated AND .b.allocated
      c(3) = .gc.allocated

      res = any(c)

   end

   is_allocated_with_genre(genre) result (res) ::: PURE
   ! Returns FALSE if self is not allocated
   ! Returns FALSE, unless subkind "genre" of self has been created.
      self :: allocatable, IN
      genre :: STR, IN
      res :: BIN
      if (.deallocated) then; res = FALSE
      else;                   res = .has_genre(genre)
      end
   end

   is_deallocated_or_no_genre result (res) ::: pure
   ! Returns true if self is deallocated OR has all components of
   ! self have been deallocated.
      self :: allocatable, IN
      res :: BIN

      d :: VEC{BIN}(3)

      if (.deallocated) then
         res = TRUE
      else
         d(1) =  .r.deallocated
         d(2) =  .a.deallocated AND .b.deallocated
         d(3) = .gc.deallocated
         res = all(d)
      end

   end

   has_genre(genre) result (res) ::: PURE
   ! Returns FALSE, unless subkind "genre" of self has been created.
      self  :: IN
      genre :: STR, IN
      res   :: BIN

   ENSURE(genre.is_one_of(allowed_genres), "unknown genre, "//trim(genre))

      res = FALSE
      select case (genre)
      case ("r "); res = .r.allocated
      case ("u "); res = .a.allocated AND .b.allocated
      case ("gc"); res = .gc.allocated
      end

   end

   is_compatible_with(X) result (res) ::: pure
   ! Returns TRUE if the "self" and "X" are compatible
      self :: IN
      X :: OPMATRIX, IN
      res :: BIN

      cs,cx :: VEC{BIN}(8)

      cs(1) =   .r.allocated
      cs(2) =   .a.allocated AND  .b.allocated
      cs(3) =  .gc.allocated

      cx(1) =  X.r.allocated
      cx(2) =  X.a.allocated AND X.b.allocated
      cx(3) = X.gc.allocated
   

      res = all(cs EQV cx)

   end

!   is_compatible_with(X,genre) result (res) ::: PURE
!   ! Returns TRUE if the "self" and "X" are compatible
!      self :: IN
!      X :: OPMATRIX, IN
!      genre :: STR, IN
!      res :: BIN
!      res = .has_genre(genre) AND X.has_genre(genre)
!   end

   number_kind result (res) ::: pure
   ! Return the kind of numbers used in the representation
      self :: IN
      res :: STR
      select case (.genre)
      case("r "); res = "real"
      case("u "); res = "real"
      case("gc"); res = "complex"
      end
   end

!   same_spinorbital_kind_as(X) result (res) ::: pure
!   ! Return TRUE if "self" has the genre as "self" 
!   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
!      self :: IN
!      X :: OPMATRIX, IN
!      res :: BIN
!      res = .genre==X.genre
!   end

!   same_spinorbital_kind_as(X,genre) result (res) ::: PURE
!   ! Return TRUE if "X" has the same "genre" as "self" 
!   ! ****************************************************************
!   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
!   ! ****************************************************************
!      self :: IN
!      X :: OPMATRIX, IN
!      genre :: STR, IN
!      res :: BIN
!
!      res = .has_genre(genre) AND X.has_genre(genre)
!
!   end

!   spinorbital_kind(genre) result (res) ::: PURE
!   ! Return the kind of spinorbitals used in the representation
!   ! ****************************************************************
!   ! NOTE: The *simplest* spinorbital kind in use is the one returned.
!   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
!   ! ****************************************************************
!      self :: IN
!      genre :: STR, IN, optional
!      res :: STR
!
!   ENSURE(.has_any_genre OR present(genre),"no component created")
!
!      if (present(genre)) then
!
!         ENSURE(genre.is_one_of(allowed_kinds), "unknown genre, "//trim(genre))
!         res = genre
!
!      else
!
!         res = " "
!              if (.r.allocated)         then; res = "r "
!         else if (.a.allocated)         then; res = "u "
!         else if (.gc.allocated) then; res = "gc"
!         end
!
!      end
!
!   end

   occ_nos_genre result (res) ::: pure
   ! Return the kind of OPVECTOR used for the occupation numbers.
      self :: IN
      res :: STR
      res = " "
      if      ( .r.allocated)                  then; res = "r "
      else if ( .a.allocated AND .b.allocated) then; res = "u "
      else if (.gc.allocated)                  then; res = "gc"
      end
   end

   guess_SCF_kind result (res) ::: PURE
   ! Guess the kind of SCF to be used from the spinorbitals used in the
   ! representation. WARNING: use as a last resort.
      self :: IN
      res :: STR
      res = " "
      select case (.genre)
      case("r "); res = "rhf"
      case("u "); res = "uhf"
      case("gc"); res = "gchf"
      end
   end

!  ==========
!  Conversion
!  ==========

   convert_to(new,factor,destroy_original) ::: leaky
   ! Convert self to a "new" genre. To convert MO's please use the
   ! next routine.
      self :: INOUT
      new  :: STR, IN
      factor  :: REAL, optional, IN
      destroy_original :: BIN, optional, IN

      old :: STR
      destroy_old, fail :: BIN

      destroy_old = TRUE
      if (present(destroy_original)) destroy_old = destroy_original

      ! Done?
      old = .genre
      if (new==old) return

      .create(new)

      ! Convert old -> ne
      fail = FALSE
      select case (old)

      case("r ")
         select case (new)
         case("u ")
            if (present(factor)) then
               .a = .r*factor
               .b = .r*factor
            else
               .a = .r
               .b = .r
            end
         case("gc")
            .gc = ZERO
            if (present(factor)) then
               .gc.set_aa_block_to(.r,factor)
               .gc.set_bb_block_to(.r,factor)
            else
               .gc.set_aa_block_to(.r)
               .gc.set_bb_block_to(.r)
            end
         case default
            fail = TRUE
         end

      case("u ")

         select case (new)
         case("r ")
            if (present(factor)) then
               .r = .a*factor
            else
               .r = .a
            end
         case("gc")
            .gc = ZERO
            .gc.set_aa_block_to(.a)
            .gc.set_bb_block_to(.b)
         case default
            fail = TRUE
         end

      case default
         fail = TRUE

      end

      ! Clean
      if (destroy_old) .destroy(old)

      if (fail) then
         DIE("can't convert genre " // trim(old) // " to genre " // trim(new))
      end

   end

   convert_to(new,na,nb,quantization_axis) ::: leaky
   ! Convert self (a set of MO's) to a new genre "new"
      self :: INOUT
      new  :: STR, IN
      na,nb :: INT, IN
      quantization_axis :: VEC{REAL}(3), optional, IN

      old  :: STR
      d,ne :: INT
      quantize, fail :: BIN
      lam,tmp,ar,br,bi :: REAL

      d  = .n_bf
      ne = na + nb

      ! Done?
      old = .genre
      if (new==old) return

      ! Create the new (leaky)
      .create(new)

      fail = FALSE
      select case (old)

      case("r ")
         select case (new)
         case("u ")
            .a = .r
            .b  = .r
         case("gc")
            .gc = ZERO
            .gc(  1:d,     1:2*nb-1:2) = .r(:,   1:nb)
            .gc(d+1: ,     2:2*nb  :2) = .r(:,   1:nb)
            .gc(  1:d,2*nb+1:ne      ) = .r(:,nb+1:na)
            .gc(d+1: ,  ne+1:2*na    ) = .r(:,nb+1:na)
            .gc(  1:d,2*na+1:2*d -1:2) = .r(:,na+1: d)
            .gc(d+1: ,2*na+2:2*d   :2) = .r(:,na+1: d)
         case default
            fail = TRUE
         end
  
      case("u ")
         select case (new)
         case("r ")
            .r = .a ! Loss of information here
         case("gc")
            .gc = ZERO
            quantize = FALSE
            if (present(quantization_axis)) then
               quantize = NOT quantization_axis.equals((/ZERO,ZERO,ONE/))
            end
            if (quantize) then
               lam = quantization_axis.norm
               tmp = abs(quantization_axis(3)+lam) ! always positive anyway
               if (tmp.equals(ZERO)) then
                  ar = ZERO
                  br = ONE
                  bi = ZERO
               else
                  ar = sqrt(tmp/(TWO*lam))
                  br = ONE/sqrt(TWO*lam*tmp)
                  bi = br
                  br = br*quantization_axis(1)
                  bi = bi*quantization_axis(2)
               end
               .gc(d+1: ,     1:  na) = cmplx(br,bi,kind=CPX_KIND)*.a(:,   1:na)
               .gc(  1:d,     1:  na) =                         ar*.a(:,   1:na)
               .gc(d+1: ,  ne+1:nb+d) = cmplx(br,bi,kind=CPX_KIND)*.a(:,na+1: d)
               .gc(  1:d,  ne+1:nb+d) =                         ar*.a(:,na+1: d)
               br = -br
               .gc(  1:d,  na+1:ne  ) = cmplx(br,bi,kind=CPX_KIND)*.b (:,   1:nb)
               .gc(d+1: ,  na+1:ne  ) =                         ar*.b (:,   1:nb)
               .gc(  1:d,nb+d+1:    ) = cmplx(br,bi,kind=CPX_KIND)*.b (:,nb+1: d)
               .gc(d+1: ,nb+d+1:    ) =                         ar*.b (:,nb+1: d)
            else
               .gc(  1:d,     1:na  ) = .a(:,   1:na)
               .gc(d+1: ,  na+1:ne  ) = .b(:,   1:nb)
               .gc(  1:d,  ne+1:nb+d) = .a(:,na+1:  )
               .gc(d+1: ,nb+d+1:    ) = .b(:,nb+1:  )
            end

         case default
            fail = TRUE
         end
  
      case default
         fail = TRUE

      end

      ! Clean?
      .destroy(old)

      if (fail) then
         DIE("can't convert genre " // trim(old) // " to genre " // trim(new))
      end

   end

!  ===========
!  Compression
!  ===========

   l_compress(genre) result (res) ::: PURE
   ! Return the length of the compressed object
      self :: IN
      genre :: STR, optional, IN
      res :: INT

      k :: STR

      if (present(genre)) then; k =  genre
      else;                     k = .genre
      end

      res = 0
      select case (k)
      case("r "); res = int(HALF*.n_bf*(.n_bf+1))
      case("u "); res =   .n_bf*(.n_bf+1)
      case("gc"); res = 4*.n_bf*.n_bf
      end

   end

   compress(genre) ::: leaky, PURE
   ! Compress the opmatrix into a triangle or square vector 
   ! to save space
      self :: INOUT
      genre :: STR, optional, IN

      k :: STR
      l :: INT
      W :: VEC{REAL}@

      k = .genre
      if (present(genre)) k = genre

      select case (k)

      case("r ")
         .tri.destroy
         .tri.create(.l_compress(k))
         .r.zip_lower_triangle_to(.tri)
         .r.destroy

      case("u ")
         l = .l_compress(k)
         .tri.destroy
         .tri.create(l)
         W.create(l/2)
         .a.zip_lower_triangle_to(W); .tri.set_a_block_to(W)
         .b.zip_lower_triangle_to(W); .tri.set_b_block_to(W)
         W.destroy
         .a.destroy
         .b.destroy

      case("gc")
         .sqr.destroy
         .sqr.create(.l_compress(k))
         .gc.zip_lower_triangles_to(.sqr)
         .gc.destroy

      end

   end

   uncompress ::: leaky, PURE
   ! Uncompress the opmatrix
      self :: INOUT
      l :: INT

      l = -1
      if (.tri.allocated) l = size(.tri)
      if (.sqr.allocated) l = size(.sqr)

      if      (l==.l_compress("r ")) then
            .destroy("r ")
             .create("r ")
            .r.symmetric_unzip_triangle(.tri)
            .tri.destroy

      else if (l==.l_compress("u ")) then
            .destroy("u ")
             .create("u ")
            .a.symmetric_unzip_triangle(.tri.a_block)
            .b.symmetric_unzip_triangle(.tri.b_block)
            .tri.destroy

      else if (l==.l_compress("gc")) then
            .destroy("gc")
             .create("gc")
            .gc.hermitian_unzip_triangles(.sqr)
            .sqr.destroy

      end

   end

!  ===============
!  Math operations
!  ===============

   plus(X,genre) ::: PURE
   ! Add "X" to "self", only the right genre
      self :: INOUT
      X :: OPMATRIX, IN
      genre :: STR, optional, IN

      k :: STR

      k = .genre
      if (present(genre)) k = genre

      select case (k)
      case("r "); .r  = .r  + X.r
      case("u "); .a  = .a  + X.a
                  .b  = .b + X.b
      case("gc"); .gc = .gc + X.gc
      end

   end

   minus(X,genre) ::: PURE
   ! Subtract "X" from "self", only the right genre
      self :: INOUT
      X :: OPMATRIX, IN
      genre :: STR, optional, IN

      k :: STR

      k = .genre
      if (present(genre)) k = genre

      select case (k)
      case("r "); .r  = .r  - X.r
      case("u "); .a  = .a  - X.a
                  .b  = .b  - X.b
      case("gc"); .gc = .gc - X.gc
      end

   end

   scale_by(fac) ::: PURE
   ! Set "self" to a scaled version of itself.
      self :: INOUT
      fac :: REAL, IN

      select case (.genre)
      case("r "); .r  = fac*.r
      case("u "); .a  = fac*.a
                  .b  = fac*.b
      case("gc"); .gc = fac*.gc
      end

   end

   to_scaled(X,fac) ::: PURE
   ! Set "self" to a scaled version of "X". The two must be compatible.
      self :: OUT
      X :: OPMATRIX, IN
      fac :: REAL, IN

      select case (.genre)
      case("r "); .r  = fac*X.r
      case("u "); .a  = fac*X.a
                  .b  = fac*X.b
      case("gc"); .gc = fac*X.gc
      end

   end

   plus_scaled(X,fac) ::: PURE
   ! Add to "self" a scaled version of "X".
      self :: OUT
      X :: OPMATRIX, IN
      fac :: REAL, IN

      select case (.genre)
      case("r "); .r  = .r  + fac*X.r
      case("u "); .a  = .a  + fac*X.a
                  .b  = .b  + fac*X.b
      case("gc"); .gc = .gc + fac*X.gc
      end

   end

   to_product_of(X,Y) ::: leaky, PURE
   ! Set "self" to product of "X" times "self", for all genres. 
      self :: OUT
      X :: MAT{REAL}, IN
      Y :: OPMATRIX, IN

      if (Y.r.allocated)  .r  = matmul(X,Y.r)
      if (Y.a.allocated)  .a  = matmul(X,Y.a)
      if (Y.b.allocated)  .b  = matmul(X,Y.b)
      if (Y.gc.allocated) .gc = matmul(X,Y.gc)

   end

   to_product_of(X,Y) ::: leaky, PURE
   ! Set "self" to product of "X" times "self", for all genres. 
      self :: OUT
      X,Y :: OPMATRIX, IN

      if (X.r.allocated)  .r  = matmul(X.r ,Y.r )
      if (X.a.allocated)  .a  = matmul(X.a ,Y.a )
      if (X.b.allocated)  .b  = matmul(X.b ,Y.b )
      if (X.gc.allocated) .gc = matmul(X.gc,Y.gc)

   end

   damp(old,mix) ::: PURE
   ! Constructs the new self matrix by combining it with the "old" one
   ! using a "mix" factor, i.e.  self = (1-mix)*self + mix*old.
      self :: INOUT
      old  :: OPMATRIX, IN
      mix  :: REAL, IN
      .scale_by(ONE-mix)
      .plus_scaled(old,mix)
   end

   expectation(X) result (res)
   ! Expectation value of the matrix "X": res = Trace (X.self)
      self :: IN
      X    :: OPMATRIX, IN
      res  :: REAL

   ENSURE(X.n_bf==.n_bf,"wrong X dimension")

      res = ZERO
      select case (.genre)
      case("r "); res = .r.trace_product_with(X.r)
      case("u "); res = .a.trace_product_with(X.a) + .b.trace_product_with(X.b)
      case("gc"); res = RE(.gc.trace_product_with(X.gc))
      end

   end

   expectation(X) result (res)
   ! Expectation value of the matrix "X": res = Trace (X.self)
      self :: IN
      X    :: MAT{REAL}, IN
      res  :: REAL

   ENSURE(X.dim1==.n_bf,"wrong X dimension")
   ENSURE(X.is_square,"X is not square")

      res = ZERO
      select case (.genre)
      case("r "); res = .r.trace_product_with(X)
      case("u "); res = .a.trace_product_with(X) + .b.trace_product_with(X)
      case("gc"); res = RE(.gc.trace_product_with(X))
      end

   end

!  ==================
!  Orthonormalization
!  ==================

   Schmidt_orthonormalise(S,scale) ::: PURE
   ! Schmidt Orthonormalise self.  (For molecular orbitals).
      self :: INOUT
      S    :: MAT{REAL}, IN
      scale :: REAL, optional, OUT

      SS :: MAT{REAL}@
      n  :: INT

      select case(.genre)

      case("r ")
         .r.Schmidt_orthonormalise(S,scale)

      case("u ")
         .a.Schmidt_orthonormalise(S)
         .b.Schmidt_orthonormalise(S)

      case("gc")
         n = 2*S.dim1
         SS.create(n,n)
         SS = ZERO
         SS.set_aa_block_to(S)
         SS.set_bb_block_to(S)
         .gc.Schmidt_orthonormalise(SS,scale)
         SS.destroy

      end

   end

   symmetrically_orthonormalise(S) ::: PURE
   ! Symmetrically orthonormalise self. (For molecular orbitals).
   ! "S" is the AO overlap matrix.
      self :: INOUT
      S    :: MAT{REAL}, IN


      SS :: MAT{REAL}@
      n  :: INT

      select case(.genre)

      case("r ")
         .r.symmetrically_orthonormalise(S)

      case("u ")
         .a.symmetrically_orthonormalise(S)
         .b.symmetrically_orthonormalise(S)

      case("gc")
         n = 2*S.dim1
         SS.create(n,n)
         SS = ZERO
         ENSURE(SS.dim1==2*S.dim1,"wrong size, S")
         SS.set_aa_block_to(S)
         SS.set_bb_block_to(S)
         .gc.symmetrically_orthonormalise(SS)
         SS.destroy

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

!  ===============================
!  Normalisation & unnormalisation
!  ===============================

   unnormalise(first,last,angmom) ::: PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      first,last,angmom :: VEC{INT}, IN

      select case(.genre)

      case("r ")
         GAUSSIAN_DATA:unnormalise(.r,first,last,angmom)

      case("u ")
         GAUSSIAN_DATA:unnormalise(.a,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.b,first,last,angmom)

      case("gc")
         GAUSSIAN_DATA:unnormalise(.gc(      1:.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.gc(      1:.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.gc(.n_bf+1:.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.gc(.n_bf+1:.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)

      end

   end

   unnormalise(ind,first,last,angmom) ::: PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      ind :: STR, IN
      first,last,angmom :: VEC{INT}, IN

      select case(.genre)

      case("r ")
         GAUSSIAN_DATA:unnormalise(.r,ind,first,last,angmom)

      case("u ")
         GAUSSIAN_DATA:unnormalise(.a,ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.b,ind,first,last,angmom)

      case("gc")
         GAUSSIAN_DATA:unnormalise(.gc(      1:  .n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.gc(      1:  .n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.gc(.n_bf+1:2*.n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.gc(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)

      end

   end

   renormalise(first,last,angmom) ::: PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      first,last,angmom :: VEC{INT}, IN

      select case(.genre)

      case("r ")
         GAUSSIAN_DATA:renormalise(.r,first,last,angmom)

      case("u ")
         GAUSSIAN_DATA:renormalise(.a,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.b,first,last,angmom)

      case("gc")
         GAUSSIAN_DATA:renormalise(.gc(      1:  .n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.gc(      1:  .n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.gc(.n_bf+1:2*.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.gc(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)

      end

   end

   renormalise(ind,first,last,angmom) ::: PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      ind :: STR, IN
      first,last,angmom :: VEC{INT}, IN

      select case(.genre)

      case("r ")
         GAUSSIAN_DATA:renormalise(.r,ind,first,last,angmom)

      case("u ")
         GAUSSIAN_DATA:renormalise(.a,ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.b,ind,first,last,angmom)

      case("gc")
         GAUSSIAN_DATA:renormalise(.gc(      1:  .n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.gc(      1:  .n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.gc(.n_bf+1:2*.n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.gc(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)

      end

   end

end
