!===================================================================
!
! OPMATRIX: Operator matrices.
!
! Provide a basis set (matrix) representation of a one-electron
! quantum mechanical operator. Can cope with polymorphic types of
! basis representations, including restricted, unrestricted, and
! general basis orbital matrices.  Also, complex types for all these
! matrices.
!
! Basically, its a polymorphic matrix type.
!
! Copyright (C) Dylan Jayatilaka 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module OPMATRIX

   implicit none

   allowed_kinds :: VEC{STR}(len=20,10)

   data allowed_kinds/ &
      "restricted          ",  &
      "unrestricted        ",  &
      "alpha               ",  &
      "beta                ",  &
      "general             ",  &
      "restricted_complex  ",  &
      "unrestricted_complex",  &
      "alpha_complex       ",  &
      "beta_complex        ",  &
      "general_complex     "   /

contains

! ==========
! Allocation
! ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   create(n_bf) ::: leaky, PURE
   ! Create an opmatrix object, in a basis set with "n_bf" spatial orbitals
      self :: allocatable, OUT
      n_bf :: INT, IN

      .create
      .n_bf = n_bf
      .n_mo = n_bf

   end

   create(genre) ::: leaky, PURE
   ! Create the appropriate spinorbital kind the opmatrix
      self :: INOUT
      genre :: STR, IN

   ENSURE(.n_bf>0, "bad number of basis functions.")
   ENSURE(genre.is_one_of(allowed_kinds), "unknown genre, "//trim(genre))

      select case (genre)

      ! Real
      case (  "restricted");         .restricted.create(.n_bf,.n_bf)
      case ("unrestricted");              .alpha.create(.n_bf,.n_bf)
                                           .beta.create(.n_bf,.n_bf)
      case (       "alpha");              .alpha.create(.n_bf,.n_bf)
      case (        "beta");               .beta.create(.n_bf,.n_bf)
      case (     "general");            .general.create(2*.n_bf,2*.n_bf)

      ! Complex
      case (  "restricted_complex"); .restricted_complex.create(.n_bf,.n_bf)
      case ("unrestricted_complex");      .alpha_complex.create(.n_bf,.n_bf)
                                           .beta_complex.create(.n_bf,.n_bf)
      case (       "alpha_complex");      .alpha_complex.create(.n_bf,.n_bf)
      case (        "beta_complex");       .beta_complex.create(.n_bf,.n_bf)
      case (     "general_complex");    .general_complex.create(2*.n_bf,2*.n_bf)

      end

   end

   create(n_bf,genre) ::: leaky, PURE
   ! Create an opmatrix object, in a basis set with "n_bf" spatial orbitals
      self :: allocatable, OUT
      n_bf :: INT, IN
      genre :: STR, IN

      .create(n_bf)
      .create(genre)

   end

   create(n_bf,n_mo,genre) ::: leaky, PURE
   ! Create an opmatrix object, in a basis set with "n_bf" spatial orbitals
      self :: allocatable, OUT
      n_bf :: INT, IN
      n_mo :: INT, IN
      genre :: STR, IN

   ENSURE(n_bf>0, "bad number of basis functions.")
   ENSURE(n_mo>0, "bad number of basis functions.")
   ENSURE(genre=="general", "only for general ELMO/ALO case.")


      .create

      .n_bf = n_bf
      .n_mo = n_mo

      .general.create(2*.n_bf,.n_mo)

   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy(genre) ::: leaky, PURE
   ! Destroy the appropriate spinorbital kind of the opmatrix
      self :: INOUT
      genre :: STR, IN

   ENSURE(genre.is_one_of(allowed_kinds), "unknown genre, "//trim(genre))

      select case (genre)
      case (  "restricted");         .restricted.destroy
      case ("unrestricted");              .alpha.destroy
                                           .beta.destroy
      case (       "alpha");              .alpha.destroy
      case (        "beta");               .beta.destroy
      case (     "general");            .general.destroy
      ! Complex
      case (  "restricted_complex"); .restricted_complex.destroy
      case ("unrestricted_complex");      .alpha_complex.destroy
                                          .beta_complex.destroy
      case (       "alpha_complex");     .alpha_complex.destroy
      case (        "beta_complex");      .beta_complex.destroy
      case (     "general_complex");   .general_complex.destroy
      end

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of the opmatrix object
      self :: INOUT

      .restricted.destroy
      .alpha.destroy
      .beta.destroy
      .general.destroy
      .restricted_complex.destroy
      .alpha_complex.destroy
      .beta_complex.destroy
      .general_complex.destroy
      .triangle.destroy
      .square.destroy

   end

!  ====
!  Copy
!  ====

   create_copy(mx) ::: leaky, PURE
   ! Create an opmatrix object
      self :: allocatable, OUT
      mx :: OPMATRIX, IN

      self = mx

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: pure
   ! Set defaults
      self :: INOUT

      .n_bf = 0

   end

   set_to(mx) ::: leaky, PURE
   ! Set "self" to "mx".
      self :: INOUT
      mx :: OPMATRIX, IN

      .set(mx.n_bf)

      .destroy_ptr_part

      if (mx.restricted.allocated)         .restricted = mx.restricted
      if (mx.alpha.allocated)              .alpha = mx.alpha
      if (mx.beta.allocated)               .beta = mx.beta
      if (mx.general.allocated)            .general = mx.general
      if (mx.restricted_complex.allocated) .restricted_complex = mx.restricted_complex
      if (mx.alpha_complex.allocated)      .alpha_complex = mx.alpha_complex
      if (mx.beta_complex.allocated)       .beta_complex = mx.beta_complex
      if (mx.general_complex.allocated)    .general_complex = mx.general_complex

   end

   set(n_bf) ::: pure
   ! Set with "n_bf" spatial orbitals
      self :: INOUT
      n_bf :: INT, IN

      .n_bf = n_bf
   
   end

   set_to_zero ::: pure
   ! Set self to zero
      self :: INOUT

      if (.restricted.allocated)         .restricted = ZERO
      if (.alpha.allocated)              .alpha      = ZERO
      if (.beta.allocated)               .beta       = ZERO
      if (.general.allocated)            .general    = ZERO

      if (.restricted_complex.allocated) .restricted_complex = (ZERO,ZERO)
      if (.alpha_complex.allocated)      .alpha_complex      = (ZERO,ZERO)
      if (.beta_complex.allocated)       .beta_complex       = (ZERO,ZERO)
      if (.general_complex.allocated)    .general_complex    = (ZERO,ZERO)

   end

!  ===============
!  Inquiry methods
!  ===============

   has_any_genre result (res) ::: pure
   ! Returns true if any component of self has been created
   ! NOTE: the beta parts are NOT tested for creation.
      self :: IN
      res :: BIN

      c :: BIN, dimension(6)

      c(1) = .restricted.allocated
      c(2) = .alpha.allocated
      c(3) = .general.allocated
      c(4) = .restricted_complex.allocated
      c(5) = .alpha_complex.allocated
      c(6) = .general_complex.allocated

      res = any(c)

   end

   is_deallocated_or_no_genre result (res) ::: pure
   ! Returns true if self is deallocated OR has all components of
   ! self have been deallocated.  NOTE: the beta parts are NOT
   ! tested.
      self :: allocatable, IN
      res :: BIN

      d :: BIN, dimension(6)

      if (.deallocated) then

         res = TRUE

      else

         d(1) = .restricted.deallocated
         d(2) = .alpha.deallocated
         d(3) = .general.deallocated
         d(4) = .restricted_complex.deallocated
         d(5) = .alpha_complex.deallocated
         d(6) = .general_complex.deallocated
         res = all(d)

      end

   end

   is_allocated_with_genre(genre) result (res) ::: PURE
   ! Returns FALSE if self is not allocated
   ! Returns FALSE, unless subkind "genre" of self has been created.
      self :: allocatable, IN
      genre :: STR, IN
      res :: BIN

      if (.deallocated) then; res = FALSE
      else;                   res = .has_genre(genre)
      end

   end

   has_genre(genre) result (res) ::: PURE
   ! Returns FALSE, unless subkind "genre" of self has been created.
      self :: IN
      genre :: STR, IN
      res :: BIN

   ENSURE(genre.is_one_of(allowed_kinds), "unknown genre, "//trim(genre))

      res = FALSE

      select case (genre)

      ! Real
      case (  "restricted");         res = .restricted.allocated
      case ("unrestricted");         res =      .alpha.allocated         AND .beta.allocated
      case (       "alpha");         res =      .alpha.allocated
      case (        "beta");         res =       .beta.allocated
      case (     "general");         res =    .general.allocated

      ! Complex
      case (  "restricted_complex"); res = .restricted_complex.allocated
      case ("unrestricted_complex"); res =      .alpha_complex.allocated AND .beta_complex.allocated
      case (       "alpha_complex"); res =      .alpha_complex.allocated
      case (        "beta_complex"); res =       .beta_complex.allocated
      case (     "general_complex"); res =    .general_complex.allocated

      end

   end

   has_genre_str result (res) ::: pure
   ! Return has_genre as a string
      self :: IN
      res :: STR

      ss :: STR

      ss = repeat("F",8)
      if (.restricted.allocated)         ss(1:1) = "T"
      if (    .alpha.allocated)          ss(2:2) = "T"
      if (     .beta.allocated)          ss(3:3) = "T"
      if (  .general.allocated)          ss(4:4) = "T"
      if (.restricted_complex.allocated) ss(5:5) = "T"
      if (     .alpha_complex.allocated) ss(6:6) = "T"
      if (      .beta_complex.allocated) ss(7:7) = "T"
      if (   .general_complex.allocated) ss(8:8) = "T"

      res =  "r:"//ss(1:1)//" "// &
             "a:"//ss(2:2)//" "// & 
             "b:"//ss(3:3)//" "// & 
             "g:"//ss(4:4)//" "// & 
            "rc:"//ss(5:5)//" "// & 
            "ac:"//ss(6:6)//" "// & 
            "bc:"//ss(7:7)//" "// & 
            "gc:"//ss(8:8)

   end

   has_genre_strs(X) result (res) ::: pure
   ! Returns the side-by-side has_genre strings for "self" and "X".
   ! Usefule checking if compatbile or addable.
      self :: IN
      X :: OPMATRIX, IN
      res :: STR

      ss,sx :: STR

      ss = repeat("F",8)
      if (.restricted.allocated)         ss(1:1) = "T"
      if (     .alpha.allocated)         ss(2:2) = "T"
      if (      .beta.allocated)         ss(3:3) = "T"
      if (   .general.allocated)         ss(4:4) = "T"
      if (.restricted_complex.allocated) ss(5:5) = "T"
      if (     .alpha_complex.allocated) ss(6:6) = "T"
      if (      .beta_complex.allocated) ss(7:7) = "T"
      if (   .general_complex.allocated) ss(8:8) = "T"

      sx = repeat("F",8)
      if (X.restricted.allocated)         sx(1:1) = "T"
      if (     X.alpha.allocated)         sx(2:2) = "T"
      if (      X.beta.allocated)         sx(3:3) = "T"
      if (   X.general.allocated)         sx(4:4) = "T"
      if (X.restricted_complex.allocated) sx(5:5) = "T"
      if (     X.alpha_complex.allocated) sx(6:6) = "T"
      if (      X.beta_complex.allocated) sx(7:7) = "T"
      if (   X.general_complex.allocated) sx(8:8) = "T"

      res =  "r:"//ss(1:1)//sx(1:1)//" "// &
             "a:"//ss(2:2)//sx(2:2)//" "// & 
             "b:"//ss(3:3)//sx(3:3)//" "// & 
             "g:"//ss(4:4)//sx(4:4)//" "// & 
            "rc:"//ss(5:5)//sx(5:5)//" "// & 
            "ac:"//ss(6:6)//sx(6:6)//" "// & 
            "bc:"//ss(7:7)//sx(7:7)//" "// & 
            "gc:"//ss(8:8)//sx(8:8)

   end

   is_compatible_with(X) result (res) ::: pure
   ! Returns TRUE if the "self" and "X" are compatible
      self :: IN
      X :: OPMATRIX, IN
      res :: BIN

      cs,cx :: VEC{BIN}(8)

      cs(1) = .restricted.allocated
      cs(2) =      .alpha.allocated
      cs(3) =       .beta.allocated
      cs(4) =    .general.allocated
      cs(5) = .restricted_complex.allocated
      cs(6) =      .alpha_complex.allocated
      cs(7) =       .beta_complex.allocated
      cs(8) =    .general_complex.allocated
   
      cx(1) = X.restricted.allocated
      cx(2) =      X.alpha.allocated
      cx(3) =       X.beta.allocated
      cx(4) =    X.general.allocated
      cx(5) = X.restricted_complex.allocated
      cx(6) =      X.alpha_complex.allocated
      cx(7) =       X.beta_complex.allocated
      cx(8) =    X.general_complex.allocated

      res = all(cs EQV cx)

   end

   is_compatible_with(X,genre) result (res) ::: PURE
   ! Returns TRUE if the "self" and "X" are compatible
      self :: IN
      X :: OPMATRIX, IN
      genre :: STR, IN
      res :: BIN

      res = .has_genre(genre) AND X.has_genre(genre)

   end

   is_addable_with(X) result (res) ::: pure
   ! Returns TRUE if the "self" is addable with "X" 
   ! i.e. All genres in "self" are defined in "X".
      self :: IN
      X :: OPMATRIX, IN
      res :: BIN

      cs,cx :: VEC{BIN}(8)

      cs(1) = .restricted.allocated
      cs(2) = .alpha.allocated
      cs(3) = .beta.allocated
      cs(4) = .general.allocated
      cs(5) = .restricted_complex.allocated
      cs(6) = .alpha_complex.allocated
      cs(7) = .beta_complex.allocated
      cs(8) = .general_complex.allocated

      cx(1) = X.restricted.allocated
      cx(2) = X.alpha.allocated
      cx(3) = X.beta.allocated
      cx(4) = X.general.allocated
      cx(5) = X.restricted_complex.allocated
      cx(6) = X.alpha_complex.allocated
      cx(7) = X.beta_complex.allocated
      cx(8) = X.general_complex.allocated

      ! Not addable if cs(i) is there but no cx(i)
      res = NOT any(cs AND NOT cx)

   end

   number_kind result (res) ::: pure
   ! Return the kind of numbers used in the representation
      self :: IN
      res :: STR

      res = " "
      if      (.restricted.allocated )         then; res = "real"
      else if (.alpha.allocated )              then; res = "real"
      else if (.general.allocated )            then; res = "real"
      else if (.restricted_complex.allocated ) then; res = "complex"
      else if (.alpha_complex.allocated )      then; res = "complex"
      else if (.general_complex.allocated )    then; res = "complex"
      end

   end

   same_spinorbital_kind_as(X) result (res) ::: PURE
   ! Return TRUE if "X" has the same spinorbital_kind and "self" 
   ! ****************************************************************
   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
   ! ****************************************************************
      self :: IN
      X :: OPMATRIX, IN
      res :: BIN

      res = .spinorbital_kind==X.spinorbital_kind

   end

   same_spinorbital_kind_as(X,genre) result (res) ::: PURE
   ! Return TRUE if "X" has the same "genre" as "self" 
   ! ****************************************************************
   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
   ! ****************************************************************
      self :: IN
      X :: OPMATRIX, IN
      genre :: STR, IN
      res :: BIN

      res = .has_genre(genre) AND X.has_genre(genre)

   end

   spinorbital_kind(genre) result (res) ::: PURE
   ! Return the kind of spinorbitals used in the representation
   ! ****************************************************************
   ! NOTE: The *simplest* spinorbital kind in use is the one returned.
   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
   ! ****************************************************************
      self :: IN
      genre :: STR, IN, optional
      res :: STR

   ENSURE(.has_any_genre OR present(genre),"no component created")

      if (present(genre)) then

         ENSURE(genre.is_one_of(allowed_kinds), "unknown genre, "//trim(genre))
         res = genre

      else

         res = " "
              if (.restricted.allocated)         then; res = "restricted"
         else if (     .alpha.allocated)         then; res = "unrestricted"
         else if (   .general.allocated)         then; res = "general"
         else if (.restricted_complex.allocated) then; res = "restricted_complex"
         else if (     .alpha_complex.allocated) then; res = "unrestricted_complex"
         else if (   .general_complex.allocated) then; res = "general_complex"
         end

      end

   end

   occupation_spinorbital_kind(genre) result (res) ::: PURE
   ! Return the kind of spinorbitals used for the occupation numbers.
   ! ****************************************************************
   ! NOTE: The *simplest* spinorbital kind in use is the one returned.
   ! NOTE: Use as a last resort. Use the scfdata.scf_kind if possible.
   ! ****************************************************************
      self :: IN
      genre :: STR, IN, optional
      res :: STR

   ENSURE(.has_any_genre OR present(genre),"no component created")

      if (present(genre)) then

         ENSURE(genre.is_one_of(allowed_kinds), "unknown genre, "//trim(genre))
         res = genre

      else

         res = " "
              if (.restricted.allocated)         then; res = "restricted"
         else if (     .alpha.allocated)         then; res = "restricted"
         else if (   .general.allocated)         then; res = "general"
         else if (.restricted_complex.allocated) then; res = "restricted"
         else if (     .alpha_complex.allocated) then; res = "restricted"
         else if (   .general_complex.allocated) then; res = "general"
         end

      end

   end

   guess_scf_kind result (res) ::: pure
   ! Guess the kind of SCF to be used from the spinorbitals used in the
   ! representation. WARNING: use as a last resort.
      self :: IN
      res :: STR

      res = " "
           if (.alpha.allocated )              then; res = "uhf"
      else if (.restricted.allocated )         then; res = "rhf"
      else if (.general.allocated )            then; res = "ghf"
      else if (.restricted_complex.allocated ) then; res = "rchf"
      else if (.alpha_complex.allocated )      then; res = "uchf"
      else if (.general_complex.allocated )    then; res = "gchf"
      end

   end

!  ==========================
!  Conversion and compression
!  ==========================

   convert_to(newkind,factor,destroy_original) ::: leaky
   ! Convert self to a new basis kind "newkind".  To convert MO's
   ! please use the next routine.
      self :: INOUT
      newkind :: STR, IN
      factor :: REAL, optional
      destroy_original :: BIN, optional

      oldkind :: STR
      destroy_oldkind :: BIN

      destroy_oldkind = TRUE
      if (present(destroy_original)) destroy_oldkind = destroy_original

      oldkind = .spinorbital_kind
      if (newkind==oldkind) return

      .create(newkind)

      ! Convert oldkind -> newkind
      select case (oldkind)

         case("restricted")

            select case (newkind)

               case("unrestricted")
                  if (present(factor)) then
                     .alpha = factor*.restricted
                     .beta  = factor*.restricted
                  else
                     .alpha =        .restricted
                     .beta  =        .restricted
                  end

               case("general")
                  .general = ZERO
                  if (present(factor)) then
                     .general.set_aa_block_to(.restricted,factor)
                     .general.set_bb_block_to(.restricted,factor)
                  else
                     .general.set_aa_block_to(.restricted)
                     .general.set_bb_block_to(.restricted)
                  end

               case("restricted_complex")
                  .restricted_complex = .restricted

               case("unrestricted_complex")
                  if (present(factor)) then
                     .alpha_complex = factor*.restricted
                     .beta_complex  = factor*.restricted
                  else
                     .alpha_complex =        .restricted
                     .beta_complex  =        .restricted
                  end

               case("general_complex")
                  .general_complex = ZERO
                  if (present(factor)) then
                     .general_complex.set_aa_block_to(.restricted,factor)
                     .general_complex.set_bb_block_to(.restricted,factor)
                  else
                     .general_complex.set_aa_block_to(.restricted)
                     .general_complex.set_bb_block_to(.restricted)
                  end

               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))

            end

         case("unrestricted")

            select case (newkind)

               case("restricted")
                  if (present(factor)) then
                     .restricted = factor*.alpha
                  else
                     .restricted =        .alpha
                  end

               case("general")
                  .general = ZERO
                  .general.set_aa_block_to(.alpha)
                  .general.set_bb_block_to(.beta)

               case("unrestricted_complex")
                  .alpha_complex = .alpha
                  .beta_complex  = .beta

               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.set_aa_block_to(.alpha)
                  .general_complex.set_bb_block_to(.beta)

               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))

            end

         case("general")

            select case (newkind)

               case("unrestricted")
                  .general.put_aa_block_to(.alpha)
                  .general.put_bb_block_to(.beta)

               case("general_complex")
                  .general_complex = .general

               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))

            end

         case default

            DIE("cant convert old kind "//trim(oldkind))

      end

      ! Clean
      if (destroy_oldkind) .destroy(oldkind)

   end

   convert_to(newkind,na,nb,quantization_axis) ::: leaky
   ! Convert self (which is regarded to be a set of MO's) to a
   ! new basis kind "newkind"
      newkind :: STR
      na,nb :: INT
      quantization_axis :: VEC{REAL}(3), optional

      quantize :: BIN
      oldkind :: STR
      d,ne :: INT
      lam,tmp,ar,br,bi :: REAL

      d = .n_bf
      ne = na + nb

      oldkind = .spinorbital_kind
      if (newkind==oldkind) return

      ! Create the new (leaky)
      .create(newkind)

      select case (oldkind)

         case("restricted")
  
            select case (newkind)

               case("unrestricted")
                  .alpha = .restricted
                  .beta  = .restricted

               case("general")
                  .general = ZERO
                  .general(  1:d,     1:2*nb-1:2) = .restricted(:,   1:nb)
                  .general(d+1: ,     2:2*nb  :2) = .restricted(:,   1:nb)
                  .general(  1:d,2*nb+1:ne      ) = .restricted(:,nb+1:na)
                  .general(d+1: ,  ne+1:2*na    ) = .restricted(:,nb+1:na)
                  .general(1:d  ,2*na+1:2*d -1:2) = .restricted(:,na+1: d)
                  .general(d+1: ,2*na+2:2*d   :2) = .restricted(:,na+1: d)

               case("restricted_complex")
                  .restricted_complex = .restricted

               case("unrestricted_complex")
                  .alpha_complex = .restricted
                  .beta_complex  = .restricted

               case("general_complex")
                  .general_complex = ZERO
                  .general_complex(  1:d,     1:2*nb-1:2) = .restricted(:,   1:nb)
                  .general_complex(d+1: ,     2:2*nb  :2) = .restricted(:,   1:nb)
                  .general_complex(  1:d,2*nb+1:ne      ) = .restricted(:,nb+1:na)
                  .general_complex(d+1: ,  ne+1:2*na    ) = .restricted(:,nb+1:na)
                  .general_complex(  1:d,2*na+1:2*d -1:2) = .restricted(:,na+1: d)
                  .general_complex(d+1: ,2*na+2:2*d   :2) = .restricted(:,na+1: d)

               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))

            end
  
         case("unrestricted")
  
            select case (newkind)

               case("restricted","alpha")
                  .restricted = .alpha ! Loss of information here
                  WARN("Conversion from unrestricted to restricted ignores beta orbitals")

               case("beta")
                  .restricted = .beta  ! Loss of information here
                  WARN("Conversion from unrestricted to restricted ignores alpha orbitals")

               case("general")
                  .general = ZERO
                  .general(  1:d,     1:2*nb-1:2) = .alpha(:,   1:nb)
                  .general(d+1: ,     2:2*nb  :2) = .beta (:,   1:nb)
                  .general(  1:d,2*nb+1:ne      ) = .alpha(:,nb+1:na)
                  .general(d+1: ,  ne+1:2*na    ) = .beta (:,nb+1:na)
                  .general(  1:d,2*na+1:2*d -1:2) = .alpha(:,na+1: d)
                  .general(d+1: ,2*na+2:2*d   :2) = .beta (:,na+1: d)

               case("unrestricted_complex")
                  .alpha_complex = .alpha
                  .beta_complex  = .beta

               case("general_complex")

                  .general_complex = ZERO

                  quantize = FALSE
                  if (present(quantization_axis)) &
                     quantize = NOT quantization_axis.equals((/ZERO,ZERO,ONE/))

                  if (quantize) then

                     lam = quantization_axis.norm
                     tmp = abs(quantization_axis(3)+lam) ! always positive anyway
                     if (tmp.equals(ZERO)) then
                        ar = ZERO
                        br = ONE
                        bi = ZERO
                     else
                        ar = sqrt(tmp/(TWO*lam))
                        br = ONE/sqrt(TWO*lam*tmp)
                        bi = br
                        br = br*quantization_axis(1)
                        bi = bi*quantization_axis(2)
                     end
                     .general_complex(d+1: ,     1:  na) = cmplx(br,bi,kind=CPX_KIND)*.alpha(:,   1:na)
                     .general_complex(  1:d,     1:  na) =           ar*.alpha(:,   1:na)
                     .general_complex(d+1: ,  ne+1:nb+d) = cmplx(br,bi,kind=CPX_KIND)*.alpha(:,na+1: d)
                     .general_complex(  1:d,  ne+1:nb+d) =           ar*.alpha(:,na+1: d)
                     br = -br
                     .general_complex(  1:d,  na+1:ne  ) = cmplx(br,bi,kind=CPX_KIND)*.beta (:,   1:nb)
                     .general_complex(d+1: ,  na+1:ne  ) =           ar*.beta (:,   1:nb)
                     .general_complex(  1:d,nb+d+1:    ) = cmplx(br,bi,kind=CPX_KIND)*.beta (:,nb+1: d)
                     .general_complex(d+1: ,nb+d+1:    ) =           ar*.beta (:,nb+1: d)

                  else

                     .general_complex(  1:d,     1:na  ) = .alpha(:,   1:na)
                     .general_complex(d+1: ,  na+1:ne  ) = .beta (:,   1:nb)
                     .general_complex(  1:d,  ne+1:nb+d) = .alpha(:,na+1:  )
                     .general_complex(d+1: ,nb+d+1:    ) = .beta (:,nb+1:  )
                  end

               case default

                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))

            end
  
         case("general")
  
            select case (newkind)

               case("unrestricted")
                  .general.put_aa_block_to(.alpha)
                  .general.put_bb_block_to(.beta)
                  WARN("Conversion from general to unrestricted not recommended!")

               case("general_complex")
                  .general_complex = .general

               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))

            end
  
         case default

            DIE("cant convert old kind "//trim(oldkind))

      end

      .destroy(oldkind)

   end

   l_compress(genre) result (res) ::: PURE
   ! Return the length of the compressed object
      self :: IN
      genre :: STR, optional, IN
      res :: INT

      k :: STR

      if (present(genre)) then; k = genre
      else;                     k = .spinorbital_kind
      end

      res = 0
      select case (k)
         case("restricted          "); res = int(HALF*.n_bf*(.n_bf+1))
         case("unrestricted        "); res =   .n_bf*(  .n_bf+1)
         case("alpha               "); res =   .n_bf*(  .n_bf+1)/2
         case("beta                "); res =   .n_bf*(  .n_bf+1)/2
         case("general             "); res =   .n_bf*(2*.n_bf+1)
         case("restricted_complex  "); res =   .n_bf*.n_bf
         case("unrestricted_complex"); res = 2*.n_bf*.n_bf
         case("general_complex     "); res = 4*.n_bf*.n_bf
      end

   end

   compress(genre) ::: leaky, PURE
   ! Compress the opmatrix into a triangle or square vector to save space
      self :: INOUT
      genre :: STR, optional, IN

      k :: STR
      l :: INT
      W :: VEC{REAL}*

      k = .spinorbital_kind
      if (present(genre)) k = genre

      select case (k)

         case("restricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .restricted.zip_lower_triangle_to(.triangle)
            .restricted.destroy

         case("unrestricted")
            l = .l_compress(k)
            .triangle.destroy
            .triangle.create(l)
            W.create(l/2)
            .alpha.zip_lower_triangle_to(W); .triangle.alpha_set_to(W)
             .beta.zip_lower_triangle_to(W);  .triangle.beta_set_to(W)
            W.destroy
            .alpha.destroy
            .beta.destroy

         case("alpha")
            l = .l_compress(k)
            .triangle.destroy
            .triangle.create(l)
            W.create(l)
            .alpha.zip_lower_triangle_to(W); .triangle.set_to(W)
            W.destroy
            .alpha.destroy

         case("beta")
            l = .l_compress(k)
            .triangle.destroy
            .triangle.create(l)
            W.create(l)
            .beta.zip_lower_triangle_to(W); .triangle.set_to(W)
            W.destroy
            .beta.destroy

         case("general")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .general.zip_lower_triangle_to(.triangle)

         case("restricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .restricted_complex.zip_lower_triangles_to(.square)
            .restricted_complex.destroy

         case("unrestricted_complex")
            .square.destroy
            l = .l_compress(k)
            .square.create(l)
            allocate(W(l/2))
            .alpha_complex.zip_lower_triangles_to(W); .square.alpha_set_to(W)
             .beta_complex.zip_lower_triangles_to(W);  .square.beta_set_to(W)
            deallocate(W)
            .alpha_complex.destroy
            .beta_complex.destroy

         case("general_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .general_complex.zip_lower_triangles_to(.square)
            .general_complex.destroy

      end

   end

   uncompress ::: leaky, PURE
   ! Uncompress the opmatrix
      self :: INOUT
      l :: INT

      l = -1
      if (.triangle.allocated) l = size(.triangle)
      if (.square.allocated)   l = size(.square)

      if (l==.l_compress("restricted")) then

            .destroy("restricted")
             .create("restricted")
            .restricted.symmetric_unzip_triangle(.triangle)
            .triangle.destroy

      else if (l==.l_compress("unrestricted")) then

            .destroy("unrestricted")
             .create("unrestricted")
            .alpha.symmetric_unzip_triangle(.triangle.alpha)
             .beta.symmetric_unzip_triangle( .triangle.beta)
            .triangle.destroy

      else if (l==.l_compress("general")) then

            .destroy("general")
             .create("general")
            .general.symmetric_unzip_triangle(.triangle)
            .triangle.destroy

      else if (l==.l_compress("restricted_complex")) then

            .destroy("restricted_complex")
             .create("restricted_complex")
            .restricted_complex.hermitian_unzip_triangles(.square)
            .square.destroy

      else if (l==.l_compress("unrestricted_complex")) then

            .destroy("unrestricted_complex")
             .create("unrestricted_complex")
            .alpha_complex.hermitian_unzip_triangles(.square.alpha)
             .beta_complex.hermitian_unzip_triangles(.square.beta)

      else if (l==.l_compress("general_complex")) then

            .destroy("general_complex")
             .create("general_complex")
            .general_complex.hermitian_unzip_triangles(.square)
            .square.destroy

      end

   end

!  ===============
!  Math operations
!  ===============

   plus(X,genre) ::: PURE
   ! Add "X" to "self" for all genres. 
      self :: INOUT
      X :: OPMATRIX, IN
      genre :: STR, IN, optional

   ENSURE(.is_addable_with(X),"not (left) addable")

      if (NOT present(genre)) then

         ! Real
         if (.restricted.allocated)          .restricted.plus(X.restricted)
         if (     .alpha.allocated)               .alpha.plus(X.alpha)
         if (      .beta.allocated)                .beta.plus(X.beta)
         if (   .general.allocated)             .general.plus(X.general)
         ! Complex
         if (.restricted_complex.allocated)  .restricted_complex.plus(X.restricted_complex)
         if (     .alpha_complex.allocated)       .alpha_complex.plus(X.alpha_complex)
         if (      .beta_complex.allocated)        .beta_complex.plus(X.beta_complex)
         if (   .general_complex.allocated)     .general_complex.plus(X.general_complex)

      else

         select case(genre)
         ! Real 
         case(  "restricted");                .restricted.plus(X.restricted)
         case("unrestricted");                     .alpha.plus(X.alpha)
                                                    .beta.plus(X.beta)
         case(       "alpha");                     .alpha.plus(X.alpha)
         case(        "beta");                      .beta.plus(X.beta)
         case(     "general");                   .general.plus(X.general)
         ! Complex                            
         case(  "restricted_complex");        .restricted_complex.plus(X.restricted_complex)
         case("unrestricted_complex");             .alpha_complex.plus(X.alpha_complex)
                                                    .beta_complex.plus(X.beta_complex)
         case(       "alpha_complex");             .alpha_complex.plus(X.alpha_complex)
         case(        "beta_complex");              .beta_complex.plus(X.beta_complex)
         case(     "general_complex");           .general_complex.plus(X.general_complex)
         end

      end

   end

   minus(X,genre) ::: PURE
   ! Subtract "X" to "self" for all genres. The two must be compatible.
      self :: INOUT
      X :: OPMATRIX, IN
      genre :: STR, IN, optional

   ENSURE(.is_addable_with(X),"not (left) addable")

      if (NOT present(genre)) then

         ! Real
         if (.restricted.allocated)          .restricted.minus(X.restricted)
         if (     .alpha.allocated)               .alpha.minus(X.alpha)
         if (      .beta.allocated)                .beta.minus(X.beta)
         if (   .general.allocated)             .general.minus(X.general)
         ! Complex
         if (.restricted_complex.allocated)  .restricted_complex.minus(X.restricted_complex)
         if (     .alpha_complex.allocated)       .alpha_complex.minus(X.alpha_complex)
         if (      .beta_complex.allocated)        .beta_complex.minus(X.beta_complex)
         if (   .general_complex.allocated)     .general_complex.minus(X.general_complex)

      else

         select case(genre)
         ! Real 
         case(  "restricted");                .restricted.minus(X.restricted)
         case("unrestricted");                     .alpha.minus(X.alpha)
                                                    .beta.minus(X.beta)
         case(       "alpha");                     .alpha.minus(X.alpha)
         case(        "beta");                      .beta.minus(X.beta)
         case(     "general");                   .general.minus(X.general)
         ! Complex                            
         case(  "restricted_complex");        .restricted_complex.minus(X.restricted_complex)
         case("unrestricted_complex");             .alpha_complex.minus(X.alpha_complex)
                                                    .beta_complex.minus(X.beta_complex)
         case(       "alpha_complex");             .alpha_complex.minus(X.alpha_complex)
         case(        "beta_complex");              .beta_complex.minus(X.beta_complex)
         case(     "general_complex");           .general_complex.minus(X.general_complex)
         end

      end

   end

   scale_by(fac) ::: PURE
   ! Set "self" to a scaled version of itself.
      self :: INOUT
      fac :: REAL, IN

      if (        .restricted.allocated)         .restricted =         .restricted*fac
      if (             .alpha.allocated)              .alpha =              .alpha*fac
      if (              .beta.allocated)               .beta =               .beta*fac
      if (           .general.allocated)            .general =            .general*fac
      if (.restricted_complex.allocated) .restricted_complex = .restricted_complex*fac
      if (     .alpha_complex.allocated)      .alpha_complex =      .alpha_complex*fac
      if (      .beta_complex.allocated)       .beta_complex =       .beta_complex*fac
      if (   .general_complex.allocated)    .general_complex =    .general_complex*fac

   end

   to_scaled(X,fac) ::: PURE
   ! Set "self" to a scaled version of "X". The two must be compatible.
      self :: OUT
      X :: OPMATRIX, IN
      fac :: REAL, IN

   ENSURE(.is_compatible_with(X),"incompatible kinds")

      if (        .restricted.allocated)         .restricted.to_scaled(X.restricted        ,fac)
      if (             .alpha.allocated)              .alpha.to_scaled(     X.alpha        ,fac)
      if (              .beta.allocated)               .beta.to_scaled(      X.beta        ,fac)
      if (           .general.allocated)            .general.to_scaled(   X.general        ,fac)
      if (.restricted_complex.allocated) .restricted_complex.to_scaled(X.restricted_complex,fac)
      if (     .alpha_complex.allocated)      .alpha_complex.to_scaled(     X.alpha_complex,fac)
      if (      .beta_complex.allocated)       .beta_complex.to_scaled(      X.beta_complex,fac)
      if (   .general_complex.allocated)    .general_complex.to_scaled(   X.general_complex,fac)

   end

   to_scaled(X,fac,genre) ::: PURE
   ! Set "self" to a scaled version of "X". The two must be compatible.
      self :: PTR
      X :: OPMATRIX, PTR
      fac :: REAL, IN
      genre :: STR, IN

   ENSURE(.is_compatible_with(X,genre),"incompatible kinds")

      select case(genre)
      case(          "restricted");         .restricted.to_scaled(X.restricted        ,fac)
      case(        "unrestricted");              .alpha.to_scaled(     X.alpha        ,fac)
                                                  .beta.to_scaled(      X.beta        ,fac)
      case(               "alpha");              .alpha.to_scaled(     X.alpha        ,fac)
      case(                "beta");               .beta.to_scaled(      X.beta        ,fac)
      case(             "general");            .general.to_scaled(   X.general        ,fac)
      case(  "restricted_complex"); .restricted_complex.to_scaled(X.restricted_complex,fac)
      case("unrestricted_complex");      .alpha_complex.to_scaled(     X.alpha_complex,fac)
                                          .beta_complex.to_scaled(      X.beta_complex,fac)
      case(       "alpha_complex");      .alpha_complex.to_scaled(     X.alpha_complex,fac)
      case(        "beta_complex");       .beta_complex.to_scaled(      X.beta_complex,fac)
      case(     "general_complex");    .general_complex.to_scaled(   X.general_complex,fac)
      end

   end

   plus_scaled(X,fac) ::: PURE
   ! Add to "self" a scaled version of "X". The two must be compatible.
      self :: INOUT
      X :: OPMATRIX, IN
      fac :: REAL, IN

   ENSURE(.is_compatible_with(X),"incompatible kinds")

      ! Real
      if (.restricted.allocated)         .restricted.plus_scaled(X.restricted,fac)
      if (     .alpha.allocated)              .alpha.plus_scaled(     X.alpha,fac)
      if (      .beta.allocated)               .beta.plus_scaled(      X.beta,fac)
      if (   .general.allocated)            .general.plus_scaled(   X.general,fac)
      ! Complex
      if (.restricted_complex.allocated) .restricted_complex.plus_scaled(X.restricted_complex,fac)
      if (     .alpha_complex.allocated)      .alpha_complex.plus_scaled(     X.alpha_complex,fac)
      if (      .beta_complex.allocated)       .beta_complex.plus_scaled(      X.beta_complex,fac)
      if (   .general_complex.allocated)    .general_complex.plus_scaled(   X.general_complex,fac)

   end

   plus_scaled(X,fac,genre) ::: PURE
   ! Add to "self" a scaled version of "X". The two must be compatible.
      self :: PTR
      X :: OPMATRIX, PTR
      fac :: REAL, IN
      genre :: STR, IN

   ENSURE(.is_compatible_with(X,genre),"incompatible kinds")

      select case(genre)
      case(          "restricted");         .restricted.plus_scaled(X.restricted        ,fac)
      case(        "unrestricted");              .alpha.plus_scaled(     X.alpha        ,fac)
                                                  .beta.plus_scaled(      X.beta        ,fac)
      case(               "alpha");              .alpha.plus_scaled(     X.alpha        ,fac)
      case(                "beta");               .beta.plus_scaled(      X.beta        ,fac)
      case(             "general");            .general.plus_scaled(   X.general        ,fac)
      case(  "restricted_complex"); .restricted_complex.plus_scaled(X.restricted_complex,fac)
      case("unrestricted_complex");      .alpha_complex.plus_scaled(     X.alpha_complex,fac)
                                          .beta_complex.plus_scaled(      X.beta_complex,fac)
      case(       "alpha_complex");      .alpha_complex.plus_scaled(     X.alpha_complex,fac)
      case(        "beta_complex");       .beta_complex.plus_scaled(      X.beta_complex,fac)
      case(     "general_complex");    .general_complex.plus_scaled(   X.general_complex,fac)
      end

   end

   to_product_of(X,Y) ::: leaky, PURE
   ! Add "X" to "self" for all genres. 
      self :: OUT
      X :: MAT{REAL}, IN
      Y :: OPMATRIX, IN

      ! Real
      if (Y.restricted.allocated) &
         .restricted = matmul(X,Y.restricted)

      if (Y.alpha.allocated) &
         .alpha = matmul(X,Y.alpha)

      if (Y.beta.allocated) &
         .beta  = matmul(X,Y.beta)

      if (Y.general.allocated) &
         .general = matmul(X,Y.general)

      ! Complex
      if (Y.restricted_complex.allocated) &
         .restricted_complex = matmul(X,Y.restricted_complex)

      if (Y.alpha_complex.allocated) &
         .alpha_complex = matmul(X,Y.alpha_complex)
 
      if (Y.beta_complex.allocated) &
         .beta_complex  = matmul(X,Y.beta_complex)

      if (Y.general_complex.allocated) &
         .general_complex = matmul(X,Y.general_complex)

   end

   to_product_of(X,Y) ::: leaky, PURE
   ! Add "X" to "self" for all genres. 
      self :: OUT
      X,Y :: OPMATRIX, IN

   ENSURE(X.is_addable_with(Y),"X and Y are not compatible!")

      ! Real
      if (X.restricted.allocated) &
         .restricted = matmul(X.restricted,Y.restricted)

      if (X.alpha.allocated) &
         .alpha = matmul(X.alpha,Y.alpha)

      if (X.beta.allocated) &
         .beta  = matmul(X.beta,Y.beta)

      if (X.general.allocated) &
         .general = matmul(X.general,Y.general)

      ! Complex
      if (X.restricted_complex.allocated) &
         .restricted_complex = matmul(X.restricted_complex,Y.restricted_complex)

      if (X.alpha_complex.allocated) &
         .alpha_complex = matmul(X.alpha_complex,Y.alpha_complex)
 
      if (X.beta_complex.allocated) &
         .beta_complex  = matmul(X.beta_complex,Y.beta_complex)

      if (X.general_complex.allocated) &
         .general_complex = matmul(X.general_complex,Y.general_complex)

   end

   damp(old,mix) ::: PURE
   ! Constructs the new self matrix by combining it with the "old" one using a
   ! "mix" factor, i.e.  self = (1-mix)*self + mix*old.
      self :: INOUT
      old :: OPMATRIX, IN
      mix :: REAL, IN

      .scale_by(ONE-mix)
      .plus_scaled(old,mix)

   end

   expectation(X) result (res)
   ! Get the expectation value of the matrix "X", i.e:
   !    res = Trace ( X . self )
      self :: IN
      X :: OPMATRIX, IN
      res :: REAL

   ENSURE(X.n_bf==.n_bf,"wrong X dimension")

      genre :: STR

      genre = .spinorbital_kind

      res = ZERO

      select case (genre)

      case ("restricted");      res = .restricted.trace_product_with(X.restricted)
      case ("unrestricted");    res = .alpha.trace_product_with(X.alpha)
                                res = .beta.trace_product_with(X.beta) + res
      case ("general_complex"); res = RE(.general_complex.trace_product_with(X.general_complex))
      case ("general");         res = .general.trace_product_with(X.general)
      case default;             DIE("not implemented, "//trim(genre))

      end

   end

   expectation(X) result (res)
   ! Get the expectation value of the matrix "X", i.e:
   !    res = Trace ( X . self )
      self :: IN
      X :: MAT{REAL}, IN
      res :: REAL

   ENSURE(X.dim1==.n_bf,"wrong X dimension")
   ENSURE(X.is_square,"X is not square")

      genre :: STR

      genre = .spinorbital_kind

      res = ZERO

      select case (genre)

      case ("restricted");      res = .restricted.trace_product_with(X)
      case ("unrestricted");    res = .alpha.trace_product_with(X)
                                res = .beta.trace_product_with(X) + res
      case ("general_complex"); res = RE(.general_complex.trace_product_with(X))
      case ("general");         res = .general.trace_product_with(X)
      case default;             DIE("not implemented, "//trim(genre))

      end

   end

!  ==================
!  Orthonormalization
!  ==================

   schmidt_orthonormalise(S,scale)
   ! Schmidt Orthonormalise self.  (For molecular orbitals).
      S :: MAT{REAL}, IN
      scale :: REAL, optional
      genre :: STR
      n :: INT
      SS :: MAT{REAL}*
      genre = .spinorbital_kind
      select case(genre)
         case("restricted")
                  .restricted.schmidt_orthonormalise(S,scale)
         case("unrestricted")
                  .alpha.schmidt_orthonormalise(S)
                  .beta.schmidt_orthonormalise(S)
         case("alpha")
                  .alpha.schmidt_orthonormalise(S,scale)
         case("beta")
                  .beta.schmidt_orthonormalise(S,scale)
         case("general")
                  n = 2*S.dim1
                  SS.create(n,n)
                  SS = ZERO
                  SS.set_aa_block_to(S)
                  SS.set_bb_block_to(S)
                  .general.schmidt_orthonormalise(SS,scale)
                  SS.destroy
         case("restricted_complex")
                  .restricted_complex.schmidt_orthonormalise(S,scale)
         case("unrestricted_complex")
                  .alpha_complex.schmidt_orthonormalise(S)
                  .beta_complex.schmidt_orthonormalise(S)
         case("alpha_complex")
                  .alpha_complex.schmidt_orthonormalise(S,scale)
         case("beta_complex")
                  .beta_complex.schmidt_orthonormalise(S,scale)
         case("general_complex")
                  n = 2*S.dim1
                  SS.create(n,n)
                  SS = ZERO
                  SS.set_aa_block_to(S)
                  SS.set_bb_block_to(S)
                  .general_complex.schmidt_orthonormalise(SS,scale)
                  SS.destroy
         case default;   DIE("unknown kind, "//trim(genre))
      end
   end

   symmetrically_orthonormalise(S)
   ! Symmetrically orthonormalise self. (For molecular orbitals).
   ! "S" is the AO overlap matrix.
      S :: MAT{REAL}, IN

      genre :: STR
      n :: INT
      SS :: MAT{REAL}*

      genre = .spinorbital_kind

      select case(genre)

         case("restricted")
            .restricted.symmetrically_orthonormalise(S)

         case("unrestricted")
            .alpha.symmetrically_orthonormalise(S)
            .beta.symmetrically_orthonormalise(S)

         case("alpha")
            .alpha.symmetrically_orthonormalise(S)

         case("beta")
            .beta.symmetrically_orthonormalise(S)

         case("general")
            n = 2*S.dim1
            SS.create(n,n)
            SS = ZERO
            ENSURE(SS.dim1==2*S.dim1,"wrong size, S")
            SS.set_aa_block_to(S)
            SS.set_bb_block_to(S)
            .general.symmetrically_orthonormalise(SS)
            SS.destroy

         case("restricted_complex")
            .restricted.symmetrically_orthonormalise(S)

         case("unrestricted_complex")
            .alpha_complex.symmetrically_orthonormalise(S)
            .beta_complex.symmetrically_orthonormalise(S)

         case("alpha_complex")
            .alpha_complex.symmetrically_orthonormalise(S)

         case("beta_complex")
            .beta_complex.symmetrically_orthonormalise(S)

         case("general_complex")
            n = 2*S.dim1
            SS.create(n,n)
            SS = ZERO
            ENSURE(SS.dim1==2*S.dim1,"wrong size, S")
            SS.set_aa_block_to(S)
            SS.set_bb_block_to(S)
            .general_complex.symmetrically_orthonormalise(SS)
            SS.destroy

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

!  ===============================
!  Normalisation & unnormalisation
!  ===============================

   unnormalise(first,last,angmom)
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      first,last,angmom :: VEC{INT}, IN

      if (.restricted.allocated) then
         GAUSSIAN_DATA:unnormalise(.restricted,first,last,angmom)
      end

      if (.alpha.allocated) then
         GAUSSIAN_DATA:unnormalise(.alpha,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.beta, first,last,angmom)
      end

      if (.general.allocated) then
         GAUSSIAN_DATA:unnormalise(.general(      1:.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general(      1:.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general(.n_bf+1:.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general(.n_bf+1:.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
      end

      if (.restricted_complex.allocated) then
         GAUSSIAN_DATA:unnormalise(.restricted_complex,first,last,angmom)
      end

      if (.alpha_complex.allocated) then
         GAUSSIAN_DATA:unnormalise(.alpha_complex,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.beta_complex, first,last,angmom)
      end

      if (.general_complex.allocated) then
         GAUSSIAN_DATA:unnormalise(.general_complex(      1:.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general_complex(      1:.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general_complex(.n_bf+1:.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general_complex(.n_bf+1:.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
      end

   end

   unnormalise(ind,first,last,angmom)
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      ind :: STR, IN
      first,last,angmom :: VEC{INT}, IN

      if (.restricted.allocated) then
         GAUSSIAN_DATA:unnormalise(.restricted,ind,first,last,angmom)
      end

      if (.alpha.allocated) then
         GAUSSIAN_DATA:unnormalise(.alpha,ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.beta, ind,first,last,angmom)
      end

      if (.general.allocated) then
         GAUSSIAN_DATA:unnormalise(.general(      1:  .n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general(      1:  .n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general(.n_bf+1:2*.n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
      end

      if (.restricted_complex.allocated) then
         GAUSSIAN_DATA:unnormalise(.restricted_complex,ind,first,last,angmom)
      end

      if (.alpha_complex.allocated) then
         GAUSSIAN_DATA:unnormalise(.alpha_complex,ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.beta_complex, ind,first,last,angmom)
      end

      if (.general_complex.allocated) then
         GAUSSIAN_DATA:unnormalise(.general_complex(      1:  .n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general_complex(      1:  .n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general_complex(.n_bf+1:2*.n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:unnormalise(.general_complex(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
      end

   end

   renormalise(first,last,angmom)
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      first,last,angmom :: VEC{INT}, IN

      if (.restricted.allocated) then
         GAUSSIAN_DATA:renormalise(.restricted,first,last,angmom)
      end

      if (.alpha.allocated) then
         GAUSSIAN_DATA:renormalise(.alpha,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.beta, first,last,angmom)
      end

      if (.general.allocated) then
         GAUSSIAN_DATA:renormalise(.general(      1:  .n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general(      1:  .n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general(.n_bf+1:2*.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
      end

      if (.restricted_complex.allocated) then
         GAUSSIAN_DATA:renormalise(.restricted_complex,first,last,angmom)
      end

      if (.alpha_complex.allocated) then
         GAUSSIAN_DATA:renormalise(.alpha_complex,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.beta_complex, first,last,angmom)
      end

      if (.general_complex.allocated) then
         GAUSSIAN_DATA:renormalise(.general_complex(      1:  .n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general_complex(      1:  .n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general_complex(.n_bf+1:2*.n_bf,      1:  .n_bf),first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general_complex(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),first,last,angmom)
      end

   end

   renormalise(ind,first,last,angmom)
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      self :: INOUT
      ind :: STR, IN
      first,last,angmom :: VEC{INT}, IN

      if (.restricted.allocated) then
         GAUSSIAN_DATA:renormalise(.restricted,ind,first,last,angmom)
      end

      if (.alpha.allocated) then
         GAUSSIAN_DATA:renormalise(.alpha,ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.beta, ind,first,last,angmom)
      end

      if (.general.allocated) then
         GAUSSIAN_DATA:renormalise(.general(      1:  .n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general(      1:  .n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general(.n_bf+1:2*.n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
      end

      if (.restricted_complex.allocated) then
         GAUSSIAN_DATA:renormalise(.restricted_complex,ind,first,last,angmom)
      end

      if (.alpha_complex.allocated) then
         GAUSSIAN_DATA:renormalise(.alpha_complex,ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.beta_complex, ind,first,last,angmom)
      end

      if (.general_complex.allocated) then
         GAUSSIAN_DATA:renormalise(.general_complex(      1:  .n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general_complex(      1:  .n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general_complex(.n_bf+1:2*.n_bf,      1:  .n_bf),ind,first,last,angmom)
         GAUSSIAN_DATA:renormalise(.general_complex(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf),ind,first,last,angmom)
      end

   end

end
