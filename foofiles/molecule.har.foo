!==================================================================
!
! MOLECULE.HAR: 
!
! Hirshfeld atom refinement, invarioms and related concepts.
!
! Copyright (C) Dylan Jayatilaka, 2012
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==============================================================================-


module MOLECULE.HAR

   implicit none

contains

!  =========================
!  Hirshfeld atom refinement
!  =========================

   fragHAR_refinement ::: leaky
   ! Do an fragment HAR.
      self :: INOUT

   DIE_IF(.atom.deallocated, "no atoms to fit")
   DIE_IF(.atom_group.deallocated, "no atom_group's")
   DIE_IF(NOT .scfdata.allocated,"no scfdata")
   DIE_IF(NOT .crystal.allocated, "no crystal")
   DIE_IF(NOT .crystal.xray_data.allocated,"no crystal xray data")
   DIE_IF(NOT .crystal.xray_data.reflections.allocated,"no reflections")

      results,output :: BIN
      do_ASFs :: BIN

      ! Use disk SFs for now ...
      .crystal.xray_data.SET:set_use_disk_SFs(TRUE)

      ! Output options
      results = .crystal.xray_data.show_refinement_results
      output  = .crystal.xray_data.show_refinement_output

      ! ANO's and interpolators?
      .SCF:make_HA_inputs

      ! Initial F_calc's for pruning
      if (NOT .crystal.xray_data.reflections.have_F_pred) then
         if (output) then
            stdout.flush
            stdout.text("Making F_pred ...")
         end
         do_ASFs = NOT .scfdata.restart_skip_asfs
         .SCF:fragment_SCF(do_SFs=do_ASFs)
         .crystal.make_F_predicted
       ! .SCF:make_X_SFs
      end

      ! Prune?
      if (.crystal.xray_data.INQ:is_F_calc_prunable) then
         ! Prune
         if (output) then
            stdout.flush
            stdout.text("Pruning reflections with F_pred/F_calc for refinement ...")
         end
         .crystal.xray_data.SET:prune_reflections
      end

      ! Initialize message
      if (output) then
         stdout.flush
         stdout.text("Starting refinement ...")
      end
      .crystal.initialize_refinement_data

      ! Turn off unwanted printing ...
      .crystal.xray_data.SET:set_refine_fragments(TRUE)
      .crystal.xray_data.SET:set_refine_structure(TRUE)
      .crystal.xray_data.SET:set_fit_structure(FALSE)
      .scfdata.set_output(FALSE)

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header
      if (output) then
         .crystal.put_refinement_header_info
      end
      
      do ! ... LS cycle

         ! Remake fragments & do SCF
         if (.crystal.xray_data.ref_iteration>0) then
            .BASE:update_atom_groups ! needed?
            .SCF:fragment_SCF(restart=TRUE,do_SFs=TRUE)
         end
      
         !!!!!!!!!!!!!!!!!!!!!!
         .:LS_fit_fragHAR_disk
         !!!!!!!!!!!!!!!!!!!!!!
      
         ! Update geometry & errors
         .crystal.xray_data.SET:update_refinement_parameters
         .crystal.update_refinement_ESDs

         ! Put the iteration results
         if (output) then
            .crystal.xray_data.PUT:put_refinement_table_body
         end

         ! Finished?
         .crystal.xray_data.SET:update_refinement_info
         if (.crystal.xray_data.refinement_finished) exit

      end ! ... LS cycle

      .crystal.xray_data.SET:update_refinement_info
      
      ! Table footer
      if (output) then
         .crystal.xray_data.ref_table.put_footer
      end

      ! Final results
      if (results) then
         .crystal.put_refinement_results
      end

      ! Final bond lengths, angles, torsions, with errors
      if (output) then
         .crystal.put_bond_info_with_errors
      end

      ! SCF @ final geometry
      .SCF:fragment_SCF(restart=TRUE)
      .scfdata.set_output(TRUE) ! put back

      ! Put analysis info ...
      if (.crystal.xray_data.do_standard_plots) then
         .crystal.put_X_data_analysis(output=TRUE)
      end

      ! Final results
      .crystal.put_correlations(name=trim(.name)//".correlation-coefficients")

      ! Put residuals ...
      if (.crystal.xray_data.do_residual_cube) &
         .SCF:get_minmax_residual_density(output=TRUE)

      ! Put final CIF after residuals
      .PUT:put_CIFs(with_ESDs=TRUE)

      ! Do standatd plots and properties
      if (.crystal.xray_data.do_standard_plots) then
      end

   end

   LS_fit_fragHAR_disk ::: leaky
   ! LS fit the Hirshfeld atoms to the calculated structure factors.
   ! Disk version
      self :: INOUT

      ! Do a least squares
      .HAR:LS_fit(.crystal.xray_data.show_fit_output,.crystal.xray_data.show_fit_results)
      
      ! Put final CIF after residuals
      .PUT:put_CIFs(with_ESDs=TRUE)
        
   end


!   TAR_refinement ::: leaky
!   ! Do a Tanaka atom refinement (TAR) on the X-ray data. 
!      self :: INOUT
!
!   DIE_IF(NOT .atom.allocated, "no atoms to fit")
!   DIE_IF(NOT .scfdata.allocated,"no scfdata")
!   DIE_IF(NOT .crystal.allocated, "no crystal")
!   DIE_IF(NOT .crystal.xray_data.allocated,"no crystal xray data")
!   DIE_IF(NOT .crystal.uses_one_center_TF_model,"must use one-center temperature factor model")
!
!      results,output :: BIN
!
!      ! Output options
!      results = .crystal.xray_data.show_refinement_results
!      output  = .crystal.xray_data.show_refinement_output
!      output = TRUE
!
!      ! Initial SCF
!      if (.density_mx.deallocated) then
!
!         if (output) then
!            stdout.flush
!            stdout.text("Initial density matrix for refinement ...")
!         end
!
!         ! Initial promolecule SCF
!         if (.scfdata.using_cluster_charges) .SCF:promolecule_scf
!
!         .SCF:scf
!
!      end
!
!      ! Always use initial_density for stability
!      .scfdata.set_initial_density(.scfdata.spinorbital_genre)
!
!      ! Initial F_calc's for pruning
!      if (NOT .crystal.xray_data.reflections.have_F_pred) then
!         if (output) then
!            stdout.flush
!            stdout.text("Making F_pred ...")
!         end
!         .SCF:make_X_SFs
!      end
!
!      ! Prune?
!      if (.crystal.xray_data.INQ:is_F_calc_prunable) then
!         if (output) then
!            stdout.flush
!            stdout.text("Pruning reflections with F_pred/F_calc for refinement ...")
!         end
!         .crystal.xray_data.SET:prune_reflections
!      end
!
!      ! Initialize message
!      if (output) then
!         stdout.flush
!         stdout.text("Starting refinement ...")
!      end
!
!      .crystal.initialize_refinement_data
!
!      ! Turn off unwanted printing ...
!      .crystal.xray_data.SET:set_refine_structure(TRUE)
!      .crystal.xray_data.SET:set_fit_structure(FALSE)
!      .scfdata.set_output(FALSE)
!
!      ! Banner, options/switches, initial parameters,
!      ! start banner, and iteration table header
!      if (output) then
!         .crystal.put_refinement_header_info
!      end
!
!      ! Refinement cycle 
!      do
!
!         ! SCF
!         if (.crystal.xray_data.ref_iteration>0) then
!            if (.crystal.xray_data.restart_HAR_with_promolecule) &
!            .SCF:promolecule_scf
!            .SCF:scf
!         end
!
!         !!!!!!!!!!!!!!!!!!!!!
!         .:LS_fit_Tanaka_atoms
!         !!!!!!!!!!!!!!!!!!!!!
!
!         ! Update geometry & errors
!         .crystal.xray_data.SET:update_refinement_parameters
!         .crystal.update_refinement_ESDs
!
!         ! Put the iteration results
!         if (output) then
!            .crystal.xray_data.PUT:put_refinement_table_body
!         end
!
!         ! Finished?
!         .crystal.xray_data.SET:update_refinement_info
!         if (.crystal.xray_data.refinement_finished) exit
!
!      end ! ... LS cycle
!
!      .crystal.xray_data.SET:update_refinement_info
!
!      ! Table footer
!      if (output) then
!         .crystal.xray_data.ref_table.put_footer
!      end
!
!      ! Final results
!      if (results) then
!         .crystal.put_refinement_results
!      end
!
!      ! Final bond lengths, angles, torsions, with errors
!      if (output) then
!         .crystal.put_bond_info_with_errors
!      end
!
!      ! SCF @ final geometry
!      .SCF:scf
!      .scfdata.set_output(TRUE) ! put back
!
!      ! Put analysis info ...
!      if (.crystal.xray_data.do_standard_plots) then
!         .crystal.put_X_data_analysis(output=TRUE)
!      end
!
!      ! Put residuals ...
!      if (.crystal.xray_data.do_residual_cube) then
!         .SCF:get_minmax_residual_density(output=TRUE)
!
!      ! Put final CIF after residuals
!      .PUT:put_CIFs(with_ESDs=TRUE)
!
!      ! Do standatd plots and properties
!      if (.crystal.xray_data.do_standard_plots) then
!      end
!
!   end

!   LS_fit_Tanaka_atoms ::: leaky
!   ! LS fit the Hirshfeld atoms to the calculated structure factors.
!   ! In-memory version.
!      self :: INOUT
!
!      ff :: MAT{CPX}@
!
!      ! Hirshfeld-atom structure factors
!      ! NOTE: in iteration 0, these were already calculated
!      ! as part of make_X_SFs ... double work!
!      .SCF:get_Tanaka_atom_FFs(ff)
!
!      ! Do a least squares
!      .HAR:LS_fit(ff,.crystal.xray_data.show_fit_output,.crystal.xray_data.show_fit_results)
!
!      ! Final results
!      .crystal.put_correlations(name=trim(.name)//".correlation-coefficients")
!
!      ! Put final CIF after residuals
!      .PUT:put_CIFs(with_ESDs=TRUE)
!
!      ! Clean up
!      ff.destroy
!
!   end


   HAR_refinement ::: leaky
   ! Do a Hirshfeld atom refinement (HAR) on the X-ray data. 
   ! The wavefunction and form factors are recalculated every 
   ! time the geometry changes, until appropriately converged, 
   ! normally to a maximum relative change of 0.01\sigma
      self :: INOUT

   DIE_IF(NOT .atom.allocated, "no atoms to fit")
   DIE_IF(NOT .scfdata.allocated,"no scfdata")
   DIE_IF(NOT .crystal.allocated, "no crystal")
   DIE_IF(NOT .crystal.xray_data.allocated,"no crystal xray data")
   DIE_IF(NOT .crystal.uses_one_center_TF_model,"must use one-center temperature factor model")

      results,output :: BIN

      ! Output options
      results = .crystal.xray_data.show_refinement_results
      output  = .crystal.xray_data.show_refinement_output

      ! ANO's and interpolators?
      .SCF:make_HA_inputs

      ! Initial SCF
      if (.density_mx.deallocated) then
         if (output) then
            stdout.flush
            stdout.text("Initial density matrix for refinement ...")
         end
         ! Initial promolecule SCF
         if (.scfdata.using_cluster_charges) &
         .SCF:promolecule_scf
         .SCF:scf ! ???
      end

      ! Always use initial_density for stability
      .scfdata.set_initial_density(.scfdata.spinorbital_genre)

      ! Initial F_calc's for pruning
      if (NOT .crystal.xray_data.reflections.have_F_pred) then
         if (output) then
            stdout.flush
            stdout.text("Making F_pred ...")
         end
         .SCF:make_X_SFs
      end

      ! Prune?
      if (.crystal.xray_data.INQ:is_F_calc_prunable) then
         if (output) then
            stdout.flush
            stdout.text("Pruning reflections with F_pred/F_calc for refinement ...")
         end
         .crystal.xray_data.SET:prune_reflections
      end

      ! Initialize & turn off unwanted printing ...
      .crystal.initialize_refinement_data
      .crystal.xray_data.SET:set_refine_structure(TRUE)
      .crystal.xray_data.SET:set_fit_structure(FALSE)
      .scfdata.set_output(FALSE)

      ! Do banner, options/switches, initial parameters,
      ! refinement iteration banner & iteration table header
      if (output) then
         stdout.flush
         stdout.text("Starting refinement ...")
         .crystal.put_refinement_header_info
      end

      !==========
      ! HAR cycle
      !==========
      do

         ! SCF
         if (.crystal.xray_data.ref_iteration>0) then
            if (.crystal.xray_data.restart_HAR_with_promolecule) &
            .SCF:promolecule_SCF
            .SCF:scf ! ???
         end

         !=======================
         .:LS_fit_Hirshfeld_atoms
         !=======================

         ! Update geometry & errors
         .crystal.xray_data.SET:update_refinement_parameters
         .crystal.update_refinement_ESDs

         ! Put the iteration results
         if (output) then
            .crystal.xray_data.PUT:put_refinement_table_body
         end

         ! Finished?
         .crystal.xray_data.SET:update_refinement_info
         if (.crystal.xray_data.refinement_finished) exit

      end ! ... LS cycle

      ! Table footer
      if (output) then
         .crystal.xray_data.ref_table.put_footer
      end

      ! Final results
      if (results) then
         .crystal.put_refinement_results
      end

      ! Final bond lengths, angles, torsions, with errors
      if (output) then
         .crystal.put_bond_info_with_errors
      end

      ! SCF @ final geometry
      .SCF:scf
      .scfdata.set_output(TRUE) ! put back

      ! Put analysis info ...
      if (.crystal.xray_data.do_standard_plots) then
         .crystal.put_X_data_analysis(output=TRUE)
      end

      ! Put residuals ...
      if (.crystal.xray_data.do_residual_cube) then
         .SCF:get_minmax_residual_density(output=TRUE)
      end

      ! Put final CIF after residuals
      .PUT:put_CIFs(with_ESDs=TRUE)

      ! Do standatd plots and properties
      if (.crystal.xray_data.do_standard_plots) then
      end

   end

   LS_fit_Hirshfeld_atoms ::: leaky
   ! LS fit the Hirshfeld atoms to the calculated structure factors.
   ! Cartesian (bohr) coordinates are used because structure factors
   ! are aspherical and calculated from the QM wavefunction.
   ! NOTE: this routine does only one cycle of fitting with the
   ! current density matrix i.e. this is a "rigid atom fit".
   ! NOTE: It's tricky exactly which atom's are used for refinement:
   ! * Structure factors are calculated only for *unique* fragment
   !   atoms since the QM wavefunction refers to the fragment_atoms.
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to the fragment atom
   !   positions and ADPs) but these parameters and shifts are later
   !   transformed back into asymmetric unit.
      self :: INOUT

      if (.crystal.xray_data.use_disk_SFs) then; .:LS_fit_HAs_disk
      else;                                      .:LS_fit_HAs_memory
      end

   end

   LS_fit_HAs_memory ::: leaky
   ! LS fit the Hirshfeld atoms to the calculated structure factors.
   ! In-memory version.
      self :: INOUT

      fitout,fitres :: BIN
      ff :: MAT{CPX}@
      ff_diffs :: VEC{REAL}@

      ! Output options
      fitout = .crystal.xray_data.show_fit_output
      fitres = .crystal.xray_data.show_fit_results

      ! Hirshfeld-atom structure factors
      ! NOTE: in iteration 0, these were already calculated
      ! as part of make_X_SFs ... double work!
      select case (.crystal.xray_data.partition_model)
      case("oc-crystal23"); .SCF:get_C23_Hirshfeld_atom_FFs(ff)
      case("oc-hirshfeld"); .SCF:get_Hirshfeld_atom_FFs(ff)
      end

      !! Kang added Symmetrize form factor of all unique frag atoms : ff (2024.Jun.3)
      ff_diffs.create(ff.dim2)
      .crystal.symmetrize_FFs(ff,ff_diffs)
      stdout.flush
      stdout.text("________________________________________________________________________________+")
      stdout.text("  : Symmetrizing Form Factors")
      stdout.text("  :   Each atomic form factor is symmetrized.")
      stdout.text("  :   Sum_k |F(k) - F_symmetrized(k)|^2 =")
      stdout.put( ff_diffs )
      stdout.text("  :")
      stdout.text("  :  - If the atom's site symmetry factor is 1, its form factor is unchanged")
      stdout.text("  :  - The larger residual square sum, the more initial symmetry violation of ED")
      stdout.text("__:_____________________________________________________________________________")
      stdout.flush
      !! /Kang/

      ! Least squares (maybe with output)
      .HAR:LS_fit(ff,fitout,fitres)

      ! Put final CIF after residuals
      .PUT:put_CIFs(with_ESDs=TRUE)

      ! Clean up
      ff.destroy

   end

!  Strategy: insert calls, separate out sf_u.
!  End result: one shift update of parameters
!  Then this goes in the normal LSQ cycle in LS_fit

   LS_fit_HAs_disk ::: leaky
   ! LS fit the Hirshfeld atoms to the calculated structure factors.
   ! Low memory version.
      self :: INOUT

      d_Fa :: MAT{REAL}@

      do

         d_Fa.create(.crystal.xray_data.reflections.dim,.crystal.asymmetric_unit_atom.no_of_pADPs)
         .:make_LS_mx(d_Fa)
         .:do_LS_refinement(d_Fa)
         d_Fa.destroy

         .crystal.xray_data.PUT:put_fit_table_body

         ! Finished?
         if (.crystal.xray_data.fit_finished) exit

      end

      ! Table footer
      .crystal.xray_data.fit_table.put_footer

      ! Set the fragment covariances from cov matrix
      .crystal.set_fragment_esds

      ! Print out bond length, angle, torsion tables with errors
      .crystal.put_bond_info_with_errors

      ! Finally: remake .asymmetric_unit_atom/unit_cell geometry from
      ! .fragment_atom, which *must* be assigned since it must point
      ! to molecule.atom
      .crystal.asymmetric_unit_atom.destroy
      .crystal.asymmetric_unit_geometry.destroy
      .crystal.asymmetric_unit_source = "tonto-ls-structure-fit"
      .crystal.update_fragment_info(.crystal.fragment_atom)

      ! Set geometry type
      .crystal.asymmetric_unit_source = "tonto-refinement"

      ! Final results
      .crystal.put_correlations(name=trim(.name)//".correlation-coefficients")

      ! Put final CIF after residuals
      .PUT:put_CIFs(with_ESDs=TRUE)

      if (NOT .crystal.xray_data.use_IAM_density) then

         ! Delete stored matrices
         .SET:delete_SCF_archives(keep_DM=TRUE)
         .SET:destroy_SCF_results(keep_MOs=TRUE) 
         .SET:destroy_SCF_integrals

         if (.scfdata.allocated) then
         if (NOT .scfdata.SCF_kind=="mfcc") then
         ! Orthonormalize MO's at new geometry
         .SCF:symmetrically_orthonormalize(.MOs)
         end
         end

      end
   end

   get_derivative_F_calc_for_atom(a,dFc) ::: leaky
   ! Get "dFc", the derivatives of the complex F_calcs for the
   ! fragment atom corresponding to asymmetric unit atom "a".
      self :: INOUT
      a :: INT, IN
      dFc :: MAT{CPX}, OUT

      ff :: VEC{CPX}@
      n_refl,n_p :: INT

      ! Complex structure factor derivatives
      n_refl = .crystal.xray_data.reflections.dim
      n_p    = .crystal.asymmetric_unit_atom(a).no_of_pADPs

      ! Hirshfeld-atom structure factors
      ! NOTE: in iteration 0, these were already calculated
      ! as part of make_X_SFs ... double work!
      .SCF:get_Hirshfeld_atom_FFs_for_atom(a,ff)

      ! Do a least squares
      .crystal.make_F_calc_derivs_for_atom(a,dFc,ff)

      ! Clean up
      ff.destroy

   end
   
! Hey - this routine below is too long and a joke!
! Did I do this crap? Why!!! --dylan

   make_LS_mx(d_Fa) ::: leaky
   ! Calculate the LS matrix Low memory version.
      self :: target, INOUT
      d_Fa :: MAT{REAL}@, OUT
   
   ENSURE(.crystal.xray_data.allocated, "no data")
   ENSURE(.crystal.fragment_info_made, "no fragment info")
   ENSURE(.atom.allocated, "no atoms to fit")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated,"no crystal xray data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated, "no density matrix")

      list :: VEC{STR}@
      tags :: VEC{STR}@
      labels    :: VEC{STR}@
      refine_U3 :: VEC{STR}@
      refine_U4 :: VEC{STR}@
      sf_d :: MAT{CPX}@
      sf_e, sf_u   :: VEC{CPX}@
      rc,Wc,wt     :: VEC{REAL}@
      xa,ya,za,a2  :: VEC{REAL}@
      rho, ga,gb   :: VEC{REAL}@
      skipa0,skipa :: VEC{BIN}@
      skipab,skipb :: VEC{BIN}@
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      pt,grida,gridb,bf_save     :: MAT{REAL}@
      arch :: ARCHIVE@
      sha :: SHELL1
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      n_keep,n_unique, n_k,n_p,n_p_atom, u,f,base :: INT
      a,n_f,n_pt, c,ca,cb, b,i,j,k,n,p :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb :: INT
      sa,fa,la,na, as :: INT
      sb,fb,lb,nb :: INT
      kv,ra :: VEC{REAL}(3)
      k_pts, k_pt :: MAT{REAL}@
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      dFc,dFc_atom, dFa_atom,dFb_atom :: MAT{CPX}@
      rf, cutoff,sc,s2,kr, Dab, val :: REAL
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      fac,zero3 :: REAL
      spin, has_skip,has_Uiso,is_H_atom :: BIN
      refine_positions,refine_Uiso :: BIN
      refine_positions_only,refine_ADPs_only :: BIN
      refine_ADPs,refine_ADP4s,refine_ADP3s :: BIN
      II, sf,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      tag :: STR

      ! Constants
      II  = IMAGIFY(ONE)
      n_p = .crystal.asymmetric_unit_atom.no_of_pADPs
      n_f = .crystal.fragment_atom.no_of_pADPs
      n_k = .crystal.n_unique_SF_k_pts
      
      ! Hirshfeld-atom structure factors
      n_unique = .crystal.n_unique_frag_atoms

      ! Make sure HA stuff is there
      .SCF:make_HA_inputs(skip_NOs=TRUE)

      ! Create refinement arrays & initialize (leaky)
      ! - asymmetric atom and fragment atom pADPs are set.
      ! Create space for asymmetric unit atom pADPs (leaky)
      refine_U3 = .crystal.xray_data.refine_3rd_order_for_atom
      refine_U4 = .crystal.xray_data.refine_4th_order_for_atom
      .crystal.asymmetric_unit_atom.reset_pADPs_and_errors(refine_U3,refine_U4)

      ! Create space for the fragment_atom pADPs (leaky)
      do f = 1,.crystal.n_fragment_atoms
         a = .crystal.asym_atom_for_frag_atom(f)
         n_p_atom = .crystal.asymmetric_unit_atom(a).no_of_pADPs
         .crystal.fragment_atom(f).reset_pADPs_and_errors(n_p_atom)
      end

      ! Set fragment_atom pADPs from asymmetric unit atom pADPs
      .crystal.set_frag_from_asym_pADPs 

      ! Get labels (leaky)
      labels = .crystal.asymmetric_unit_atom.tag_pADP_labels

      ! Is there a nothing list?
      has_skip = .crystal.xray_data.refine_nothing_for_atom.allocated
      if (has_skip) then
         tags = .crystal.fragment_atom.tag
         list = .crystal.xray_data.refine_nothing_for_atom
         DIE_IF(NOT list.has_all_elements_common_with(tags), "you try to refine nothing for an atom that is not in your list")
      end

      ! Are there atoms to be refined isotropically?
      has_Uiso = .crystal.xray_data.refine_U_iso_for_atom.allocated
      if (has_Uiso) then
         tags = .crystal.fragment_atom.tag
         list = .crystal.xray_data.refine_U_iso_for_atom
         DIE_IF(NOT list.has_all_elements_common_with(tags), "you try to refine an atom isotropically that is not in your list")
      end

      refine_ADPs_only = .crystal.xray_data.refine_ADPs_only
      refine_positions_only = .crystal.xray_data.refine_positions_only
      
      ! Defaults per atom
      if (NOT refine_ADPs_only) then 
         refine_positions = TRUE 
      else
         refine_positions = FALSE
      end
      
      if (NOT refine_positions_only) then 
         refine_ADPs      = TRUE
      else
         refine_ADPs      = FALSE
      end
      
      ! Final check to do U_iso this atom?
      refine_Uiso = FALSE
      if (NOT refine_Uiso) then
      if (has_Uiso) then
      if (any(.crystal.xray_data.refine_U_iso_for_atom==tag)) then
         refine_Uiso = TRUE
      end
      end
      end
      
      ! Skip derivatives for this atom?
      if (has_skip) then
      if (any(.crystal.xray_data.refine_nothing_for_atom==tag)) then
         refine_positions = FALSE
         refine_ADPs      = FALSE
      end
      end

      ! Sanity check
      ! Create refinement arrays & initialize (leaky)
      .crystal.xray_data.SET:initialize_fit_data(n_p,n_f,labels)

      ! Clean
      labels.destroy

      ! Allocate structure factor array (leaky)
      ! For pne atom
      dFc.create(.crystal.xray_data.reflections.dim,n_p)

      sf_e.create(n_k)     ! Symmetry generated SF's
      sf_e = ZERO

      do u = 1,n_unique

         refine_Uiso  = FALSE
         refine_ADP4s = .crystal.fragment_atom(u).has_only_ADP4s_and_errors
         refine_ADP3s = .crystal.fragment_atom(u).has_only_ADP3s_and_errors
    
         ! Special cases for H atom
         is_H_atom = .crystal.fragment_atom(u).atomic_number==1
         if (is_H_atom) then
            refine_positions = .crystal.xray_data.refine_H_positions
            refine_ADPs      = .crystal.xray_data.refine_H_ADPs
            refine_Uiso      = .crystal.xray_data.refine_H_U_iso
         end
    
         sf_u.create(n_k)
         sf_u = ZERO

         ! Symmetry generated K points and SF's
    
         ! Make list of symmetry non-equivalent symops
         ! and the necessary k points
         k_pts.create(n_k,3)
         .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
    
         ! X-ray or PND?
         spin = FALSE
    
         ! Density matrix (leaky)
         if (NOT spin) then; .BASE:make_r_density_mx
         else;               .BASE:make_r_Sz_density_mx
         end
         ENSURE(.density_mx.r.allocated, "no restricted DM")
    
         ! Basis function cutoff
         cutoff = .becke_grid.basis_function_cutoff
    
         ! Max no of becke grid points per atom
         n_pt = .becke_grid.max_no_of_points_per_atom
    
         ! Atom "a" displaced points and skip switches
         xa.create(n_pt)
         ya.create(n_pt)
         za.create(n_pt)
         a2.create(n_pt)
         skipa0.create(n_pt)
         skipab.create(n_pt)

         ! Loop over integration atoms "c"
         c  = .crystal.unique_frag_atom(u)
         rc = .atom(c).position
  
         ! Repetition factor for this atom
         sc = .crystal.frag_atom_sym_factor(c)

         if (NOT sc.is_zero) then

            s2 = ONE/sc
  
            ! Overlapping atoms
            overlapping_atom = .overlapping_atoms_for_atom(c).element
  
            ! Get the Becke grid for atom "c" (leaky)
            .becke_grid.make_grid(pt,wt,bf_save,c)
            n_pt = pt.dim1
  
            ! Make stockholder weight function "Wc" for atom "c"
            ! If using interpolatators, then on overlapping atoms
            ! are used ... otherwise nothing is skipped
            Wc.create(n_pt)
            if (.use_interpolators) then
               .GRID:make_stockholder_atom_grid(Wc,c,pt,overlapping_atom)
            else
               .GRID:make_stockholder_atom_grid(Wc,c,pt)
            end
  
            ! Incorporate integration weight
            wt = Wc*wt
  
            Wc.destroy
  
            ! Prune the grid with new "wt", get saved bf grid bf_save,
            ! and new no of points, n_pt (leaky)
            .becke_grid.prune_grid(pt,wt,bf_save)
            n_pt = pt.dim1
  
            ! Basis function grid and skip list
            bf_skip.create(.n_shell)
            bf_grid.create(.n_shell)
  
            ! Density for atom "c"
            rho.create(n_pt)
            rho = ZERO
  
            ! Loop c-overlapping atoms a
            do ca = 1,overlapping_atom.dim
  
               oa  = overlapping_atom(ca)
               fsa = .first_shell_for_atom(oa)
               lsa =  .last_shell_for_atom(oa)
               fba = .first_basis_fn_for_atom(oa)
               ra  = .atom(oa).position
  
               ! Make the displaced points for atom "a"
               .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)
  
               ! Loop shells on atom a
               do sa = fsa,lsa
  
                  ! Shell a limits
                  fa = .first_basis_fn_for_shell(sa)
                  la =  .last_basis_fn_for_shell(sa)
                  na = la - fa + 1
                  as = .basis_shell_for_shell(sa)
  
                  ! Set shell "sa"
                  sha = .basis_shell1pair(as,1).a
                  sha.position = ra
  
                  ! Make shell "sa" skip list
                  skipa.create(n_pt)
                  sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)
  
                  ! Next shell "sa" if no sig. points
                  if (n_keep==0) then
                     skipa.destroy
                     cycle
                  end
  
                  ! Assign the "sa" skipa list
                  bf_skip(sa).element = skipa
  
                  ! Make/copy the "sa" basis function grida
                  ! This must be copied since skipa could be TRUE
                  bf_grid(sa).element.create(n_keep,na)
                  if (oa/=c) then
                     ! Calculate grid if necessary
                     sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
                  else
                     ! Extract grid values from saved grid values
                     do a = 1,na
                        i = 0
                        do n = 1,n_pt
                           if (skipa(n)) cycle
                           i = i + 1
                           bf_grid(sa)[i,a] = bf_save(n,a+fa-fba)
                        end
                     end
                  end
                  grida = bf_grid(sa).element
  
                  ! Loop c-overlapping atoms b
                  do cb = 1,ca
  
                     ob  = overlapping_atom(cb)
                     fsb = .first_shell_for_atom(ob)
                     lsb =  .last_shell_for_atom(ob)
  
                     ! Loop shells on atom b
                     do sb = fsb,min(lsb,sa)
  
                        ! No significant points ... save time!
                        if (bf_skip(sb).element.deallocated) cycle
  
                        ! Shell b limits
                        fb = .first_basis_fn_for_shell(sb)
                        lb = .last_basis_fn_for_shell(sb)
                        nb = lb - fb + 1
  
                        ! Set the "sb" basis function grid
                        skipb = bf_skip(sb).element
                        gridb = bf_grid(sb).element
  
                        ! How many points in common? Save time?
                        skipab(1:n_pt) = skipa OR skipb
                        n_keep = count(NOT skipab(1:n_pt))
                        if (n_keep==0) cycle
  
                        ! Factor
                        fac = TWO
                        if (sa==sb) fac = ONE
  
                        ! Density block
  
                        if (na*nb==1) then ! s.s product
  
                           ! Add density contribution to rho
                           ga = grida(:,1)
                           gb = gridb(:,1)
                           Dab = fac*.density_mx.r(fa,fb)
                           i = 0; j = 0
                           do n = 1,n_pt
                              if (NOT skipa(n)) i = i + 1
                              if (NOT skipb(n)) j = j + 1
                              if (skipab(n)) cycle
                              val    = ga(i)*gb(j)*Dab
                              rho(n) = rho(n) + val
                           end
  
                        else              ! not s.s product
  
                           ! Create space for gathered index info
                           pi.create(n_keep)
                           pj.create(n_keep)
                           pn.create(n_keep)
  
                           ! Make mapper arrays
                           p = 0; i = 0; j = 0
                           do n = 1,n_pt
                              if (NOT skipa(n)) i = i + 1
                              if (NOT skipb(n)) j = j + 1
                              if (skipab(n)) cycle
                              p = p + 1
                              pi(p) = i
                              pj(p) = j
                              pn(p) = n
                           end
  
                           ! Add density contribution to rho
                           do a = 1,na
                              ga = grida(:,a)
                              do b = 1,nb
                                 gb = gridb(:,b)
                                 Dab = fac*.density_mx.r(fa+a-1,fb+b-1)
                                 do p = 1,n_keep
                                    i = pi(p)
                                    j = pj(p)
                                    n = pn(p)
                                    val    = ga(i)*gb(j)*Dab
                                    rho(n) = rho(n) + val
                                 end
                              end
                           end
  
                           ! Clean up
                           pn.destroy
                           pj.destroy
                           pi.destroy
  
                        end
  
                     end
                  end
               end
            end
  
            ! Weight the atom "c" density
            rho = rho*wt
  
            ! Get aspherical form factor sf_u
            do k = 1,n_k
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               sf = IMAGIFY(ZERO)
               do i = 1,n_pt
                  kr = k1*pt(i,1)+k2*pt(i,2)+k3*pt(i,3)
                  sf = sf + rho(i)*exp(IMAGIFY(kr))
               end
               sf_u(k) = sf * s2
            end
  
         !  ! Write out sf_u
         !  arch.create(trim(.atom(c).tag)//"-SFs")
         !  if (.crystal.xray_data.use_text_SFs) arch.set_format("ascii")
         !  arch.parallel_write(sf_u)
         !  arch.destroy
  
            ! Clean up atom "c" stuff
            rho.destroy
            grida.destroy
            gridb.destroy
            bf_grid.destroy
            bf_skip.destroy
            bf_save.destroy
            wt.destroy
            pt.destroy
  
            ! Clean up
            skipab.destroy
            skipa0.destroy
            a2.destroy
            za.destroy
            ya.destroy
            xa.destroy
            k_pts.destroy

         end

       ! .SCF:get_Hirshfeld_atom_FFs(sf_u)
   
         ! Do a least squares
  
         ! Do the fit 
  
         ! Place asym atom position/ADPs in vector .xray_data.X_fit
         ! - asymmetric_unit_atom keeps the pADPs
         .crystal.asymmetric_unit_atom.put_pADP_vector_to(.crystal.xray_data.X_fit)
         
         ! If refining, store a copy of the pADPs in .xray_data.X_ref
         if (.crystal.xray_data.refine_structure) .crystal.xray_data.X_ref = .crystal.xray_data.X_fit
         
         ! Banner, options/switches, initial parameters,
         ! start banner, and iteration table header.
         .crystal.put_fit_header
         
         ! Constants
         ! Fragment atom
         f   = .crystal.unique_frag_atom(u)
         a   = .crystal.asym_atom_for_frag_atom(f) ! declare
         n_p_atom = .crystal.asymmetric_unit_atom(a).no_of_pADPs
         
         
         ! Per u-atom Symmetry generated structure factors
         sf_d.create(n_k,n_p_atom) ! Symmetry generated SF derivatives
         
         ! Aspherical temperature independent SFs
         ! sf_u = ZERO
         ! HERE
         
         ! Symmetry generated k points
         k_pt.create(n_k,3)
         .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pt,.crystal.spacegroup,.crystal.unit_cell)
         
         ! Refine only 4th's?
         zero3 = ONE
         if (.crystal.xray_data.refine_4th_order_only) zero3 = ZERO
         
         ! Initialize
         sf_d = ZERO
         
         ! This atom's label
         tag = .crystal.fragment_atom(f).tag
  
  
         ! Read stored SFS !!!!!!!!!!!!
         ! arch.create(trim(tag)//"-SFs")
         ! if (.crystal.xray_data.use_text_SFs) arch.set_format("ascii")
         ! arch.read(sf_u)
         ! arch.destroy
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
         ! May need to be initialised. Trying without atm
         ! DIE_IF(NOT adp2.equals(.crystal.fragment_atom(f).ADP_tensor),"ADP2 not equal to ADP_tensor")
            
         ! Get ADP2s
         .crystal.fragment_atom(f).put_ADP2_vector_to(adp2)
         
         ! ADP4's !!!!!!!!!!!!!
         if (refine_ADP4s) then
         !!!!!!!!!!!!!!!!!!!!!!
         
            ! Get ADP tensors
            .crystal.fragment_atom(f).put_ADP3_vector_to(adp3)
            .crystal.fragment_atom(f).put_ADP4_vector_to(adp4)
         
            do k = 1,n_k
         
               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]
         
               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3
         
               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER
         
               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)
         
               ! Multiples of *anharmonic* structure factor
               sf1 = sfh * (ONE - II*c3 + c4)
               sf2 = sf1 * HALF
         
               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1
         
               if (refine_positions) then 
                  sf_d(k, 1) =  II*k1*sf1
                  sf_d(k, 2) =  II*k2*sf1
                  sf_d(k, 3) =  II*k3*sf1
               end
         
               if (refine_ADPs) then
         
                  ! U2 derivatives
                  sf_d(k, 4) = -k1_k1*sf2
                  sf_d(k, 5) = -k2_k2*sf2
                  sf_d(k, 6) = -k3_k3*sf2
                  sf_d(k, 7) = -k1_k2*sf1
                  sf_d(k, 8) = -k1_k3*sf1
                  sf_d(k, 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf4  = sf1 * QUARTER
                  sf6  = sf1 * SIXTH
                  sf24 = sf1 * SIXTH*QUARTER
                 
                  ! U3 derivatives
                  sf_d(k,10) = -II*k1_k1*k1*sf6*zero3
                  sf_d(k,11) = -II*k2_k2*k2*sf6*zero3
                  sf_d(k,12) = -II*k3_k3*k3*sf6*zero3
                  sf_d(k,13) = -II*k1_k1*k2*sf2*zero3
                  sf_d(k,14) = -II*k1_k1*k3*sf2*zero3
                  sf_d(k,15) = -II*k2_k2*k1*sf2*zero3
                  sf_d(k,16) = -II*k2_k2*k3*sf2*zero3
                  sf_d(k,17) = -II*k3_k3*k1*sf2*zero3
                  sf_d(k,18) = -II*k3_k3*k2*sf2*zero3
                  sf_d(k,19) = -II*k1*k2*k3*sf1*zero3
                 
                  ! U4 derivatives
                  sf_d(k,20) = k1_k1*k1_k1*sf24
                  sf_d(k,21) = k2_k2*k2_k2*sf24
                  sf_d(k,22) = k3_k3*k3_k3*sf24
                  sf_d(k,23) = k1_k1*k1_k2*sf6
                  sf_d(k,24) = k1_k1*k1_k3*sf6
                  sf_d(k,25) = k2_k2*k1_k2*sf6
                  sf_d(k,26) = k2_k2*k2_k3*sf6
                  sf_d(k,27) = k3_k3*k1_k3*sf6
                  sf_d(k,28) = k3_k3*k2_k3*sf6
                  sf_d(k,29) = k1_k1*k2_k2*sf4
                  sf_d(k,30) = k1_k1*k3_k3*sf4
                  sf_d(k,31) = k2_k2*k3_k3*sf4
                  sf_d(k,32) = k1_k1*k2_k3*sf2
                  sf_d(k,33) = k2_k2*k1_k3*sf2
                  sf_d(k,34) = k3_k3*k1_k2*sf2
         
               end
         
            end
         
         
         ! ADP3's !!!!!!!!!!!!!!!!!!
         else if (refine_ADP3s) then
         !!!!!!!!!!!!!!!!!!!!!!!!!!!
         
         
            ! Get ADP tensors
            .crystal.fragment_atom(f).put_ADP3_vector_to(adp3)
         
            do k = 1,n_k
         
               ! Scattering vector
               k1 = k_pt(k,1)
               k2 = k_pt(k,2)
               k3 = k_pt(k,3)
               kv = [k1,k2,k3]
         
               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3
         
               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
         
               ! Static structure factor x TF
               ! i.e. dynamic structure factor,
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)
         
               ! Multiples of *anharmonic* structure factor
               ! -- 3rd order only.
               sf1 = sfh * (ONE - II*c3)
               sf2 = sf1 * HALF
         
               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1
         
               !test refine_H_positions Lorraine
               if (refine_positions) then
         
                  ! Pos derivatives
                  sf_d(k, 1) =  II*k1*sf1
                  sf_d(k, 2) =  II*k2*sf1
                  sf_d(k, 3) =  II*k3*sf1
         
               end
         
               if (refine_ADPs) then
         
                  ! U2 derivatives
                  sf_d(k, 4) = -k1_k1*sf2
                  sf_d(k, 5) = -k2_k2*sf2
                  sf_d(k, 6) = -k3_k3*sf2
                  sf_d(k, 7) = -k1_k2*sf1
                  sf_d(k, 8) = -k1_k3*sf1
                  sf_d(k, 9) = -k2_k3*sf1
                 
                  ! Structure factor (harmonic!)
                  sf1  = sfh
                 
                  ! Multiples of *harmonic* sf
                  sf2  = sf1 * HALF
                  sf6  = sf1 * SIXTH
                 
                  ! U3 derivatives
                  sf_d(k,10) = -II*k1_k1*k1*sf6
                  sf_d(k,11) = -II*k2_k2*k2*sf6
                  sf_d(k,12) = -II*k3_k3*k3*sf6
                  sf_d(k,13) = -II*k1_k1*k2*sf2
                  sf_d(k,14) = -II*k1_k1*k3*sf2
                  sf_d(k,15) = -II*k2_k2*k1*sf2
                  sf_d(k,16) = -II*k2_k2*k3*sf2
                  sf_d(k,17) = -II*k3_k3*k1*sf2
                  sf_d(k,18) = -II*k3_k3*k2*sf2
                  sf_d(k,19) = -II*k1*k2*k3*sf1
         
               end
         
            end
         
         
         ! ADP2's !!!!!!!!!!!!!!
         else ! NO anharmonicity
         !!!!!!!!!!!!!!!!!!!!!!!
         
         
            ! This is for isotropic refinement
            if (refine_Uiso) then ! For U_iso 
         
               do k = 1,n_k
         
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
         
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
         
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
         
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
         
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF * (k1_k1+k2_k2+k3_k3)
         
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
         
                  if (refine_positions) then
         
                     ! Pos derivatives
                     sf_d(k, 1) =  II*k1*sf1
                     sf_d(k, 2) =  II*k2*sf1
                     sf_d(k, 3) =  II*k3*sf1
         
                  end
         
                  if (refine_ADPs) then
         
                     ! U_iso derivatives
                     sf_d(k, 4) = -sf2
                     sf_d(k, 5) = -sf2
                     sf_d(k, 6) = -sf2
                     sf_d(k, 7) = ZERO
                     sf_d(k, 8) = ZERO
                     sf_d(k, 9) = ZERO
         
                  end
         
               end
         
            ! This is an isotropic refinement
            else ! For ADP2s !!!!!!!!!!!!!!!!!
         
               do k = 1,n_k
         
                  ! Scattering vector
                  k1 = k_pt(k,1)
                  k2 = k_pt(k,2)
                  k3 = k_pt(k,3)
                  kv = [k1,k2,k3]
         
                  ! Component products
                  k1_k1 = k1*k1
                  k2_k2 = k2*k2
                  k3_k3 = k3*k3
                  k1_k2 = k1*k2
                  k1_k3 = k1*k3
                  k2_k3 = k2*k3
         
                  ! U tensor contracted with k vector
                  c2 = adp2.contract_with(kv)*HALF
         
                  ! Static structure factor x TF
                  ! i.e. dynamic structure factor,
                  ! in the harmonic approximation
                  sfh = sf_u(k) * exp(-c2)
         
                  ! Multiples *harmonic* structure factor
                  sf1 = sfh
                  sf2 = sf1 * HALF
         
                  ! SF contribution (harmonic)
                  sf_e(k) = sf_e(k) + sf1
         
                  if (refine_positions) then
         
                     ! Pos derivatives
                     sf_d(k, 1) =  II*k1*sf1
                     sf_d(k, 2) =  II*k2*sf1
                     sf_d(k, 3) =  II*k3*sf1
         
                  end
         
                  if (refine_ADPs) then
         
                     ! U2 derivatives
                     sf_d(k, 4) = -k1_k1*sf2
                     sf_d(k, 5) = -k2_k2*sf2
                     sf_d(k, 6) = -k3_k3*sf2
                     sf_d(k, 7) = -k1_k2*sf1
                     sf_d(k, 8) = -k1_k3*sf1
                     sf_d(k, 9) = -k2_k3*sf1
         
                  end
         
               end
         
            end
         
         end
         
         ! Clean
         k_pt.destroy ! KEEP ... Keep what? DJ
         
         ! WRITE SF_U TO DISK HERE TO SAVE TIME
         ! Write out sf_u
         arch.create(trim(.atom(c).tag)//"-SFs")
         if (.crystal.xray_data.use_text_SFs) arch.set_format("ascii")
         arch.parallel_write(sf_u)
         arch.destroy
         
         sf_u.destroy
         
         ! .crystal.make_unique_sf_derivs(sf_e,sf_d) ! processor 1 finishes here
         
         ! Make and set F_pred with scale & extinction.
         .crystal.xray_data.reflections.reset_F_corr_to_F_exp ! We fit to F_corr
         .crystal.make_F_predicted_from(sf_e)            ! Always includes dispersion
         
         ! Base index for unique frag atom
         base = .crystal.fragment_atom(.crystal.unique_frag_atom).no_of_pADPs_up_to_atom(u)
         
         ! Sum the symmetry-generated SF's to get
         ! the derivative structure factors dFc
         dFc_atom.create(.crystal.xray_data.reflections.dim,n_p_atom)
         .crystal.spacegroup.sum_unique_sf_derivs(dFc_atom,sf_d,.crystal.xray_data.reflections) ! Check dimensions in here
         sf_d.destroy
         
         ! Add derivative of anomalous contribution to |SF|, dFc
         ! Only if F_calc has anomalous dispersion added into it.
         if (.crystal.xray_data.add_dispersion_to_F_calc) then
         
            ! Size of symmetry generated k points
            ! WARNING: new k_pt array
            n_k = .crystal.n_symop_generated_SF_k_pts
            k_pts.create(n_k,3) ! NEW
          
            ! Size of anamalous Jacobian
            dFa_atom.create(n_k,n_p_atom)
            dFb_atom.create(.crystal.xray_data.reflections.dim,n_p)
          
            ! The full list of symmetry-generated k points
            .crystal.xray_data.reflections.make_symop_generated_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
          
            ! Note: each atom contribution scales by a site-symmetry factor
            dFa_atom = ZERO
          
            rf = .crystal.frag_atom_sym_factor(f)
            if (NOT rf.is_zero) then
               base = .crystal.fragment_atom(.crystal.unique_frag_atom).no_of_pADPs_up_to_atom(u)
               .crystal.fragment_atom(f).add_derivative_dispn(dFa_atom,base,k_pts,rf) ! Get rid of base here
            end
          
            ! Add together symmetry contributions
            dFb_atom = ZERO
            .crystal.spacegroup.add_full_sf_derivs_d(dFb_atom,dFa_atom,.crystal.xray_data.reflections)
          
            dFc_atom = dFc_atom + dFb_atom
         
            ! Clean
            dFb_atom.destroy
            dFa_atom.destroy
            k_pts.destroy
         
         end 
         
         ! Copy & clean
         dFc(:,base+1:base+n_p_atom) = dFc_atom
         dFc_atom.destroy

      end
     
      sf_e.destroy
     
      ! Get the derivative absolute SF's, F_abs = |F_calc|
      .crystal.xray_data.INQ:d_F_abs_dX(d_Fa,dFc)
      dFc.destroy

   end

   do_LS_refinement(d_Fa) ::: leaky 
   ! Performs the least squares refinement
      self :: INOUT
      d_Fa :: MAT{REAL}@, INOUT

      dF :: MAT{REAL}@

      ! Get the unique atom shifts, dX (leaky)
      .crystal.xray_data.SET:solve_normal_equations(d_Fa)

      ! Change/store unique frag atom -> asym atom shifts
      ! Change/store the covariance matrix too.
      .crystal.set_asym_from_ufrag_shifts ! .xray_data.dX now for asym atoms
      .crystal.set_asym_from_ufrag_cov_mx

      ! Stop symmetry breaking
      ! NOTE: we should apply this to the gradient *not*
      ! the shift to make sure the shift maintains symmetry
      .crystal.stabilize_asym_atom_shifts

      ! Store old asym-atom parameter vector.
      ! Add shift dA to get new .xray_data.X_fit
      .crystal.xray_data.SET:update_fit_parameters
      .crystal.asymmetric_unit_atom.set_pADP_vector_to(.crystal.xray_data.X_fit)

      ! Set the fit errors e.g. max(dX/esd)
      ! Copy them to the asymmetric unit atoms.
      .crystal.update_fit_esds
      .crystal.asymmetric_unit_atom.set_pADP_errors_to(.crystal.xray_data.covariance_mx,.crystal.xray_data.refine_H_U_iso)

      ! Set ALL fragment_atom positions/ADPs from asym atoms HERE
      ! >>>fragment_atom must be the same as molecule.atom
      dF.create(3,.crystal.n_fragment_atoms)
      .crystal.set_frag_from_asym_pADPs(dF)

      ! Update structure factors, the unique (rigid) frag atom SF's.
      ! Use the frag atom position shifts "dF".
      .crystal.shift_update_ff(dF)
      dF.destroy

   end

!  ==============
!  IAM refinement
!  ==============

   IAM_refinement
   ! Do an IAM refinement. Actually this is just a fit.
   ! Cartesian (bohr) coordinates are used because structure factors
   ! are aspherical and calculated from the QM wavefunction.
   ! NOTE: this routine does only one cycle of fitting with the
   ! current density matrix i.e. this is a "rigid atom fit".
   ! NOTE: It's tricky exactly which atom's are used for refinement:
   ! * Structure factors are calculated only for *unique* fragment
   !   atoms since the QM wavefunction refers to the fragment_atoms.
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to the fragment atom
   !   positions and ADPs) but these parameters and shifts are later
   !   transformed back into asymmetric unit.
      self :: INOUT

   ENSURE(.atom.allocated, "no atoms to fit")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated,"no crystal xray data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      ff :: MAT{CPX}@
      keep :: BIN

      ! Set IAM/save state
      keep = .crystal.xray_data.use_IAM_density
      .crystal.xray_data.SET:set_use_IAM_density(TRUE)

      ! Isotropic H's?
    ! if (.crystal.xray_data.refine_H_U_iso) .atom.set_isotropic_H_ADP

      ! Get atom SF's
      .SCF:get_unique_IAM_atom_SFs(ff)

      ! Do a least squares
      .HAR:LS_fit(ff,.crystal.xray_data.show_fit_output,.crystal.xray_data.show_fit_results)

      ! Clean up
      ff.destroy

      ! Restore original state
      .crystal.xray_data.SET:set_use_IAM_density(keep)

      ! Put analysis info ...
      if (.crystal.xray_data.do_standard_plots) then
         .crystal.put_X_data_analysis(output=TRUE)
      end

      ! Correlations
      .crystal.put_correlations(name=trim(.name)//".correlation-coefficients")

      ! Put residuals ...
      if (.crystal.xray_data.do_residual_cube) then
         .SCF:get_minmax_residual_density(output=TRUE)
      end

      ! Put final CIF after residuals
      .PUT:put_CIFs(with_ESDs=TRUE)

      ! Do standatd plots and properties
      if (.crystal.xray_data.do_standard_plots) then
      end

   end

!  ========================
!  Least-squares refinement
!  ========================

   LS_fit(ff,output,results) ::: leaky, private
   ! Do a least sqaures structure refinement with a given set of
   ! static aspherical form factors "ff". Note the dimensions.
   ! The structure factors "ff" update when the geometry shifts.
   ! If "output"  is false, do not print any LS fit output.
   ! If "results" is false, do not print any LS fit results.
      self :: INOUT
      ff   :: MAT{CPX}, INOUT
      output,results :: BIN, IN

   ENSURE(.atom.allocated, "no atoms to fit")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated,"no crystal xray data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")
   ENSURE(ff.dim1==.crystal.n_unique_SF_k_pts,       "ff: wrong dim1")
   ENSURE(ff.dim2==.crystal.n_asymmetric_unit_atoms, "ff: wrong dim2")

      ! Do the fit 
      .crystal.LS_structure_fit(ff,output,results)

      ! Set geometry type
      .atom = .crystal.fragment_atom
      .crystal.asymmetric_unit_source = "tonto-refinement"

      if (NOT .crystal.xray_data.use_IAM_density) then

         ! Delete stored matrices
         .SET:delete_SCF_archives(keep_DM=TRUE)
         .SET:destroy_SCF_results(keep_MOs=TRUE)
         .SET:destroy_SCF_integrals

         ! Orthonormalize MO's at new geometry
         if (NOT .crystal.xray_data.partition_model=="oc-crystal23") then
         .SCF:symmetrically_orthonormalize(.MOs)
         end

      end

      ! Put residuals ...
      if (.crystal.xray_data.do_residual_cube) &
         .SCF:get_minmax_residual_density(output=TRUE)

      ! Correlations
      .crystal.put_correlations(name=trim(.name)//".correlation-coefficients")

   end

   ! Split? Simplifify logic & presentation?

   LS_fit(output,results) ::: leaky, private
   ! Do a least sqaures structure refinement with a given set of
   ! static aspherical form factors which are on disk.
   ! If "output"  is false, do not print any LS fit output.
   ! If "results" is false, do not print any LS fit results.
      self :: INOUT
      output,results :: BIN, IN

   ENSURE(.atom.allocated, "no atoms to fit")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      ! Do the fit 
      .crystal.LS_structure_fit(output,results)

      ! Set geometry type
      .atom = .crystal.fragment_atom
      .crystal.asymmetric_unit_source = "tonto-refinement"

      if (NOT .crystal.xray_data.use_IAM_density) then

         ! Delete stored matrices
         .SET:delete_SCF_archives(keep_DM=TRUE)
         .SET:destroy_SCF_results(keep_MOs=TRUE)
         .SET:destroy_SCF_integrals

         if (.scfdata.allocated) then
         if (NOT .scfdata.SCF_kind(1:8)=="fragment") then
         ! Orthonormalize MO's at new geometry
         .SCF:symmetrically_orthonormalize(.MOs)
         end
         end

      end

   end

!  ===============
!  Invariom labels
!  ===============

   put_SMILES_invariom_labels
   ! Analyze the SCF energy into MO contributions
      self :: IN

   ENSURE(.atom.allocated,"no atoms")

      labels :: VEC{STR}@
      invariom_kind :: VEC{EVEC{INT}}@
      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels = .atom.smiles_invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("SMILES invariom labels:")
      stdout.put(labels,left=TRUE)

      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels =",invariom_kind.dim)
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_labels
   ! Analyze the SCF energy into MO contributions
      self :: IN

   ENSURE(.atom.allocated,"no atoms")

      labels :: VEC{STR}@
      invariom_kind :: VEC{EVEC{INT}}@

      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels = .atom.invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("Atom names and their invariom labels:")

      do k = 1,labels.dim
         stdout.put(k,width=5)
         stdout.put(.atom(k).label,width=10,left=TRUE)
         stdout.put(labels(k),width=25,left=TRUE)
         stdout.flush
      end
      stdout.flush


      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels =",invariom_kind.dim)
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush

      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))

      do k = 1,n_kind

         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush

      end

      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_label
   ! Analyze the SCF energy into MO contributions
      self :: IN

   ENSURE(.atom.allocated,"no atoms")

      label :: STR
      i :: INT

      stdin.read(i)
      label = .atom.invariom_label_of(i)
      stdout.flush
      stdout.show("Invariom label for atom "//trim(i.to_str)//" = ",label)

   end

   put_next_neighbour_handedness
   ! Put the next neighbour handedness out, for the atom with the
   ! index specified in the input.
      self :: IN

   ENSURE(.atom.allocated,"no atoms")

      hand :: STR
      i :: INT

      stdin.read(i)
      hand = .atom.next_neighbour_handedness_of(i)
      stdout.flush
      stdout.show("Next-neighbour handedness of atom "//trim(i.to_str)//" = ",hand)

   end

!  ====================================
!  Spherically averaged Hirshfeld atoms
!  ====================================

   make_iterative_HAs ::: leaky
   ! Make the (iteratively) Hirshfeld atoms a la Wheatly.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.n_atom_kind>0,"no atom kinds")

      max_iterations :: INT

      ! Do it
      max_iterations = 250
      .:make_SAHA(max_iterations)

   end

   make_spherically_averaged_HAs ::: leaky
   ! Make the (iteratively) spherically averaged Hirshfeld atom (SAHA)
   ! density interpolators. You may specify the maximum iterations on
   ! the input line if you want; if not, it is assumed to be 1.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.n_atom_kind>0,"no atom kinds")

      max_iterations :: INT

      ! Read max # if iterations
      max_iterations = 1
      if (stdin.n_line_items>1) stdin.read(max_iterations)

      ! Do it
      .:make_SAHA(max_iterations)

   end

   make_SAHA(max_iterations) ::: private, leaky
   ! Make the (iteratively) spherically averaged Hirshfeld atom (SAHA)
   ! density interpolators, for every atom. NOTE: these are supposed
   ! to be the iterative stockholder atoms (ISA) of Lillestolen &
   ! Wheatley, Chem. Commun., 2008, 59095911.
      self :: INOUT
      max_iterations :: INT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.n_atom_kind>0,"no atom kinds")

      interpolator :: VEC{INTERPOLATOR}@
      rho_av :: VEC{EVEC{REAL}}@
      max_eps,eps,eps_a :: REAL
      max_l, a,iteration :: INT

      ! Parameters defining the SAHA's
      max_l          = 18     ! L-value for for spherical averaging.
      max_eps        = TOL(6) ! Maximum absolute difference for convergence

      ! Switch interpolators on
      if (NOT .use_interpolators) then
         WARN("You must be using interpolators!")
         .use_interpolators = TRUE
      end

      ! Set default template for atom interpolators
      if (.interpolator.deallocated) then
         .interpolator.create
         .interpolator.set_interpolation_method("linear")
         .interpolator.set_range_mapping("none")
         .interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
         .interpolator.set_table_length(ONE)
         .interpolator.set_spacing(0.01d0)
         .interpolator.set_table_eps(0.001d0)
      end

      ! Reset ANO interpolators
      .SET:destroy_interpolators
      .SCF:make_HA_inputs

      ! Copy ANO interpolators (which become IHA's)
      interpolator.create(.n_atom)
      do a = 1,.n_atom
         interpolator(a) = .atom(a).interpolator
       ! interpolator(a).put
      end

      ! Reassign fresh (non-ANO) interpolator copy;
      ! Create averaged rho; set extrapolator.
      .SET:destroy_ANO_matrices
      rho_av.create(.n_atom)
      do a = 1,.n_atom
         .atom(a).interpolator = interpolator(a)
         rho_av(a).element.create(interpolator(a).n_data)
      end
      .atom.set_is_unique_kind(FALSE)

      ! Banner
      stdout.flush
      stdout.text("=========================================")
      stdout.text("Make spherically averaged Hirshfeld atoms")
      stdout.text("=========================================")

      stdout.flush
      if (max_iterations==1) then
      stdout.text("This will make a single-iteration average")
      else
      stdout.text("This may make an iteratively spherical averaged")
      stdout.text("Hirshfeld atom (IHA) or ISA as described by these :")
      stdout.text("Lillestolen & Wheatley, Chem. Commun., 2008, 59095911.")
      stdout.text("but only if the precedure converges!")
      stdout.flush
      stdout.show("Max. iterations             =",max_iterations)
      end

      stdout.show("Convergence on density      =",max_eps)
      stdout.show("L max (for spherical avg.)  =",max_l)

      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("Max change")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)


      ! Begin iterative cycle to get the IHA
      iteration = 0

      do

         iteration = iteration + 1

         ! Spherically average & extrapolate, for each atom
         eps = ZERO
         do a = 1,.n_atom

            .:make_spherically_averaged_HA(rho_av(a).element,eps_a,a,interpolator(a),max_l)

            eps = max(eps,eps_a)

         end

         ! Update convergence
         stdout.put(iteration)
         stdout.put(eps)
         stdout.flush

         ! Transfer averaged values to atoms and interpolators
         do a = 1,.n_atom
            interpolator(a).set_data_values(rho_av(a).element)
            interpolator(a).update
         end

         ! Spherically avereaged Hirshfeld atoms obtained?
         if (eps<max_eps) exit
         if (iteration>max_iterations) exit

      end

      ! Footer
      stdout.dash(int_fields=1,real_fields=1)

      ! Clean up
      rho_av.destroy

   end

   make_spherically_averaged_HA(rho_av,eps,a,interpolator,l_max)
   ! Make the spherically averaged Hirshfeld atom density "rho_av" for
   ! the atom with index "a". Also return "eps", the maximum
   ! difference between the rho_av values and those stored in the
   ! interpolator data_values. The spacing and radial data values from
   ! the center of atom "a" are taken from the "interpolator". "l_max"
   ! is the maximum l value for the lebedev angular integration grid
      rho_av :: VEC{REAL}, OUT
      eps :: REAL, OUT
      a,l_max :: INT, IN
      interpolator :: INTERPOLATOR

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.atom.has_all_interpolators,"No interpolators")
   ENSURE(rho_av.dim==interpolator.n_data,"wrong size, rho_av")
   ENSURE(a.is_in_range([1,.n_atom]),"a out of range")
   ENSURE(.overlapping_atoms_for_atom.allocated,"no overlapping_atoms")

      pt     :: MAT{REAL}@
      rho,Wa :: VEC{REAL}@
      pos    :: VEC{REAL}(3)
      old,r  :: REAL
      n_pts,n,i :: INT
      lebedev :: LEBEDEV@

      ! Set the spherical grid
      lebedev.create
      lebedev.set_l(l_max)

      ! No of quadrature points (on sphere)
      n_pts = lebedev.n_points

      ! Weight function, molecular density, spherical points
      ! and weights
      Wa.create(n_pts)
      rho.create(n_pts)
      pt.create(n_pts,3)

      ! Atom position
      pos = .atom(a).position

      ! Maximum relative difference
      eps = ZERO

    ! Debug
    ! stdout.show("atom =",a)
    ! interpolator.put

    ! stdout.put("r")
    ! stdout.put("rho_av")
    ! stdout.put("old")
    ! stdout.put("%")
    ! stdout.flush

      ! Loop over radial values
      do i = 1,interpolator.n_data

         ! Table value r
         r = interpolator.data_point(i)

         ! Interpolator data valie
         old = interpolator.data_value(i)

         ! Convert to actual r?
         if (interpolator.domain_is_sqrt_x1x) &
            r = sqrt(r/(1-r))*interpolator.domain_scale_factor

         ! For each r, make a spherical shell of points
         do n = 1,n_pts
            pt(n,1) = pos(1) + r*lebedev.point(n,1)
            pt(n,2) = pos(2) + r*lebedev.point(n,2)
            pt(n,3) = pos(3) + r*lebedev.point(n,3)
         end

         ! Weight function for atom a on the spherical shell
         .GRID:make_stockholder_atom_grid(Wa,a,pt,.overlapping_atoms_for_atom(a).element)

         ! Molecular density on the spherical shell
         .GRID:make_ED_grid(rho,pt)

         ! Weighted Hirshfeld atom density on shell
         Wa  = Wa*rho*lebedev.weight

         ! Averaged value
         rho_av(i) = VEC{REAL}:sum_elements(Wa)

         ! Average percentage change
         eps = max(eps,abs((rho_av(i)-old)))

    ! del = rho_av(i)-old
    ! stdout.put(r)
    ! stdout.put(rho_av(i))
    ! stdout.put(del)
    ! stdout.flush

      end

      ! Clean up
      pt.destroy
      rho.destroy
      Wa.destroy
      lebedev.destroy

   end

!  ====================
!  Bonded density atoms
!  ====================

   make_averaged_BDAs ::: leaky
   ! Make the spherically averaged bond density atom
   ! interpolators for every atom.
      self :: INOUT

   ENSURE(.use_interpolators,"must be using interpolators")

      interpolator :: VEC{INTERPOLATOR}@
      rho_av :: VEC{EVEC{REAL}}@
      eps,eps_a :: REAL
      a,l_max,iteration :: INT

      ! Set up the template for interpolators
      if (.interpolator.deallocated) then
         .interpolator.create
         .interpolator.set_interpolation_method("cubic_spline")
         .interpolator.set_range_mapping("none")
         .interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
         .interpolator.set_table_length(ONE)
         .interpolator.set_spacing(0.001d0)
         .interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)
      end

      ! Set up grids, atomic densities, and NO's
      .SCF:make_HA_inputs

      ! List of initial atom interpolators. Leaky
      interpolator.create(.n_atom)
      do a = 1,.n_atom
         interpolator(a) = .atom(a).interpolator
      end

      ! Destroy atom ANO data and interpolators. Leaky.
      .SET:destroy_ANO_matrices
      .SET:destroy_interpolators

      ! The list of new atomic radial densities
      rho_av.create(.n_atom)

      ! Reassign fresh interpolator copy; create averaged rho
      do a = 1,.n_atom
         .atom(a).interpolator = interpolator(a)
         rho_av(a).element.create(interpolator(a).n_data)
      end

      ! No of Gauss-Legendre integration points
      l_max = 35

      ! Banner
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("Max change")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)

      ! Begin iterative cycle
      iteration = 0

      do

         iteration = iteration + 1

         stdout.show("Iteration =",iteration)

         ! Spherically average each atom
         eps = ZERO
         do a = 1,.n_atom
            .:make_averaged_BDAs(rho_av(a).element,eps_a,a,interpolator(a),l_max)
            eps = max(eps,eps_a)
         end

         ! Update convergence
         stdout.put(iteration)
         stdout.put(eps)
         stdout.flush

         ! Transfer averaged values to atoms and interpolators
         do a = 1,.n_atom
            interpolator(a).set_data_values(rho_av(a).element)
            interpolator(a).update
            .atom(a).interpolator = interpolator(a)
          ! interpolator(a).put
         end

         ! Spherical atoms obtained
         if (eps<TOL(6)) exit
         if (iteration>=1) exit

      end

      ! Footer
      stdout.dash(int_fields=1,real_fields=1)

      ! Copy atom interpolators. Leaky
      do a = 1,.n_atom
         .atom(a).interpolator.destroy
         .atom(a).interpolator =  interpolator(a)
      end

      ! Clean up
      rho_av.destroy
      interpolator.destroy

   end

   make_averaged_BDAs(rho_av,eps,a,interpolator,l_max)
   ! Make the spherically averaged Hirshfeld atom density "rho_av" for
   ! the atom with index "a". Also return "eps", the maximum
   ! difference between the rho_av values and those stored in the
   ! interpolator data_values. The spacing and radial data values from
   ! the center of atom "a" are taken from the "interpolator". "l_max"
   ! is the maximum l value for the lebedev angular integration grid
      rho_av :: VEC{REAL}, OUT
      eps :: REAL, OUT
      a,l_max :: INT, IN
      interpolator :: INTERPOLATOR

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.atom.has_all_interpolators,"No interpolators")
   ENSURE(rho_av.dim==interpolator.n_data,"wrong size, rho_av")
   ENSURE(a.is_in_range([1,.n_atom]),"a out of range")

      pt :: MAT{REAL}@
      rho,Wa, del,pc :: VEC{REAL}@
      pos :: VEC{REAL}(3)
      old,r :: REAL
      n_pts,n,i :: INT
      lebedev :: LEBEDEV@

      ! Set the spherical grid
      lebedev.create
      lebedev.set_l(l_max)

      ! No of quadrature points (on sphere)
      n_pts = lebedev.n_points

      ! Weight function, molecular density, spherical points
      ! and weights
      Wa.create(n_pts)
      rho.create(n_pts)
      pt.create(n_pts,3)

      del.create(interpolator.n_data)
      pc.create(interpolator.n_data)

      ! Atom position
      pos = .atom(a).position

      ! Maximum relative difference
      eps = ZERO

      stdout.show("atom =",a)
      interpolator.put

    ! stdout.put("r")
    ! stdout.put("rho_av")
    ! stdout.put("old")
    ! stdout.put("%")
    ! stdout.flush

      ! Loop over radial values
      do i = 1,interpolator.n_data

         ! Table value r
         r = interpolator.data_point(i)

         ! Interpolator data valie
         old = interpolator.data_value(i)

         ! Convert to actual r?
         if (interpolator.domain_is_sqrt_x1x) &
            r = sqrt(r/(1-r))*interpolator.domain_scale_factor

         ! For each r, make a spherical shell of points
         do n = 1,n_pts
            pt(n,1) = pos(1) + r*lebedev.point(n,1)
            pt(n,2) = pos(2) + r*lebedev.point(n,2)
            pt(n,3) = pos(3) + r*lebedev.point(n,3)
         end

         ! Weight function for atom a on the spherical shell
         .GRID:make_bond_density_atom_grid(Wa,pt,a)

         ! Weighted Hirshfeld atom density on shell
         Wa  = Wa*lebedev.weight

         ! Averaged value
         rho_av(i) = VEC{REAL}:sum_elements(Wa)

         ! Average percentage change
         eps = max(eps,abs((rho_av(i)-old)))
         del(i) = rho_av(i)-old
         pc(i)  = del(i)/old

    ! stdout.put(r)
    ! stdout.put(rho_av(i))
    ! stdout.put(old)
    ! stdout.put(pc)
    ! stdout.flush

      end

      stdout.text("del:")
      stdout.put(del)

      stdout.text("pc:")
      stdout.put(pc)

      ! Clean up
      pc.destroy; del.destroy
      pt.destroy; rho.destroy; Wa.destroy
      lebedev.destroy

   end

   put_BDA_charges
   ! Put the BDA charges.
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")

      bond :: VEC{EVEC{INT}}@
      bond_charge :: VEC{EVEC{REAL}}@
      label :: STR
      a,b,c :: INT
      has_bond :: BIN

      ! Make the charges
      .:make_BDA_charges(bond,bond_charge)

      ! Put the table
      stdout.dash(real_fields=3)
      stdout.tab(real_fields=1)
      stdout.put("Bonded")
      stdout.put("Bond")
      stdout.flush
      stdout.put("Atom")
      stdout.put("Atom")
      stdout.put("Charge")
      stdout.flush
      stdout.dash(real_fields=3)

      do a = 1,.n_atom

         label = trim(.atom(a).label) // "(" // trim(a.to_str) // ")"
         stdout.put(label)

         has_bond = bond(a).element.allocated
         if (has_bond) has_bond = bond(a).element.dim>0

         if (NOT has_bond) then
            stdout.flush
         else

            do b = 1,bond(a).element.dim
               if (b>1) stdout.tab(real_fields=1)
               c = bond(a).element(b)
               label = trim(.atom(c).label) // "(" // trim(c.to_str) // ")"
               stdout.put(label)
               stdout.put(-bond_charge(a).element(b))
               stdout.flush
            end
            stdout.tab(real_fields=2)
            stdout.put(-VEC{REAL}:sum_elements(bond_charge(a).element))
            stdout.flush

         end

      end

      stdout.dash(real_fields=3)

      ! Clean up
      bond.destroy
      bond_charge.destroy

   end

   make_BDA_charges(bond,bond_charge) ::: leaky
   ! make the bond density atom charges.
      self :: INOUT
      bond :: VEC{EVEC{INT}}@, OUT
      bond_charge :: VEC{EVEC{REAL}}@, OUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")

      pt :: MAT{REAL}@
      wt,rho_aba,def_density_grid :: VEC{REAL}@
      bond_density_atom :: VEC{INT}@
      n_pt,a,b :: INT
      val :: REAL

      ! Set up grids, atomic densities, and NO's
      .SCF:make_HA_inputs

      ! Array for bonds and bond charges
      bond.create(.n_atom)
      bond_charge.create(.n_atom)

      ! Loop over atoms, a
      do a = 1,.n_atom

         ! Make becke grid
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1

         ! Deformation density on grid
         def_density_grid.create(n_pt)
         .GRID:make_def_ED_grid(def_density_grid,pt)

         ! Bond density on grid
         rho_aba.create(n_pt)

         ! bond density atom
         bond_density_atom.create(3)
         bond_density_atom(1) = a
         bond_density_atom(3) = a

         ! Loop over atoms b, bonded to a
         do b = 1,.n_atom

            if (a==b) cycle
            if (NOT .atom.bonded(a,b)) cycle

            ! Get the bond density
            bond_density_atom(2) = b
            .GRID:make_def_bond_density_grid(rho_aba,pt,bond_density_atom,def_density_grid)

            ! Get weighted integral
            rho_aba  = rho_aba*wt

            ! Get charge
            val = VEC{REAL}:sum_elements(rho_aba)

            ! Store charge
            bond(a).element.append(b)
            bond_charge(a).element.append(val)

         end

         ! Clean up
         bond_density_atom.destroy
         rho_aba.destroy
         def_density_grid.destroy
         pt.destroy
         wt.destroy

      end

   end

!  =======================================
!  Scaled and derivative stockholder grids
!  =======================================

   make_scaled_stockholder_derivs(G,H,kappa,delta,skip_NOs)
   ! Make the scaled stockholder atom derivatives "G" and hessian "H"
   ! for used in a Newton-Raphson procedure to find the best scale
   ! factors.
      self :: INOUT
      G :: VEC{REAL}, OUT
      H :: MAT{REAL}, OUT
      kappa :: VEC{REAL}, IN
      delta :: REAL, OUT
      skip_NOs :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.MOs.allocated, "no MO's")
   ENSURE(.MOs.r.allocated, "no restricted MO's")
   ENSURE(.becke_grid.allocated, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(H.is_square,"H is not square")
   ENSURE(G.dim==H.dim1,"G and H are inconsistent")

      Wa_cd :: MAT3{REAL}@
      pt,Wa_c :: MAT{REAL}@
      wt,Wa,G_grid,K_grid,Ga :: VEC{REAL}@
      delta2 :: REAL
      a,c,d,n_pt :: INT

      ! Set up grids, spherical atomic densities, and NO's
      .SCF:make_HA_inputs(skip_NOs)

      ! Make the stockholder derivatives D and H
      delta = ZERO
      G = ZERO
      H = ZERO
      do a = 1,.n_atom

         ! Make integration grids
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1

         ! Make G and K kinetic densities
         G_grid.create(n_pt)
         K_grid.create(n_pt)
         .GRID:make_G_and_K_kinetic_grids(G_grid,K_grid,pt)

         ! Make Hirshfeld atoms
         Wa.create(n_pt)
         .:make_stockholder_atom_grid(Wa,a,kappa,pt)

         ! Make delta kinetic grid
         G_grid = (G_grid - K_grid)*wt
         delta2 = TWO*VEC{REAL}:sum_elements(G_grid*Wa)
         delta  = delta + QUARTER*delta2*delta2
         Wa.destroy
         K_grid.destroy

         ! Stockholder 1st derivatives
         Ga.create(.n_atom)
         Wa_c.create(n_pt,.n_atom)
         .:make_d_stockholder_atom_grid(Wa_c,a,kappa,pt)
         do c = 1,.n_atom
            Ga(c) = VEC{REAL}:sum_elements(Wa_c(:,c)*G_grid)
         end
         Wa_c.destroy

         ! Add contribution from 1st derivatives
         G = G + delta2*Ga
         H.plus_outer_product_of(Ga,TWO)
         Ga.destroy

         ! Stockholder 2nd derivatives
         Wa_cd.create(n_pt,.n_atom,.n_atom)
         .:make_d2_stockholder_atom_grid(Wa_cd,a,kappa,pt)

         ! Add contribution from 2nd derivatives
         G_grid = delta2*G_grid
         do c = 1,.n_atom
         do d = 1,.n_atom
            H(c,d) = H(c,d) + VEC{REAL}:sum_elements(Wa_cd(:,c,d)*G_grid)
         end
         end
         Wa_cd.destroy

         ! Clean
         G_grid.destroy
         wt.destroy
         pt.destroy

      end

      delta = sqrt(delta)

   end

   make_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the scaled stockholder desity "grid" for the atom with index
   ! "a" and with scale parameters "kappa" using supplied points "pt".
   ! This uses gaussian atomic densities.
      self  :: IN
      grid  :: VEC{REAL}, OUT
      a     :: INT, IN
      kappa :: VEC{REAL}, IN
      pt    :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      rho_a  :: VEC{REAL}@
      n_pt,i :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_ED_grid(rho_a,pt)

      ! Make total density in "grid"
      grid = kappa(a)*rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_ED_grid(grid,pt,kappa(i))
      end

      ! Make the stockholder weight
      do i = 1,n_pt
       if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
       else;                           grid(i) = ZERO
       end
      end
      rho_a.destroy

   end

   make_d_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the derivative scaled stockholder desity "grid" for the atom
   ! with index "a" and with scale parameters "kappa" using supplied
   ! points "pt".  This uses gaussian atomic densities.
      self :: IN
      grid :: MAT{REAL}, OUT
      a  :: INT, IN
      kappa :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim1==pt.dim1,"wrong dim1, grid")
   ENSURE(grid.dim2==.n_atom,"wrong dim2, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      rho_a,rho_c,rho :: VEC{REAL}@
      n_pt,i,c :: INT

      ! Allocate temporary densities
      n_pt = grid.dim1
      rho_a.create(n_pt)
      rho_c.create(n_pt)
      rho.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_ED_grid(rho_a,pt)

      ! Make total density in "rho" with kappa factors
      rho_a = kappa(a)*rho_a
      rho = rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_ED_grid(rho,pt,kappa(i))
      end

      where (rho>epsilon(ONE)); rho_a = rho_a/(rho*rho)
      elsewhere;                rho_a = ZERO
      end

      ! Make the derivative stockholder weight
      do c = 1,.n_atom

        .atom(c).make_ED_grid(rho_c,pt)

        grid(:,c) = -rho_a*rho_c

        if (c/=a) cycle
        where (rho>epsilon(ONE)) grid(:,c) = grid(:,c) + rho_c/rho

      end

      ! Clean
      rho.destroy
      rho_c.destroy; rho_a.destroy

   end

   make_d2_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the 2nd derivative scaled stockholder desity "grid" for the
   ! atom with index "a" and with scale parameters "kappa" using
   ! supplied points "pt".  This uses gaussian atomic densities.
      self :: IN
      grid :: MAT3{REAL}, OUT
      a  :: INT, IN
      kappa :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim1==pt.dim1,"wrong dim1, grid")
   ENSURE(grid.dim2==.n_atom,"wrong dim2, grid")
   ENSURE(grid.dim3==.n_atom,"wrong dim3, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      rho_a,rho_c,rho_d,rho :: VEC{REAL}@
      n_pt,i,c,d :: INT

      ! Allocate temporary densities
      n_pt = grid.dim1
      rho_a.create(n_pt)
      rho_c.create(n_pt)
      rho_d.create(n_pt)
      rho.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_ED_grid(rho_a,pt)

      ! Make total density in "rho" with kappa factors
      rho_a = kappa(a)*rho_a
      rho = rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_ED_grid(rho,pt,kappa(i))
      end

      where (rho>epsilon(ONE)); rho_a = TWO*rho_a/(rho*rho*rho)
      elsewhere;                rho_a = ZERO
      end

      where (rho>epsilon(ONE)); rho = ONE/(rho*rho)
      elsewhere;                rho = ZERO
      end

      ! Make the derivative stockholder weight
      do c = 1,.n_atom

        .atom(c).make_ED_grid(rho_c,pt)

        do d = 1,.n_atom

           .atom(d).make_ED_grid(rho_d,pt)

           grid(:,c,d) =  rho_a*rho_c*rho_d

           if (c==a) grid(:,c,d) = grid(:,c,d) - rho_d*rho
           if (d==a) grid(:,c,d) = grid(:,c,d) - rho_c*rho

        end

      end

      ! Clean
      rho.destroy
      rho_d.destroy; rho_c.destroy; rho_a.destroy

   end

end
