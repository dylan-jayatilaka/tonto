!===============================================================================
!
! MOLECULE.NOMO: NOMO-related methods.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!===============================================================================

module MOLECULE.NOMO

   implicit none

   nomo_self :: MOLECULE*  DEFAULT_NULL

contains

!  ===
!  SCF
!  ===

   scf ::: leaky
   ! Do an SCF calculation. The following :
   !   .molecular_orbitals, .orbital_energies, .density_matrix
   ! are produced as results.
      self :: INOUT

   ENSURE(.scfdata.associated,"no scfdata provided")

      select case (.scfdata.scf_kind)

   !  case ("embedded_rhf")
   !     .embedded_scf

   !  case ("crystal_rhf")
   !     .crystal_scf

      case ("group")
         .SCF:group_scf

      case ("ghf","no_ghf")
        .:NO_ghf

      case ("xray_rhf","xray_rks","xray_uhf","xray_uks","xray_gchf", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         .SCF:constrained_scf

      case default
         .SCF:usual_scf

      end

   end

!  ==========================
!  Non-orthogonalk general HF
!  ==========================

   NO_ghf ::: leaky
   ! Do non-orthogonal SCF calculation. Bespoke.

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,   "no atom list")
   ENSURE(.scfdata.created,"no scfdata")

    !  if(.scfdata.use_ELMO_01) then
    !     .scfdata.set_use_ELMO_01(FALSE)
         .SCF:initialize_scf
    !     .scfdata.set_use_ELMO_01(TRUE)
    !  else
    !     .:initialize_scf
    !  end if

      .SCF:put_scf_banner_and_options
      .SCF:put_scf_table_header

      ! SCF iterations
      do

         .SCF:extrapolate_fock_matrix

         .:update_molecular_orbitals

         .BASE:make_scf_density_matrix

         .SCF:make_fock_matrix

         .SCF:update_scfdata
         .SCF:update_scfdata_error

         .SCF:put_scf_table_body

         if (.scfdata.scf_done) exit

      end

      if(.scfdata.use_ELMO_01) then
         .scfdata.set_use_ELMO_01(FALSE)
         .BASE:make_scf_density_matrix

         .SCF:make_fock_matrix

         .SCF:update_scfdata
         .SCF:update_scfdata_error

         .SCF:put_scf_table_body
      end if

      .SCF:put_scf_results

      .SCF:archive_scf_results

      .SCF:cleanup_scf

   end

!  ================================
!  Orbital update/cleaning routines
!  ================================

   update_molecular_orbitals
   ! Solve for the molecular orbitals.  Requires a set of old molecular
   ! orbitals.
   ENSURE(.scfdata.associated,"no scfdata")

      if      (.scfdata.use_NOMO) then;                 .:NOMO_update
      else;                                             .:MO_gradient_update
      end

   end

   MO_gradient_update
   ! Update the molecular orbitals using the gradient. Requires a set of old
   ! molecular orbitals. The new molecular orbitals "c" are found by
   ! incrementing a little along the gradient: (FDS - SDFDS)c and then
   ! reorthogonalising c.  NOTE: the normal Fock matrix DIIS update is turned
   ! off if this routine executes.
      self :: INOUT

   ENSURE(.scfdata.using_MO_gradient_update,"not allowed")
   ENSURE(.fock_matrix.associated,"no fock_matrix")
   ENSURE(.fock_matrix.has_any_genre,"no fock_matrix")
   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.has_any_genre,"no density_matrix")
   ENSURE(.molecular_orbitals.associated,"no MO's")
   ENSURE(.molecular_orbitals.has_any_genre,"no MO's")

      orb_kind :: STR
      MOv :: VEC{REAL}*
      gm,h,MO,F,P :: MAT{REAL}*
      f1,f2 :: REAL
      step :: REAL = ONE

      orb_kind = .scfdata.scf_kind

      select case (orb_kind)

      case ("rhf     ", &
            "rks     ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")

         F  => .fock_matrix.restricted
         P  => .density_matrix.restricted
         MO => .molecular_orbitals.restricted(:,1:.n_a)

         MOv.create(size(MO))
         MOv = reshape(MO,[size(MO)])
         .scfdata.bfgs.minimize_L_BFGS(::NOMO_gradient_r,MOv)

         MO = reshape(MOv,[.n_bf,.n_a])

      case default
         DIE("SCF kind "//trim(orb_kind)//" not implemented")

      end

   end

! NOMO

   NOMO_update
   ! Use the BFGS NOMO update ...
      self :: target

   ENSURE(.scfdata.use_NOMO,"not allowed")
   ENSURE(.fock_matrix.associated,"no fock_matrix")
   ENSURE(.fock_matrix.has_any_genre,"no fock_matrix")
   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.has_any_genre,"no density_matrix")
   ENSURE(.molecular_orbitals.associated,"no MO's")
   ENSURE(.molecular_orbitals.has_any_genre,"no MO's")

      orb_kind :: STR
      MOv, gv,sh :: VEC{REAL}*
      gm,ge,MO,MOa,MOb,F,P,Fa,Fb,Pa,Pb :: MAT{REAL}*
      E,delta :: REAL
      i :: INT

      orb_kind = .scfdata.scf_kind

      select case (orb_kind)

      case ("rhf     ", &
            "rks     ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")

         F  => .fock_matrix.restricted
         P  => .density_matrix.restricted
         MO => .molecular_orbitals.restricted(:,1:.n_a)

         if (.scfdata.use_BFGS) then

            ! Convert the vector
            MOv.create(size(MO))
            MOv = reshape(MO,[size(MO)])

            ! BFGS
            nomo_self => self
            .scfdata.bfgs.minimize_L_BFGS(::NOMO_gradient_r,MOv)

            ! Back to matrix
            MO = reshape(MOv,[.n_bf,.n_a])

            MOv.destroy

         else

            ! Least squares method
            sh.create(.n_bf*.n_a)
            gv.create(.n_bf*.n_a)
            gm.create(.n_bf,.n_a)

            .:make_NOMO_gradient_r(MO,E,gm)

            gv = reshape(gm,[size(gv)])

            MAT{REAL}::solve_normal_equations(gv,sh)

            MO = MO + 0.001*reshape(sh,[.n_bf,.n_a])
            
            do i=1,.n_a
               MO(:,i) = MO(:,i)/(MO(:,i).norm)
            end do

            ! Clean
            gm.destroy
            gv.destroy
            sh.destroy

         end
      
      case ("no_ghf","ghf")

         F  => .fock_matrix.general
         P  => .density_matrix.general
         MO => .molecular_orbitals.general(:,1:.n_e)

         if (.scfdata.use_BFGS) then
            
            if (.scfdata.use_ELMO_01) then
            
               ! Convert the vector
               MOv.create(size(MO))
               MOv = reshape(MO,[size(MO)])

               ! BFGS
               nomo_self => self
               .scfdata.bfgs.minimize_L_BFGS(::ELMO_01_gradient_g,MOv)

               ! Back to matrix
               MO = reshape(MOv,[2*.n_bf,.n_e])
                
               !do i=1,.n_a
               !   MO(:,i) = MO(:,i)/(MO(:,i).norm)
               !end do

                
               MOv.destroy
               
            else

               ! Convert the vector
               MOv.create(size(MO))
               MOv = reshape(MO,[size(MO)])

               ! BFGS
               nomo_self => self
               .scfdata.bfgs.minimize_L_BFGS(::NOMO_gradient_g,MOv)

               ! Back to matrix
               MO = reshape(MOv,[2*.n_bf,.n_e])

               MOv.destroy
                
            end if

         elseif (.scfdata.use_LSQ) then

            ! Least squares method
            sh.create(2*.n_bf*.n_e)
            gv.create(2*.n_bf*.n_e)
            gm.create(2*.n_bf,.n_e)

            .:make_NOMO_gradient_g(MO,E,gm)

            gv = reshape(gm,[size(gv)])

            delta = .scfdata.energy - .scfdata.E_initial

            MAT{REAL}::solve_normal_equations(gv,sh,delta)

            MO = MO + 1*reshape(sh,[.n_bf,.n_a])
            
            do i=1,.n_a
               MO(:,i) = MO(:,i)/(MO(:,i).norm)
            end do

            ! Clean
            gm.destroy
            gv.destroy
            sh.destroy

         ! A simple Gradient Check Operation
         else
            
            if (.scfdata.use_ELMO) then
               
               stdout.text("Fock: ")
               stdout.put(F)

               ! Creates the gradient matrix
               gm.create(2*.n_bf,.n_e)
               gm=ZERO

               ! Calculates gradient with equations derived from Stoll
               .:make_ELMO_01_gradient_g(MO,E,gm)
               ge.create(2*.n_bf,.n_e)
               ge = gm
               stdout.text("Equation Gradient: ")
               stdout.put(ge)
               gm = ZERO

               ! Ensures all values are solely due to FD approach 
               .:make_ELMO_01_gradient_g_fd(MO,E,gm)
               stdout.text("Finite Difference Gradient: ")
               stdout.put(gm)
               
               stdout.show("Difference is: ", norm2(gm-ge))
               
               ! Convert the vector
               MOv.create(size(MO))
               MOv = reshape(MO,[size(MO)])

               ! BFGS
               nomo_self => self
               .scfdata.bfgs.minimize_L_BFGS(::ELMO_01_gradient_g,MOv)

               ! Back to matrix
               MO = reshape(MOv,[2*.n_bf,.n_e])
                
               !do i=1,.n_a
               !   MO(:,i) = MO(:,i)/(MO(:,i).norm)
               !end do

                
               MOv.destroy
               
            
            else

               ! Creates the gradient matrix
               gm.create(2*.n_bf,.n_e)
               gm=ZERO

               ! Calculates gradient with equations derived from Stoll
               .:make_NOMO_gradient_g(MO,E,gm)
               ge.create(2*.n_bf,.n_e)
               ge = gm
               stdout.text("Equation Gradient: ")
               stdout.put(ge)
               gm = ZERO

               ! Ensures all values are solely due to FD approach 
               .:make_NOMO_gradient_g_fd(MO,E,gm)
               stdout.text("Finite Difference Gradient: ")
               stdout.put(gm)
               
               stdout.show("Difference is: ", norm2(gm-ge))
               stop
            
            end if
         
         end if
      
      case ("uhf     ")


         if (.scfdata.use_BFGS) then
            
           ! MOa => .molecular_orbitals.alpha(:,1:.n_a)
           ! MOb => .molecular_orbitals.beta(:,1:.n_b)

            ! Convert the vector
           ! MOv.create((size(MOa)+size(MOb)))
           ! MOv(1:(.n_a*.n_bf)) = reshape(MOa,[size(MOa)])
!            MOv((.n_a*.n_bf+1):.n_bf*(.n_a+.n_b)) = reshape(MOb,[size(MOb)])
!            
!            ! BFGS
!            nomo_self => self
!            .scfdata.bfgs.minimize_L_BFGS(::ELMO_gradient_u,MOv)
!
!            ! Back to matrix
!            MOa = reshape(MOv(1:.n_a*.n_bf),[.n_bf,.n_a])
!            MOb = reshape(MOv((.n_bf*.n_a+1):.n_bf*(.n_a+.n_b)),[.n_bf,.n_b])
!
!            MOv.destroy
!            
!            ! Back to matrix
!
!            MOv.destroy

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)

            ! Convert the vector
            MOv.create(size(MOa))
            MOv = reshape(MOa,[size(MOa)])

            ! BFGS
            nomo_self => self
            .scfdata.bfgs.minimize_L_BFGS_a(::NOMO_gradient_u_a,MOv)

            ! Back to matrix
            MOa = reshape(MOv,[.n_bf,.n_a])
            MOv.destroy

            ! Convert the vector
            MOv.create(size(MOb))
            MOv = reshape(MOb,[size(MOb)])

            ! BFGS
            .scfdata.bfgs.minimize_L_BFGS_b(::NOMO_gradient_u_b,MOv)

            ! Back to matrix
            MOb = reshape(MOv,[.n_bf,.n_b])
            MOv.destroy

!            MOb = reshape(MOv((.n_bf*.n_a+1):.n_bf*(.n_a+.n_b)),[.n_bf,.n_b])

         else

            ! Least squares method
            sh.create(.n_bf*.n_a)
            gv.create(.n_bf*.n_a)
            gm.create(.n_bf,.n_a)

            .:make_NOMO_gradient_r(MO,E,gm)

            gv = reshape(gm,[size(gv)])

            MAT{REAL}::solve_normal_equations(gv,sh)

            MO = MO + reshape(sh,[.n_bf,.n_a])
            
            do i=1,.n_a
               MO(:,i) = MO(:,i)/(MO(:,i).norm)
            end do

            ! Clean
            gm.destroy
            gv.destroy
            sh.destroy

         end

      case default
         DIE("SCF kind "//trim(orb_kind)//" not implemented")

      end

   end

   NOMO_electronic_energy_r(MO) result (res)
   ! Evaluates the NOMO electronic energy for an arbitrary
   ! non-orthogonal set of "MO" coefficients. NOTE: the density matrix
   ! and Fock is reconstruicted from, scratch!
      self :: IN
      MO :: MAT{REAL}, IN
      res :: REAL

      P,F :: OPMATRIX*

      ! Create
      F.create(.n_bf,"restricted")
      P.create(.n_bf,"restricted")

      ! Make NOMO density matrix "D"
      .BASE:make_NOMO_density_matrix_r(P.restricted,MO)

      ! Make two electron Fock matrix
      .FOCK:make_r_fock(P,F,core=FALSE)

      ! Make energy matrix
      F.scale_by(HALF)     ! 2-electron part x 1/2
      F.plus(.core_matrix) ! + h

      ! Do it
      res = P.restricted.trace_product_with(F.restricted)

      ! Cleanup
      P.destroy
      F.destroy

   end

   make_NOMO_gradient_r(MO,E,gm)
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gm = 4 (F MO S^{-1} - (1/2)S P F MO S^{-1}) as matrices!!!
      self :: IN
      MO :: MAT{REAL}, IN
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MO.dim1==.n_bf AND MO.dim2==.n_a,"MO wrong shape")
   ENSURE(gm.is_same_shape_as(MO),"gradient gm and MO are not the same shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      SP,S_inv, FcSm1,cSm1 :: MAT{REAL}*

      ! Create Fock & density matrix
      F.create(.n_bf,"restricted")
      P.create(.n_bf,"restricted")

      ! Make S, S^{-1} in the MO basis
      S_inv.create(.n_a,.n_a)
      .BASE:make_NOMO_S_inv_r(S_inv,MO)

      ! Back transform -> P
      S_inv.back_transform_to(P.restricted,MO(:,1:.n_a))

      ! Factor 2 for RHF
      P.scale_by(TWO)

      ! Make two electron Fock matrix 
      .FOCK:make_r_fock(P,F)

      ! Make F x c x S-1
      FcSm1.create(.n_bf,.n_a)
      cSm1.create(.n_bf,.n_a)
      cSm1.to_product_of(MO,S_inv)
      FcSm1.to_product_of(F.restricted,cSm1)
      cSm1.destroy

      ! Make S x P ... note 1/2 to cancel factor 2 in P.restricted
      SP.create(.n_bf,.n_bf)
      SP.to_scaled_product_of(.overlap_matrix,P.restricted,fac=HALF)

      ! Assemble 1st and 2nd terms of gradient
      gm = FcSm1
      gm.plus_scaled_product_of(SP,FcSm1,fac=-ONE)

      gm = FOUR*gm

      ! Make 2 x energy matrix
      F.plus(.core_matrix)

      ! Do energy
      E = HALF * F.expectation(P.restricted)

      ! Clean up
      SP.destroy
      FcSm1.destroy
      S_inv.destroy
      P.destroy
      F.destroy

   end

   NOMO_gradient_r(MO,E,gv) ::: selfless
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
      MO :: VEC{REAL}, IN
      E  :: REAL, OUT
      gv :: VEC{REAL}, OUT

      Cm,gm :: MAT{REAL}*
      self :: MOLECULE*

      ! Restore self
      self => nomo_self

      Cm.create(.n_bf,.n_a)
      gm.create(.n_bf,.n_a)

      Cm = reshape(MO,[.n_bf,.n_a])
      gm = reshape(gv,[.n_bf,.n_a])

      .:make_NOMO_gradient_r(Cm,E,gm)

      gv = reshape(gm,[.n_bf*.n_a])

      gm.destroy
      Cm.destroy

   end

   make_ELMO_01_gradient_g_fd(MO,E,gm)
   ! Make the ELMO energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - S P F MO S^{-1}, as matrices!!!
      self :: INOUT
      MO :: MAT{REAL}, INOUT
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MO.dim1==2*.n_bf AND MO.dim2==.n_e,"MO wrong shape")
   ENSURE(gm.is_same_shape_as(MO),"gradient gm and MO are not the same shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      S_inv :: MAT{REAL}*
      step, bm,b,m :: INT
      stps,stp2,leng :: REAL

      nullify(P)
      nullify(F)

      leng = 0.0001d0
         
      gm = ZERO

      do step = -1,1,2

        stps = step*leng
        stp2 = ONE/(TWO*leng)

        do bm = 1,2*.n_bf*.n_e

           ! ????
           b = mod(bm-1,2*.n_bf) + 1
           m = floor(real(bm-1)/(2*.n_bf)) + 1
           
           ! Add step
           MO(b,m) = MO(b,m) + stps

           ! Fock & density matrix
           P.destroy
           F.destroy
           P.create(.n_bf,"general")
           F.create(.n_bf,"general")
           F.general = ZERO
           P.general = ZERO
         
           ! Make S, S^{-1} in the MO basis
           S_inv.create(.n_e,.n_e)
           S_inv = ZERO
           .BASE:make_NOMO_S_inv_g(S_inv,MO)

           ! Back transform -> P
           S_inv.back_transform_to(P.general,MO(:,1:.n_e))
           S_inv.destroy
           
           ! Make two electron Fock matrix 
           .FOCK:make_ELMO_01_g_fock(P,F)

           ! Make 2 x energy matrix
           F.plus(.core_matrix)
         
           ! Do energy E(x0+/-step)
           E = HALF * F.general.trace_product_with(P.general)

           ! Add part
           gm(b,m) = gm(b,m) + step*stp2*E

           ! Remove step
           MO(b,m) = MO(b,m) - stps
        end

      end
        
      ! Clean up
      S_inv.destroy
      P.destroy
      F.destroy

   end

   make_NOMO_gradient_g_fd(MO,E,gm)
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - S P F MO S^{-1}, as matrices!!!
      self :: INOUT
      MO :: MAT{REAL}, INOUT
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MO.dim1==2*.n_bf AND MO.dim2==.n_e,"MO wrong shape")
   ENSURE(gm.is_same_shape_as(MO),"gradient gm and MO are not the same shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      S_inv :: MAT{REAL}*
      step, bm,b,m :: INT
      stps,stp2,leng :: REAL

      nullify(P)
      nullify(F)

      leng = 0.001d0
         
      gm = ZERO

      do step = -1,1,2

        stps = step*leng
        stp2 = ONE/(TWO*leng)

        do bm = 1,2*.n_bf*.n_e

           ! ????
           b = mod(bm-1,2*.n_bf) + 1
           m = floor(real(bm-1)/(2*.n_bf)) + 1
           
           ! Add step
           MO(b,m) = MO(b,m) + stps

           ! Fock & density matrix
           P.destroy
           F.destroy
           P.create(.n_bf,"general")
           F.create(.n_bf,"general")
           F.general = ZERO
           P.general = ZERO
         
           ! Make S, S^{-1} in the MO basis
           S_inv.create(.n_e,.n_e)
           S_inv = ZERO
           .BASE:make_NOMO_S_inv_g(S_inv,MO)

           ! Back transform -> P
           S_inv.back_transform_to(P.general,MO(:,1:.n_e))
           S_inv.destroy
           
           ! Make two electron Fock matrix 
           .FOCK:make_g_fock(P,F)
         
           ! Make 2 x energy matrix
           F.plus(.core_matrix)
         
           ! Do energy E(x0+/-step)
           E = HALF * F.general.trace_product_with(P.general)

           ! Add part
           gm(b,m) = gm(b,m) + step*stp2*E

           ! Remove step
           MO(b,m) = MO(b,m) - stps
        end

      end

      ! Clean up
      S_inv.destroy
      P.destroy
      F.destroy

   end


   make_gradient_g(MO,E,gm) ::: template
   ! Make the NOMO GHF energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - S P F MO S^{-1}, as matrices!!!
      self :: INOUT
      MO :: MAT{REAL}, IN
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MO.dim1==2*.n_bf AND MO.dim2==.n_e,"MO wrong shape")
   ENSURE(gm.is_same_shape_as(MO),"gradient gm and MO are not the same shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      SSP,SS,S_inv, FcSm1,cSm1 :: MAT{REAL}*

      ! Create Fock & density matrix
      P.create(.n_bf,"general")
      F.create(.n_bf,"general")
      F.general = ZERO
      P.general = ZERO

      ! Make S, S^{-1} in the MO basis
      S_inv.create(.n_e,.n_e)
      S_inv = ZERO
      .BASE:make_NOMO_S_inv_g(S_inv,MO)

      ! Back transform -> P
      S_inv.back_transform_to(P.general,MO(:,1:.n_e))
      
      ! Make two electron Fock matrix 
      .FOCK:FOCK?(P,F)
      !stdout.text("Fock: ")
      !stdout.put(F)


      ! Make gradient
      FcSm1.create(2*.n_bf,.n_e)
      cSm1.create(2*.n_bf,.n_e)
      cSm1.to_product_of(MO,S_inv)
      FcSm1.to_product_of(F.general,cSm1)
      cSm1.destroy

      ! Make spin-orbital SSP
      SS.create(2*.n_bf, 2*.n_bf)
      SS = ZERO
      SS.alpha_alpha_set_to(.overlap_matrix)
        SS.beta_beta_set_to(.overlap_matrix)

      ! Make SS x P
      SSP.create(2*.n_bf,2*.n_bf)
      SSP.to_scaled_product_of(SS,P.general,fac=ONE)

      ! Assemble 1st and 2nd terms of gradient
      gm = FcSm1
      gm.plus_scaled_product_of(SSP,FcSm1,fac=-ONE)

      gm = TWO*gm

      ! Make 2 x energy matrix
      F.plus(.core_matrix)

      ! Do energy
      E = HALF * F.general.trace_product_with(P.general)

      ! Clean up
      SSP.destroy
      SS.destroy
      FcSm1.destroy
      S_inv.destroy
      P.destroy
      F.destroy

   end

   make_NOMO_gradient_g(MO,E,gm) ::: get_from(make_gradient_g, FOCK?=>make_g_fock)
   ! Make the NOMO GHF energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - S P F MO S^{-1}, as matrices!!!
   end

   make_ELMO_01_gradient_g(MO,E,gm) ::: get_from(make_gradient_g, FOCK?=>make_ELMO_01_g_fock)
   ! Make the NOMO GHF energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - S P F MO S^{-1}, as matrices!!!
   end

   make_ELMO_11_gradient_g(MO,E,gm) ::: get_from(make_gradient_g, FOCK?=>make_ELMO_11_g_fock)
   ! Make the NOMO GHF energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - S P F MO S^{-1}, as matrices!!!
   end


   gradient_g(MO,E,gv) ::: template, selfless
   ! Make the GHF energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
      MO :: VEC{REAL}, IN
      E  :: REAL, OUT
      gv :: VEC{REAL}, OUT

      Cm,gm :: MAT{REAL}*
      self :: MOLECULE*

      ! Restore self
      self => nomo_self

      Cm.create(2*.n_bf,.n_e)
      gm.create(2*.n_bf,.n_e)

      Cm = reshape(MO,[2*.n_bf,.n_e])
      gm = reshape(gv,[2*.n_bf,.n_e])

      .:GRAD?(Cm,E,gm)

      gv = reshape(gm,[size(gm)])

      gm.destroy
      Cm.destroy

   end

   NOMO_gradient_g(MO,E,gv) ::: get_from(gradient_g, GRAD?=>make_NOMO_gradient_g), selfless
   ! Make the GHF energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
   end

   ELMO_01_gradient_g(MO,E,gv) ::: get_from(gradient_g, GRAD?=>make_ELMO_01_gradient_g), selfless
   ! Make the GHF energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
   end

   ELMO_11_gradient_g(MO,E,gv) ::: get_from(gradient_g, GRAD?=>make_ELMO_11_gradient_g), selfless
   ! Make the GHF energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
   end


   NOMO_gradient_u(MO,E,gv) ::: selfless
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
      MO :: VEC{REAL}, IN
      E  :: REAL, OUT
      gv :: VEC{REAL}, OUT

      Cm,gm :: MAT{REAL}*
      self :: MOLECULE*

      ! Restore self
      self => nomo_self

      Cm.create(.n_bf,(.n_a+.n_b))
      gm.create(.n_bf,(.n_a+.n_b))

      Cm = reshape(MO,[.n_bf,(.n_a+.n_b)])
      gm = reshape(gv,[.n_bf,(.n_a+.n_b)])
      
      .:make_NOMO_gradient_u(Cm,E,gm)

      gv = reshape(gm,[.n_bf*(.n_a+.n_b)])

      gm.destroy
      Cm.destroy

   end

   NOMO_gradient_u_a(MOa,E,gv) ::: selfless
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
      MOa :: VEC{REAL}, IN
      E  :: REAL, OUT
      gv :: VEC{REAL}, OUT

      Cm,gm :: MAT{REAL}*
      self :: MOLECULE*

      ! Restore self
      self => nomo_self

      Cm.create(.n_bf,.n_a)
      gm.create(.n_bf,.n_a)

      Cm = reshape(MOa,[.n_bf,.n_a])
      gm = reshape(gv,[.n_bf,.n_a])
      
      .:make_NOMO_gradient_u_a(Cm,E,gm)

      gv = reshape(gm,[.n_bf*.n_a])

      gm.destroy
      Cm.destroy

   end

   NOMO_gradient_u_b(MOb,E,gv) ::: selfless
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gv = F MO S^{-1} - (1/2)S D F MO S^{-1}, as vectors!!!
      MOb :: VEC{REAL}, IN
      E  :: REAL, OUT
      gv :: VEC{REAL}, OUT

      Cm,gm :: MAT{REAL}*
      self :: MOLECULE*

      ! Restore self
      self => nomo_self

      Cm.create(.n_bf,.n_a)
      gm.create(.n_bf,.n_a)

      Cm = reshape(MOb,[.n_bf,.n_b])
      gm = reshape(gv,[.n_bf,.n_b])
      
      .:make_NOMO_gradient_u_b(Cm,E,gm)

      gv = reshape(gm,[.n_bf*.n_a])

      gm.destroy
      Cm.destroy

   end


   make_NOMO_gradient_u(MO,E,gm)
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - (1/2)S D F MO S^{-1}, as matrices!!!
      self :: IN
      MO :: MAT{REAL}, IN
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MO.dim1==.n_bf AND MO.dim2==(.n_a+.n_b),"MO wrong shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      MOa,MOb,S_inv_a,S_inv_b,FcSm1,cSm1 :: MAT{REAL}*

      ! Create Fock & density matrix
      F.create(.n_bf,"unrestricted")
      P.create(.n_bf,"unrestricted")
      MOa.create(.n_bf,.n_a)
      MOb.create(.n_bf,.n_b)
      MOa = MO(:,1:.n_a)
      MOb = MO(:,(.n_a+1):(.n_a+.n_b))

      ! Repeating for the beta case
      S_inv_b.create(.n_b,.n_b)
      .BASE:make_NOMO_S_inv_u_b(S_inv_b,MOb)
      
      ! Back transform -> P
      S_inv_b.back_transform_to(P.beta,MOb)
      
      ! alpha
      ! Make S, S^{-1} in the MO basis
      S_inv_a.create(.n_a,.n_a)
      .BASE:make_NOMO_S_inv_u_a(S_inv_a,MOa)

      ! Back transform -> P
      S_inv_a.back_transform_to(P.alpha,MOa)
      
      ! Make two electron Fock matrix 
      .FOCK:make_u_fock(P,F)

      ! Make gradient
      FcSm1.create(.n_bf,.n_a)
      cSm1.create(.n_bf,.n_a)
      cSm1.to_product_of(MOa,S_inv_a)
      FcSm1.to_product_of(F.alpha,cSm1)
      cSm1.destroy
      cSm1.create(.n_bf,.n_bf)
      cSm1.to_scaled_product_of(.overlap_matrix,P.alpha,fac=ONE)

      ! Assemble 1st and 2nd terms of gradient
      gm(:,1:.n_a) = FcSm1
      gm(:,1:.n_a).plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)
      cSm1.to_scaled_product_of(.overlap_matrix,P.beta,fac=ONE)
      gm(:,1:.n_a).plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)
      cSm1.destroy
      FcSm1.destroy

      ! Make gradient
      FcSm1.create(.n_bf,.n_b)
      cSm1.create(.n_bf,.n_b)
      cSm1.to_product_of(MOb,S_inv_b)
      FcSm1.to_product_of(F.beta,cSm1)
      cSm1.destroy
      cSm1.create(.n_bf,.n_bf)
      cSm1.to_scaled_product_of(.overlap_matrix,P.alpha,fac=HALF)

      ! Assemble 1st and 2nd terms of gradient
      gm(:,.n_a+1:.n_a+.n_b) = FcSm1
      gm(:,.n_a+1:.n_a+.n_b).plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)
      cSm1.to_scaled_product_of(.overlap_matrix,P.beta,fac=HALF)
      gm(:,.n_a+1:.n_a+.n_b).plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)

      ! Make 2 x energy matrix
      F.plus(.core_matrix)

      ! Do energy
      E = HALF * P.alpha.trace_product_with(F.alpha) &
        + HALF * P.beta.trace_product_with(F.alpha) &
        + HALF * P.alpha.trace_product_with(F.beta) &
        + HALF * P.beta.trace_product_with(F.beta)

      ! Clean up
      cSm1.destroy
      FcSm1.destroy
      S_inv_b.destroy
      S_inv_a.destroy
      P.destroy
      F.destroy

   end

   make_NOMO_gradient_u_a(MOa,E,gm)
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - (1/2)S D F MO S^{-1}, as matrices!!!
      self :: IN
      MOa :: MAT{REAL}, IN
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MOa.dim1==.n_bf AND MOa.dim2==.n_a,"MO wrong shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      MOb,S_inv, FcSm1,cSm1 :: MAT{REAL}*

      ! Create Fock & density matrix
      F.create(.n_bf,"unrestricted")
      P.create(.n_bf,"unrestricted")
      MOb => .molecular_orbitals.beta(:,1:.n_b)
      
      ! Repeating for the beta case
      S_inv.create(.n_b,.n_b)
      .BASE:make_NOMO_S_inv_u_b(S_inv,MOb)
      
      ! Back transform -> P
      S_inv.back_transform_to(P.beta,MOb)
      S_inv.destroy
      
      ! alpha
      ! Make S, S^{-1} in the MO basis
      S_inv.create(.n_a,.n_a)
      .BASE:make_NOMO_S_inv_u_a(S_inv,MOa)

      ! Back transform -> P
      S_inv.back_transform_to(P.alpha,MOa)
      
      ! Make two electron Fock matrix 
      .FOCK:make_u_fock(P,F)

      ! Make gradient
      FcSm1.create(.n_bf,.n_a)
      cSm1.create(.n_bf,.n_a)
      cSm1.to_product_of(MOa,S_inv)
      FcSm1.to_product_of(F.alpha,cSm1)
      cSm1.destroy
      cSm1.create(.n_bf,.n_bf)
      cSm1.to_scaled_product_of(.overlap_matrix,P.alpha,fac=HALF)

      ! Assemble 1st and 2nd terms of gradient
      gm = FcSm1
      gm.plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)
      cSm1.to_scaled_product_of(.overlap_matrix,P.beta,fac=HALF)
      gm.plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)

      ! Make 2 x energy matrix
      F.plus(.core_matrix)

      ! Do energy
      E = HALF * P.alpha.trace_product_with(F.alpha) &
        + HALF * P.beta.trace_product_with(F.alpha)

      ! Clean up
      cSm1.destroy
      FcSm1.destroy
      S_inv.destroy
      P.destroy
      F.destroy

   end

   make_NOMO_gradient_u_b(MOb,E,gm)
   ! Make the NOMO energy "E" and gradient "g" of the "MO"s,
   ! gm = F MO S^{-1} - (1/2)S D F MO S^{-1}, as matrices!!!
      self :: IN
      MOb :: MAT{REAL}, IN
      E  :: REAL, OUT
      gm :: MAT{REAL}, OUT

   ENSURE(MOa.dim1==.n_bf AND MOa.dim2==.n_a,"MO wrong shape")
   ENSURE( .overlap_matrix.created,"NO overlap_matrix")

      P,F :: OPMATRIX*
      MOa,S_inv, FcSm1,cSm1 :: MAT{REAL}*

      ! Create Fock & density matrix
      F.create(.n_bf,"unrestricted")
      P.create(.n_bf,"unrestricted")
      MOa => .molecular_orbitals.alpha(:,1:.n_a)

      ! Repeating for the beta case
      S_inv.create(.n_a,.n_a)
      .BASE:make_NOMO_S_inv_u_a(S_inv,MOa)
      
      ! Back transform -> P
      S_inv.back_transform_to(P.alpha,MOa)
      S_inv.destroy

      ! beta
      ! Make S, S^{-1} in the MO basis
      S_inv.create(.n_b,.n_b)
      .BASE:make_NOMO_S_inv_u_b(S_inv,MOb)

      ! Back transform -> P
      S_inv.back_transform_to(P.beta,MOb)

      ! Make two electron Fock matrix 
      .FOCK:make_u_fock(P,F)

      ! Make gradient
      FcSm1.create(.n_bf,.n_b)
      cSm1.create(.n_bf,.n_b)
      cSm1.to_product_of(MOb,S_inv)
      FcSm1.to_product_of(F.beta,cSm1)
      cSm1.destroy
      cSm1.create(.n_bf,.n_bf)
      cSm1.to_scaled_product_of(.overlap_matrix,P.beta,fac=ONE)

      ! Assemble 1st and 2nd terms of gradient
      gm = FcSm1
      gm.plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)
      cSm1.to_scaled_product_of(.overlap_matrix,P.alpha,fac=ONE)
      gm.plus_scaled_product_of(cSm1,FcSm1,fac=-ONE)

      ! Make 2 x energy matrix
      F.plus(.core_matrix)

      ! Do energy
      E = HALF *  P.beta.trace_product_with(F.beta) &
        + HALF * P.alpha.trace_product_with(F.beta)

      ! Clean up
      cSm1.destroy
      FcSm1.destroy
      S_inv.destroy
      P.destroy
      F.destroy

   end


!   MO_exponential_update
!   ! Update the molecular orbitals using an antisymmetric first-order
!   ! update.
!   ENSURE(.scfdata.using_MO_gradient_update,"not allowed")
!   ENSURE(.fock_matrix.associated,"no fock_matrix")
!   ENSURE(.fock_matrix.has_any_genre,"no fock_matrix")
!   ENSURE(.density_matrix.associated,"no density_matrix")
!   ENSURE(.density_matrix.has_any_genre,"no density_matrix")
!   ENSURE(.molecular_orbitals.associated,"no MO's")
!   ENSURE(.molecular_orbitals.has_any_genre,"no MO's")
!
!      orb_kind :: STR
!      g,h,MO,F,P :: MAT{REAL}*
!      f1,f2,scale :: REAL
!      step :: REAL = ONE
!
!      orb_kind = .scfdata.scf_kind
!
!      select case (orb_kind)
!
!        case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")
!
!           g.create(.n_bf,.n_bf)
!           F  => .fock_matrix.restricted
!           MO => .molecular_orbitals.restricted
!           g = F
!           g.change_basis(MO)
!           g(1     :.n_a,1     :.n_a) = ZERO
!           g(.n_a+1:    ,.n_a+1:    ) = ZERO
!           g(1     :.n_a,.n_a+1:    ) = ZERO
!           g.make_antisymmetric
!           .make_MO_r_gradient(g,F,P,MO)
!           f1 = g.trace_product_with(transpose(g))
!           MO = MO - (TOL(2)/sqrt(f1))*g
!           .schmidt_orthonormalise(.molecular_orbitals,scale)
!           scale = ONE/scale
!           .BASE:make_scf_density_matrix
!           .:make_fock_matrix
!           h.create(.n_bf,.n_bf)
!           .make_MO_r_gradient(h,F,P,MO)
!           h = (scale*h-g)/TOL(2)
!           f2 = h.trace_product_with(transpose(h))
!           h.destroy
!           step = f1/f2
!           step = min(.scfdata.max_update_stepsize,step)
!           MO = MO - (step + TOL(2)/sqrt(f1))*g
!           g.destroy
!
!        case default
!           DIE("SCF kind "//trim(orb_kind)//" not implemented")
!
!      end
!      .scfdata.set_diis_error(f1)
!      .BASE:archive(.molecular_orbitals,"molecular_orbitals")
!   end

end
