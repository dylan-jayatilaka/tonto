!==================================================================
!
! MOLECULE.SCF: SCF-related methods.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!==================================================================

module MOLECULE.SCF

   implicit none

contains

!  ===============
!  Hirshfeld atoms
!  ===============

   make_HA_inputs(skip_NOs) ::: leaky
   ! Set up the quanitites for a Hirshfeld calculation:
   ! (1) DFT grid information
   ! (2) ANO's and ANOP interpolators grid information
   ! (3) Assign NO's to MO's
   ! NOTE: this procedure needs to go in .SCF because a molecular SCF
   ! is done for each atom. We could change this by making
   ! atom-specific SCF routines ... that would be nicer.
      self :: INOUT
      skip_NOs :: BIN, optional, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.scfdata.allocated,"no scfdata")

      ! Resolve bases & update
      .BASE:update_atom_basis_group_info

      ! Set up integration grid
      .GRID:set_up_becke_grid ! NOT PURE

      ! ANO's
      .:make_ANO_data

      ! Skip NO's?
      if (present(skip_NOs)) then
      if (skip_NOs) return
      end

      ! Assign NO's to MO's for density evaluation
      if (.MOs.allocated) .BASE:assign_NOs_to_MOs

   end

!  Needed for core-matrix-cluster-of-charges method

   make_r_HA_info(spin,output) ::: leaky
   ! Make the Hirshfeld atom properties
      self :: INOUT
      spin   :: BIN, optional, IN
      output :: BIN, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.INQ:has_Hirshfeld_inputs,"no becke_grid/ANOs! make_HA_inputs?")
   ENSURE(.density_mx.allocated,"no density matrix")

      pt,D :: MAT{REAL}@
      wt,N0,r1,r2,r3 :: VEC{REAL}@
      q,n_e,c1,c2,c3 :: REAL
      dipole :: VEC{REAL}(3)
      quadru :: MAT{REAL}(3,3)
      spn,out :: BIN
      c :: INT

      spn = FALSE
      if (present(spin)) spn = spin

      out = TRUE
      if (present(output)) out = output

      ! If no density in memory get from disk
    ! if (.density_mx.deallocated) then
    !    .:read_or_make_SCF_DM
    ! end

      ! Make the AO density matrix
      D.create(.n_bf,.n_bf)
      if (spn) then; .BASE:make_r_Sz_density_mx(D)
      else;          .BASE:make_r_density_mx(D)
      end

      ! Total no of electrons (check)
      n_e = ZERO

      ! Loop over atoms "c"
      do c = 1,.n_atom

         if (.atom(c).atomic_number<1) cycle

         ! Get Hirshfeld density N0 for atom "c"
         .GRID:make_Hirshfeld_rho_grid(N0,pt,wt,c,D)

         ! Integration points
         r1 = pt(:,1)
         r2 = pt(:,2)
         r3 = pt(:,3)

         ! Atom c position
         c1 = .atom(c).position(1)
         c2 = .atom(c).position(2)
         c3 = .atom(c).position(3)

         ! Make moments
         q   = sum(N0)
         n_e = n_e + q

         dipole(1) = sum(N0*(r1-c1))
         dipole(2) = sum(N0*(r2-c2))
         dipole(3) = sum(N0*(r3-c3))

         quadru(1,1) = sum(N0*(r1-c1)*(r1-c1))
         quadru(2,2) = sum(N0*(r2-c2)*(r2-c2))
         quadru(3,3) = sum(N0*(r3-c3)*(r3-c3))
         quadru(1,2) = sum(N0*(r1-c1)*(r2-c2))
         quadru(1,3) = sum(N0*(r1-c1)*(r3-c3))
         quadru(2,3) = sum(N0*(r2-c2)*(r3-c3))
         quadru(2,1) = quadru(1,2)
         quadru(3,1) = quadru(1,3)
         quadru(3,2) = quadru(2,3)


         ! charges and moments
         q      = -q + .atom(c).atomic_number
         dipole = -dipole
         quadru = -quadru

         ! Assign the charges and moments
         .atom(c).set_charge(q)
         .atom(c).set_dipole(dipole)
         .atom(c).set_quadrupole(quadru)

         ! Clean up
         wt.destroy; pt.destroy
         N0.destroy

      end ! -- integration atom c

      ! Clean up
      D.destroy

      ! Check integration accuracy
      if (out) then
      stdout.flush
      stdout.text("Making Hirshfeld atom info ...")
      stdout.flush
      stdout.show("Check: no. of electrons =",n_e)
      end

      ! Put charges to asymmetric unit
      if (.crystal.allocated) then
         .crystal.destroy_asymmetric_unit
         .crystal.update_fragment_info(.atom)
      end

      .HA_info_made = TRUE

   end

!   read_or_make_SCF_DM ::: leaky, private
!   ! Read of make an SCF density matrix if it is not there
!      self :: INOUT
!
!   ENSURE(.basis_info_made, "no basis info")
!
!      archive :: ARCHIVE
!      genre :: STR
!
!      .density_mx.destroy
!      .density_mx.create(.n_bf)
!
!      ! Get genre
!      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
!      else;                         genre = "r "
!      end
!
!      ! Read density or make it from MO's
!      archive.set_defaults
!      archive.set(.name,"density_mx",genre)
!      if (archive.exists) then
!         archive.read(.density_mx)
!      else
!         .MOs.destroy
!         .MOs.create(.n_bf)
!         archive.set(.name,"MOs",genre)
!         archive.read(.MOs)
!         .BASE:make_SCF_density_mx
!      end
!
!   end

!  ============
!  Form factors
!  ============

   get_unique_IAM_atom_SFs(sf_n) ::: leaky, PURE
   ! Get "sf_n", the IAM structure factors for the symmetry generated
   ! K points with *no* thermal smearing, for every unique atom.
      self :: INOUT
      sf_n :: MAT{CPX}@, OUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
   ENSURE(.crystal.xray_data.use_IAM_density,"not using IAM density!")
   ENSURE(.crystal.asymmetric_unit_atom.allocated,"no asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.allocated,"no unique-frag_atom")
   ENSURE(.crystal.asym_atom_for_frag_atom.allocated,"no asym-frag_atom")

      k_pts :: MAT{REAL}@
      n_atom,n_k, u,f :: INT
      rf :: REAL
      old :: BIN
    ! rc :: VEC{REAL}(3)
    ! k  :: INT
    ! k1,k2,k3,kr :: REAL
    ! sf :: CPX

      ! Asymmetric unit atoms;
      ! Symmetry generated K points and SF's
      n_atom = .crystal.asymmetric_unit_atom.dim
      n_k    = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      sf_n.create(n_k,n_atom)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! Make the SF's
      sf_n = ZERO

      ! Loop over integration atoms "c"
      do u = 1,.crystal.n_unique_frag_atoms

         ! Atoms
         f = .crystal.unique_frag_atom(u)

         ! Structure factors
         old = .atom(f).use_IAM_ITC_FFs
         .atom(f).set_use_IAM_ITC_FFs(TRUE)
         .atom(f).make_FT(sf_n(:,u),k_pts)
         .atom(f).set_use_IAM_ITC_FFs(old)  ! Put back

         ! Repetition (site-symmetry) factor
         rf = .crystal.frag_atom_sym_factor(f)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Scale
         sf_n(:,u) = sf_n(:,u) * rf

       ! ! Add on real part of dispersion - testing only
       ! if (.crystal.xray_data.use_real_dispersion) then
       !    sf = .atom(c).dispersion_correction * rf
       !    rc = .atom(c).position
       !    do k = 1,n_k
       !       k1 = k_pts(k,1)
       !       k2 = k_pts(k,2)
       !       k3 = k_pts(k,3)
       !       kr = k1*rc(1)+k2*rc(2)+k3*rc(3)
       !       sf_n(k,u) = sf_n(k,u) + sf*COMPLEXIFY(cos(kr),sin(kr))
       !    end
       ! end

      end

      ! Clean up
      k_pts.destroy

   end

   get_Tanaka_atom_FFs(ff_n,spin_density) ::: leaky, PURE
   ! Get "ff_n", the Tanaka *static* atomic form factors for the
   ! symmetry related K points for every unique atom.
   ! NOTE: "ff_n" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
      self :: INOUT
      ff_n :: MAT{CPX}@, OUT
      spin_density :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      FT :: MAT3{CPX}@
      k_pts, DM, pf :: MAT{REAL}@
      sh :: SHELL2
      n_atom, n_k,k, q :: INT
      ua,ra,fa,la,na,atom_a :: INT
      ub,   fb,lb,nb,atom_b :: INT
      pa,pk  :: VEC{REAL}(3)
    ! pb     :: VEC{REAL}(3)
      sa     :: REAL
      cutoff :: REAL
      do_it,spin :: BIN
      II, phase  :: CPX

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Form factor array (no temp factor) (leaky)
      ff_n.create(n_k,n_atom)
      ff_n = IMAGIFY(ZERO)
      II   = IMAGIFY(ONE)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! X-ray or PND?
      spin = FALSE
      if (present(spin_density)) spin = spin_density

      ! Density matrix (leaky)
      if (NOT spin) then; .BASE:make_r_density_mx
      else;               .BASE:make_r_Sz_density_mx
      end
      ENSURE(.density_mx.r.allocated, "no restricted DM")

      ! Store density matrix
      DM.create(.n_bf,.n_bf)
      DM = .density_mx.r

      ! Too small threshhold
      cutoff = TOL(10)/.n_shell_pairs

      ! Loop over all shell pairs
      do q = 1,.n_shell_pairs

         ! Get shell pairs
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ! Skip?
         ua = .crystal.unique_frag_atom.index_of_value(atom_a)
         ub = .crystal.unique_frag_atom.index_of_value(atom_b)
         do_it = (ua>0 OR ub>0) AND NOT sh.skip_ft(cutoff)

         ! =============================
         ! Do (non-zero) asym-atom pairs
         ! =============================
         if (do_it) then

            ! Tanaka gaussian-partition factors
            pf.create(sh.a.n_cc,sh.b.n_cc)

            ! Block of FT basis-function integrals
            FT.create(n_k,na,nb)

            if (atom_a==atom_b) then ! SAME ATOMS A==B

               ! Site symmetry factor can't be zero
               pa = .atom(atom_a).position
               ra = .crystal.frag_atom_sym_factor(atom_a)
               sa = ONE/ra

               ! Only one atom -- no need to partition
               pf = ONE
              
               ! The static FT integrals 
               sh.make_FT_parted(FT,k_pts,pf)

               if (fa==fb) then
                  ! Diagonal shell
                  do k = 1,n_k
                     pk = k_pts(k,:)
                     phase = exp(-II*dot_product(pk,pa))
                     ff_n(k,ua) = ff_n(k,ua) +     sum(FT(k,:,:)*DM(fa:la,fb:lb))*phase
                  end
               else
                  ! Off-diagonal shell -- count twice for same atom
                  do k = 1,n_k
                     pk = k_pts(k,:)
                     phase = exp(-II*dot_product(pk,pa))
                     ff_n(k,ua) = ff_n(k,ua) + TWO*sum(FT(k,:,:)*DM(fa:la,fb:lb))*phase
                  end
               end

          ! else ! DIFFERENT ATOMS A /= B

          !    ! Zero site symmetry factors if not asymmetric-unit atom
          !    pa = .atom(atom_a).position
          !    ra = .crystal.frag_atom_sym_factor(atom_a)
          !    if      (ua<1) then; sa = ZERO
          !    else;                sa = ONE/ra
          !    end
          !    pb = .atom(atom_b).position
          !    rb = .crystal.frag_atom_sym_factor(atom_b)
          !    if      (ub<1) then; sb = ZERO
          !    else;                sb = ONE/rb
          !    end

          !    ! Make the ATOM A static FT integrals, lower-diagonal
          !    if (ua>1) then
          !       sh.make_tanaka_partition(pf,sa,sb,center="A")
          !       sh.make_FT_parted(FT,k_pts,pf)
          !       do k = 1,n_k
          !          phase = exp(-II*dot_product(pk,pa))
          !          ff_n(k,ua) = ff_n(k,ua) + sum(FT(k,:,:)*DM(fa:la,fb:lb))*phase
          !       end
          !    end

          !    ! Make the ATOM B static FT integrals, lower-diagonal
          !    ! No need to actually transpose ...
          !    if (ub>1) then
          !       sh.make_tanaka_partition(pf,sa,sb,center="B")
          !       sh.make_FT_parted(FT,k_pts,pf)
          !       do k = 1,n_k
          !          phase = exp(-II*dot_product(pk,pb))
          !          ff_n(k,ub) = ff_n(k,ub) + sum(FT(k,:,:)*DM(fa:la,fb:lb))*phase
          !       end
          !    end
          !   
            end

            ! Clean
            pf.destroy
            FT.destroy

         end

         ! Clean
         sh.destroy_ptr_part

      end

      ! Clean up
      k_pts.destroy
      DM.destroy

   end


   get_Hirshfeld_atom_FFs_v1(ff,spin_density) ::: leaky, PURE
   ! Get "ff", the static Hirshfeld atom form factors for the
   ! symmetry related K points with *no* thermal smearing, for every
   ! unique atom.
   ! NOTE: "ff" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
   ! NOTE: not working yet
      self :: INOUT
      ff   :: MAT{CPX}@, OUT
      spin_density :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      rho, wt,Wc,rc :: VEC{REAL}@
      pt, k_pts, DM :: MAT{REAL}@
      cutoff,ss,sc,s2, k1,k2,k3,kr :: REAL
      n_atom,n_k,n_pt, u,c, i,k    :: INT
      spin :: BIN
      sf :: CPX

      ! Make sure HA stuff is there
   !  .:make_HA_inputs(skip_NOs=TRUE)

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      ff.create(n_k,n_atom)
      ff = ZERO

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! X-ray or PND?
      spin = FALSE
      if (present(spin_density)) spin = spin_density

      ! Density matrix (leaky)
      if (NOT spin) then; .BASE:make_r_density_mx
      else;               .BASE:make_r_Sz_density_mx
      end
      ENSURE(.density_mx.r.allocated, "no restricted DM")

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Symmetrization via site-symmetery operations
      DM.create(.n_bf,.n_bf)
      DM = .density_mx.r

      ! Loop over asymmetric/unique atoms "c"
      parallel do u = 1,.crystal.n_unique_frag_atoms

         c  = .crystal.unique_frag_atom(u)
         rc = .atom(c).position

         ! Site-symmetry factor for this atom
         ss = .crystal.frag_atom_sym_factor(c)
         sc = ss
         if (sc.is_zero) cycle
         s2 = ONE/sc

         ! Get the Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,c)
         n_pt = pt.dim1

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         Wc.create(n_pt)
         if (.use_interpolators) then
            .GRID:make_stockholder_atom_grid(Wc,c,pt,.overlapping_atoms_for_atom(c)[:])
         else
            .GRID:make_stockholder_atom_grid(Wc,c,pt)
         end

         ! Integration weight
         wt = Wc*wt
         Wc.destroy

         ! Prune the grid with new "wt"
         .becke_grid.prune_grid(pt,wt)

         ! Density for atom "c"
         n_pt = pt.dim1   ! <-- New n_pt !!!
         rho.create(n_pt)
         rho = ZERO
         .GRID:add_ED_grid_v1(rho,pt,DM,cutoff)

         ! Weight the atom "c" density
         rho = rho*wt

         ! Make the (unique) atomic form factors
         ! Fourier transform, yay!
         do k = 1,n_k
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            sf = IMAGIFY(ZERO)
            do i = 1,n_pt
               kr = k1*pt(i,1)+k2*pt(i,2)+k3*pt(i,3)
               sf = sf + rho(i)*exp(IMAGIFY(kr))
            end
            ff(k,u) = sf * s2 * .atom(c).site_occupancy ! <-----
         end

         ! Clean up atom "c" stuff
         rho.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(ff)
      end

      ! Clean up
      k_pts.destroy
      DM.destroy

   end

   get_Hirshfeld_atom_FFs(ff,spin_density) ::: leaky, PURE
   ! Get "ff", the static Hirshfeld atom form factors for the
   ! symmetry related K points with *no* thermal smearing, for every
   ! unique atom.
   ! NOTE: "ff" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
      self :: INOUT
      ff   :: MAT{CPX}@, OUT
      spin_density :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      overlapping_atom :: VEC{INT}@
      rc, ra  :: VEC{REAL}(3)
      wt, Wc  :: VEC{REAL}@
      xa,ya,za,a2 :: VEC{REAL}@
      rho, ga,gb  :: VEC{REAL}@
      pi,pj,pn    :: VEC{INT}@
      skipa0,skipab :: VEC{BIN}@
      skipa,skipb   :: VEC{BIN}@
      pt, k_pts, DM :: MAT{REAL}@
      sha :: SHELL1
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      sf :: CPX
      cutoff,ss,sc,s2, k1,k2,k3,kr, Dab, fac, val :: REAL
      n_atom,n_k,n_pt,n_keep :: INT
    ! max_n_pt,max_n_ss :: INT
      u,c,ca,cb :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb, as :: INT
      sa,fa,la,na    :: INT
      sb,fb,lb,nb    :: INT
      a,b,i,j,k,n,p  :: INT
      seitz :: MAT3{REAL}@
      spin :: BIN

      ! Make sure HA stuff is there
   !  .:make_HA_inputs(skip_NOs=TRUE)

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Seitz matrices for symmetrisation
      seitz = .crystal.xyz_seitz_matrices 

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      ff.create(n_k,n_atom)
      ff = ZERO

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! X-ray or PND?
      spin = FALSE
      if (present(spin_density)) spin = spin_density

      ! Density matrix (leaky)
      if (NOT spin) then; .BASE:make_r_density_mx
      else;               .BASE:make_r_Sz_density_mx
      end
      ENSURE(.density_mx.r.allocated, "no restricted DM")

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Symmetrization via site-symmetery operations
      DM.create(.n_bf,.n_bf)
      DM = .density_mx.r
    ! .BASE:symmetrize_DM_like_mx(DM)

      ! Atom "a" displaced numerical integration grid points 
      ! and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop over asymmetric/unique atoms "c"
      parallel do u = 1,.crystal.n_unique_frag_atoms

         c  = .crystal.unique_frag_atom(u)
         rc = .atom(c).position

         ! Site-symmetry factor for this atom
         ss = .crystal.frag_atom_sym_factor(c)
         sc = ss
         if (sc.is_zero) cycle
         s2 = ONE/sc
       ! s2 = s2*s2


         ! Overlapping atoms for density evaluation
         overlapping_atom = .overlapping_atoms_for_atom(c).element

         ! Get the Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,c)
       ! .becke_grid.make_grid(pt0,wt0,bf_save,c)
         n_pt = pt.dim1

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         Wc.create(n_pt)
         if (.use_interpolators) then
            .GRID:make_stockholder_atom_grid(Wc,c,pt,overlapping_atom)
         else
            .GRID:make_stockholder_atom_grid(Wc,c,pt)
         end

         ! Incorporate integration weight
         wt = Wc*wt
         Wc.destroy

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt (leaky)
         .becke_grid.prune_grid(pt,wt)
       ! .becke_grid.prune_grid(pt,wt,bf_save)

         ! *New* points
         n_pt = pt.dim1
         !!!!!!!!!!!!!!

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .basis_shell1pair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if basis fn is always too small on
               ! the grid points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element = skipa

               ! Make/copy the "sa" basis function grid
               ! This must be copied since skipa could be TRUE
               ! LOTS OF MEMORY USED HERE!
               bf_grid(sa).element.create(n_keep,na)
               sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.deallocated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor for lower triangle-only loop
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga = bf_grid(sa)[:,1]
                        gb = bf_grid(sb)[:,1]
                        Dab = fac*DM(fa,fb)
                      ! Dab = fac*.density_mx.r(fa,fb)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                        ga.destroy
                        gb.destroy

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0
                        i = 0
                        j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga = bf_grid(sa)[:,a]
                           do b = 1,nb
                              gb = bf_grid(sb)[:,b]
                              Dab = fac*DM(fa+a-1,fb+b-1)
                            ! Dab = fac*.density_mx.r(fa+a-1,fb+b-1)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val ! Hooray !
                              end
                           end
                        end

                        ! Clean up
                        ga.destroy
                        gb.destroy
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                     skipb.destroy

                  end
               end
            end
         end

         ! Weight the atom "c" density
         ! Now only the FT e^(ik.r) part missing
         rho = rho*wt


       ! ! Maximum no. of site symmetry operators
       ! max_n_ss = maxval(.crystal.frag_atom_sym_factor)
       ! max_n_pt = n_pt*max_n_ss

       ! ! Make symmetrised pruned becke grid
       ! if (sc==1) then
       !    pt = pt0
       !    wt = wt0
       ! else
       !    ! Generate site-symmetry equivalent grid points
       !    ! No. of pt's and wt's now are multiplied by no. of site symops
       !    .crystal.make_symmetry_equivalents_from(pt0,wt0,c,pt,wt)
       ! end

         ! Make the (unique) atomic form factors
         ! Fourier transform, yay!
         do k = 1,n_k
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            sf = IMAGIFY(ZERO)
            do i = 1,n_pt
               kr = k1*pt(i,1)+k2*pt(i,2)+k3*pt(i,3)
               sf = sf + rho(i)*exp(IMAGIFY(kr))
            end
            ff(k,u) = sf * s2 * .atom(c).site_occupancy ! <-----
         end

         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(ff)
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      k_pts.destroy
      DM.destroy

   end
   
   delete_Hirshfeld_atom_FFs
   ! Delete all the asymmetric unit form factor (FF) files
   ! before they are (re)generated.
      self :: IN

      arch :: ARCHIVE
      a :: INT

      do a = 1,.crystal.n_asymmetric_unit_atoms
         arch.set(trim(.crystal.asymmetric_unit_atom(a).label)//"-SFs")
         arch.delete
      end 

   end


   get_C23_Hirshfeld_atom_FFs(ff) ::: leaky
   ! Get "ff_n", the static Hirshfeld atom form factors (from a
   ! periodic CRYSTAL23 calculation) for the symmetry related K points
   ! with *no* thermal smearing, for every unique atom.
   ! NOTE: "ff" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
      self :: INOUT
      ff :: MAT{CPX}@, OUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      rc, rho, wt,Wc :: VEC{REAL}@
      pt, k_pts :: MAT{REAL}@
      h_pts :: MAT{INT}@
      ss,sc,s2, k1,k2,k3,kr  :: REAL
      n_atom, n_k, n_pt :: INT
      u,c,a,i,k :: INT
      HS_atoms  :: VEC{ATOM}@
      sf :: CPX
      library_basis_labels :: VEC{STR}@
      library  :: STR

   !  .:make_HA_inputs(skip_NOs=TRUE)

      ! Asymmetric unit atoms,
      ! Symmetry-generated K points and/or SF's
      n_atom = .crystal.asymmetric_unit_atom.dim
      n_k    = .crystal.n_unique_SF_k_pts

      ! Form factor array (leaky)
      ff.create(n_k,n_atom)
      ff = ZERO

      ! Make the Thakkar slaterbases
      .slaterbasis.destroy
      .slaterbasis_name = "Thakkar" ! ugly
      .atom.set_basis_kind("slater")
      library = .slaterbasis.library_file(.slaterbasis_name)
      library_basis_labels = .atom.library_basis_labels(.slaterbasis_name)
      .slaterbasis.read_library_data(library,library_basis_labels)
      library_basis_labels.destroy
      .slaterbasis.unnormalize

      ! Ensure .atom's have their .slaterbases
      .GRID:make_slater_interpolators
      .SET:resolve_slaterbases(.crystal.asymmetric_unit_atom)
      .crystal.asymmetric_unit_atom.set_basis_kind("slater")
     
      ! Destroy the fragment geometry & set it to asymmetri unit
    ! .crystal.asymmetric_unit_geometry.destroy
    ! .crystal.asymmetric_unit_atom.destroy
    ! .crystal.update_fragment_info(.crystal.asymmetric_unit_atom)

      ! Make the HS_atoms & resolve the interpolators
    ! .crystal.asymmetric_unit_atom.set_basis_kind("slater")
      .crystal.make_asym_unit_HS_cluster(HS_atoms,TOL(10)) ! <===
      HS_atoms.set_basis_kind("slater")
      HS_atoms.resolve_bases(.slaterbasis,.slaterbasis_name)
      HS_atoms.update_kinds    
      !!!!!!!!!!!!!!
      HS_atoms.put ! ?? what does this line do? -- Kang
      !!!!!!!!!!!!!!

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      h_pts.create(n_k,3)
      .crystal.make_unique_X_SF_Miller_indices(h_pts)

      ! Set up integration grid
      ! Max no of becke grid points per atom
      .becke_grid.create
      .becke_grid.set_atom_info(.crystal.asymmetric_unit_atom) ! NOT PURE
      ! In a coflicted version the above argument was .atom ?
      .becke_grid.set_grid_data
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Loop over asymmetric/unique atoms "c"
      parallel do u = 1,.crystal.n_unique_frag_atoms

         c  = .crystal.unique_frag_atom(u)
         rc = .crystal.asymmetric_unit_atom(c).position

         ! Site-symmetry factor for this atom
         ! ???? REALLY ??? What about if it rotates ???
         ss = .crystal.asym_atom_sym_factor(c)
         sc = ss
         if (sc.is_zero) cycle
         s2 = ONE/sc

         ! Get the Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,c)
         n_pt = pt.dim1
!! Following lines are disabled - Kang ..>
       !  stdout.text("atom c = ",) !         
       !  stdout.put(rc)
       !  stdout.text("Becke grid pt:") !         
       !  stdout.put(pt) 
       !  stdout.text("Becke grid wt:") !         
       !  stdout.put(wt)
!! <..
         ! Make stockholder weight function "Wc" for atom "c"
         Wc.create(n_pt)
         HS_atoms.make_Hirshfeld_weight_grid(Wc,pt,c)

         ! Incorporate integration weight
         wt = Wc*wt
         Wc.destroy

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt (leaky)
         .becke_grid.prune_grid(pt,wt)

         ! *New* points
         n_pt = pt.dim1
         !!!!!!!!!!!!!!
    
         ! Density for atom "c"
         ! Call the C23 density routine
         rho.create(n_pt)
         .GRID:make_CRYSTAL23_ED_grid_v1(rho,pt)

         ! Weight the atom "c" density
         ! Now only the FT e^(ik.r) part missing
         rho = rho*wt

         ! Make the (unique) atomic form factors
         ! Fourier transform, yay!
         do k = 1,n_k
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            sf = IMAGIFY(ZERO)
            do i = 1,n_pt
               kr = k1*pt(i,1)+k2*pt(i,2)+k3*pt(i,3)
               sf = sf + rho(i)*exp(IMAGIFY(kr))
            end
            ff(k,u) = sf * s2 * .atom(c).site_occupancy ! <-----
         end

         ! Clean up atom "c" stuff
         rho.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(ff)
      end

      ! Clean up
      k_pts.destroy
      HS_atoms.destroy

      stdout.text("===")
      stdout.text("ff:")
      stdout.put(ff)

      stdout.text("===")
      stdout.text("h:")
      stdout.put(h_pts)

   end

   make_asym_unit_HS_cluster(HS_atoms,tol) ::: leaky
   ! Make "HS_atoms", a cluster of atoms surrounding the asymmetric
   ! unit in the crystal. The cluster has the property that for every
   ! atom in the cluster, the Thakkar-type spherical electron density
   ! is accurate to "tol" when evaluated at the atomic position of
   ! every atom in the asymmetric unit.
   ! NOTE: the .crystal.asymmetric_unit is destroyed and remade so
   ! that it ervy atom in it has a .slaterbasis with an interoplator.
      self     :: INOUT
      HS_atoms :: VEC{ATOM}@, OUT
      tol      :: REAL, IN

      library_basis_labels :: VEC{STR}@
      library  :: STR

      ! Remake the slaterbasis
      .slaterbasis.destroy
      .slaterbasis_name = "Thakkar" ! ugly
      .atom.set_basis_kind("slater")
      library = .slaterbasis.library_file(.slaterbasis_name)
      library_basis_labels = .atom.library_basis_labels(.slaterbasis_name)
      .slaterbasis.read_library_data(library,library_basis_labels)
      library_basis_labels.destroy
      .slaterbasis.unnormalize

      ! Make sure every .atom has a .slaterbasis
      .GRID:make_slater_interpolators
      .SET:resolve_slaterbases(.crystal.asymmetric_unit_atom)
      .crystal.asymmetric_unit_atom.set_basis_kind("slater")

      ! Make the HS_atoms & resolve the interpolators
      .crystal.make_asym_unit_HS_cluster(HS_atoms,tol) ! <===
      HS_atoms.resolve_bases(.slaterbasis,.slaterbasis_name)
      HS_atoms.set_basis_kind("slater")
      HS_atoms.update_kinds    

   end


   get_unique_fragHAR_SFs(spin_density) ::: leaky
   ! Write out the fragHAR static structure factors for each
   ! .atom_group.mol molecule.
      self :: INOUT
      spin_density :: BIN, optional, IN

   ENSURE(.atom_group.allocated,"no .atom_group")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")
   ENSURE(.cif.allocated,"no cif specified")

      g, n_group :: INT

      ! Make ANO's & interpolators for parent
      ! WARNING: dies if no ANOs or interpolators
      .:make_ANO_data

      ! Make sutructure factors for each residue
      do g = 1,.atom_group.dim

         ! NOTE: change DFT -> becke
         .mol(g).SET:initialize_DFT_grids

         ! Assign previously made ANOs
         .mol(g).SET:resolve_ANOs_from(self)

         ! Write the SFs for each fragment to disk
         n_group = .atom_group(g).atom_index.dim
         .mol(g).SCF:get_Hirshfeld_atom_FFs(n_group,spin_density)

      end

   end

   get_Hirshfeld_atom_FFs(n_last,spin_density) ::: leaky
   ! Write out the static Hirshfeld atom form factors for the symmetry
   ! related K points with *no* thermal smearing, for every unique
   ! atom. If "n_last" is present only do unique atoms up to this
   ! atom, which is useful to eliminate capping atoms in a fragment.
   ! If "spin_densityy" is present the spinb density SFs are made.
   ! NOTE: The integrals "sf_u" written  are the FT rho_a(r), eqn (3)
   ! in Jayatilaka 2008, Acta Cryst A 64 p. 383-393. It is also f_a(q)
   ! in eqn (11) except without the thermal smearing factor.
      self :: INOUT
      n_last :: INT, optional, IN
      spin_density :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      sf_u  :: VEC{CPX}@
    ! sf_t  :: VEC{CPX}@
      rc,ra :: VEC{REAL}(3)
      ga,gb :: VEC{REAL}@
      Wc,wt, xa,ya,za,a2, rho :: VEC{REAL}@
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab,skipa,skipb :: VEC{BIN}@
      k_pts,pt,bf_save :: MAT{REAL}@
      sha :: SHELL1
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      sf  :: CPX
      cutoff,sc,s2, k1,k2,k3,kr, Dab, fac, val :: REAL
      n_atom,n_k,n_pt,n_keep :: INT
      u,c,ca,cb :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb :: INT
      sa,fa,la,na, as :: INT
      sb,fb,lb,nb :: INT
      a,b,i,j,k,n,p :: INT
      n_unique :: INT
      spin :: BIN
      arch :: ARCHIVE*

      n_unique = .crystal.n_unique_frag_atoms
      if (present(n_last)) n_unique = n_last

      ! Make sure HA stuff is there
      .:make_HA_inputs(skip_NOs=TRUE)

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      ! For pne atom
      sf_u.create(n_k)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! X-ray or PND?
      spin = FALSE
      if (present(spin_density)) spin = spin_density

      ! Density matrix (leaky)
      if (NOT spin) then; .BASE:make_r_density_mx
      else;               .BASE:make_r_Sz_density_mx
      end
      ENSURE(.density_mx.r.allocated, "no restricted DM")

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop over integration atoms "c"
      parallel do u = 1,n_unique

         sf_u = ZERO

         c  = .crystal.unique_frag_atom(u)
         rc = .atom(c).position

         ! Skip cap atoms
         if (.atom(c).is_cap_atom) cycle

         ! Repetition factor for this atom
         ! Also include the site occupancy factor
         ! (Dont forget this for the non-fragHAR routine)
         sc = .crystal.frag_atom_sym_factor(c)
         if (sc.is_zero) cycle
         s2 = .crystal.fragment_atom(c).site_occupancy/sc
       ! s2 = s2*s2

         ! Overlapping atoms
         overlapping_atom = .overlapping_atoms_for_atom(c).element

         ! Get the Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         Wc.create(n_pt)
         if (.use_interpolators) then
            .GRID:make_stockholder_atom_grid(Wc,c,pt,overlapping_atom)
         else
            .GRID:make_stockholder_atom_grid(Wc,c,pt)
         end

         ! Incorporate integration weight
         wt = Wc*wt

         Wc.destroy

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt (leaky)
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .basis_shell1pair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element = skipa

               ! Make/copy the "sa" basis function grid
               ! This must be copied since skipa could be TRUE
               bf_grid(sa).element.create(n_keep,na)
               if (oa/=c) then
                  ! Calculate grid if necessary
                  sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
               else
                  ! Extract grid values from saved grid values
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        bf_grid(sa)[i,a] = bf_save(n,a+fa-fba)
                     end
                  end
               end

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.deallocated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga = bf_grid(sa)[:,1]
                        gb = bf_grid(sb)[:,1]
                        Dab = fac*.density_mx.r(fa,fb)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga = bf_grid(sa)[:,a]
                           do b = 1,nb
                              gb = bf_grid(sb)[:,b]
                              Dab = fac*.density_mx.r(fa+a-1,fb+b-1)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                  end
               end
            end
         end

         ! Weight the atom "c" density
         rho = rho*wt

         ! Get aspherical form factor sf_u
         do k = 1,n_k
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            sf = IMAGIFY(ZERO)
            do i = 1,n_pt
               kr = k1*pt(i,1)+k2*pt(i,2)+k3*pt(i,3)
               sf = sf + rho(i)*exp(IMAGIFY(kr))
            end
            sf_u(k) = sf * s2
         end

         ! Write out sf_u
       ! a = .crystal.asym_atom_for_frag_atom(c)
       ! arch.create(trim(.atom(a).label)//"-SFs")
         arch.create(trim(.atom(c).tag)//"-SFs")
         if (.crystal.xray_data.use_text_SFs) arch.set_format("ascii")
       ! if (arch.exists) then
       !    ! Read file and add contribtion
       !    sf_t = sf_u
       !    arch.read(sf_t)
       !    sf_u = sf_t + sf_u
       ! end
         arch.parallel_write(sf_u)
         arch.destroy

         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Clean up
      sf_u.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      k_pts.destroy

   end

   get_Hirshfeld_atom_FFs_for_atom(u,sf_n,spin_density) ::: leaky
   ! Get "sf_n", the static Hirshfeld atom form factors for the
   ! symmetry related K points with *no* thermal smearing, for every
   ! unique atom.
   ! NOTE: "sf_n" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
      self :: INOUT
      u    :: INT, IN
      sf_n :: VEC{CPX}@, OUT
      spin_density :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      rc,ra :: VEC{REAL}(3)
      ga,gb :: VEC{REAL}@
      Wc,wt, xa,ya,za,a2, rho :: VEC{REAL}@
      overlapping_atom, pi,pj,pn :: VEC{INT}@
      skipa0,skipab,skipa,skipb :: VEC{BIN}@
      k_pts,pt,bf_save :: MAT{REAL}@
      sha :: SHELL1
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      sf :: CPX
      cutoff,sc,s2, k1,k2,k3,kr, Dab, fac, val :: REAL
      n_k,n_pt,n_keep :: INT
      c,ca,cb :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb :: INT
      sa,fa,la,na, as :: INT
      sb,fb,lb,nb :: INT
      a,b,i,j,k,n,p :: INT
      spin :: BIN

      ! Make sure HA stuff is there
    ! .:make_HA_inputs(skip_NOs=TRUE)

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      sf_n.create(n_k)
      sf_n = ZERO

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! X-ray or PND?
      spin = FALSE
      if (present(spin_density)) spin = spin_density

      ! Density matrix (leaky)
      if (NOT spin) then; .BASE:make_r_density_mx
      else;               .BASE:make_r_Sz_density_mx
      end
      ENSURE(.density_mx.r.allocated, "no restricted DM")

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop over integration atoms "c"
         c  = .crystal.unique_frag_atom(u)
         rc = .atom(c).position

         ! Repetition factor for this atom
         sc = .crystal.frag_atom_sym_factor(c)
       ! if (sc.is_zero) cycle
         s2 = ONE/sc
       ! s2 = s2*s2

         ! Overlapping atoms
         overlapping_atom = .overlapping_atoms_for_atom(c).element

         ! Get the Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         Wc.create(n_pt)
         if (.use_interpolators) then
            .GRID:make_stockholder_atom_grid(Wc,c,pt,overlapping_atom)
         else
            .GRID:make_stockholder_atom_grid(Wc,c,pt)
         end

         ! Incorporate integration weight
         wt = Wc*wt
         Wc.destroy

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt (leaky)
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .basis_shell1pair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element = skipa

               ! Make/copy the "sa" basis function grid
               ! This must be copied since skipa could be TRUE
               bf_grid(sa).element.create(n_keep,na)
               if (oa/=c) then
                  ! Calculate grid if necessary
                  sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
               else
                  ! Extract grid values from saved grid values
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        bf_grid(sa)[i,a] = bf_save(n,a+fa-fba)
                     end
                  end
               end

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.deallocated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga = bf_grid(sa)[:,1]
                        gb = bf_grid(sb)[:,1]
                        Dab = fac*.density_mx.r(fa,fb)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga = bf_grid(sa)[:,a]
                           do b = 1,nb
                              gb = bf_grid(sb)[:,b]
                              Dab = fac*.density_mx.r(fa+a-1,fb+b-1)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                  end
               end
            end
         end

         ! Weight the atom "c" density
         rho = rho*wt

         ! Make the (unique) structure factors
         do k = 1,n_k
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            sf = IMAGIFY(ZERO)
            do i = 1,n_pt
               kr = k1*pt(i,1)+k2*pt(i,2)+k3*pt(i,3)
               sf = sf + rho(i)*exp(IMAGIFY(kr))
            end
            sf_n(k) = sf * s2 * .atom(c).site_occupancy
         end

         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      k_pts.destroy

   end


!  =================
!  Structure factors
!  =================

!  X-ray

   make_X_SFs(output)
   ! Make the X-ray structure factors for this molecule.
      self :: INOUT
      output :: BIN, optional, IN

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")

      out :: BIN

      ! Output
      out = FALSE
      if (present(output)) out = output

      if (out) then

      stdout.flush
      stdout.text("============================")
      stdout.text("Make X-ray structure factors")
      stdout.text("============================")

      stdout.flush
      stdout.show("Number of reflections     = ",.crystal.xray_data.reflections.dim)
      stdout.show("Density partition model   = ",trim(.crystal.xray_data.partition_model))
      stdout.show("Thermal smearing model    = ",trim(.crystal.temperature_factor_model))
      stdout.show("Use disk SF data?         = ",.crystal.xray_data.use_disk_SFs)
      stdout.flush

      end

      ! Make the SF's
      select case (.crystal.xray_data.partition_model)

      ! Two-center models
      case ("none        ", &
            "tc-mulliken ", &
            "tc-tanaka   ") ; .:make_X_SFs_RF

      ! One-center models
      case ("oc-crystal23") ; .:make_X_SFs_C23
      case ("oc-hirshfeld") ; .:make_X_SFs_HAR
      case ("oc-tanaka   ") ; .:make_X_SFs_TAR

      end

   end

!   make_X_free_SFs
!   ! Make the *free* X-ray structure factors for this molecule.
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_r_free_data.allocated, "no x-ray R-free reflection data")
!
!      ! Assign data
!      .crystal.assign_xray_r_free
!
!
!      ! Make the SF's
!      select case (.crystal.temperature_factor_model)
!
!      case ("none        ", &
!            "tc-mulliken ", &
!            "tc-tanaka   ") ; .:make_X_SFs_RF
!
!      case ("oc-hirshfeld") ; .:make_X_SFs_HAR
!
!      case ("oc-tanaka   ") ; .:make_X_SFs_TAR
!
!      end
!
!   end

!  X-ray helpers

   make_X_SFs_RF ::: private
   ! Make basis-fn pair structure factors for this molecule.
   ! NOTE: includes the temperature factor/ADPs
      self :: INOUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.scfdata.allocated, "no scfdata")

      sf_eq,Fc :: VEC{CPX}@
      k_pts :: MAT{REAL}@
      genre :: STR
      n_k,n_refl :: INT

      n_k    = .crystal.n_unique_SF_k_pts
      n_refl = .crystal.xray_data.reflections.dim

      ! Allocate complex structure factors
      Fc.create(n_refl)

      ! Make k points
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)

      ! Make density matrix
      .BASE:make_r_density_mx

      ! Symmetry-generated SF'd
      sf_eq.create(n_k)

      ! Make symmetry-generated SF's
      genre = .scfdata.spinorbital_genre

      if (genre.includes("complex")) then

         if (.scfdata.spinorbital_genre=="gc") then
            .XTAL:make_FT_gc(sf_eq,.density_mx.gc,k_pts)
         end

      else

         .XTAL:make_ft(sf_eq,.density_mx.r,k_pts)

         if (.scfdata.allocated) then
         if (.scfdata.spinorbital_genre=="u ") then
            .density_mx.destroy("r ")
         end
         end

      end

      ! Make the predicted SF's
      .crystal.make_F_predicted_from(sf_eq)

   end

   make_X_SFs_HAR ::: private
   ! Make the structure factors for this molecule.
   ! WARNING: this does not seem to include the temperature factor
      self :: INOUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")

      if (.crystal.xray_data.use_disk_SFs) then; .:make_X_SFs_HAR_disk
      else;                                      .:make_X_SFs_HAR_memory
      end

   end

   make_X_SFs_HAR_disk ::: private
   ! Make the structure factors for this molecule.
   ! WARNING: this does not seem to include the temperature factor
      self :: INOUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")

      ! Get atomic form factors
      .:get_Hirshfeld_atom_FFs

      ! Make F_pred & chi2
      .crystal.make_F_predicted

   end

   make_X_SFs_HAR_memory ::: private
   ! Make the structure factors for this molecule.
   ! WARNING: this does not seem to include the temperature factor
      self :: INOUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")

      sf_n :: MAT{CPX}@

      ! Get atomic form factors
      .:get_Hirshfeld_atom_FFs(sf_n)

      ! Make F_pred & chi2
      .crystal.make_F_predicted(sf_n)

      sf_n.destroy

   end

   make_X_SFs_TAR ::: private
   ! Make basis-fn pair structure factors for this molecule.
   ! NOTE: includes the temperature factor/ADPs
      self :: INOUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.scfdata.allocated, "no scfdata")

      sf_n :: MAT{CPX}@

      ! Get atomic form factors
      .:get_Tanaka_atom_FFs(sf_n)

      ! Make F_pred & chi2
      .crystal.make_F_predicted(sf_n)

      sf_n.destroy

   end

   make_X_SFs_C23 ::: private
   ! Make the CRYSTAL23 structure factors from, the XML file.
      self :: INOUT

      ff :: MAT{CPX}@

      ! Get atomic form factors
      .:get_C23_Hirshfeld_atom_FFs(ff)

      ! Make F_pred & chi2
      .crystal.make_F_predicted(ff)

      ff.destroy

   end

!  For fragHAR

   make_F_predicted
   ! Make F predicted from SFs files.
      self :: INOUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")

      ! Make the SF's
      .crystal.make_F_predicted ! NOT PURE

   end


!  PND

!   make_N_SFs
!   ! Make the PND structure factors for this molecule.
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_data.allocated, "no reflection data")
!   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
!
!      if (.crystal.temperature_factor_model=="hirshfeld") then
!         .:make_N_SFs_h
!      else
!         .:make_N_SFs_p
!      end
!
!   end

!   make_N_free_SFs
!   ! Make the free PND structure factors for this molecule.
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_data.allocated, "no reflection data")
!   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
!
!      ! Assign free SF's
!      if (.crystal.temperature_factor_model=="hirshfeld") then
!         .:make_N_SFs_h
!      else
!         .:make_N_SFs_p
!      end
!
!   end

!  PND helpers

!   make_N_SFs_h ::: private
!   ! Make the free PND structure factors for this molecule.
!   ! WARNING: this does not seem to include the temperature factor
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_data.allocated, "no reflection data")
!
!      if (.crystal.xray_data.use_disk_SFs) then; .:make_N_SFs_h_disk
!      else;                                 .:make_N_SFs_h_memory
!      end
!
!   end

!   make_N_SFs_h_memory ::: private
!   ! Make the structure factors for this molecule.
!   ! WARNING: this does not seem to include the temperature factor
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_data.allocated, "no reflection data")
!   ENSURE(.density_mx.allocated, "no density matrix")
!   ENSURE(.scfdata.allocated, "no scfdata")
!
!      sf_n :: MAT{CPX}@
!
!      ! Get atomic spin form factors
!      .:get_Hirshfeld_atom_FFs(sf_n,spin_density=TRUE)
!
!      ! Make F_pred & chi2
!      .crystal.make_F_predicted(sf_n)
!
!      sf_n.destroy
!
!   end

!   make_N_SFs_h_disk ::: private
!   ! Make the structure factors for this molecule.
!   ! WARNING: this does not seem to include the temperature factor
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_data.allocated, "no reflection data")
!   ENSURE(.density_mx.allocated, "no density matrix")
!   ENSURE(.scfdata.allocated, "no scfdata")
!
!      ! Get atomic spin form factors
!      .:get_Hirshfeld_atom_FFs(spin_density=TRUE)
!
!      ! Make F_pred & chi2
!      .crystal.make_F_predicted
!
!   end

!   make_N_SFs_p ::: private
!   ! Make the S_z structure factors for this molecule.
!      self :: INOUT
!
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.xray_data.allocated, "no reflection data")
!   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
!
!      sf_eq,Fc :: VEC{CPX}@
!      k_pts :: MAT{REAL}@
!      genre :: STR
!      complx :: BIN
!      n_k,n_refl :: INT
!
!      n_k    = .crystal.n_unique_SF_k_pts
!      n_refl = .crystal.xray_data.reflections.dim
!
!      ! Allocate complex structure factors
!      Fc.create(n_refl)
!
!      ! Make unique k points
!      k_pts.create(n_k,3)
!      .crystal.make_unique_X_SF_k_pts(k_pts)
!
!      ! Make S_z density matrix
!      .BASE:make_r_Sz_density_mx
!
!      ! Make the symmetry-generated SF's
!      sf_eq.create(n_k)
!      genre = .density_mx.genre
!      complx = genre.includes("complex")
!      if (complx) then
!         .XTAL:make_ft(sf_eq,.density_mx.r_complex,k_pts)
!      else
!         .XTAL:make_ft(sf_eq,.density_mx.r,k_pts)
!      end
!
!      ! Destroy the S_z density matrix
!      .density_mx.destroy("r ")
!
!      ! Make the predicted SF's
!      .crystal.make_F_predicted_from(sf_eq)
!
!   end

!  ===============================
!  Energy density matrix of Krogel
!  ===============================

   make_E_SCF_density_mx(method) ::: leaky
   ! Make the density matrix from the molecular orbitals.
   ! . If "damp" is present use it to damp the updated density matrix.
   !   An .old_density_mx must exist for this to work.
   ! . If "n_a" is present it is used as the number of alpha electrons
   !   in embedded scf calculations.
   ! . If "method" is present it is used as the kind of density matrix
   !   to make, otherwise taken from .scfdata.SCF_kind, or guessed
   !   from the spinorbital_genre of the MO's.
   ! NOTE:
   ! . If .scfdata.do_delta_build is set and a a .delta_density_mx
   !   is created, then a delta density is made.
   ! . If .scfdata.apply_pFON a finite temperature density matrix is
   !   made with temperature .scfdata.temperature_for_pFON (untested)
      self :: INOUT
      method :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")
   ENSURE(.fock_mx.allocated, "no fock matrix")
   ENSURE(.fock_mx.has_any_genre, "no fock matrix")
   ENSURE(.core_mx.allocated, "no core matrix")

      MO,MOa,MOb :: MAT{REAL}@
      scf_method,genre :: STR

      ! Ensure we have this
    ! if (.core_mx.deallocated) then
    !    .:make_core_mx
    ! end

      ! Determine (or guess) the kind of SCF method to be used.
      if      (present(method))    then; scf_method = method
      else if (.scfdata.allocated) then; scf_method = .scfdata.SCF_kind
      else;                              scf_method = .MOs.guess_SCF_kind
      end

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Make the Krogel matrix
      .E_density_mx = .fock_mx
      .E_density_mx.plus(.core_mx)
      .E_density_mx.scale_by(HALF)

      ! Make the E natural orbitals
      .BASE:make_E_NOs

      ! Make the E density matrix
      ! Not complete
      select case (scf_method)

      case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
         ENSURE(.E_NOs.is_allocated_with_genre("r "),"no energy NO's")
         ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.atom.chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))
         MO = .E_NOs.r(:,1:.n_a)
         .E_density_mx.r.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

      case ("rohf")
         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
         MOa = .MOs.r(:,1:.n_a)
         MOb = .MOs.r(:,1:.n_b)
         .density_mx.a.to_product_of(MOa,MOa,transpose_b=TRUE)
          .density_mx.b.to_product_of(MOb,MOb,transpose_b=TRUE)

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         ENSURE(.MOs.is_allocated_with_genre("u "),"no MO's")
         MOa = .MOs.a(:,1:.n_a)
         MOb = .MOs.b(:,1:.n_b)
         .density_mx.a.to_product_of(MOa,MOa,transpose_b=TRUE)
          .density_mx.b.to_product_of(MOb,MOb,transpose_b=TRUE)

    ! case default
    !    DIE("unknown SCF kind, "//trim(scf_method))

      end

   end

!  ===========
!  Core matrix
!  ===========

!  These could go in the ATOM module if the atomic_SCF and 
!  ANOs could be factored out.

   make_core_mx(genre) ::: leaky
   ! Get the core hamiltonian matrix.
   ! If possible the kind is made from the kind of scfdata.
   ! If its already in memory, do nothing; otherwise make it.
      self :: INOUT
      genre :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      genus :: STR

      ! Create core_mx if not there
      if (NOT .core_mx.allocated) then
         .core_mx.create(.n_bf) 
      end

      ! Make sure restricted part is there at least
      if (NOT .core_mx.has_genre("r ")) then
         .:make_r_core_mx
      end

      genus = .scfdata.spinorbital_genre
      if (present(genre)) genus = genre

      if (.core_mx.has_genre(genus)) then
         return
      end

      ! Make or convert it
      select case (genus)

      case ("gc")
         .:make_gc_core_mx

      case ("r ")
         ! Already there

      case default
         .core_mx.convert_to(genus,destroy_original=FALSE)

      end

   end

   make_r_core_mx ::: leaky
   ! Make the *restricted* core hamiltonian matrix appropriate for the
   ! current scf calculation. If already in memory, do nothing.
   ! If it isn't, burn everything and start again from scratch.
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.scfdata.allocated,  "no scfdata")

      Z :: MAT{REAL}@

      ! Is it already there?
      if (.core_mx.allocated) then
      if (.core_mx.has_genre("r ")) then
         return
      end
      end

      ! Allocate core matrix
      .core_mx.destroy
      .core_mx.create(.n_bf)
      .core_mx.create("r ")

      ! Make the core matrix here (relativistic vs non-rel)
      select case (.scfdata.relativity_kind)
    ! case ("douglas-kroll-hess","dkh");     .REL:make_r_DKH1_core_mx(.core_mx.r)
    ! case ("douglas-kroll-hess-2","dkh-2"); .REL:make_r_DKH2_core_mx(.core_mx.r)
    ! case ("iotc");                         .REL:make_r_IOTC_core_mx(.core_mx.r)
      case default;                          .:make_r_NREL_core_mx(.core_mx.r)
      end

      ! No cluster charges for SCF guess
      if (.scfdata.is_guess)  return

      if (.scfdata.using_cluster_charges) then
         ! Add cluster charges if needed
         ! NOTE: includes the self-consistent case
         if (NOT .HA_info_made) then
            ENSURE(.crystal.allocated,"no crystal")
            .:make_HA_inputs
            .:make_r_HA_info(output=FALSE)
         end
         Z.create(.n_bf,.n_bf)
         .:make_cluster_charge_mx(Z) ! leaky
         .core_mx.r = .core_mx.r + Z
         Z.destroy
      else if (.scfdata.using_SC_Lorentz_fields) then
         ! Add Lorentz fields if needed
         if (NOT .HA_info_made) then
            ENSURE(.crystal.allocated,"no crystal")
            .:make_HA_inputs ! NOT PURE
            .:make_r_HA_info(output=FALSE)
         end
         Z.create(.n_bf,.n_bf)
         .:make_Lorentz_core(Z)
         .core_mx.r = .core_mx.r + Z
         Z.destroy
      end

   end

   make_r_NREL_core_mx(H) ::: leaky, PURE
   ! Make the non-relativistic core hamiltonian (T+NA) matrix "H".
      self :: INOUT
      H :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      Dx,Dy,Dz :: MAT{REAL}@

      ! Get kinetic matrix (leaky)
      .INTS:make_kinetic_energy_mx
      .kinetic_energy_mx.uncompress

      ! Get nuclear matrix (leaky)
      .INTS:make_nuclear_attraction_mx
      .nuclear_attraction_mx.uncompress

      ! Make core matrix
      H = .kinetic_energy_mx.r  &
        + .nuclear_attraction_mx.r
      
      if (NOT .E_field.is_zero) then
         ! Finite-electric-field contribution
         Dx.create(.n_bf,.n_bf)
         Dy.create(.n_bf,.n_bf)
         Dz.create(.n_bf,.n_bf)
         .INTS:make_dipole_matrices(Dx,Dy,Dz)
         H = H &
           + Dx*.E_field(1) &
           + Dy*.E_field(2) &
           + Dz*.E_field(3)
         Dz.destroy
         Dy.destroy
         Dx.destroy
      end

      ! Compress (leaky)
      .kinetic_energy_mx.compress
      .nuclear_attraction_mx.compress

   end

   make_gc_core_mx ::: leaky, PURE
   ! Make the general complex core hamiltonian matrix.
   ! If already in memory, do nothing.
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(.core_mx.allocated,"no core matrix")
   ENSURE(.core_mx.has_genre("r "),"no restricted core matrix")

      ! Return if core matrix already there
      if (.core_mx.has_genre("gc")) return

      ! Allocate core matrix
      .core_mx.create("gc")
      .core_mx.gc = (ZERO,ZERO)

      ! Add the lower half in ... depending on the method
      ! NOTE: there may be some failures here ...
      select case (.scfdata.relativity_kind)
    ! case ("douglas-kroll-hess"); .:add_gc_DKH_core_mx
    ! case ("dkh");                .:add_gc_DKH_core_mx
    ! case ("zora");               .:add_gc_ZORA_core_mx
    ! case ("iotc");               .:set_gc_IOTC_core_mx
      case ("pauli");              .:add_gc_Pauli_core_mx
      case ("none");               .:add_gc_core_mx
      end

      ! Make it Hermitian
      .core_mx.gc.make_hermitian

   end

!   add_gc_DKH_core_mx
!   ! Add the DKH core hamiltonian
!   ! NOTE: only lower half is made
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.core_mx.is_allocated_with_genre("gc"),"no core matrix")
!
!      T,Lx,Ly,Lz :: MAT{REAL}@
!      fac :: REAL
!      I :: CPX
!
!      I = (ZERO,ONE)
!
!      T.create(.n_bf,.n_bf)
!      Lx.create(.n_bf,.n_bf)
!      Ly.create(.n_bf,.n_bf)
!      Lz.create(.n_bf,.n_bf)
!
!      .REL:make_DKH_matrices(T,Lx,Ly,Lz)
!
!      .core_mx.gc.aa_block_plus(T)
!      .core_mx.gc.bb_block_plus(T)
!
!      fac= ONE
!      .core_mx.gc.ba_block_plus(Lx,fac*I)
!      .core_mx.gc.ba_block_plus(Ly,-fac)
!      .core_mx.gc.aa_block_plus(Lz,fac*I)
!      .core_mx.gc.bb_block_plus(Lz,-fac*I)
!
!      T.destroy
!      Lz.destroy
!      Ly.destroy
!      Lx.destroy
!
!   end

!   add_gc_ZORA_core_mx
!   ! Add the core hamiltonain to a general complex "F"
!   ! NOTE: only lower half is made
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.scfdata.using_1e_zora_term," no Pauli?")
!   ENSURE(.core_mx.is_allocated_with_genre("gc"),"no core matrix")
!
!      T,Lx,Ly,Lz :: MAT{REAL}@
!      fac :: REAL
!      I :: CPX
!
!      I = (ZERO,ONE)
!
!      T.create(.n_bf,.n_bf)
!      Lx.create(.n_bf,.n_bf)
!      Ly.create(.n_bf,.n_bf)
!      Lz.create(.n_bf,.n_bf)
!      .INTS:make_1e_ZORA_matrices(T,Lx,Ly,Lz)
!
!      .core_mx.gc.aa_block_plus(T)
!      .core_mx.gc.bb_block_plus(T)
!
!      fac = G_FACTOR/TWO
!      fac = fac * .scfdata.sl_1e_factor
!      .core_mx.gc.ba_block_plus(Lx,-fac*I)
!      .core_mx.gc.ba_block_plus(Ly,fac)
!      .core_mx.gc.aa_block_plus(Lz,-fac*I)
!      .core_mx.gc.bb_block_plus(Lz,fac*I)
!      
!      T.destroy
!      Lz.destroy
!      Ly.destroy
!      Lx.destroy
!
!   end

!   set_gc_IOTC_core_mx
!   ! Add the core hamiltonain to a general complex "F"
!   ! NOTE: only lower half is made
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.core_mx.is_allocated_with_genre("gc"),"no core matrix")
!
!      .REL:make_gc_IOTC_core_mx(.core_mx.gc)
!
!   end

   add_gc_Pauli_core_mx ::: PURE
   ! Add the Pauli core hamiltonian ... including B-field terms
   ! NOTE: only lower half is made
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.overlap_mx.allocated,"no overlap matrix")
   ENSURE(.core_mx.allocated,"no core matrix")
   ENSURE(.core_mx.has_genre("r "),     "no R core matrix")
   ENSURE(.core_mx.has_genre("gc"),"no GC core matrix")

      T, Lx,Ly,Lz :: MAT{REAL}@
      xx,yy,zz,xy,xz,yz :: MAT{REAL}@
      BB  :: MAT{REAL}(3,3)
      k,l :: INT
      fac :: REAL
      I   :: CPX

      I = (ZERO,ONE)

      .core_mx.gc.aa_block_plus(.core_mx.r)
      .core_mx.gc.bb_block_plus(.core_mx.r)

      ! The Pauli terms below are not normally active
      ! if Douglas-Kroll has been used ...
      if (.scfdata.using_1e_sl_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .INTS:make_spin_orbit_matrices(Lx,Ly,Lz)
            fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
            fac = fac * .scfdata.sl_1e_factor
            .core_mx.gc.ba_block_plus(Lx,-fac*I)
            .core_mx.gc.ba_block_plus(Ly,fac)
            .core_mx.gc.aa_block_plus(Lz,-fac*I)
            .core_mx.gc.bb_block_plus(Lz,fac*I)
            Lz.destroy
            Ly.destroy
            Lx.destroy
      end

      if (NOT .B_field.is_zero) then

         if (.scfdata.using_bs_term) then
            fac = G_FACTOR/FOUR
            .core_mx.gc.aa_block_plus(.overlap_mx, fac*.B_field(3))
            .core_mx.gc.bb_block_plus(.overlap_mx,-fac*.B_field(3))
            .core_mx.gc.ba_block_plus(.overlap_mx, fac*.B_field(1))
            .core_mx.gc.ba_block_plus(.overlap_mx, fac*.B_field(2)*I)
         end

         if (.scfdata.using_bs_t_term) then
            T.create(.n_bf,.n_bf)
            .INTS:make_kinetic_energy_mx(T)
            fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
            .core_mx.gc.aa_block_plus(T, fac*.B_field(3))
            .core_mx.gc.bb_block_plus(T,-fac*.B_field(3))
            .core_mx.gc.ba_block_plus(T, fac*.B_field(1))
            .core_mx.gc.ba_block_plus(T, fac*.B_field(2)*I)
            T.destroy
         end

         if (.scfdata.using_bl_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .INTS:make_L_matrices(Lx,Ly,Lz)
            Lx = Lx*.B_field(1) &
               + Ly*.B_field(2) &
               + Lz*.B_field(3)
            fac = HALF
            .core_mx.gc.aa_block_plus(Lx,fac*I)
            .core_mx.gc.bb_block_plus(Lx,fac*I)
            Lz.destroy
            Ly.destroy
            Lx.destroy
         end

         if (.scfdata.using_aa_term) then
           xx.create(.n_bf,.n_bf)
           yy.create(.n_bf,.n_bf)
           zz.create(.n_bf,.n_bf)
           xy.create(.n_bf,.n_bf)
           xz.create(.n_bf,.n_bf)
           yz.create(.n_bf,.n_bf)
           .INTS:make_quadrupole_matrices(xx,yy,zz,xy,xz,yz)
           fac = ONE/EIGHT
           do k = 1,3
              BB(k,k) = .B_field.dot(.B_field) - .B_field(k)*.B_field(k)
           end
           do k =   1,3
           do l = k+1,3
              BB(k,l) = -TWO*.B_field(k)*.B_field(l)
           end
           end
           BB = fac*BB
           xx =      BB(1,1)*xx
           xx = xx + BB(2,2)*yy
           xx = xx + BB(3,3)*zz
           xx = xx + BB(1,2)*xy
           xx = xx + BB(1,3)*xz
           xx = xx + BB(2,3)*yz
           .core_mx.gc.aa_block_plus(xx)
           .core_mx.gc.bb_block_plus(xx)
           yz.destroy
           xz.destroy
           xy.destroy
           zz.destroy
           yy.destroy
           xx.destroy
         end

         if (.scfdata.using_1e_srxa_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .INTS:make_spin_orbit_B_matrices(Lx,Ly,Lz)
            fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
            .core_mx.gc.ba_block_plus(Lx, fac)
            .core_mx.gc.ba_block_plus(Ly, fac*I)
            .core_mx.gc.aa_block_plus(Lz, fac)
            .core_mx.gc.bb_block_plus(Lz,-fac)
            Lz.destroy
            Ly.destroy
            Lx.destroy
         end

      end

   end

   add_gc_core_mx ::: private, PURE
   ! Add the Pauli core hamiltonian ... including B-field terms
   ! NOTE: only lower half is made
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.core_mx.allocated,"no core matrix")
   ENSURE(.core_mx.has_genre("r "),"no R core matrix")
   ENSURE(.core_mx.has_genre("gc"),"no GC core matrix")

      ! Define the gc parts
      .core_mx.gc.aa_block_plus(.core_mx.r)
      .core_mx.gc.bb_block_plus(.core_mx.r)

   end


   put_cluster_charges ::: leaky
   ! Make the point charge matrix "Z" from the point charges in .atom
   ! and the positions derived from ".scfdata.cluster".
   ! WARNING: the crystal asym unit charges must be defined.
      self :: INOUT

      name :: STR

      ! Make it
      .:make_cluster_charges

      ! Write
      name = trim(.name) // ".gaussian-point-charges"
      .scfdata.put_cluster_charges(name)

   end

   make_cluster_charges ::: leaky
   ! Make the point charge matrix "Z" from the point charges in .atom
   ! and the positions derived from ".scfdata.cluster".
   ! WARNING: the crystal asym unit charges must be defined.
      self :: INOUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.HA_info_made, "no Hirshfeld atom info")

      pos :: MAT{REAL}@
      charge :: VEC{REAL}@
      n_charges :: INT

      ! Make Hirshfeld charges
      .:make_r_HA_info

      ! Set up the cluster ... leaky
      .scfdata.cluster.destroy
      .scfdata.cluster.create
      .scfdata.cluster.set_defaults(.crystal)

      ! Make the cluster
      .scfdata.cluster.set_generation_method("within_radius")
      if (.scfdata.defragment) then
         .scfdata.cluster.set_defragment(TRUE)
      else
         .scfdata.cluster.set_defragment(FALSE)
      end
      .scfdata.cluster.set_radius(.scfdata.cluster_radius)
      .scfdata.cluster.update_info ! NOT PURE

      ! Make the cluster charges
      n_charges = .scfdata.cluster.n_atoms &
                - .scfdata.cluster.n_fragment_atoms

      if (NOT .scfdata.using_qq_cluster_charges) then
         n_charges = 3*n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         .scfdata.cluster.make_non_fragment_mu_charges(pos,charge)
      else
         n_charges = 9*n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         .scfdata.cluster.make_non_fragment_qq_charges(pos,charge)
      end

      ! Save the information
      .scfdata.cluster_charges          = charge
      .scfdata.cluster_charge_positions = pos

   end

   make_cluster_charge_mx(Z) ::: leaky
   ! Make the point charge matrix "Z" from the point charges in .atom
   ! and the positions derived from ".scfdata.cluster".
   ! WARNING: the crystal asym unit charges must be defined.
      self :: INOUT
      Z :: MAT{REAL}, OUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.HA_info_made, "no Hirshfeld atom info")

      charge  :: VEC{REAL}@
      Z_c,pos :: MAT{REAL}@
      n_charges,q,c,fa,la,na,fb,lb,nb :: INT
      q_c :: REAL
      sh :: SHELL2

      ! Set up the cluster ... leaky
      .scfdata.cluster.destroy
      .scfdata.cluster.create
      .scfdata.cluster.set_defaults(.crystal)

      ! Make the cluster
      .scfdata.cluster.set_generation_method("within_radius")
      if (.scfdata.defragment) then
         .scfdata.cluster.set_defragment(TRUE)
      else
         .scfdata.cluster.set_defragment(FALSE)
      end
      .scfdata.cluster.set_radius(.scfdata.cluster_radius)
      .scfdata.cluster.update_info ! leaky

      ! Make the cluster charges
      n_charges = .scfdata.cluster.n_atoms &
                - .scfdata.cluster.n_fragment_atoms

      if (NOT .scfdata.using_qq_cluster_charges) then
         n_charges = 3*n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         .scfdata.cluster.make_non_fragment_mu_charges(pos,charge)
      else
         n_charges = 9*n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         .scfdata.cluster.make_non_fragment_qq_charges(pos,charge)
      end

      ! Make the charge contribution to one electron Hamiltonian
      Z = ZERO

      parallel do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb)

         Z_c.create(na,nb)
         do c = 1,charge.dim
            q_c = charge(c)
            if (q_c.equals(ZERO)) cycle
            sh.get_nuc(Z_c,ZERO,pos(:,c))
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - q_c*Z_c
         end

         Z_c.destroy
         sh.destroy_ptr_part

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(Z)
      else
         Z.symmetric_reflect
      end

      if (.scfdata.save_cluster_charges) then
         .scfdata.cluster_charges          = charge
         .scfdata.cluster_charge_positions = pos
      else
         pos.destroy
         charge.destroy
      end

   end

   make_Lorentz_core(Z)
   ! Add the local electric fields "F" to the core matrix, made from
   ! the Lorentz factor tensors
      self :: INOUT
      Z :: MAT{REAL}, OUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.HA_info_made,"no Hirshfeld charges and dipoles")

      rF, pF,ww :: VEC{REAL}@
      ra, ga,gb :: VEC{REAL}@
      wt, xa,ya,za,a2  :: VEC{REAL}@
      near_atom, pi,pj :: VEC{INT}@
      skipa0,skipa :: VEC{BIN}@
      skipab,skipb :: VEC{BIN}@
      F,pt,bf_save :: MAT{REAL}@
      ZZ :: MAT{REAL}@
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      cutoff, fac,val :: REAL
      n_pt,n_keep    :: INT
      c,ca,cb        :: INT
      oa,fsa,lsa,fba :: INT
      ob,fsb,lsb, as :: INT
      sa,fa,la,na    :: INT
      sb,fb,lb,nb    :: INT
      a,b,i,j,n,p    :: INT
      sha :: SHELL1

      ! Make the local Lorentz fields at every atom
      F.create(3,.n_atom)
      .:make_Lorentz_fields(F)

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Initialise
      Z = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.n_atom

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         near_atom = .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         .GRID:apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt -- leaky
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! r.F for each grid point
         rF.create(n_pt)
         rF = pt(:,1)*F(1,c) + pt(:,2)*F(2,c) + pt(:,3)*F(3,c)

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Loop c-overlapping atoms "oa"
         do ca = 1,near_atom.dim

            oa  = near_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "oa"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .basis_shell1pair(as,1).a
               sha.position = ra

               ! Make shell "sa" skipa list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element = skipa

               ! Make/copy the "sa" basis function grid
               ! This must be copied since skipa could be TRUE
               bf_grid(sa).element.create(n_keep,na)
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        bf_grid(sa)[i,a] = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
               end

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = near_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     if (bf_skip(sb).element.deallocated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Density block
                     ZZ = Z(fa:la,fb:lb)

                     if (na*nb==1) then

                        ! Add density contribution to rho
                        ga = bf_grid(sa)[:,1]
                        gb = bf_grid(sb)[:,1]
                        i = 0; j = 0
                        val = ZERO
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           fac = ga(i)*gb(j)*wt(n)
                           val = val + fac * rF(n)
                        end
                        ZZ(1,1) = ZZ(1,1) + val

                     else

                        ! Create space for gathered index info
                        pi.create(n_keep); pj.create(n_keep); ww.create(n_keep)
                        pF.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           ww(p) = wt(n)
                           pF(p) = rF(n)
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga = bf_grid(sa)[:,a]
                           do b = 1,nb
                              gb = bf_grid(sb)[:,b]
                              val = ZERO
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 fac = ga(i)*gb(j)*ww(p)
                                 val = val + fac * pF(p)
                              end
                              ZZ(a,b) = ZZ(a,b) + val
                           end
                        end

                        ! Clean up
                        pF.destroy
                        ww.destroy
                        pj.destroy
                        pi.destroy

                     end

                  end ! -- loops sa,sb
               end
            end       ! -- lops ca,cb
         end

         ! Clean up
         bf_save.destroy
         bf_grid.destroy
         bf_skip.destroy
         rF.destroy
         wt.destroy
         pt.destroy

      end ! -- integration atom c

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      F.destroy

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(Z)
      else
         Z.symmetric_reflect
      end

   end

   make_Lorentz_fields(F)
   ! Make the local Lorentz electric fields "F" at each atom site due
   ! to the crystal environment calculated from the charges and
   ! dipoles on each atom (so the Hirshfeld or other charges and
   ! dipoles need to be made). Only monopole and dipole contributions
   ! are made.
      self :: IN
      F :: MAT{REAL}, OUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.HA_info_made,"no Hirshfeld charges and dipoles")
   ENSURE(F.dim1==3,"wromg dim1, F")
   ENSURE(F.dim2==.n_atom,"wromg dim1, F")

      cluster :: CLUSTER@
      xyz :: MAT{REAL}@

      ! Set up the cluster ... leaky
      cluster.create
      cluster.set_defaults(.crystal)
      xyz = .atom.coordinates
      cluster.set_fragment_geometry(xyz,cartesian=TRUE)
      xyz.destroy
      cluster.set_generation_method("within_radius")
      cluster.set_defragment(FALSE)
      cluster.set_radius(ZERO)
      cluster.update_info ! NOT PURE - annoying !

      ! Make the local Lorentz fields at every atom
      cluster.make_Lorentz_fields(F)
      cluster.destroy

   end

   make_Lorentz_interactions(I0,I1)
   ! Make the local Lorentz interactions terms with charges and
   ! dipoles due to dipoles ONLY on the atoms in the crystal
   ! environment (so the Hirshfeld or other charges and dipoles need
   ! to be made).  A minus sign is neede when combined.
      self :: IN
      I0 :: VEC{REAL}, OUT
      I1 :: MAT{REAL}, OUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.HA_info_made,"no Hirshfeld charges and dipoles")
   ENSURE(I1.dim1==3,"wrong dim1, I2")
   ENSURE(I1.dim2==.n_atom,"wrong dim2, I2")
   ENSURE(I0.dim ==.n_atom,"wrong dim, I0")

      cluster :: CLUSTER@
      xyz :: MAT{REAL}@

      ! Set up the cluster ... leaky
      cluster.create
      cluster.set_defaults(.crystal)
      xyz = .atom.coordinates
      cluster.set_fragment_geometry(xyz,cartesian=TRUE)
      xyz.destroy
      cluster.set_generation_method("within_radius")
      cluster.set_defragment(FALSE)
      cluster.set_radius(ZERO)
      cluster.update_info ! NOT PURE - crazy!

      ! Make the local Lorentz interactions with charges
      ! and dipoles at every atom
      cluster.make_Lorentz_interactions(I0,I1)
      cluster.destroy

   end

!  ====================
!  Fock matrix routines
!  ====================

   make_Fock_mx(core,r12) ::: leaky
   ! If r12  is present and FALSE, the r12 part is not computed.
      self :: INOUT
      core,r12 :: BIN, optional, IN

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.has_genre(.scfdata.spinorbital_genre),"incompatible density")

      dF :: OPMATRIX@
      delta_build,add_core :: BIN

      ! Use a delta fock matrix build?
      delta_build = .scfdata.do_delta_build &
                AND .delta_density_mx.allocated &
                AND .fock_2e_mx.allocated

      if (NOT delta_build) then
         ! Make the 2e fock matrix from density
         .fock_2e_mx.destroy
         .fock_2e_mx.create(.n_bf)
         .FOCK:make_Fock_mx(.fock_2e_mx,.density_mx,core=FALSE,r12=r12,xc=FALSE)
      else
        ! Make the 2e fock matrix from delta density
        .fock_2e_mx.uncompress
        dF.create(.n_bf)
        .FOCK:make_Fock_mx(dF,.delta_density_mx,core=FALSE,r12=r12,xc=FALSE)
        .fock_2e_mx.plus(dF) ! Add Delta F
        dF.destroy
      end

      ! Set fock matrix & save space
      .fock_mx.destroy
      .fock_mx = .fock_2e_mx
      .fock_2e_mx.compress

      ! Now do the XC part if needed
      if (.scfdata.is_DFT_calculation) then
         .FOCK:add_XC_mx(.fock_mx)
      end

      ! Force update of 1e hamiltonian if required
      if (.scfdata.using_SC_cluster_charges OR .scfdata.using_SC_Lorentz_fields) then
         .core_mx.destroy
         .HA_info_made = FALSE
      end

      ! Add one electron part?
      add_core = TRUE
      if (present(core)) add_core = core

      ! Add core. Make sure it is there.
      if (add_core) then
         .:make_core_mx(.scfdata.spinorbital_genre) ! NOT PURE
         .:make_core_mx(.scfdata.MOs_genre)
         .fock_mx.plus(.core_mx)
      end

   end

!  ===
!  SCF
!  ===

   SCF ::: leaky
   ! Do an SCF calculation. The following :
   !   .MOs, .MO_energies, .density_mx
   ! are produced as results.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata provided")

      select case (.scfdata.SCF_kind)

      case ("group")
         .:atom_group_SCF

      case ("fragment-rhf","fragment-rks")
         ! What is the diffeence to the above SCF?!!!
         .:fragment_SCF

      case ("xray_rhf","xray_rks","xray_uhf","xray_uks","xray_gchf", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         .:constrained_SCF

      case default
         .:usual_SCF

      end

   end

   promolecule_SCF
   ! Do an initial promolecule SCF.
      self :: INOUT

      use_cc,use_sc :: BIN

      ! Save guess
      use_cc = .scfdata.using_cluster_charges
      use_sc = .scfdata.using_SC_cluster_charges

      ! Do promolecule restart; set .scfdata.output=YES to see ...
      .scfdata.set_initial_density("promolecule")
      .scfdata.set_using_cluster_charges(FALSE)

      !!!!!!!!
      .SCF:SCF
      !!!!!!!!

      ! Set guess back
      .scfdata.set_initial_density(.scfdata.spinorbital_genre)
      .scfdata.set_using_cluster_charges(use_cc)
      .scfdata.set_using_SC_cluster_charges(use_sc)

   end

!  =========
!  Usual SCF
!  =========

   usual_SCF ::: leaky
   ! Do an SCF calculation. The .MOs,
   ! .MO_energies, and .density_mx are produced as results.
      self :: INOUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,   "no atom list")
   ENSURE(.scfdata.allocated,"no scfdata")

      .:initialize_SCF
      .:put_SCF_banner_and_options
      .:put_SCF_table_header

      do

         .:extrapolate_Fock_mx
         .:update_MOs
         .BASE:make_SCF_density_mx
         .:make_Fock_mx
         .:update_scfdata
         .:update_scfdata_error
         .:put_SCF_table_body

         if (.scfdata.scf_done) exit

      end

      .:put_SCF_results
      .:archive_SCF_results
      .:cleanup_scf

   end

   atomic_SCF ::: leaky
   ! Do an atomic SCF calculation; this is for initial guesses.
   ! The molecule comprises a single atom. The .MOs,
   ! .MO_energies, and .density_mx are produced as results.
      self :: INOUT

   ENSURE(.atom.allocated,   "no atom list")
   ENSURE(.atom.dim==1 ,   "atom list length > 1")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.scfdata.allocated,"no scfdata")

      .:initialize_atomic_SCF
      .:put_SCF_banner_and_options
      .:put_SCF_table_header

      do

         .:extrapolate_Fock_mx
         .:update_MOs
         .BASE:make_SCF_density_mx
         .:make_Fock_mx
         .:update_scfdata
         .:update_scfdata_error
         .:put_SCF_table_body

         if (.scfdata.scf_done) exit

      end

      .:put_SCF_results
      .:archive_SCF_results
      .:cleanup_scf

   end
   
   initialize_SCF ::: leaky
   ! Initialize any molecular SCF procedure
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      ! Overlap matrix
      .INTS:make_overlap_mx

      ! Integration grids
      if (.scfdata.is_DFT_calculation) .SET:initialize_DFT_grids

      ! Get initial guess
      .:get_initial_guess

      ! Core matrix: both kinds
      .core_mx.destroy
      .:make_core_mx(.scfdata.spinorbital_genre)
      .:make_core_mx(.scfdata.MOs_genre)
         
      ! Get Fock matrix
      .:make_Fock_mx

      ! Make structure factors?
      if (.scfdata.fitting) then
         .crystal.xray_data.SET:set_XCW(TRUE) ! add one to n_param
         .:make_constraint_data
      end

      ! Reset all SCF data (except DFT parts)
      .scfdata.reset
    ! .scfdata.set_crystal(.crystal)
      if (.scfdata.fitting) .scfdata.set_penalty(.crystal)
      .:update_scfdata_energies

      ! Add constraint to F?
      if (.scfdata.fitting) .:add_constraint_to_Fock_mx

      if (.scfdata.using_DIIS) then
         ! Initialise DIIS error
         .:update_scfdata_error
      end if

      ! Initialise Schwarz inequality integrals (leaky)
      .FOCK:initialize_max_I

      ! Initialise SCF table (leaky)
      .scfdata.set_table

   end

   initialize_atomic_SCF ::: leaky
   ! Initialize an atomic SCF procedure
   ! The guess must be core. There is not fitting.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(NOT .scfdata.fitting,"fitting not allowed")

      ! Overlap matrix
      .INTS:make_overlap_mx

      ! Integration grids
      if (.scfdata.is_DFT_calculation) .SET:initialize_DFT_grids

      ! Get core guess -- different
      .scfdata.set_is_guess(TRUE)
      .:make_core_mx_guess_MOs

      ! Core matrix: both kinds
      .core_mx.destroy
      .:make_core_mx(.scfdata.spinorbital_genre)
      .:make_core_mx(.scfdata.MOs_genre)

      ! Get Fock matrix
      .:make_Fock_mx

      ! Reset all SCF data (except DFT parts)
      .scfdata.reset
      .:update_scfdata_energies

      ! Initialise DIIS error
      .:update_scfdata_error

      ! Initialise Schwarz inequality integrals (leaky)
      .FOCK:initialize_max_I

      ! Initialise SCF table (leaky)
      .scfdata.set_table

   end

   update_scfdata_energies ::: private
   ! Update SCF energies
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      e :: REAL

      ! Energies
      .scfdata.nuclear_repulsion_energy  = .INQ:nuclear_repulsion_energy
      .scfdata.nuclear_attraction_energy = .:nuclear_attraction_energy
      if (.scfdata.using_cluster_charges) &
      .scfdata.charge_attraction_energy  = .:charge_attraction_energy
      .scfdata.kinetic_energy            = .:kinetic_energy

      ! Total SCF energy [including V(nuc) repulsion] and penalty
      e = .:SCF_energy

      ! Update energy & penalty
      .scfdata.update_energy(e,.crystal)

      ! Set electron repulsion energy by subtraction
      .scfdata.electron_repulsion_energy = .scfdata.energy &
                                         - .scfdata.nuclear_repulsion_energy &
                                         - .scfdata.nuclear_attraction_energy &
                                         - .scfdata.charge_attraction_energy &
                                         - .scfdata.kinetic_energy

   end

   update_scfdata
   ! Update the scf iteration count, scf energies used to
   ! test for convergence in the SCF procedure.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      ! New iteration
      .scfdata.update_iteration

      ! Update energies and penalty
      .:update_scfdata_energies

   end

   update_scfdata_error
   ! Update the scfdata gradient of the SCF energy with respect to
   ! orbital rotations, otherwise known as the "DIIS error". This is
   ! used to check for SCF convergence.
      self :: INOUT

      DIIS_error :: REAL

      .:make_DIIS_error_length(DIIS_error)

   end

   put_SCF_banner_and_options
   ! Put out the SCF banner and options
      self :: INOUT

   ENSURE(.scfdata.allocated,            "no scfdata")
   ENSURE(.scfdata.iteration==0,       "iteration is not 0!")
   ENSURE(.scfdata.lambda_iteration==0,"lambda_iteration is not 0!")

      ! SCF banner and options
      .scfdata.put_banner
      .scfdata.put_options(.crystal)

      ! Diffraction data-treatment options
      if (.scfdata.output) then
      if (.scfdata.fitting) then

         if (.crystal.xray_data.allocated AND .scfdata.SCF_kind.includes("xray")) then
            stdout.flush
            stdout.text("X-ray data-treatment options:")
            .crystal.put_correction_data
         end

       ! if (.crystal.pnd_data.allocated AND .scfdata.SCF_kind.includes("pnd")) then
       !    .crystal.assign_pnd
       !    stdout.flush
       !    stdout.text("PND data-treatment options:")
       !    .crystal.put_correction_data
       ! end

      end
      end

      ! Initial guess energies
      .scfdata.put_initial_guess_energies

   end

   put_SCF_table_header_only
   ! Put out the SCF iteration table header
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      ! Table head & n-th iteration results
      .scfdata.put_table_header

   end

   put_SCF_table_header
   ! Put out the SCF iteration table header
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      ! Table head & 0-th iteration results
      .scfdata.put_table_head
      .scfdata.put_table_body_and_footer(.crystal)

   end

   put_SCF_table_body(flush)
   ! Put out the SCF iteration results, body and footer
      self :: INOUT
      flush :: BIN, optional, IN

   ENSURE(.scfdata.allocated,"no scfdata")

      .scfdata.put_table_body_and_footer(.crystal,flush)

   end

   put_SCF_results
   ! Put out the SCF results
      self :: IN

   ENSURE(.scfdata.allocated,"no scfdata")

      name :: STR

      .scfdata.put_results(.crystal)

      if (.scfdata.save_cluster_charges) then
         name = trim(.name) // ".gaussian-point-charges"
         .scfdata.put_cluster_charges(name)
      end

   end

   archive_SCF_results
   ! Save the SCF results in various archives on disk
      self :: IN

   ENSURE(.scfdata.allocated,"no scfdata")

      name :: STR

      if (.scfdata.delete_all_archives) return

      .PUT:put_archive(.MOs,"MOs",with_lambda=TRUE)
      .PUT:put_archive(.MO_energies,"MO_energies",with_lambda=TRUE)
      .PUT:put_archive(.density_mx,"density_mx",with_lambda=TRUE)

      ! Put out cluster charges
      if (.scfdata.cluster_charges.allocated) then
         name = trim(.name) // ".gaussian-point-charges"
         .scfdata.put_cluster_charges(name)
      end

   end

   cleanup_scf ::: leaky
   ! Clean up the SCF files produced.
   ! Keep only MOs and density matrix
      self :: INOUT

      .SET:destroy_tmp_SCF_matrices

      if (.scfdata.allocated) then
         .scfdata.SCF_DIIS.reset_iteration_defaults
         if (.scfdata.delete_SCF_archives) .SET:delete_SCF_archives(keep_MOs=TRUE,keep_DM=TRUE)
      end

      ! Clean
      .scfdata.table_info.destroy
      .scfdata.table.destroy
      .max_I.destroy

   end

!  ===============
!  Constrained SCF
!  ===============

   constrained_SCF ::: leaky
   ! Do a constrained SCF calculation.
   ! The following objects are produced as results:
   !   .MOs, .MO_energies, .density_mx
      self :: INOUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated, "no crystal information")
   ENSURE(.crystal.xray_data.allocated, "no diffraction data")

      .:initialize_scf

      .:put_SCF_banner_and_options
      .:put_SCF_table_header

      do ! lambda loop

         do ! scf loop

            .:extrapolate_Fock_mx
            .:update_MOs
            .BASE:make_SCF_density_mx
            .:make_Fock_mx
            .:make_constraint_data
            .:update_scfdata
            .:add_constraint_to_Fock_mx
            .:update_scfdata_error
            .:put_SCF_table_body(flush=TRUE)
            if (.scfdata.scf_done) exit

         end

         .:archive_SCF_results
         .BASE:put_florian_wfn_file(with_lambda=TRUE)

         ! Calculate the residuals & CIF at this lambda
         if (.crystal.xray_data.do_residual_cube) then
            .:get_minmax_residual_density(output=TRUE)
            .PUT:put_CIFs(with_ESDs=FALSE)
            .PUT:put_tonto_fcf_XCW
            .PUT:put_olex_fcf_XCW
            .PUT:put_xd_fco_XCW
         end

         .scfdata.update_lambda

         if (.scfdata.exceeded_lambda_max) exit

         .:reset_for_next_lambda
         .:update_scfdata_error
         .:put_SCF_table_header_only

      end

      .:put_SCF_results

      .:cleanup_scf

      ! Put data analysis & cube output
      if (.crystal.xray_data.do_standard_plots) then
         .crystal.put_X_data_analysis(output=TRUE)
      end

!     ! Residual density   !this procedure is redundant(Lorraine)
!     if (.crystal.xray_data.do_residual_cube) &
!        .SCF:get_minmax_residual_density(output=TRUE)

   end

   make_constraint_data
   ! Make the predicted constraint data, e.g. X-ray structure factors
   ! or PND structure factors, or whatever data are to be used in the
   ! constrained wavefunction procedure
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      scf_kind :: STR

      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("xray_rhf","xray_rks","xray_uhf","xray_uks","xray_gchf");
         if (.crystal.uses_Hirshfeld_atoms) .:make_HA_inputs(skip_NOs=TRUE)
         .:make_X_SFs
    !    if (.crystal.xray_r_free_data.allocated) .:make_X_free_SFs

    ! case ("pnd_uhf","pnd_uks");
    !    .:make_N_SFs
    !    if (.crystal.pnd_r_free_data.allocated)  .:make_N_free_SFs

    ! case ("xray_pnd_uhf","xray_pnd_uks");
    !    if (.crystal.uses_Hirshfeld_atoms) .:make_HA_inputs(skip_NOs=TRUE)
    !    .:make_X_SFs
    !    .:make_N_SFs
    !    if (.crystal.xray_r_free_data.allocated) .:make_X_free_SFs
    !    if (.crystal.pnd_r_free_data.allocated)  .:make_N_free_SFs

      case default
         DIE("unknown wavefunction fitting kind, "//scf_kind.trim)

      end

   end

   add_constraint_to_Fock_mx
   ! Make the constraint matrix for wavefunction fitting and add it to the fock
   ! matrix to obtain the effective fock matrix.
      self :: INOUT

      ENSURE(.scfdata.allocated,"no scf data")
      ENSURE(.fock_mx.allocated,"no fock matrix")
      ENSURE(.fock_mx.has_any_genre,"no fock matrix")

      C :: OPMATRIX@

      C.create(.n_bf,.scfdata.spinorbital_genre)

      if (.scfdata.lambda.is_zero) then

         ! Save some work if lamda is zero
         C.set_to_zero

      else

         ! Make the constraint term
         .:make_X_constraint(C)
         .fock_mx.plus_scaled(C,.scfdata.lambda)

      end

      ! Clean up
      C.destroy

   end

   make_X_constraint(C)
   ! Make constraint matrix for restricted or unrestricted SCF cases
      self :: INOUT
      C :: OPMATRIX, INOUT

   ENSURE(any(.scfdata.spinorbital_genre==["r","u"]),"only rhf/uhf!")
   ENSURE(.crystal.allocated,  "no crystal info")
   ENSURE(.crystal.xray_data.allocated, "no reflection data")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

    ! tmp :: OPMATRIX@
      CR  :: MAT{REAL}@

      select case (.scfdata.SCF_kind)

      case ("xray_rhf","xray_rks")
         if (.crystal.uses_Hirshfeld_atoms) then
            .:make_H_r_constraint(C.r)
         else
            .:make_r_constraint(C.r)
         end

      case ("xray_uhf","xray_uks")
         if (.crystal.uses_Hirshfeld_atoms) then
            .:make_H_r_constraint(C.a)
         else
            .:make_r_constraint(C.a)
         end
         C.b = C.a

      case ("xray_gchf")
         if (.crystal.uses_Hirshfeld_atoms) then
             DIE("hirshi not yet available for xray_gchf")
           ! .:make_H_r_constraint(C.a)
         else
         C.gc=(ZERO,ZERO)
         CR.create(2*.n_bf,2*.n_bf)
            .:make_gc_constraint(CR)
         end
         C.gc = CR
         CR.destroy

    ! case ("pnd_uhf","pnd_uks")
    !    if (.crystal.uses_Hirshfeld_atoms) then
    !       ! This is NOT correct 22/3/10, dylan
    !       .:make_H_r_constraint(C.a)
    !    else
    !       .:make_pnd_constraint(C.a)
    !    end
    !    C.b = -C.a

    ! case ("xray_pnd_uhf","xray_pnd_uks")
    !    tmp.create(.n_bf,.scfdata.spinorbital_genre)
    !    .:make_r_constraint(tmp.a)
    !    tmp.b = tmp.a
    !    C.to_scaled(tmp,ONE/.crystal.F_chi2)
    !    .:make_pnd_constraint(tmp.a)
    !    tmp.b = -tmp.a
    !    C.plus_scaled(tmp,ONE/.crystal.F_chi2)
    !    tmp.destroy

      end

   end

   make_r_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
      self :: INOUT
      C :: MAT{REAL}, INOUT

      k_pts :: MAT{REAL}@
      ft_ab    :: MAT3{CPX}@
      ft_ab_eq :: MAT3{CPX}@
      Fc :: VEC{CPX}@
      fac_times_alpha :: VEC{REAL}@
      Fm,Fexp,Fsig    :: VEC{REAL}@
      alpha,Fcr,Fci   :: VEC{REAL}@
      fac, cutoff :: REAL
      q,fa,la,fb,lb,na,nb :: INT
      i,j,  atom_a,atom_b :: INT
      n_k,n_refl,n_par    :: INT
      sh :: SHELL2

      n_k    = .crystal.n_unique_SF_k_pts
      n_refl = .crystal.xray_data.reflections.dim
      n_par  = .crystal.xray_data.n_param

      fac = TWO/max(n_refl - n_par,1)
 
      fac_times_alpha.create(n_refl)
 
      Fcr.create(n_refl)
      Fci.create(n_refl)
 
      Fc    = .crystal.xray_data.reflections.F_calc
      alpha = .crystal.xray_data.INQ:F_scale_and_extn_correction
      Fexp  = .crystal.xray_data.reflections.F_exp
      Fsig  = .crystal.xray_data.reflections.F_sigma
      Fm    = max(abs(Fc),TOL(10))
 
      fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)
 
      Fm.destroy
      Fsig.destroy
      Fexp.destroy
      alpha.destroy
 
      Fcr = fac_times_alpha * RE(Fc)
      Fci = fac_times_alpha * IM(Fc)
 
      fac_times_alpha.destroy
      Fc.destroy
 
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)
 
      cutoff = TOL(10) / .n_shell_pairs
 
      C = ZERO
 
      parallel do q = 1, .n_shell_pairs
 
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)
 
         if (sh.skip_ft(cutoff)) then
            sh.destroy_ptr_part
            cycle
         end
 
         ft_ab.create([1,n_refl],[fa,la],[fb,lb])
         ft_ab_eq.create(n_k,na,nb)
         .XTAL:make_FT_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         .crystal.spacegroup.sum_unique_sf_ints(ft_ab,ft_ab_eq,.crystal.xray_data.reflections)
         ft_ab_eq.destroy
 
         do i = fa,la
         do j = fb,min(lb,i)
            C(i,j) = VEC{REAL}:sum_elements( RE(ft_ab(:,i,j))*Fcr + IM(ft_ab(:,i,j))*Fci )
         end
         end
 
         ft_ab.destroy
         sh.destroy_ptr_part
 
      end
 
      ! Symmetrise
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(C)
      else
         C.symmetric_reflect
      end
 
      ! Get rid of OO block if requested
      if (.scfdata.zero_oo_constraint_block) then
         C.change_basis_using(.MOs.r)
         C(1:.n_a,1:.n_a) = ZERO
         C.back_transform_using(.MOs.r)
      end
 
      ! Clean up
      k_pts.destroy
      Fci.destroy
      Fcr.destroy

   end

   make_gc_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
      self :: INOUT
      C :: MAT{REAL}, INOUT  ! CPX ????
     
      k_pts    :: MAT{REAL}@
      ft_ab    :: MAT3{CPX}@
      ft_ab_eq :: MAT3{CPX}@
      Fc :: VEC{CPX}@
      fac_times_alpha :: VEC{REAL}@
      Fm,Fexp,Fsig    :: VEC{REAL}@
      alpha,Fcr,Fci   :: VEC{REAL}@
      fac,cutoff :: REAL
      q,fa,la,fb,lb,na,nb :: INT
      i,j,  atom_a,atom_b :: INT
      n_k,n_refl,n_par    :: INT
      sh :: SHELL2
     
      n_k    = .crystal.n_unique_SF_k_pts
      n_refl = .crystal.xray_data.reflections.dim
      n_par  = .crystal.xray_data.n_param
      fac    = TWO/max(n_refl - n_par,1)
     
      fac_times_alpha.create(n_refl)
     
      Fcr.create(n_refl)
      Fci.create(n_refl)
     
      Fc.create(n_refl)
      Fc = .crystal.xray_data.reflections.F_calc
     
      alpha.create(n_refl)
      alpha = .crystal.xray_data.INQ:F_scale_and_extn_correction
     
      Fexp.create(n_refl);  Fexp = .crystal.xray_data.reflections.F_exp
      Fsig.create(n_refl);  Fsig = .crystal.xray_data.reflections.F_sigma
      Fm.create(n_refl);    Fm = max(abs(Fc),TOL(10))
     
      fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)
     
      Fm.destroy
      Fsig.destroy
      Fexp.destroy
      alpha.destroy
     
      Fcr = fac_times_alpha * RE(Fc)
      Fci = fac_times_alpha * IM(Fc)
     
      fac_times_alpha.destroy
      Fc.destroy
     
      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)
     
      cutoff = TOL(10) / .n_shell_pairs
     
      C = ZERO
     
      parallel do q = 1, .n_shell_pairs
     
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)
     
         if (sh.skip_ft(cutoff)) then
            sh.destroy_ptr_part
            cycle
         end
     
         ft_ab.create([1,n_refl],[fa,la],[fb,lb])
         ft_ab_eq.create(n_k,na,nb)
         .XTAL:make_FT_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         .crystal.spacegroup.sum_unique_sf_ints(ft_ab,ft_ab_eq,.crystal.xray_data.reflections)
         ft_ab_eq.destroy
     
         do i = fa,la
         do j = fb,min(lb,i)
            C(i,j) = VEC{REAL}:sum_elements( RE(ft_ab(:,i,j))*Fcr + IM(ft_ab(:,i,j))*Fci )
            C(i+.n_bf,j+.n_bf) = VEC{REAL}:sum_elements( RE(ft_ab(:,i,j))*Fcr + IM(ft_ab(:,i,j))*Fci )  ! ???
         end
         end
     
         ft_ab.destroy
         sh.destroy_ptr_part
     
      end
     
      ! Symmetrise
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(C)
      else
         C.symmetric_reflect ! make hermitean ????
      end
     
      ! Get rid of OO block if requested -- not valid for gchf
      !if (.scfdata.zero_oo_constraint_block) then
      !   C.change_basis_using(.MOs.r)
      !   C(1:.n_a,1:.n_a) = ZERO
      !   C.back_transform_using(.MOs.r)
      !end
     
      ! Clean up
      k_pts.destroy
      Fci.destroy
      Fcr.destroy

   end

   make_H_r_constraint(constraint)
   ! Make the "constraint" matrix for restricted X-ray wavefunction
   ! fitting ...using Hirshfeld atoms to do thermal smearing
      self :: INOUT
      constraint :: MAT{REAL}, target

   ENSURE(.INQ:has_Hirshfeld_inputs,"no becke_grid/ANOs! make_HA_inputs?")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.r.allocated,"no restricted density matrix")
   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.crystal.allocated,"no crystal info")
   ENSURE(.basis_info_made,"no basis info")

      Fc, tfc :: VEC{CPX}@
      Fcr,Fci,X,wt,Fm :: VEC{REAL}@
      Fexp,Fsig,alpha :: VEC{REAL}@
      fac_times_alpha :: VEC{REAL}@
      xa,ya,za,a2     :: VEC{REAL}@
      tf2,tf3,tf4     :: VEC{REAL}@
      ra, ga,gb       :: VEC{REAL}@
      near_atom       :: VEC{INT}@
      pi,pj,pn        :: VEC{INT}@
      skipa0, skipa   :: VEC{BIN}@
      skipab, skipb   :: VEC{BIN}@
      adp2    :: MAT{REAL}(3,3)
      adp3    :: MAT3{REAL}(3,3,3)
      adp4    :: MAT4{REAL}(3,3,3,3)
      k_pt,pt :: MAT{REAL}@
      bf_save :: MAT{REAL}@
      bf_skip :: VEC{EVEC{BIN}}@
      bf_grid :: VEC{EMAT{REAL}}@
      fac,cutoff,rf, val :: REAL
      ca,oa,fsa,lsa, sa,fa,la,na   :: INT
      cb,ob,fsb,lsb, sb,fb,lb,nb   :: INT
      n_k,n_refl,n_par,n_pt,n_keep :: INT
      c, fba, as, a,b, p,i,j,n     :: INT
      sha :: SHELL1

      ! Number of reflections
      n_k    = .crystal.n_unique_SF_k_pts
      n_refl = .crystal.xray_data.reflections.dim
      n_par  = .crystal.xray_data.n_param

      ! Multipliers for the ft integrals
      Fcr.create(n_refl)
      Fci.create(n_refl)

      ! The calculated (complex) structure factors
      Fc.create(n_refl)
      Fc = .crystal.xray_data.reflections.F_calc

      ! Make the multipliers ... and clean up
      fac = TWO/max(n_refl - n_par,1)
      fac_times_alpha.create(n_refl)

      alpha.create(n_refl)
      Fexp.create(n_refl)
      Fsig.create(n_refl)
      Fm.create(n_refl)

      alpha = .crystal.xray_data.INQ:F_scale_and_extn_correction
      Fexp  = .crystal.xray_data.reflections.F_exp
      Fsig  = .crystal.xray_data.reflections.F_sigma
      Fm    = max(abs(Fc),TOL(10))

      fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)

      Fm.destroy
      Fsig.destroy
      Fexp.destroy
      alpha.destroy

      Fcr = fac_times_alpha * RE(Fc)
      Fci = fac_times_alpha * IM(Fc)

      fac_times_alpha.destroy
      Fc.destroy

      ! Symmetry generated K points and SF's
      k_pt.create(n_k,3)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      .crystal.make_unique_X_SF_k_pts(k_pt)

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Initialse the constraint
      constraint = ZERO

      ! Loop over integration atoms "c"
      ! -- Must we loop on all, or just asymmetric unit?
      parallel do c = 1,.n_atom

         ! Repetition factor for this atom
         rf = .crystal.repetition_factor(c)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         near_atom = .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         .GRID:apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt -- leaky
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Harmonic temperature factor (for each reflection)
         .atom(c).put_ADP2_vector_to(adp2)
         tf2.create(n_k)
         tf2.to_contraction_i2_of(k_pt,adp2)
         tf2 = exp(-HALF*tf2)

         ! Die if there are only ADP3s
         DIE_IF(.atom(c).has_only_ADP3s_and_errors,"only ADP3s with HA XCW: unimplemented")

         ! Anharmonic temperature factor?
         if (.atom(c).has_only_ADP4s_and_errors) then

            ! Get anharmonic constants
            .atom(c).put_ADP3_vector_to(adp3)
            .atom(c).put_ADP4_vector_to(adp4)

            ! Temperature factor contributions
            tfc.create(n_k)
            tf3.create(n_k)
            tf4.create(n_k)

            ! Harmonic and anharmonic temperature factors (for each reflection)
            tf3.to_contraction_i2_of(k_pt,adp3)
            tf4.to_contraction_i2_of(k_pt,adp4)
            tfc = tf2 * SIXTH * cmplx(SIX + QUARTER*tf4,-tf3,kind=CPX_KIND)

            ! Get effective density "X"
            X.create(n_pt)
            .crystal.spacegroup.sum_unique_sf_pts(X,k_pt,pt,tfc,Fcr,Fci,.crystal.xray_data.reflections)

            ! Fold effective density "X" into "wt"
            wt = rf * wt * X

            ! Clean
            X.destroy
            tf4.destroy
            tf3.destroy
            tfc.destroy
            tf2.destroy

         else

            ! Get effective density "X"
            X.create(n_pt)
            .crystal.spacegroup.sum_unique_sf_pts(X,k_pt,pt,tf2,Fcr,Fci,.crystal.xray_data.reflections)

            ! Fold effective density "X" into "wt"
            wt = rf * wt * X

            ! Clean
            X.destroy
            tf2.destroy

         end

         ! Loop c-overlapping atoms a
         do ca = 1,near_atom.dim

            oa  = near_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .basis_shell1pair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element = skipa

               ! Make/copy the "sa" basis function grid
               ! This must be copied since skipa could be TRUE
               bf_grid(sa).element.create(n_keep,na)
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        bf_grid(sa)[i,a] = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(bf_grid(sa).element,n_keep,xa,ya,za,a2,skipa,n_pt)
               end

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = near_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points
                     if (bf_skip(sb).element.deallocated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Product of ga and gb and effective density for "c"
                     ! Add the contribution to constraint "C"
                   ! CC = constraint(fa:la,fb:lb)

                     if (na*nb==1) then

                        ga = bf_grid(sa)[:,1]
                        gb = bf_grid(sb)[:,1]
                        val = ZERO
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val = val +  ga(i)*gb(j)*wt(n)
                        end
                        constraint(fa,fb) = constraint(fa,fb) + val

                     else

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        do a = 1,na
                           ga = bf_grid(sa)[:,a]
                           do b = 1,nb
                              gb = bf_grid(sb)[:,b]
                              val = ZERO
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val = val +  ga(i)*gb(j)*wt(n)
                              end
                              constraint(fa-1+a,fb-1+b) = constraint(fa-1+a,fb-1+b) + val
                           end
                        end

                        ! Clean up
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                     ! Copy back
                   ! constraint(fa:la,fb:lb) = CC

                  end
               end
            end
         end

         ! Clean up atom "c" stuff
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      k_pt.destroy
      Fci.destroy
      Fcr.destroy

      ! Symmetrise
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(constraint)
      else
         constraint.symmetric_reflect
      end

      ! Get rid of OO block if requested
      if (.scfdata.zero_oo_constraint_block) then
         constraint.change_basis_using(.MOs.r)
         constraint(1:.n_a,1:.n_a) = ZERO
         constraint.back_transform_using(.MOs.r)
      end

   end

   make_pnd_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
      self :: INOUT
      C :: MAT{REAL}, INOUT

   ENSURE(.crystal.allocated,"no crystal info")
   ENSURE(.crystal.spacegroup.centrosymmetric,"crystal must be centrosymmetric")
   DIE_IF(NOT .crystal.spacegroup.centrosymmetric,"crystal must be centrosymmetric")

      k_pts :: MAT{REAL}@
      ft_ab_eq,ft_ab :: MAT3{CPX}@
      Fc,fac_times_alpha :: VEC{CPX}@
      Fexp,Fsig,alpha :: VEC{REAL}@
      fac,cutoff :: REAL
      q,fa,la,fb,lb,na,nb :: INT
      i,j,atom_a,atom_b   :: INT
      n_k,n_refl,n_par    :: INT
      sh :: SHELL2

      n_k    = .crystal.n_unique_SF_k_pts
      n_refl = .crystal.xray_data.reflections.dim
      fac    = -G_FACTOR/(TWO*max(n_refl - n_par,1))

      fac_times_alpha.create(n_refl)

      Fc.create(n_refl)
      Fc = .crystal.xray_data.reflections.F_calc

      alpha.create(n_refl)
      alpha = .crystal.xray_data.INQ:F_scale_and_extn_correction

      Fexp.create(n_refl);  Fexp = .crystal.xray_data.reflections.F_exp
      Fsig.create(n_refl);  Fsig = .crystal.xray_data.reflections.F_sigma
      fac_times_alpha = fac * alpha * (alpha * Fc - Fexp) / (Fsig * Fsig)

      Fsig.destroy
      Fexp.destroy
      alpha.destroy
      Fc.destroy

      k_pts.create(n_k,3)
      .crystal.make_unique_X_SF_k_pts(k_pts)
      cutoff = TOL(10) / .n_shell_pairs

      C = ZERO

      parallel do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then
            sh.destroy_ptr_part
            cycle
         end

         ft_ab.create([1,n_refl],[fa,la],[fb,lb])
         ft_ab_eq.create(n_k,na,nb)
         .XTAL:make_FT_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         .crystal.spacegroup.sum_unique_sf_ints(ft_ab,ft_ab_eq,.crystal.xray_data.reflections)
         ft_ab_eq.destroy

         do i = fa,la
            do j = fb,min(lb,i)
               C(i,j) = VEC{REAL}:sum_elements( RE(fac_times_alpha(:)*ft_ab(:,i,j)) )
            end
         end

         ft_ab.destroy
         sh.destroy_ptr_part

      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(C)
      else
         C.symmetric_reflect
      end

      k_pts.destroy
      fac_times_alpha.destroy

   end

   reset_for_next_lambda ::: leaky
   ! Reset the iteration counters for the next lambda iteration.
   ! Also reset the fock matrices on disk.
      self :: INOUT

      .INTS:make_overlap_mx
      .scfdata.reset_for_next_lambda

   end

!  ========================
!  Min-max residual density
!  ========================

   get_minmax_residual_density(output)
   ! Evaluate the min and max residual density from the
   ! fitted structure factors, evaluated on a grid 0.1 A
   ! per side. Also evaluate the residuals at the atom
   ! centers and report the worst one. Store results in the
   ! diffraction data object.
      self :: INOUT
      output :: BIN, IN

   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no crystal data")

      .:get_minmax_residual_density_p( &
         .crystal.xray_data.min_residual, &
         .crystal.xray_data.max_residual, &
         .crystal.xray_data.rms_residual, &
!        .crystal.xray_data.min_atom_residual, &
!        .crystal.xray_data.max_atom_residual, &
!        .crystal.xray_data.rms_atom_residual, &
!        .crystal.xray_data.min_atom_residual_tag, &
!        .crystal.xray_data.max_atom_residual_tag, &
         output)   

   end

   get_minmax_residual_density_p(minp,maxp,rmsp,output) ::: private
   ! Evaluate the min and max residual density from the
   ! fitted structure factors, evaluated on a grid 0.1 A
   ! per side. Also evaluate the residuals at the atom
   ! centers and report the worst one.
      self :: INOUT
      minp, maxp, rmsp  :: REAL, OUT
!     minpa,maxpa,rmspa :: REAL, OUT
!     minat,maxat       :: STR, OUT
      output :: BIN, IN

   DIE_IF(NOT .atom.allocated, "no atoms to fit")
   DIE_IF(NOT .crystal.allocated, "no crystal")
   DIE_IF(NOT .crystal.fragment_info_made, "no crystal fragment info")
   DIE_IF(NOT .crystal.xray_data.allocated,"no crystal data")
   DIE_IF(NOT .crystal.xray_data.allocated,"no crystal xray data")

      map :: VEC{REAL}@
      pt :: MAT{REAL}@
      n_pt, maxa,mina :: INT
      maxtag,mintag :: STR
      maxpos,minpos :: VEC{REAL}(3)
      fac,fac3,maxd,mind :: REAL

      ! Set up
      if (.plot_grid.deallocated) .plot_grid.create
      .plot_grid.set_plot_kind("residual_density")

      ! Use unit cell as bbox if requested
      .plot_grid.set_box_scale_factor(ONE)

      if (.plot_grid.desired_separation.is_zero) then
      if (.plot_grid.n_x.is_one) then
         .plot_grid.set_desired_separation(0.1*BOHR_PER_ANGSTROM)
      end
      if (.plot_grid.n_y.is_one) then
         .plot_grid.set_desired_separation(0.1*BOHR_PER_ANGSTROM)
      end
      if (.plot_grid.n_z.is_one) then
         .plot_grid.set_desired_separation(0.1*BOHR_PER_ANGSTROM)
      end
      end
      .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)

      if (output) then

      stdout.flush
      stdout.text("=====================")
      stdout.text("Residual density data")
      stdout.text("=====================")

      stdout.flush
      stdout.text(". Grid has voxels less than 0.1 A per side")
      stdout.text(". Length units are in Angstrom")

      stdout.flush
      .plot_grid.put_minimal

      end

      ! Make the residual map
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3) ! Needed to see cartesian (xyz) coord
      map.create(n_pt)  ! Done in fractionals using plot.nx's
      .plot_grid.set_plot_kind("residual_density")
      .plot_grid.make_points(pt)
      .crystal.make_residual_density_cell(map,.plot_grid.n_x,.plot_grid.n_y,.plot_grid.n_z)

      ! Change to /A3
      fac    = ANGSTROM_PER_BOHR
      fac3   = BOHR_PER_ANGSTROM**3
      map    = fac3*map

      maxa   = maxloc(map,dim=1)
      mina   = minloc(map,dim=1)
      maxp   = map(maxa)
      minp   = map(mina)
      rmsp   = map.standard_deviation

      maxpos = pt(maxa,:)
      minpos = pt(mina,:)
      maxa   = .atom.nearest_atom_to(maxpos)
      mina   = .atom.nearest_atom_to(minpos)
      maxtag = .atom(maxa).tag
      mintag = .atom(mina).tag
      maxd   = VEC{REAL}:norm(maxpos-.atom(maxa).position)
      mind   = VEC{REAL}:norm(minpos-.atom(mina).position)

      if (output) then
      stdout.flush
      stdout.text("Unit cell residual density:")
      stdout.flush
      stdout.show("Maximum                 = ",maxp)
      stdout.show("- nearest atom          = ",maxtag)
      stdout.show("- distance to it        = ",maxd*fac)
      stdout.show("Minimum                 = ",minp)
      stdout.show("- nearest atom          = ",mintag)
      stdout.show("- distance to it        = ",mind*fac)
      stdout.show("RMS                     = ",rmsp)
      end

      ! Write cube file
      .PUT:dump_plot_grid(map,"residual_density",form="cell.cube")

      ! Clean
      pt.destroy
      map.destroy
      .plot_grid.destroy

!     ! Create atom coords
!     pt.create(.n_atom,3)
!     map.create(.n_atom)
!     .atom.put_coordinates_to(pt,positions_as_rows=FALSE)
!     .crystal.make_residual_density_map(map,pt)

!     ! Change to /A3
!     map    = fac3*map
!     maxa   = maxloc(map,dim=1)
!     mina   = minloc(map,dim=1)
!     maxpa  = map(maxa)
!     minpa  = map(mina)
!     rmspa  = map.standard_deviation
!     maxat  = .atom(maxa).tag
!     minat  = .atom(mina).tag

    ! if (output) then
    ! stdout.flush
    ! stdout.text("Residuals on atoms:")
    ! stdout.flush
    ! stdout.show("Maximum                 = ",maxpa)
    ! stdout.show("- for atom              = ",maxat)
    ! stdout.show("Minimum                 = ",minpa)
    ! stdout.show("- for atom              = ",minat)
    ! stdout.show("RMS                     = ",rmspa)
    ! end

      ! Clean
!     pt.destroy
!     map.destroy

   end

!  ============
!  Embedded SCF
!  ============

!   embedded_scf ::: leaky
!   ! Do an SCF calculation for a molecular fragment embedded in a crystal
!   ! generated cluster. The .MOs and .MO_energies are
!   ! obtained for the embedded fragment. The .density_mx is obtained for the
!   ! whole cluster. There must be a pre-existing cluster, and self must be the
!   ! same as this cluster. Also, there must be a .saved molecule representing
!   ! the embedded fragment whose orbitals are obtained.
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.allocated,"no atom list")
!   ENSURE(.cluster.allocated,"no cluster")
!   ENSURE(.saved.allocated,"no saved fragment molecule")
!   ENSURE(.saved.MOs.allocated,"no saved molecular orbitals")
!     .initialize_scf
!     .put_SCF_results
!     do
!       if (.scfdata.scf_done) exit
!       .add_cluster_projector(.fock_mx,.MOs)
!       .accelerate_Fock_mx
!       ! Get back the fragment MO's
!       .unarchive_MOs
!       .update_MOs
!       ! Symmetry transform the occupied MO's around the crystal cluster.
!       ! This stuffs up the fragment MO's.
!       .transform_embedded_orbitals(.MOs,do_virtual=FALSE)
!       ! This is the cluster density matrix
!       .BASE:make_SCF_density_mx(n_a=.saved.n_a*.cluster.n_fragment_symop)
!       ! This is the cluster fock matrix
!       .:make_Fock_mx
!       ! Now make the fragment density matrix, and update info
!       .BASE:make_SCF_density_mx(n_a=.saved.n_a,damp=FALSE)
!       .update_scfdata
!       .update_scfdata_error
!       .put_SCF_results
!     end
!     .:archive_SCF_results
!     .:cleanup_scf
!   end
!
!   initialize_embedded_scf ::: leaky
!   ! Initialise the embedded SCF procedure
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.saved.allocated,"no saved molecule")
!   ENSURE(.cluster.allocated,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")

!      if (.scfdata.is_DFT_calculation) .SET:initialize_DFT_grids
!      ! Initialize and archive the MO's
!      .initialize_embedded_orbitals
!      .transform_embedded_orbitals(.MOs,do_virtual=TRUE)
!      .PUT:put_archive(.MOs,"MOs",with_lambda=TRUE)
!      ! This is the cluster density matrix
!      .BASE:make_SCF_density_mx(n_a=.saved.n_a*.cluster.n_fragment_symop,damp=FALSE)
!      ! This is the cluster fock matrix
!      .:make_Fock_mx
!      ! Now we have back the fragment density matrix
!      .BASE:make_SCF_density_mx(n_a=.saved.n_a,damp=FALSE)
!      .initialize_scfdata
!      .initialize_scfdata_error
!      .scfdata.SCF_DIIS.cleanup

!   end
!
!   initialize_embedded_orbitals ::: leaky
!   ! Initialise the embedded cluster .molecular orbitals from those in the
!   ! .saved fragment. This does not do any symmetry transformation.
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.saved.allocated,"no saved molecule")
!   ENSURE(.cluster.allocated,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      nsb,nso,nsv,no,nv :: INT
!      nsb = .saved.n_bf
!      nso = .saved.n_a
!      nsv = nsb - nso
!      no  = nso*.cluster.n_fragment_symop
!      nv  = nsv*.cluster.n_fragment_symop
!      select case (.scfdata.SCF_kind)
!         case ("embedded_rhf","crystal_rhf")
!            .MOs.destroy("r ")
!            .MOs.r.create(.n_bf,.n_bf)
!            .MOs.r = ZERO
!            .MOs.r(1:nsb,1:nso) = .saved.MOs.r(:,1:nso)
!            .MOs.r(1:nsb,no+1:no+nsv) = .saved.MOs.r(:,nso+1:nso+nsv)
!            .MO_energies.create(genre=.scfdata.MO_energies_kind)
!         case default
!            DIE("unknown or unimplemented SCF kind, "//trim(.scfdata.SCF_kind))
!      end
!   end
!
!   transform_embedded_orbitals(MO,do_virtual)
!   ! Transform the (.saved) embedded molecular orbitals "MO" into the crystal
!   ! orbitals over the cluster (i.e. this molecule) using crystal symmetry
!   ! operations.
!      MO :: OPMATRIX@
!      do_virtual :: BIN, optional
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.saved.allocated,"no scfdata")
!      select case (.scfdata.SCF_kind)
!         case ("embedded_rhf","crystal_rhf")
!            .transform_embedded_orbitals_r(MO.r,do_virtual)
!         case default
!            DIE("unknown or unimplemented SCF kind, "//trim(.scfdata.SCF_kind))
!      end
!   end
!
!   transform_embedded_orbitals_r(MO,do_virtual)
!   ! Transform the (.saved) embedded molecular orbitals "MO" into the crystal
!   ! orbitals over the cluster (i.e. this molecule) using crystal symmetry
!   ! operations.
!      MO :: MAT{REAL}@
!      do_virtual :: BIN, optional
!   ENSURE(MO.is_square,"MO is not square")
!   ENSURE(MO.dim1==.n_bf,"wrong size for MO")
!   ENSURE(.saved.allocated,"no saved molecule")
!   ENSURE(.cluster.allocated,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      seitz :: MAT3{REAL}@
!      tr :: VEC{MAT3_{REAL}}@
!      nso,nsv,no,nv,q,op,fo,lo,fv,lv,s,a,fs,ls,sf,sl,p,fp,fa,L :: INT
!      do_virt :: BIN
!      do_virt = FALSE
!      if (present(do_virtual)) do_virt = do_virtual
!      seitz = .crystal.xyz_seitz_matrices
!      tr.make_gaussian_xyz_matrices(seitz)
!      nso = .saved.n_a
!      nsv = .saved.n_bf - nso
!      no  = nso*.cluster.n_fragment_symop
!      nv  = nsv*.cluster.n_fragment_symop
!      ! Assume the occupied neighbouring orbitals occur as the end columns (due
!      ! to the use of a projection operator of high energy)
!    ! MO(:,no+1:no+nv) = MO(:,nso+1:nso+nv)
!      MO(:,nso+1:no) = ZERO                    ! to be defined below
!      if (do_virt) MO(:,no+nsv+1:no+nv) = ZERO ! to be defined below
!      lo = nso
!      lv = no+nsv
!      do q = 2,.cluster.n_fragment_symop                  ! Loop over generating cluster symops
!         op  = .cluster.fragment_symop(1,q)               ! The seitz op for the cluster symop
!         fo = lo + 1
!         lo = lo + nso
!         fv = lv + 1
!         lv = lv + nsv
!         do s = 1,.n_shell                                ! Loops over shells s in the row i.e. ao's.
!            a = .atom_for_shell(s)                        ! The atom for shell s
!            p  = .cluster.fragment_parents_for_atom(a,q)  ! Which atom (not necesarily fragment) did "a" come from?
!            if (p==0) cycle                               ! No parent? then cycle
!            fs = .first_basis_fn_for_shell(s)
!            ls = .last_basis_fn_for_shell(s)
!            fa = .first_basis_fn_for_atom(a)
!            fp = .first_basis_fn_for_atom(p)
!            sf = fp + fs - fa                             ! first function for embedded shell
!            sl = fp + ls - fa                             ! last  function for embedded shell
!            L  = .angular_moment_for_shell(s)
!            MO(fs:ls,fo:lo).to_product_of(tr(L)[:,:,op],MO(sf:sl,1:nso))
!            if (do_virt) &
!            MO(fs:ls,fv:lv).to_product_of(tr(L)[:,:,op],MO(sf:sl,no+1:no+nsv))
!         end
!      end
!      tr.destroy
!      seitz.destroy
!   end
!
!   collapse_crystal_orbitals_r(MO) ::: leaky
!   ! Collapse the crystal orbitals back into the (.saved) embedded fragment
!   ! orbitals.
!      MO :: MAT{REAL}@
!   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO")
!   ENSURE(MO.dim2==.n_bf,"wrong dim1 for MO")
!      nso,nsv,no,nv :: INT
!      nso = .saved.n_a
!      nsv = .saved.n_bf - nso
!      no  = nso*.cluster.n_fragment_symop
!      nv  = nsv*.cluster.n_fragment_symop
!      MO(:,nso+1:nso+nsv) = MO(:,no +1:no+nsv)
!      MO.shrink_columns(nso+nsv)
!   end
!
!   add_cluster_projector(F,MO)
!   ! Add the cluster projector to the fock matrix "F" using the molecular
!   ! orbitals "MO. This ensures that the occupied orbitals are orthogonal to the
!   ! occupied orbitals of neighbouring molecules.
!     F,MO :: OPMATRIX@
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(F.allocated,"no Fock matrix")
!   ENSURE(F.has_any_genre,"no Fock matrix")
!   ENSURE(F.genre==.scfdata.spinorbital_genre,"incompatible Fock matrix")
!     P,S :: MAT{REAL}@
!     k,l :: INT
!     scf_kind :: STR
!     scf_kind = .scfdata.SCF_kind
!     select case (scf_kind)
!        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf")
!           k = .saved.n_a + 1
!           l = .saved.n_a*.cluster.n_fragment_symop
!           P.create(.n_bf,.n_bf)
!           S.create(.n_bf,.n_bf); .make_r_overlap_mx(S)
!           P.to_product_of(MO.r(:,k:l),MO.r(:,k:l),transpose_b=TRUE)
!           P.change_basis_using(S)
!           .fock_mx.r = .fock_mx.r + .scfdata.kappa*P
!           S.destroy
!           P.destroy
!        case default
!           DIE("unknown or unimplemented SCF kind, "//trim(scf_kind))
!     end
!   end

!   transform_embedded_orbitals(MO)
!   ! Transform the embedded orbitals "MO".
!      MO :: MAT{REAL}
!      seitz :: MAT3{REAL}@
!      tr :: VEC{MAT3_{REAL}}@
!      n_embedded_bf,n_embedded_shell :: INT
!      i,ai,fi,li,if,il,j,aj,fj,lj,jf,jl, q,u,f,p,fa,fp,L :: INT
!      n_embedded_bf = .saved.n_bf
!      n_embedded_shell = .saved.n_shell
!      seitz = .crystal.xyz_seitz_matrices
!      tr.make_gaussian_xyz_matrices(seitz)
!      do i = n_embedded_shell+1,.n_shell                  ! Loop over group i of shells (orbitals) in column
!         ai = .atom_for_shell(i)                          ! The atom that the orbitals in group i belong to
!         q  = .cluster.fragment_symop_for_atom(ai)        ! Which symop generated these shells?
!     !   u  = .cluster.unit_cell_atom_for_atom(ai)
!     !   f  = .crystal.frag_cell_for_unit_cell_atom(u)
!     !   p  = .crystal.frag_atom_for_frag_cell_atom(f)    ! Which fragment atom did "ai" come from?
!         p  = .cluster.fragment_parents_for_atom(ai,q)    ! Which fragment atom did "ai" come from?
!         fi = .first_basis_fn_for_shell(i)
!         li = .last_basis_fn_for_shell(i)
!         fa = .first_basis_fn_for_atom(ai)
!         fp = .saved.first_basis_fn_for_atom(p)
!         if = fp + fi - fa                                ! first function for embedded shell
!         il = fp + li - fa                                ! last  function for embedded shell
!     !      stdout.text("======================================")
!     !      stdout.show("shell i                  =",i)
!     !      stdout.show("atom ai for shell i      =",ai)
!     !      stdout.show("parent p for atom a      =",p)
!     !      stdout.show("clust symop q for atom a =",q)
!     !      stdout.show("first fn for shell i, fi =",fi)
!     !      stdout.show("last  fn for shell i, li =",li)
!     !      stdout.show("first fn for atom a,  fa =",fa)
!     !      stdout.show("first fn for atom p,  fp =",fp)
!     !      stdout.show("first embedded fn,    if =",if)
!     !      stdout.show("last  embedded fn,    il =",il)
!         do j = 1,.n_shell                                ! Loops over shells s in the row i.e. ao's.
!            aj = .atom_for_shell(j)                       ! The atom for shells s
!            p  = .cluster.fragment_parents_for_atom(aj,q) ! Which atom (not necesarily fragment) did "a" come from?
!            if (p==0) cycle
!            fj = .first_basis_fn_for_shell(j)
!            lj = .last_basis_fn_for_shell(j)
!            fa = .first_basis_fn_for_atom(aj)
!            fp = .first_basis_fn_for_atom(p)
!            jf = fp + fj - fa                             ! first function for embedded shell
!            jl = fp + lj - fa                             ! last  function for embedded shell
!            L  = .angular_moment_for_shell(j)
!     !      stdout.flush
!     !      stdout.show("shell j                  =",j)
!     !      stdout.show("atom aj for shell j      =",aj)
!     !      stdout.show("parent p for atom a      =",p)
!     !      stdout.show("clust symop q for atom a =",q)
!     !      stdout.show("first fn for shell j, fj =",fj)
!     !      stdout.show("last  fn for shell j, lj =",lj)
!     !      stdout.show("first fn for atom a,  fa =",fa)
!     !      stdout.show("first fn for atom p,  fp =",fp)
!     !      stdout.show("first embedded fn,    jf =",jf)
!     !      stdout.show("last  embedded fn,    jl =",jl)
!     !      stdout.flush
!            MO(fj:lj,fi:li).to_product_of(tr(L)[:,:,q],MO(jf:jl,if:il))
!         end
!      end
!      tr.destroy
!      seitz.destroy
!   end

!  ===========
!  Crystal SCF
!  ===========
!
!   crystal_scf ::: leaky
!   ! Do an SCF calculation for a molecular fragment embedded in a crystal
!   ! generated cluster. The .MOs and .MO_energies are
!   ! obtained for the embedded fragment. The .density_mx is obtained for the
!   ! whole cluster. There must be a pre-existing cluster, and self must be the
!   ! same as this cluster. Also, there must be a .saved molecule representing the
!   ! embedded fragment whose orbitals are obtained.
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.allocated,"no atom list")
!   ENSURE(.cluster.allocated,"no cluster")
!   ENSURE(.saved.allocated,"no saved fragment molecule")
!   ENSURE(.saved.MOs.allocated,"no saved molecular orbitals")
!     .initialize_scf
!     .put_SCF_results
!     do
!       if (.scfdata.scf_done) exit
!       .add_cluster_projector(.fock_mx,.MOs)
!       .accelerate_Fock_mx
!       ! Get back the fragment MO's
!       .unarchive_MOs
!       .update_MOs
!       ! Symmetry transform the occupied MO's around the crystal cluster.
!       ! This stuffs up the fragment MO's.
!       .transform_embedded_orbitals(.MOs,do_virtual=FALSE)
!       ! This is the cluster density matrix
!       .BASE:make_SCF_density_mx(n_a=.saved.n_a*.cluster.n_fragment_symop)
!       ! This is the cluster fock matrix
!       .:make_Fock_mx
!       ! Now make the fragment density matrix, and update info
!       .BASE:make_SCF_density_mx(n_a=.saved.n_a,damp=FALSE)
!       .update_scfdata
!       .update_scfdata_error
!       .put_SCF_results
!     end
!     .:archive_SCF_results
!     .:cleanup_scf
!   end
!
!   initialize_crystal_scf ::: leaky
!   ! Initialise the crystal SCF procedure
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.saved.allocated,"no saved molecule")
!   ENSURE(.cluster.allocated,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      ! Initialise and archive the MO's
!      .initialize_embedded_orbitals
!      .transform_embedded_orbitals(.MOs,do_virtual=TRUE)
!      .PUT:put_archive(.MOs,"MOs",with_lambda=TRUE)
!      ! This is the cluster density matrix
!      .BASE:make_SCF_density_mx(n_a=.saved.n_a*.cluster.n_fragment_symop,damp=FALSE)
!      ! This is the cluster fock matrix
!      .:make_Fock_mx
!      ! Now we have back the fragment density matrix
!      .BASE:make_SCF_density_mx(n_a=.saved.n_a,damp=FALSE)
!      .initialize_scfdata
!      .initialize_scfdata_error
!      .scfdata.SCF_DIIS.cleanup
!   end
!
!   set_crystal_SCF_occupations
!   ! Set the SCF occupation numbers for the natural orbitals
!   ENSURE(.saved.allocated,"no saved molecule fragment")
!      NO_kind :: STR
!      n_a,n_b,n_e :: INT
!      n_a = .saved.n_a
!      n_b = .saved.n_b
!      n_e = .saved.n_e
!      NO_kind = .NOs.genre
!      select case (NO_kind)
!         case ("r ")
!            .NO_occ_nos.r(1:n_a) = TWO
!         case ("u ")
!            .NO_occ_nos.a(1:n_a) = ONE
!            .NO_occ_nos.b(1:n_b) = ONE
!      end
!   end
!
!   make_effective_charges(charges,positions)
!   ! Make a list of effective point charges that accurately represents the total
!   ! charge of the unit cell.  Includes contributions from electrons and nuclei.
!   ! NOTE: this is normally called on a .saved fragment
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.n_atom,"charges has wrong size")
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.allocated,"Need a list of atoms")
!   ENSURE(.dftgrid.allocated,"no DFT grid")
!     ch,wt,rho,deficit :: VEC{REAL}@
!     pt :: MAT{REAL}@
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,n,i,f,l,ff,ll :: INT
!     Z,val :: REAL
!     ! Make the effective electronic charges "ch" and positions "pt"
!     n_pt = .dftgrid.n_pts*.n_atom
!     ch.create(n_pt); pt.create(n_pt,3)
!     wt.create(n_pt); rho.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(rho,pt)
!     ch = -rho*wt
!     rho.destroy; wt.destroy
!   ! stdout.set_real_style("e")
!   ! stdout.text("charges:")
!   ! stdout.put(ch)
!   ! stdout.text("pt:")
!   ! stdout.put(pt)
!     ! First get the atomic charges, which are assigned to balance the
!     ! electronic charge in case the DFT integration grid is poor.
!     deficit.create(.n_atom)
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        Z = ZERO
!        do i = f,l
!           Z = Z + ch(i)
!        end
!        deficit(n) = -Z
!     end
!     ! Now set the full "charges" and "positions" arrays, including the
!     ! (corrected) atomic charges, at the end of the list
!     l = 0
!     ll = 0
!     do n = 1,.n_atom
!        f  = l  + 1
!        l  = l  + n_pt
!        ff = ll + 1
!        ll = ll + n_pt
!        charges(f:l) = ch(ff:ll)
!        positions(:,f:l) = transpose(pt(ff:ll,:))
!        l = l + 1
!        charges(l) = deficit(n)
!        deficit(n) = .atom(n).atomic_number - deficit(n)
!        positions(:,l) = .atom(n).position
!     end
!     stdout.set_real_style("e")
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit)
!     stdout.show("sum of deficit charges =", VEC{REAL}:sum_elements(deficit))
!     stdout.show("sum of charges         =", VEC{REAL}:sum_elements(charges))
!     deficit.destroy
!   ! stdout.flush
!   ! stdout.text("Charges:")
!   ! stdout.flush
!   ! stdout.put(charges)
!   ! stdout.flush
!   ! stdout.text("Positions:")
!   ! stdout.flush
!   ! stdout.put(positions,"transpose")
!     stdout.set_real_style("f")
!     pt.destroy; ch.destroy
!   end

!   make_uc_effective_charges(charges,positions)
!   ! Make a list of effective point charges that accurately represents the total
!   ! charge of the unit cell.  Includes contributions from electrons and nuclei.
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.n_atom,"charges has wrong size")
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.allocated,"Need a list of atoms")
!   ENSURE(.saved.dftgrid.allocated,"no DFT grid")
!     ch,wt,rho,deficit :: VEC{REAL}@
!     pt :: MAT{REAL}@
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,n,i,f,l,ff,ll :: INT
!     ZZ,val :: REAL
!
!     pos,new_pos :: MAT{REAL}@
!     Z,n_ch,n_pt,n,f,l,s :: INT
!
!     stdout.text("making saved dft grid")
!     n_ch = .saved.dftgrid.n_pts
!     n_pt = .saved.dftgrid.n_pts
!     ch.create(n_pt)
!     pos.create(3,n_pt)
!     .saved.dftgrid.make_grid(pos,wt,.saved.atom)
!     ! Change fragment positions into fractionals
!     .crystal.unit_cell.change_into_fractional(pos)
!     new_pos.create(pos.dim1,pos.dim2)
!     ! Use symmetry to generate the effective charges and their positions in the
!     ! whole unit cell. This assumes that the fragment cell is generated from
!     ! the *whole* fragment by .crystal.Z symops.
!     l = 0
!     do n = 1,Z
!        f = l + 1
!        l = l + n_ch
!        .charges(f:l) = .fragment_charges
!        new_pos = pos
!        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*.crystal.n_fragment_atoms)
!        .crystal.transform_geometry(new_pos,op=s)
!        .crystal.put_to_unit_cell(new_pos)
!        .positions(:,f:l) = new_pos ! in cartesians
!     end
!     new_pos.destroy; pos.destroy
!
!     do n = 1,.n_atoms          ! Loop over atoms in whole cluster
!     do q = 1,.n_fragment_symop ! Loop over fragment symops
!        child = .geometry(:,n)  ! Get the image of the parent p under the fragment symop s
!        op = int(.fragment_symop(1,q))
!        tr = .fragment_symop(2:4,q)
!        .crystal.transform_position(child,op,tr)
!        if (NOT .geometry.has_column(child,col=c)) cycle
!        .fragment_parents_for_atom(c,q) = n
!     end
!     end
!
!     ! Make the effective electronic charges "ch" and positions "pt"
!     Z = .n_atom/.saved.n_atom
!     n_pt = .saved.dftgrid.n_pts*Z
!     stdout.show("n_pt =",n_pt)
!     ch.create(n_pt); pt.create(n_pt,3)
!     wt.create(n_pt); rho.create(n_pt)
!
!     stdout.text("made dft grid")
!     stdout.text("making density grid")
!     .make_density_grid(rho,pt)
!     stdout.text("made density grid")
!     ch = -rho*wt
!     rho.destroy; wt.destroy
!     stdout.set_real_style("e")
!     stdout.text("charges:")
!     stdout.put(ch)
!     stdout.text("pt:")
!     stdout.put(pt)
!     ! First get the atomic charges, which are assigned to balance the
!     ! electronic charge in case the DFT integration grid is poor.
!     deficit.create(.n_atom)
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        ZZ = ZERO
!        do i = f,l
!           ZZ = ZZ + ch(i)
!        end
!        deficit(n) = -ZZ
!     end
!     ! Now set the full "charges" and "positions" arrays, including the
!     ! (corrected) atomic charges, at the end of the list
!     l = 0
!     ll = 0
!     do n = 1,.n_atom
!        f  = l  + 1
!        l  = l  + n_pt
!        ff = ll + 1
!        ll = ll + n_pt
!        charges(f:l) = ch(ff:ll)
!        positions(:,f:l) = transpose(pt(ff:ll,:))
!        l = l + 1
!        charges(l) = deficit(n)
!        deficit(n) = .atom(n).atomic_number - deficit(n)
!        positions(:,l) = .atom(n).position
!     end
!     stdout.set_real_style("e")
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit)
!     stdout.show("sum of deficit charges =", VEC{REAL}:sum_elements(deficit))
!     stdout.show("sum of charges         =", VEC{REAL}:sum_elements(charges))
!     deficit.destroy
!   ! stdout.flush
!   ! stdout.text("Charges:")
!   ! stdout.flush
!   ! stdout.put(charges")
!   ! stdout.flush
!   ! stdout.text("Positions:")
!   ! stdout.flush
!   ! stdout.put(positions,"transpose")
!     stdout.set_real_style("f")
!     pt.destroy; ch.destroy
!   end

!   make_unit_cell_point_charges(charges,positions)
!   ! Make a list of point charges that accurately represents the total charge of
!   ! the unit cell.  Includes contributions from electrons and nuclei.
!   ! NOTE: this is normally called on a .saved fragment
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.allocated,"Need a list of atoms")
!   ENSURE(.dftgrid.allocated,"no DFT grid")
!   ENSURE(.crystal.allocated,"no crystal data")
!   ENSURE(.crystal.Z.is_int(TOL(3)), "must have an integer number of fragments in the unit cell")
!   ENSURE(.crystal.frag_atom_for_frag_cell_atom.allocated,"fragment cell map not created")
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.crystal.n_unit_cell_atoms,"charges has wrong size")
!     ch,wt,rho,deficit :: VEC{REAL}@
!     pos,pt,uc_pos :: MAT{REAL}@
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,Z,n,f,l,s :: INT
!     e_sum,n_sum :: REAL
!     ! Make the effective electronic charges for the fragment.
!     n_pt = .dftgrid.n_pts*.n_atom
!     deficit.create(.n_atom)
!     ch.create(n_pt); pos.create(3,n_pt)
!     wt.create(n_pt); pt.create(n_pt,3); rho.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(rho,pt)
!     ch = -rho*wt
!     pos = transpose(pt)
!     ! Work out the deficit charge for each atom, which is the charge that can
!     ! be ascribed to the dft integration grid point at the atomic nucleus. It
!     ! should normally be negative because near the nucleus the density should
!     ! be evaluated in the midpoint of the region but it is evaluated closer to
!     ! the nucleus and hence is larger than it should be (?). Thats my
!     ! explanation anyhow === dylan
!     Z = .crystal.Z
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        deficit(n) = .atom(n).atomic_number +  VEC{REAL}:sum_elements(ch(f:l))
!     end
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit)
!     stdout.show("sum of deficit charges =",  VEC{REAL}:sum_elements(deficit))
!     stdout.show("Z times sum of deficit =",Z*VEC{REAL}:sum_elements(deficit))
!     rho.destroy; pt.destroy; wt.destroy
!     ! When added to any fractional position, "shift" will convert that
!     ! position to be such that the center of the fragment molecule is at the
!     ! center of the unit cell.
!     shift = .center_of_atoms ! The fragment molecule center
!     .crystal.unit_cell.change_into_fractional(shift)
!     shift = [HALF,HALF,HALF] - shift
!     ! Use symmetry to generate the effective electronic charges and their
!     ! positions in the whole unit cell. This assumes that the fragment cell is
!     ! generated from the *whole* fragment by .crystal.Z symops.
!     .crystal.unit_cell.change_into_fractional(pos)
!     n_pt = .dftgrid.n_pts*.n_atom
!     l = 0
!     do n = 1,Z
!        f = l + 1
!        l = l + n_pt
!        charges(f:l) = ch
!        positions(:,f:l) = pos
!        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*Z)
!        .crystal.transform_geometry(positions(:,f:l),op=s)
!        ! Shift the positions so that they are relative to the fragment molecule
!        ! center before changing to the unit cell -- so the unit cell surrounds
!        ! the central fragment molecule.
!        positions(:,f:l) = positions(:,f:l) + spread(shift,dim=2,ncopies=n_pt)
!        .crystal.put_to_unit_cell(positions(:,f:l))
!        positions(:,f:l) = positions(:,f:l) - spread(shift,dim=2,ncopies=n_pt)
!        .crystal.unit_cell.change_from_fractional(positions(:,f:l))
!     end
!     pos.destroy; ch.destroy
!     ! Sum electron charges
!     n_pt = n_pt*Z
!     e_sum = VEC{REAL}:sum_elements(charges(1:n_pt))
!     stdout.show("sum of electrn charges =",e_sum)
!     ! Add the nuclear charges to the list. Don't forget to add the deficit
!     ! charges.
!     do n = 1,.crystal.n_unit_cell_atoms
!        f = .crystal.frag_atom_for_unit_cell_atom(n)
!        charges(n_pt+n) = .atom(f).atomic_number - deficit(f)
!        pos3 = .atom(f).position
!        .crystal.unit_cell.change_into_fractional(pos3)
!        pos3 = pos3 + shift
!        .crystal.put_to_unit_cell(pos3)
!        pos3 = pos3 - shift
!        .crystal.unit_cell.change_from_fractional(pos3)
!        positions(:,n_pt+n) = pos3
!     end
!     deficit.destroy
!     n_sum = VEC{REAL}:sum_elements(charges(n_pt+1:))
!     stdout.show("sum of nuclear charges =",n_sum)
!   end

!  ================================
!  Orbital update/cleaning routines
!  ================================

   Schmidt_orthonormalize_MOs
   ! Schmidt orthonormalize the ".MOs" and archive
      self :: INOUT

      .INTS:make_overlap_mx

      .:Schmidt_orthonormalize(.MOs)

   end

   Schmidt_orthonormalize(MO,scale)
   ! Schmidt orthonormalize the molecular orbitals, "MO"
      self  :: INOUT
      MO    :: OPMATRIX, INOUT
      scale :: REAL, optional, OUT

      .INTS:make_overlap_mx

      MO.Schmidt_orthonormalize(.overlap_mx,scale)

   end

   symmetrically_orthonormalize(MO)
   ! Symmetrically orthonormalize the molecular orbitals, "MO"
      self :: INOUT
      MO :: OPMATRIX, INOUT

      .INTS:make_overlap_mx

      MO.symmetrically_orthonormalize(.overlap_mx)

   end

   update_MOs
   ! Solve for the molecular orbitals. Requires a set of old
   ! molecular orbitals.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.MOs.allocated,"no old MO's")
   ENSURE(.MOs.has_any_genre,"no old MO's")

      .:MO_eigen_update
   
   end

   MO_eigen_update ::: private
   ! Solve for the molecular orbitals.  Requires a set of old
   ! molecular orbitals.  The new molecular orbitals "cU" are found
   ! from the old MOs "c" by solving :
   !    (c^T F c)U = c^T S c U E 
   ! where U is an orthogonal matrix, F fock matrix.
      self :: INOUT

   ENSURE(.MOs.allocated,"no old MO's")
   ENSURE(.MOs.has_any_genre,"no old MO's")

      scf_kind :: STR

      ! Update the MO's
      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("rhf     ", &
            "rks     ", &
            "rohf    ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")
         .:MO_r_eigen_update(.MO_energies.r,.MOs.r,.fock_mx.r)

      case ("uhf         ", &
            "uks         ", &
            "xray_uhf    ", &
            "xray_uks    ", &
            "pnd_uhf     ", &
            "pnd_uks     ", &
            "xray_pnd_uhf", &
            "xray_pnd_uks")
         .:MO_r_eigen_update(.MO_energies.a,.MOs.a,.fock_mx.a)
         .:MO_r_eigen_update(.MO_energies.b,.MOs.b,.fock_mx.b)

      case default
         DIE("unknown scf kind, "//scf_kind.trim)

      end

   end

   MO_r_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and
   ! the new molecular orbitals "MO", given an initial old set (in
   ! "MO") and a fock matrix "F".  The new molecular orbitals "MO*U"
   ! are found from the old MOs "MO" by solving : 
   !   (c^T F c)U = c^T S c U E  .. where U is an orthogonal matrix.
      self :: IN
      MO_energies :: VEC{REAL}, OUT
      MO :: MAT{REAL}, INOUT
      F :: MAT{REAL}, IN

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.overlap_mx.allocated,"no overlap_mx")
   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_eigenvalues")

      G,U :: MAT{REAL}@
      i :: INT

      ! Copy F -> G
      G.create(.n_bf,.n_bf)
      G = F

      ! Change F into old MO basis, G
      G.change_basis_using(MO)

      ! Level shift in old MO basis
      if (.scfdata.apply_level_shifting) then
         do i = .n_a + 1, .n_bf
            G(i,i) = .scfdata.level_shift + G(i,i)
         end
      end

      ! Get rotation U from old to new MO's
      U.create(.n_bf,.n_bf)
      G.solve_symmetric_eigenproblem(MO_energies,U)
    ! G.diagonalize_by_jacobi(MO_energies,U)

      ! Lock orbitals in place?
      if (.scfdata.using_orbital_locking) U.make_diagonally_dominant

      ! Update orbitals
      G.to_product_of(MO,U)

      ! Project linear dependence
    ! .left_project_dependence_r(G)

      ! Finished
      MO = G

      ! Clean up
      U.destroy
      G.destroy

   end

!   left_project_dependence_r(MO)
!   ! Left project the linear dependence from an "MO" like matrix
!   ! WARNING: this routine assumed overlap_eigenvalues are ordered
!   ! smallest to largest.
!      MO :: MAT{REAL}
!
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.overlap_mx.allocated,"no overlap_mx")
!   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
!   ENSURE(.overlap_eigenvalues.allocated,"no overlap_eigenvalues")
!   ENSURE(MO.is_square,"MO not square")
!   ENSURE(MO.dim1==.n_bf,"wrong size, MO")
!
!      P,W :: MAT{REAL}@
!      n,i :: INT
!      tol :: REAL
!
!      ! Return if all overlap matrix eigenvalues are big enough
!      tol = .scfdata.linear_dependence_tol
!      n   = .overlap_eigenvalues.index_of_first_greater_than(tol)
!      if (n==1) return
!
!      ! Set the projector
!      P.create(.n_bf,.n_bf)
!      P.to_unit_mx
!      do i = 1,n-1
!         P.plus_outer_product_of(.overlap_eigenvectors(:,i),-ONE)
!      end
!
!      ! Project it now
!      W.create(.n_bf,.n_bf)
!      W = MO
!      MO.to_product_of(P,W)
!
!      ! Clean up
!      W.destroy
!      P.destroy
!
!   end

   MO_g_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and the new
   ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
   ! matrix "F".
   ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by
   ! solving (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
      MO_energies :: VEC{REAL}
      MO,F :: MAT{REAL}

   DIE_IF(NOT F.is_symmetric,"F is not symmetric! WTF?!")

      G,U :: MAT{REAL}@
      i :: INT

      ! Change F into old MO basis --> G
      G.create(2*.n_bf,2*.n_bf)
      F.change_basis_to(G,MO)

      ! Level shift in old MO basis
      if (.scfdata.apply_level_shifting) then
         do i = .n_e + 1, 2*.n_bf
            G(i,i) = .scfdata.level_shift + G(i,i)
         end
      end

      ! Get rotation U from old to new MO's
      U.create(2*.n_bf,2*.n_bf)
      G.symmetrize
      G.diagonalize_by_jacobi(MO_energies,U)

      ! Lock orbitals in place, if requested
      if (.scfdata.using_orbital_locking) U.make_diagonally_dominant

      ! Update orbitals
      G.to_product_of(MO,U)
      MO = G

      ! Clean up
      U.destroy
      G.destroy

   end

   MO_gc_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and the new
   ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
   ! matrix "F".
   ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by
   ! solving (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
      MO_energies :: VEC{REAL}
      MO,F :: MAT{CPX}

   DIE_IF(NOT F.is_hermitian,"F is not hermitian! WTF?!")

      G,U :: MAT{CPX}@
      i :: INT

      ! Change F into old MO basis --> G
      G.create(2*.n_bf,2*.n_bf)
      F.change_basis_to(G,MO)

      ! Level shift in old MO basis
      if (.scfdata.apply_level_shifting) then
         do i = .n_e + 1, 2*.n_bf
            G(i,i) = .scfdata.level_shift + G(i,i)
         end
      end

      ! Get rotation U from old to new MO's
      U.create(2*.n_bf,2*.n_bf)
      G.make_hermitian
    ! G.solve_hermitian_eigenproblem(MO_energies,U)
      G.diagonalize_by_jacobi(MO_energies,U)

      ! Lock orbitals in place, if requested
      if (.scfdata.using_orbital_locking) U.make_diagonally_dominant

      ! Update orbitals
      G.to_product_of(MO,U)
      MO = G

      ! Clean up
      U.destroy
      G.destroy

   end

   MO_g_reorder(MO_energies,MO)
   ! Reorder the GC molecular orbitals so that the alpha orbitals come
   ! first, then the beta. This assumes that the alph and betra
   ! orbitals are nearly degenerate.
      MO_energies :: VEC{REAL}
      MO :: MAT{REAL}

      e :: VEC{REAL}@
      W :: MAT{REAL}@
      i,k :: INT

      e.create(2*.n_bf)
      W.create(2*.n_bf,2*.n_bf)

      k = 0
      do i = 1,2*.n_b-1,2
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      do i = 2,2*.n_b,2
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      do i = 2*.n_b+1,.n_e
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      do i = .n_e+1,2*.n_bf
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      MO_energies = e
      MO = W

      W.destroy
      e.destroy

   end

   MO_gc_reorder(MO_energies,MO)
   ! Reorder the GC molecular orbitals so that the alpha orbitals come
   ! first, then the beta. This assumes that the alph and betra
   ! orbitals are nearly degenerate.
      MO_energies :: VEC{REAL}
      MO :: MAT{CPX}

      e :: VEC{REAL}@
      W :: MAT{CPX}@
      i,k :: INT

      e.create(2*.n_bf)
      W.create(2*.n_bf,2*.n_bf)

      k = 0
      do i = 1,2*.n_b-1,2
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      do i = 2,2*.n_b,2
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      do i = 2*.n_b+1,.n_e
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      do i = .n_e+1,2*.n_bf
         k = k + 1
         e(k)   = MO_energies(i)
         W(:,k) = MO(:,i)
      end

      MO_energies = e
      MO = W

      W.destroy
      e.destroy

   end

!  ==========================
!  Energy evaluation routines
!  ==========================

   put_SCF_energy
   ! Output the scf energy.
      self :: IN

      stdout.show("The SCF energy is ",              .:SCF_energy)
      stdout.show("The kinetic energy is ",          .:kinetic_energy)
      if (.scfdata.is_DFT_calculation) &
      stdout.show("The Kohn-Sham DFT XC energy is ", .scfdata.DFT_energy_correction)

   end

   kinetic_energy result (res) ::: PURE
   ! Evaluates the SCF kinetic energy as a trace of ".density_mx"
   ! with the ".kinetic matrix".
      self :: IN
      res :: REAL

   ENSURE(.scfdata.allocated,           "no scfdata")
   ENSURE(.density_mx.allocated,    "no density matrix")
   ENSURE(.density_mx.has_any_genre,"no density matrix")

      HH :: MAT{CPX}@
      H  :: MAT{REAL}@
      scf_kind :: STR

      res = ZERO

      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("rhf     ", &
            "rks     ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")

         H.create(.n_bf,.n_bf)
         .INTS:make_kinetic_energy_mx(H)
         res = .density_mx.r.trace_product_with(H)
         H.destroy

      case ("uhf         ", &
            "uks         ", &
            "xray_uhf    ", &
            "xray_uks    ", &
            "rohf        ", &
            "pnd_uhf     ", &
            "pnd_uks     ", &
            "xray_pnd_uhf", &
            "xray_pnd_uks")

         H.create(.n_bf,.n_bf)
         .INTS:make_kinetic_energy_mx(H)
         res = .density_mx.a.trace_product_with(H)
         res = .density_mx.b.trace_product_with(H) + res
         H.destroy

      case ("gchf","xray_gchf")

         HH.create(2*.n_bf,2*.n_bf)
         H.create(.n_bf,.n_bf)
         .INTS:make_kinetic_energy_mx(H)
         HH = ZERO
         HH.set_aa_block_to(H)
         HH.set_bb_block_to(H)
         res = RE(.density_mx.gc.trace_product_with(HH))
         H.destroy
         HH.destroy

    ! case default
    !    DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   nuclear_attraction_energy result (res) ::: PURE
   ! Evaluates the SCF electron-nuclear attraction energy as a trace
   ! of ".density_mx"
      self :: IN
      res :: REAL

   ENSURE(.scfdata.allocated,           "no scfdata")
   ENSURE(.density_mx.allocated,    "no density matrix")
   ENSURE(.density_mx.has_any_genre,"no density matrix")
   ENSURE(.nuclear_attraction_mx.allocated,"no nuclear_attraction_mx")

      HH :: MAT{CPX}@
      H  :: MAT{REAL}@
      scf_kind :: STR

      res = ZERO

      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("rhf     ", &
            "rks     ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")

         H.create(.n_bf,.n_bf)
         .INTS:make_nuclear_attraction_mx(H)
         res = .density_mx.r.trace_product_with(H)
         H.destroy

      case ("uhf         ", &
            "uks         ", &
            "xray_uhf    ", &
            "xray_uks    ", &
            "rohf        ", &
            "pnd_uhf     ", &
            "pnd_uks     ", &
            "xray_pnd_uhf", &
            "xray_pnd_uks")

         H.create(.n_bf,.n_bf)
         .INTS:make_nuclear_attraction_mx(H)
         res = .density_mx.a.trace_product_with(H)
         res =  .density_mx.b.trace_product_with(H) + res

         H.destroy

      case ("gchf","xray_gchf")

         HH.create(2*.n_bf,2*.n_bf)
         H.create(.n_bf,.n_bf)
         .INTS:make_nuclear_attraction_mx(H)
         HH = ZERO
         HH.set_aa_block_to(H)
         HH.set_bb_block_to(H)
         res = RE(.density_mx.gc.trace_product_with(HH))
         H.destroy
         HH.destroy

    ! case default
    !    DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   charge_attraction_energy result (res) ::: PURE
   ! Evaluates the point-charge attraction energy as a trace of
   ! ".density_mx" with the ".kinetic matrix".
      self :: IN
      res :: REAL

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.has_any_genre,"no density matrix")
   ENSURE(.core_mx.allocated,"no core matrix")

      HH  :: MAT{CPX}@
      H,T :: MAT{REAL}@
      scf_kind :: STR

      res = ZERO

      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("rhf     ", &
            "rks     ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")

         H.create(.n_bf,.n_bf)
         T.create(.n_bf,.n_bf)

         .INTS:make_nuclear_attraction_mx(H)
         .INTS:make_kinetic_energy_mx(T)

         H   = .core_mx.r - H - T
         res = .density_mx.r.trace_product_with(H)

         T.destroy
         H.destroy

      case ("uhf         ", &
            "uks         ", &
            "xray_uhf    ", &
            "xray_uks    ", &
            "rohf        ", &
            "pnd_uhf     ", &
            "pnd_uks     ", &
            "xray_pnd_uhf", &
            "xray_pnd_uks")

         H.create(.n_bf,.n_bf)
         T.create(.n_bf,.n_bf)
         .INTS:make_kinetic_energy_mx(T)
         .INTS:make_nuclear_attraction_mx(H)
         H   = .core_mx.a - H - T
         res = .density_mx.a.trace_product_with(H)
         res =  .density_mx.b.trace_product_with(H) + res
         T.destroy
         H.destroy

      case ("gchf","xray_gchf")

         HH.create(2*.n_bf,2*.n_bf)
         H.create(.n_bf,.n_bf)
         T.create(.n_bf,.n_bf)
         .INTS:make_kinetic_energy_mx(T)
         .INTS:make_nuclear_attraction_mx(H)
         HH = ZERO
         H  = H + T
         HH.set_aa_block_to(H)
         HH.set_bb_block_to(H)
         HH = .core_mx.gc - HH
         res = RE(.density_mx.gc.trace_product_with(HH))
         T.destroy
         H.destroy
         HH.destroy

    ! case default
    !    DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   SCF_energy result (res)
   ! Evaluates the total SCF energy (including nuclear) as a trace of
   ! ".density_mx" with the ".fock matrix".
      self :: IN
      res :: REAL

   ENSURE(.density_mx.allocated,    "no density matrix")
   ENSURE(.density_mx.has_any_genre,"no density matrix")
   ENSURE(.fock_mx.allocated,    "no fock matrix")
   ENSURE(.fock_mx.has_any_genre,"no fock matrix")

      res = .:SCF_energy(.density_mx,.fock_mx) ! NOT PURE

   end

   SCF_energy(P,F) result (res)
   ! Evaluates the total SCF energy (including nuclear) as a trace of
   ! "P" with the fock matrix "F".
      self :: IN
      P,F :: OPMATRIX, IN
      res :: REAL

   ENSURE(.scfdata.allocated, "no scf data")
   ENSURE(.atom.allocated, "no atoms")

      g,a :: INT
      I0 :: VEC{REAL}@
      I1 :: MAT{REAL}@
      mu :: VEC{REAL}(3)

      res = ZERO

      ! Electronic + nuclear energy
      select case  (.scfdata.SCF_kind)

      case ("noninteracting-group-rhf")
         res = .SCF:SCF_electronic_energy(P,F)
         do g = 1,.atom_group.dim
            res = res + .atom(.atom_group(g).atom_index).nuclear_repulsion_energy
         end

      case default
         res = .SCF:SCF_electronic_energy(P,F) &
             + .INQ:nuclear_repulsion_energy

      end

      ! Add finite field
      if (NOT .E_field.is_zero) then
         mu  = .atom.nuclear_dipole_moment
         res = res - .E_field.dot(mu)
      end

      ! Add finite local Lorentz fields
      ! Only dipole contributions are done
      ! The charge-charge terms are missing
      if (.scfdata.using_SC_Lorentz_fields) then
         I0.create(.n_atom)
         I1.create(3,.n_atom)
         .:make_Lorentz_interactions(I0,I1)
         do a = 1,.n_atom
            res = res - .atom(a).charge*I0(a)
            res = res - I1(:,a).dot(.atom(a).dipole)
         end
         I1.destroy
         I0.destroy
      end

   end

   SCF_electronic_energy(P,core) result (res) ::: PURE
   ! Evaluates the SCF electronic energy as a trace of density "P"
   ! with ".fock_mx". If "core" is present and FALSE, the core
   ! contribution is not added.
      self :: IN
      P    :: OPMATRIX, IN
      core :: BIN, optional, IN 
      res :: REAL

   ENSURE(.fock_mx.allocated,    "no fock matrix")
   ENSURE(.fock_mx.has_any_genre,"no fock matrix")

      res = .:SCF_electronic_energy(P,.fock_mx,core)

   end

   SCF_electronic_energy(P,F,core) result (res) ::: PURE
   ! Evaluates the SCF electronic energy as a trace of density "P"
   ! with fock matrix "F". If "core" is present and FALSE, the core
   ! contribution is not added.  NOTE: this includes the DFT
   ! electronic energies, and it assumes that these energy
   ! contributions were calculated at the time of the formation of "F"
   ! from "P", and that they were stored in .scfdata.
      self :: IN
      P, F :: OPMATRIX, IN
      core :: BIN, optional, IN
      res  :: REAL

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.core_mx.allocated,"core_mx missing")
   ENSURE(.core_mx.has_genre(.scfdata.spinorbital_genre),"core_mx missing")

      add_core :: BIN
      W :: OPMATRIX@

      add_core = TRUE
      if (present(core)) add_core = core

      ! W = F + h
      W = F
      if (add_core) W.plus(.core_mx,.scfdata.spinorbital_genre)

      res = ZERO

      select case (.scfdata.SCF_kind)

      case ("rhf","xray_rhf","noninteracting-group-rhf")
         res = HALF * P.r.trace_product_with(W.r)

      case ("rks","xray_rks")
         res = HALF * P.r.trace_product_with(W.r) &
             + .scfdata.DFT_energy_correction

      case ("uhf","xray_uhf","rohf","pnd_uhf","xray_pnd_uhf")
         res = HALF * P.a.trace_product_with(W.a) &
             + HALF *  P.b.trace_product_with(W.b)

      case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
         res = HALF * P.a.trace_product_with(W.a) &
             + HALF *  P.b.trace_product_with(W.b) &
             + .scfdata.DFT_alpha_energy_correction &
             + .scfdata.DFT_beta_energy_correction

      case ("gchf","xray_gchf")
         res = HALF * RE(P.gc.trace_product_with(W.gc))

    ! case default
    !    DIE("unknown scf kind, "//trim(.scfdata.SCF_kind))

      end

      ! Clean
      W.destroy

   end

   SCF_electronic_energies result (res) ::: PURE
   ! Evaluates the SCF electronic energies as a trace of density "P" with
   ! fock matrix "F". In the case of UHF the energies are the E^alpha and E^beta
   ! energies. NOTE: this includes the DFT energy contributions.
      self :: IN
      res :: VEC{REAL}@
      res = .:SCF_electronic_energies(.density_mx,.fock_mx)
   end

   SCF_electronic_energies(P,F) result (res) ::: PURE
   ! Evaluates the SCF electronic energies as a trace of density "P" with
   ! fock matrix "F". In the case of UHF the energies are the E^alpha and E^beta
   ! energies. NOTE: this includes the DFT electronic energies, and it assumes
   ! that these energy contributions were calculated at the time of the
   ! formation of "F" from "P", and that they were stored in .scfdata.
      self :: IN
      P,F  :: OPMATRIX, IN
      res  :: VEC{REAL}@

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.core_mx.allocated,"no core_mx")

      W :: OPMATRIX@

      W = F

      select case (.scfdata.SCF_kind)

      case ("rhf","xray_rhf","noninteracting-group-rhf")
         res.create(1)
         W.plus(.core_mx)
         res(1) = HALF * P.r.trace_product_with(W.r)

      case ("rks","xray_rks")
         res.create(1)
         W.plus(.core_mx)
         res(1) = HALF * P.r.trace_product_with(W.r) &
                + .scfdata.DFT_energy_correction

      case ("uhf","xray_uhf","rohf","pnd_uhf","xray_pnd_uhf")
         res.create(2)
         W.plus(.core_mx)
         res(1) = HALF * P.a.trace_product_with(W.a)
         res(2) = HALF *  P.b.trace_product_with(W.b)

      case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
         res.create(2)
         W.plus(.core_mx)
         res(1) = HALF * P.a.trace_product_with(W.a) + .scfdata.DFT_alpha_energy_correction
         res(2) = HALF *  P.b.trace_product_with(W.b)   + .scfdata.DFT_beta_energy_correction

      case ("gchf","xray_gchf")
         res.create(1)
         W.plus(.core_mx)
         res(1) = HALF * RE(P.gc.trace_product_with(W.gc))

    ! case default
    !    DIE("unknown or unimplemented scf kind, "//trim(.scfdata.SCF_kind))

      end

      ! Clean
      W.destroy

   end

!  ==============================
!  Initial orbital guess routines
!  ==============================

   get_initial_guess ::: leaky
   ! Get the initial guess for the ".density_mx" and the
   ! ".MOs". If .scfdata.initial_MOs is set, it
   ! overides .initial_density.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      select case(.scfdata.initial_MOs)
      case("--using density--"); .:make_initial_density
      case default;              .:read_initial_MOs
      end

   end

   read_initial_MOs ::: leaky
   ! Get the initial guess for the .MOs
   ! Convert the .MOs, if neccesary.
      self :: INOUT
      select case (.scfdata.initial_MOs)
      case("r              "); .:read_old_MOs_guess
      case("restricted     "); .:read_old_MOs_guess
      case("u              "); .:read_old_MOs_guess
      case("unrestricted   "); .:read_old_MOs_guess
      case("gc             "); .:read_old_MOs_guess
      case("general_complex"); .:read_old_MOs_guess
      case default; UNKNOWN(.scfdata.initial_MOs)
      end
   end

   read_old_MOs_guess ::: leaky
   ! Get the initial guess for the .MOs by reading an
   ! old archive of .MOs, converting the MO's if
   ! necessary, and then making the SCF density matrix as well.
      self :: INOUT

      arch :: ARCHIVE

      ! Recreate MO's
      .MOs.destroy
      .MOs.create(.n_bf,.scfdata.initial_MOs)

      ! Recreate energies
      .MO_energies.destroy
      .MO_energies.create(.n_bf,genre=.scfdata.MO_energies_genre)

      ! Read
      arch.set(.name,"MOs",genre=.scfdata.initial_MOs)
      arch.read(.MOs)

      ! Convert (if necessary)
      .MOs.convert_to(.scfdata.MOs_genre,.n_a,.n_b,.scfdata.quantization_axis)
      ! Re-orthonormalize ?
    ! if (.scfdata.allocated) then
    ! if (.scfdata.initial_MOs=="r ") then
    ! .symorthonormalize_occupied_MOs
    ! end
    ! end

      ! Make the density matrix
      .BASE:make_SCF_density_mx

   end

   make_atom_MOs_guess ::: leaky
   ! Get the initial guess for the .MOs by getting the highest
   ! occupied restricted natural orbitals from the sum of atomic densities guess
   ! for the density matrix. Convert these .MOs, if neccesary.
   ! Also make the SCF .density_mx from these .MOs.
      self :: INOUT

      MOs_genre :: STR
      arch :: ARCHIVE

      ! Make promolecule density
      .:make_promolecule_density_mx

      ! What is this?
      if (.density_mx.genre/="r ") then
         arch.set(.name,"promolecule_density_mx", genre="r ")
         .density_mx.destroy("r ")
         arch.read(.density_mx)
      end

      .BASE:make_NOs
      .PUT:put_NOs
      .BASE:assign_MOs_to_NOs

      ! Convert MO's if needed
      MOs_genre = .scfdata.MOs_genre
      .MOs.convert_to(MOs_genre,.n_a,.n_b,.scfdata.quantization_axis)

      ! Recreate orbital energies
      .MO_energies.destroy
      .MO_energies.create(genre=.scfdata.MO_energies_genre)

      ! Make density matrix
      .BASE:make_SCF_density_mx


   end

   make_initial_density ::: leaky
   ! Get the initial guess for the ".density_mx"
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      .scfdata.set_is_guess(TRUE)

      select case (.scfdata.initial_density)
      case("core           "); .:make_core_mx_guess_MOs
      case("fock           "); .:make_Fock_mx_guess_MOs
      case("group          "); .:make_atom_group_guess_MOs
      case("promolecule    "); .:make_promol_guess_MOs
      ! Different types of saved .density_mx
      case("r              "); .:read_density_guess
      case("restricted     "); .:read_density_guess
      case("u              "); .:read_density_guess
      case("unrestricted   "); .:read_density_guess
      case("gc             "); .:read_density_guess
      case("general_complex"); .:read_density_guess
      case default;  DIE("unknown density, "//trim(.scfdata.initial_density))
      end

      .scfdata.set_is_guess(FALSE)

   end

   read_density_guess ::: leaky
   ! Read an old .density_mx of type "initial_guess" and use it to
   ! make initial .MOs to start an scf calculation.
   ! Convert the .density_mx, if neccesary.
      self :: INOUT

      genre :: STR
      arch :: ARCHIVE

      genre = .scfdata.initial_density_genre

      ! Create
      .density_mx.destroy
      .density_mx.create(.n_bf,genre)

      ! Read
      arch.set(.name,"density_mx")
      arch.read(.density_mx,genre=genre)

      ! Convert
      .density_mx.convert_to(.scfdata.spinorbital_genre)

      ! Make a fock matrix & starting MO's
      .:make_Fock_mx
      .:make_Fock_mx_guess_MOs

   end

   make_core_mx_guess_MOs ::: leaky
   ! Do a core scf for the ".density_mx", ".MOs" and
   ! ".MO_energies". Also makes the restricted ".core_mx".
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      MOs_genre :: STR

      ! Recreate and initialize (leaky)
      .MO_energies.destroy
      .MO_energies.create(.n_bf,"r ")

      .MOs.destroy
      .MOs.create(.n_bf,"r ")

      ! Get restricted core and overlap matrices (leaky)
      .:make_r_core_mx
      .INTS:make_overlap_mx

      ! Get the guess orbitals
      .:diagonalize_r_mx(.core_mx.r, &
                           .MO_energies.r, &
                           .MOs.r)

      ! Convert the orbitals to the right kind (leaky)
      MOs_genre = .scfdata.MO_energies_genre
      .MO_energies.convert_to(MOs_genre)
      MOs_genre = .scfdata.MOs_genre
      .MOs.convert_to(MOs_genre,.n_a,.n_b,.scfdata.quantization_axis)

      ! Make the densityy matrix
      .BASE:make_SCF_density_mx

      ! Get a reasonable set of starting MO's
      .:make_Fock_mx
      .:make_Fock_mx_guess_MOs

   end

   make_promol_guess_MOs ::: leaky
   ! Make a ".density matrix" and fock matrix from the sum of atomic
   ! densities.  Then get initial orbitals from this fock matrix, and
   ! make the density corresponding to these initial orbitals.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      ! Get initial MO's
      if (.scfdata.SCF_kind=="rohf") then; .:make_promolecule_guess_rohf
      else;                                .:make_promolecule_density_mx
      end

      ! Get a starting fock matrix from this density
      .:make_Fock_mx

      ! Make the MO's 
      .:make_Fock_mx_guess_MOs

   end

   make_promolecule_guess_rohf ::: leaky
   ! Make a forced *restricted* ".density matrix" and fock matrix from
   ! the sum of atomic densities.  Then get initial restricted
   ! orbitals from this fock matrix. This is neccessary for ROHF
   ! initial guesses.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.scfdata.SCF_kind=="rohf","not an ROHF calculation")

      charge,mult :: INT

      ! Store original charge & multiplicity
      charge = .charge
      mult   = .spin_multiplicity

      ! Reset to closed shell +1 charge
      ! (-1 charge may not converge).
      if (.n_e.is_odd) .charge = .charge + 1
      .spin_multiplicity = 1

      ! Set to RHF
      .scfdata.set_SCF_kind("rhf")
    ! .SET:set_atom_info

      ! Make promolecule density
      .:make_promolecule_density_mx

      ! Get a starting MO's from this density
      .:make_Fock_mx
      .:make_Fock_mx_guess_MOs

      ! Change back to original state
      .charge            = charge
      .spin_multiplicity = mult

      ! And back to ROHF
      .scfdata.set_SCF_kind("rohf")
    ! .SET:set_atom_info

      ! Make (uhf) density matrix from (rhf) MO's
      .BASE:make_SCF_density_mx

   end

   make_promolecule_density_mx ::: leaky
   ! Make the ANO densities and add them together.
      self :: INOUT

      ! ANO's
      .:make_ANO_data

      ! Add spherical atomic densities
      .:add_ANO_densities

      ! Convert
      .density_mx.convert_to(.scfdata.spinorbital_genre,factor=HALF)

      ! Save this
      .PUT:put_archive(.density_mx,"density_mx")

   end

   add_ANO_densities ::: leaky
   ! Add the ANO densities to make the total density matrix
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.INQ:has_all_ANO_matrices,"no ANOs")

      a,b,f,l :: INT

      ! Recreate the density
      .density_mx.destroy
      .density_mx.create(.n_bf,"r ")

      ! Set to zero
      .density_mx.r = ZERO

      ! Add 'em up
      do a = 1,.n_atom

         ! Transfer non-unique atoms
         do b = 1,.n_atom

            if (NOT .atom(b).is_same_kind_as(.atom(a))) cycle

            f = .first_basis_fn_for_atom(b)
            l =  .last_basis_fn_for_atom(b)
            .density_mx.r(f:l,f:l) = .atom(a).density_mx.r

         end

      end

      ! Symmetrize
      .density_mx.r.symmetric_reflect

   end

   make_atom_group_guess_MOs ::: leaky
   ! Make a .density matrix and .fock_mx from the sum of noninteracting
   ! atom_group densities. Then get initial orbitals from this fock matrix,
   ! and make the density corresponding to these initial orbitals.
      self :: INOUT

   ENSURE(.scfdata.SCF_kind/="rohf","atom guess not available for ROHF")

      ! Sum of group densities
      .:atom_group_SCF

      ! Get a reasonable set of starting MO's
      .:make_Fock_mx
      .:make_Fock_mx_guess_MOs

   end

   make_group_energies(g,E_SCF,E_T,E_Z,E_C,E_K,fac)
   ! Assuming group densities exist (see .do_atom_group_SCF), then
   ! for group number "g" make the group SCF energy "E_SCF", the group
   ! kinetic energy "E_T", the group nuclear attraction energy "E_Z",
   ! the group coulomb energy "E_C", and the group exchange energy
   ! "E_K". If "fac" is present, multiply all the energy values by
   ! this factor.
      self :: target, INOUT
      g :: INT, IN
      E_SCF,E_T,E_Z,E_C,E_K :: REAL, OUT
      fac :: REAL, optional, IN

   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(g<=.atom_group.dim,"group out of range")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")
   ENSURE(.mol(g).scfdata.allocated,"no atom_group molecule scfdata")
   ENSURE(.mol(g).spin_multiplicity==1,"only singlets allowed for now")

      C, K :: MAT{REAL}@
      n_bf :: INT

      E_SCF = ZERO
      E_T = ZERO
      E_Z = ZERO
      E_C = ZERO
      E_K = ZERO

      if (.mol(g).INQ:no_of_electrons >= 1) then

         ! Get the SCF energy
         E_SCF = .mol(g).scfdata.energy

         ! Get the kinetic energy
         E_T = .mol(g).scfdata.kinetic_energy

         ! Get the nuclear attraction energy
         E_Z = .mol(g).scfdata.nuclear_attraction_energy

         ! Coulomb/exchange matrices
         n_bf = .mol(g).n_bf
         C.create(n_bf,n_bf)
         K.create(n_bf,n_bf)
         .mol(g).FOCK:make_r_JK_nosym(C,K,.mol(g).density_mx.r)

         ! Coulomb & exchange energies
         E_C = HALF*C.trace_product_with(.mol(g).density_mx.r)
         E_K = -QUARTER*K.trace_product_with(.mol(g).density_mx.r)
         K.destroy
         C.destroy

         ! Clean up disk
         .mol(g).SET:delete_SCF_archives

      end

      if (present(fac)) then
         E_SCF = fac*E_SCF
         E_T   = fac*E_T
         E_Z   = fac*E_Z
         E_C   = fac*E_C
         E_K   = fac*E_K
      end

   end

   make_Fock_mx_guess_MOs ::: leaky
   ! From an initial .fock_mx make the .MOs, and
   ! .MO_energies.  Then make the .density_mx from these
   ! orbitals.  Destroy .fock_mx afterwards
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.fock_mx.allocated,"need an initial fock matrix")
   ENSURE(.fock_mx.has_genre(.scfdata.spinorbital_genre),"need right kind of initial fock matrix")

      MOs_genre :: STR

      ! Clean
      .MOs.destroy
      .MO_energies.destroy

      ! Get core and overlap
      .INTS:make_overlap_mx

      ! MO/Fock matrix genre
      MOs_genre = .scfdata.MOs_genre

      ! Build the Fock matrix
      select case (MOs_genre)

      case ("r ")
         ! Restricted MO's
         .MO_energies.create(.n_bf,"r ")
         .MOs.create(.n_bf,"r ")
         .:make_r_guess_from(.fock_mx.r,.MO_energies.r,.MOs.r)

      case ("u ")
         .MO_energies.create(.n_bf,"u ")
         .MOs.create(.n_bf,"u ")
         .:make_r_guess_from(.fock_mx.a,.MO_energies.a,.MOs.a)
         .:make_r_guess_from(.fock_mx.b,.MO_energies.b,.MOs.b)

      case ("gc")
         .MO_energies.create(.n_bf,"g ")
         .MOs.create(.n_bf,"gc")
         .:make_gc_Fock_guess(.MO_energies.g,.MOs.gc,.fock_mx.gc)

      case default
         DIE("unknown MO kind, "//trim(MOs_genre))

      end

      ! Delete Fock matrix used to make MO's
    ! .fock_mx.destroy(MOs_genre)

      ! Make the (spinorbital_genre) density matrix
      .BASE:make_SCF_density_mx

   end

   make_gc_Fock_guess(MO_energies,MO,fock_mx)
   ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
   ! a given complex general "fock_mx".
      self :: INOUT
      MO_energies :: VEC{REAL}, OUT
      MO :: MAT{CPX}, OUT
      fock_mx :: MAT{CPX}, IN

   DIE_IF(NOT fock_mx.is_hermitian,"fock_mx not hermitian!  WTF?!")
   ENSURE(.overlap_mx.allocated,"no overlap matrix")

      S,R :: MAT{REAL}@
      H   :: MAT{CPX}@

      R.create(2*.n_bf,2*.n_bf)
      S.create(.n_bf,.n_bf)

      ! S = S^-1/2, R = big inverse S
      .INTS:make_r_overlap_inverse_sqrt(S)

      ! R = big inverse S
      R = ZERO
      R.set_aa_block_to(S)
      R.set_bb_block_to(S)
      S.destroy

      ! H = Fock matrix
      H.create(2*.n_bf,2*.n_bf)
      H = fock_mx

      ! H = S^-1/2 F S^-1/2
      H.change_basis_using(R)

      H.diagonalize_by_jacobi(MO_energies,MO)

      !  c  = S^-1/2 c~
      H.to_product_of(R,MO)
      MO = H

      ! Clean
      H.destroy
      R.destroy

   end

   make_r_guess_from(fock_mx,MO_energies,MO) ::: private
   ! Make initial "MO's" and "MO_energies" from a given "fock_mx"
   ! ... for cartesian basis functions
      self :: INOUT
      fock_mx :: MAT{REAL}, IN
      MO      :: MAT{REAL}, OUT
      MO_energies :: VEC{REAL}, OUT

   ENSURE(fock_mx.is_symmetric,"fock_mx not symmetric!  WTF?!")

      F,R :: MAT{REAL}@

      F.create(.n_bf,.n_bf)
      R.create(.n_bf,.n_bf)

      !  Get S^{-1/2 }
      .INTS:make_r_overlap_inverse_sqrt(R) ! INOUT

      !  H~ = S^-1/2 H S^-1/2
      fock_mx.change_basis_to(F,R)

      ! Remove linear dependence
      if (.scfdata.allocated) .BASE:shift_dependence_from_r(F)

      !  Solve for c~
      F.solve_symmetric_eigenproblem(MO_energies,MO)

      ! Back transform: c = S^{-1/2} c~
      F.to_product_of(R,MO)
      MO = F

      ! Clean
      R.destroy
      F.destroy

   end


   diagonalize_r_mx(H,eigenvalues,eigenvectors) ::: private
   ! Diagonalize a restricted one-electron AO operator matrix "H",
   ! return the "eigenvalues" and "eigenvector" coefficients.
      self :: INOUT
      H :: MAT{REAL}, IN
      eigenvalues  :: VEC{REAL}, OUT
      eigenvectors :: MAT{REAL}, OUT

   ENSURE(H.is_symmetric,"H not symmetric!  WTF?!")

      F,R :: MAT{REAL}@

      F.create(.n_bf,.n_bf)
      R.create(.n_bf,.n_bf)

      !  Get S^{-1/2 }
      .INTS:make_r_overlap_inverse_sqrt(R)

      !  H~ = S^-1/2 H S^-1/2
      H.change_basis_to(F,R)

      ! Remove linear dependence
      if (.scfdata.allocated) .BASE:shift_dependence_from_r(F)

      !  Solve for cO~
      F.solve_symmetric_eigenproblem(eigenvalues,eigenvectors)

      ! Back transform: c = S^{-1/2} c~
      F.to_product_of(R,eigenvectors)
      eigenvectors = F

      ! Clean
      R.destroy
      F.destroy

   end

   diagonalize_gen_mx(H,eigenvalues,eigenvectors) ::: template
   ! Diagonalize a general (complex) one-electron AO operator matrix
   ! "H", return the "eigenvalues" and "eigenvector" coefficients wrt
   ! the basis.
      self :: INOUT
      H :: TYPE?, IN
      eigenvalues :: VEC{REAL}, OUT
      eigenvectors :: TYPE?, OUT

 ! DIE_IF(NOT H.is_hermitian,"fock_mx not hermitian!  WTF?!")

      S,R :: MAT{REAL}@
      F   :: TYPE?@

      R.create(2*.n_bf,2*.n_bf)
      S.create(.n_bf,.n_bf)

      ! S = S^-1/2, R = big inverse S
      .INTS:make_r_overlap_inverse_sqrt(S)

      ! R = big inverse S
      R = ZERO
      R.set_aa_block_to(S)
      R.set_bb_block_to(S)
      S.destroy

      ! H = Fock matrix
      F.create(2*.n_bf,2*.n_bf)
      F = H

      ! H = S^-1/2 F S^-1/2
      F.change_basis_using(R)

      F.diagonalize_by_jacobi(eigenvalues,eigenvectors)

      !  c  = S^-1/2 c~
      F.to_product_of(R,eigenvectors)
      eigenvectors = F

      ! Clean
      F.destroy
      R.destroy

   end

   diagonalize_g_mx(H,eigenvalues,eigenvectors) ::: get_from(diagonalize_gen_mx, TYPE?=>MAT{REAL})
   ! Diagonalize a general (complex) one-electron AO operator matrix
   ! "H", return the "eigenvalues" and "eigenvector" coefficients wrt
   ! the basis.
   end

   diagonalize_gc_mx(H,eigenvalues,eigenvectors) ::: get_from(diagonalize_gen_mx, TYPE?=>MAT{CPX})
   ! Diagonalize a general (complex) one-electron AO operator matrix
   ! "H", return the "eigenvalues" and "eigenvector" coefficients wrt
   ! the basis.
   end

!  =============
!  Group density
!  =============

   make_atom_group_density_mx ::: leaky
   ! Make the promolecule density matrix from *symmetrically
   ! orthonormalized* group (monomer) molecular orbitals. Do not
   ! confuse this with the progroup density matrix, made with
   ! .make_progroup_density_mx. The symmetrically orthonormalized
   ! molecular orbitals are made and are ordered by group.  This will
   ! destroy any existing restricted density matrix and MOs.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")

      .:do_atom_group_SCF(MOs=TRUE)     ! leaky
      .:symorthonormalize_occupied_MOs  ! leaky

      ! Assign the NO's (occupations must exist!)
      .NOs = .MOs

      ! Make density from NO's
      .BASE:make_density_mx_from_NOs

      ! Clean
      .NOs.destroy

   end

   symorthonormalize_occupied_MOs ::: leaky
   ! Symmetrically orthonormalize the occupied MO's. The occupied
   ! orbitals are defined by the .NO_occ_nos vector. The
   ! virtual orbitals are schmidt orthonormalized to the occupied MOs.
   ! Only works for restricted at the moment.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no rhf MO's")

      occ,vir,all :: VEC{INT}@
      MO :: MAT{REAL}@
      i,no,nv :: INT

      ! Hoe many occupied and virtual?
      no = count(.NO_occ_nos.r >0.1)
      nv = count(.NO_occ_nos.r<=0.1)
      ENSURE((no+nv)==.n_bf,"error determining no and nv")

      ! Banner
      stdout.flush
      stdout.text("Symorthnormalising occupied MO's")
      stdout.flush
      stdout.text("The occupied orbitals are defined by the current ")
      stdout.text("occupation numbers. Virtual orbitals are Schmidt-")
      stdout.text("orthonormalized to the occupied MO's. Virtual orbitals")
      stdout.text("are Schmidt-orthonormalized to the occupied MO's.")
      stdout.flush
      stdout.show("No. of occupied MO's =",no)
      stdout.show("No. of virtual  MO's =",nv)

      ! Get indices of occ & virtuals
      occ.create(no)
      vir.create(nv)
      i = 0
      occ = pack([(i,i=1,.n_bf)],.NO_occ_nos.r> 0.1)
      vir = pack([(i,i=1,.n_bf)],.NO_occ_nos.r<=0.1)

      ! Make sure overlap exists
      .INTS:make_overlap_mx

      ! Symmetric orthonormalize the occupied MO's
      MO.create(.n_bf,no)
      MO = .MOs.r(:,occ)
      MO.symmetrically_orthonormalize(.overlap_mx)
      .MOs.r(:,occ) = MO
      MO.destroy

      ! Schmidt orthonormalize the virtuals to the occupieda
      all = [occ, vir]
      MO.create(.n_bf,.n_bf)
      MO = .MOs.r(:,all)
      MO.Schmidt_orthonormalize(.overlap_mx)
      .MOs.r(:,all) = MO

      ! Clean up
      all.destroy
      MO.destroy
      vir.destroy
      occ.destroy

   end

!  Newer, restricted only

   merge_atom_group_DMs ::: leaky
   ! Merge the group DMs into the supermolecule MOs.
   ! All occupied first, then all virtuals, as columns.
      self :: INOUT

   ENSURE(.atom_group.allocated,"no .atom_group info")
   ENSURE(.mol.allocated, "no .mol")
   ENSURE(.mol.dim==.atom_group.dim, "wrong size, .mol")

      mess, genre :: STR
      g,nb,fb,lb  :: INT

      if(.scfdata.is_restricted) then; genre = "r "
      else;                            genre = "u "
      end

      .density_mx.destroy
      .density_mx.create(.n_bf, genre)

      if(genre == "u ") then

         .density_mx.a = ZERO
         lb = 0
         ! Loop over atom group "g" and set MOs
         do g = 1,.atom_group.dim
            mess = "group "//trim(g.to_str)
            DIE_IF(.mol(g).density_mx.deallocated,trim(mess)//" density matrix undefined!")
            if (.mol(g).INQ:no_of_electrons>=1) then
               ! Sizes
               nb = .mol(g).n_bf
               ! MO/GO counters
               fb = lb + 1
               lb = lb + nb
               ! Copy the block
               .density_mx.a(fb:lb,fb:lb) = .mol(g).density_mx.a
            end
         end
         .density_mx.b = ZERO
         lb = 0
         ! Loop over atom group "g" and set MOs
         do g = 1,.atom_group.dim
            mess = "group "//trim(g.to_str)
            DIE_IF(.mol(g).density_mx.deallocated,trim(mess)//" density matrix undefined!")
            if (.mol(g).INQ:no_of_electrons>=1) then
               ! Sizes
               nb = .mol(g).n_bf
               ! MO/GO counters
               fb = lb + 1
               lb = lb + nb
               ! Copy the block
               .density_mx.b(fb:lb,fb:lb) = .mol(g).density_mx.b
            end
         end

      else

         .density_mx.r = ZERO
         lb = 0
         ! Loop over atom group "g" and set MOs
         do g = 1,.atom_group.dim
            mess = "group "//trim(g.to_str)
            DIE_IF(.mol(g).density_mx.deallocated,trim(mess)//" density matrix undefined!")
            if (.mol(g).INQ:no_of_electrons>=1) then
               ! Sizes
               nb = .mol(g).n_bf
               ! MO/GO counters
               fb = lb + 1
               lb = lb + nb
               ! Copy the block
               .density_mx.r(fb:lb,fb:lb) = .mol(g).density_mx.r
            end
         end

      end
   end

   merge_group_MOs ::: leaky
   ! Merge the group MOs into the supermolecule MOs.
   ! All occupied first, then all virtuals, as columns.
      self :: INOUT

   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.mol.allocated, "no .mol")
   ENSURE(.mol.dim==.atom_group.dim, "wrong size, .mol")

      mess :: STR
      g,nb,no,nv :: INT
      fb,lb,fo,lo,fv,lv :: INT
      all_restricted :: BIN
      knd :: STR

      ! Check if ANY of the atom groups has an unrestricted wavefunction
      all_restricted = TRUE
      do g = 1,.atom_group.dim
         knd = .mol(g).MOs.genre
         if (knd=="u ") then
            all_restricted = FALSE
            exit
         end
      end do

      if(.MOs.allocated) then
         .MOs.destroy
      end if

      if (all_restricted) then
         ! If not, use the restricted case
         .SCF:merge_group_MOs_r
      else
         .MOs.create(.n_bf,"u ")
         ! Alpha part
         .MOs.a = ZERO

         ! MO/GO counters
         lb = 0
         lo = 0
         lv = .n_a

         ! Loop over atom group "g" and set MOs
         do g = 1,.atom_group.dim

            mess = "group "//trim(g.to_str)
            DIE_IF(.mol(g).MOs.deallocated,trim(mess)//" MOs not defined!")

            if (.mol(g).INQ:no_of_electrons<1) cycle

            ! Sizes
            nb = .mol(g).n_bf
            no = .mol(g).n_a
            nv = nb - no ! number of unoccupied orbitals

            ! MO/GO counters
            fb = lb + 1
            lb = lb + nb
            fo = lo + 1
            lo = lo + no
            fv = lv + 1
            lv = lv + nv

            ! Copy occupied and virtuals
            if (.mol(g).MOs.a.allocated) then
               .MOs.a(fb:lb,fo:lo) = .mol(g).MOs.a(:,   1:no)
               .MOs.a(fb:lb,fv:lv) = .mol(g).MOs.a(:,no+1:nb)
            else
               .MOs.a(fb:lb,fo:lo) = .mol(g).MOs.r(:,   1:no)
               .MOs.a(fb:lb,fv:lv) = .mol(g).MOs.r(:,no+1:nb)
            end

         end

         ! Beta part
         .MOs.b = ZERO

         lb = 0
         lo = 0
         ! change in unrestricted case
         lv = .n_b

         ! Loop over atom group "g" and set MOs
         do g = 1,.atom_group.dim

            mess = "group "//trim(g.to_str)
            DIE_IF(.mol(g).MOs.deallocated,trim(mess)//" MOs not defined!")

            if (.mol(g).INQ:no_of_electrons<1) cycle

            ! Sizes
            nb = .mol(g).n_bf
            no = .mol(g).n_b
            nv = nb - no

            ! MO/GO counters
            fb = lb + 1
            lb = lb + nb
            fo = lo + 1
            lo = lo + no
            fv = lv + 1
            lv = lv + nv

            ! Copy occupied and virtuals
            if (.mol(g).MOs.b.allocated) then
               .MOs.b(fb:lb,fo:lo) = .mol(g).MOs.b(:,   1:no)
               .MOs.b(fb:lb,fv:lv) = .mol(g).MOs.b(:,no+1:nb)
            else
               .MOs.b(fb:lb,fo:lo) = .mol(g).MOs.r(:,   1:no)
               .MOs.b(fb:lb,fv:lv) = .mol(g).MOs.r(:,no+1:nb)
            end if
         end
      end if
   end


   merge_group_MOs_r ::: leaky
   ! Merge the group MOs into the supermolecule MOs.
   ! All occupied first, then all virtuals, as columns.
      self :: INOUT

   ENSURE(.atom_group.allocated,    "no atom_group info")
   ENSURE(.mol.allocated, "no .mol")
   ENSURE(.mol.dim==.atom_group.dim, "wrong size, .mol")

      mess :: STR
      g,nb,no,nv :: INT
      fb,lb,fo,lo,fv,lv :: INT

      .MOs.destroy
      .MOs.create(.n_bf,"r ")
      .MOs.r = ZERO

      lb = 0
      lo = 0
      ! change in unrestricted case
      lv = .n_a

      ! Loop over atom group "g" and set MOs
      do g = 1,.atom_group.dim

         mess = "group "//trim(g.to_str)
         DIE_IF(.mol(g).MOs.deallocated,trim(mess)//" MOs not defined!")

         if (.mol(g).INQ:no_of_electrons<1) cycle

         ! Sizes
         nb = .mol(g).n_bf
         no = .mol(g).n_a
         nv = nb - no

         ! MO/GO counters
         fb = lb + 1
         lb = lb + nb
         fo = lo + 1
         lo = lo + no
         fv = lv + 1
         lv = lv + nv

         ! Copy occupied and virtuals
         .MOs.r(fb:lb,fo:lo) = .mol(g).MOs.r(:,   1:no)
         .MOs.r(fb:lb,fv:lv) = .mol(g).MOs.r(:,no+1:nb)

      end

   end

   symmorthonormalize_occupied_MOs ::: leaky
   ! Symmetrically orthonormalize the occupied MO's. The occupied
   ! orbitals are the first .n_a orbitals. The remaining virtual
   ! orbitals are schmidt orthonormalized to the occupied MOs.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")

      if(.MOs.genre == "u ") then
         .SCF:symmorthonormalize_occupied_MOs_u
      else
         .SCF:symmorthonormalize_occupied_MOs_r
      end
   end


   symmorthonormalize_occupied_MOs_r ::: leaky
   ! Symmetrically orthonormalize the occupied MO's. The occupied
   ! orbitals are the first .n_a orbitals. The remaining virtual
   ! orbitals are schmidt orthonormalized to the occupied MOs.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no rhf MO's")

      MO :: MAT{REAL}@
      no,nv :: INT

      no = .n_a
      nv = .n_bf - no

      ! Make sure overlap exists
      .INTS:make_overlap_mx

      ! Symmetric orthonormalize the occupied MO's
      MO.create(.n_bf,no)
      MO = .MOs.r(:,1:no)
      MO.symmetrically_orthonormalize(.overlap_mx)
      .MOs.r(:,1:no) = MO
      MO.destroy

      ! Schmidt orthonormalize the virtuals to occupieds
      MO.create(.n_bf,nv)
      MO = .MOs.r(:,no+1:)
      MO.schmidt_orthonormalize(.overlap_mx)
      .MOs.r(:,no+1:) = MO
      MO.destroy

   end

   symmorthonormalize_occupied_MOs_u ::: leaky
   ! Symmetrically orthonormalize the occupied MO's. The occupied
   ! orbitals are the first .n_a orbitals. The remaining virtual
   ! orbitals are schmidt orthonormalized to the occupied MOs.
      self :: INOUT

   ENSURE(.MOs.allocated,"no MOs")
   ENSURE(.MOs.a.allocated,"no alpha MOs")

      MO :: MAT{REAL}@
      no,nv :: INT

      ! Alpha case
      no = .n_a
      nv = .n_bf - no

      ! Make sure overlap exists
      .INTS:make_overlap_mx

      ! Symmetric orthonormalize the occupied MO's
      MO.create(.n_bf,no)
      MO = .MOs.a(:,1:no)
      MO.symmetrically_orthonormalize(.overlap_mx)
      .MOs.a(:,1:no) = MO
      MO.destroy

      ! Schmidt orthonormalize the virtuals to occupieds
      MO.create(.n_bf,nv)
      MO = .MOs.a(:,no+1:)
      MO.schmidt_orthonormalize(.overlap_mx)
      .MOs.a(:,no+1:) = MO
      MO.destroy

      ! beta case
      no = .n_b
      nv = .n_bf - no

      ! Symmetric orthonormalize the occupied MO's
      MO.create(.n_bf,no)
      MO = .MOs.b(:,1:no)
      MO.symmetrically_orthonormalize(.overlap_mx)
      .MOs.b(:,1:no) = MO
      MO.destroy

      ! Schmidt orthonormalize the virtuals to occupieds
      MO.create(.n_bf,nv)
      MO = .MOs.b(:,no+1:)
      MO.schmidt_orthonormalize(.overlap_mx)
      .MOs.b(:,no+1:) = MO
      MO.destroy
   end


!  ==============
!  Atom group SCF
!  ==============

   atom_group_SCF ::: leaky
   ! Reads a progroup .density_mx from the archive, otherwise
   ! makes it. Then convert it to the right kind for an SCF calc.
      self :: INOUT

      arch :: ARCHIVE

      arch.set(.name,"group_density_mx", genre="r ")

      if (arch.exists) then
         ! Read the answer?
         .density_mx.destroy
         .density_mx.create(.n_bf,"r ")
         arch.read(.density_mx)
      else
         ! Make the answer
         .:do_atom_group_SCF
      end

      ! Convert
      .density_mx.convert_to(.scfdata.spinorbital_genre,factor=HALF)

   end

   make_progroup_density_mx ::: leaky
   ! Make the density matrix which is a sum of density matrices for
   ! each group specified in the molecule in the atom_group array.
   ! This will destroy any existing restricted density matrix archive.
      self :: INOUT

      archive :: ARCHIVE
      P :: OPMATRIX@

      ! Leaky
      .:do_atom_group_SCF

      ! Archive as the density_mx
      P.create(.n_bf)
      archive.set_defaults
      archive.set(.name,"group_density_mx", genre="r ")
      archive.read(P, genre="r ")
      archive.set(.name,"density_mx", genre="r ")
      archive.write(P, genre="r ")
      P.destroy

   end

   do_atom_group_SCF(MOs,output) ::: leaky
   ! Make a ".density matrix" from the sum of atom_group densities.
   ! If "MOs" is present and true, make ".MOs" which
   ! are the columns of orbitals from each group and also make the
   ! ".NO_occ_nos" vector set to 2 for the occupied group
   ! MO's.  If output is FALSE, the density matrix is not archived
      self :: INOUT
      MOs :: BIN, optional, IN
      output :: BIN, optional, IN

   ENSURE(.atom_group.allocated,"no .atom_group info")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"no .mol")
   ENSURE(.scfdata.allocated,"no scfdata")

      do_output,do_MOs :: BIN
      arch :: ARCHIVE
      g :: INT

      ! Optional switches
      do_output=TRUE
      if (present(output)) do_output=output

      do_MOs=FALSE
      if (present(MOs)) do_MOs=MOs

      ! Destroy this density matrix
      DIE_IF(.scfdata.spinorbital_genre/="r ","only for restricted DM so far")
      .density_mx.destroy
      .density_mx.create(.n_bf,.scfdata.spinorbital_genre)
      .density_mx.r = ZERO

      ! Destroy the MO's if requested
      if (do_MOs) then

         .MOs.destroy
         .MOs.create(.n_bf,"r ")
         .MOs.r = ZERO

         .NO_occ_nos.destroy
         .NO_occ_nos.create(.n_bf,"r ")
         .NO_occ_nos.r = ZERO

      end

      ! Make the ANOs: atom groups need it (leaky)
      .:make_ANO_data

      ! Update ANOs in atom_group(:).mol's
      .SET:update_group_crystal_and_ANOs

      ! Loop over atom group "g"
      do g = 1,.atom_group.dim

         ! Skip SCF for atoms without electrons
         if (.mol(g).INQ:no_of_electrons < 1) cycle

         ! Set SCF options
       ! if (.atom_group(g).n_atoms>1) then
       !    genre = mol.scfdata.spinorbital_genre
       !    if (mol.PUT:put_archive_exists("MOs",genre)) then;
       !       mol.scfdata.set_initial_MOs(genre)
       !    else
       !       mol.scfdata.set_initial_density("promolecule")
       !    end
       ! end

         ! Output details?
         if (do_output) .mol(g).PUT:put_basics

         ! Do the SCF !!!!!!!!!!!!!!!!!!!!!
         .mol(g).scfdata.set_level_shift(100d0)
         .mol(g).:scf
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! Make the AO density matrix for this group
         if (.atom_group(g).n_MOs>0) then;
            stdout.show("using fewer MOs =",.atom_group(g).n_MOs)
            stdout.text("normal P:")
            .mol(g).BASE:make_r_density_mx
            stdout.put(.mol(g).density_mx.r)
            stdout.text("reduced P:")
            .mol(g).BASE:make_SCF_density_mx(method="group",n_a=.atom_group(g).n_MOs)
            stdout.put(.mol(g).density_mx.r)
         else
            .mol(g).BASE:make_r_density_mx
         end

         ! Copy this group density matrix
         .SET:set_group_density(g,.mol(g))

         ! Copy this group's MO's and occupations
         if (do_MOs) then
            .SET:set_group_MOs(g,.mol(g))
         end

         ! Clean up files
         .mol(g).:cleanup_scf

      end

      if (do_output) then
         arch.set(.name,"group_density_mx", genre="r ")
         arch.write(.density_mx, genre="r ")
      end

      if (do_output AND do_MOs) then
         arch.set(.name,"group_MOs", genre="r ")
         arch.write(.MOs, genre="r ")
      end

   end

   fragment_SCF(restart,spin_density,do_SFs) ::: leaky
   ! Do an fragment SCF calculation on each of the .atom_group.mol
   ! molecules and calculate the structure factors.
      self :: INOUT
      restart :: BIN, optional, IN
      spin_density :: BIN, optional, IN
      do_SFs :: BIN, optional, IN

#ifndef MPI      
      .SCF:fragment_SCF_normal(restart,spin_density,do_SFs)
#else
      .SCF:fragment_SCF_MPI(restart,spin_density,do_SFs)
#endif

   end

   fragment_SCF_normal(restart,spin_density,do_SFs) ::: leaky
   ! Do an fragment SCF calculation on each of the .atom_group.mol
   ! molecules and calculate the structure factors. 
   ! If "restart" is present and TRUE then fragHAR fragment SCF's are
   ! restarted with MOs/density matrices from the previous iteration.
   ! Otherwise they are restart as requested in scfdata block using
   ! most likely "promolecule".
   ! If "spin_density" is present magnetic structure factors are
   ! calculated instead of ED structure factors.
   ! If "do_SFs" is FALSE do not calculate the atomic form factors.
      self :: INOUT
      restart :: BIN, optional, IN
      spin_density :: BIN, optional, IN
      do_SFs :: BIN, optional, IN

   ENSURE(.atom_group.allocated,"no .atom_group")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"no .mol")
   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.cif.allocated,"no cif specified")

      n_group,g :: INT
      SFs :: BIN
      name,guess :: STR

      ! Do structure factors?
      SFs = TRUE
      if (present(do_SFs)) SFs = do_SFs

      ! Need these for SFs
      if (SFs) then
         .SCF:make_ANO_data
         .SCF:delete_Hirshfeld_atom_FFs
      end

      ! Output details?
      .PUT:put_atom_group_mols

      do g = 1,.atom_group.dim

         ! Set up a molecule for this group of atoms
         .mol(g).name = .atom_group(g).name

         ! Skip SCF for atoms without electrons
         if (.mol(g).INQ:no_of_electrons < 1) cycle

         ! Make crystal
         if (.mol(g).crystal.deallocated) then
             .mol(g).crystal.update_fragment_info( .mol(g).atom)
         end

         ! Set up SCF options
       ! mol.SET:set_SCF_guess_defaults_from(.scfdata)
       ! if (.scfdata.SCF_kind=="fragment-rks") then
       !    mol.becke_grid.destroy
       !    mol.SCF:make_HA_inputs(skip_NOs=TRUE)
       !  ! mol.GRID:set_up_becke_grid
       ! end

         .mol(g).scfdata.set_output(TRUE)
         if (.mol(g).atom.dim==1) then
            .mol(g).scfdata.set_initial_density("core")
         else 
            .mol(g).scfdata.set_initial_MOs(.scfdata.initial_MOs)
            .mol(g).scfdata.set_initial_density(.scfdata.initial_density)
         end

         if (present(restart)) then
         if (restart) then
            guess = .mol(g).scfdata.spinorbital_genre
            .mol(g).scfdata.set_initial_density(guess)
         end
         end

         ! SCF !!!!!!!!!!!!!!!!!!!!!!!!!!!!
         tonto.set_parallel_IO_allowed(TRUE)
         name = trim(.mol(g).name)
         stdout.redirect(name)
         stdout.move_to_end
         .mol(g).SCF:usual_scf ! <<<
         stdout.revert
         tonto.set_parallel_IO_allowed(FALSE)
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         if (SFs) then
            ! NOTE: change DFT -> becke
            .mol(g).SET:initialize_DFT_grids
           
            ! Assign previously made ANOs
            .mol(g).SET:resolve_ANOs_from(self)
           
            ! Write SFs for each fragment to disk - in parallel
            n_group = .atom_group(g).atom_index.dim
            tonto.set_parallel_IO_allowed(TRUE)
            .mol(g).SCF:get_Hirshfeld_atom_FFs(spin_density=spin_density)
          ! .mol(g).SCF:get_Hirshfeld_atom_FFs(n_group,spin_density)
            tonto.set_parallel_IO_allowed(FALSE)

         end
      
      end

   end


!   fragment_SCF_MPI(restart,spin_density,do_SFs) ::: leaky
!   ! Do an fragment SCF calculation on each of the .atom_group.mol
!   ! molecules and calculate the structure factors.
!      self :: INOUT
!      restart :: BIN, optional, IN
!      spin_density :: BIN, optional, IN
!      do_SFs :: BIN, optional, IN
!
!   ENSURE(.atom_group.allocated,"no atom_group info")
!   ENSURE(.scfdata.allocated,"no scfdata")
!   ENSURE(.crystal.allocated,"no crystal")
!   ENSURE(.cif.allocated,"no cif specified")
!
!      SFs :: BIN
!      mol :: MOLECULE*
!      name,guess :: STR
!      g,n_group, x,w :: INT
!      n_bf :: VEC{INT}@
!
!      ! Do structure factors?
!      SFs = FALSE
!      if (present(do_SFs)) SFs = do_SFs
!
!      ! Need these for SFs
!      if (SFs) &
!         .:make_ANO_data
!
!      ! Output details?
!      .PUT:put_atom_group_mols
!
!      ! Loop over atom group "g"
!      if (tonto.n_processors > 2) then
!         
!         if (tonto.p_loop_list.deallocated) then
!
!            tonto.p_loop_list.destroy
!            tonto.p_loop_list.create(.atom_group.dim)
!            n_bf.create(.atom_group.dim)
!            do x = 1, .atom_group.dim
!               n_bf(x) = .atom_group(x).mol.n_bf
!            end
!            n_bf.quick_sort(tonto.p_loop_list,decreasing_order=TRUE)
!            n_bf.destroy
!
!         end
!      
!         tonto.setup_p_loop(w,lb=1,ub=.atom_group.dim)
!
!         do
!
!            ! NOTE: call this before exit conditions
!            g = tonto.next_p_loop_index(w)
!
!            ! Exit if no more to do, or master
!            ! NOTE: Must be in this order!
!            if (tonto.exit_p_loop) exit
!            if (tonto.is_master_processor) cycle
!                  
!            ! Set up a molecule for this group of atoms
!            mol => .atom_group(g).mol
!            DIE_IF(mol.disassociated,"molecule group "//trim(g.to_str)//" not defined!")
!
!            ! Skip SCF for atoms without electrons
!            if (mol.INQ:no_of_electrons < 1) cycle
!
!            ! Make crystal
!            if (mol.crystal.deallocated) then
!               mol.crystal.update_fragment_info(mol.atom)
!            end
!
!            mol.scfdata.set_output(TRUE)
!            if (mol.atom.dim==1) then
!               mol.scfdata.set_initial_density("core")
!            else 
!               mol.scfdata.set_initial_MOs(.scfdata.initial_MOs)
!               mol.scfdata.set_initial_density(.scfdata.initial_density)
!            end
!
!            if (present(restart)) then
!            if (restart) then
!               guess = mol.scfdata.spinorbital_genre
!               mol.scfdata.set_initial_density(guess)
!            end
!            end
!
!            ! SCF !!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            tonto.set_parallel_IO_allowed(TRUE)
!            name = trim(mol.name)
!            stdout.redirect(name)
!            stdout.move_to_end
!            mol.:usual_scf ! <<<
!            stdout.revert
!            tonto.set_parallel_IO_allowed(FALSE)
!            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!            if (SFs) then
!
!               ! NOTE: change DFT -> becke
!               .atom_group(g).mol.SET:initialize_DFT_grids
!              
!               ! Assign previously made ANOs
!               .atom_group(g).mol.SET:resolve_ANOs_from(self)
!              
!               ! Write SFs for each fragment to disk - in parallel
!               n_group = .atom_group(g).atom_index.dim
!               tonto.set_parallel_IO_allowed(TRUE)
!             ! .atom_group(g).mol.SCF:get_Hirshfeld_atom_FFs(n_group,spin_density)
!               .atom_group(g).mol.SCF:get_Hirshfeld_atom_FFs(spin_density=spin_density)
!               tonto.set_parallel_IO_allowed(FALSE)
!
!            end
!      
!         end do
!         
!         tonto.unlock_parallel_do("no")
!         
!      else
!         
!         parallel do g = 1,.atom_group.dim
!
!            ! Set up a molecule for this group of atoms
!            mol => .atom_group(g).mol
!            DIE_IF(mol.disassociated,"molecule group "//trim(g.to_str)//" not defined!")
!
!            ! Skip SCF for atoms without electrons
!            if (mol.INQ:no_of_electrons < 1) cycle
!
!            ! Make crystal
!            if (mol.crystal.deallocated) then
!               mol.crystal.update_fragment_info(mol.atom)
!            end
!
!            mol.scfdata.set_output(TRUE)
!            if (mol.atom.dim==1) then
!               mol.scfdata.set_initial_density("core")
!            else 
!               mol.scfdata.set_initial_MOs(.scfdata.initial_MOs)
!               mol.scfdata.set_initial_density(.scfdata.initial_density)
!            end
!
!            if (present(restart)) then
!            if (restart) then
!               guess = mol.scfdata.spinorbital_genre
!               mol.scfdata.set_initial_density(guess)
!            end
!            end
!
!            ! SCF !!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            tonto.set_parallel_IO_allowed(TRUE)
!            name = trim(mol.name)
!            stdout.redirect(name)
!            stdout.move_to_end
!            mol.:usual_scf ! <<<
!            stdout.revert
!            tonto.set_parallel_IO_allowed(FALSE)
!            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!            if (SFs) then
!
!               ! NOTE: change DFT -> becke
!               .atom_group(g).mol.SET:initialize_DFT_grids
!              
!               ! Assign previously made ANOs
!               .atom_group(g).mol.SET:resolve_ANOs_from(self)
!              
!               ! Write SFs for each fragment to disk - in parallel
!               n_group = .atom_group(g).atom_index.dim
!               tonto.set_parallel_IO_allowed(TRUE)
!             ! .atom_group(g).mol.SCF:get_Hirshfeld_atom_FFs(n_group,spin_density)
!               .atom_group(g).mol.SCF:get_Hirshfeld_atom_FFs(spin_density=spin_density)
!               tonto.set_parallel_IO_allowed(FALSE)
!
!            end
!         
!         end
!      
!      end if 
!
!      tonto.barrier
!
!   end

!  ===========
!  Monomer MOs
!  ===========

   make_monomer_MOs ::: leaky
   ! Make the monomer MOs from symmetrically orthonormalized group
   ! (monomer) molecular orbitals. The promolecule MOs are ordered by
   ! group.  The orbitals and the corresponding promolecule density
   ! are *not* archived.  This will destroy any existing restricted
   ! density matrix and MOs.
      self :: INOUT
      .:do_atom_group_SCF(MOs=TRUE,output=FALSE)
   end

   make_promol_MOs ::: leaky
   ! Make the promolecule MOs from symmetrically orthonormalized group
   ! (monomer) molecular orbitals. The promolecule orbitals are
   ! ordered by group.  The orbitals and the corresponding density are
   ! *not* archived.  This will destroy any existing restricted
   ! density matrix and MOs.
      self :: INOUT
      .:do_atom_group_SCF(MOs=TRUE,output=FALSE)
      .:symorthonormalize_occupied_MOs
   end

!  =============
!  Make ANO data
!  =============

   make_ANO_data ::: leaky
   ! Make the atomic natural orbitals (ANOs) *and* the corresponding
   ! spherically-averaged interpolators for the molecule.
   ! NOTE: this applies only to molecules with more than one atom.
      self :: INOUT

      if (.n_atom<=1) return

      ! Atomic natural orbitals, atomic energy, atomic density
      ! matrices, and atomic MO's
      .:make_ANOs

      ! ANO interpolators (leaky)
      .GRID:make_ANO_interpolators ! NOT PURE

      ! Atom shell-basis-function-limit info
      .SET:update_atom_shell_info

   end

   make_ANOs ::: leaky, private
   ! Get the restricted atomic natural orbitals (ANO) data and
   ! corresponding atomic-SCF data for all atoms in the molecule.
   ! NOTE: do not use this, use make_ANO_data to make everything.
      self :: INOUT

   ENSURE(.scfdata.allocated,"No scfdata")
   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      a,b :: INT
      done :: VEC{BIN}@
      first :: BIN

      .atom.set_basis_kind("gaussian")

      if (.INQ:has_all_ANO_matrices) return

      done.create(.n_atom)
      done = FALSE
      first = TRUE

      do a = 1,.n_atom

         ! ANOs made?
         if (done(a)) cycle

         if (NOT .atom(a).has_ANO_matrices) then

            .:make_ANOs_for_atom(a)

            if (first) then
               stdout.flush
               stdout.text("Making gaussian ANO data ...")
               first = FALSE
            end

         end

         done(a) = TRUE


         ! Set atoms of same kind
         do b = a+1,.n_atom

            ! Right kind?
            if (done(b)) cycle
            if (NOT .atom(b).is_same_kind_as(.atom(a))) cycle

            .atom(b).set_is_unique_kind(FALSE)

            .atom(b).density_mx = .atom(a).density_mx
            .atom(b).NOs        = .atom(a).NOs
            .atom(b).NO_occ_nos = .atom(a).NO_occ_nos
            .atom(b).AOs        = .atom(a).AOs

            .atom(b).set_energy(.atom(a).energy)

            done(b) = TRUE

         end

      end

      done.destroy

      DIE_IF(NOT .INQ:has_all_ANO_matrices,"ANO's were not made!")

   end

   make_ANOs_for_atom(a) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a".
      self :: INOUT
      a :: INT, IN

   ENSURE(.atom(a).NOs.deallocated,  "NO's exist! Atom "//trim(a.to_str))
   ENSURE(.atom(a).NO_occ_nos.deallocated,"OCCs exist! Atom "//trim(a.to_str))
   ENSURE(.atom(a).density_mx.deallocated,    "DM exists! Atom " //trim(a.to_str))

      mol :: MOLECULE@

      ! Create the molecule
      mol.SET:create
      .SET:set_molecule_from_atom(a,mol)

      ! Reset some SCF options
      mol.scfdata.set_using_direct_scf(TRUE) ! use direct scf
      mol.scfdata.set_is_guess(TRUE)         ! don't use cluster charges
      mol.scfdata.set_delete_all_archives(TRUE)

      ! Output?
      if (.scfdata.guess_output) mol.PUT:put_basics

      ! Do the atomic SCF
      mol.:atomic_SCF

      ! Eliminate core electrons from DM?
      ! Bespoke DM code
      ! Add code

      ! Spherically average the AO density
      mol.BASE:make_r_density_mx
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.BASE:symmetrize(mol.density_mx)

      ! Make the natural orbitals ... leaky
      mol.BASE:make_NOs

      ! Clean up the SCF files
      mol.SET:delete_SCF_archives

      ! Destroy the atoms's NO  ... leaky
      .atom(a).AOs.destroy
      .atom(a).density_mx.destroy
      .atom(a).NO_occ_nos.destroy
      .atom(a).NOs.destroy

      ! Copy the results
      .atom(a).NOs        = mol.NOs
      .atom(a).NO_occ_nos = mol.NO_occ_nos
      .atom(a).density_mx = mol.density_mx
      .atom(a).AOs        = mol.MOs
      .atom(a).set_energy(mol.scfdata.energy)
      .atom(a).set_atom_data_made(TRUE)

      ! Safe to destroy
      mol.SET:destroy

   end

   make_NAOs ::: leaky
   ! Get the restricted natural atomic orbitals (NAO) data
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_mx.allocated,"no basis_set info")

      a :: INT
      do_NAOs :: BIN
      
      if (.INQ:has_all_NAO_matrices) return

      ! Get restricted DM
      .BASE:make_r_density_mx

      ! NAOs or projected NAOs?
      do_NAOs = TRUE
      if (.roby.allocated) then
      if (.roby.use_projected_NAOs) then
         do_NAOs = FALSE
      end
      end

      if (do_NAOs) then

         ! NBO stype NAOs
         do a = 1,.n_atom
            .:make_NAOs_for_atom(a)
         end

      else

         ! Projected NAOs from P_A \rho P_A, P_A = atomic projector
         do a = 1,.n_atom
            .:make_pNAOs_for_atom(a)
         end

      end

   end

   make_NAOs_for_atom(a) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a".
      self :: INOUT
      a :: INT, IN

   ENSURE(.overlap_mx.allocated,"no overlap matrix")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.r.allocated,"no restricted density matrix")

      NAO, S,V,X,P :: MAT{REAL}@
      occupation :: VEC{REAL}@
      group :: VEC{INT}(1)
      n_bf :: INT

      ! Clean up
      .atom(a).NAOs.destroy
      .atom(a).NAO_occupations.destroy

      ! No. of basis functions in the group
      n_bf  = .atom(a).basis.n_bf
      group = [ a ]

      ! Create the (full) NAO and occupation matrix
      NAO.create(n_bf,n_bf)
      occupation.create(n_bf)

      ! S = overlap matrix for group(:) basis
      S.create(n_bf,n_bf)
      .BASE:AO_subspace_set(S,.overlap_mx,group,group)

      ! Get V = S^(1/2)
      V.create(n_bf,n_bf)
      V.to_sqrt_of(S)

      ! Diagonal part of P matrix
      P.create(n_bf,n_bf)
      .BASE:AO_subspace_set(P,.density_mx.r,group,group)

      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.show("Atom = ",.atom(a).tag)
         stdout.text("S:")
         stdout.put(S)
         stdout.text("P:")
         stdout.put(P)
      end
      end

      if (.roby.allocated) then
      if (.roby.use_spherical_averaging) then

         ! Symmetrize P
         .pointgroup.destroy
         .pointgroup.create("oh",.use_spherical_basis)
         .atom(a).symmetrize(P,.pointgroup)
         .pointgroup.destroy

      end
      end
        
      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.text("P after symmetrization:")
         stdout.put(P)
      end
      end

      ! Transform P -> S^(1/2) P S^(1/2)
      X.create(n_bf,n_bf)
      P.change_basis_to(X,V)

      ! Diagonalize
      X.solve_symmetric_eigenproblem(occupation,P)

      ! Get V = S^(-1/2)
      V.to_inverse_sqrt_of(S)

      ! Back transform
      NAO.to_product_of(V,P)

      ! Clean
      X.destroy
      P.destroy
      V.destroy
      S.destroy

      ! Reverse order
      occupation = occupation(n_bf:1:-1)
      NAO        =      NAO(:,n_bf:1:-1)

      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.flush
         stdout.text("NAO occupations:")
         stdout.show("Atom #         = ",a)
         stdout.show("Atom label     = ",trim(.atom(a).tag))
         stdout.flush
         stdout.put(occupation)
         stdout.text("NAO:")
         stdout.put(NAO)
      end
      end

      ! Assign
      .atom(a).NAOs            = NAO
      .atom(a).NAO_occupations = occupation

   end

   make_pNAOs_for_atom(a) ::: leaky, private
   ! Make the projected restricted natural atomic orbitals (pNAOs).
      self :: INOUT
      a :: INT, IN

   ENSURE(.atom(a).NAOs.deallocated,           "NAO's exist! Atom "//trim(a.to_str))
   ENSURE(.atom(a).NAO_occupations.deallocated,"NAO occs exist! Atom "//trim(a.to_str))
   ENSURE(.overlap_mx.allocated,"no overlap matrix")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.r.allocated,"no restricted density matrix")

      NAO, S,Smh,P,Q :: MAT{REAL}@
      occupation :: VEC{REAL}@
      group :: VEC{INT}(1)
      n_bf :: INT

      ! No. of basis functions in the group
      n_bf  = .atom(a).basis.n_bf
      group = [ a ]

      ! Create the (full) NAO and occupation matrix
      NAO.create(n_bf,n_bf)
      occupation.create(n_bf)

      ! Density matrices (see below)
      Q.create(n_bf,n_bf)
      P.create(n_bf,n_bf)

      ! S = S(:,a), overlap matrix for all,atom A
      S.create(.n_bf,n_bf)
      .BASE:AO_subspace_set(S,.overlap_mx,col_atom=group)

      ! Transform density matrix D -> P = S^T D S
      .density_mx.r.change_basis_to(P,S)

      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.show("Atom = ",.atom(a).tag)
         stdout.text("S:")
         stdout.put(S)
         stdout.text("P:")
         stdout.put(P)
      end
      end

      ! S_A = overlap matrix atom a
      S.destroy
      Smh.create(n_bf,n_bf)
      S.create(n_bf,n_bf)
      .BASE:AO_subspace_set(S,.overlap_mx,group,group)

      ! Get (S_A)^-1
      Smh.to_inverse_of(S)

      ! Transform density P -> Q = (S_A)^-1 P (S_A)^-1
      P.change_basis_to(Q,Smh)

      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.put(S)
         stdout.text("Q:")
         stdout.put(Q)
      end
      end

      if (.roby.allocated) then
      if (.roby.use_spherical_averaging) then

         ! Symmetrize P
         .pointgroup.destroy
         .pointgroup.create("oh",.use_spherical_basis)
         .atom(a).symmetrize(Q,.pointgroup)
         .pointgroup.destroy

      end
      end

      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.text("Q after symmetrization:")
         stdout.put(Q)
      end
      end

      ! Get (S_A)^1/2
      Smh.to_sqrt_of(S)

      ! Transform density Q -> Q = (S_A)^1/2 Q (S_A)^1/2
      Q.change_basis_to(P,Smh)

      ! Diagonalize; now Q = eigenvectors
      P.solve_symmetric_eigenproblem(occupation,Q)

      ! Get (S_A)^-1/2
      Smh.to_inverse_sqrt_of(S)

      ! Back transform
      NAO.to_product_of(Smh,Q)

      ! Clean
      S.destroy
      Smh.destroy
      P.destroy
      Q.destroy

      ! Reverse order
      occupation = occupation(n_bf:1:-1)
      NAO        =      NAO(:,n_bf:1:-1)

      if (.roby.allocated) then
      if (.roby.show_calcs) then
         stdout.text("NAO occupation:")
         stdout.put(occupation)
         stdout.text("NAO:")
         stdout.put(NAO)
      end
      end

      ! Assign
      .atom(a).NAOs            = NAO
      .atom(a).NAO_occupations = occupation

   end

!  ==========================
!  DIIS/Orbital extrapolation
!  ==========================

   make_DIIS_error_length(length) ::: leaky
   ! Make the SCF error vector from the current fock_mx and
   ! density_mx, and return the error "length".  Useful for reporting the
   ! error length.
      self :: INOUT
      length :: REAL, OUT

   ENSURE(.fock_mx.allocated,"no fock matrix")
   ENSURE(.fock_mx.has_any_genre,"no fock matrix")
   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.has_any_genre,"no density matrix")

      ! Get overlap matrix (leaky)
      .INTS:make_overlap_mx

      ! Get error length
      length = ::DIIS_error_length(.fock_mx,.density_mx,.overlap_mx)

      ! Set the length
      .scfdata.SCF_DIIS.set_error_length(length)
      .scfdata.set_DIIS_error(length)

   end

   extrapolate_Fock_mx ::: leaky
   ! Extrapolate the fock matrix, currently only using DIIS.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.fock_mx.allocated,"no fock matrix")
   ENSURE(.density_mx.allocated,"no density matrix")

      spinorbital_genre,scf_kind :: STR
      error :: REAL
      C :: OPMATRIX@
      dim :: INT

      ! DIIS sometimes forbidden 
      if (NOT .scfdata.using_DIIS) return

      .scfdata.set_DIIS_error(ZERO)

      if (NOT .fock_mx.has_any_genre) return

      ! Get overlap if not there (leaky)
      .INTS:make_overlap_mx

      ! Spinorbital kind before compression
      spinorbital_genre = .fock_mx.genre

      ! Make commutator C
      C.create(.fock_mx.n_bf,spinorbital_genre)
      MOLECULE.SCF:make_DIIS_commutator(C,.fock_mx,.density_mx,.overlap_mx)

      ! Compress
      C.compress
      .fock_mx.compress

      ! Extrapolate compressed entities
      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("rhf","rks","noninteracting-group-rhf")
         dim = C.tri.dim
         .scfdata.SCF_DIIS.extrapolate(.fock_mx.tri,C.tri,dim) ! NOT PURE
         error = C.tri.norm

      case ("xray_rhf","xray_rks")
         dim = C.tri.dim
         .scfdata.SCF_DIIS.extrapolate(.fock_mx.tri,C.tri,dim)
         error = C.tri.norm

      case ("rohf")
         dim = C.tri.dim
         .scfdata.SCF_DIIS.extrapolate(.fock_mx.tri,C.tri,dim)
         error = C.tri.norm

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         dim = C.tri.dim
         .scfdata.SCF_DIIS.extrapolate(.fock_mx.tri,C.tri,dim)
         error = C.tri.norm

      case ("gchf","xray_gchf")
         dim = C.sqr.dim
         .scfdata.SCF_DIIS.extrapolate(.fock_mx.sqr,C.sqr,dim)
         error = C.sqr.norm

    ! case default
    !    DIE("unknown SCF kind, "//trim(scf_kind))

      end

      ! Set the error
      .scfdata.set_DIIS_error(error)

      ! Clean
      C.destroy

      ! Uncompress
      .fock_mx.uncompress

   end

!  ======================
!  Setting the DIIS error
!  ======================

   DIIS_error_length(F,D,S) result (res) ::: selfless, PURE
   ! Make the real DIIS commutator matrix, C = FDS - SDF and set the DIIS
   ! .error_length to be sqrt(C-.C). The minus sign is because C is
   ! antisymmetric.
      F,D :: OPMATRIX,  IN
      S   :: MAT{REAL}, IN
      res :: REAL

   ENSURE(F.has_any_genre,"no Fock matrix")
   ENSURE(D.has_any_genre,"no density matrix")

      C :: OPMATRIX@
      spinorbital_genre :: STR

      ! Kind
      spinorbital_genre = F.genre

      ! Make commutator
      C.create(F.n_bf,spinorbital_genre)

      MOLECULE.SCF:make_DIIS_commutator(C,F,D,S)
      C.compress

      ! Set error length
      res = ZERO
      select case (spinorbital_genre)
      case("r "); res = C.tri.norm
      case("u "); res = C.tri.norm
      case("gc"); res = C.sqr.norm
    ! case default; UNKNOWN(spinorbital_genre)
      end

      ! Clean
      C.destroy

   end

   make_DIIS_commutator(C,F,D,S) ::: selfless, PURE
   ! Make the DIIS commutator opmatrix, C = FDS - SDF.
      C   :: OPMATRIX, INOUT
      F,D :: OPMATRIX, IN
      S   :: MAT{REAL}, IN

   select case (F.genre)

   case("r ")
      MOLECULE.SCF:make_DIIS_commutator_r(C.r,F.r,D.r,S)

   case("u ")
      MOLECULE.SCF:make_DIIS_commutator_r(C.a,F.a,D.a,S)
      MOLECULE.SCF:make_DIIS_commutator_r(C.b,F.b,D.b,S)
      C.a = C.a + C.b

   case("gc")
      MOLECULE.SCF:make_DIIS_commutator_gc(C.gc,F.gc,D.gc,S)

    ! case default
    !    DIE("unimplemented")

      end

   end

   make_DIIS_commutator_r(C,F,D,S) ::: selfless, private, PURE
   ! Make the real DIIS commutator matrix, C = FDS - SDF.
      C :: MAT{REAL}, OUT
      F,D,S :: MAT{REAL}, IN

      W :: MAT{REAL}@

      W.create(F.dim1,F.dim1)
      W.to_product_of(D,S)
      C.to_product_of(F,W)
      W.destroy

      C.antisymmetric_fold
      C.antisymmetric_reflect

   end

   make_DIIS_commutator_gc(C,F,D,S) ::: selfless, private, PURE
   ! Make the complex DIIS commutator matrix, C = FDS - SDF.
      C   :: MAT{CPX}, OUT
      F,D :: MAT{CPX},  IN
      S   :: MAT{REAL}, IN

      O,W :: MAT{CPX}@

      W.create(F.dim1,F.dim1)

      ! Make the overlap matrix
      O.create(F.dim1,F.dim1)
      O = ZERO
      O.set_aa_block_to(S)
      O.set_bb_block_to(S)

      ! D . S
      W.to_product_of(D,O)
      O.destroy

      ! F . D . S
      C.to_product_of(F,W)
      W.destroy

      ! Make FDS - SDF
      C.antihermitian_fold
      C.antihermitian_reflect

   end

!  =========================
!  Canonicalisation routines
!  =========================

   canonicalize_MOs
   ! Generate the Fock matrix from the molecular orbitals and
   ! diagonalise it on the occupied-occupied block to get the
   ! canonical molecular orbitals, and write them out.
      self :: INOUT

   ENSURE(.MOs.allocated,"need old MOs!")
   ENSURE(.MO_energies.allocated,"need old energies")

      scf_kind :: STR

      .BASE:make_SCF_density_mx

      .:make_Fock_mx

      scf_kind = .scfdata.SCF_kind

      select case (scf_kind)

      case ("rhf     ", &
            "rks     ", &
            "xray_rhf", &
            "xray_rks", &
            "noninteracting-group-rhf")
         .MO_energies.destroy
         .MO_energies.create(.n_bf,"r ")
         .:canonicalize_r_MO(.MO_energies.r,.MOs.r,.fock_mx.r,.n_e/2)
         stdout.flush
         stdout.text("Canonicalized MO energies:")
         stdout.put(.MO_energies.r)

      case ("uhf         ", &
            "uks         ", &
            "xray_uhf    ", &
            "xray_uks    ", &
            "rohf        ", &
            "pnd_uhf     ", &
            "pnd_uks     ", &
            "xray_pnd_uhf", &
            "xray_pnd_uks")
         .MO_energies.destroy
         .MO_energies.create(.n_bf,"u ")
         .:canonicalize_r_MO(.MO_energies.a,.MOs.a,.fock_mx.a,.n_a)
         .:canonicalize_r_MO(.MO_energies.b,.MOs.b,.fock_mx.b,.n_b)
         stdout.flush
         stdout.text("Canonicalized alpha MO energies:")
         stdout.put(.MO_energies.a(1:.n_a))
         stdout.flush
         stdout.text("Canonicalized beta MO energies:")
         stdout.put(.MO_energies.b(1:.n_b))

    ! case default
    !    DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   canonicalize_r_MO(MO_energies,MO,F,n)
   ! Digaonalise the Fock matrix "F" in the occupied-occupied and
   ! virtual-virtual block of the molecular orbitals "MO", and reset the
   ! occupied "MO_energies".
      self :: INOUT
      MO_energies :: VEC{REAL}, OUT
      MO :: MAT{REAL}, INOUT
      F  :: MAT{REAL}, IN
      n  :: INT, IN

      G,U,MO_old :: MAT{REAL}@
      v :: INT

      G.create(n,n)
      U.create(n,n)
      MO_old.create(.n_bf,n)

      ! Canonicalise the occ-occ block
      MO_old = MO(:,1:n)
      F.change_basis_to(G,MO_old)
      G.solve_symmetric_eigenproblem(MO_energies(1:n),U) ! NOT PURE
      MO(:,1:n).to_product_of(MO_old,U)

      MO_old.destroy
      U.destroy
      G.destroy

      ! Canonicalise the vir-vir block
      v = .n_bf - n
      G.create(v,v)
      U.create(v,v)
      MO_old.create(.n_bf,v)
      MO_old = MO(:,n+1:)

      F.change_basis_to(G,MO_old)
      G.solve_symmetric_eigenproblem(MO_energies(n+1:),U)
      MO(:,n+1:).to_product_of(MO_old,U)

      MO_old.destroy
      U.destroy
      G.destroy

   end

!  =================
!  Localize orbitals
!  =================

   localize_MOs ::: leaky
   ! Localize the MO's
      self :: INOUT

   ENSURE(.MOs.allocated,"no MO's")
   ENSURE(.MOs.r.allocated,"no MO's")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated, "no atom info")

      D,Q :: MAT3{REAL}@

      ! Leaky
      .localiser.create

      D.create(.n_bf,.n_bf,3)
      Q.create(.n_bf,.n_bf,6)

      .INTS:make_dipole_matrices(D(:,:,1),D(:,:,2),D(:,:,3))
      .INTS:make_quadrupole_matrices(Q(:,:,1),Q(:,:,2),Q(:,:,3),Q(:,:,4),Q(:,:,5),Q(:,:,6))

      .localiser.set_defaults(.MOs.r(:,1:.n_a),D,Q)
      .localiser.set_MO(.MOs.r(:,1:.n_a))
      .localiser.read_keywords

      Q.destroy
      D.destroy

   end

end
