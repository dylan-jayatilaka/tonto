module TEST_PARALLEL

implicit none

contains

   send_testing_suite :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM@

      neighbours :: VEC{INT}@

      allocate(mpi)

      mpi.init

      .check_neighbours(mpi,neighbours)
      .sending_mpi_test(mpi,neighbours)
      .ssending_mpi_test(mpi,neighbours)
      .isending_mpi_test(mpi,neighbours)
      .issending_mpi_test(mpi,neighbours)
      .sendrecv_mpi_test(mpi,neighbours)
      .gather_mpi_test(mpi)
      .allgather_mpi_test(mpi)
      .bcast_mpi_test(mpi)
      .scatter_mpi_test(mpi)
      .alltoall_mpi_test(mpi)
      .sum_mpi_test(mpi)
      .allsum_mpi_test(mpi)
      .scansum_mpi_test(mpi)
      .prod_mpi_test(mpi)
      .allprod_mpi_test(mpi)
      .scanprod_mpi_test(mpi)
      .max_mpi_test(mpi)
      .allmax_mpi_test(mpi)
      .scanmax_mpi_test(mpi)
      .min_mpi_test(mpi)
      .allmin_mpi_test(mpi)
      .scanmin_mpi_test(mpi)
      .lor_mpi_test(mpi)
      .alllor_mpi_test(mpi)
      .scanlor_mpi_test(mpi)
      .land_mpi_test(mpi)
      .allland_mpi_test(mpi)
      .scanland_mpi_test(mpi)
      .lxor_mpi_test(mpi)
      .alllxor_mpi_test(mpi)
      .scanlxor_mpi_test(mpi)
      !.maxloc_mpi_test(mpi)
      !.minloc_mpi_test(mpi)
      .barrier_mpi_test(mpi)
      !.igather_mpi_test(mpi)
      
      mpi.finalize
   end 

   check_neighbours(mpi,neighbours) :::  public
   ! This routine returns which processors are adjacent to it in the
   ! grid.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      neighbours :: VEC{INT}@, OUT 
      sorted :: VEC{INT}@ 
      rank,size :: INT

      mpi.comm_rank(rank)
      mpi.comm_size(size)
      
      if (size == 4) then
         if (mod(rank,2) == 0) then
            sorted.append(rank+1)
            if (rank<2) sorted.append(rank+2)
            if (rank>0) sorted.append(rank-2)
         else if (mod(rank,2) == 1) then
            sorted.append(rank-1)
            if(rank>1) sorted.append(rank-2)
            if(rank<2) sorted.append(rank+2)
         end if
      else if (size == 6) then
         if (mod(rank,3) == 0) then
            sorted.append(rank+1)
            if (rank<4) sorted.append(rank+3)
            if (rank>0) sorted.append(rank-3)
         else if (mod(rank,3) == 1) then
            sorted.append(rank-1)
            sorted.append(rank+1)
            if(rank>2) sorted.append(rank-3)
            if(rank<3) sorted.append(rank+3)
         else if (mod(rank,3) == 2) then
            sorted.append(rank-1)
            if (rank<3) sorted.append(rank+3)
            if (rank>3) sorted.append(rank-3)
         end if
      else if (size == 8) then
         if (mod(rank,4) == 0) then
            sorted.append(rank+1)
            if (rank<4) sorted.append(rank+4)
            if (rank>0) sorted.append(rank-4)
         else if (mod(rank,4) == 1 OR mod(rank,4) ==2) then
            sorted.append(rank-1)
            sorted.append(rank+1)
            if(rank>3) sorted.append(rank-4)
            if(rank<4) sorted.append(rank+4)
         else if (mod(rank,4) == 3) then
            sorted.append(rank-1)
            if (rank<4) sorted.append(rank+4)
            if (rank>4) sorted.append(rank-4)
         end if
      else if (size == 9) then
         if (mod(rank,3) == 0) then
            sorted.append(rank+1)
            if (rank<6) sorted.append(rank+3)
            if (rank>0) sorted.append(rank-3)
         else if (mod(rank,3) == 1) then
            sorted.append(rank-1)
            sorted.append(rank+1)
            if(rank>2) sorted.append(rank-3)
            if(rank<6) sorted.append(rank+3)
         else if (mod(rank,3) == 2) then
            sorted.append(rank-1)
            if (rank<6) sorted.append(rank+3)
            if (rank>0) sorted.append(rank-3)
         end if
      else
         if (rank>0) sorted.append(rank-1)
         if (rank<size-1) sorted.append(rank+1)
      end if
      sorted.sort
      print*, "I am processor: ", rank, "my neighbours are:", sorted 
      neighbours = sorted
   end
   
   sending_mpi_test(mpi,neighbours) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      neighbours :: VEC{INT}, IN
      i,j,k,l,m,rank,int_a,int_b,int_c,int_d,int_e :: INT
      str_a,str_b,str_c,str_d,str_e     :: STR
      bin_a,bin_b,bin_c,bin_d,bin_e     :: BIN
      cpx_a,cpx_b,cpx_c,cpx_d,cpx_e     :: CPX
      real_a,real_b,real_c,real_d,real_e   :: REAL
      int_va,int_vb,int_vc,int_vd,int_ve   :: VEC{INT}@
      str_va,str_vb,str_vc,str_vd,str_ve   :: VEC{STR}@
      bin_va,bin_vb,bin_vc,bin_vd,bin_ve   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve   :: VEC{CPX}@
      real_va,real_vb,real_vc,real_vd,real_ve :: VEC{REAL}@
      int_ma,int_mb,int_mc,int_md,int_me   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mc,str_md,str_me   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mc,bin_md,bin_me   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mc,real_md,real_me :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3c,int_m3d,int_m3e   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3c,real_m3d,real_m3e :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4c,int_m4d,int_m4e   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4c,real_m4d,real_m4e :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5c,real_m5d,real_m5e :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b,int_m5c,int_m5d,int_m5e :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      write(str_a,*) rank
      int_a  = 4+3*rank
      bin_a  = (mod(rank,2)==0)
      cpx_a  = cmplx(4.3,123.2)+3*real(rank)
      real_a = 1.34+3*real(rank)
      str_va  = [str_a,str_a]
      int_va  = [4+3*rank,2+3*rank]
      bin_va  = [(mod(rank,2)==0),(mod(rank,2)==0)]
      cpx_va  = [cmplx(4.3,123.2)+rank*3,cmplx(6.7,5.7)+rank*3]
      real_va = [1.34+real(rank*3),34.5+real(rank*3)]
      str_ma(1,:) = [str_a,str_a,str_a] 
      str_ma(2,:) = [str_a,str_a,str_a] 
      str_ma(3,:) = [str_a,str_a,str_a] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (mod(i*j+rank,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3+rank*3)/54,real(j)**(1/2)+real(rank*3)*65)
            real_ma(i,j) = real(i**4+rank*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+rank
               if (mod(i*j*k+rank,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3+rank*3)/54 + real(k)*0.05432,real(k+rank*3)*5433.43 + real(j)**(1/2)*65) 
               real_m3a(i,j,k) = real(i**4+3*rank)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+rank
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(rank + j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(rank+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+rank
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3+rank)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l+rank)+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Initialise all the variables for send testing.
      write(str_b,*) neighbours(1)
      int_b  = 4+3*neighbours(1)
      bin_b  = (mod(neighbours(1),2)==0)
      cpx_b  = cmplx(4.3,123.2)+3*real(neighbours(1))
      real_b = 1.34+3*real(neighbours(1))
      str_vb  = [str_b,str_b]
      int_vb  = [4+3*neighbours(1),2+3*neighbours(1)]
      bin_vb  = [(mod(neighbours(1),2)==0),(mod(neighbours(1),2)==0)]
      cpx_vb  = [cmplx(4.3,123.2)+neighbours(1)*3,cmplx(6.7,5.7)+neighbours(1)*3]
      real_vb = [1.34+real(neighbours(1))*3,34.5+real(neighbours(1))*3]
      str_mb(1,:) = [str_b,str_b,str_b] 
      str_mb(2,:) = [str_b,str_b,str_b] 
      str_mb(3,:) = [str_b,str_b,str_b] 
      do i = 1,3
         do j = 1,3
            int_mb(i,j) = i*j
            if (mod(i*j+neighbours(1),2) == 0) then
               bin_mb(i,j) = TRUE
            else
               bin_mb(i,j) = FALSE
            end if
            cpx_mb(i,j) = cmplx(real(i**3+neighbours(1)*3)/54,real(j)**(1/2)+real(neighbours(1)*3)*65)
            real_mb(i,j) = real(i**4+neighbours(1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3b(i,j,k) = i*j*k+neighbours(1)
               if (mod(i*j*k+neighbours(1),2) == 0) then
                  bin_m3b(i,j,k) = TRUE
               else
                  bin_m3b(i,j,k) = FALSE
               end if
               cpx_m3b(i,j,k) = cmplx(real(i**3+neighbours(1)*3)/54 + real(k)*0.05432,real(k+neighbours(1)*3)*5433.43 + real(j)**(1/2)*65 )
               real_m3b(i,j,k) = real(i**4+3*neighbours(1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4b(i,j,k,l) = i*j*k*l+neighbours(1)
                  cpx_m4b(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(1) + j)**(1/2)*65)
                  real_m4b(i,j,k,l) = real(neighbours(1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5b(i,j,k,l,m) = i*j*k*l-m+neighbours(1)
                     cpx_m5b(i,j,k,l,m) = cmplx(real(i**3+neighbours(1))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5b(i,j,k,l,m) = real(i**l+neighbours(1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      if (neighbours.dim >1) then
         ! Initialise all the variables for send testing.
         write(str_c,*) neighbours(2)
         int_c  = 4+3*neighbours(2)
         bin_c  = (mod(neighbours(2),2)==0)
         cpx_c  = cmplx(4.3,123.2)+3*real(neighbours(2))
         real_c = 1.34+3*real(neighbours(2))
         str_vc  = [str_c,str_c]
         int_vc  = [4+3*neighbours(2),2+3*neighbours(2)]
         bin_vc  = [(mod(neighbours(2),2)==0),(mod(neighbours(2),2)==0)]
         cpx_vc  = [cmplx(4.3,123.2)+neighbours(2)*3,cmplx(6.7,5.7)+neighbours(2)*3]
         real_vc = [1.34+real(neighbours(2)*3),34.5+real(neighbours(2))*3]
         str_mc(1,:) = [str_c,str_c,str_c] 
         str_mc(2,:) = [str_c,str_c,str_c] 
         str_mc(3,:) = [str_c,str_c,str_c] 
         do i = 1,3
            do j = 1,3
               int_mc(i,j) = i*j
               if (mod(i*j+neighbours(2),2) == 0) then
                  bin_mc(i,j) = TRUE
               else
                  bin_mc(i,j) = FALSE
               end if
               cpx_mc(i,j) = cmplx(real(i**3+neighbours(2)*3)/54,real(j)**(1/2)+neighbours(2)*3*65)
               real_mc(i,j) = real(i**4+neighbours(2)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3c(i,j,k) = i*j*k+neighbours(2)
                  if (mod(i*j*k+neighbours(2),2) == 0) then
                     bin_m3c(i,j,k) = TRUE
                  else
                     bin_m3c(i,j,k) = FALSE
                  end if
                  cpx_m3c(i,j,k) = cmplx(real(i**3+neighbours(2)*3)/54 + real(k)*0.05432,real(k+neighbours(2)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3c(i,j,k) = real(i**4+3*neighbours(2))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4c(i,j,k,l) = i*j*k*l+neighbours(2)
                     cpx_m4c(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(2) + j)**(1/2)*65)
                     real_m4c(i,j,k,l) = real(neighbours(2)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5c(i,j,k,l,m) = i*j*k*l-m+neighbours(2)
                        cpx_m5c(i,j,k,l,m) = cmplx(real(i**3+neighbours(2))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j**(1/2))*65)
                        real_m5c(i,j,k,l,m) = real(i**l+neighbours(2))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>2) then
         ! Initialise all the variables for send testing.
         write(str_d,*) neighbours(3)
         int_d  = 4+3*neighbours(3)
         bin_d  = (mod(neighbours(3),2)==0)
         cpx_d  = cmplx(4.3,123.2)+3*real(neighbours(3))
         real_d = 1.34+3*real(neighbours(3))
         str_vd  = [str_d,str_d]
         int_vd  = [4+3*neighbours(3),2+3*neighbours(3)]
         bin_vd  = [(mod(neighbours(3),2)==0),(mod(neighbours(3),2)==0)]
         cpx_vd  = [cmplx(4.3,123.2)+neighbours(3)*3,cmplx(6.7,5.7)+neighbours(3)*3]
         real_vd = [1.34+real(neighbours(3)*3),34.5+real(neighbours(3))*3]
         str_md(1,:) = [str_d,str_d,str_d] 
         str_md(2,:) = [str_d,str_d,str_d] 
         str_md(3,:) = [str_d,str_d,str_d] 
         do i = 1,3
            do j = 1,3
               int_md(i,j) = i*j
               if (mod(i*j+neighbours(3),2) == 0) then
                  bin_md(i,j) = TRUE
               else
                  bin_md(i,j) = FALSE
               end if
               cpx_md(i,j) = cmplx(real(i**3+neighbours(3)*3)/54,real(j)**(1/2)+neighbours(3)*3*65)
               real_md(i,j) = real(i**4+neighbours(3)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3d(i,j,k) = i*j*k+neighbours(3)
                  if (mod(i*j*k+neighbours(3),2) == 0) then
                     bin_m3d(i,j,k) = TRUE
                  else
                     bin_m3d(i,j,k) = FALSE
                  end if
                  cpx_m3d(i,j,k) = cmplx(real(i**3+neighbours(3)*3)/54 + real(k)*0.05432,real(k+neighbours(3)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3d(i,j,k) = real(i**4+3*neighbours(3))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4d(i,j,k,l) = i*j*k*l+neighbours(3)
                     cpx_m4d(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(3) + j)**(1/2)*65)
                     real_m4d(i,j,k,l) = real(neighbours(3)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5d(i,j,k,l,m) = i*j*k*l-m+neighbours(3)
                        cpx_m5d(i,j,k,l,m) = cmplx(real(i**3+neighbours(3))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5d(i,j,k,l,m) = real(i**l+neighbours(3))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>3) then
         ! Initialise all the variables for send testing.
         write(str_e,*) neighbours(4)
         int_e  = 4+3*neighbours(4)
         bin_e  = (mod(neighbours(4),2)==0)
         cpx_e  = cmplx(4.3,123.2)+3*real(neighbours(4))
         real_e = 1.34+3*real(neighbours(4))
         str_ve  = [str_e,str_e]
         int_ve  = [4+3*neighbours(4),2+3*neighbours(4)]
         bin_ve  = [(mod(neighbours(4),2)==0),(mod(neighbours(4),2)==0)]
         cpx_ve  = [cmplx(4.3,123.2)+neighbours(4)*3,cmplx(6.7,5.7)+neighbours(4)*3]
         real_ve = [1.34+real(neighbours(4)*3),34.5+real(neighbours(4)*3)]
         str_me(1,:) = [str_e,str_e,str_e] 
         str_me(2,:) = [str_e,str_e,str_e] 
         str_me(3,:) = [str_e,str_e,str_e] 
         do i = 1,3
            do j = 1,3
               int_me(i,j) = i*j
               if (mod(i*j+neighbours(4),2) == 0) then
                  bin_me(i,j) = TRUE
               else
                  bin_me(i,j) = FALSE
               end if
               cpx_me(i,j) = cmplx(real(i**3+neighbours(4)*3)/54,real(j)**(1/2)+real(neighbours(4)*3*65))
               real_me(i,j) = real(i**4+neighbours(4)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3e(i,j,k) = i*j*k+neighbours(4)
                  if (mod(i*j*k+neighbours(4),2) == 0) then
                     bin_m3e(i,j,k) = TRUE
                  else
                     bin_m3e(i,j,k) = FALSE
                  end if
                  cpx_m3e(i,j,k) = cmplx(real(i**3+neighbours(4)*3)/54 + real(k)*0.05432,real(k+neighbours(4)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3e(i,j,k) = real(i**4+3*neighbours(4))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4e(i,j,k,l) = i*j*k*l+neighbours(4)
                     cpx_m4e(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(4) + j)**(1/2)*65)
                     real_m4e(i,j,k,l) = real(neighbours(4)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5e(i,j,k,l,m) = i*j*k*l-m+neighbours(4)
                        cpx_m5e(i,j,k,l,m) = cmplx(real(i**3+neighbours(4))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5e(i,j,k,l,m) = real(i**l+neighbours(4))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 


      ! Call the routines

      ! Single numbers
      .test_send(rank,neighbours,mpi,str_a,str_b,str_c,str_d,str_e)
      .test_send(rank,neighbours,mpi,int_a,int_b,int_c,int_d,int_e)
      .test_send(rank,neighbours,mpi,bin_a,bin_b,bin_c,bin_d,bin_e)
      .test_send(rank,neighbours,mpi,real_a,real_b,real_c,real_d,real_e)
      .test_send(rank,neighbours,mpi,cpx_a,cpx_b,cpx_c,cpx_d,cpx_e)
   
      ! Vectors
      .test_send(rank,neighbours,mpi,str_va,str_vb,str_vc,str_vd,str_ve)
      .test_send(rank,neighbours,mpi,int_va,int_vb,int_vc,int_vd,int_ve)
      .test_send(rank,neighbours,mpi,bin_va,bin_vb,bin_vc,bin_vd,bin_ve)
      .test_send(rank,neighbours,mpi,real_va,real_vb,real_vc,real_vd,real_ve)
      .test_send(rank,neighbours,mpi,cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve)
      
      ! Matrix
      .test_send(rank,neighbours,mpi,str_ma,str_mb,str_mc,str_md,str_me)
      .test_send(rank,neighbours,mpi,int_ma,int_mb,int_mc,int_md,int_me)
      .test_send(rank,neighbours,mpi,bin_ma,bin_mb,bin_mc,bin_md,bin_me)
      .test_send(rank,neighbours,mpi,real_ma,real_mb,real_mc,real_md,real_me)
      .test_send(rank,neighbours,mpi,cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me)
      
      ! Matrix 3s
      .test_send(rank,neighbours,mpi,int_m3a,int_m3b,int_m3c,int_m3d,int_m3e)
      .test_send(rank,neighbours,mpi,bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e)
      .test_send(rank,neighbours,mpi,real_m3a,real_m3b,real_m3c,real_m3d,real_m3e)
      .test_send(rank,neighbours,mpi,cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e)
      !
      ! Matrix 4s
      .test_send(rank,neighbours,mpi,int_m4a,int_m4b,int_m4c,int_m4d,int_m4e)
      .test_send(rank,neighbours,mpi,real_m4a,real_m4b,real_m4c,real_m4d,real_m4e)
      .test_send(rank,neighbours,mpi,cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e)
      !
      ! Matrix 5s
      .test_send(rank,neighbours,mpi,int_m5a,int_m5b,int_m5c,int_m5d,int_m5e)
      .test_send(rank,neighbours,mpi,real_m5a,real_m5b,real_m5c,real_m5d,real_m5e)
      .test_send(rank,neighbours,mpi,cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e)
      
   
   end

   ssending_mpi_test(mpi,neighbours) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      neighbours :: VEC{INT}, IN
      i,j,k,l,m,rank,int_a,int_b,int_c,int_d,int_e :: INT
      str_a,str_b,str_c,str_d,str_e     :: STR
      bin_a,bin_b,bin_c,bin_d,bin_e     :: BIN
      cpx_a,cpx_b,cpx_c,cpx_d,cpx_e     :: CPX
      real_a,real_b,real_c,real_d,real_e   :: REAL
      int_va,int_vb,int_vc,int_vd,int_ve   :: VEC{INT}@
      str_va,str_vb,str_vc,str_vd,str_ve   :: VEC{STR}@
      bin_va,bin_vb,bin_vc,bin_vd,bin_ve   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve   :: VEC{CPX}@
      real_va,real_vb,real_vc,real_vd,real_ve :: VEC{REAL}@
      int_ma,int_mb,int_mc,int_md,int_me   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mc,str_md,str_me   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mc,bin_md,bin_me   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mc,real_md,real_me :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3c,int_m3d,int_m3e   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3c,real_m3d,real_m3e :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4c,int_m4d,int_m4e   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4c,real_m4d,real_m4e :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5c,real_m5d,real_m5e :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b,int_m5c,int_m5d,int_m5e :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      write(str_a,*) rank
      int_a  = 4+3*rank
      bin_a  = (mod(rank,2)==0)
      cpx_a  = cmplx(4.3,123.2)+3*real(rank)
      real_a = 1.34+3*real(rank)
      str_va  = [str_a,str_a]
      int_va  = [4+3*rank,2+3*rank]
      bin_va  = [(mod(rank,2)==0),(mod(rank,2)==0)]
      cpx_va  = [cmplx(4.3,123.2)+rank*3,cmplx(6.7,5.7)+rank*3]
      real_va = [1.34+real(rank*3),34.5+real(rank*3)]
      str_ma(1,:) = [str_a,str_a,str_a] 
      str_ma(2,:) = [str_a,str_a,str_a] 
      str_ma(3,:) = [str_a,str_a,str_a] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (mod(i*j+rank,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3+rank*3)/54,real(j)**(1/2)+real(rank*3)*65)
            real_ma(i,j) = real(i**4+rank*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+rank
               if (mod(i*j*k+rank,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3+rank*3)/54 + real(k)*0.05432,real(k+rank*3)*5433.43 + real(j)**(1/2)*65) 
               real_m3a(i,j,k) = real(i**4+3*rank)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+rank
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(rank + j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(rank+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+rank
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3+rank)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l+rank)+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Initialise all the variables for send testing.
      write(str_b,*) neighbours(1)
      int_b  = 4+3*neighbours(1)
      bin_b  = (mod(neighbours(1),2)==0)
      cpx_b  = cmplx(4.3,123.2)+3*real(neighbours(1))
      real_b = 1.34+3*real(neighbours(1))
      str_vb  = [str_b,str_b]
      int_vb  = [4+3*neighbours(1),2+3*neighbours(1)]
      bin_vb  = [(mod(neighbours(1),2)==0),(mod(neighbours(1),2)==0)]
      cpx_vb  = [cmplx(4.3,123.2)+neighbours(1)*3,cmplx(6.7,5.7)+neighbours(1)*3]
      real_vb = [1.34+real(neighbours(1))*3,34.5+real(neighbours(1))*3]
      str_mb(1,:) = [str_b,str_b,str_b] 
      str_mb(2,:) = [str_b,str_b,str_b] 
      str_mb(3,:) = [str_b,str_b,str_b] 
      do i = 1,3
         do j = 1,3
            int_mb(i,j) = i*j
            if (mod(i*j+neighbours(1),2) == 0) then
               bin_mb(i,j) = TRUE
            else
               bin_mb(i,j) = FALSE
            end if
            cpx_mb(i,j) = cmplx(real(i**3+neighbours(1)*3)/54,real(j)**(1/2)+real(neighbours(1)*3)*65)
            real_mb(i,j) = real(i**4+neighbours(1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3b(i,j,k) = i*j*k+neighbours(1)
               if (mod(i*j*k+neighbours(1),2) == 0) then
                  bin_m3b(i,j,k) = TRUE
               else
                  bin_m3b(i,j,k) = FALSE
               end if
               cpx_m3b(i,j,k) = cmplx(real(i**3+neighbours(1)*3)/54 + real(k)*0.05432,real(k+neighbours(1)*3)*5433.43 + real(j)**(1/2)*65 )
               real_m3b(i,j,k) = real(i**4+3*neighbours(1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4b(i,j,k,l) = i*j*k*l+neighbours(1)
                  cpx_m4b(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(1) + j)**(1/2)*65)
                  real_m4b(i,j,k,l) = real(neighbours(1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5b(i,j,k,l,m) = i*j*k*l-m+neighbours(1)
                     cpx_m5b(i,j,k,l,m) = cmplx(real(i**3+neighbours(1))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5b(i,j,k,l,m) = real(i**l+neighbours(1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      if (neighbours.dim >1) then
         ! Initialise all the variables for send testing.
         write(str_c,*) neighbours(2)
         int_c  = 4+3*neighbours(2)
         bin_c  = (mod(neighbours(2),2)==0)
         cpx_c  = cmplx(4.3,123.2)+3*real(neighbours(2))
         real_c = 1.34+3*real(neighbours(2))
         str_vc  = [str_c,str_c]
         int_vc  = [4+3*neighbours(2),2+3*neighbours(2)]
         bin_vc  = [(mod(neighbours(2),2)==0),(mod(neighbours(2),2)==0)]
         cpx_vc  = [cmplx(4.3,123.2)+neighbours(2)*3,cmplx(6.7,5.7)+neighbours(2)*3]
         real_vc = [1.34+real(neighbours(2)*3),34.5+real(neighbours(2))*3]
         str_mc(1,:) = [str_c,str_c,str_c] 
         str_mc(2,:) = [str_c,str_c,str_c] 
         str_mc(3,:) = [str_c,str_c,str_c] 
         do i = 1,3
            do j = 1,3
               int_mc(i,j) = i*j
               if (mod(i*j+neighbours(2),2) == 0) then
                  bin_mc(i,j) = TRUE
               else
                  bin_mc(i,j) = FALSE
               end if
               cpx_mc(i,j) = cmplx(real(i**3+neighbours(2)*3)/54,real(j)**(1/2)+neighbours(2)*3*65)
               real_mc(i,j) = real(i**4+neighbours(2)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3c(i,j,k) = i*j*k+neighbours(2)
                  if (mod(i*j*k+neighbours(2),2) == 0) then
                     bin_m3c(i,j,k) = TRUE
                  else
                     bin_m3c(i,j,k) = FALSE
                  end if
                  cpx_m3c(i,j,k) = cmplx(real(i**3+neighbours(2)*3)/54 + real(k)*0.05432,real(k+neighbours(2)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3c(i,j,k) = real(i**4+3*neighbours(2))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4c(i,j,k,l) = i*j*k*l+neighbours(2)
                     cpx_m4c(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(2) + j)**(1/2)*65)
                     real_m4c(i,j,k,l) = real(neighbours(2)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5c(i,j,k,l,m) = i*j*k*l-m+neighbours(2)
                        cpx_m5c(i,j,k,l,m) = cmplx(real(i**3+neighbours(2))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j**(1/2))*65)
                        real_m5c(i,j,k,l,m) = real(i**l+neighbours(2))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>2) then
         ! Initialise all the variables for send testing.
         write(str_d,*) neighbours(3)
         int_d  = 4+3*neighbours(3)
         bin_d  = (mod(neighbours(3),2)==0)
         cpx_d  = cmplx(4.3,123.2)+3*real(neighbours(3))
         real_d = 1.34+3*real(neighbours(3))
         str_vd  = [str_d,str_d]
         int_vd  = [4+3*neighbours(3),2+3*neighbours(3)]
         bin_vd  = [(mod(neighbours(3),2)==0),(mod(neighbours(3),2)==0)]
         cpx_vd  = [cmplx(4.3,123.2)+neighbours(3)*3,cmplx(6.7,5.7)+neighbours(3)*3]
         real_vd = [1.34+real(neighbours(3)*3),34.5+real(neighbours(3))*3]
         str_md(1,:) = [str_d,str_d,str_d] 
         str_md(2,:) = [str_d,str_d,str_d] 
         str_md(3,:) = [str_d,str_d,str_d] 
         do i = 1,3
            do j = 1,3
               int_md(i,j) = i*j
               if (mod(i*j+neighbours(3),2) == 0) then
                  bin_md(i,j) = TRUE
               else
                  bin_md(i,j) = FALSE
               end if
               cpx_md(i,j) = cmplx(real(i**3+neighbours(3)*3)/54,real(j)**(1/2)+neighbours(3)*3*65)
               real_md(i,j) = real(i**4+neighbours(3)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3d(i,j,k) = i*j*k+neighbours(3)
                  if (mod(i*j*k+neighbours(3),2) == 0) then
                     bin_m3d(i,j,k) = TRUE
                  else
                     bin_m3d(i,j,k) = FALSE
                  end if
                  cpx_m3d(i,j,k) = cmplx(real(i**3+neighbours(3)*3)/54 + real(k)*0.05432,real(k+neighbours(3)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3d(i,j,k) = real(i**4+3*neighbours(3))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4d(i,j,k,l) = i*j*k*l+neighbours(3)
                     cpx_m4d(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(3) + j)**(1/2)*65)
                     real_m4d(i,j,k,l) = real(neighbours(3)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5d(i,j,k,l,m) = i*j*k*l-m+neighbours(3)
                        cpx_m5d(i,j,k,l,m) = cmplx(real(i**3+neighbours(3))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5d(i,j,k,l,m) = real(i**l+neighbours(3))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>3) then
         ! Initialise all the variables for send testing.
         write(str_e,*) neighbours(4)
         int_e  = 4+3*neighbours(4)
         bin_e  = (mod(neighbours(4),2)==0)
         cpx_e  = cmplx(4.3,123.2)+3*real(neighbours(4))
         real_e = 1.34+3*real(neighbours(4))
         str_ve  = [str_e,str_e]
         int_ve  = [4+3*neighbours(4),2+3*neighbours(4)]
         bin_ve  = [(mod(neighbours(4),2)==0),(mod(neighbours(4),2)==0)]
         cpx_ve  = [cmplx(4.3,123.2)+neighbours(4)*3,cmplx(6.7,5.7)+neighbours(4)*3]
         real_ve = [1.34+real(neighbours(4)*3),34.5+real(neighbours(4)*3)]
         str_me(1,:) = [str_e,str_e,str_e] 
         str_me(2,:) = [str_e,str_e,str_e] 
         str_me(3,:) = [str_e,str_e,str_e] 
         do i = 1,3
            do j = 1,3
               int_me(i,j) = i*j
               if (mod(i*j+neighbours(4),2) == 0) then
                  bin_me(i,j) = TRUE
               else
                  bin_me(i,j) = FALSE
               end if
               cpx_me(i,j) = cmplx(real(i**3+neighbours(4)*3)/54,real(j)**(1/2)+real(neighbours(4)*3*65))
               real_me(i,j) = real(i**4+neighbours(4)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3e(i,j,k) = i*j*k+neighbours(4)
                  if (mod(i*j*k+neighbours(4),2) == 0) then
                     bin_m3e(i,j,k) = TRUE
                  else
                     bin_m3e(i,j,k) = FALSE
                  end if
                  cpx_m3e(i,j,k) = cmplx(real(i**3+neighbours(4)*3)/54 + real(k)*0.05432,real(k+neighbours(4)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3e(i,j,k) = real(i**4+3*neighbours(4))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4e(i,j,k,l) = i*j*k*l+neighbours(4)
                     cpx_m4e(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(4) + j)**(1/2)*65)
                     real_m4e(i,j,k,l) = real(neighbours(4)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5e(i,j,k,l,m) = i*j*k*l-m+neighbours(4)
                        cpx_m5e(i,j,k,l,m) = cmplx(real(i**3+neighbours(4))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5e(i,j,k,l,m) = real(i**l+neighbours(4))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 


      ! Call the routines

      ! Single numbers
      .test_ssend(rank,neighbours,mpi,str_a,str_b,str_c,str_d,str_e)
      .test_ssend(rank,neighbours,mpi,int_a,int_b,int_c,int_d,int_e)
      .test_ssend(rank,neighbours,mpi,bin_a,bin_b,bin_c,bin_d,bin_e)
      .test_ssend(rank,neighbours,mpi,real_a,real_b,real_c,real_d,real_e)
      .test_ssend(rank,neighbours,mpi,cpx_a,cpx_b,cpx_c,cpx_d,cpx_e)
   
      ! Vectors
      .test_ssend(rank,neighbours,mpi,str_va,str_vb,str_vc,str_vd,str_ve)
      .test_ssend(rank,neighbours,mpi,int_va,int_vb,int_vc,int_vd,int_ve)
      .test_ssend(rank,neighbours,mpi,bin_va,bin_vb,bin_vc,bin_vd,bin_ve)
      .test_ssend(rank,neighbours,mpi,real_va,real_vb,real_vc,real_vd,real_ve)
      .test_ssend(rank,neighbours,mpi,cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve)
      
      ! Matrix
      .test_ssend(rank,neighbours,mpi,str_ma,str_mb,str_mc,str_md,str_me)
      .test_ssend(rank,neighbours,mpi,int_ma,int_mb,int_mc,int_md,int_me)
      .test_ssend(rank,neighbours,mpi,bin_ma,bin_mb,bin_mc,bin_md,bin_me)
      .test_ssend(rank,neighbours,mpi,real_ma,real_mb,real_mc,real_md,real_me)
      .test_ssend(rank,neighbours,mpi,cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me)
      
      ! Matrix 3s
      .test_ssend(rank,neighbours,mpi,int_m3a,int_m3b,int_m3c,int_m3d,int_m3e)
      .test_ssend(rank,neighbours,mpi,bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e)
      .test_ssend(rank,neighbours,mpi,real_m3a,real_m3b,real_m3c,real_m3d,real_m3e)
      .test_ssend(rank,neighbours,mpi,cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e)
      !
      ! Matrix 4s
      .test_ssend(rank,neighbours,mpi,int_m4a,int_m4b,int_m4c,int_m4d,int_m4e)
      .test_ssend(rank,neighbours,mpi,real_m4a,real_m4b,real_m4c,real_m4d,real_m4e)
      .test_ssend(rank,neighbours,mpi,cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e)
      !
      ! Matrix 5s
      .test_ssend(rank,neighbours,mpi,int_m5a,int_m5b,int_m5c,int_m5d,int_m5e)
      .test_ssend(rank,neighbours,mpi,real_m5a,real_m5b,real_m5c,real_m5d,real_m5e)
      .test_ssend(rank,neighbours,mpi,cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e)
      
   
   end

   isending_mpi_test(mpi,neighbours) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      neighbours :: VEC{INT}, IN
      i,j,k,l,m,rank,int_a,int_b,int_c,int_d,int_e :: INT
      str_a,str_b,str_c,str_d,str_e     :: STR
      bin_a,bin_b,bin_c,bin_d,bin_e     :: BIN
      cpx_a,cpx_b,cpx_c,cpx_d,cpx_e     :: CPX
      real_a,real_b,real_c,real_d,real_e   :: REAL
      int_va,int_vb,int_vc,int_vd,int_ve   :: VEC{INT}@
      str_va,str_vb,str_vc,str_vd,str_ve   :: VEC{STR}@
      bin_va,bin_vb,bin_vc,bin_vd,bin_ve   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve   :: VEC{CPX}@
      real_va,real_vb,real_vc,real_vd,real_ve :: VEC{REAL}@
      int_ma,int_mb,int_mc,int_md,int_me   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mc,str_md,str_me   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mc,bin_md,bin_me   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mc,real_md,real_me :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3c,int_m3d,int_m3e   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3c,real_m3d,real_m3e :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4c,int_m4d,int_m4e   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4c,real_m4d,real_m4e :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5c,real_m5d,real_m5e :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b,int_m5c,int_m5d,int_m5e :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      write(str_a,*) rank
      int_a  = 4+3*rank
      bin_a  = (mod(rank,2)==0)
      cpx_a  = cmplx(4.3,123.2)+3*real(rank)
      real_a = 1.34+3*real(rank)
      str_va  = [str_a,str_a]
      int_va  = [4+3*rank,2+3*rank]
      bin_va  = [(mod(rank,2)==0),(mod(rank,2)==0)]
      cpx_va  = [cmplx(4.3,123.2)+rank*3,cmplx(6.7,5.7)+rank*3]
      real_va = [1.34+real(rank*3),34.5+real(rank*3)]
      str_ma(1,:) = [str_a,str_a,str_a] 
      str_ma(2,:) = [str_a,str_a,str_a] 
      str_ma(3,:) = [str_a,str_a,str_a] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (mod(i*j+rank,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3+rank*3)/54,real(j)**(1/2)+real(rank*3)*65)
            real_ma(i,j) = real(i**4+rank*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+rank
               if (mod(i*j*k+rank,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3+rank*3)/54 + real(k)*0.05432,real(k+rank*3)*5433.43 + real(j)**(1/2)*65) 
               real_m3a(i,j,k) = real(i**4+3*rank)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+rank
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(rank + j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(rank+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+rank
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3+rank)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l+rank)+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Initialise all the variables for send testing.
      write(str_b,*) neighbours(1)
      int_b  = 4+3*neighbours(1)
      bin_b  = (mod(neighbours(1),2)==0)
      cpx_b  = cmplx(4.3,123.2)+3*real(neighbours(1))
      real_b = 1.34+3*real(neighbours(1))
      str_vb  = [str_b,str_b]
      int_vb  = [4+3*neighbours(1),2+3*neighbours(1)]
      bin_vb  = [(mod(neighbours(1),2)==0),(mod(neighbours(1),2)==0)]
      cpx_vb  = [cmplx(4.3,123.2)+neighbours(1)*3,cmplx(6.7,5.7)+neighbours(1)*3]
      real_vb = [1.34+real(neighbours(1))*3,34.5+real(neighbours(1))*3]
      str_mb(1,:) = [str_b,str_b,str_b] 
      str_mb(2,:) = [str_b,str_b,str_b] 
      str_mb(3,:) = [str_b,str_b,str_b] 
      do i = 1,3
         do j = 1,3
            int_mb(i,j) = i*j
            if (mod(i*j+neighbours(1),2) == 0) then
               bin_mb(i,j) = TRUE
            else
               bin_mb(i,j) = FALSE
            end if
            cpx_mb(i,j) = cmplx(real(i**3+neighbours(1)*3)/54,real(j)**(1/2)+real(neighbours(1)*3)*65)
            real_mb(i,j) = real(i**4+neighbours(1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3b(i,j,k) = i*j*k+neighbours(1)
               if (mod(i*j*k+neighbours(1),2) == 0) then
                  bin_m3b(i,j,k) = TRUE
               else
                  bin_m3b(i,j,k) = FALSE
               end if
               cpx_m3b(i,j,k) = cmplx(real(i**3+neighbours(1)*3)/54 + real(k)*0.05432,real(k+neighbours(1)*3)*5433.43 + real(j)**(1/2)*65 )
               real_m3b(i,j,k) = real(i**4+3*neighbours(1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4b(i,j,k,l) = i*j*k*l+neighbours(1)
                  cpx_m4b(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(1) + j)**(1/2)*65)
                  real_m4b(i,j,k,l) = real(neighbours(1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5b(i,j,k,l,m) = i*j*k*l-m+neighbours(1)
                     cpx_m5b(i,j,k,l,m) = cmplx(real(i**3+neighbours(1))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5b(i,j,k,l,m) = real(i**l+neighbours(1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      if (neighbours.dim >1) then
         ! Initialise all the variables for send testing.
         write(str_c,*) neighbours(2)
         int_c  = 4+3*neighbours(2)
         bin_c  = (mod(neighbours(2),2)==0)
         cpx_c  = cmplx(4.3,123.2)+3*real(neighbours(2))
         real_c = 1.34+3*real(neighbours(2))
         str_vc  = [str_c,str_c]
         int_vc  = [4+3*neighbours(2),2+3*neighbours(2)]
         bin_vc  = [(mod(neighbours(2),2)==0),(mod(neighbours(2),2)==0)]
         cpx_vc  = [cmplx(4.3,123.2)+neighbours(2)*3,cmplx(6.7,5.7)+neighbours(2)*3]
         real_vc = [1.34+real(neighbours(2)*3),34.5+real(neighbours(2))*3]
         str_mc(1,:) = [str_c,str_c,str_c] 
         str_mc(2,:) = [str_c,str_c,str_c] 
         str_mc(3,:) = [str_c,str_c,str_c] 
         do i = 1,3
            do j = 1,3
               int_mc(i,j) = i*j
               if (mod(i*j+neighbours(2),2) == 0) then
                  bin_mc(i,j) = TRUE
               else
                  bin_mc(i,j) = FALSE
               end if
               cpx_mc(i,j) = cmplx(real(i**3+neighbours(2)*3)/54,real(j)**(1/2)+neighbours(2)*3*65)
               real_mc(i,j) = real(i**4+neighbours(2)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3c(i,j,k) = i*j*k+neighbours(2)
                  if (mod(i*j*k+neighbours(2),2) == 0) then
                     bin_m3c(i,j,k) = TRUE
                  else
                     bin_m3c(i,j,k) = FALSE
                  end if
                  cpx_m3c(i,j,k) = cmplx(real(i**3+neighbours(2)*3)/54 + real(k)*0.05432,real(k+neighbours(2)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3c(i,j,k) = real(i**4+3*neighbours(2))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4c(i,j,k,l) = i*j*k*l+neighbours(2)
                     cpx_m4c(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(2) + j)**(1/2)*65)
                     real_m4c(i,j,k,l) = real(neighbours(2)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5c(i,j,k,l,m) = i*j*k*l-m+neighbours(2)
                        cpx_m5c(i,j,k,l,m) = cmplx(real(i**3+neighbours(2))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j**(1/2))*65)
                        real_m5c(i,j,k,l,m) = real(i**l+neighbours(2))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>2) then
         ! Initialise all the variables for send testing.
         write(str_d,*) neighbours(3)
         int_d  = 4+3*neighbours(3)
         bin_d  = (mod(neighbours(3),2)==0)
         cpx_d  = cmplx(4.3,123.2)+3*real(neighbours(3))
         real_d = 1.34+3*real(neighbours(3))
         str_vd  = [str_d,str_d]
         int_vd  = [4+3*neighbours(3),2+3*neighbours(3)]
         bin_vd  = [(mod(neighbours(3),2)==0),(mod(neighbours(3),2)==0)]
         cpx_vd  = [cmplx(4.3,123.2)+neighbours(3)*3,cmplx(6.7,5.7)+neighbours(3)*3]
         real_vd = [1.34+real(neighbours(3)*3),34.5+real(neighbours(3))*3]
         str_md(1,:) = [str_d,str_d,str_d] 
         str_md(2,:) = [str_d,str_d,str_d] 
         str_md(3,:) = [str_d,str_d,str_d] 
         do i = 1,3
            do j = 1,3
               int_md(i,j) = i*j
               if (mod(i*j+neighbours(3),2) == 0) then
                  bin_md(i,j) = TRUE
               else
                  bin_md(i,j) = FALSE
               end if
               cpx_md(i,j) = cmplx(real(i**3+neighbours(3)*3)/54,real(j)**(1/2)+neighbours(3)*3*65)
               real_md(i,j) = real(i**4+neighbours(3)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3d(i,j,k) = i*j*k+neighbours(3)
                  if (mod(i*j*k+neighbours(3),2) == 0) then
                     bin_m3d(i,j,k) = TRUE
                  else
                     bin_m3d(i,j,k) = FALSE
                  end if
                  cpx_m3d(i,j,k) = cmplx(real(i**3+neighbours(3)*3)/54 + real(k)*0.05432,real(k+neighbours(3)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3d(i,j,k) = real(i**4+3*neighbours(3))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4d(i,j,k,l) = i*j*k*l+neighbours(3)
                     cpx_m4d(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(3) + j)**(1/2)*65)
                     real_m4d(i,j,k,l) = real(neighbours(3)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5d(i,j,k,l,m) = i*j*k*l-m+neighbours(3)
                        cpx_m5d(i,j,k,l,m) = cmplx(real(i**3+neighbours(3))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5d(i,j,k,l,m) = real(i**l+neighbours(3))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>3) then
         ! Initialise all the variables for send testing.
         write(str_e,*) neighbours(4)
         int_e  = 4+3*neighbours(4)
         bin_e  = (mod(neighbours(4),2)==0)
         cpx_e  = cmplx(4.3,123.2)+3*real(neighbours(4))
         real_e = 1.34+3*real(neighbours(4))
         str_ve  = [str_e,str_e]
         int_ve  = [4+3*neighbours(4),2+3*neighbours(4)]
         bin_ve  = [(mod(neighbours(4),2)==0),(mod(neighbours(4),2)==0)]
         cpx_ve  = [cmplx(4.3,123.2)+neighbours(4)*3,cmplx(6.7,5.7)+neighbours(4)*3]
         real_ve = [1.34+real(neighbours(4)*3),34.5+real(neighbours(4)*3)]
         str_me(1,:) = [str_e,str_e,str_e] 
         str_me(2,:) = [str_e,str_e,str_e] 
         str_me(3,:) = [str_e,str_e,str_e] 
         do i = 1,3
            do j = 1,3
               int_me(i,j) = i*j
               if (mod(i*j+neighbours(4),2) == 0) then
                  bin_me(i,j) = TRUE
               else
                  bin_me(i,j) = FALSE
               end if
               cpx_me(i,j) = cmplx(real(i**3+neighbours(4)*3)/54,real(j)**(1/2)+real(neighbours(4)*3*65))
               real_me(i,j) = real(i**4+neighbours(4)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3e(i,j,k) = i*j*k+neighbours(4)
                  if (mod(i*j*k+neighbours(4),2) == 0) then
                     bin_m3e(i,j,k) = TRUE
                  else
                     bin_m3e(i,j,k) = FALSE
                  end if
                  cpx_m3e(i,j,k) = cmplx(real(i**3+neighbours(4)*3)/54 + real(k)*0.05432,real(k+neighbours(4)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3e(i,j,k) = real(i**4+3*neighbours(4))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4e(i,j,k,l) = i*j*k*l+neighbours(4)
                     cpx_m4e(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(4) + j)**(1/2)*65)
                     real_m4e(i,j,k,l) = real(neighbours(4)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5e(i,j,k,l,m) = i*j*k*l-m+neighbours(4)
                        cpx_m5e(i,j,k,l,m) = cmplx(real(i**3+neighbours(4))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5e(i,j,k,l,m) = real(i**l+neighbours(4))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 


      ! Call the routines

      ! Single numbers
      .test_isend(rank,neighbours,mpi,str_a,str_b,str_c,str_d,str_e)
      .test_isend(rank,neighbours,mpi,int_a,int_b,int_c,int_d,int_e)
      .test_isend(rank,neighbours,mpi,bin_a,bin_b,bin_c,bin_d,bin_e)
      .test_isend(rank,neighbours,mpi,real_a,real_b,real_c,real_d,real_e)
      .test_isend(rank,neighbours,mpi,cpx_a,cpx_b,cpx_c,cpx_d,cpx_e)
   
      ! Vectors
      .test_isend(rank,neighbours,mpi,str_va,str_vb,str_vc,str_vd,str_ve)
      .test_isend(rank,neighbours,mpi,int_va,int_vb,int_vc,int_vd,int_ve)
      .test_isend(rank,neighbours,mpi,bin_va,bin_vb,bin_vc,bin_vd,bin_ve)
      .test_isend(rank,neighbours,mpi,real_va,real_vb,real_vc,real_vd,real_ve)
      .test_isend(rank,neighbours,mpi,cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve)
      
      ! Matrix
      .test_isend(rank,neighbours,mpi,str_ma,str_mb,str_mc,str_md,str_me)
      .test_isend(rank,neighbours,mpi,int_ma,int_mb,int_mc,int_md,int_me)
      .test_isend(rank,neighbours,mpi,bin_ma,bin_mb,bin_mc,bin_md,bin_me)
      .test_isend(rank,neighbours,mpi,real_ma,real_mb,real_mc,real_md,real_me)
      .test_isend(rank,neighbours,mpi,cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me)
      
      ! Matrix 3s
      .test_isend(rank,neighbours,mpi,int_m3a,int_m3b,int_m3c,int_m3d,int_m3e)
      .test_isend(rank,neighbours,mpi,bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e)
      .test_isend(rank,neighbours,mpi,real_m3a,real_m3b,real_m3c,real_m3d,real_m3e)
      .test_isend(rank,neighbours,mpi,cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e)
      !
      ! Matrix 4s
      .test_isend(rank,neighbours,mpi,int_m4a,int_m4b,int_m4c,int_m4d,int_m4e)
      .test_isend(rank,neighbours,mpi,real_m4a,real_m4b,real_m4c,real_m4d,real_m4e)
      .test_isend(rank,neighbours,mpi,cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e)
      !
      ! Matrix 5s
      .test_isend(rank,neighbours,mpi,int_m5a,int_m5b,int_m5c,int_m5d,int_m5e)
      .test_isend(rank,neighbours,mpi,real_m5a,real_m5b,real_m5c,real_m5d,real_m5e)
      .test_isend(rank,neighbours,mpi,cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e)
      
   
   end

   issending_mpi_test(mpi,neighbours) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      neighbours :: VEC{INT}, IN
      i,j,k,l,m,rank,int_a,int_b,int_c,int_d,int_e :: INT
      str_a,str_b,str_c,str_d,str_e     :: STR
      bin_a,bin_b,bin_c,bin_d,bin_e     :: BIN
      cpx_a,cpx_b,cpx_c,cpx_d,cpx_e     :: CPX
      real_a,real_b,real_c,real_d,real_e   :: REAL
      int_va,int_vb,int_vc,int_vd,int_ve   :: VEC{INT}@
      str_va,str_vb,str_vc,str_vd,str_ve   :: VEC{STR}@
      bin_va,bin_vb,bin_vc,bin_vd,bin_ve   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve   :: VEC{CPX}@
      real_va,real_vb,real_vc,real_vd,real_ve :: VEC{REAL}@
      int_ma,int_mb,int_mc,int_md,int_me   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mc,str_md,str_me   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mc,bin_md,bin_me   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mc,real_md,real_me :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3c,int_m3d,int_m3e   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3c,real_m3d,real_m3e :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4c,int_m4d,int_m4e   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4c,real_m4d,real_m4e :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5c,real_m5d,real_m5e :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b,int_m5c,int_m5d,int_m5e :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      write(str_a,*) rank
      int_a  = 4+3*rank
      bin_a  = (mod(rank,2)==0)
      cpx_a  = cmplx(4.3,123.2)+3*real(rank)
      real_a = 1.34+3*real(rank)
      str_va  = [str_a,str_a]
      int_va  = [4+3*rank,2+3*rank]
      bin_va  = [(mod(rank,2)==0),(mod(rank,2)==0)]
      cpx_va  = [cmplx(4.3,123.2)+rank*3,cmplx(6.7,5.7)+rank*3]
      real_va = [1.34+real(rank*3),34.5+real(rank*3)]
      str_ma(1,:) = [str_a,str_a,str_a] 
      str_ma(2,:) = [str_a,str_a,str_a] 
      str_ma(3,:) = [str_a,str_a,str_a] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (mod(i*j+rank,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3+rank*3)/54,real(j)**(1/2)+real(rank*3)*65)
            real_ma(i,j) = real(i**4+rank*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+rank
               if (mod(i*j*k+rank,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3+rank*3)/54 + real(k)*0.05432,real(k+rank*3)*5433.43 + real(j)**(1/2)*65) 
               real_m3a(i,j,k) = real(i**4+3*rank)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+rank
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(rank + j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(rank+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+rank
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3+rank)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l+rank)+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Initialise all the variables for send testing.
      write(str_b,*) neighbours(1)
      int_b  = 4+3*neighbours(1)
      bin_b  = (mod(neighbours(1),2)==0)
      cpx_b  = cmplx(4.3,123.2)+3*real(neighbours(1))
      real_b = 1.34+3*real(neighbours(1))
      str_vb  = [str_b,str_b]
      int_vb  = [4+3*neighbours(1),2+3*neighbours(1)]
      bin_vb  = [(mod(neighbours(1),2)==0),(mod(neighbours(1),2)==0)]
      cpx_vb  = [cmplx(4.3,123.2)+neighbours(1)*3,cmplx(6.7,5.7)+neighbours(1)*3]
      real_vb = [1.34+real(neighbours(1))*3,34.5+real(neighbours(1))*3]
      str_mb(1,:) = [str_b,str_b,str_b] 
      str_mb(2,:) = [str_b,str_b,str_b] 
      str_mb(3,:) = [str_b,str_b,str_b] 
      do i = 1,3
         do j = 1,3
            int_mb(i,j) = i*j
            if (mod(i*j+neighbours(1),2) == 0) then
               bin_mb(i,j) = TRUE
            else
               bin_mb(i,j) = FALSE
            end if
            cpx_mb(i,j) = cmplx(real(i**3+neighbours(1)*3)/54,real(j)**(1/2)+real(neighbours(1)*3)*65)
            real_mb(i,j) = real(i**4+neighbours(1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3b(i,j,k) = i*j*k+neighbours(1)
               if (mod(i*j*k+neighbours(1),2) == 0) then
                  bin_m3b(i,j,k) = TRUE
               else
                  bin_m3b(i,j,k) = FALSE
               end if
               cpx_m3b(i,j,k) = cmplx(real(i**3+neighbours(1)*3)/54 + real(k)*0.05432,real(k+neighbours(1)*3)*5433.43 + real(j)**(1/2)*65 )
               real_m3b(i,j,k) = real(i**4+3*neighbours(1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4b(i,j,k,l) = i*j*k*l+neighbours(1)
                  cpx_m4b(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(1) + j)**(1/2)*65)
                  real_m4b(i,j,k,l) = real(neighbours(1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5b(i,j,k,l,m) = i*j*k*l-m+neighbours(1)
                     cpx_m5b(i,j,k,l,m) = cmplx(real(i**3+neighbours(1))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5b(i,j,k,l,m) = real(i**l+neighbours(1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      if (neighbours.dim >1) then
         ! Initialise all the variables for send testing.
         write(str_c,*) neighbours(2)
         int_c  = 4+3*neighbours(2)
         bin_c  = (mod(neighbours(2),2)==0)
         cpx_c  = cmplx(4.3,123.2)+3*real(neighbours(2))
         real_c = 1.34+3*real(neighbours(2))
         str_vc  = [str_c,str_c]
         int_vc  = [4+3*neighbours(2),2+3*neighbours(2)]
         bin_vc  = [(mod(neighbours(2),2)==0),(mod(neighbours(2),2)==0)]
         cpx_vc  = [cmplx(4.3,123.2)+neighbours(2)*3,cmplx(6.7,5.7)+neighbours(2)*3]
         real_vc = [1.34+real(neighbours(2)*3),34.5+real(neighbours(2))*3]
         str_mc(1,:) = [str_c,str_c,str_c] 
         str_mc(2,:) = [str_c,str_c,str_c] 
         str_mc(3,:) = [str_c,str_c,str_c] 
         do i = 1,3
            do j = 1,3
               int_mc(i,j) = i*j
               if (mod(i*j+neighbours(2),2) == 0) then
                  bin_mc(i,j) = TRUE
               else
                  bin_mc(i,j) = FALSE
               end if
               cpx_mc(i,j) = cmplx(real(i**3+neighbours(2)*3)/54,real(j)**(1/2)+neighbours(2)*3*65)
               real_mc(i,j) = real(i**4+neighbours(2)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3c(i,j,k) = i*j*k+neighbours(2)
                  if (mod(i*j*k+neighbours(2),2) == 0) then
                     bin_m3c(i,j,k) = TRUE
                  else
                     bin_m3c(i,j,k) = FALSE
                  end if
                  cpx_m3c(i,j,k) = cmplx(real(i**3+neighbours(2)*3)/54 + real(k)*0.05432,real(k+neighbours(2)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3c(i,j,k) = real(i**4+3*neighbours(2))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4c(i,j,k,l) = i*j*k*l+neighbours(2)
                     cpx_m4c(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(2) + j)**(1/2)*65)
                     real_m4c(i,j,k,l) = real(neighbours(2)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5c(i,j,k,l,m) = i*j*k*l-m+neighbours(2)
                        cpx_m5c(i,j,k,l,m) = cmplx(real(i**3+neighbours(2))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j**(1/2))*65)
                        real_m5c(i,j,k,l,m) = real(i**l+neighbours(2))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>2) then
         ! Initialise all the variables for send testing.
         write(str_d,*) neighbours(3)
         int_d  = 4+3*neighbours(3)
         bin_d  = (mod(neighbours(3),2)==0)
         cpx_d  = cmplx(4.3,123.2)+3*real(neighbours(3))
         real_d = 1.34+3*real(neighbours(3))
         str_vd  = [str_d,str_d]
         int_vd  = [4+3*neighbours(3),2+3*neighbours(3)]
         bin_vd  = [(mod(neighbours(3),2)==0),(mod(neighbours(3),2)==0)]
         cpx_vd  = [cmplx(4.3,123.2)+neighbours(3)*3,cmplx(6.7,5.7)+neighbours(3)*3]
         real_vd = [1.34+real(neighbours(3)*3),34.5+real(neighbours(3))*3]
         str_md(1,:) = [str_d,str_d,str_d] 
         str_md(2,:) = [str_d,str_d,str_d] 
         str_md(3,:) = [str_d,str_d,str_d] 
         do i = 1,3
            do j = 1,3
               int_md(i,j) = i*j
               if (mod(i*j+neighbours(3),2) == 0) then
                  bin_md(i,j) = TRUE
               else
                  bin_md(i,j) = FALSE
               end if
               cpx_md(i,j) = cmplx(real(i**3+neighbours(3)*3)/54,real(j)**(1/2)+neighbours(3)*3*65)
               real_md(i,j) = real(i**4+neighbours(3)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3d(i,j,k) = i*j*k+neighbours(3)
                  if (mod(i*j*k+neighbours(3),2) == 0) then
                     bin_m3d(i,j,k) = TRUE
                  else
                     bin_m3d(i,j,k) = FALSE
                  end if
                  cpx_m3d(i,j,k) = cmplx(real(i**3+neighbours(3)*3)/54 + real(k)*0.05432,real(k+neighbours(3)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3d(i,j,k) = real(i**4+3*neighbours(3))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4d(i,j,k,l) = i*j*k*l+neighbours(3)
                     cpx_m4d(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(3) + j)**(1/2)*65)
                     real_m4d(i,j,k,l) = real(neighbours(3)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5d(i,j,k,l,m) = i*j*k*l-m+neighbours(3)
                        cpx_m5d(i,j,k,l,m) = cmplx(real(i**3+neighbours(3))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5d(i,j,k,l,m) = real(i**l+neighbours(3))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>3) then
         ! Initialise all the variables for send testing.
         write(str_e,*) neighbours(4)
         int_e  = 4+3*neighbours(4)
         bin_e  = (mod(neighbours(4),2)==0)
         cpx_e  = cmplx(4.3,123.2)+3*real(neighbours(4))
         real_e = 1.34+3*real(neighbours(4))
         str_ve  = [str_e,str_e]
         int_ve  = [4+3*neighbours(4),2+3*neighbours(4)]
         bin_ve  = [(mod(neighbours(4),2)==0),(mod(neighbours(4),2)==0)]
         cpx_ve  = [cmplx(4.3,123.2)+neighbours(4)*3,cmplx(6.7,5.7)+neighbours(4)*3]
         real_ve = [1.34+real(neighbours(4)*3),34.5+real(neighbours(4)*3)]
         str_me(1,:) = [str_e,str_e,str_e] 
         str_me(2,:) = [str_e,str_e,str_e] 
         str_me(3,:) = [str_e,str_e,str_e] 
         do i = 1,3
            do j = 1,3
               int_me(i,j) = i*j
               if (mod(i*j+neighbours(4),2) == 0) then
                  bin_me(i,j) = TRUE
               else
                  bin_me(i,j) = FALSE
               end if
               cpx_me(i,j) = cmplx(real(i**3+neighbours(4)*3)/54,real(j)**(1/2)+real(neighbours(4)*3*65))
               real_me(i,j) = real(i**4+neighbours(4)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3e(i,j,k) = i*j*k+neighbours(4)
                  if (mod(i*j*k+neighbours(4),2) == 0) then
                     bin_m3e(i,j,k) = TRUE
                  else
                     bin_m3e(i,j,k) = FALSE
                  end if
                  cpx_m3e(i,j,k) = cmplx(real(i**3+neighbours(4)*3)/54 + real(k)*0.05432,real(k+neighbours(4)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3e(i,j,k) = real(i**4+3*neighbours(4))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4e(i,j,k,l) = i*j*k*l+neighbours(4)
                     cpx_m4e(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(4) + j)**(1/2)*65)
                     real_m4e(i,j,k,l) = real(neighbours(4)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5e(i,j,k,l,m) = i*j*k*l-m+neighbours(4)
                        cpx_m5e(i,j,k,l,m) = cmplx(real(i**3+neighbours(4))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5e(i,j,k,l,m) = real(i**l+neighbours(4))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 


      ! Call the routines

      ! Single numbers
      .test_issend(rank,neighbours,mpi,str_a,str_b,str_c,str_d,str_e)
      .test_issend(rank,neighbours,mpi,int_a,int_b,int_c,int_d,int_e)
      .test_issend(rank,neighbours,mpi,bin_a,bin_b,bin_c,bin_d,bin_e)
      .test_issend(rank,neighbours,mpi,real_a,real_b,real_c,real_d,real_e)
      .test_issend(rank,neighbours,mpi,cpx_a,cpx_b,cpx_c,cpx_d,cpx_e)
   
      ! Vectors
      .test_issend(rank,neighbours,mpi,str_va,str_vb,str_vc,str_vd,str_ve)
      .test_issend(rank,neighbours,mpi,int_va,int_vb,int_vc,int_vd,int_ve)
      .test_issend(rank,neighbours,mpi,bin_va,bin_vb,bin_vc,bin_vd,bin_ve)
      .test_issend(rank,neighbours,mpi,real_va,real_vb,real_vc,real_vd,real_ve)
      .test_issend(rank,neighbours,mpi,cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve)
      
      ! Matrix
      .test_issend(rank,neighbours,mpi,str_ma,str_mb,str_mc,str_md,str_me)
      .test_issend(rank,neighbours,mpi,int_ma,int_mb,int_mc,int_md,int_me)
      .test_issend(rank,neighbours,mpi,bin_ma,bin_mb,bin_mc,bin_md,bin_me)
      .test_issend(rank,neighbours,mpi,real_ma,real_mb,real_mc,real_md,real_me)
      .test_issend(rank,neighbours,mpi,cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me)
      
      ! Matrix 3s
      .test_issend(rank,neighbours,mpi,int_m3a,int_m3b,int_m3c,int_m3d,int_m3e)
      .test_issend(rank,neighbours,mpi,bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e)
      .test_issend(rank,neighbours,mpi,real_m3a,real_m3b,real_m3c,real_m3d,real_m3e)
      .test_issend(rank,neighbours,mpi,cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e)
      !
      ! Matrix 4s
      .test_issend(rank,neighbours,mpi,int_m4a,int_m4b,int_m4c,int_m4d,int_m4e)
      .test_issend(rank,neighbours,mpi,real_m4a,real_m4b,real_m4c,real_m4d,real_m4e)
      .test_issend(rank,neighbours,mpi,cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e)
      !
      ! Matrix 5s
      .test_issend(rank,neighbours,mpi,int_m5a,int_m5b,int_m5c,int_m5d,int_m5e)
      .test_issend(rank,neighbours,mpi,real_m5a,real_m5b,real_m5c,real_m5d,real_m5e)
      .test_issend(rank,neighbours,mpi,cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e)
      
   
   end

   sendrecv_mpi_test(mpi,neighbours) :::  public
   ! This routine calls and tests all sendrecv functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      neighbours :: VEC{INT}, IN
      i,j,k,l,m,rank,int_a,int_b,int_c,int_d,int_e :: INT
      str_a,str_b,str_c,str_d,str_e     :: STR
      bin_a,bin_b,bin_c,bin_d,bin_e     :: BIN
      cpx_a,cpx_b,cpx_c,cpx_d,cpx_e     :: CPX
      real_a,real_b,real_c,real_d,real_e   :: REAL
      int_va,int_vb,int_vc,int_vd,int_ve   :: VEC{INT}@
      str_va,str_vb,str_vc,str_vd,str_ve   :: VEC{STR}@
      bin_va,bin_vb,bin_vc,bin_vd,bin_ve   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve   :: VEC{CPX}@
      real_va,real_vb,real_vc,real_vd,real_ve :: VEC{REAL}@
      int_ma,int_mb,int_mc,int_md,int_me   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mc,str_md,str_me   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mc,bin_md,bin_me   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mc,real_md,real_me :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3c,int_m3d,int_m3e   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3c,real_m3d,real_m3e :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4c,int_m4d,int_m4e   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4c,real_m4d,real_m4e :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5c,real_m5d,real_m5e :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b,int_m5c,int_m5d,int_m5e :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      write(str_a,*) rank
      int_a  = 4+3*rank
      bin_a  = (mod(rank,2)==0)
      cpx_a  = cmplx(4.3,123.2)+3*real(rank)
      real_a = 1.34+3*real(rank)
      str_va  = [str_a,str_a]
      int_va  = [4+3*rank,2+3*rank]
      bin_va  = [(mod(rank,2)==0),(mod(rank,2)==0)]
      cpx_va  = [cmplx(4.3,123.2)+rank*3,cmplx(6.7,5.7)+rank*3]
      real_va = [1.34+real(rank*3),34.5+real(rank*3)]
      str_ma(1,:) = [str_a,str_a,str_a] 
      str_ma(2,:) = [str_a,str_a,str_a] 
      str_ma(3,:) = [str_a,str_a,str_a] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (mod(i*j+rank,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3+rank*3)/54,real(j)**(1/2)+real(rank*3)*65)
            real_ma(i,j) = real(i**4+rank*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+rank
               if (mod(i*j*k+rank,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3+rank*3)/54 + real(k)*0.05432,real(k+rank*3)*5433.43 + real(j)**(1/2)*65) 
               real_m3a(i,j,k) = real(i**4+3*rank)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+rank
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(rank + j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(rank+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+rank
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3+rank)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l+rank)+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Initialise all the variables for send testing.
      write(str_b,*) neighbours(1)
      int_b  = 4+3*neighbours(1)
      bin_b  = (mod(neighbours(1),2)==0)
      cpx_b  = cmplx(4.3,123.2)+3*real(neighbours(1))
      real_b = 1.34+3*real(neighbours(1))
      str_vb  = [str_b,str_b]
      int_vb  = [4+3*neighbours(1),2+3*neighbours(1)]
      bin_vb  = [(mod(neighbours(1),2)==0),(mod(neighbours(1),2)==0)]
      cpx_vb  = [cmplx(4.3,123.2)+neighbours(1)*3,cmplx(6.7,5.7)+neighbours(1)*3]
      real_vb = [1.34+real(neighbours(1))*3,34.5+real(neighbours(1))*3]
      str_mb(1,:) = [str_b,str_b,str_b] 
      str_mb(2,:) = [str_b,str_b,str_b] 
      str_mb(3,:) = [str_b,str_b,str_b] 
      do i = 1,3
         do j = 1,3
            int_mb(i,j) = i*j
            if (mod(i*j+neighbours(1),2) == 0) then
               bin_mb(i,j) = TRUE
            else
               bin_mb(i,j) = FALSE
            end if
            cpx_mb(i,j) = cmplx(real(i**3+neighbours(1)*3)/54,real(j)**(1/2)+real(neighbours(1)*3)*65)
            real_mb(i,j) = real(i**4+neighbours(1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3b(i,j,k) = i*j*k+neighbours(1)
               if (mod(i*j*k+neighbours(1),2) == 0) then
                  bin_m3b(i,j,k) = TRUE
               else
                  bin_m3b(i,j,k) = FALSE
               end if
               cpx_m3b(i,j,k) = cmplx(real(i**3+neighbours(1)*3)/54 + real(k)*0.05432,real(k+neighbours(1)*3)*5433.43 + real(j)**(1/2)*65 )
               real_m3b(i,j,k) = real(i**4+3*neighbours(1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4b(i,j,k,l) = i*j*k*l+neighbours(1)
                  cpx_m4b(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(1) + j)**(1/2)*65)
                  real_m4b(i,j,k,l) = real(neighbours(1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5b(i,j,k,l,m) = i*j*k*l-m+neighbours(1)
                     cpx_m5b(i,j,k,l,m) = cmplx(real(i**3+neighbours(1))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5b(i,j,k,l,m) = real(i**l+neighbours(1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      if (neighbours.dim >1) then
         ! Initialise all the variables for send testing.
         write(str_c,*) neighbours(2)
         int_c  = 4+3*neighbours(2)
         bin_c  = (mod(neighbours(2),2)==0)
         cpx_c  = cmplx(4.3,123.2)+3*real(neighbours(2))
         real_c = 1.34+3*real(neighbours(2))
         str_vc  = [str_c,str_c]
         int_vc  = [4+3*neighbours(2),2+3*neighbours(2)]
         bin_vc  = [(mod(neighbours(2),2)==0),(mod(neighbours(2),2)==0)]
         cpx_vc  = [cmplx(4.3,123.2)+neighbours(2)*3,cmplx(6.7,5.7)+neighbours(2)*3]
         real_vc = [1.34+real(neighbours(2)*3),34.5+real(neighbours(2))*3]
         str_mc(1,:) = [str_c,str_c,str_c] 
         str_mc(2,:) = [str_c,str_c,str_c] 
         str_mc(3,:) = [str_c,str_c,str_c] 
         do i = 1,3
            do j = 1,3
               int_mc(i,j) = i*j
               if (mod(i*j+neighbours(2),2) == 0) then
                  bin_mc(i,j) = TRUE
               else
                  bin_mc(i,j) = FALSE
               end if
               cpx_mc(i,j) = cmplx(real(i**3+neighbours(2)*3)/54,real(j)**(1/2)+neighbours(2)*3*65)
               real_mc(i,j) = real(i**4+neighbours(2)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3c(i,j,k) = i*j*k+neighbours(2)
                  if (mod(i*j*k+neighbours(2),2) == 0) then
                     bin_m3c(i,j,k) = TRUE
                  else
                     bin_m3c(i,j,k) = FALSE
                  end if
                  cpx_m3c(i,j,k) = cmplx(real(i**3+neighbours(2)*3)/54 + real(k)*0.05432,real(k+neighbours(2)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3c(i,j,k) = real(i**4+3*neighbours(2))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4c(i,j,k,l) = i*j*k*l+neighbours(2)
                     cpx_m4c(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(2) + j)**(1/2)*65)
                     real_m4c(i,j,k,l) = real(neighbours(2)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5c(i,j,k,l,m) = i*j*k*l-m+neighbours(2)
                        cpx_m5c(i,j,k,l,m) = cmplx(real(i**3+neighbours(2))/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j**(1/2))*65)
                        real_m5c(i,j,k,l,m) = real(i**l+neighbours(2))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>2) then
         ! Initialise all the variables for send testing.
         write(str_d,*) neighbours(3)
         int_d  = 4+3*neighbours(3)
         bin_d  = (mod(neighbours(3),2)==0)
         cpx_d  = cmplx(4.3,123.2)+3*real(neighbours(3))
         real_d = 1.34+3*real(neighbours(3))
         str_vd  = [str_d,str_d]
         int_vd  = [4+3*neighbours(3),2+3*neighbours(3)]
         bin_vd  = [(mod(neighbours(3),2)==0),(mod(neighbours(3),2)==0)]
         cpx_vd  = [cmplx(4.3,123.2)+neighbours(3)*3,cmplx(6.7,5.7)+neighbours(3)*3]
         real_vd = [1.34+real(neighbours(3)*3),34.5+real(neighbours(3))*3]
         str_md(1,:) = [str_d,str_d,str_d] 
         str_md(2,:) = [str_d,str_d,str_d] 
         str_md(3,:) = [str_d,str_d,str_d] 
         do i = 1,3
            do j = 1,3
               int_md(i,j) = i*j
               if (mod(i*j+neighbours(3),2) == 0) then
                  bin_md(i,j) = TRUE
               else
                  bin_md(i,j) = FALSE
               end if
               cpx_md(i,j) = cmplx(real(i**3+neighbours(3)*3)/54,real(j)**(1/2)+neighbours(3)*3*65)
               real_md(i,j) = real(i**4+neighbours(3)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3d(i,j,k) = i*j*k+neighbours(3)
                  if (mod(i*j*k+neighbours(3),2) == 0) then
                     bin_m3d(i,j,k) = TRUE
                  else
                     bin_m3d(i,j,k) = FALSE
                  end if
                  cpx_m3d(i,j,k) = cmplx(real(i**3+neighbours(3)*3)/54 + real(k)*0.05432,real(k+neighbours(3)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3d(i,j,k) = real(i**4+3*neighbours(3))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4d(i,j,k,l) = i*j*k*l+neighbours(3)
                     cpx_m4d(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(3) + j)**(1/2)*65)
                     real_m4d(i,j,k,l) = real(neighbours(3)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5d(i,j,k,l,m) = i*j*k*l-m+neighbours(3)
                        cpx_m5d(i,j,k,l,m) = cmplx(real(i**3+neighbours(3))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5d(i,j,k,l,m) = real(i**l+neighbours(3))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 
      if (neighbours.dim>3) then
         ! Initialise all the variables for send testing.
         write(str_e,*) neighbours(4)
         int_e  = 4+3*neighbours(4)
         bin_e  = (mod(neighbours(4),2)==0)
         cpx_e  = cmplx(4.3,123.2)+3*real(neighbours(4))
         real_e = 1.34+3*real(neighbours(4))
         str_ve  = [str_e,str_e]
         int_ve  = [4+3*neighbours(4),2+3*neighbours(4)]
         bin_ve  = [(mod(neighbours(4),2)==0),(mod(neighbours(4),2)==0)]
         cpx_ve  = [cmplx(4.3,123.2)+neighbours(4)*3,cmplx(6.7,5.7)+neighbours(4)*3]
         real_ve = [1.34+real(neighbours(4)*3),34.5+real(neighbours(4)*3)]
         str_me(1,:) = [str_e,str_e,str_e] 
         str_me(2,:) = [str_e,str_e,str_e] 
         str_me(3,:) = [str_e,str_e,str_e] 
         do i = 1,3
            do j = 1,3
               int_me(i,j) = i*j
               if (mod(i*j+neighbours(4),2) == 0) then
                  bin_me(i,j) = TRUE
               else
                  bin_me(i,j) = FALSE
               end if
               cpx_me(i,j) = cmplx(real(i**3+neighbours(4)*3)/54,real(j)**(1/2)+real(neighbours(4)*3*65))
               real_me(i,j) = real(i**4+neighbours(4)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3e(i,j,k) = i*j*k+neighbours(4)
                  if (mod(i*j*k+neighbours(4),2) == 0) then
                     bin_m3e(i,j,k) = TRUE
                  else
                     bin_m3e(i,j,k) = FALSE
                  end if
                  cpx_m3e(i,j,k) = cmplx(real(i**3+neighbours(4)*3)/54 + real(k)*0.05432,real(k+neighbours(4)*3)*5433.43 + real(j)**(1/2)*65) 
                  real_m3e(i,j,k) = real(i**4+3*neighbours(4))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4e(i,j,k,l) = i*j*k*l+neighbours(4)
                     cpx_m4e(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 + real(neighbours(4) + j)**(1/2)*65)
                     real_m4e(i,j,k,l) = real(neighbours(4)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5e(i,j,k,l,m) = i*j*k*l-m+neighbours(4)
                        cpx_m5e(i,j,k,l,m) = cmplx(real(i**3+neighbours(4))/54 + real(l)*0.05432,real(k)*real(m)*433.43 + real(j)**(1/2)*65)
                        real_m5e(i,j,k,l,m) = real(i**l+neighbours(4))+real(j)**(1/real(m)) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
      end if 


      ! Call the routines

      ! Single numbers
      .test_sendrecv(rank,neighbours,mpi,str_a,str_b,str_c,str_d,str_e)
      .test_sendrecv(rank,neighbours,mpi,int_a,int_b,int_c,int_d,int_e)
      .test_sendrecv(rank,neighbours,mpi,bin_a,bin_b,bin_c,bin_d,bin_e)
      .test_sendrecv(rank,neighbours,mpi,real_a,real_b,real_c,real_d,real_e)
      .test_sendrecv(rank,neighbours,mpi,cpx_a,cpx_b,cpx_c,cpx_d,cpx_e)
   
      ! Vectors
      .test_sendrecv(rank,neighbours,mpi,str_va,str_vb,str_vc,str_vd,str_ve)
      .test_sendrecv(rank,neighbours,mpi,int_va,int_vb,int_vc,int_vd,int_ve)
      .test_sendrecv(rank,neighbours,mpi,bin_va,bin_vb,bin_vc,bin_vd,bin_ve)
      .test_sendrecv(rank,neighbours,mpi,real_va,real_vb,real_vc,real_vd,real_ve)
      .test_sendrecv(rank,neighbours,mpi,cpx_va,cpx_vb,cpx_vc,cpx_vd,cpx_ve)
      
      ! Matrix
      .test_sendrecv(rank,neighbours,mpi,str_ma,str_mb,str_mc,str_md,str_me)
      .test_sendrecv(rank,neighbours,mpi,int_ma,int_mb,int_mc,int_md,int_me)
      .test_sendrecv(rank,neighbours,mpi,bin_ma,bin_mb,bin_mc,bin_md,bin_me)
      .test_sendrecv(rank,neighbours,mpi,real_ma,real_mb,real_mc,real_md,real_me)
      .test_sendrecv(rank,neighbours,mpi,cpx_ma,cpx_mb,cpx_mc,cpx_md,cpx_me)
      
      ! Matrix 3s
      .test_sendrecv(rank,neighbours,mpi,int_m3a,int_m3b,int_m3c,int_m3d,int_m3e)
      .test_sendrecv(rank,neighbours,mpi,bin_m3a,bin_m3b,bin_m3c,bin_m3d,bin_m3e)
      .test_sendrecv(rank,neighbours,mpi,real_m3a,real_m3b,real_m3c,real_m3d,real_m3e)
      .test_sendrecv(rank,neighbours,mpi,cpx_m3a,cpx_m3b,cpx_m3c,cpx_m3d,cpx_m3e)
      !
      ! Matrix 4s
      .test_sendrecv(rank,neighbours,mpi,int_m4a,int_m4b,int_m4c,int_m4d,int_m4e)
      .test_sendrecv(rank,neighbours,mpi,real_m4a,real_m4b,real_m4c,real_m4d,real_m4e)
      .test_sendrecv(rank,neighbours,mpi,cpx_m4a,cpx_m4b,cpx_m4c,cpx_m4d,cpx_m4e)
      !
      ! Matrix 5s
      .test_sendrecv(rank,neighbours,mpi,int_m5a,int_m5b,int_m5c,int_m5d,int_m5e)
      .test_sendrecv(rank,neighbours,mpi,real_m5a,real_m5b,real_m5c,real_m5d,real_m5e)
      .test_sendrecv(rank,neighbours,mpi,cpx_m5a,cpx_m5b,cpx_m5c,cpx_m5d,cpx_m5e)
   
   end

   gather_mpi_test(mpi) :::  public
   ! This routine calls and tests gather functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a :: INT
      str_a     :: STR
      bin_a     :: BIN
      cpx_a     :: CPX
      real_a   :: REAL
      int_va,int_vb,int_b,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_b,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_b,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_b,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_b,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      int_m5b,int_m5t   :: MAT5{INT}@
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_b(commsize))
      allocate(str_t(commsize))
      allocate(int_b(commsize))
      allocate(int_t(commsize))
      allocate(bin_b(commsize))
      allocate(bin_t(commsize))
      allocate(real_b(commsize))
      allocate(real_t(commsize))
      allocate(cpx_b(commsize))
      allocate(cpx_t(commsize))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_gather(commsize,rank,mpi,str_t,str_a,str_b)
      .test_gather(commsize,rank,mpi,int_t,int_a,int_b)
      .test_gather(commsize,rank,mpi,bin_t,bin_a,bin_b)
      .test_gather(commsize,rank,mpi,real_t,real_a,real_b)
      .test_gather(commsize,rank,mpi,cpx_t,cpx_a,cpx_b)
      deallocate(str_b)
      deallocate(str_t)
      deallocate(int_b)
      deallocate(int_t)
      deallocate(bin_b)
      deallocate(bin_t)
      deallocate(real_b)
      deallocate(real_t)
      deallocate(cpx_b)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(commsize*str_va.dim))
      allocate(int_vb(commsize*int_va.dim))
      allocate(bin_vb(commsize*bin_va.dim))
      allocate(real_vb(commsize*real_va.dim))
      allocate(cpx_vb(commsize*cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_gather(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_gather(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_gather(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_gather(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_gather(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mb(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,commsize*cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_gather(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_gather(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_gather(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_gather(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_gather(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      !if(rank == 1) then   
      !   print*, "======="
      !   print*, "Complex:"
      !   print*, "======="
      !   do i = 1, cpx_mb.dim1
      !      do j = 1,cpx_mb.dim2
      !         print*,"M(",i,",",j,"): ",  cpx_mb(i,j)
      !         print*,"T(",i,",",j,"): ",  cpx_mt(i,j)
      !      end do
      !   end do
      !end if
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_gather(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_gather(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_gather(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_gather(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_gather(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_gather(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_gather(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      int_m5t = 0
      real_m5t = 0.0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
      end do
      .test_gather(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_gather(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_gather(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(int_m5b)
      deallocate(cpx_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   
   end

   igather_mpi_test(mpi) :::  public
   ! This routine calls and tests gather functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a :: INT
      reqs :: VEC{INT}@
      str_a     :: STR
      bin_a     :: BIN
      cpx_a     :: CPX
      real_a   :: REAL
      int_va,int_vb,int_b,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_b,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_b,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_b,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_b,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      int_m5b,int_m5t   :: MAT5{INT}@
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_b(commsize))
      allocate(str_t(commsize))
      allocate(int_b(commsize))
      allocate(int_t(commsize))
      allocate(bin_b(commsize))
      allocate(bin_t(commsize))
      allocate(real_b(commsize))
      allocate(real_t(commsize))
      allocate(cpx_b(commsize))
      allocate(cpx_t(commsize))
      allocate(reqs(5))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_igather(commsize,rank,mpi,str_a,str_b,i)
      reqs(1) = i
      .test_igather(commsize,rank,mpi,int_a,int_b,i)
      reqs(2) = i
      .test_igather(commsize,rank,mpi,bin_a,bin_b,i)
      reqs(3) = i
      .test_igather(commsize,rank,mpi,real_a,real_b,i)
      reqs(4) = i
      .test_igather(commsize,rank,mpi,cpx_a,cpx_b,i)
      reqs(5) = i
         print*, "waiting"
         i = reqs(1)
         mpi.parallel_wait(i)
         i = reqs(2)
         mpi.parallel_wait(i)
         i = reqs(3)
         mpi.parallel_wait(i)
         i = reqs(4)
         mpi.parallel_wait(i)
         i = reqs(5)
         mpi.parallel_wait(i)
         print*, "I'm done waiting"
      if(rank == 1) then
         print*, "Moving to check now"
         if (all(str_b == str_t)) then
            print*, "MPI can succesfully gather the type STR in a nonblocking way"
         else
            print*, "MPI failed to gather the type STR in a nonblocking way"
         end if
         if (all(int_b == int_t)) then
            print*, "MPI can succesfully gather the type INT in a nonblocking way"
         else
            print*, "MPI failed to gather the type INT in a non blocking way"
         end if
         if (all(bin_b EQV bin_t)) then
            print*, "MPI can succesfully gather the type BIN"
         else
            print*, "MPI failed to gather the type BIN"
         end if
         if (all(real_b == real_t)) then
            print*, "MPI can succesfully gather the type REAL"
         else
            print*, "MPI failed to gather the type REAL"
         end if
         if (all(cpx_b == cpx_t)) then
            print*, "MPI can succesfully gather the type CPX"
         else
            print*, "MPI failed to gather the type CPX"
         end if
      end if
      mpi.barrier
      stop
      deallocate(str_b)
      deallocate(str_t)
      deallocate(int_b)
      deallocate(int_t)
      deallocate(bin_b)
      deallocate(bin_t)
      deallocate(real_b)
      deallocate(real_t)
      deallocate(cpx_b)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(commsize*str_va.dim))
      allocate(int_vb(commsize*int_va.dim))
      allocate(bin_vb(commsize*bin_va.dim))
      allocate(real_vb(commsize*real_va.dim))
      allocate(cpx_vb(commsize*cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_igather(commsize,rank,mpi,str_va,str_vb,i)
      print*,"Sent: ",  str_va
      if(rank == 1) then   
         print*, "======="
         print*, "STR:"
         print*, "======="
         do i = 1, str_vb.dim
               print*,"M(",i,"): ",  str_vb(i)
               print*,"T(",i,"): ",  str_vt(i)
         end do
      end if
      .test_igather(commsize,rank,mpi,int_va,int_vb,i)
      if(rank == 1) then   
         print*, "======="
         print*, "INT:"
         print*, "======="
         do i = 1, int_vb.dim
               print*,"M(",i,"): ",  int_vb(i)
               print*,"T(",i,"): ",  int_vt(i)
         end do
      end if
      .test_igather(commsize,rank,mpi,bin_va,bin_vb,i)
      .test_igather(commsize,rank,mpi,real_va,real_vb,i)
      .test_igather(commsize,rank,mpi,cpx_va,cpx_vb,i)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mb(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,commsize*cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_igather(commsize,rank,mpi,str_ma,str_mb,i)
      .test_igather(commsize,rank,mpi,int_ma,int_mb,i)
      .test_igather(commsize,rank,mpi,bin_ma,bin_mb,i)
      .test_igather(commsize,rank,mpi,real_ma,real_mb,i)
      .test_igather(commsize,rank,mpi,cpx_ma,cpx_mb,i)
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_igather(commsize,rank,mpi,int_m3a,int_m3b,i)
      .test_igather(commsize,rank,mpi,bin_m3a,bin_m3b,i)
      .test_igather(commsize,rank,mpi,real_m3a,real_m3b,i)
      .test_igather(commsize,rank,mpi,cpx_m3a,cpx_m3b,i)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_igather(commsize,rank,mpi,int_m4a,int_m4b,i)
      .test_igather(commsize,rank,mpi,real_m4a,real_m4b,i)
      .test_igather(commsize,rank,mpi,cpx_m4a,cpx_m4b,i)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      int_m5t = 0
      real_m5t = 0.0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
      end do
      .test_igather(commsize,rank,mpi,real_m5a,real_m5b,i)
      .test_igather(commsize,rank,mpi,cpx_m5a,cpx_m5b,i)
      .test_igather(commsize,rank,mpi,int_m5a,int_m5b,i)
      deallocate(real_m5b)
      deallocate(cpx_m5b)
      deallocate(int_m5b)
      deallocate(real_m5t)
      deallocate(cpx_m5t)
      deallocate(int_m5t)
      
   
   end

   allgather_mpi_test(mpi) :::  public
   ! This routine calls and tests gather functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a :: INT
      str_a     :: STR
      bin_a     :: BIN
      cpx_a     :: CPX
      real_a   :: REAL
      int_va,int_vb,int_b,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_b,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_b,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_b,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_b,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      int_m5b,int_m5t   :: MAT5{INT}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_b(commsize))
      allocate(str_t(commsize))
      allocate(int_b(commsize))
      allocate(int_t(commsize))
      allocate(bin_b(commsize))
      allocate(bin_t(commsize))
      allocate(real_b(commsize))
      allocate(real_t(commsize))
      allocate(cpx_b(commsize))
      allocate(cpx_t(commsize))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_allgather(commsize,rank,mpi,str_t,str_a,str_b)
      .test_allgather(commsize,rank,mpi,int_t,int_a,int_b)
      .test_allgather(commsize,rank,mpi,bin_t,bin_a,bin_b)
      .test_allgather(commsize,rank,mpi,real_t,real_a,real_b)
      .test_allgather(commsize,rank,mpi,cpx_t,cpx_a,cpx_b)
      deallocate(str_b)
      deallocate(str_t)
      deallocate(int_b)
      deallocate(int_t)
      deallocate(bin_b)
      deallocate(bin_t)
      deallocate(real_b)
      deallocate(real_t)
      deallocate(cpx_b)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(commsize*str_va.dim))
      allocate(int_vb(commsize*int_va.dim))
      allocate(bin_vb(commsize*bin_va.dim))
      allocate(real_vb(commsize*real_va.dim))
      allocate(cpx_vb(commsize*cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_allgather(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_allgather(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_allgather(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_allgather(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_allgather(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mb(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,commsize*cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_allgather(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_allgather(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_allgather(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_allgather(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_allgather(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      !if(rank == 1) then   
      !   print*, "======="
      !   print*, "Complex:"
      !   print*, "======="
      !   do i = 1, cpx_mb.dim1
      !      do j = 1,cpx_mb.dim2
      !         print*,"M(",i,",",j,"): ",  cpx_mb(i,j)
      !         print*,"T(",i,",",j,"): ",  cpx_mt(i,j)
      !      end do
      !   end do
      !end if
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_allgather(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_allgather(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_allgather(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_allgather(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_allgather(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_allgather(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_allgather(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      int_m5t = 0
      real_m5t = 0.0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
      end do
      .test_allgather(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_allgather(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_allgather(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(int_m5b)
      deallocate(cpx_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   
   end

   bcast_mpi_test(mpi) :::  public
   ! This routine calls and tests the bcast functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_bcast(rank,mpi,str_a,str_b)
      .test_bcast(rank,mpi,int_a,int_b)
      .test_bcast(rank,mpi,bin_a,bin_b)
      .test_bcast(rank,mpi,real_a,real_b)
      .test_bcast(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_bcast(rank,mpi,str_va,str_vb)
      .test_bcast(rank,mpi,int_va,int_vb)
      .test_bcast(rank,mpi,bin_va,bin_vb)
      .test_bcast(rank,mpi,real_va,real_vb)
      .test_bcast(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_bcast(rank,mpi,str_ma,str_mb)
      .test_bcast(rank,mpi,int_ma,int_mb)
      .test_bcast(rank,mpi,bin_ma,bin_mb)
      .test_bcast(rank,mpi,real_ma,real_mb)
      .test_bcast(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_bcast(rank,mpi,int_m3a,int_m3b)
      .test_bcast(rank,mpi,bin_m3a,bin_m3b)
      .test_bcast(rank,mpi,real_m3a,real_m3b)
      .test_bcast(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_bcast(rank,mpi,int_m4a,int_m4b)
      .test_bcast(rank,mpi,real_m4a,real_m4b)
      .test_bcast(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_bcast(rank,mpi,real_m5a,real_m5b)
      .test_bcast(rank,mpi,cpx_m5a,cpx_m5b)
      .test_bcast(rank,mpi,int_m5a,int_m5b)
      
   
   end

   scatter_mpi_test(mpi) :::  public
   ! This routine calls and tests scatter functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      int_m5b,int_m5t   :: MAT5{INT}@
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_t(commsize))
      allocate(int_t(commsize))
      allocate(bin_t(commsize))
      allocate(real_t(commsize))
      allocate(cpx_t(commsize))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_scatter(commsize,rank,mpi,str_t,str_a,str_b)
      .test_scatter(commsize,rank,mpi,int_t,int_a,int_b)
      .test_scatter(commsize,rank,mpi,bin_t,bin_a,bin_b)
      .test_scatter(commsize,rank,mpi,real_t,real_a,real_b)
      .test_scatter(commsize,rank,mpi,cpx_t,cpx_a,cpx_b)
      deallocate(str_t)
      deallocate(int_t)
      deallocate(bin_t)
      deallocate(real_t)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(str_va.dim))
      allocate(int_vb(int_va.dim))
      allocate(bin_vb(bin_va.dim))
      allocate(real_vb(real_va.dim))
      allocate(cpx_vb(cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_scatter(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_scatter(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_scatter(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_scatter(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_scatter(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,str_ma.dim2))
      allocate(int_mb(int_ma.dim1,int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_scatter(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_scatter(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_scatter(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_scatter(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_scatter(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      !if(rank == 1) then   
      !   print*, "======="
      !   print*, "Complex:"
      !   print*, "======="
      !   do i = 1, cpx_mb.dim1
      !      do j = 1,cpx_mb.dim2
      !         print*,"M(",i,",",j,"): ",  cpx_mb(i,j)
      !         print*,"T(",i,",",j,"): ",  cpx_mt(i,j)
      !      end do
      !   end do
      !end if
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_scatter(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_scatter(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_scatter(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_scatter(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_scatter(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_scatter(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_scatter(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      real_m5t = 0.0
      int_m5t  = 0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
      end do
      .test_scatter(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_scatter(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_scatter(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(cpx_m5b)
      deallocate(int_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   
   end

   alltoall_mpi_test(mpi) :::  public
   ! This routine calls and tests alltoall functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize :: INT
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}@ 
      str_ma   :: MAT{STR}@
      bin_ma   :: MAT{BIN}@
      cpx_ma   :: MAT{CPX}@
      real_ma :: MAT{REAL}@
      int_mt   :: MAT{INT}@
      str_mt   :: MAT{STR}@
      bin_mt   :: MAT{BIN}@
      cpx_mt   :: MAT{CPX}@
      real_mt :: MAT{REAL}@
      int_mb   :: MAT{INT}@
      str_mb   :: MAT{STR}@
      bin_mb   :: MAT{BIN}@
      cpx_mb   :: MAT{CPX}@
      real_mb :: MAT{REAL}@
      int_m3a   :: MAT3{INT}@
      bin_m3a   :: MAT3{BIN}@
      cpx_m3a   :: MAT3{CPX}@
      real_m3a :: MAT3{REAL}@
      int_m3t   :: MAT3{INT}@
      bin_m3t   :: MAT3{BIN}@
      cpx_m3t   :: MAT3{CPX}@
      real_m3t :: MAT3{REAL}@
      int_m3b   :: MAT3{INT}@
      bin_m3b   :: MAT3{BIN}@
      cpx_m3b   :: MAT3{CPX}@
      real_m3b :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}@
      cpx_m4a   :: MAT4{CPX}@
      real_m4a :: MAT4{REAL}@
      int_m4b   :: MAT4{INT}@
      cpx_m4b   :: MAT4{CPX}@
      real_m4b :: MAT4{REAL}@
      int_m4t   :: MAT4{INT}@
      cpx_m4t   :: MAT4{CPX}@
      real_m4t :: MAT4{REAL}@
      int_m5a   :: MAT5{INT}@ 
      cpx_m5a   :: MAT5{CPX}@
      real_m5a :: MAT5{REAL}@
      int_m5b   :: MAT5{INT}@
      cpx_m5b   :: MAT5{CPX}@
      real_m5b :: MAT5{REAL}@
      int_m5t   :: MAT5{INT}@
      cpx_m5t   :: MAT5{CPX}@
      real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      allocate(str_va(2*commsize))
      allocate(int_va(2*commsize))
      allocate(bin_va(2*commsize))
      allocate(cpx_va(2*commsize))
      allocate(real_va(2*commsize))
      do i = 1,commsize
         str_va(2*(i-1)+1:2*i)  = ["blah","dogg"]
         int_va(2*(i-1)+1:2*i)  = [i,i]
         bin_va(2*(i-1)+1:2*i)  = [TRUE,FALSE]
         cpx_va(2*(i-1)+1:2*i)  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
         real_va(2*(i-1)+1:2*i) = [1.34,34.5]
      end do
      allocate(str_ma(2,2*commsize))
      allocate(int_ma(2,2*commsize))
      allocate(bin_ma(2,2*commsize))
      allocate(cpx_ma(2,2*commsize))
      allocate(real_ma(2,2*commsize))
      allocate(int_m3a(2,2,2*commsize))
      allocate(bin_m3a(2,2,2*commsize))
      allocate(cpx_m3a(2,2,2*commsize))
      allocate(real_m3a(2,2,2*commsize))
      allocate(int_m4a(2,2,2,2*commsize))
      allocate(cpx_m4a(2,2,2,2*commsize))
      allocate(real_m4a(2,2,2,2*commsize))
      allocate(int_m5a(2,2,2,2,2*commsize))
      allocate(cpx_m5a(2,2,2,2,2*commsize))
      allocate(real_m5a(2,2,2,2,2*commsize))
      do i = 1,2*commsize
            str_ma(:,i) = ["a","b"] 
         do j = 1,2
            int_ma(j,i) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(j,i) = TRUE
            else
               bin_ma(j,i) = FALSE
            end if
            cpx_ma(j,i) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(j,i) = real(i**4)+real(j**(1/2))
            do k = 1,2
               int_m3a(j,k,i) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(j,k,i) = TRUE
               else
                  bin_m3a(j,k,i) = FALSE
               end if
               cpx_m3a(j,k,i) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(j,k,i) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,2
                  int_m4a(j,k,l,i) = i*j*k*l
                  cpx_m4a(j,k,l,i) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(j,k,l,i) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,2
                     int_m5a(j,k,l,m,i) = i*j*k*l-m
                     cpx_m5a(j,k,l,m,i) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(j,k,l,m,i) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines
   
      ! Vectors
      allocate(str_vb(str_va.dim))
      allocate(int_vb(int_va.dim))
      allocate(bin_vb(bin_va.dim))
      allocate(real_vb(real_va.dim))
      allocate(cpx_vb(cpx_va.dim))
      allocate(str_vt(str_va.dim))
      allocate(int_vt(int_va.dim))
      allocate(bin_vt(bin_va.dim))
      allocate(real_vt(real_va.dim))
      allocate(cpx_vt(cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      str_vb  = ''
      int_vb  = 0
      bin_vb  = FALSE
      real_vb = 0.0
      cpx_vb  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim/commsize+1:i*str_va.dim/commsize) = str_va(rank*str_va.dim/commsize+1:(rank+1)*str_va.dim/commsize)
         int_vt((i-1)*int_va.dim/commsize+1:i*int_va.dim/commsize) = int_va(rank*int_va.dim/commsize+1:(rank+1)*int_va.dim/commsize)
         bin_vt((i-1)*bin_va.dim/commsize+1:i*bin_va.dim/commsize) = bin_va(rank*bin_va.dim/commsize+1:(rank+1)*bin_va.dim/commsize)
         real_vt((i-1)*real_va.dim/commsize+1:i*real_va.dim/commsize) = real_va(rank*real_va.dim/commsize+1:(rank+1)*real_va.dim/commsize)
         cpx_vt((i-1)*cpx_va.dim/commsize+1:i*cpx_va.dim/commsize) = cpx_va(rank*cpx_va.dim/commsize+1:(rank+1)*cpx_va.dim/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_alltoall(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_alltoall(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_alltoall(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_alltoall(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      ! Matrix
      allocate(str_mb(str_ma.dim1,str_ma.dim2))
      allocate(int_mb(int_ma.dim1,int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,str_ma.dim2))
      allocate(int_mt(int_ma.dim1,int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      str_mb  = ''
      int_mb  = 0
      bin_mb  = FALSE
      real_mb = 0.0
      cpx_mb  = cmplx(0.0,0.0)
      
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2/commsize+1:i*str_ma.dim2/commsize) = str_ma(:,rank*str_ma.dim2/commsize+1:(rank+1)*str_ma.dim2/commsize)
         int_mt(:,(i-1)*int_ma.dim2/commsize+1:i*int_ma.dim2/commsize) = int_ma(:,rank*int_ma.dim2/commsize+1:(rank+1)*int_ma.dim2/commsize)
         bin_mt(:,(i-1)*bin_ma.dim2/commsize+1:i*bin_ma.dim2/commsize) = bin_ma(:,rank*bin_ma.dim2/commsize+1:(rank+1)*bin_ma.dim2/commsize)
         real_mt(:,(i-1)*real_ma.dim2/commsize+1:i*real_ma.dim2/commsize) = real_ma(:,rank*real_ma.dim2/commsize+1:(rank+1)*real_ma.dim2/commsize)
         cpx_mt(:,(i-1)*cpx_ma.dim2/commsize+1:i*cpx_ma.dim2/commsize) = cpx_ma(:,rank*cpx_ma.dim2/commsize+1:(rank+1)*cpx_ma.dim2/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_alltoall(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_alltoall(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_alltoall(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_alltoall(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3/commsize+1:i*int_m3a.dim3/commsize) = int_m3a(:,:,rank*int_m3a.dim3/commsize+1:(rank+1)*int_m3a.dim3/commsize)
         bin_m3t(:,:,(i-1)*bin_m3a.dim3/commsize+1:i*bin_m3a.dim3/commsize) = bin_m3a(:,:,rank*bin_m3a.dim3/commsize+1:(rank+1)*bin_m3a.dim3/commsize)
         real_m3t(:,:,(i-1)*real_m3a.dim3/commsize+1:i*real_m3a.dim3/commsize) = real_m3a(:,:,rank*real_m3a.dim3/commsize+1:(rank+1)*real_m3a.dim3/commsize)
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3/commsize+1:i*cpx_m3a.dim3/commsize) = cpx_m3a(:,:,rank*cpx_m3a.dim3/commsize+1:(rank+1)*cpx_m3a.dim3/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_alltoall(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_alltoall(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_alltoall(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4/commsize+1:i*int_m4a.dim4/commsize) = int_m4a(:,:,:,rank*int_m4a.dim4/commsize+1:(rank+1)*int_m4a.dim4/commsize)
         real_m4t(:,:,:,(i-1)*real_m4a.dim4/commsize+1:i*real_m4a.dim4/commsize) = real_m4a(:,:,:,rank*real_m4a.dim4/commsize+1:(rank+1)*real_m4a.dim4/commsize)
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4/commsize+1:i*cpx_m4a.dim4/commsize) = cpx_m4a(:,:,:,rank*cpx_m4a.dim4/commsize+1:(rank+1)*cpx_m4a.dim4/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_alltoall(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_alltoall(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,real_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,cpx_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,int_m5a.dim5))
      real_m5t = 0.0
      int_m5t  = 0 
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5/commsize+1:i*real_m5a.dim5/commsize) = real_m5a(:,:,:,:,rank*real_m5a.dim5/commsize+1:(rank+1)*real_m5a.dim5/commsize)
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5/commsize+1:i*int_m5a.dim5/commsize) = int_m5a(:,:,:,:,rank*int_m5a.dim5/commsize+1:(rank+1)*int_m5a.dim5/commsize)
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5/commsize+1:i*cpx_m5a.dim5/commsize) = cpx_m5a(:,:,:,:,rank*cpx_m5a.dim5/commsize+1:(rank+1)*cpx_m5a.dim5/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_alltoall(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_alltoall(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(int_m5b)
      deallocate(cpx_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      deallocate(str_ma)
      deallocate(int_ma)
      deallocate(bin_ma)
      deallocate(cpx_ma)
      deallocate(real_ma)
      deallocate(int_m3a)
      deallocate(bin_m3a)
      deallocate(cpx_m3a)
      deallocate(real_m3a)
      deallocate(int_m4a)
      deallocate(cpx_m4a)
      deallocate(real_m4a)
      deallocate(int_m5a)
      deallocate(cpx_m5a)
      deallocate(real_m5a)
      
   end

   sum_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_sum and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for reduce_sum testing.
      int_a  = 4  
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      int_va  = [4,2]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j)**(1/2)*65)
            real_ma(i,j) = real(i**4)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j)**(1/2)*65)
               real_m3a(i,j,k) = real(i**4)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j)**(1/real(m)) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_b    =  commsize*int_a
      int_vb   =  commsize*int_va
      int_mb   =  commsize*int_ma
      int_m3b  =  commsize*int_m3a
      int_m4b  =  commsize*int_m4a
      int_m5b  =  commsize*int_m5a
      cpx_b    =  real(commsize)*cpx_a
      real_b   =  real(commsize)*real_a
      cpx_vb   =  real(commsize)*cpx_va
      real_vb  =  real(commsize)*real_va
      cpx_mb   =  real(commsize)*cpx_ma
      real_mb  =  real(commsize)*real_ma
      cpx_m3b  =  real(commsize)*cpx_m3a
      real_m3b =  real(commsize)*real_m3a
      cpx_m4b  =  real(commsize)*cpx_m4a
      real_m4b =  real(commsize)*real_m4a
      cpx_m5b  =  real(commsize)*cpx_m5a
      real_m5b =  real(commsize)*real_m5a 

      
      ! Call the routines

      ! Single numbers
      .test_reduce_sum(rank,mpi,int_a,int_b)
      .test_reduce_sum(rank,mpi,real_a,real_b)
      .test_reduce_sum(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_reduce_sum(rank,mpi,int_va,int_vb)
      .test_reduce_sum(rank,mpi,real_va,real_vb)
      .test_reduce_sum(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_reduce_sum(rank,mpi,int_ma,int_mb)
      .test_reduce_sum(rank,mpi,real_ma,real_mb)
      .test_reduce_sum(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_reduce_sum(rank,mpi,int_m3a,int_m3b)
      .test_reduce_sum(rank,mpi,real_m3a,real_m3b)
      .test_reduce_sum(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_reduce_sum(rank,mpi,int_m4a,int_m4b)
      .test_reduce_sum(rank,mpi,real_m4a,real_m4b)
      .test_reduce_sum(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_reduce_sum(rank,mpi,real_m5a,real_m5b)
      .test_reduce_sum(rank,mpi,cpx_m5a,cpx_m5b)
      .test_reduce_sum(rank,mpi,int_m5a,int_m5b)
      
   
   end

   allsum_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_sum and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for reduce_sum testing.
      int_a  = 4  
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      int_va  = [4,2]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j)**(1/2)*65)
            real_ma(i,j) = real(i**4)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j)**(1/2)*65)
               real_m3a(i,j,k) = real(i**4)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j)**(1/real(m)) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_b    =  commsize*int_a
      int_vb   =  commsize*int_va
      int_mb   =  commsize*int_ma
      int_m3b  =  commsize*int_m3a
      int_m4b  =  commsize*int_m4a
      int_m5b  =  commsize*int_m5a
      cpx_b    =  real(commsize)*cpx_a
      real_b   =  real(commsize)*real_a
      cpx_vb   =  real(commsize)*cpx_va
      real_vb  =  real(commsize)*real_va
      cpx_mb   =  real(commsize)*cpx_ma
      real_mb  =  real(commsize)*real_ma
      cpx_m3b  =  real(commsize)*cpx_m3a
      real_m3b =  real(commsize)*real_m3a
      cpx_m4b  =  real(commsize)*cpx_m4a
      real_m4b =  real(commsize)*real_m4a
      cpx_m5b  =  real(commsize)*cpx_m5a
      real_m5b =  real(commsize)*real_m5a 
      
      ! Call the routines

      ! Single numbers
      .test_parallel_sum(rank,mpi,int_a,int_b)
      .test_parallel_sum(rank,mpi,real_a,real_b)
      .test_parallel_sum(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_parallel_sum(rank,mpi,int_va,int_vb)
      .test_parallel_sum(rank,mpi,real_va,real_vb)
      .test_parallel_sum(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_parallel_sum(rank,mpi,int_ma,int_mb)
      .test_parallel_sum(rank,mpi,real_ma,real_mb)
      .test_parallel_sum(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_parallel_sum(rank,mpi,int_m3a,int_m3b)
      .test_parallel_sum(rank,mpi,real_m3a,real_m3b)
      .test_parallel_sum(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_parallel_sum(rank,mpi,int_m4a,int_m4b)
      .test_parallel_sum(rank,mpi,real_m4a,real_m4b)
      .test_parallel_sum(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_parallel_sum(rank,mpi,real_m5a,real_m5b)
      .test_parallel_sum(rank,mpi,int_m5a,int_m5b)
      .test_parallel_sum(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   scansum_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_sum and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for reduce_sum testing.
      int_a  = 4  
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      int_va  = [4,2]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j)**(1/2)*65)
            real_ma(i,j) = real(i**4)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j)**(1/2)*65)
               real_m3a(i,j,k) = real(i**4)+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j)**(1/2)*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m)*433.43 +  real(j)**(1/2)*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j)**(1/real(m)) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_b    =  (1+rank)*int_a
      int_vb   =  (1+rank)*int_va
      int_mb   =  (1+rank)*int_ma
      int_m3b  =  (1+rank)*int_m3a
      int_m4b  =  (1+rank)*int_m4a
      int_m5b  =  (1+rank)*int_m5a
      cpx_b    =  real(1+rank)*cpx_a
      real_b   =  real(1+rank)*real_a
      cpx_vb   =  real(1+rank)*cpx_va
      real_vb  =  real(1+rank)*real_va
      cpx_mb   =  real(1+rank)*cpx_ma
      real_mb  =  real(1+rank)*real_ma
      cpx_m3b  =  real(1+rank)*cpx_m3a
      real_m3b =  real(1+rank)*real_m3a
      cpx_m4b  =  real(1+rank)*cpx_m4a
      real_m4b =  real(1+rank)*real_m4a
      cpx_m5b  =  real(1+rank)*cpx_m5a
      real_m5b =  real(1+rank)*real_m5a 

      ! Call the routines

      ! Single numbers
      .test_scan_sum(rank,mpi,int_a,int_b)
      .test_scan_sum(rank,mpi,real_a,real_b)
      .test_scan_sum(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_scan_sum(rank,mpi,int_va,int_vb)
      .test_scan_sum(rank,mpi,real_va,real_vb)
      .test_scan_sum(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_scan_sum(rank,mpi,int_ma,int_mb)
      .test_scan_sum(rank,mpi,real_ma,real_mb)
      .test_scan_sum(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_scan_sum(rank,mpi,int_m3a,int_m3b)
      .test_scan_sum(rank,mpi,real_m3a,real_m3b)
      .test_scan_sum(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_scan_sum(rank,mpi,int_m4a,int_m4b)
      .test_scan_sum(rank,mpi,real_m4a,real_m4b)
      .test_scan_sum(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_scan_sum(rank,mpi,real_m5a,real_m5b)
      .test_scan_sum(rank,mpi,cpx_m5a,cpx_m5b)
      .test_scan_sum(rank,mpi,int_m5a,int_m5b)
      
   
   end

   prod_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_prod and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for reduce_prod testing.
      int_a  = 4  
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      int_va  = [4,2]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            cpx_ma(i,j) = cmplx(real(i**3)/5,real(j)*65)
            real_ma(i,j) = real(i**4)+real(j)+0.5
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               cpx_m3a(i,j,k) = cmplx(real(i**3)/5 + real(k),real(k)*0.5 +  real(j)*65)
               real_m3a(i,j,k) = real(i**4)+real(j) +0.5*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/5 + real(l)*0.5,real(k) +  real(j)*65+0.5)
                  real_m4a(i,j,k,l) = real(i**l)+real(j)*3.5 +0.5*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/5 + real(l)*0.5,real(k)*real(m)*0.4 +  real(j)*65)
                     real_m5a(i,j,k,l,m) = real(i*l)+real(j)*real(m)+0.5*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_b    =  int_a  **commsize
      int_vb   =  int_va **commsize
      int_mb   =  int_ma **commsize
      int_m3b  =  int_m3a**commsize
      int_m4b  =  int_m4a**commsize
      int_m5b  =  int_m5a**commsize 
      cpx_b    =  cpx_a   **commsize
      real_b   =  real_a  **commsize
      cpx_vb   =  cpx_va  **commsize
      real_vb  =  real_va **commsize
      cpx_mb   =  cpx_ma  **commsize
      real_mb  =  real_ma **commsize
      cpx_m3b  =  cpx_m3a **commsize
      real_m3b =  real_m3a**commsize
      cpx_m4b  =  cpx_m4a **commsize
      real_m4b =  real_m4a**commsize 
      cpx_m5b  =  cpx_m5a **commsize
      real_m5b =  real_m5a**commsize  

      ! Call the routines

      ! Single numbers
      .test_reduce_prod(rank,mpi,int_a,int_b)
      .test_reduce_prod(rank,mpi,real_a,real_b)
      .test_reduce_prod(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_reduce_prod(rank,mpi,int_va,int_vb)
      .test_reduce_prod(rank,mpi,real_va,real_vb)
      .test_reduce_prod(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_reduce_prod(rank,mpi,int_ma,int_mb)
      .test_reduce_prod(rank,mpi,real_ma,real_mb)
      .test_reduce_prod(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_reduce_prod(rank,mpi,int_m3a,int_m3b)
      .test_reduce_prod(rank,mpi,real_m3a,real_m3b)
      .test_reduce_prod(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_reduce_prod(rank,mpi,int_m4a,int_m4b)
      .test_reduce_prod(rank,mpi,real_m4a,real_m4b)
      .test_reduce_prod(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_reduce_prod(rank,mpi,real_m5a,real_m5b)
      .test_reduce_prod(rank,mpi,int_m5a,int_m5b)
      .test_reduce_prod(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   allprod_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_prod and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for reduce_prod testing.
      int_a  = 4  
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      int_va  = [4,2]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            cpx_ma(i,j) = cmplx(real(i**3)/5,real(j)*65)
            real_ma(i,j) = real(i**4)+real(j)+0.5
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               cpx_m3a(i,j,k) = cmplx(real(i**3)/5 + real(k),real(k)*0.5 +  real(j)*65)
               real_m3a(i,j,k) = real(i**4)+real(j) +0.5*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/5 + real(l)*0.5,real(k) +  real(j)*65+0.5)
                  real_m4a(i,j,k,l) = real(i**l)+real(j)*3.5 +0.5*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/5 + real(l)*0.5,real(k)*real(m)*0.4 +  real(j)*65)
                     real_m5a(i,j,k,l,m) = real(i*l)+real(j)*real(m)+0.5*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_b    =  int_a  **commsize
      int_vb   =  int_va **commsize
      int_mb   =  int_ma **commsize
      int_m3b  =  int_m3a**commsize
      int_m4b  =  int_m4a**commsize
      int_m5b  =  int_m5a**commsize 
      cpx_b    =  cpx_a   **commsize
      real_b   =  real_a  **commsize
      cpx_vb   =  cpx_va  **commsize
      real_vb  =  real_va **commsize
      cpx_mb   =  cpx_ma  **commsize
      real_mb  =  real_ma **commsize
      cpx_m3b  =  cpx_m3a **commsize
      real_m3b =  real_m3a**commsize
      cpx_m4b  =  cpx_m4a **commsize
      real_m4b =  real_m4a**commsize 
      cpx_m5b  =  cpx_m5a **commsize
      real_m5b =  real_m5a**commsize  
      
      ! Call the routines
      
      ! Single numbers
      .test_parallel_prod(rank,mpi,int_a,int_b)
      .test_parallel_prod(rank,mpi,real_a,real_b)
      .test_parallel_prod(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_parallel_prod(rank,mpi,int_va,int_vb)
      .test_parallel_prod(rank,mpi,real_va,real_vb)
      .test_parallel_prod(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_parallel_prod(rank,mpi,int_ma,int_mb)
      .test_parallel_prod(rank,mpi,real_ma,real_mb)
      .test_parallel_prod(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_parallel_prod(rank,mpi,int_m3a,int_m3b)
      .test_parallel_prod(rank,mpi,real_m3a,real_m3b)
      .test_parallel_prod(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_parallel_prod(rank,mpi,int_m4a,int_m4b)
      .test_parallel_prod(rank,mpi,real_m4a,real_m4b)
      .test_parallel_prod(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_parallel_prod(rank,mpi,real_m5a,real_m5b)
      .test_parallel_prod(rank,mpi,int_m5a,int_m5b)
      .test_parallel_prod(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   scanprod_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_prod and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for reduce_prod testing.
      int_a  = 4  
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      int_va  = [4,2]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            cpx_ma(i,j) = cmplx(real(i**3)/5,real(j)*65)
            real_ma(i,j) = real(i**4)+real(j)+0.5
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               cpx_m3a(i,j,k) = cmplx(real(i**3)/5 + real(k),real(k)*0.5 +  real(j)*65)
               real_m3a(i,j,k) = real(i**4)+real(j) +0.5*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/5 + real(l)*0.5,real(k) +  real(j)*65+0.5)
                  real_m4a(i,j,k,l) = real(i**l)+real(j)*3.5 +0.5*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/5 + real(l)*0.5,real(k)*real(m)*0.4 +  real(j)*65)
                     real_m5a(i,j,k,l,m) = real(i*l)+real(j)*real(m)+0.5*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_b    =  int_a   **(rank+1)
      int_vb   =  int_va  **(rank+1)
      int_mb   =  int_ma  **(rank+1)
      int_m3b  =  int_m3a **(rank+1)
      int_m4b  =  int_m4a **(rank+1)
      int_m5b  =  int_m5a **(rank+1) 
      cpx_b    =  cpx_a   **(rank+1)
      real_b   =  real_a  **(rank+1)
      cpx_vb   =  cpx_va  **(rank+1)
      real_vb  =  real_va **(rank+1)
      cpx_mb   =  cpx_ma  **(rank+1)
      real_mb  =  real_ma **(rank+1)
      cpx_m3b  =  cpx_m3a **(rank+1)
      real_m3b =  real_m3a**(rank+1)
      cpx_m4b  =  cpx_m4a **(rank+1)
      real_m4b =  real_m4a**(rank+1) 
      cpx_m5b  =  cpx_m5a **(rank+1)
      real_m5b =  real_m5a**(rank+1)  

      ! Call the routines

      ! Single numbers
      .test_scan_prod(rank,mpi,int_a,int_b)
      .test_scan_prod(rank,mpi,real_a,real_b)
      .test_scan_prod(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_scan_prod(rank,mpi,int_va,int_vb)
      .test_scan_prod(rank,mpi,real_va,real_vb)
      .test_scan_prod(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_scan_prod(rank,mpi,int_ma,int_mb)
      .test_scan_prod(rank,mpi,real_ma,real_mb)
      .test_scan_prod(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_scan_prod(rank,mpi,int_m3a,int_m3b)
      .test_scan_prod(rank,mpi,real_m3a,real_m3b)
      .test_scan_prod(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_scan_prod(rank,mpi,int_m4a,int_m4b)
      .test_scan_prod(rank,mpi,real_m4a,real_m4b)
      .test_scan_prod(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_scan_prod(rank,mpi,real_m5a,real_m5b)
      .test_scan_prod(rank,mpi,int_m5a,int_m5b)
      .test_scan_prod(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   max_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_max and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,a,i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      random,int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(random(commsize))
      do i = 1,commsize
         random(i) = int(100*rand(0))
      end do

      ! Synchronise all instances of the random numbers
      mpi.broadcast(random,0)
      


      ! Initialise all the variables for max testing.
      int_a  = 4+3*random(rank+1)
      real_a = 1.34+3*real(random(rank+1))
      int_va  = [4+3*random(rank+1),2+3*random(rank+1)]
      real_va = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            real_ma(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+random(rank+1)
               real_m3a(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+random(rank+1)
                  real_m4a(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                     real_m5a(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_t=   int_a
      real_t=  real_a
      int_vt=  int_va
      real_vt= real_va
      int_mt=  int_ma
      real_mt= real_ma
      int_m3t= int_m3a
      real_m3t=real_m3a
      int_m4t= int_m4a
      real_m4t=real_m4a
      int_m5t= int_m5a
      real_m5t=real_m5a
      do a = 1, commsize 
         rank = a - 1
         int_b  = 4+3*random(rank+1)
         real_b = 1.34+3*real(random(rank+1))
         int_vb  = [4+3*random(rank+1),2+3*random(rank+1)]
         real_vb = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
         do i = 1,3
            do j = 1,3
               int_mb(i,j) = i*j
               real_mb(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3b(i,j,k) = i*j*k+random(rank+1)
                  real_m3b(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4b(i,j,k,l) = i*j*k*l+random(rank+1)
                     real_m4b(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5b(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                        real_m5b(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
         int_t=max(int_t,int_b)
         real_t=max(real_t,real_b)
         int_vt=max(int_vt,int_vb)
         real_vt=max(real_vt,real_vb)
         int_mt=max(int_mt,int_mb)
         real_mt=max(real_mt,real_mb)
         int_m3t=max(int_m3t,int_m3b)
         real_m3t=max(real_m3t,real_m3b)
         int_m4t=max(int_m4t,int_m4b)
         real_m4t=max(real_m4t,real_m4b)
         int_m5t=max(int_m5t,int_m5b)
         real_m5t=max(real_m5t,real_m5b)
      end do
      
      mpi.comm_rank(rank)
      

      ! Call the routines

      ! Single numbers
      .test_reduce_max(rank,mpi,int_a,int_b,int_t)
      .test_reduce_max(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_reduce_max(rank,mpi,int_va,int_vb,int_vt)
      .test_reduce_max(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_reduce_max(rank,mpi,int_ma,int_mb,int_mt)
      .test_reduce_max(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_reduce_max(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_reduce_max(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_reduce_max(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_reduce_max(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_reduce_max(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_reduce_max(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   allmax_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_max and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,a,i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      random,int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(random(commsize))
      do i = 1,commsize
         random(i) = int(100*rand(0))
      end do

      ! Synchronise all instances of the random numbers
      mpi.broadcast(random,0)
      


      ! Initialise all the variables for max testing.
      int_a  = 4+3*random(rank+1)
      real_a = 1.34+3*real(random(rank+1))
      int_va  = [4+3*random(rank+1),2+3*random(rank+1)]
      real_va = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            real_ma(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+random(rank+1)
               real_m3a(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+random(rank+1)
                  real_m4a(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                     real_m5a(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_t=   int_a
      real_t=  real_a
      int_vt=  int_va
      real_vt= real_va
      int_mt=  int_ma
      real_mt= real_ma
      int_m3t= int_m3a
      real_m3t=real_m3a
      int_m4t= int_m4a
      real_m4t=real_m4a
      int_m5t= int_m5a
      real_m5t=real_m5a
      do a = 1, commsize 
         rank = a - 1
         int_b  = 4+3*random(rank+1)
         real_b = 1.34+3*real(random(rank+1))
         int_vb  = [4+3*random(rank+1),2+3*random(rank+1)]
         real_vb = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
         do i = 1,3
            do j = 1,3
               int_mb(i,j) = i*j
               real_mb(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3b(i,j,k) = i*j*k+random(rank+1)
                  real_m3b(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4b(i,j,k,l) = i*j*k*l+random(rank+1)
                     real_m4b(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5b(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                        real_m5b(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
         int_t=max(int_t,int_b)
         real_t=max(real_t,real_b)
         int_vt=max(int_vt,int_vb)
         real_vt=max(real_vt,real_vb)
         int_mt=max(int_mt,int_mb)
         real_mt=max(real_mt,real_mb)
         int_m3t=max(int_m3t,int_m3b)
         real_m3t=max(real_m3t,real_m3b)
         int_m4t=max(int_m4t,int_m4b)
         real_m4t=max(real_m4t,real_m4b)
         int_m5t=max(int_m5t,int_m5b)
         real_m5t=max(real_m5t,real_m5b)
      end do
      
      mpi.comm_rank(rank)
      
      ! Call the routines

      ! Single numbers
      .test_parallel_max(rank,mpi,int_a,int_b,int_t)
      .test_parallel_max(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_parallel_max(rank,mpi,int_va,int_vb,int_vt)
      .test_parallel_max(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_parallel_max(rank,mpi,int_ma,int_mb,int_mt)
      .test_parallel_max(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_parallel_max(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_parallel_max(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_parallel_max(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_parallel_max(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_parallel_max(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_parallel_max(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   scanmax_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_max and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      maxrank,commsize,a,i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      random,int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(random(commsize))
      do i = 1,commsize
         random(i) = int(100*rand(0))
      end do

      ! Synchronise all instances of the random numbers
      mpi.broadcast(random,0)
      


      ! Initialise all the variables for max testing.
      int_a  = 4+3*random(rank+1)
      real_a = 1.34+3*real(random(rank+1))
      int_va  = [4+3*random(rank+1),2+3*random(rank+1)]
      real_va = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            real_ma(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+random(rank+1)
               real_m3a(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+random(rank+1)
                  real_m4a(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                     real_m5a(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_t=   int_a
      real_t=  real_a
      int_vt=  int_va
      real_vt= real_va
      int_mt=  int_ma
      real_mt= real_ma
      int_m3t= int_m3a
      real_m3t=real_m3a
      int_m4t= int_m4a
      real_m4t=real_m4a
      int_m5t= int_m5a
      real_m5t=real_m5a
      
      maxrank = rank+1
      do a = 1, maxrank 
         rank = a - 1
         int_b  = 4+3*random(rank+1)
         real_b = 1.34+3*real(random(rank+1))
         int_vb  = [4+3*random(rank+1),2+3*random(rank+1)]
         real_vb = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
         do i = 1,3
            do j = 1,3
               int_mb(i,j) = i*j
               real_mb(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3b(i,j,k) = i*j*k+random(rank+1)
                  real_m3b(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4b(i,j,k,l) = i*j*k*l+random(rank+1)
                     real_m4b(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5b(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                        real_m5b(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
         int_t=max(int_t,int_b)
         real_t=max(real_t,real_b)
         int_vt=max(int_vt,int_vb)
         real_vt=max(real_vt,real_vb)
         int_mt=max(int_mt,int_mb)
         real_mt=max(real_mt,real_mb)
         int_m3t=max(int_m3t,int_m3b)
         real_m3t=max(real_m3t,real_m3b)
         int_m4t=max(int_m4t,int_m4b)
         real_m4t=max(real_m4t,real_m4b)
         int_m5t=max(int_m5t,int_m5b)
         real_m5t=max(real_m5t,real_m5b)
      end do
      
      mpi.comm_rank(rank)
      

      ! Call the routines

      ! Single numbers
      .test_scan_max(rank,mpi,int_a,int_b,int_t)
      .test_scan_max(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_scan_max(rank,mpi,int_va,int_vb,int_vt)
      .test_scan_max(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_scan_max(rank,mpi,int_ma,int_mb,int_mt)
      .test_scan_max(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_scan_max(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_scan_max(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_scan_max(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_scan_max(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_scan_max(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_scan_max(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   min_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_min and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,a,i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      random,int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(random(commsize))
      do i = 1,commsize
         random(i) = int(100*rand(0))
      end do

      ! Synchronise all instances of the random numbers
      mpi.broadcast(random,0)
      


      ! Initialise all the variables for min testing.
      int_a  = 4+3*random(rank+1)
      real_a = 1.34+3*real(random(rank+1))
      int_va  = [4+3*random(rank+1),2+3*random(rank+1)]
      real_va = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            real_ma(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+random(rank+1)
               real_m3a(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+random(rank+1)
                  real_m4a(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                     real_m5a(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_t=   int_a
      real_t=  real_a
      int_vt=  int_va
      real_vt= real_va
      int_mt=  int_ma
      real_mt= real_ma
      int_m3t= int_m3a
      real_m3t=real_m3a
      int_m4t= int_m4a
      real_m4t=real_m4a
      int_m5t= int_m5a
      real_m5t=real_m5a
      do a = 1, commsize 
         rank = a - 1
         int_b  = 4+3*random(rank+1)
         real_b = 1.34+3*real(random(rank+1))
         int_vb  = [4+3*random(rank+1),2+3*random(rank+1)]
         real_vb = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
         do i = 1,3
            do j = 1,3
               int_mb(i,j) = i*j
               real_mb(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3b(i,j,k) = i*j*k+random(rank+1)
                  real_m3b(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4b(i,j,k,l) = i*j*k*l+random(rank+1)
                     real_m4b(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5b(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                        real_m5b(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
         int_t=min(int_t,int_b)
         real_t=min(real_t,real_b)
         int_vt=min(int_vt,int_vb)
         real_vt=min(real_vt,real_vb)
         int_mt=min(int_mt,int_mb)
         real_mt=min(real_mt,real_mb)
         int_m3t=min(int_m3t,int_m3b)
         real_m3t=min(real_m3t,real_m3b)
         int_m4t=min(int_m4t,int_m4b)
         real_m4t=min(real_m4t,real_m4b)
         int_m5t=min(int_m5t,int_m5b)
         real_m5t=min(real_m5t,real_m5b)
      end do
      
      mpi.comm_rank(rank)
      

      ! Call the routines

      ! Single numbers
      .test_reduce_min(rank,mpi,int_a,int_b,int_t)
      .test_reduce_min(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_reduce_min(rank,mpi,int_va,int_vb,int_vt)
      .test_reduce_min(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_reduce_min(rank,mpi,int_ma,int_mb,int_mt)
      .test_reduce_min(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_reduce_min(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_reduce_min(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_reduce_min(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_reduce_min(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_reduce_min(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_reduce_min(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   allmin_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_min and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,a,i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      random,int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(random(commsize))
      do i = 1,commsize
         random(i) = int(100*rand(0))
      end do

      ! Synchronise all instances of the random numbers
      mpi.broadcast(random,0)
      


      ! Initialise all the variables for min testing.
      int_a  = 4+3*random(rank+1)
      real_a = 1.34+3*real(random(rank+1))
      int_va  = [4+3*random(rank+1),2+3*random(rank+1)]
      real_va = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            real_ma(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+random(rank+1)
               real_m3a(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+random(rank+1)
                  real_m4a(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                     real_m5a(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_t=   int_a
      real_t=  real_a
      int_vt=  int_va
      real_vt= real_va
      int_mt=  int_ma
      real_mt= real_ma
      int_m3t= int_m3a
      real_m3t=real_m3a
      int_m4t= int_m4a
      real_m4t=real_m4a
      int_m5t= int_m5a
      real_m5t=real_m5a
      do a = 1, commsize 
         rank = a - 1
         int_b  = 4+3*random(rank+1)
         real_b = 1.34+3*real(random(rank+1))
         int_vb  = [4+3*random(rank+1),2+3*random(rank+1)]
         real_vb = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
         do i = 1,3
            do j = 1,3
               int_mb(i,j) = i*j
               real_mb(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3b(i,j,k) = i*j*k+random(rank+1)
                  real_m3b(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4b(i,j,k,l) = i*j*k*l+random(rank+1)
                     real_m4b(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5b(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                        real_m5b(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
         int_t=min(int_t,int_b)
         real_t=min(real_t,real_b)
         int_vt=min(int_vt,int_vb)
         real_vt=min(real_vt,real_vb)
         int_mt=min(int_mt,int_mb)
         real_mt=min(real_mt,real_mb)
         int_m3t=min(int_m3t,int_m3b)
         real_m3t=min(real_m3t,real_m3b)
         int_m4t=min(int_m4t,int_m4b)
         real_m4t=min(real_m4t,real_m4b)
         int_m5t=min(int_m5t,int_m5b)
         real_m5t=min(real_m5t,real_m5b)
      end do
      
      mpi.comm_rank(rank)
      
      ! Call the routines

      ! Single numbers
      .test_parallel_min(rank,mpi,int_a,int_b,int_t)
      .test_parallel_min(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_parallel_min(rank,mpi,int_va,int_vb,int_vt)
      .test_parallel_min(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_parallel_min(rank,mpi,int_ma,int_mb,int_mt)
      .test_parallel_min(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_parallel_min(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_parallel_min(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_parallel_min(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_parallel_min(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_parallel_min(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_parallel_min(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   scanmin_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_min and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      minrank,commsize,a,i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      random,int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(random(commsize))
      do i = 1,commsize
         random(i) = int(100*rand(0))
      end do

      ! Synchronise all instances of the random numbers
      mpi.broadcast(random,0)
      


      ! Initialise all the variables for min testing.
      int_a  = 4+3*random(rank+1)
      real_a = 1.34+3*real(random(rank+1))
      int_va  = [4+3*random(rank+1),2+3*random(rank+1)]
      real_va = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            real_ma(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
            do k = 1,3
               int_m3a(i,j,k) = i*j*k+random(rank+1)
               real_m3a(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l+random(rank+1)
                  real_m4a(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                     real_m5a(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_t=   int_a
      real_t=  real_a
      int_vt=  int_va
      real_vt= real_va
      int_mt=  int_ma
      real_mt= real_ma
      int_m3t= int_m3a
      real_m3t=real_m3a
      int_m4t= int_m4a
      real_m4t=real_m4a
      int_m5t= int_m5a
      real_m5t=real_m5a
      
      minrank = rank+1
      do a = 1, minrank 
         rank = a - 1
         int_b  = 4+3*random(rank+1)
         real_b = 1.34+3*real(random(rank+1))
         int_vb  = [4+3*random(rank+1),2+3*random(rank+1)]
         real_vb = [1.34+real(random(rank+1)*3),34.5+real(random(rank+1)*3)]
         do i = 1,3
            do j = 1,3
               int_mb(i,j) = i*j
               real_mb(i,j) = real(i**4+random(rank+1)*3)+real(j)**(1/2)
               do k = 1,3
                  int_m3b(i,j,k) = i*j*k+random(rank+1)
                  real_m3b(i,j,k) = real(i**4+3*random(rank+1))+real(j)**(1/2) +0.0543*real(k)
                  do l = 1,3
                     int_m4b(i,j,k,l) = i*j*k*l+random(rank+1)
                     real_m4b(i,j,k,l) = real(random(rank+1)+i**l)+real(j)**(1/2) +0.0543*real(k)
                     do m = 1,3
                        int_m5b(i,j,k,l,m) = i*j*k*l-m+random(rank+1)
                        real_m5b(i,j,k,l,m) = real(i**l+random(rank+1))+real(j)**(real(1/real(m))) +0.0543*real(k)
                     end do
                  end do
               end do
            end do
         end do
         int_t=min(int_t,int_b)
         real_t=min(real_t,real_b)
         int_vt=min(int_vt,int_vb)
         real_vt=min(real_vt,real_vb)
         int_mt=min(int_mt,int_mb)
         real_mt=min(real_mt,real_mb)
         int_m3t=min(int_m3t,int_m3b)
         real_m3t=min(real_m3t,real_m3b)
         int_m4t=min(int_m4t,int_m4b)
         real_m4t=min(real_m4t,real_m4b)
         int_m5t=min(int_m5t,int_m5b)
         real_m5t=min(real_m5t,real_m5b)
      end do
      
      mpi.comm_rank(rank)
      

      ! Call the routines

      ! Single numbers
      .test_scan_min(rank,mpi,int_a,int_b,int_t)
      .test_scan_min(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_scan_min(rank,mpi,int_va,int_vb,int_vt)
      .test_scan_min(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_scan_min(rank,mpi,int_ma,int_mb,int_mt)
      .test_scan_min(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_scan_min(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_scan_min(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_scan_min(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_scan_min(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_scan_min(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_scan_min(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   maxloc_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_maxloc and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank :: INT
      int_a,int_b,int_t :: VEC{INT}(2)
      real_a,real_b,real_t  :: VEC{REAL}(2)
      int_va,int_vb,int_vt   :: MAT{INT}(2,2)
      real_va,real_vb,real_vt :: MAT{REAL}(2,2)
      int_ma,int_mb,int_mt   :: MAT3{INT}(2,3,3)
      real_ma,real_mb,real_mt :: MAT3{REAL}(2,3,3)
      int_m3a,int_m3b,int_m3t   :: MAT4{INT}(2,3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT4{REAL}(2,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT5{REAL}(2,3,3,3,3)
      int_m4a,int_m4b,int_m4t :: MAT5{INT}(2,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_maxloc testing.
      int_a(1)  = 4
      int_b(1)  = 2
      real_a(1) = 1.34
      real_b(1) = 22.3
      int_va(1,:)  = [4,2]
      int_vb(1,:)  = [2,5]
      real_va(1,:) = [1.34,34.5]
      real_vb(1,:) = [12.0,22.3]
      int_a(2)  = rank
      int_b(2)  = rank
      real_a(2) = rank
      real_b(2) = rank
      int_va(2,:)  = rank
      int_vb(2,:)  = rank
      real_va(2,:) = rank
      real_vb(2,:) = rank
      do i = 1,3
         do j = 1,3
            int_ma(1,i,j) = i*j
            int_mb(1,i,j) = 0
            real_ma(1,i,j) = real(i**4)+real(j**(1/2))
            real_mb(1,i,j) = 0.0
            int_ma(2,i,j)  = rank 
            int_mb(2,i,j)  = rank 
            real_ma(2,i,j) = rank 
            real_mb(2,i,j) = rank 
            do k = 1,3
                int_m3a(1,i,j,k) = i*j*k
                int_m3b(1,i,j,k) = 0
               real_m3a(1,i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(1,i,j,k) = 0.0
                int_m3a(2,i,j,k)  = rank  
                int_m3b(2,i,j,k)  = rank 
               real_m3a(2,i,j,k) = rank 
               real_m3b(2,i,j,k) = rank 
               do l = 1,3
                   int_m4a(1,i,j,k,l) = i*j*k*l
                   int_m4b(1,i,j,k,l) = 0
                  real_m4a(1,i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(1,i,j,k,l) = 0.0
                  int_m4a(2,i,j,k,l)  = rank  
                  int_m4b(2,i,j,k,l)  = rank 
                  real_m4a(2,i,j,k,l) = rank 
                  real_m4b(2,i,j,k,l) = rank
               end do
            end do
         end do
      end do
      int_t(1)=max(int_a(1),int_b(1))
      if(int_a(1)>int_b(1)) then
         int_t(2)=0
      else
         int_t(2)=1
      end if
      real_t(1)=max(real_a(1),real_b(1))
      if(real_a(1)>real_b(1)) then
         real_t(2)=0
      else
         real_t(2)=1
      end
      do i=1,2
         int_vt(1,i)=max(int_va(1,i),int_vb(1,i))
         if(int_va(1,i) > int_vb(1,i)) then
            int_vt(2,i)=0
         else
            int_vt(2,i)=1
         end if
         real_vt(1,i)=max(real_va(1,i),real_vb(1,i))
         if(real_va(1,i) > real_vb(1,i)) then
            real_vt(2,i)=0
         else
            real_vt(2,i)=1
         end if
      end do
      do i=1,3
         do j=1,3
            int_mt(1,i,j)=max(int_ma(1,i,j),int_mb(1,i,j))
            if(int_ma(1,i,j) > int_mb(1,i,j)) then
               int_mt(2,i,j)=0
            else
               int_mt(2,i,j)=1
            end if
            real_mt(1,i,j)=max(real_ma(1,i,j),real_mb(1,i,j))
            if(real_ma(1,i,j) > real_mb(1,i,j)) then
               real_mt(2,i,j)=0
            else
               real_mt(2,i,j)=1
            end if
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               int_m3t(1,i,j,k)=max(int_m3a(1,i,j,k),int_m3b(1,i,j,k))
               if(int_m3a(1,i,j,k) > int_m3b(1,i,j,k)) then
                  int_m3t(2,i,j,k)=0
               else
                  int_m3t(2,i,j,k)=1
               end if
               real_m3t(1,i,j,k)=max(real_m3a(1,i,j,k),real_m3b(1,i,j,k))
               if(real_m3a(1,i,j,k) > real_m3b(1,i,j,k)) then
                  real_m3t(2,i,j,k)=0
               else
                  real_m3t(2,i,j,k)=1
               end if
            end do
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               do l=1,3
                  int_m4t(1,i,j,k,l)=max(int_m4a(1,i,j,k,l),int_m4b(1,i,j,k,l))
                  if(int_m4a(1,i,j,k,l) > int_m4b(1,i,j,k,l)) then
                     int_m4t(2,i,j,k,l)=0
                  else
                     int_m4t(2,i,j,k,l)=1
                  end if
                  real_m4t(1,i,j,k,l)=max(real_m4a(1,i,j,k,l),real_m4b(1,i,j,k,l))
                  if(real_m4a(1,i,j,k,l) > real_m4b(1,i,j,k,l)) then
                     real_m4t(2,i,j,k,l)=0
                  else
                     real_m4t(2,i,j,k,l)=1
                  end if
               end do
            end do
         end do
      end do

      

      ! Call the routines
      ! Single numbers
      .test_reduce_maxloc(rank,mpi,int_a,int_b,int_t)
      .test_reduce_maxloc(rank,mpi,real_a,real_b,real_t)

      ! Vectors
      .test_reduce_maxloc(rank,mpi,int_va,int_vb,int_vt)
      .test_reduce_maxloc(rank,mpi,real_va,real_vb,real_vt)
   
      ! Matrix
      .test_reduce_maxloc(rank,mpi,int_ma,int_mb,int_mt)
      .test_reduce_maxloc(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_reduce_maxloc(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_reduce_maxloc(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      !.test_reduce_maxloc(rank,mpi,int_m4a,int_m4b,int_m4t)
      !.test_reduce_maxloc(rank,mpi,real_m4a,real_m4b,real_m4t)
      
   
   end

   minloc_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_minloc and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank :: INT
      int_mina,int_minb,int_mint :: VEC{INT}(2)
      real_mina,real_minb,real_mint  :: VEC{REAL}(2)
      int_minva,int_minvb,int_minvt   :: MAT{INT}(2,2)
      real_minva,real_minvb,real_minvt :: MAT{REAL}(2,2)
      int_minma,int_minmb,int_minmt   :: MAT3{INT}(2,3,3)
      real_minma,real_minmb,real_minmt :: MAT3{REAL}(2,3,3)
      int_minm3a,int_minm3b,int_minm3t   :: MAT4{INT}(2,3,3,3)
      real_minm3a,real_minm3b,real_minm3t :: MAT4{REAL}(2,3,3,3)
      real_minm4a,real_minm4b,real_minm4t :: MAT5{REAL}(2,3,3,3,3)
      int_minm4a,int_minm4b,int_minm4t :: MAT5{INT}(2,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_minloc testing.
      int_mina(1)  = 4
      int_minb(1)  = 2
      real_mina(1) = 1.34
      real_minb(1) = 22.3
      int_minva(1,:)  = [4,2]
      int_minvb(1,:)  = [2,5]
      real_minva(1,:) = [1.34,34.5]
      real_minvb(1,:) = [12.0,22.3]
      int_mina(2)  = rank
      int_minb(2)  = rank
      real_mina(2) = rank
      real_minb(2) = rank
      int_minva(2,:)  = rank
      int_minvb(2,:)  = rank
      real_minva(2,:) = rank
      real_minvb(2,:) = rank
      do i = 1,3
         do j = 1,3
            int_minma(1,i,j) = i*j
            int_minmb(1,i,j) = 0
            real_minma(1,i,j) = real(i**4)+real(j**(1/2))
            real_minmb(1,i,j) = 0.0
            int_minma(2,i,j)  = rank 
            int_minmb(2,i,j)  = rank 
            real_minma(2,i,j) = rank 
            real_minmb(2,i,j) = rank 
            do k = 1,3
                int_minm3a(1,i,j,k) = i*j*k
                int_minm3b(1,i,j,k) = 0
               real_minm3a(1,i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_minm3b(1,i,j,k) = 0.0
                int_minm3a(2,i,j,k)  = rank  
                int_minm3b(2,i,j,k)  = rank 
               real_minm3a(2,i,j,k) = rank 
               real_minm3b(2,i,j,k) = rank 
               do l = 1,3
                   int_minm4a(1,i,j,k,l) = i*j*k*l
                   int_minm4b(1,i,j,k,l) = 0
                  real_minm4a(1,i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_minm4b(1,i,j,k,l) = 0.0
                  int_minm4a(2,i,j,k,l)  = rank  
                  int_minm4b(2,i,j,k,l)  = rank 
                  real_minm4a(2,i,j,k,l) = rank 
                  real_minm4b(2,i,j,k,l) = rank
               end do
            end do
         end do
      end do
      int_mint(1)=min(int_mina(1),int_minb(1))
      if(int_mina(1)<int_minb(1)) then
         int_mint(2)=0
      else
         int_mint(2)=1
      end if
      real_mint(1)=min(real_mina(1),real_minb(1))
      if(real_mina(1)<real_minb(1)) then
         real_mint(2)=0
      else
         real_mint(2)=1
      end
      do i=1,2
         int_minvt(1,i)=min(int_minva(1,i),int_minvb(1,i))
         if(int_minva(1,i) < int_minvb(1,i)) then
            int_minvt(2,i)=0
         else
            int_minvt(2,i)=1
         end if
         real_minvt(1,i)=min(real_minva(1,i),real_minvb(1,i))
         if(real_minva(1,i) < real_minvb(1,i)) then
            real_minvt(2,i)=0
         else
            real_minvt(2,i)=1
         end if
      end do
      do i=1,3
         do j=1,3
            int_minmt(1,i,j)=min(int_minma(1,i,j),int_minmb(1,i,j))
            if(int_minma(1,i,j) < int_minmb(1,i,j)) then
               int_minmt(2,i,j)=0
            else
               int_minmt(2,i,j)=1
            end if
            real_minmt(1,i,j)=min(real_minma(1,i,j),real_minmb(1,i,j))
            if(real_minma(1,i,j) < real_minmb(1,i,j)) then
               real_minmt(2,i,j)=0
            else
               real_minmt(2,i,j)=1
            end if
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               int_minm3t(1,i,j,k)=min(int_minm3a(1,i,j,k),int_minm3b(1,i,j,k))
               if(int_minm3a(1,i,j,k) < int_minm3b(1,i,j,k)) then
                  int_minm3t(2,i,j,k)=0
               else
                  int_minm3t(2,i,j,k)=1
               end if
               real_minm3t(1,i,j,k)=min(real_minm3a(1,i,j,k),real_minm3b(1,i,j,k))
               if(real_minm3a(1,i,j,k) < real_minm3b(1,i,j,k)) then
                  real_minm3t(2,i,j,k)=0
               else
                  real_minm3t(2,i,j,k)=1
               end if
            end do
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               do l=1,3
                  int_minm4t(1,i,j,k,l)=min(int_minm4a(1,i,j,k,l),int_minm4b(1,i,j,k,l))
                  if(int_minm4a(1,i,j,k,l) < int_minm4b(1,i,j,k,l)) then
                     int_minm4t(2,i,j,k,l)=0
                  else
                     int_minm4t(2,i,j,k,l)=1
                  end if
                  real_minm4t(1,i,j,k,l)=min(real_minm4a(1,i,j,k,l),real_minm4b(1,i,j,k,l))
                  if(real_minm4a(1,i,j,k,l) < real_minm4b(1,i,j,k,l)) then
                     real_minm4t(2,i,j,k,l)=0
                  else
                     real_minm4t(2,i,j,k,l)=1
                  end if
               end do
            end do
         end do
      end do

      

      ! Call the routines
      ! Single numbers
      .test_reduce_minloc(rank,mpi,int_mina,int_minb,int_mint)
      .test_reduce_minloc(rank,mpi,real_mina,real_minb,real_mint)
      
      ! Vectors
      .test_reduce_minloc(rank,mpi,int_minva,int_minvb,int_minvt)
      .test_reduce_minloc(rank,mpi,real_minva,real_minvb,real_minvt)
   
      ! Matrix
      .test_reduce_minloc(rank,mpi,int_minma,int_minmb,int_minmt)
      .test_reduce_minloc(rank,mpi,real_minma,real_minmb,real_minmt)
      
      ! Matrix 3s
      .test_reduce_minloc(rank,mpi,int_minm3a,int_minm3b,int_minm3t)
      .test_reduce_minloc(rank,mpi,real_minm3a,real_minm3b,real_minm3t)
      
      ! Matrix 4s
      !.test_reduce_minloc(rank,mpi,int_minm4a,int_minm4b,int_minm4t)
      !.test_reduce_minloc(rank,mpi,real_minm4a,real_minm4b,real_minm4t)
      
   
   end

   lor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      do a =1,commsize
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t = bin_t OR bin_b
         bin_vt = bin_vt OR bin_vb
         bin_mt = bin_mt OR bin_mb
         bin_m3t = bin_m3t OR bin_m3b
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_reduce_lor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_reduce_lor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_reduce_lor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_reduce_lor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   alllor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      do a =1,commsize
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t = bin_t OR bin_b
         bin_vt = bin_vt OR bin_vb
         bin_mt = bin_mt OR bin_mb
         bin_m3t = bin_m3t OR bin_m3b
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_parallel_or(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_parallel_or(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_parallel_or(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_parallel_or(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   scanlor_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_lor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      maxrank,old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      maxrank = old_rank +1
      do a =1,maxrank
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t = bin_t OR bin_b
         bin_vt = bin_vt OR bin_vb
         bin_mt = bin_mt OR bin_mb
         bin_m3t = bin_m3t OR bin_m3b
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_scan_lor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_scan_lor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_scan_lor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_scan_lor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   land_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_land functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      do a =1,commsize
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t = bin_t AND bin_b
         bin_vt = bin_vt AND bin_vb
         bin_mt = bin_mt AND bin_mb
         bin_m3t = bin_m3t AND bin_m3b
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_reduce_land(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_reduce_land(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_reduce_land(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_reduce_land(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   allland_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_land functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      do a =1,commsize
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t = bin_t AND bin_b
         bin_vt = bin_vt AND bin_vb
         bin_mt = bin_mt AND bin_mb
         bin_m3t = bin_m3t AND bin_m3b
      end do
      
      rank = old_rank
   
   
      ! Call the routines
      ! Single numbers
      .test_parallel_and(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_parallel_and(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_parallel_and(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_parallel_and(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   scanland_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_land functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      maxrank,old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      maxrank = old_rank +1
      do a =1,maxrank
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t = bin_t AND bin_b
         bin_vt = bin_vt AND bin_vb
         bin_mt = bin_mt AND bin_mb
         bin_m3t = bin_m3t AND bin_m3b
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_scan_land(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_scan_land(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_scan_land(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_scan_land(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   lxor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lxor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      do a =1,commsize
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t   =  NOT(bin_t EQV bin_b)
         bin_vt  =  NOT(bin_vt EQV bin_vb)
         bin_mt  =  NOT(bin_mt EQV bin_mb)
         bin_m3t =  NOT(bin_m3t EQV bin_m3b)
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_reduce_lxor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectxors
      .test_reduce_lxor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_reduce_lxor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_reduce_lxor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   alllxor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lxor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      do a =1,commsize
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t   =  NOT(bin_t EQV bin_b)
         bin_vt  =  NOT(bin_vt EQV bin_vb)
         bin_mt  =  NOT(bin_mt EQV bin_mb)
         bin_m3t =  NOT(bin_m3t EQV bin_m3b)
      end do
      
      rank = old_rank
   
      ! Call the routines
      ! Single numbers
      .test_parallel_xor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectxors
      .test_parallel_xor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_parallel_xor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_parallel_xor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   scanlxor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lxor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      maxrank,old_rank,commsize,rank,a,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      rand_a    :: VEC{REAL}@
      rand_va    :: MAT{REAL}@
      rand_ma    :: MAT3{REAL}@
      rand_m3a    :: MAT4{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      allocate(rand_a(commsize))
      allocate(rand_va(3,commsize))
      allocate(rand_ma(3,3,commsize))
      allocate(rand_m3a(3,3,3,commsize))
      do a = 1,commsize
         rand_a(a) = rand(0)
         do i = 1,3
            rand_va(i,a) = rand(0)
            do j = 1,3
               rand_ma(i,j,a) = rand(0)
               do k = 1,3
                  rand_m3a(i,j,k,a) = rand(0)
               end do
            end do
         end do
      end do
      
      ! Synchronise all instances of the random numbers
      mpi.broadcast(rand_a,0)  
      mpi.broadcast(rand_va,0) 
      mpi.broadcast(rand_ma,0) 
      mpi.broadcast(rand_m3a,0)

      
      ! Initialise all the variables for send testing.
      bin_a  = (rand_a(rank+1)>0.5)
      bin_va  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
      do i = 1,3
         do j = 1,3
            if (rand_ma(i,j,rank+1)>0.5) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            do k = 1,3
               if (rand_m3a(i,j,k,rank+1)>0.5) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
            end do
         end do
      end do

      bin_t = bin_a 
      bin_vt = bin_va 
      bin_mt = bin_ma
      bin_m3t = bin_m3a 
      
      ! Initialise all the variables for send testing.
      old_rank = rank
      maxrank = old_rank +1
      do a =1,maxrank
         rank = a - 1
         if (rank == old_rank) cycle
         ! Initialise all the variables for send testing.
         bin_b  = (rand_a(rank+1)>0.5)
         bin_vb  = [(rand_va(1,rank+1)>0.5),(rand_va(2,rank+1)>0.5),(rand_va(3,rank+1)>0.5)]
         do i = 1,3
            do j = 1,3
               if (rand_ma(i,j,rank+1)>0.5) then
                  bin_mb(i,j) = TRUE
               else
                  bin_mb(i,j) = FALSE
               end if
               do k = 1,3
                  if (rand_m3a(i,j,k,rank+1)>0.5) then
                     bin_m3b(i,j,k) = TRUE
                  else
                     bin_m3b(i,j,k) = FALSE
                  end if
               end do
            end do
         end do
         bin_t   = NOT(bin_t EQV bin_b)
         bin_vt  = NOT(bin_vt EQV bin_vb)
         bin_mt  = NOT(bin_mt EQV bin_mb)
         bin_m3t = NOT(bin_m3t EQV bin_m3b)
      end do
      
      rank = old_rank
   
   
      ! Call the routines
      ! Single numbers
      .test_scan_lxor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectxors
      .test_scan_lxor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_scan_lxor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_scan_lxor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   barrier_mpi_test(mpi) :::  public
   ! This routine calls and tests all barrier functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT
      
      mpi.comm_rank(rank)
      
      ! Test barrier
      .test_barrier(rank,mpi)
      
   
   end


!=====
! Send
!=====

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.send(send_a,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            else
               mpi.send(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.send(send_a,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            else
               mpi.send(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            end
         else if (i == 3) then
            mpi.send(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (d EQ send_d)
         else if (i == 4) then
            mpi.send(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (e EQ send_e)
         end if   
      end do

      if (all(testing_vector)) then
         print*, "MPI can succesfully send the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to send to the following neighbours: ", testing_vector
      end if

   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.send(send_a,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            else
               mpi.send(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.send(send_a,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            else
               mpi.send(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            end
         else if (i == 3) then
            mpi.send(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (all(d EQ send_d))
         else if (i == 4) then
            mpi.send(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (all(e EQ send_e))
         end if   
      end do
      if (all(testing_vector)) then
         print*, "MPI can succesfully send the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to send VAR_TYPE for the neighbour: ", testing_vector
      end if

   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

!======
! SSend
!======

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.ssend(send_a,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            else
               mpi.ssend(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.ssend(send_a,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            else
               mpi.ssend(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            end
         else if (i == 3) then
            mpi.ssend(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (d EQ send_d)
         else if (i == 4) then
            mpi.ssend(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (e EQ send_e)
         end if   
      end do

      if (all(testing_vector)) then
         print*, "MPI can succesfully ssend the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to ssend to the following neighbours: ", testing_vector
      end if

   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.ssend(send_a,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            else
               mpi.ssend(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.ssend(send_a,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            else
               mpi.ssend(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            end
         else if (i == 3) then
            mpi.ssend(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (all(d EQ send_d))
         else if (i == 4) then
            mpi.ssend(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (all(e EQ send_e))
         end if   
      end do
      if (all(testing_vector)) then
         print*, "MPI can succesfully ssend the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to ssend VAR_TYPE for the neighbour: ", testing_vector
      end if

   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

! =====
! Isend
! =====

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.isend(send_a,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            else
               mpi.isend(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.isend(send_a,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            else
               mpi.isend(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            end
         else if (i == 3) then
            mpi.isend(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (d EQ send_d)
         else if (i == 4) then
            mpi.isend(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (e EQ send_e)
         end if   
      end do

      if (all(testing_vector)) then
         print*, "MPI can succesfully isend the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to isend to the following neighbours: ", testing_vector
      end if

   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.isend(send_a,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            else
               mpi.isend(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.isend(send_a,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            else
               mpi.isend(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            end
         else if (i == 3) then
            mpi.isend(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (all(d EQ send_d))
         else if (i == 4) then
            mpi.isend(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (all(e EQ send_e))
         end if   
      end do
      if (all(testing_vector)) then
         print*, "MPI can succesfully isend the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to isend VAR_TYPE for the neighbour: ", testing_vector
      end if

   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Issend
!=======

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.issend(send_a,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            else
               mpi.issend(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (b EQ send_b)
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.issend(send_a,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            else
               mpi.issend(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (c EQ send_c)
            end
         else if (i == 3) then
            mpi.issend(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (d EQ send_d)
         else if (i == 4) then
            mpi.issend(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (e EQ send_e)
         end if   
      end do

      if (all(testing_vector)) then
         print*, "MPI can succesfully issend the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to issend to the following neighbours: ", testing_vector
      end if

   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            if (neighbours(i) < rank) then
               b = send_a
               mpi.recv(b,neighbours(i))
               mpi.issend(send_a,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            else
               mpi.issend(send_a,neighbours(i))
               b = send_a
               mpi.recv(b,neighbours(i))
               testing_vector(i) = (all(b EQ send_b))
            end if
         else if (i == 2) then
            if (neighbours(i) < rank) then
               c = send_a
               mpi.recv(c,neighbours(i))
               mpi.issend(send_a,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            else
               mpi.issend(send_a,neighbours(i))
               c = send_a
               mpi.recv(c,neighbours(i))
               testing_vector(i) = (all(c EQ send_c))
            end
         else if (i == 3) then
            mpi.issend(send_a,neighbours(i))
            d = send_a
            mpi.recv(d,neighbours(i))
            testing_vector(i) = (all(d EQ send_d))
         else if (i == 4) then
            mpi.issend(send_a,neighbours(i))
            e = send_a
            mpi.recv(e,neighbours(i))
            testing_vector(i) = (all(e EQ send_e))
         end if   
      end do
      if (all(testing_vector)) then
         print*, "MPI can succesfully issend the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to issend VAR_TYPE for the neighbour: ", testing_vector
      end if

   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


!=========
! Sendrecv
!=========
   
   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            b = send_a
            mpi.sendrecv(send_a,b,neighbours(i))
            testing_vector(i) = (b EQ send_b)
         else if (i == 2) then
            c = send_a
            mpi.sendrecv(send_a,c,neighbours(i))
            testing_vector(i) = (c EQ send_c)
         else if (i == 3) then
            d = send_a
            mpi.sendrecv(send_a,d,neighbours(i))
            testing_vector(i) = (d EQ send_d)
         else if (i == 4) then
            e = send_a
            mpi.sendrecv(send_a,e,neighbours(i))
            testing_vector(i) = (e EQ send_e)
         end if   
      end do

      if (all(testing_vector)) then
         print*, "MPI can succesfully sendrecv the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to sendrecv to the following neighbours: ", testing_vector
      end if

   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: template
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      neighbours :: VEC{INT}, IN
      send_a :: VAR_TYPE, INOUT
      send_b :: VAR_TYPE, INOUT
      send_c :: VAR_TYPE, INOUT, optional
      send_d :: VAR_TYPE, INOUT, optional
      send_e :: VAR_TYPE, INOUT, optional 
      testing_vector :: VEC{BIN}(neighbours.dim)
      b,c,d,e  :: VAR_TYPE@
      i :: INT
      
      do i = 1, neighbours.dim
         if (i == 1) then
            b = send_a
            mpi.sendrecv(send_a,b,neighbours(i))
            testing_vector(i) = (all(b EQ send_b))
         else if (i == 2) then
            c = send_a
            mpi.sendrecv(send_a,c,neighbours(i))
            testing_vector(i) = (all(c EQ send_c))
         else if (i == 3) then
            d = send_a
            mpi.sendrecv(send_a,d,neighbours(i))
            testing_vector(i) = (all(d EQ send_d))
         else if (i == 4) then
            e = send_a
            mpi.sendrecv(send_a,e,neighbours(i))
            testing_vector(i) = (all(e EQ send_e))
         end if   
      end do
      if (all(testing_vector)) then
         print*, "MPI can succesfully sendrecv the type VAR_TYPE, from rank: ", rank
      else
         print*, "Rank: ", rank, "failed to sendrecv VAR_TYPE for the neighbour: ", testing_vector
      end if

   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,neighbours,mpi,send_a,send_b,send_c,send_d,send_e) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: template
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = send
         mpi.sendrecv(a,b,1)
         if (recv EQ b) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE on master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE on master"
         end if
      else if (rank == 1) then
         b = recv
         mpi.sendrecv(b,a,0)
         if (a EQ send) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE non-master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE non-master"
         end if
      end if

   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: template
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = send
         b = send
         mpi.sendrecv(a,b,1)
         if (all(recv EQ b)) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE on master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE on master"
         end if
      else if (rank == 1) then
         b = recv
         a = recv
         mpi.sendrecv(b,a,0)
         if (all(a EQ send)) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE non-master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE non-master"
         end if
      end if

   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

!======
! Bcast
!======

   test_bcast(rank,mpi,send,recv) ::: template
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      
      if(rank == 0) then
         mpi.broadcast(send,0)
      else
         mpi.broadcast(recv,0)
         if (recv EQ send) then
            print*, "MPI can succesfully bcast the type VAR_TYPE rank: ", rank
         else
            print*, "MPI failed to bcast the type VAR_TYPE rank: ", rank
         end if
      end if

   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: template
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      
      if(rank == 0) then
         mpi.broadcast(send,0)
      else 
         mpi.broadcast(recv,0)
         if (all(recv EQ send)) then
            print*, "MPI can succesfully bcast the type VAR_TYPE rank: ", rank
         else
            print*, "MPI failed to bcast the type VAR_TYPE rank: ", rank
         end if
      end if

   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Gather
!=======

   test_gather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the gather routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VEC{VAR_TYPE}, INOUT
      a  :: VAR_TYPE
      b :: VEC{VAR_TYPE}@
      
      
      a = send
      mpi.gather(a,recv,0)
      if (rank == 0 ) then   
         if (all(recv EQ test)) then
            print*, "MPI can succesfully gather the type VAR_TYPE rank master"
         else
            print*, "MPI failed to gather the type VAR_TYPE rank master"
            print*,"Receiving", recv
            print*,"It should be:", test
         end if
      end if

   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      i,j :: INT
      
      mpi.gather(send,recv,0)
      if(rank == 0) then
         if (all(recv EQ test)) then
            print*, "MPI can succesfully gather the type VAR_TYPE rank master"
         else
            print*, "MPI failed to gather the type VAR_TYPE rank master"
         end if
      end if

   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

!========
! Igather
!========

   test_igather(commsize,rank,mpi,send,recv,request) ::: template
   ! Test the gather routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VEC{VAR_TYPE}, INOUT
      request :: INT, OUT
      a  :: VAR_TYPE
      b :: VEC{VAR_TYPE}@
      
      
      a = send
      mpi.igather(a,recv,0,request)

   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: template
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      request :: INT, OUT
      a,b  :: VAR_TYPE@
      
      a = send
      mpi.igather(a,recv,0,request=request)

   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

!==========
! Allgather
!==========

   test_allgather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VEC{VAR_TYPE}, INOUT
      a  :: VAR_TYPE
      b :: VEC{VAR_TYPE}@
      
      
      a = send
      mpi.allgather(a,recv)
      if (all(recv EQ test)) then
         print*, "MPI can succesfully allgather the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to allgather the type VAR_TYPE on rank: ", rank
      end if

   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      
      mpi.allgather(send,recv)
      if (all(recv EQ test)) then
         print*, "MPI can succesfully allgather the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to allgather the type VAR_TYPE on rank: ", rank
      end if

   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

!========
! Scatter
!========

   test_scatter(commsize,rank,mpi,send,test,recv) ::: template
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VEC{VAR_TYPE}, INOUT
      test,recv :: VAR_TYPE, INOUT
      a  :: VEC{VAR_TYPE}@
      
      
      if(rank == 0) then
         mpi.scatter(send,recv,0)
      else 
         mpi.scatter(send,recv,0)
         if (recv EQ test) then
            print*, "MPI can succesfully scatter the type VAR_TYPE rank: ", rank
         else
            print*, "MPI failed to scatter the type VAR_TYPE rank: ", rank
         end if
      end if

   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: template
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      i,j :: INT
      
      if(rank == 0) then
         mpi.scatter(send,recv,0)
      else
         mpi.scatter(send,recv,0)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully scatter the type VAR_TYPE rank: ", rank
         else
            print*, "MPI failed to scatter the type VAR_TYPE rank: ", rank
         end if
      end if

   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

!=========
! Alltoall
!=========
   
   test_alltoall(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      i,j :: INT
      
      mpi.alltoall(send,recv,commsize)
      if (all(recv EQ test)) then
         print*, "MPI can succesfully alltoall the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to alltoall the type VAR_TYPE on rank: ", rank
         print*, "TEst: ", test
         print*, "Recv: ", recv
      end if

   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

!====
! Sum
!====

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: template
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         mpi.reduce_sum(reduce_sum,0,a)
         b = recv
         if (a EQ b) then
            print*, "MPI can succesfully reduce_sum the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_sum the type VAR_TYPE"
            print*, a
            print*, b
         end if
      else   
         mpi.reduce_sum(reduce_sum,0)
      end if

   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: template
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_sum
         mpi.reduce_sum(reduce_sum,0,a)
         b = recv
         if (all(a EQ b)) then
            print*, "MPI can succesfully reduce_sum the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_sum the type VAR_TYPE"
            print*, a
            print*, b
         end if
      else 
         mpi.reduce_sum(reduce_sum,0)
      end if

   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Allsum
!=======

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: template
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      mpi.parallel_sum(parallel_sum,a)
      b = recv
      if (a EQ b) then
         print*, "MPI can succesfully parallel_sum the type VAR_TYPE rank: ", rank
      else
         print*, "MPI failed to parallel_sum the type VAR_TYPE on rank: ", rank
         print*, a
         print*, b
      end if

   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: template
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = parallel_sum
      mpi.parallel_sum(parallel_sum,a)
      b = recv
      if (all(a EQ b)) then
         print*, "MPI can succesfully parallel_sum the type VAR_TYPE rank: ", rank
      else
         print*, "MPI failed to parallel_sum the type VAR_TYPE on rank: ", rank
         print*, a
         print*, b
      end if

   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

!===============
! Summation Scan
!===============

   test_scan_sum(rank,mpi,scan_sum,recv) ::: template
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      mpi.scan_sum(scan_sum,a)
      b = recv
      if (a EQ b) then
         print*, "MPI can succesfully scan_sum the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_sum the type VAR_TYPE on rank: ", rank
         print*, a
         print*, b
      end if

   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: template
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = scan_sum
      mpi.scan_sum(scan_sum,a)
      b = recv
      if (all(a EQ b)) then
         print*, "MPI can succesfully scan_sum the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_sum the type VAR_TYPE on rank: ", rank
         print*, a
         print*, b
      end if
   
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

!=====
! Prod
!=====

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: template
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         mpi.reduce_prod(reduce_prod,0,a)
         b = recv
         if (abs(a-b) < 1.0d-5) then
            print*, "MPI can succesfully reduce_prod the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_prod the type VAR_TYPE"
            print*, abs(a-b), ">",  1.0d-5     
         end if
      else   
         mpi.reduce_prod(reduce_prod,0)
      end if

   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT)
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL)
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX)
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: template
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_prod
         mpi.reduce_prod(reduce_prod,0,a)
         b = recv
         if (all(abs(a-b)<1.0d-5)) then
            print*, "MPI can succesfully reduce_prod the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_prod the type VAR_TYPE"
            print*, abs(a-b), ">",  1.0d-5     
         end if
      else 
         mpi.reduce_prod(reduce_prod,0)
      end if

   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX})
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

!========
! Allprod
!========

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: template
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      mpi.parallel_product(parallel_prod,a)
      b = recv
      if (abs(a-b)<1.0d-5) then
         print*, "MPI can succesfully parallel_prod the type VAR_TYPE rank: ", rank
      else
         print*, "MPI failed to parallel_prod the type VAR_TYPE on rank: ", rank
         print*, abs(a-b), ">",  1.0d-5     
      end if

   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT)
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL)
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX)
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: template
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = parallel_prod
      mpi.parallel_product(parallel_prod,a)
      b = recv
      if (all(abs(a-b)<1.0d-5)) then
         print*, "MPI can succesfully parallel_prod the type VAR_TYPE rank: ", rank
      else
         print*, "MPI failed to parallel_prod the type VAR_TYPE on rank: ", rank
         print*, abs(a-b), ">",  1.0d-5     
      end if
   
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX})
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

!=============
! Product Scan
!=============

   test_scan_prod(rank,mpi,scan_prod,recv) ::: template
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      mpi.scan_product(scan_prod,a)
      b = recv
      if (abs(a-b)<1.0d-5) then
         print*, "MPI can succesfully scan_prod the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_prod the type VAR_TYPE on rank: ", rank
         print*, abs(a-b), ">",  1.0d-5     
      end if

   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT)
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL)
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX)
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: template
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = scan_prod
      mpi.scan_product(scan_prod,a)
      b = recv
      if (all(abs(a-b)<1.0d-5)) then
         print*, "MPI can succesfully scan_prod the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_prod the type VAR_TYPE on rank: ", rank
         print*, abs(a-b), ">",  1.0d-5     
      end if

   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX})
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

!====
! Max
!====

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: template
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = reduce_max
         b = recv
         mpi.reduce_max(a,0,b)
         if (b EQ test) then
            print*, "MPI can succesfully reduce_max the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_max the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         a = reduce_max
         mpi.reduce_max(a,0)
      end if

   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: template
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_max
         b = recv
         mpi.reduce_max(a,0,b)
         if (all(b EQ test)) then
            print*, "MPI can succesfully reduce_max the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_max the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         a = reduce_max
         mpi.reduce_max(a,0)
      end if
   
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Allmax
!=======

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: template
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      

      a = parallel_max
      b = recv
      mpi.parallel_maximum(a,b)
      if (b EQ test) then
         print*, "MPI can succesfully allmax the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to allmax the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if


   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: template
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = parallel_max
      b = recv
      mpi.parallel_maximum(a,b)
      if (all(b EQ test)) then
         print*, "MPI can succesfully allmax the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to allmax the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if

   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

!=============
! Maximum Scan
!=============

   test_scan_max(rank,mpi,scan_max,recv,test) ::: template
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      a = scan_max
      b = recv
      mpi.scan_maximum(a,b)
      if (b EQ test) then
         print*, "MPI can succesfully scan_max the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_max the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if


   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: template
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = scan_max
      b = recv
      mpi.scan_maximum(a,b)
      if (all(b EQ test)) then
         print*, "MPI can succesfully scan_max the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_max the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if

   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

!====
! Min
!====

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: template
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = reduce_min
         b = recv
         mpi.reduce_min(a,0,b)
         if (b EQ test) then
            print*, "MPI can succesfully reduce_min the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_min the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         a = reduce_min
         mpi.reduce_min(a,0)
      end if

   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: template
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_min
         b = recv
         mpi.reduce_min(a,0,b)
         if (all(b EQ test)) then
            print*, "MPI can succesfully reduce_min the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_min the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         a = reduce_min
         mpi.reduce_min(a,0)
      end if
   
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Allmin
!=======

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: template
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      

      a = parallel_min
      b = recv
      mpi.parallel_minimum(a,b)
      if (b EQ test) then
         print*, "MPI can succesfully allmin the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to allmin the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if


   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: template
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = parallel_min
      b = recv
      mpi.parallel_minimum(a,b)
      if (all(b EQ test)) then
         print*, "MPI can succesfully allmin the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to allmin the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if

   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

!=============
! Minimum Scan
!=============

   test_scan_min(rank,mpi,scan_min,recv,test) ::: template
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      a = scan_min
      b = recv
      mpi.scan_minimum(a,b)
      if (b EQ test) then
         print*, "MPI can succesfully scan_min the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_min the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if


   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: template
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      a = scan_min
      b = recv
      mpi.scan_minimum(a,b)
      if (all(b EQ test)) then
         print*, "MPI can succesfully scan_min the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_min the type VAR_TYPE on rank: ", rank
         print*, b
         print*, test
      end if

   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Maxloc
!=======

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: template
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_maxloc,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      var  :: VAR_TYPE@ 
      
     if(rank == 0) then
         mpi.reduce_maxloc(reduce_maxloc,root=1)
      else if (rank == 1) then
         mpi.reduce_maxloc(recv,root=1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully reduce_maxloc the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_maxloc the type VAR_TYPE"
            print*, test
            print*, recv
         end if
      end if

   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


!=======
! Minloc
!=======

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: template
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_minloc,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      var  :: VAR_TYPE@ 
      
     if(rank == 0) then
         mpi.reduce_minloc(reduce_minloc,root=1)
      else if (rank == 1) then
         mpi.reduce_minloc(recv,root=1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully reduce_minloc the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_minloc the type VAR_TYPE"
            print*, test
            print*, recv
         end if
      end if

   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

!====
! Lor
!====

   test_reduce_lor(rank,mpi,send,recv,test) 
   ! Test the reduce_lor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.reduce_lor(send,0,b)
         if (b EQV test) then
            print*, "MPI can succesfully reduce_lor the type BIN"
         else
            print*, "MPI failed to reduce_lor the type BIN"
            print*, b
            print*, test
         end if
      else
         mpi.reduce_lor(send,0)
      end if

   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: template
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         b = recv
         b = FALSE
         mpi.reduce_lor(send,0,b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully reduce_lor the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_lor the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         mpi.reduce_lor(send,0)
      end if

   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
   end

!=======
! AllLor
!=======

   test_parallel_or(rank,mpi,send,recv,test) 
   ! Test the parallel_or routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      mpi.parallel_or(send,b)
      if (b EQV test) then
         print*, "MPI can succesfully parallel_lor the type BIN on rank: ", rank
      else
         print*, "MPI failed to parallel_lor the type BIN on rank: ", rank
         print*, send
         print*, test
      end if

   end

   test_parallel_or(rank,mpi,send,recv,test) ::: template
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      b = recv
      b = FALSE
      mpi.parallel_or(send,b)
      if (all(b EQV test)) then
         print*, "MPI can succesfully parallel_lor the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to parallel_lor the type VAR_TYPE on rank: ", rank
         print*, send
         print*, test
      end if

   end

   test_parallel_or(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_or(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_or(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
   end

!=========
! Scan Lor
!=========

   test_scan_lor(rank,mpi,send,recv,test) 
   ! Test the scan_lor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      mpi.scan_lor(send,b)
      if (b EQV test) then
         print*, "MPI can succesfully scan_lor the type BIN on rank: ", rank
      else
         print*, "MPI failed to scan_lor the type BIN on rank: ", rank
         print*, send
         print*, b
      end if

   end

   test_scan_lor(rank,mpi,send,recv,test) ::: template
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      b = send
      b = FALSE
      mpi.scan_lor(send,b)
      if (all(b EQV test)) then
         print*, "MPI can succesfully scan_lor the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_lor the type VAR_TYPE on rank: ", rank
         print*, send
         print*, b
      end if

   end

   test_scan_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
   end

!=====
! Land
!=====

   test_reduce_land(rank,mpi,send,recv,test) 
   ! Test the reduce_land routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.reduce_land(send,0,b)
         if (b EQV test) then
            print*, "MPI can succesfully reduce_land the type BIN"
         else
            print*, "MPI failed to reduce_land the type BIN"
            print*, b
            print*, test
         end if
      else
         mpi.reduce_land(send,0)
      end if

   end

   test_reduce_land(rank,mpi,send,recv,test) ::: template
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         b = recv
         b = FALSE
         mpi.reduce_land(send,0,b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully reduce_land the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_land the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         mpi.reduce_land(send,0)
      end if

   end

   test_reduce_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
   end

!========
! AllLand
!========

   test_parallel_and(rank,mpi,send,recv,test) 
   ! Test the parallel_and routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      mpi.parallel_and(send,b)
      if (b EQV test) then
         print*, "MPI can succesfully parallel_land the type BIN on rank: ", rank
      else
         print*, "MPI failed to parallel_land the type BIN on rank: ", rank
         print*, send
         print*, test
      end if

   end

   test_parallel_and(rank,mpi,send,recv,test) ::: template
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      b = recv
      b = FALSE
      mpi.parallel_and(send,b)
      if (all(b EQV test)) then
         print*, "MPI can succesfully parallel_land the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to parallel_land the type VAR_TYPE on rank: ", rank
         print*, send
         print*, test
      end if

   end

   test_parallel_and(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_and(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_and(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
   end

!==========
! Scan Land
!==========

   test_scan_land(rank,mpi,send,recv,test) 
   ! Test the scan_land routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      mpi.scan_land(send,b)
      if (b EQV test) then
         print*, "MPI can succesfully scan_land the type BIN on rank: ", rank
      else
         print*, "MPI failed to scan_land the type BIN on rank: ", rank
         print*, send
         print*, b
      end if

   end

   test_scan_land(rank,mpi,send,recv,test) ::: template
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      b = send
      b = FALSE
      mpi.scan_land(send,b)
      if (all(b EQV test)) then
         print*, "MPI can succesfully scan_land the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_land the type VAR_TYPE on rank: ", rank
         print*, send
         print*, b
      end if

   end

   test_scan_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
   end

!=====
! Lxor
!=====

   test_reduce_lxor(rank,mpi,send,recv,test) 
   ! Test the reduce_lxor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.reduce_lxor(send,0,b)
         if (b EQV test) then
            print*, "MPI can succesfully reduce_lxor the type BIN"
         else
            print*, "MPI failed to reduce_lxor the type BIN"
            print*, b
            print*, test
         end if
      else
         mpi.reduce_lxor(send,0)
      end if

   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: template
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         b = recv
         b = FALSE
         mpi.reduce_lxor(send,0,b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully reduce_lxor the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_lxor the type VAR_TYPE"
            print*, b
            print*, test
         end if
      else
         mpi.reduce_lxor(send,0)
      end if

   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
   end

!========
! AllLxor
!========

   test_parallel_xor(rank,mpi,send,recv,test) 
   ! Test the parallel_xor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      mpi.parallel_xor(send,b)
      if (b EQV test) then
         print*, "MPI can succesfully parallel_lxor the type BIN on rank: ", rank
      else
         print*, "MPI failed to parallel_lxor the type BIN on rank: ", rank
         print*, send
         print*, test
      end if

   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: template
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      b = recv
      b = FALSE
      mpi.parallel_xor(send,b)
      if (all(b EQV test)) then
         print*, "MPI can succesfully parallel_lxor the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to parallel_lxor the type VAR_TYPE on rank: ", rank
         print*, send
         print*, test
      end if

   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
   end

!==========
! Scan Lxor
!==========

   test_scan_lxor(rank,mpi,send,recv,test) 
   ! Test the scan_lxor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      mpi.scan_lxor(send,b)
      if (b EQV test) then
         print*, "MPI can succesfully scan_lxor the type BIN on rank: ", rank
      else
         print*, "MPI failed to scan_lxor the type BIN on rank: ", rank
         print*, send
         print*, b
      end if

   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: template
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      b = send
      b = FALSE
      mpi.scan_lxor(send,b)
      if (all(b EQV test)) then
         print*, "MPI can succesfully scan_lxor the type VAR_TYPE on rank: ", rank
      else
         print*, "MPI failed to scan_lxor the type VAR_TYPE on rank: ", rank
         print*, send
         print*, b
      end if

   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
   end

!========
! Barrier
!========

   test_barrier(rank,mpi) 
   ! Test the barrier routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      a,b  :: INT
      time2,time1 :: REAL
      
      if(rank == 0) then
         call sleep(1)
         mpi.barrier
      else
         mpi.wtime(time1)
         mpi.barrier
         mpi.wtime(time2)
         if(time2-time1>1) print*, "Barrier and wtime both function correctly"
      end if

   end


end
