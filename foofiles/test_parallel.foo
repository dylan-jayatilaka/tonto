module TEST_PARALLEL

implicit none

contains

   send_testing_suite :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM@

      allocate(mpi)

      mpi.init
      .sending_mpi_test(mpi)
      .ssending_mpi_test(mpi)
      .isending_mpi_test(mpi)
      .issending_mpi_test(mpi)
      .sendrecv_mpi_test(mpi)
      .gather_mpi_test(mpi)
      .allgather_mpi_test(mpi)
      .bcast_mpi_test(mpi)
      .scatter_mpi_test(mpi)
      .alltoall_mpi_test(mpi)
      .sum_mpi_test(mpi)
      .allsum_mpi_test(mpi)
      .scansum_mpi_test(mpi)
      .prod_mpi_test(mpi)
      .allprod_mpi_test(mpi)
      .scanprod_mpi_test(mpi)
      .max_mpi_test(mpi)
      .allmax_mpi_test(mpi)
      .scanmax_mpi_test(mpi)
      .min_mpi_test(mpi)
      .allmin_mpi_test(mpi)
      .scanmin_mpi_test(mpi)
      .lor_mpi_test(mpi)
      .alllor_mpi_test(mpi)
      .scanlor_mpi_test(mpi)
      .land_mpi_test(mpi)
      .allland_mpi_test(mpi)
      .scanland_mpi_test(mpi)
      .lxor_mpi_test(mpi)
      .alllxor_mpi_test(mpi)
      .scanlxor_mpi_test(mpi)
      !.maxloc_mpi_test(mpi)
      !.minloc_mpi_test(mpi)
      .barrier_mpi_test(mpi)
      !.igather_mpi_test(mpi)
      
      mpi.finalize
   end 

   sending_mpi_test(mpi) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_send(rank,mpi,str_a,str_b)
      .test_send(rank,mpi,int_a,int_b)
      .test_send(rank,mpi,bin_a,bin_b)
      .test_send(rank,mpi,real_a,real_b)
      .test_send(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_send(rank,mpi,str_va,str_vb)
      .test_send(rank,mpi,int_va,int_vb)
      .test_send(rank,mpi,bin_va,bin_vb)
      .test_send(rank,mpi,real_va,real_vb)
      .test_send(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_send(rank,mpi,str_ma,str_mb)
      .test_send(rank,mpi,int_ma,int_mb)
      .test_send(rank,mpi,bin_ma,bin_mb)
      .test_send(rank,mpi,real_ma,real_mb)
      .test_send(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_send(rank,mpi,int_m3a,int_m3b)
      .test_send(rank,mpi,bin_m3a,bin_m3b)
      .test_send(rank,mpi,real_m3a,real_m3b)
      .test_send(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_send(rank,mpi,int_m4a,int_m4b)
      .test_send(rank,mpi,real_m4a,real_m4b)
      .test_send(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_send(rank,mpi,real_m5a,real_m5b)
      .test_send(rank,mpi,int_m5a,int_m5b)
      .test_send(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   ssending_mpi_test(mpi) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_ssend(rank,mpi,str_a,str_b)
      .test_ssend(rank,mpi,int_a,int_b)
      .test_ssend(rank,mpi,bin_a,bin_b)
      .test_ssend(rank,mpi,real_a,real_b)
      .test_ssend(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_ssend(rank,mpi,str_va,str_vb)
      .test_ssend(rank,mpi,int_va,int_vb)
      .test_ssend(rank,mpi,bin_va,bin_vb)
      .test_ssend(rank,mpi,real_va,real_vb)
      .test_ssend(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_ssend(rank,mpi,str_ma,str_mb)
      .test_ssend(rank,mpi,int_ma,int_mb)
      .test_ssend(rank,mpi,bin_ma,bin_mb)
      .test_ssend(rank,mpi,real_ma,real_mb)
      .test_ssend(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_ssend(rank,mpi,int_m3a,int_m3b)
      .test_ssend(rank,mpi,bin_m3a,bin_m3b)
      .test_ssend(rank,mpi,real_m3a,real_m3b)
      .test_ssend(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_ssend(rank,mpi,int_m4a,int_m4b)
      .test_ssend(rank,mpi,real_m4a,real_m4b)
      .test_ssend(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_ssend(rank,mpi,real_m5a,real_m5b)
      .test_ssend(rank,mpi,cpx_m5a,cpx_m5b)
      .test_ssend(rank,mpi,int_m5a,int_m5b)
      
   
   end

   isending_mpi_test(mpi) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fish"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
           ! str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_isend(rank,mpi,str_a,str_b)
      .test_isend(rank,mpi,int_a,int_b)
      .test_isend(rank,mpi,bin_a,bin_b)
      .test_isend(rank,mpi,real_a,real_b)
      .test_isend(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_isend(rank,mpi,str_va,str_vb)
      .test_isend(rank,mpi,int_va,int_vb)
      .test_isend(rank,mpi,bin_va,bin_vb)
      .test_isend(rank,mpi,real_va,real_vb)
      .test_isend(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"]
      str_mb = "no"
      .test_isend(rank,mpi,str_ma,str_mb)
      .test_isend(rank,mpi,int_ma,int_mb)
      .test_isend(rank,mpi,bin_ma,bin_mb)
      .test_isend(rank,mpi,real_ma,real_mb)
      .test_isend(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_isend(rank,mpi,int_m3a,int_m3b)
      .test_isend(rank,mpi,bin_m3a,bin_m3b)
      .test_isend(rank,mpi,real_m3a,real_m3b)
      .test_isend(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_isend(rank,mpi,int_m4a,int_m4b)
      .test_isend(rank,mpi,real_m4a,real_m4b)
      .test_isend(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_isend(rank,mpi,real_m5a,real_m5b)
      .test_isend(rank,mpi,cpx_m5a,cpx_m5b)
      .test_isend(rank,mpi,int_m5a,int_m5b)
      
   
   end

   issending_mpi_test(mpi) :::  public
   ! This routine calls and tests all send and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_issend(rank,mpi,str_a,str_b)
      .test_issend(rank,mpi,int_a,int_b)
      .test_issend(rank,mpi,bin_a,bin_b)
      .test_issend(rank,mpi,real_a,real_b)
      .test_issend(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_issend(rank,mpi,str_va,str_vb)
      .test_issend(rank,mpi,int_va,int_vb)
      .test_issend(rank,mpi,bin_va,bin_vb)
      .test_issend(rank,mpi,real_va,real_vb)
      .test_issend(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"]
      str_mb = "no"
      .test_issend(rank,mpi,str_ma,str_mb)
      .test_issend(rank,mpi,int_ma,int_mb)
      .test_issend(rank,mpi,bin_ma,bin_mb)
      .test_issend(rank,mpi,real_ma,real_mb)
      .test_issend(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_issend(rank,mpi,int_m3a,int_m3b)
      .test_issend(rank,mpi,bin_m3a,bin_m3b)
      .test_issend(rank,mpi,real_m3a,real_m3b)
      .test_issend(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_issend(rank,mpi,int_m4a,int_m4b)
      .test_issend(rank,mpi,real_m4a,real_m4b)
      .test_issend(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_issend(rank,mpi,real_m5a,real_m5b)
      .test_issend(rank,mpi,int_m5a,int_m5b)
      .test_issend(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   sendrecv_mpi_test(mpi) :::  public
   ! This routine calls and tests all sendreceive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            int_mb(i,j) = i+j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
               bin_mb(i,j) = FALSE
            else
               bin_ma(i,j) = FALSE
               bin_mb(i,j) = TRUE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(real(i)*1.0,real(j)*2.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = real(j**4)+real(i**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = i+j+k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
                  bin_m3b(i,j,k) = FALSE
               else
                  bin_m3a(i,j,k) = FALSE
                  bin_m3b(i,j,k) = TRUE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(real(i+j),3*real(k))
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = real(i*j*k)/123.3
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = i+j+k+l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(i+j+0.5,k+l+0.21212)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 4.4444*(real(k**l))+real(i+j)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(real(i*j**k),real(l)/real(m))
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = real(m**i)+real(j*k)/real(l)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_sendrecv(rank,mpi,str_a,str_b)
      .test_sendrecv(rank,mpi,int_a,int_b)
      .test_sendrecv(rank,mpi,bin_a,bin_b)
      .test_sendrecv(rank,mpi,real_a,real_b)
      .test_sendrecv(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_sendrecv(rank,mpi,str_va,str_vb)
      .test_sendrecv(rank,mpi,int_va,int_vb)
      .test_sendrecv(rank,mpi,bin_va,bin_vb)
      .test_sendrecv(rank,mpi,real_va,real_vb)
      .test_sendrecv(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_sendrecv(rank,mpi,str_ma,str_mb)
      .test_sendrecv(rank,mpi,int_ma,int_mb)
      .test_sendrecv(rank,mpi,bin_ma,bin_mb)
      .test_sendrecv(rank,mpi,real_ma,real_mb)
      .test_sendrecv(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_sendrecv(rank,mpi,int_m3a,int_m3b)
      .test_sendrecv(rank,mpi,bin_m3a,bin_m3b)
      .test_sendrecv(rank,mpi,real_m3a,real_m3b)
      .test_sendrecv(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_sendrecv(rank,mpi,int_m4a,int_m4b)
      .test_sendrecv(rank,mpi,real_m4a,real_m4b)
      .test_sendrecv(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_sendrecv(rank,mpi,real_m5a,real_m5b)
      .test_sendrecv(rank,mpi,int_m5a,int_m5b)
      .test_sendrecv(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   gather_mpi_test(mpi) :::  public
   ! This routine calls and tests gather functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a :: INT
      str_a     :: STR
      bin_a     :: BIN
      cpx_a     :: CPX
      real_a   :: REAL
      int_va,int_vb,int_b,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_b,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_b,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_b,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_b,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      int_m5b,int_m5t   :: MAT5{INT}@
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_b(commsize))
      allocate(str_t(commsize))
      allocate(int_b(commsize))
      allocate(int_t(commsize))
      allocate(bin_b(commsize))
      allocate(bin_t(commsize))
      allocate(real_b(commsize))
      allocate(real_t(commsize))
      allocate(cpx_b(commsize))
      allocate(cpx_t(commsize))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_gather(commsize,rank,mpi,str_t,str_a,str_b)
      .test_gather(commsize,rank,mpi,int_t,int_a,int_b)
      .test_gather(commsize,rank,mpi,bin_t,bin_a,bin_b)
      .test_gather(commsize,rank,mpi,real_t,real_a,real_b)
      .test_gather(commsize,rank,mpi,cpx_t,cpx_a,cpx_b)
      deallocate(str_b)
      deallocate(str_t)
      deallocate(int_b)
      deallocate(int_t)
      deallocate(bin_b)
      deallocate(bin_t)
      deallocate(real_b)
      deallocate(real_t)
      deallocate(cpx_b)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(commsize*str_va.dim))
      allocate(int_vb(commsize*int_va.dim))
      allocate(bin_vb(commsize*bin_va.dim))
      allocate(real_vb(commsize*real_va.dim))
      allocate(cpx_vb(commsize*cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_gather(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_gather(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_gather(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_gather(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_gather(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mb(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,commsize*cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_gather(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_gather(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_gather(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_gather(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_gather(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      !if(rank == 1) then   
      !   print*, "======="
      !   print*, "Complex:"
      !   print*, "======="
      !   do i = 1, cpx_mb.dim1
      !      do j = 1,cpx_mb.dim2
      !         print*,"M(",i,",",j,"): ",  cpx_mb(i,j)
      !         print*,"T(",i,",",j,"): ",  cpx_mt(i,j)
      !      end do
      !   end do
      !end if
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_gather(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_gather(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_gather(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_gather(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_gather(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_gather(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_gather(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      int_m5t = 0
      real_m5t = 0.0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
      end do
      .test_gather(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_gather(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_gather(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(int_m5b)
      deallocate(cpx_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   
   end

   igather_mpi_test(mpi) :::  public
   ! This routine calls and tests gather functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a :: INT
      reqs :: VEC{INT}@
      str_a     :: STR
      bin_a     :: BIN
      cpx_a     :: CPX
      real_a   :: REAL
      int_va,int_vb,int_b,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_b,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_b,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_b,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_b,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      int_m5b,int_m5t   :: MAT5{INT}@
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_b(commsize))
      allocate(str_t(commsize))
      allocate(int_b(commsize))
      allocate(int_t(commsize))
      allocate(bin_b(commsize))
      allocate(bin_t(commsize))
      allocate(real_b(commsize))
      allocate(real_t(commsize))
      allocate(cpx_b(commsize))
      allocate(cpx_t(commsize))
      allocate(reqs(5))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_igather(commsize,rank,mpi,str_a,str_b,i)
      reqs(1) = i
      .test_igather(commsize,rank,mpi,int_a,int_b,i)
      reqs(2) = i
      .test_igather(commsize,rank,mpi,bin_a,bin_b,i)
      reqs(3) = i
      .test_igather(commsize,rank,mpi,real_a,real_b,i)
      reqs(4) = i
      .test_igather(commsize,rank,mpi,cpx_a,cpx_b,i)
      reqs(5) = i
         print*, "waiting"
         i = reqs(1)
         mpi.parallel_wait(i)
         i = reqs(2)
         mpi.parallel_wait(i)
         i = reqs(3)
         mpi.parallel_wait(i)
         i = reqs(4)
         mpi.parallel_wait(i)
         i = reqs(5)
         mpi.parallel_wait(i)
         print*, "I'm done waiting"
      if(rank == 1) then
         print*, "Moving to check now"
         if (all(str_b == str_t)) then
            print*, "MPI can succesfully gather the type STR in a nonblocking way"
         else
            print*, "MPI failed to gather the type STR in a nonblocking way"
         end if
         if (all(int_b == int_t)) then
            print*, "MPI can succesfully gather the type INT in a nonblocking way"
         else
            print*, "MPI failed to gather the type INT in a non blocking way"
         end if
         if (all(bin_b EQV bin_t)) then
            print*, "MPI can succesfully gather the type BIN"
         else
            print*, "MPI failed to gather the type BIN"
         end if
         if (all(real_b == real_t)) then
            print*, "MPI can succesfully gather the type REAL"
         else
            print*, "MPI failed to gather the type REAL"
         end if
         if (all(cpx_b == cpx_t)) then
            print*, "MPI can succesfully gather the type CPX"
         else
            print*, "MPI failed to gather the type CPX"
         end if
      end if
      mpi.barrier
      stop
      deallocate(str_b)
      deallocate(str_t)
      deallocate(int_b)
      deallocate(int_t)
      deallocate(bin_b)
      deallocate(bin_t)
      deallocate(real_b)
      deallocate(real_t)
      deallocate(cpx_b)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(commsize*str_va.dim))
      allocate(int_vb(commsize*int_va.dim))
      allocate(bin_vb(commsize*bin_va.dim))
      allocate(real_vb(commsize*real_va.dim))
      allocate(cpx_vb(commsize*cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_igather(commsize,rank,mpi,str_va,str_vb,i)
      print*,"Sent: ",  str_va
      if(rank == 1) then   
         print*, "======="
         print*, "STR:"
         print*, "======="
         do i = 1, str_vb.dim
               print*,"M(",i,"): ",  str_vb(i)
               print*,"T(",i,"): ",  str_vt(i)
         end do
      end if
      .test_igather(commsize,rank,mpi,int_va,int_vb,i)
      if(rank == 1) then   
         print*, "======="
         print*, "INT:"
         print*, "======="
         do i = 1, int_vb.dim
               print*,"M(",i,"): ",  int_vb(i)
               print*,"T(",i,"): ",  int_vt(i)
         end do
      end if
      .test_igather(commsize,rank,mpi,bin_va,bin_vb,i)
      .test_igather(commsize,rank,mpi,real_va,real_vb,i)
      .test_igather(commsize,rank,mpi,cpx_va,cpx_vb,i)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mb(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,commsize*cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_igather(commsize,rank,mpi,str_ma,str_mb,i)
      .test_igather(commsize,rank,mpi,int_ma,int_mb,i)
      .test_igather(commsize,rank,mpi,bin_ma,bin_mb,i)
      .test_igather(commsize,rank,mpi,real_ma,real_mb,i)
      .test_igather(commsize,rank,mpi,cpx_ma,cpx_mb,i)
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_igather(commsize,rank,mpi,int_m3a,int_m3b,i)
      .test_igather(commsize,rank,mpi,bin_m3a,bin_m3b,i)
      .test_igather(commsize,rank,mpi,real_m3a,real_m3b,i)
      .test_igather(commsize,rank,mpi,cpx_m3a,cpx_m3b,i)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_igather(commsize,rank,mpi,int_m4a,int_m4b,i)
      .test_igather(commsize,rank,mpi,real_m4a,real_m4b,i)
      .test_igather(commsize,rank,mpi,cpx_m4a,cpx_m4b,i)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      int_m5t = 0
      real_m5t = 0.0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
      end do
      .test_igather(commsize,rank,mpi,real_m5a,real_m5b,i)
      .test_igather(commsize,rank,mpi,cpx_m5a,cpx_m5b,i)
      .test_igather(commsize,rank,mpi,int_m5a,int_m5b,i)
      deallocate(real_m5b)
      deallocate(cpx_m5b)
      deallocate(int_m5b)
      deallocate(real_m5t)
      deallocate(cpx_m5t)
      deallocate(int_m5t)
      
   
   end

   allgather_mpi_test(mpi) :::  public
   ! This routine calls and tests gather functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a :: INT
      str_a     :: STR
      bin_a     :: BIN
      cpx_a     :: CPX
      real_a   :: REAL
      int_va,int_vb,int_b,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_b,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_b,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_b,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_b,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      int_m5b,int_m5t   :: MAT5{INT}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_b(commsize))
      allocate(str_t(commsize))
      allocate(int_b(commsize))
      allocate(int_t(commsize))
      allocate(bin_b(commsize))
      allocate(bin_t(commsize))
      allocate(real_b(commsize))
      allocate(real_t(commsize))
      allocate(cpx_b(commsize))
      allocate(cpx_t(commsize))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_allgather(commsize,rank,mpi,str_t,str_a,str_b)
      .test_allgather(commsize,rank,mpi,int_t,int_a,int_b)
      .test_allgather(commsize,rank,mpi,bin_t,bin_a,bin_b)
      .test_allgather(commsize,rank,mpi,real_t,real_a,real_b)
      .test_allgather(commsize,rank,mpi,cpx_t,cpx_a,cpx_b)
      deallocate(str_b)
      deallocate(str_t)
      deallocate(int_b)
      deallocate(int_t)
      deallocate(bin_b)
      deallocate(bin_t)
      deallocate(real_b)
      deallocate(real_t)
      deallocate(cpx_b)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(commsize*str_va.dim))
      allocate(int_vb(commsize*int_va.dim))
      allocate(bin_vb(commsize*bin_va.dim))
      allocate(real_vb(commsize*real_va.dim))
      allocate(cpx_vb(commsize*cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_allgather(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_allgather(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_allgather(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_allgather(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_allgather(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mb(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,commsize*cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_allgather(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_allgather(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_allgather(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_allgather(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_allgather(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      !if(rank == 1) then   
      !   print*, "======="
      !   print*, "Complex:"
      !   print*, "======="
      !   do i = 1, cpx_mb.dim1
      !      do j = 1,cpx_mb.dim2
      !         print*,"M(",i,",",j,"): ",  cpx_mb(i,j)
      !         print*,"T(",i,",",j,"): ",  cpx_mt(i,j)
      !      end do
      !   end do
      !end if
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_allgather(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_allgather(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_allgather(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_allgather(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_allgather(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_allgather(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_allgather(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      int_m5t = 0
      real_m5t = 0.0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
      end do
      .test_allgather(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_allgather(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_allgather(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(int_m5b)
      deallocate(cpx_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   
   end

   bcast_mpi_test(mpi) :::  public
   ! This routine calls and tests the bcast functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      bin_a  = TRUE
      bin_b  = FALSE
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = [2,5]
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      .test_bcast(rank,mpi,str_a,str_b)
      .test_bcast(rank,mpi,int_a,int_b)
      .test_bcast(rank,mpi,bin_a,bin_b)
      .test_bcast(rank,mpi,real_a,real_b)
      .test_bcast(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_bcast(rank,mpi,str_va,str_vb)
      .test_bcast(rank,mpi,int_va,int_vb)
      .test_bcast(rank,mpi,bin_va,bin_vb)
      .test_bcast(rank,mpi,real_va,real_vb)
      .test_bcast(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_bcast(rank,mpi,str_ma,str_mb)
      .test_bcast(rank,mpi,int_ma,int_mb)
      .test_bcast(rank,mpi,bin_ma,bin_mb)
      .test_bcast(rank,mpi,real_ma,real_mb)
      .test_bcast(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_bcast(rank,mpi,int_m3a,int_m3b)
      .test_bcast(rank,mpi,bin_m3a,bin_m3b)
      .test_bcast(rank,mpi,real_m3a,real_m3b)
      .test_bcast(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_bcast(rank,mpi,int_m4a,int_m4b)
      .test_bcast(rank,mpi,real_m4a,real_m4b)
      .test_bcast(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_bcast(rank,mpi,real_m5a,real_m5b)
      .test_bcast(rank,mpi,cpx_m5a,cpx_m5b)
      .test_bcast(rank,mpi,int_m5a,int_m5b)
      
   
   end

   scatter_mpi_test(mpi) :::  public
   ! This routine calls and tests scatter functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb,int_t,int_vt   :: VEC{INT}@
      str_va,str_vb,str_t,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_t,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_t,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_t,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(3,3)
      str_ma   :: MAT{STR}(3,3)
      bin_ma   :: MAT{BIN}(3,3)
      cpx_ma   :: MAT{CPX}(3,3)
      real_ma :: MAT{REAL}(3,3)
      int_mb,int_mt   :: MAT{INT}@
      str_mb,str_mt   :: MAT{STR}@
      bin_mb,bin_mt   :: MAT{BIN}@
      cpx_mb,cpx_mt   :: MAT{CPX}@
      real_mb,real_mt :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(3,3,3)
      bin_m3a   :: MAT3{BIN}(3,3,3)
      cpx_m3a   :: MAT3{CPX}(3,3,3)
      real_m3a :: MAT3{REAL}(3,3,3)
      int_m3b,int_m3t   :: MAT3{INT}@
      bin_m3b,bin_m3t   :: MAT3{BIN}@
      cpx_m3b,cpx_m3t   :: MAT3{CPX}@
      real_m3b,real_m3t :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(3,3,3,3)
      cpx_m4a   :: MAT4{CPX}(3,3,3,3)
      real_m4a :: MAT4{REAL}(3,3,3,3)
      int_m4b,int_m4t   :: MAT4{INT}@
      cpx_m4b,cpx_m4t   :: MAT4{CPX}@
      real_m4b,real_m4t :: MAT4{REAL}@
      int_m5a   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a :: MAT5{REAL}(3,3,3,3,3)
      int_m5b,int_m5t   :: MAT5{INT}@
      cpx_m5b,cpx_m5t   :: MAT5{CPX}@
      real_m5b,real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_a  = "blah"
      int_a  = 4
      bin_a  = TRUE
      cpx_a  = cmplx(4.3,123.2)
      real_a = 1.34
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines

      ! Single numbers
      allocate(str_t(commsize))
      allocate(int_t(commsize))
      allocate(bin_t(commsize))
      allocate(real_t(commsize))
      allocate(cpx_t(commsize))
      str_t  = ''
      int_t  = 0
      bin_t  = FALSE
      real_t = 0.0
      cpx_t  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_t(i)  = str_a
         int_t(i)  = int_a
         bin_t(i)  = bin_a
         real_t(i) = real_a
         cpx_t(i)  = cpx_a
       end do
      .test_scatter(commsize,rank,mpi,str_t,str_a,str_b)
      .test_scatter(commsize,rank,mpi,int_t,int_a,int_b)
      .test_scatter(commsize,rank,mpi,bin_t,bin_a,bin_b)
      .test_scatter(commsize,rank,mpi,real_t,real_a,real_b)
      .test_scatter(commsize,rank,mpi,cpx_t,cpx_a,cpx_b)
      deallocate(str_t)
      deallocate(int_t)
      deallocate(bin_t)
      deallocate(real_t)
      deallocate(cpx_t)
   
      ! Vectors
      allocate(str_vb(str_va.dim))
      allocate(int_vb(int_va.dim))
      allocate(bin_vb(bin_va.dim))
      allocate(real_vb(real_va.dim))
      allocate(cpx_vb(cpx_va.dim))
      allocate(str_vt(commsize*str_va.dim))
      allocate(int_vt(commsize*int_va.dim))
      allocate(bin_vt(commsize*bin_va.dim))
      allocate(real_vt(commsize*real_va.dim))
      allocate(cpx_vt(commsize*cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim+1:i*str_va.dim)  = str_va
         int_vt((i-1)*int_va.dim+1:i*int_va.dim)  = int_va
         bin_vt((i-1)*bin_va.dim+1:i*bin_va.dim)  = bin_va
         real_vt((i-1)*real_va.dim+1:i*real_va.dim)  = real_va
         cpx_vt((i-1)*cpx_va.dim+1:i*cpx_va.dim)  = cpx_va
      end do
      .test_scatter(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_scatter(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_scatter(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_scatter(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_scatter(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,str_ma.dim2))
      allocate(int_mb(int_ma.dim1,int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,commsize*str_ma.dim2))
      allocate(int_mt(int_ma.dim1,commsize*int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,commsize*bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,commsize*real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,commsize*cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2+1:i*str_ma.dim2)  = str_ma
         int_mt(:,(i-1)*int_ma.dim2+1:i*int_ma.dim2)  = int_ma
         bin_mt(:,(i-1)*bin_ma.dim2+1:i*bin_ma.dim2)  = bin_ma
         real_mt(:,(i-1)*real_ma.dim2+1:i*real_ma.dim2)  = real_ma
         cpx_mt(:,(i-1)*cpx_ma.dim2+1:i*cpx_ma.dim2)  = cpx_ma
      end do
      .test_scatter(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_scatter(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_scatter(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_scatter(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_scatter(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      !if(rank == 1) then   
      !   print*, "======="
      !   print*, "Complex:"
      !   print*, "======="
      !   do i = 1, cpx_mb.dim1
      !      do j = 1,cpx_mb.dim2
      !         print*,"M(",i,",",j,"): ",  cpx_mb(i,j)
      !         print*,"T(",i,",",j,"): ",  cpx_mt(i,j)
      !      end do
      !   end do
      !end if
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,commsize*int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,commsize*bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,commsize*real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,commsize*cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3+1:i*int_m3a.dim3)  = int_m3a
         bin_m3t(:,:,(i-1)*bin_m3a.dim3+1:i*bin_m3a.dim3)  = bin_m3a
         real_m3t(:,:,(i-1)*real_m3a.dim3+1:i*real_m3a.dim3)  = real_m3a
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3+1:i*cpx_m3a.dim3)  = cpx_m3a
      end do
      .test_scatter(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_scatter(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_scatter(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_scatter(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,commsize*int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,commsize*real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,commsize*cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4+1:i*int_m4a.dim4)  = int_m4a
         real_m4t(:,:,:,(i-1)*real_m4a.dim4+1:i*real_m4a.dim4)  = real_m4a
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4+1:i*cpx_m4a.dim4)  = cpx_m4a
      end do
      .test_scatter(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_scatter(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_scatter(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,commsize*real_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,commsize*int_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,commsize*cpx_m5a.dim5))
      real_m5t = 0.0
      int_m5t  = 0
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5+1:i*real_m5a.dim5)  = real_m5a
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5+1:i*int_m5a.dim5)  = int_m5a
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5+1:i*cpx_m5a.dim5)  = cpx_m5a
      end do
      .test_scatter(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_scatter(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_scatter(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(cpx_m5b)
      deallocate(int_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   
   end

   alltoall_mpi_test(mpi) :::  public
   ! This routine calls and tests alltoall functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,commsize :: INT
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma   :: MAT{INT}(2,2)
      str_ma   :: MAT{STR}(2,2)
      bin_ma   :: MAT{BIN}(2,2)
      cpx_ma   :: MAT{CPX}(2,2)
      real_ma :: MAT{REAL}(2,2)
      int_mt   :: MAT{INT}@
      str_mt   :: MAT{STR}@
      bin_mt   :: MAT{BIN}@
      cpx_mt   :: MAT{CPX}@
      real_mt :: MAT{REAL}@
      int_mb   :: MAT{INT}@
      str_mb   :: MAT{STR}@
      bin_mb   :: MAT{BIN}@
      cpx_mb   :: MAT{CPX}@
      real_mb :: MAT{REAL}@
      int_m3a   :: MAT3{INT}(2,2,2)
      bin_m3a   :: MAT3{BIN}(2,2,2)
      cpx_m3a   :: MAT3{CPX}(2,2,2)
      real_m3a :: MAT3{REAL}(2,2,2)
      int_m3t   :: MAT3{INT}@
      bin_m3t   :: MAT3{BIN}@
      cpx_m3t   :: MAT3{CPX}@
      real_m3t :: MAT3{REAL}@
      int_m3b   :: MAT3{INT}@
      bin_m3b   :: MAT3{BIN}@
      cpx_m3b   :: MAT3{CPX}@
      real_m3b :: MAT3{REAL}@
      int_m4a   :: MAT4{INT}(2,2,2,2)
      cpx_m4a   :: MAT4{CPX}(2,2,2,2)
      real_m4a :: MAT4{REAL}(2,2,2,2)
      int_m4b   :: MAT4{INT}@
      cpx_m4b   :: MAT4{CPX}@
      real_m4b :: MAT4{REAL}@
      int_m4t   :: MAT4{INT}@
      cpx_m4t   :: MAT4{CPX}@
      real_m4t :: MAT4{REAL}@
      int_m5a   :: MAT5{INT}(2,2,2,2,2)
      cpx_m5a   :: MAT5{CPX}(2,2,2,2,2)
      real_m5a :: MAT5{REAL}(2,2,2,2,2)
      int_m5b   :: MAT5{INT}@
      cpx_m5b   :: MAT5{CPX}@
      real_m5b :: MAT5{REAL}@
      int_m5t   :: MAT5{INT}@
      cpx_m5t   :: MAT5{CPX}@
      real_m5t :: MAT5{REAL}@
      
      mpi.comm_rank(rank)
      mpi.comm_size(commsize)
      
      ! Initialise all the variables for send testing.
      str_va  = ["blah","dogg"]
      int_va  = [4,2]
      bin_va  = [TRUE,FALSE]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      real_va = [1.34,34.5]
      str_ma(1,:) = ["a","b"] 
      str_ma(2,:) = ["d","e"] 
      do i = 1,2
         do j = 1,2
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,2
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,2
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,2
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      
      ! Call the routines
   
      ! Vectors
      allocate(str_vb(str_va.dim))
      allocate(int_vb(int_va.dim))
      allocate(bin_vb(bin_va.dim))
      allocate(real_vb(real_va.dim))
      allocate(cpx_vb(cpx_va.dim))
      allocate(str_vt(str_va.dim))
      allocate(int_vt(int_va.dim))
      allocate(bin_vt(bin_va.dim))
      allocate(real_vt(real_va.dim))
      allocate(cpx_vt(cpx_va.dim))
      str_vt  = ''
      int_vt  = 0
      bin_vt  = FALSE
      real_vt = 0.0
      cpx_vt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_vt((i-1)*str_va.dim/commsize+1:i/commsize*str_va.dim)  = str_va((rank*str_va.dim/commsize)+1:str_va.dim/commsize*(rank+1)) 
         int_vt((i-1)*int_va.dim/commsize+1:i/commsize*int_va.dim)  = int_va((rank*int_va.dim/commsize)+1:int_va.dim/commsize*(rank+1))
         bin_vt((i-1)*bin_va.dim/commsize+1:i/commsize*bin_va.dim)  = bin_va((rank*bin_va.dim/commsize)+1:bin_va.dim/commsize*(rank+1))
         real_vt((i-1)*real_va.dim/commsize+1:i/commsize*real_va.dim) = real_va((rank*real_va.dim/commsize)+1:real_va.dim/commsize*(rank+1))
         cpx_vt((i-1)*cpx_va.dim/commsize+1:i/commsize*cpx_va.dim)  = cpx_va((rank*cpx_va.dim/commsize)+1:cpx_va.dim/commsize*(rank+1))
      end do
      .test_alltoall(commsize,rank,mpi,str_vt,str_va,str_vb)
      .test_alltoall(commsize,rank,mpi,int_vt,int_va,int_vb)
      .test_alltoall(commsize,rank,mpi,bin_vt,bin_va,bin_vb)
      .test_alltoall(commsize,rank,mpi,real_vt,real_va,real_vb)
      .test_alltoall(commsize,rank,mpi,cpx_vt,cpx_va,cpx_vb)
      deallocate(str_vb)
      deallocate(int_vb)
      deallocate(bin_vb)
      deallocate(real_vb)
      deallocate(cpx_vb)
      deallocate(str_vt)
      deallocate(int_vt)
      deallocate(bin_vt)
      deallocate(real_vt)
      deallocate(cpx_vt)
      
      ! Matrix
      allocate(str_mb(str_ma.dim1,str_ma.dim2))
      allocate(int_mb(int_ma.dim1,int_ma.dim2))
      allocate(bin_mb(bin_ma.dim1,bin_ma.dim2))
      allocate(real_mb(real_ma.dim1,real_ma.dim2))
      allocate(cpx_mb(cpx_ma.dim1,cpx_ma.dim2))
      allocate(str_mt(str_ma.dim1,str_ma.dim2))
      allocate(int_mt(int_ma.dim1,int_ma.dim2))
      allocate(bin_mt(bin_ma.dim1,bin_ma.dim2))
      allocate(real_mt(real_ma.dim1,real_ma.dim2))
      allocate(cpx_mt(cpx_ma.dim1,cpx_ma.dim2))
      str_mt  = ''
      int_mt  = 0
      bin_mt  = FALSE
      real_mt = 0.0
      cpx_mt  = cmplx(0.0,0.0)
      do i = 1,commsize
         str_mt(:,(i-1)*str_ma.dim2/commsize+1:i*str_ma.dim2/commsize) = str_ma(:,rank*str_ma.dim2/commsize+1:(rank+1)*str_ma.dim2/commsize)
         int_mt(:,(i-1)*int_ma.dim2/commsize+1:i*int_ma.dim2/commsize) = int_ma(:,rank*int_ma.dim2/commsize+1:(rank+1)*int_ma.dim2/commsize)
         bin_mt(:,(i-1)*bin_ma.dim2/commsize+1:i*bin_ma.dim2/commsize) = bin_ma(:,rank*bin_ma.dim2/commsize+1:(rank+1)*bin_ma.dim2/commsize)
         real_mt(:,(i-1)*real_ma.dim2/commsize+1:i*real_ma.dim2/commsize) = real_ma(:,rank*real_ma.dim2/commsize+1:(rank+1)*real_ma.dim2/commsize)
         cpx_mt(:,(i-1)*cpx_ma.dim2/commsize+1:i*cpx_ma.dim2/commsize) = cpx_ma(:,rank*cpx_ma.dim2/commsize+1:(rank+1)*cpx_ma.dim2/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,str_mt,str_ma,str_mb)
      .test_alltoall(commsize,rank,mpi,int_mt,int_ma,int_mb)
      .test_alltoall(commsize,rank,mpi,bin_mt,bin_ma,bin_mb)
      .test_alltoall(commsize,rank,mpi,real_mt,real_ma,real_mb)
      .test_alltoall(commsize,rank,mpi,cpx_mt,cpx_ma,cpx_mb)
      deallocate(str_mb )
      deallocate(int_mb )
      deallocate(bin_mb )
      deallocate(real_mb)
      deallocate(cpx_mb )
      deallocate(str_mt )
      deallocate(int_mt )
      deallocate(bin_mt )
      deallocate(real_mt)
      deallocate(cpx_mt )
      
      ! Matrix 3s
      allocate(int_m3b(int_m3a.dim1,int_m3a.dim2,int_m3a.dim3))
      allocate(bin_m3b(bin_m3a.dim1,bin_m3a.dim2,bin_m3a.dim3))
      allocate(real_m3b(real_m3a.dim1,real_m3a.dim2,real_m3a.dim3))
      allocate(cpx_m3b(cpx_m3a.dim1,cpx_m3a.dim2,cpx_m3a.dim3))
      allocate(int_m3t(int_m3a.dim1,int_m3a.dim2,int_m3a.dim3))
      allocate(bin_m3t(bin_m3a.dim1,bin_m3a.dim2,bin_m3a.dim3))
      allocate(real_m3t(real_m3a.dim1,real_m3a.dim2,real_m3a.dim3))
      allocate(cpx_m3t(cpx_m3a.dim1,cpx_m3a.dim2,cpx_m3a.dim3))
      int_m3t  = 0
      bin_m3t  = FALSE
      real_m3t = 0.0
      cpx_m3t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m3t(:,:,(i-1)*int_m3a.dim3/commsize+1:i*int_m3a.dim3/commsize) = int_m3a(:,:,rank*int_m3a.dim3/commsize+1:(rank+1)*int_m3a.dim3/commsize)
         bin_m3t(:,:,(i-1)*bin_m3a.dim3/commsize+1:i*bin_m3a.dim3/commsize) = bin_m3a(:,:,rank*bin_m3a.dim3/commsize+1:(rank+1)*bin_m3a.dim3/commsize)
         real_m3t(:,:,(i-1)*real_m3a.dim3/commsize+1:i*real_m3a.dim3/commsize) = real_m3a(:,:,rank*real_m3a.dim3/commsize+1:(rank+1)*real_m3a.dim3/commsize)
         cpx_m3t(:,:,(i-1)*cpx_m3a.dim3/commsize+1:i*cpx_m3a.dim3/commsize) = cpx_m3a(:,:,rank*cpx_m3a.dim3/commsize+1:(rank+1)*cpx_m3a.dim3/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,int_m3t,int_m3a,int_m3b)
      .test_alltoall(commsize,rank,mpi,bin_m3t,bin_m3a,bin_m3b)
      .test_alltoall(commsize,rank,mpi,real_m3t,real_m3a,real_m3b)
      .test_alltoall(commsize,rank,mpi,cpx_m3t,cpx_m3a,cpx_m3b)
      deallocate(int_m3b )
      deallocate(bin_m3b )
      deallocate(real_m3b)
      deallocate(cpx_m3b )
      deallocate(int_m3t )
      deallocate(bin_m3t )
      deallocate(real_m3t)
      deallocate(cpx_m3t )
      
      ! Matrix 4s
      allocate(int_m4b(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,int_m4a.dim4))
      allocate(real_m4b(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,real_m4a.dim4))
      allocate(cpx_m4b(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,cpx_m4a.dim4))
      allocate(int_m4t(int_m4a.dim1,int_m4a.dim2,int_m4a.dim3,int_m4a.dim4))
      allocate(real_m4t(real_m4a.dim1,real_m4a.dim2,real_m4a.dim3,real_m4a.dim4))
      allocate(cpx_m4t(cpx_m4a.dim1,cpx_m4a.dim2,cpx_m4a.dim3,cpx_m4a.dim4))
      int_m4t  = 0
      real_m4t = 0.0
      cpx_m4t  = cmplx(0.0,0.0)
      do i = 1,commsize
         int_m4t(:,:,:,(i-1)*int_m4a.dim4/commsize+1:i*int_m4a.dim4/commsize) = int_m4a(:,:,:,rank*int_m4a.dim4/commsize+1:(rank+1)*int_m4a.dim4/commsize)
         real_m4t(:,:,:,(i-1)*real_m4a.dim4/commsize+1:i*real_m4a.dim4/commsize) = real_m4a(:,:,:,rank*real_m4a.dim4/commsize+1:(rank+1)*real_m4a.dim4/commsize)
         cpx_m4t(:,:,:,(i-1)*cpx_m4a.dim4/commsize+1:i*cpx_m4a.dim4/commsize) = cpx_m4a(:,:,:,rank*cpx_m4a.dim4/commsize+1:(rank+1)*cpx_m4a.dim4/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,int_m4t,int_m4a,int_m4b)
      .test_alltoall(commsize,rank,mpi,real_m4t,real_m4a,real_m4b)
      .test_alltoall(commsize,rank,mpi,cpx_m4t,cpx_m4a,cpx_m4b)
      deallocate(int_m4b )
      deallocate(real_m4b)
      deallocate(cpx_m4b )
      deallocate(int_m4t )
      deallocate(real_m4t)
      deallocate(cpx_m4t )
      
      ! Matrix 5s
      allocate(real_m5b(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,real_m5a.dim5))
      allocate(cpx_m5b(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,cpx_m5a.dim5))
      allocate(int_m5b(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,int_m5a.dim5))
      allocate(real_m5t(real_m5a.dim1,real_m5a.dim2,real_m5a.dim3,real_m5a.dim4,real_m5a.dim5))
      allocate(cpx_m5t(cpx_m5a.dim1,cpx_m5a.dim2,cpx_m5a.dim3,cpx_m5a.dim4,cpx_m5a.dim5))
      allocate(int_m5t(int_m5a.dim1,int_m5a.dim2,int_m5a.dim3,int_m5a.dim4,int_m5a.dim5))
      real_m5t = 0.0
      int_m5t  = 0 
      cpx_m5t  = cmplx(0.0,0.0)
      do i = 1,commsize
         real_m5t(:,:,:,:,(i-1)*real_m5a.dim5/commsize+1:i*real_m5a.dim5/commsize) = real_m5a(:,:,:,:,rank*real_m5a.dim5/commsize+1:(rank+1)*real_m5a.dim5/commsize)
         int_m5t(:,:,:,:,(i-1)*int_m5a.dim5/commsize+1:i*int_m5a.dim5/commsize) = int_m5a(:,:,:,:,rank*int_m5a.dim5/commsize+1:(rank+1)*int_m5a.dim5/commsize)
         cpx_m5t(:,:,:,:,(i-1)*cpx_m5a.dim5/commsize+1:i*cpx_m5a.dim5/commsize) = cpx_m5a(:,:,:,:,rank*cpx_m5a.dim5/commsize+1:(rank+1)*cpx_m5a.dim5/commsize)
      end do
      .test_alltoall(commsize,rank,mpi,real_m5t,real_m5a,real_m5b)
      .test_alltoall(commsize,rank,mpi,int_m5t,int_m5a,int_m5b)
      .test_alltoall(commsize,rank,mpi,cpx_m5t,cpx_m5a,cpx_m5b)
      deallocate(real_m5b)
      deallocate(int_m5b)
      deallocate(cpx_m5b)
      deallocate(real_m5t)
      deallocate(int_m5t)
      deallocate(cpx_m5t)
      
   end

   sum_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_sum and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_sum testing.
      call random_number(rand)
      str_a  = "blah"
      str_b  = "blahblah"
      int_a  = 4  
      int_b  = int_a + int_a 
      bin_a  = TRUE
      bin_b  = TRUE 
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cpx_a + rand*cpx_a
      real_a = 1.34
      real_b = real_a + rand*real_a
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = int_va + int_va
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = cpx_va + rand*cpx_va
      real_va = [1.34,34.5]
      real_vb = real_va + rand*real_va
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_mb = int_ma +     int_ma
      cpx_mb = cpx_ma +     rand*cpx_ma
      real_mb = real_ma +   rand*real_ma
      int_m3b = int_m3a +   int_m3a
      cpx_m3b = cpx_m3a +   rand*cpx_m3a
      real_m3b = real_m3a + rand*real_m3a
      int_m4b = int_m4a +   int_m4a
      cpx_m4b = cpx_m4a +   rand*cpx_m4a
      real_m4b = real_m4a + rand*real_m4a
      cpx_m5b = cpx_m5a +   rand*cpx_m5a
      real_m5b = real_m5a + rand*real_m5a
      int_m5b = int_m5a +   int_m5a

      
      if (rank == 1) then
         cpx_a   =    rand*cpx_a
         real_a  =    rand*real_a
         cpx_va   =    rand*cpx_va
         real_va  =    rand*real_va
         cpx_ma   =    rand*cpx_ma
         real_ma  =    rand*real_ma
         cpx_m3a  =    rand*cpx_m3a
         real_m3a =    rand*real_m3a
         cpx_m4a  =    rand*cpx_m4a
         real_m4a =    rand*real_m4a
         cpx_m5a  =    rand*cpx_m5a
         real_m5a =    rand*real_m5a
      end if

      ! Call the routines

      ! Single numbers
      .test_reduce_sum(rank,mpi,int_a,int_b)
      .test_reduce_sum(rank,mpi,real_a,real_b)
      .test_reduce_sum(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_reduce_sum(rank,mpi,int_va,int_vb)
      .test_reduce_sum(rank,mpi,real_va,real_vb)
      .test_reduce_sum(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_reduce_sum(rank,mpi,int_ma,int_mb)
      .test_reduce_sum(rank,mpi,real_ma,real_mb)
      .test_reduce_sum(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_reduce_sum(rank,mpi,int_m3a,int_m3b)
      .test_reduce_sum(rank,mpi,real_m3a,real_m3b)
      .test_reduce_sum(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_reduce_sum(rank,mpi,int_m4a,int_m4b)
      .test_reduce_sum(rank,mpi,real_m4a,real_m4b)
      .test_reduce_sum(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_reduce_sum(rank,mpi,real_m5a,real_m5b)
      .test_reduce_sum(rank,mpi,cpx_m5a,cpx_m5b)
      .test_reduce_sum(rank,mpi,int_m5a,int_m5b)
      
   
   end

   allsum_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_sum and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_sum testing.
      int_a  = 4  
      int_b  = int_a + int_a 
      bin_a  = TRUE
      bin_b  = TRUE 
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cpx_a + cpx_a
      real_a = 1.34
      real_b = real_a + real_a
      int_va  = [4,2]
      int_vb  = int_va + int_va
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = cpx_va + cpx_va
      real_va = [1.34,34.5]
      real_vb = real_va + real_va
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_mb = int_ma +     int_ma
      cpx_mb = cpx_ma +     cpx_ma
      real_mb = real_ma +   real_ma
      int_m3b = int_m3a +   int_m3a
      cpx_m3b = cpx_m3a +   cpx_m3a
      real_m3b = real_m3a + real_m3a
      int_m4b = int_m4a +   int_m4a
      cpx_m4b = cpx_m4a +   cpx_m4a
      real_m4b = real_m4a + real_m4a
      int_m5b = int_m5a +   int_m5a
      cpx_m5b = cpx_m5a +   cpx_m5a
      real_m5b = real_m5a + real_m5a

      
      ! Call the routines

      ! Single numbers
      .test_parallel_sum(rank,mpi,int_a,int_b)
      .test_parallel_sum(rank,mpi,real_a,real_b)
      .test_parallel_sum(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_parallel_sum(rank,mpi,int_va,int_vb)
      .test_parallel_sum(rank,mpi,real_va,real_vb)
      .test_parallel_sum(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_parallel_sum(rank,mpi,int_ma,int_mb)
      .test_parallel_sum(rank,mpi,real_ma,real_mb)
      .test_parallel_sum(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_parallel_sum(rank,mpi,int_m3a,int_m3b)
      .test_parallel_sum(rank,mpi,real_m3a,real_m3b)
      .test_parallel_sum(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_parallel_sum(rank,mpi,int_m4a,int_m4b)
      .test_parallel_sum(rank,mpi,real_m4a,real_m4b)
      .test_parallel_sum(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_parallel_sum(rank,mpi,real_m5a,real_m5b)
      .test_parallel_sum(rank,mpi,int_m5a,int_m5b)
      .test_parallel_sum(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   scansum_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_sum and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for scan_sum testing.
      call random_number(rand)
      str_a  = "blah"
      str_b  = "blahblah"
      int_a  = 4  
      int_b  = int_a + int_a 
      bin_a  = TRUE
      bin_b  = TRUE 
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cpx_a + rand*cpx_a
      real_a = 1.34
      real_b = real_a + rand*real_a
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = int_va + int_va
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = cpx_va + rand*cpx_va
      real_va = [1.34,34.5]
      real_vb = real_va + rand*real_va
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_mb = int_ma +     int_ma
      cpx_mb = cpx_ma +     rand*cpx_ma
      real_mb = real_ma +   rand*real_ma
      int_m3b = int_m3a +   int_m3a
      cpx_m3b = cpx_m3a +   rand*cpx_m3a
      real_m3b = real_m3a + rand*real_m3a
      int_m4b = int_m4a +   int_m4a
      cpx_m4b = cpx_m4a +   rand*cpx_m4a
      real_m4b = real_m4a + rand*real_m4a
      cpx_m5b = cpx_m5a +   rand*cpx_m5a
      real_m5b = real_m5a + rand*real_m5a
      int_m5b = int_m5a +   int_m5a

      
      if (rank == 1) then
         cpx_a   =    rand*cpx_a
         real_a  =    rand*real_a
         cpx_va   =    rand*cpx_va
         real_va  =    rand*real_va
         cpx_ma   =    rand*cpx_ma
         real_ma  =    rand*real_ma
         cpx_m3a  =    rand*cpx_m3a
         real_m3a =    rand*real_m3a
         cpx_m4a  =    rand*cpx_m4a
         real_m4a =    rand*real_m4a
         cpx_m5a  =    rand*cpx_m5a
         real_m5a =    rand*real_m5a
      end if

      ! Call the routines

      ! Single numbers
      .test_scan_sum(rank,mpi,int_a,int_b)
      .test_scan_sum(rank,mpi,real_a,real_b)
      .test_scan_sum(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_scan_sum(rank,mpi,int_va,int_vb)
      .test_scan_sum(rank,mpi,real_va,real_vb)
      .test_scan_sum(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_scan_sum(rank,mpi,int_ma,int_mb)
      .test_scan_sum(rank,mpi,real_ma,real_mb)
      .test_scan_sum(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_scan_sum(rank,mpi,int_m3a,int_m3b)
      .test_scan_sum(rank,mpi,real_m3a,real_m3b)
      .test_scan_sum(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_scan_sum(rank,mpi,int_m4a,int_m4b)
      .test_scan_sum(rank,mpi,real_m4a,real_m4b)
      .test_scan_sum(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_scan_sum(rank,mpi,real_m5a,real_m5b)
      .test_scan_sum(rank,mpi,cpx_m5a,cpx_m5b)
      .test_scan_sum(rank,mpi,int_m5a,int_m5b)
      
   
   end

   prod_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_prod and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_prod testing.
      call random_number(rand)
      str_a  = "blah"
      str_b  = "blahblah"
      int_a  = 4  
      int_b  = int_a * int_a 
      bin_a  = TRUE
      bin_b  = TRUE 
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cpx_a * rand*cpx_a
      real_a = 1.34
      real_b = real_a * rand*real_a
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = int_va * int_va
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = cpx_va * rand*cpx_va
      real_va = [1.34,34.5]
      real_vb = real_va * rand*real_va
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_mb = int_ma     *     int_ma
      cpx_mb = cpx_ma     *     rand*cpx_ma
      real_mb = real_ma   *   rand*real_ma
      int_m3b = int_m3a   *   int_m3a
      cpx_m3b = cpx_m3a   *   rand*cpx_m3a
      real_m3b = real_m3a * rand*real_m3a
      int_m4b = int_m4a   *   int_m4a
      cpx_m4b = cpx_m4a   *   rand*cpx_m4a
      real_m4b = real_m4a * rand*real_m4a
      cpx_m5b = cpx_m5a   *   rand*cpx_m5a
      int_m5b = int_m5a   *   int_m5a
      real_m5b = real_m5a * rand*real_m5a

      
      if (rank == 1) then
         cpx_a   =    rand*cpx_a
         real_a  =    rand*real_a
         cpx_va   =    rand*cpx_va
         real_va  =    rand*real_va
         cpx_ma   =    rand*cpx_ma
         real_ma  =    rand*real_ma
         cpx_m3a  =    rand*cpx_m3a
         real_m3a =    rand*real_m3a
         cpx_m4a  =    rand*cpx_m4a
         real_m4a =    rand*real_m4a
         cpx_m5a  =    rand*cpx_m5a
         real_m5a =    rand*real_m5a
      end if

      ! Call the routines

      ! Single numbers
      .test_reduce_prod(rank,mpi,int_a,int_b)
      .test_reduce_prod(rank,mpi,real_a,real_b)
      .test_reduce_prod(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_reduce_prod(rank,mpi,int_va,int_vb)
      .test_reduce_prod(rank,mpi,real_va,real_vb)
      .test_reduce_prod(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_reduce_prod(rank,mpi,int_ma,int_mb)
      .test_reduce_prod(rank,mpi,real_ma,real_mb)
      .test_reduce_prod(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_reduce_prod(rank,mpi,int_m3a,int_m3b)
      .test_reduce_prod(rank,mpi,real_m3a,real_m3b)
      .test_reduce_prod(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_reduce_prod(rank,mpi,int_m4a,int_m4b)
      .test_reduce_prod(rank,mpi,real_m4a,real_m4b)
      .test_reduce_prod(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_reduce_prod(rank,mpi,real_m5a,real_m5b)
      .test_reduce_prod(rank,mpi,int_m5a,int_m5b)
      .test_reduce_prod(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   allprod_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_prod and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_prod testing.
      int_a  = 4  
      int_b  = int_a * int_a 
      bin_a  = TRUE
      bin_b  = TRUE 
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cpx_a * cpx_a
      real_a = 1.34
      real_b = real_a * real_a
      int_va  = [4,2]
      int_vb  = int_va * int_va
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = cpx_va * cpx_va
      real_va = [1.34,34.5]
      real_vb = real_va * real_va
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_mb = int_ma *     int_ma
      cpx_mb = cpx_ma *     cpx_ma
      real_mb = real_ma *   real_ma
      int_m3b = int_m3a *   int_m3a
      cpx_m3b = cpx_m3a *   cpx_m3a
      real_m3b = real_m3a * real_m3a
      int_m4b = int_m4a *   int_m4a
      cpx_m4b = cpx_m4a *   cpx_m4a
      real_m4b = real_m4a * real_m4a
      int_m5b = int_m5a *   int_m5a
      cpx_m5b = cpx_m5a *   cpx_m5a
      real_m5b = real_m5a * real_m5a

      
      ! Call the routines

      ! Single numbers
      .test_parallel_prod(rank,mpi,int_a,int_b)
      .test_parallel_prod(rank,mpi,real_a,real_b)
      .test_parallel_prod(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_parallel_prod(rank,mpi,int_va,int_vb)
      .test_parallel_prod(rank,mpi,real_va,real_vb)
      .test_parallel_prod(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_parallel_prod(rank,mpi,int_ma,int_mb)
      .test_parallel_prod(rank,mpi,real_ma,real_mb)
      .test_parallel_prod(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_parallel_prod(rank,mpi,int_m3a,int_m3b)
      .test_parallel_prod(rank,mpi,real_m3a,real_m3b)
      .test_parallel_prod(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_parallel_prod(rank,mpi,int_m4a,int_m4b)
      .test_parallel_prod(rank,mpi,real_m4a,real_m4b)
      .test_parallel_prod(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_parallel_prod(rank,mpi,real_m5a,real_m5b)
      .test_parallel_prod(rank,mpi,int_m5a,int_m5b)
      .test_parallel_prod(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   scanprod_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_prod and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b :: INT
      str_a,str_b     :: STR
      bin_a,bin_b     :: BIN
      cpx_a,cpx_b     :: CPX
      real_a,real_b,rand   :: REAL
      int_va,int_vb   :: VEC{INT}@
      str_va,str_vb   :: VEC{STR}@
      bin_va,bin_vb   :: VEC{BIN}@
      cpx_va,cpx_vb   :: VEC{CPX}@
      real_va,real_vb :: VEC{REAL}@
      int_ma,int_mb   :: MAT{INT}(3,3)
      str_ma,str_mb   :: MAT{STR}(3,3)
      bin_ma,bin_mb   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb   :: MAT{CPX}(3,3)
      real_ma,real_mb :: MAT{REAL}(3,3)
      int_m3a,int_m3b   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b :: MAT4{REAL}(3,3,3,3)
      cpx_m5a,cpx_m5b   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b :: MAT5{REAL}(3,3,3,3,3)
      int_m5a,int_m5b :: MAT5{INT}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for scan_prod testing.
      call random_number(rand)
      str_a  = "blah"
      str_b  = "blahblah"
      int_a  = 4  
      int_b  = int_a * int_a 
      bin_a  = TRUE
      bin_b  = TRUE 
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cpx_a * rand*cpx_a
      real_a = 1.34
      real_b = real_a * rand*real_a
      str_va  = ["blah","dogg"]
      str_vb  = ["fa","dp"]
      int_va  = [4,2]
      int_vb  = int_va * int_va
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = cpx_va * rand*cpx_va
      real_va = [1.34,34.5]
      real_vb = real_va * rand*real_va
      str_ma(1,:) = ["a","b","c"] 
      str_ma(2,:) = ["d","e","f"] 
      str_ma(3,:) = ["g","h","i"] 
      do i = 1,3
         do j = 1,3
            str_mb(i,j) = "no"
            int_ma(i,j) = i*j
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                  end do
               end do
            end do
         end do
      end do
      int_mb = int_ma     *     int_ma
      cpx_mb = cpx_ma     *     rand*cpx_ma
      real_mb = real_ma   *   rand*real_ma
      int_m3b = int_m3a   *   int_m3a
      cpx_m3b = cpx_m3a   *   rand*cpx_m3a
      real_m3b = real_m3a * rand*real_m3a
      int_m4b = int_m4a   *   int_m4a
      cpx_m4b = cpx_m4a   *   rand*cpx_m4a
      real_m4b = real_m4a * rand*real_m4a
      cpx_m5b = cpx_m5a   *   rand*cpx_m5a
      int_m5b = int_m5a   *   int_m5a
      real_m5b = real_m5a * rand*real_m5a

      
      if (rank == 1) then
         cpx_a   =    rand*cpx_a
         real_a  =    rand*real_a
         cpx_va   =    rand*cpx_va
         real_va  =    rand*real_va
         cpx_ma   =    rand*cpx_ma
         real_ma  =    rand*real_ma
         cpx_m3a  =    rand*cpx_m3a
         real_m3a =    rand*real_m3a
         cpx_m4a  =    rand*cpx_m4a
         real_m4a =    rand*real_m4a
         cpx_m5a  =    rand*cpx_m5a
         real_m5a =    rand*real_m5a
      end if

      ! Call the routines

      ! Single numbers
      .test_scan_prod(rank,mpi,int_a,int_b)
      .test_scan_prod(rank,mpi,real_a,real_b)
      .test_scan_prod(rank,mpi,cpx_a,cpx_b)
   
      ! Vectors
      .test_scan_prod(rank,mpi,int_va,int_vb)
      .test_scan_prod(rank,mpi,real_va,real_vb)
      .test_scan_prod(rank,mpi,cpx_va,cpx_vb)
      
      ! Matrix
      .test_scan_prod(rank,mpi,int_ma,int_mb)
      .test_scan_prod(rank,mpi,real_ma,real_mb)
      .test_scan_prod(rank,mpi,cpx_ma,cpx_mb)
      
      ! Matrix 3s
      .test_scan_prod(rank,mpi,int_m3a,int_m3b)
      .test_scan_prod(rank,mpi,real_m3a,real_m3b)
      .test_scan_prod(rank,mpi,cpx_m3a,cpx_m3b)
      
      ! Matrix 4s
      .test_scan_prod(rank,mpi,int_m4a,int_m4b)
      .test_scan_prod(rank,mpi,real_m4a,real_m4b)
      .test_scan_prod(rank,mpi,cpx_m4a,cpx_m4b)
      
      ! Matrix 5s
      .test_scan_prod(rank,mpi,real_m5a,real_m5b)
      .test_scan_prod(rank,mpi,int_m5a,int_m5b)
      .test_scan_prod(rank,mpi,cpx_m5a,cpx_m5b)
      
   
   end

   max_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_max and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_max testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      int_va  = [4,2]
      int_vb  = [2,5]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      int_t=max(int_a,int_b)
      real_t=max(real_a,real_b)
      int_vt=max(int_va,int_vb)
      real_vt=max(real_va,real_vb)
      int_mt=max(int_ma,int_mb)
      real_mt=max(real_ma,real_mb)
      int_m3t=max(int_m3a,int_m3b)
      real_m3t=max(real_m3a,real_m3b)
      int_m4t=max(int_m4a,int_m4b)
      real_m4t=max(real_m4a,real_m4b)
      int_m5t=max(int_m5a,int_m5b)
      real_m5t=max(real_m5a,real_m5b)

      

      ! Call the routines

      ! Single numbers
      .test_reduce_max(rank,mpi,int_a,int_b,int_t)
      .test_reduce_max(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_reduce_max(rank,mpi,int_va,int_vb,int_vt)
      .test_reduce_max(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_reduce_max(rank,mpi,int_ma,int_mb,int_mt)
      .test_reduce_max(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_reduce_max(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_reduce_max(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_reduce_max(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_reduce_max(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_reduce_max(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_reduce_max(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   allmax_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_max and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_max testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      int_va  = [4,2]
      int_vb  = [2,5]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      int_t=max(int_a,int_b)
      real_t=max(real_a,real_b)
      int_vt=max(int_va,int_vb)
      real_vt=max(real_va,real_vb)
      int_mt=max(int_ma,int_mb)
      real_mt=max(real_ma,real_mb)
      int_m3t=max(int_m3a,int_m3b)
      real_m3t=max(real_m3a,real_m3b)
      int_m4t=max(int_m4a,int_m4b)
      real_m4t=max(real_m4a,real_m4b)
      real_m5t=max(real_m5a,real_m5b)
      int_m5t=max(int_m5a,int_m5b)

      

      ! Call the routines

      ! Single numbers
      .test_parallel_max(rank,mpi,int_a,int_b,int_t)
      .test_parallel_max(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_parallel_max(rank,mpi,int_va,int_vb,int_vt)
      .test_parallel_max(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_parallel_max(rank,mpi,int_ma,int_mb,int_mt)
      .test_parallel_max(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_parallel_max(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_parallel_max(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_parallel_max(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_parallel_max(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_parallel_max(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_parallel_max(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   scanmax_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_max and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for scan_max testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      int_va  = [4,2]
      int_vb  = [2,5]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      int_t=max(int_a,int_b)
      real_t=max(real_a,real_b)
      int_vt=max(int_va,int_vb)
      real_vt=max(real_va,real_vb)
      int_mt=max(int_ma,int_mb)
      real_mt=max(real_ma,real_mb)
      int_m3t=max(int_m3a,int_m3b)
      real_m3t=max(real_m3a,real_m3b)
      int_m4t=max(int_m4a,int_m4b)
      real_m4t=max(real_m4a,real_m4b)
      real_m5t=max(real_m5a,real_m5b)
      int_m5t=max(int_m5a,int_m5b)

      

      ! Call the routines

      ! Single numbers
      .test_scan_max(rank,mpi,int_a,int_b,int_t)
      .test_scan_max(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_scan_max(rank,mpi,int_va,int_vb,int_vt)
      .test_scan_max(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_scan_max(rank,mpi,int_ma,int_mb,int_mt)
      .test_scan_max(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_scan_max(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_scan_max(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_scan_max(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_scan_max(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_scan_max(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_scan_max(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   min_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_min and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_min testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      int_va  = [4,2]
      int_vb  = [2,5]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      int_t=min(int_a,int_b)
      real_t=min(real_a,real_b)
      int_vt=min(int_va,int_vb)
      real_vt=min(real_va,real_vb)
      int_mt=min(int_ma,int_mb)
      real_mt=min(real_ma,real_mb)
      int_m3t=min(int_m3a,int_m3b)
      real_m3t=min(real_m3a,real_m3b)
      int_m4t=min(int_m4a,int_m4b)
      real_m4t=min(real_m4a,real_m4b)
      int_m5t=min(int_m5a,int_m5b)
      real_m5t=min(real_m5a,real_m5b)

      

      ! Call the routines

      ! Single numbers
      .test_reduce_min(rank,mpi,int_a,int_b,int_t)
      .test_reduce_min(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_reduce_min(rank,mpi,int_va,int_vb,int_vt)
      .test_reduce_min(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_reduce_min(rank,mpi,int_ma,int_mb,int_mt)
      .test_reduce_min(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_reduce_min(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_reduce_min(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_reduce_min(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_reduce_min(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_reduce_min(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_reduce_min(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   allmin_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_min and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_min testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      int_va  = [4,2]
      int_vb  = [2,5]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      int_t=min(int_a,int_b)
      real_t=min(real_a,real_b)
      int_vt=min(int_va,int_vb)
      real_vt=min(real_va,real_vb)
      int_mt=min(int_ma,int_mb)
      real_mt=min(real_ma,real_mb)
      int_m3t=min(int_m3a,int_m3b)
      real_m3t=min(real_m3a,real_m3b)
      int_m4t=min(int_m4a,int_m4b)
      real_m4t=min(real_m4a,real_m4b)
      real_m5t=min(real_m5a,real_m5b)
      int_m5t=min(int_m5a,int_m5b)

      

      ! Call the routines

      ! Single numbers
      .test_parallel_min(rank,mpi,int_a,int_b,int_t)
      .test_parallel_min(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_parallel_min(rank,mpi,int_va,int_vb,int_vt)
      .test_parallel_min(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_parallel_min(rank,mpi,int_ma,int_mb,int_mt)
      .test_parallel_min(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_parallel_min(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_parallel_min(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_parallel_min(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_parallel_min(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_parallel_min(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_parallel_min(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   scanmin_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_min and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank,int_a,int_b,int_t :: INT
      str_a,str_b,str_t     :: STR
      bin_a,bin_b,bin_t     :: BIN
      cpx_a,cpx_b,cpx_t     :: CPX
      real_a,real_b,real_t  :: REAL
      int_va,int_vb,int_vt   :: VEC{INT}@
      str_va,str_vb,str_vt   :: VEC{STR}@
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      cpx_va,cpx_vb,cpx_vt   :: VEC{CPX}@
      real_va,real_vb,real_vt :: VEC{REAL}@
      int_ma,int_mb,int_mt   :: MAT{INT}(3,3)
      str_ma,str_mb,str_mt   :: MAT{STR}(3,3)
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      cpx_ma,cpx_mb,cpx_mt   :: MAT{CPX}(3,3)
      real_ma,real_mb,real_mt :: MAT{REAL}(3,3)
      int_m3a,int_m3b,int_m3t   :: MAT3{INT}(3,3,3)
      bin_m3a,bin_m3b   :: MAT3{BIN}(3,3,3)
      cpx_m3a,cpx_m3b,cpx_m3t   :: MAT3{CPX}(3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT3{REAL}(3,3,3)
      int_m4a,int_m4b,int_m4t   :: MAT4{INT}(3,3,3,3)
      cpx_m4a,cpx_m4b,cpx_m4t   :: MAT4{CPX}(3,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT4{REAL}(3,3,3,3)
      int_m5a,int_m5b,int_m5t   :: MAT5{INT}(3,3,3,3,3)
      cpx_m5a,cpx_m5b,cpx_m5t   :: MAT5{CPX}(3,3,3,3,3)
      real_m5a,real_m5b,real_m5t :: MAT5{REAL}(3,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for scan_min testing.
      str_a  = "blah"
      str_b  = "fs"
      int_a  = 4
      int_b  = 2
      cpx_a  = cmplx(4.3,123.2)
      cpx_b  = cmplx(1.04,5.3)
      real_a = 1.34
      real_b = 22.3
      int_va  = [4,2]
      int_vb  = [2,5]
      cpx_va  = [cmplx(4.3,123.2),cmplx(6.7,5.7)]
      cpx_vb  = [cmplx(1.04,5.3),cmplx(12.3,1243.3)]
      real_va = [1.34,34.5]
      real_vb = [12.0,22.3]
      do i = 1,3
         do j = 1,3
            int_ma(i,j) = i*j
            int_mb(i,j) = 0
            cpx_ma(i,j) = cmplx(real(i**3)/54,real(j**(1/2))*65)
            cpx_mb(i,j) = cmplx(0.0,0.0)
            real_ma(i,j) = real(i**4)+real(j**(1/2))
            real_mb(i,j) = 0.0
            do k = 1,3
               int_m3a(i,j,k) = i*j*k
               int_m3b(i,j,k) = 0
               cpx_m3a(i,j,k) = cmplx(real(i**3)/54 + real(k)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
               cpx_m3b(i,j,k) = cmplx(0.0,0.0)
               real_m3a(i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(i,j,k) = 0.0
               do l = 1,3
                  int_m4a(i,j,k,l) = i*j*k*l
                  int_m4b(i,j,k,l) = 0
                  cpx_m4a(i,j,k,l) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*5433.43 +  real(j**(1/2))*65)
                  cpx_m4b(i,j,k,l) = cmplx(0.0,0.0)
                  real_m4a(i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(i,j,k,l) = 0.0
                  do m = 1,3
                     int_m5a(i,j,k,l,m) = i*j*k*l-m
                     int_m5b(i,j,k,l,m) = 0
                     cpx_m5a(i,j,k,l,m) = cmplx(real(i**3)/54 + real(l)*0.05432,real(k)*real(m*433.43) +  real(j**(1/2))*65)
                     cpx_m5b(i,j,k,l,m) = cmplx(0.0,0.0)
                     real_m5a(i,j,k,l,m) = real(i**l)+real(j**(real(1/m))) +0.0543*real(k)
                     real_m5b(i,j,k,l,m) = 0.0
                  end do
               end do
            end do
         end do
      end do
      
      int_t=min(int_a,int_b)
      real_t=min(real_a,real_b)
      int_vt=min(int_va,int_vb)
      real_vt=min(real_va,real_vb)
      int_mt=min(int_ma,int_mb)
      real_mt=min(real_ma,real_mb)
      int_m3t=min(int_m3a,int_m3b)
      real_m3t=min(real_m3a,real_m3b)
      int_m4t=min(int_m4a,int_m4b)
      real_m4t=min(real_m4a,real_m4b)
      real_m5t=min(real_m5a,real_m5b)
      int_m5t=min(int_m5a,int_m5b)

      

      ! Call the routines

      ! Single numbers
      .test_scan_min(rank,mpi,int_a,int_b,int_t)
      .test_scan_min(rank,mpi,real_a,real_b,real_t)
   
      ! Vectors
      .test_scan_min(rank,mpi,int_va,int_vb,int_vt)
      .test_scan_min(rank,mpi,real_va,real_vb,real_vt)
      
      ! Matrix
      .test_scan_min(rank,mpi,int_ma,int_mb,int_mt)
      .test_scan_min(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_scan_min(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_scan_min(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      .test_scan_min(rank,mpi,int_m4a,int_m4b,int_m4t)
      .test_scan_min(rank,mpi,real_m4a,real_m4b,real_m4t)
      
      ! Matrix 5s
      .test_scan_min(rank,mpi,int_m5a,int_m5b,int_m5t)
      .test_scan_min(rank,mpi,real_m5a,real_m5b,real_m5t)
      
   
   end

   maxloc_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_maxloc and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank :: INT
      int_a,int_b,int_t :: VEC{INT}(2)
      real_a,real_b,real_t  :: VEC{REAL}(2)
      int_va,int_vb,int_vt   :: MAT{INT}(2,2)
      real_va,real_vb,real_vt :: MAT{REAL}(2,2)
      int_ma,int_mb,int_mt   :: MAT3{INT}(2,3,3)
      real_ma,real_mb,real_mt :: MAT3{REAL}(2,3,3)
      int_m3a,int_m3b,int_m3t   :: MAT4{INT}(2,3,3,3)
      real_m3a,real_m3b,real_m3t :: MAT4{REAL}(2,3,3,3)
      real_m4a,real_m4b,real_m4t :: MAT5{REAL}(2,3,3,3,3)
      int_m4a,int_m4b,int_m4t :: MAT5{INT}(2,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_maxloc testing.
      int_a(1)  = 4
      int_b(1)  = 2
      real_a(1) = 1.34
      real_b(1) = 22.3
      int_va(1,:)  = [4,2]
      int_vb(1,:)  = [2,5]
      real_va(1,:) = [1.34,34.5]
      real_vb(1,:) = [12.0,22.3]
      int_a(2)  = rank
      int_b(2)  = rank
      real_a(2) = rank
      real_b(2) = rank
      int_va(2,:)  = rank
      int_vb(2,:)  = rank
      real_va(2,:) = rank
      real_vb(2,:) = rank
      do i = 1,3
         do j = 1,3
            int_ma(1,i,j) = i*j
            int_mb(1,i,j) = 0
            real_ma(1,i,j) = real(i**4)+real(j**(1/2))
            real_mb(1,i,j) = 0.0
            int_ma(2,i,j)  = rank 
            int_mb(2,i,j)  = rank 
            real_ma(2,i,j) = rank 
            real_mb(2,i,j) = rank 
            do k = 1,3
                int_m3a(1,i,j,k) = i*j*k
                int_m3b(1,i,j,k) = 0
               real_m3a(1,i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_m3b(1,i,j,k) = 0.0
                int_m3a(2,i,j,k)  = rank  
                int_m3b(2,i,j,k)  = rank 
               real_m3a(2,i,j,k) = rank 
               real_m3b(2,i,j,k) = rank 
               do l = 1,3
                   int_m4a(1,i,j,k,l) = i*j*k*l
                   int_m4b(1,i,j,k,l) = 0
                  real_m4a(1,i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_m4b(1,i,j,k,l) = 0.0
                  int_m4a(2,i,j,k,l)  = rank  
                  int_m4b(2,i,j,k,l)  = rank 
                  real_m4a(2,i,j,k,l) = rank 
                  real_m4b(2,i,j,k,l) = rank
               end do
            end do
         end do
      end do
      int_t(1)=max(int_a(1),int_b(1))
      if(int_a(1)>int_b(1)) then
         int_t(2)=0
      else
         int_t(2)=1
      end if
      real_t(1)=max(real_a(1),real_b(1))
      if(real_a(1)>real_b(1)) then
         real_t(2)=0
      else
         real_t(2)=1
      end
      do i=1,2
         int_vt(1,i)=max(int_va(1,i),int_vb(1,i))
         if(int_va(1,i) > int_vb(1,i)) then
            int_vt(2,i)=0
         else
            int_vt(2,i)=1
         end if
         real_vt(1,i)=max(real_va(1,i),real_vb(1,i))
         if(real_va(1,i) > real_vb(1,i)) then
            real_vt(2,i)=0
         else
            real_vt(2,i)=1
         end if
      end do
      do i=1,3
         do j=1,3
            int_mt(1,i,j)=max(int_ma(1,i,j),int_mb(1,i,j))
            if(int_ma(1,i,j) > int_mb(1,i,j)) then
               int_mt(2,i,j)=0
            else
               int_mt(2,i,j)=1
            end if
            real_mt(1,i,j)=max(real_ma(1,i,j),real_mb(1,i,j))
            if(real_ma(1,i,j) > real_mb(1,i,j)) then
               real_mt(2,i,j)=0
            else
               real_mt(2,i,j)=1
            end if
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               int_m3t(1,i,j,k)=max(int_m3a(1,i,j,k),int_m3b(1,i,j,k))
               if(int_m3a(1,i,j,k) > int_m3b(1,i,j,k)) then
                  int_m3t(2,i,j,k)=0
               else
                  int_m3t(2,i,j,k)=1
               end if
               real_m3t(1,i,j,k)=max(real_m3a(1,i,j,k),real_m3b(1,i,j,k))
               if(real_m3a(1,i,j,k) > real_m3b(1,i,j,k)) then
                  real_m3t(2,i,j,k)=0
               else
                  real_m3t(2,i,j,k)=1
               end if
            end do
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               do l=1,3
                  int_m4t(1,i,j,k,l)=max(int_m4a(1,i,j,k,l),int_m4b(1,i,j,k,l))
                  if(int_m4a(1,i,j,k,l) > int_m4b(1,i,j,k,l)) then
                     int_m4t(2,i,j,k,l)=0
                  else
                     int_m4t(2,i,j,k,l)=1
                  end if
                  real_m4t(1,i,j,k,l)=max(real_m4a(1,i,j,k,l),real_m4b(1,i,j,k,l))
                  if(real_m4a(1,i,j,k,l) > real_m4b(1,i,j,k,l)) then
                     real_m4t(2,i,j,k,l)=0
                  else
                     real_m4t(2,i,j,k,l)=1
                  end if
               end do
            end do
         end do
      end do

      

      ! Call the routines
      ! Single numbers
      .test_reduce_maxloc(rank,mpi,int_a,int_b,int_t)
      .test_reduce_maxloc(rank,mpi,real_a,real_b,real_t)

      ! Vectors
      .test_reduce_maxloc(rank,mpi,int_va,int_vb,int_vt)
      .test_reduce_maxloc(rank,mpi,real_va,real_vb,real_vt)
   
      ! Matrix
      .test_reduce_maxloc(rank,mpi,int_ma,int_mb,int_mt)
      .test_reduce_maxloc(rank,mpi,real_ma,real_mb,real_mt)
      
      ! Matrix 3s
      .test_reduce_maxloc(rank,mpi,int_m3a,int_m3b,int_m3t)
      .test_reduce_maxloc(rank,mpi,real_m3a,real_m3b,real_m3t)
      
      ! Matrix 4s
      !.test_reduce_maxloc(rank,mpi,int_m4a,int_m4b,int_m4t)
      !.test_reduce_maxloc(rank,mpi,real_m4a,real_m4b,real_m4t)
      
   
   end

   minloc_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_minloc and receive functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      i,j,k,l,m,rank :: INT
      int_mina,int_minb,int_mint :: VEC{INT}(2)
      real_mina,real_minb,real_mint  :: VEC{REAL}(2)
      int_minva,int_minvb,int_minvt   :: MAT{INT}(2,2)
      real_minva,real_minvb,real_minvt :: MAT{REAL}(2,2)
      int_minma,int_minmb,int_minmt   :: MAT3{INT}(2,3,3)
      real_minma,real_minmb,real_minmt :: MAT3{REAL}(2,3,3)
      int_minm3a,int_minm3b,int_minm3t   :: MAT4{INT}(2,3,3,3)
      real_minm3a,real_minm3b,real_minm3t :: MAT4{REAL}(2,3,3,3)
      real_minm4a,real_minm4b,real_minm4t :: MAT5{REAL}(2,3,3,3,3)
      int_minm4a,int_minm4b,int_minm4t :: MAT5{INT}(2,3,3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for reduce_minloc testing.
      int_mina(1)  = 4
      int_minb(1)  = 2
      real_mina(1) = 1.34
      real_minb(1) = 22.3
      int_minva(1,:)  = [4,2]
      int_minvb(1,:)  = [2,5]
      real_minva(1,:) = [1.34,34.5]
      real_minvb(1,:) = [12.0,22.3]
      int_mina(2)  = rank
      int_minb(2)  = rank
      real_mina(2) = rank
      real_minb(2) = rank
      int_minva(2,:)  = rank
      int_minvb(2,:)  = rank
      real_minva(2,:) = rank
      real_minvb(2,:) = rank
      do i = 1,3
         do j = 1,3
            int_minma(1,i,j) = i*j
            int_minmb(1,i,j) = 0
            real_minma(1,i,j) = real(i**4)+real(j**(1/2))
            real_minmb(1,i,j) = 0.0
            int_minma(2,i,j)  = rank 
            int_minmb(2,i,j)  = rank 
            real_minma(2,i,j) = rank 
            real_minmb(2,i,j) = rank 
            do k = 1,3
                int_minm3a(1,i,j,k) = i*j*k
                int_minm3b(1,i,j,k) = 0
               real_minm3a(1,i,j,k) = real(i**4)+real(j**(1/2)) +0.0543*real(k)
               real_minm3b(1,i,j,k) = 0.0
                int_minm3a(2,i,j,k)  = rank  
                int_minm3b(2,i,j,k)  = rank 
               real_minm3a(2,i,j,k) = rank 
               real_minm3b(2,i,j,k) = rank 
               do l = 1,3
                   int_minm4a(1,i,j,k,l) = i*j*k*l
                   int_minm4b(1,i,j,k,l) = 0
                  real_minm4a(1,i,j,k,l) = real(i**l)+real(j**(1/2)) +0.0543*real(k)
                  real_minm4b(1,i,j,k,l) = 0.0
                  int_minm4a(2,i,j,k,l)  = rank  
                  int_minm4b(2,i,j,k,l)  = rank 
                  real_minm4a(2,i,j,k,l) = rank 
                  real_minm4b(2,i,j,k,l) = rank
               end do
            end do
         end do
      end do
      int_mint(1)=min(int_mina(1),int_minb(1))
      if(int_mina(1)<int_minb(1)) then
         int_mint(2)=0
      else
         int_mint(2)=1
      end if
      real_mint(1)=min(real_mina(1),real_minb(1))
      if(real_mina(1)<real_minb(1)) then
         real_mint(2)=0
      else
         real_mint(2)=1
      end
      do i=1,2
         int_minvt(1,i)=min(int_minva(1,i),int_minvb(1,i))
         if(int_minva(1,i) < int_minvb(1,i)) then
            int_minvt(2,i)=0
         else
            int_minvt(2,i)=1
         end if
         real_minvt(1,i)=min(real_minva(1,i),real_minvb(1,i))
         if(real_minva(1,i) < real_minvb(1,i)) then
            real_minvt(2,i)=0
         else
            real_minvt(2,i)=1
         end if
      end do
      do i=1,3
         do j=1,3
            int_minmt(1,i,j)=min(int_minma(1,i,j),int_minmb(1,i,j))
            if(int_minma(1,i,j) < int_minmb(1,i,j)) then
               int_minmt(2,i,j)=0
            else
               int_minmt(2,i,j)=1
            end if
            real_minmt(1,i,j)=min(real_minma(1,i,j),real_minmb(1,i,j))
            if(real_minma(1,i,j) < real_minmb(1,i,j)) then
               real_minmt(2,i,j)=0
            else
               real_minmt(2,i,j)=1
            end if
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               int_minm3t(1,i,j,k)=min(int_minm3a(1,i,j,k),int_minm3b(1,i,j,k))
               if(int_minm3a(1,i,j,k) < int_minm3b(1,i,j,k)) then
                  int_minm3t(2,i,j,k)=0
               else
                  int_minm3t(2,i,j,k)=1
               end if
               real_minm3t(1,i,j,k)=min(real_minm3a(1,i,j,k),real_minm3b(1,i,j,k))
               if(real_minm3a(1,i,j,k) < real_minm3b(1,i,j,k)) then
                  real_minm3t(2,i,j,k)=0
               else
                  real_minm3t(2,i,j,k)=1
               end if
            end do
         end do
      end do
      do i=1,3
         do j=1,3
            do k = 1,3
               do l=1,3
                  int_minm4t(1,i,j,k,l)=min(int_minm4a(1,i,j,k,l),int_minm4b(1,i,j,k,l))
                  if(int_minm4a(1,i,j,k,l) < int_minm4b(1,i,j,k,l)) then
                     int_minm4t(2,i,j,k,l)=0
                  else
                     int_minm4t(2,i,j,k,l)=1
                  end if
                  real_minm4t(1,i,j,k,l)=min(real_minm4a(1,i,j,k,l),real_minm4b(1,i,j,k,l))
                  if(real_minm4a(1,i,j,k,l) < real_minm4b(1,i,j,k,l)) then
                     real_minm4t(2,i,j,k,l)=0
                  else
                     real_minm4t(2,i,j,k,l)=1
                  end if
               end do
            end do
         end do
      end do

      

      ! Call the routines
      ! Single numbers
      .test_reduce_minloc(rank,mpi,int_mina,int_minb,int_mint)
      .test_reduce_minloc(rank,mpi,real_mina,real_minb,real_mint)
      
      ! Vectors
      .test_reduce_minloc(rank,mpi,int_minva,int_minvb,int_minvt)
      .test_reduce_minloc(rank,mpi,real_minva,real_minvb,real_minvt)
   
      ! Matrix
      .test_reduce_minloc(rank,mpi,int_minma,int_minmb,int_minmt)
      .test_reduce_minloc(rank,mpi,real_minma,real_minmb,real_minmt)
      
      ! Matrix 3s
      .test_reduce_minloc(rank,mpi,int_minm3a,int_minm3b,int_minm3t)
      .test_reduce_minloc(rank,mpi,real_minm3a,real_minm3b,real_minm3t)
      
      ! Matrix 4s
      !.test_reduce_minloc(rank,mpi,int_minm4a,int_minm4b,int_minm4t)
      !.test_reduce_minloc(rank,mpi,real_minm4a,real_minm4b,real_minm4t)
      
   
   end

   lor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = bin_a OR bin_b
      bin_vt = bin_va OR bin_vb
      bin_mt = bin_ma OR bin_mb
      bin_m3t = bin_m3a OR bin_m3b
   
      ! Call the routines
      ! Single numbers
      .test_reduce_lor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_reduce_lor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_reduce_lor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_reduce_lor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   alllor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = bin_a OR bin_b
      bin_vt = bin_va OR bin_vb
      bin_mt = bin_ma OR bin_mb
      bin_m3t = bin_m3a OR bin_m3b
   
      ! Call the routines
      ! Single numbers
      .test_parallel_or(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_parallel_or(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_parallel_or(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_parallel_or(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   scanlor_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_lor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = bin_a OR bin_b
      bin_vt = bin_va OR bin_vb
      bin_mt = bin_ma OR bin_mb
      bin_m3t = bin_m3a OR bin_m3b
   
      ! Call the routines
      ! Single numbers
      .test_scan_lor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_scan_lor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_scan_lor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_scan_lor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   land_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_land functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = bin_a AND bin_b
      bin_vt = bin_va AND bin_vb
      bin_mt = bin_ma AND bin_mb
      bin_m3t = bin_m3a AND bin_m3b
   
      ! Call the routines
      ! Single numbers
      .test_reduce_land(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_reduce_land(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_reduce_land(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_reduce_land(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   allland_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_land functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = bin_a AND bin_b
      bin_vt = bin_va AND bin_vb
      bin_mt = bin_ma AND bin_mb
      bin_m3t = bin_m3a AND bin_m3b
   
      ! Call the routines
      ! Single numbers
      .test_parallel_and(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_parallel_and(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_parallel_and(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_parallel_and(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   scanland_mpi_test(mpi) :::  public
   ! This routine calls and tests all scan_land functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables for send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = bin_a AND bin_b
      bin_vt = bin_va AND bin_vb
      bin_mt = bin_ma AND bin_mb
      bin_m3t = bin_m3a AND bin_m3b
   
      ! Call the routines
      ! Single numbers
      .test_scan_land(rank,mpi,bin_a,bin_b,bin_t)

      !Vectors
      .test_scan_land(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_scan_land(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_scan_land(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   lxor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lxor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables fxor send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = NOT(bin_a EQV bin_b)
      bin_vt = NOT(bin_va EQV bin_vb)
      bin_mt = NOT(bin_ma EQV bin_mb)
      bin_m3t = NOT(bin_m3a EQV bin_m3b)
   
      ! Call the routines
      ! Single numbers
      .test_reduce_lxor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectxors
      .test_reduce_lxor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_reduce_lxor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_reduce_lxor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   alllxor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lxor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables fxor send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = NOT(bin_a EQV  bin_b)
      bin_vt = NOT(bin_va EQV bin_vb)
      bin_mt = NOT(bin_ma EQV bin_mb)
      bin_m3t = NOT(bin_m3a EQV bin_m3b)
   
      ! Call the routines
      ! Single numbers
      .test_parallel_xor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectxors
      .test_parallel_xor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_parallel_xor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_parallel_xor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   scanlxor_mpi_test(mpi) :::  public
   ! This routine calls and tests all reduce_lxor functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank,i,j,k :: INT
      bin_a,bin_b,bin_t     :: BIN
      bin_va,bin_vb,bin_vt   :: VEC{BIN}@
      bin_ma,bin_mb,bin_mt   :: MAT{BIN}(3,3)
      bin_m3a,bin_m3b,bin_m3t   :: MAT3{BIN}(3,3,3)
      
      mpi.comm_rank(rank)
      
      ! Initialise all the variables fxor send testing.
      bin_a  = TRUE
      bin_b  = FALSE
      bin_va  = [TRUE,FALSE]
      bin_vb  = [FALSE,FALSE]
      do i = 1,3
         do j = 1,3
            if (MOD(i*j,2) == 0) then
               bin_ma(i,j) = TRUE
            else
               bin_ma(i,j) = FALSE
            end if
            bin_mb(i,j) = FALSE
            do k = 1,3
               if (MOD(i*j*k,2) == 0) then
                  bin_m3a(i,j,k) = TRUE
               else
                  bin_m3a(i,j,k) = FALSE
               end if
               bin_m3b(i,j,k) = FALSE
            end do
         end do
      end do

      bin_t = NOT(bin_a EQV  bin_b)
      bin_vt = NOT(bin_va EQV bin_vb)
      bin_mt = NOT(bin_ma EQV bin_mb)
      bin_m3t = NOT(bin_m3a EQV bin_m3b)
   
      ! Call the routines
      ! Single numbers
      .test_scan_lxor(rank,mpi,bin_a,bin_b,bin_t)

      !Vectxors
      .test_scan_lxor(rank,mpi,bin_va,bin_vb,bin_vt)

      !Matrices
      .test_scan_lxor(rank,mpi,bin_ma,bin_mb,bin_mt)

      !Matrix 3s
      .test_scan_lxor(rank,mpi,bin_m3a,bin_m3b,bin_m3t)

   end

   barrier_mpi_test(mpi) :::  public
   ! This routine calls and tests all barrier functions.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT
      
      mpi.comm_rank(rank)
      
      ! Test barrier
      .test_barrier(rank,mpi)
      
   
   end


!=====
! Send
!=====

   test_send(rank,mpi,send,recv) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      
      if(rank == 0) then
         a = send
         mpi.send(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.recv(b,0)
         a = send
         recv = b
         if (a EQ b) then
            print*, "MPI can succesfully send the type VAR_TYPE"
         else
            print*, "MPI failed to send the type VAR_TYPE"
         end if
      end if

   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,mpi,send,recv) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = send
         mpi.send(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.recv(b,0)
         recv = b
         if (all(a EQ b)) then
            print*, "MPI can succesfully send the type VAR_TYPE"
         else
            print*, "MPI failed to send the type VAR_TYPE"
         end if
      end if

   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_send(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

!======
! SSend
!======

   test_ssend(rank,mpi,send,recv) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      
      if(rank == 0) then
         a = send
         mpi.ssend(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.recv(b,0)
         a = send
         recv = b
         if (a EQ b) then
            print*, "MPI can succesfully synchronised send the type VAR_TYPE"
         else
            print*, "MPI failed to synchronised send the type VAR_TYPE"
         end if
      end if

   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,mpi,send,recv) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = send
         mpi.ssend(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.recv(b,0)
         recv = b
         if (all(a EQ b)) then
            print*, "MPI can succesfully synchronised send the type VAR_TYPE"
         else
            print*, "MPI failed to synchronised send the type VAR_TYPE"
         end if
      end if

   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_ssend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

!======
! Isend
!======

   test_isend(rank,mpi,send,recv) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      request :: INT
      a,b  :: VAR_TYPE@
      
      if(rank == 0) then
         a = send
         mpi.isend(a,1)
         !mpi.barrier
      else if (rank == 1) then
         a = send
         b = recv
         mpi.irecv(b,0,request=request)
         mpi.parallel_wait(request)
         a = send
         recv = b
         if (a EQ b) then
            print*, "MPI can succesfully non-blocking send the type VAR_TYPE"
         else
            print*, "MPI failed to non-blocking send the type VAR_TYPE"
            print*,a
            print*,b
         end if
      end if

   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,mpi,send,recv) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      request :: INT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = send
         mpi.isend(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.irecv(b,0,request=request)
         mpi.parallel_wait(request)
         recv = b
         if (all(send EQ recv)) then
            print*, "MPI can succesfully non-blocking send the type VAR_TYPE"
         else
            print*, "MPI failed to non-blocking send the type VAR_TYPE"
            print*,send
            print*,recv
         end if
      end if

   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_isend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Issend
!=======

   test_issend(rank,mpi,send,recv) ::: template
   ! Test the send routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      request :: INT
      a,b  :: VAR_TYPE@
      
      if(rank == 0) then
         a = send
         mpi.issend(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.irecv(b,0,request=request)
         mpi.parallel_wait(request)
         a = send
         recv = b
         if (a EQ b) then
            print*, "MPI can succesfully non-blocking synchronised send the type VAR_TYPE"
         else
            print*, "MPI failed to non-blocking synchronised send the type VAR_TYPE"
            print*,a
            print*,b
         end if
      end if

   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the send routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,mpi,send,recv) ::: template
   ! Test the send array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      request :: INT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = send
         mpi.issend(a,1)
      else if (rank == 1) then
         a = send
         b = recv
         mpi.irecv(b,0,request=request)
         mpi.parallel_wait(request)
         recv = b
         if (all(send EQ recv)) then
            print*, "MPI can succesfully non-blocking synchronised send the type VAR_TYPE"
         else
            print*, "MPI failed to non-blocking synchronised send the type VAR_TYPE"
            print*,send
            print*,recv
         end if
      end if

   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end


   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

   test_issend(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the send array routines and print to the terminal the results of
   ! the test.
   end

!=========
! Sendrecv
!=========

   test_sendrecv(rank,mpi,send,recv) ::: template
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = send
         mpi.sendrecv(a,b,1)
         if (recv EQ b) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE on master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE on master"
         end if
      else if (rank == 1) then
         b = recv
         mpi.sendrecv(b,a,0)
         if (a EQ send) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE non-master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE non-master"
         end if
      end if

   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the sendrecv routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: template
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = send
         b = send
         mpi.sendrecv(a,b,1)
         if (all(recv EQ b)) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE on master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE on master"
         end if
      else if (rank == 1) then
         b = recv
         a = recv
         mpi.sendrecv(b,a,0)
         if (all(a EQ send)) then
            print*, "MPI can succesfully sendrecv the type VAR_TYPE non-master"
         else
            print*, "MPI failed to sendrecv the type VAR_TYPE non-master"
         end if
      end if

   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end


   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

   test_sendrecv(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the sendrecv array routines and print to the terminal the results of
   ! the test.
   end

!======
! Bcast
!======

   test_bcast(rank,mpi,send,recv) ::: template
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         mpi.broadcast(send,0)
      else if (rank == 1) then
         mpi.broadcast(recv,0)
         if (recv EQ send) then
            print*, "MPI can succesfully bcast the type VAR_TYPE non-master"
         else
            print*, "MPI failed to bcast the type VAR_TYPE non-master"
         end if
      end if

   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the bcast routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: template
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      
      if(rank == 0) then
         mpi.broadcast(send,0)
      else if (rank == 1) then
         mpi.broadcast(recv,0)
         if (all(recv EQ send)) then
            print*, "MPI can succesfully bcast the type VAR_TYPE non-master"
         else
            print*, "MPI failed to bcast the type VAR_TYPE non-master"
         end if
      end if

   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end


   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

   test_bcast(rank,mpi,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the bcast array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Gather
!=======

   test_gather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the gather routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VEC{VAR_TYPE}, INOUT
      a  :: VAR_TYPE
      b :: VEC{VAR_TYPE}@
      
      
      if(rank == 0) then
         a = send
         mpi.gather(a,recv,1)
      else if (rank == 1) then
         a = send
         mpi.gather(a,recv,1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully gather the type VAR_TYPE"
         else
            print*, "MPI failed to gather the type VAR_TYPE"
            print*,"Receiving", recv
            print*,"It should be:", test
         end if
      end if

   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      i,j :: INT
      
      if(rank == 0) then
         mpi.gather(send,root=1)
      else if (rank == 1) then
         mpi.gather(send,recv,1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully gather the type VAR_TYPE"
         else
            print*, "MPI failed to gather the type VAR_TYPE"
         end if
      end if

   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_gather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

!========
! Igather
!========

   test_igather(commsize,rank,mpi,send,recv,request) ::: template
   ! Test the gather routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VEC{VAR_TYPE}, INOUT
      request :: INT, OUT
      a  :: VAR_TYPE
      b :: VEC{VAR_TYPE}@
      
      
      if(rank == 0) then
         a = send
         mpi.igather(a,recv,1,request)
      else if (rank == 1) then
         a = send
         mpi.igather(a,recv,1,request)
      end if

   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the gather routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: template
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      request :: INT, OUT
      a,b  :: VAR_TYPE@
      
      if(rank == 0) then
         a = send
         mpi.igather(a,recv,1,request=request)
      else if (rank == 1) then
         a = send
         mpi.igather(a,recv,1,request=request)
      end if

   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end


   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

   test_igather(commsize,rank,mpi,send,recv,request) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the gather array routines and print to the terminal the results of
   ! the test.
   end

!==========
! Allgather
!==========

   test_allgather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VEC{VAR_TYPE}, INOUT
      a  :: VAR_TYPE
      b :: VEC{VAR_TYPE}@
      
      
      a = send
      mpi.allgather(a,recv)
      if (all(recv EQ test)) then
         if(rank == 0) then
            print*, "MPI can succesfully allgather the type VAR_TYPE on master"
         else
            print*, "MPI can succesfully allgather the type VAR_TYPE on non-master"
         end if
      else
         if(rank == 0) then
            print*, "MPI failed to allgather the type VAR_TYPE on master"
         else
            print*, "MPI failed to allgather the type VAR_TYPE on non-master"
         end if
      end if

   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the allgather routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      i,j :: INT
      
      mpi.allgather(send,recv)
      if (all(recv EQ test)) then
         if(rank == 0) then
            print*, "MPI can succesfully allgather the type VAR_TYPE on master"
         else
            print*, "MPI can succesfully allgather the type VAR_TYPE on non-master"
         end if
      else
         if(rank == 0) then
            print*, "MPI failed to allgather the type VAR_TYPE on master"
         else
            print*, "MPI failed to allgather the type VAR_TYPE on non-master"
         end if
      end if

   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end


   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

   test_allgather(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the allgather array routines and print to the terminal the results of
   ! the test.
   end

!========
! Scatter
!========

   test_scatter(commsize,rank,mpi,send,test,recv) ::: template
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VEC{VAR_TYPE}, INOUT
      test,recv :: VAR_TYPE, INOUT
      a  :: VEC{VAR_TYPE}@
      
      
      if(rank == 0) then
         a = send
         mpi.scatter(a,recv,1)
      else if (rank == 1) then
         a = send
         mpi.scatter(a,recv,1)
         if (recv EQ test) then
            print*, "MPI can succesfully scatter the type VAR_TYPE"
         else
            print*, "MPI failed to scatter the type VAR_TYPE"
            print*,"Receiving", recv
            print*,"It should be:", test
         end if
      end if

   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>STR, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>BIN, EQ=>EQV)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scatter routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: template
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      i,j :: INT
      
      if(rank == 0) then
         a = send
         mpi.scatter(a,recv,root=1)
      else if (rank == 1) then
         mpi.scatter(send,recv,1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully scatter the type VAR_TYPE"
         else
            print*, "MPI failed to scatter the type VAR_TYPE"
         end if
      end if

   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end


   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

   test_scatter(commsize,rank,mpi,send,test,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scatter array routines and print to the terminal the results of
   ! the test.
   end

!=========
! Alltoall
!=========
   
   test_alltoall(commsize,rank,mpi,test,send,recv) ::: template
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      commsize,rank :: INT, IN
      send :: VAR_TYPE, INOUT
      test,recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@
      i,j :: INT
      
      mpi.alltoall(send,recv,commsize)
      if (all(recv EQ test)) then
         if(rank == 0) then
            print*, "MPI can succesfully alltoall the type VAR_TYPE on master"
         else
            print*, "MPI can succesfully alltoall the type VAR_TYPE on non-master"
         end if
      else
         if(rank == 0) then
            print*, "MPI failed to alltoall the type VAR_TYPE on master"
            print*, "RECV:", recv
            print*, "TEST:", test
         else
            print*, "MPI failed to alltoall the type VAR_TYPE on non-master"
            print*, "RECV:", recv
            print*, "TEST:", test
         end if
      end if

   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{STR}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN}, EQ=>EQV)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{STR}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN}, EQ=>EQV)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN}, EQ=>EQV)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end


   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

   test_alltoall(commsize,rank,mpi,test,send,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the alltoall array routines and print to the terminal the results of
   ! the test.
   end

!====
! Sum
!====

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: template
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = reduce_sum
         mpi.reduce_sum(a,root=1)
      else if (rank == 1) then
         a = reduce_sum
         b = recv
         mpi.reduce_sum(a,root=1)
         if (a EQ b) then
            print*, "MPI can succesfully reduce_sum the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_sum the type VAR_TYPE"
            print*, a
            print*, b
         end if
      end if

   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_sum routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: template
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_sum
         mpi.reduce_sum(a,1)
      else if (rank == 1) then
         a = reduce_sum
         b = recv
         mpi.reduce_sum(a,1)
         if (all(a EQ b)) then
            print*, "MPI can succesfully reduce_sum the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_sum the type VAR_TYPE"
            print*, a
            print*, b
         end if
      end if

   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_sum(rank,mpi,reduce_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_sum array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Allsum
!=======

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: template
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = parallel_sum
         mpi.parallel_sum(a)
         b = recv
         if (a EQ b) then
            print*, "MPI can succesfully parallel_sum the type VAR_TYPE non-master"
         else
            print*, "MPI failed to parallel_sum the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      else if (rank == 1) then
         a = parallel_sum
         mpi.parallel_sum(a)
         b = recv
         if (a EQ b) then
            print*, "MPI can succesfully parallel_sum the type VAR_TYPE non-master"
         else
            print*, "MPI failed to parallel_sum the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_sum routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: template
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = parallel_sum
         mpi.parallel_sum(a)
         b=recv
         if (all(a EQ b)) then
            print*, "MPI can succesfully parallel_sum the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_sum the type VAR_TYPE on master"
            print*, a
            print*, b
         end if
      else if (rank == 1) then
         a = parallel_sum
         mpi.parallel_sum(a)
         b=recv
         if (all(a EQ b)) then
            print*, "MPI can succesfully parallel_sum the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_sum the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_sum(rank,mpi,parallel_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_sum array routines and print to the terminal the results of
   ! the test.
   end

!===============
! Summation Scan
!===============

   test_scan_sum(rank,mpi,scan_sum,recv) ::: template
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         mpi.scan_sum(scan_sum,a)
         if (a EQ scan_sum) then
            print*, "MPI can succesfully scan_sum the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_sum the type VAR_TYPE on master"
            print*, a
            print*, scan_sum 
         end if
      else if (rank == 1) then
         a = scan_sum
         b = recv
         mpi.scan_sum(a)
         if (a EQ b) then
            print*, "MPI can succesfully scan_sum the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_sum the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_sum routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: template
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_sum :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = recv
         mpi.scan_sum(scan_sum,a)
         if (all(a EQ scan_sum)) then
            print*, "MPI can succesfully scan_sum the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_sum the type VAR_TYPE on master"
            print*, a
            print*, scan_sum 
         end if
      else if (rank == 1) then
         a = scan_sum
         b = recv
         mpi.scan_sum(a)
         if (all(a EQ b)) then
            print*, "MPI can succesfully scan_sum the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_sum the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_sum(rank,mpi,scan_sum,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_sum array routines and print to the terminal the results of
   ! the test.
   end

!=====
! Prod
!=====

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: template
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = reduce_prod
         mpi.reduce_prod(a,root=1)
      else if (rank == 1) then
         a = reduce_prod
         b = recv
         mpi.reduce_prod(a,root=1)
         if (a EQ b) then
            print*, "MPI can succesfully reduce_prod the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_prod the type VAR_TYPE"
            print*, a
            print*, b
         end if
      end if

   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_prod routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: template
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_prod
         mpi.reduce_prod(a,1)
      else if (rank == 1) then
         a = reduce_prod
         b = recv
         mpi.reduce_prod(a,1)
         if (all(a EQ b)) then
            print*, "MPI can succesfully reduce_prod the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_prod the type VAR_TYPE"
            print*, a
            print*, b
         end if
      end if

   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_prod(rank,mpi,reduce_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_prod array routines and print to the terminal the results of
   ! the test.
   end

!========
! Allprod
!========

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: template
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = parallel_prod
         mpi.parallel_product(a)
         b = recv
         if (a EQ b) then
            print*, "MPI can succesfully parallel_prod the type VAR_TYPE on master"

         else
            print*, "MPI failed to parallel_prod the type VAR_TYPE on master"
            print*, a
            print*, b
         end if
      else if (rank == 1) then
         a = parallel_prod
         mpi.parallel_product(a)
         b = recv
         if (a EQ b) then
            print*, "MPI can succesfully parallel_prod the type VAR_TYPE on non-master"

         else
            print*, "MPI failed to parallel_prod the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_prod routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: template
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = parallel_prod
         mpi.parallel_product(a)
         b=recv
         if (all(a EQ b)) then
            print*, "MPI can succesfully parallel_prod the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_prod the type VAR_TYPE on master"
            print*, a
            print*, b
         end if
      else if (rank == 1) then
         a = parallel_prod
         mpi.parallel_product(a)
         b=recv
         if (all(a EQ b)) then
            print*, "MPI can succesfully parallel_prod the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_prod the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_prod(rank,mpi,parallel_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_prod array routines and print to the terminal the results of
   ! the test.
   end

!===============
! Summation Scan
!===============

   test_scan_prod(rank,mpi,scan_prod,recv) ::: template
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         mpi.scan_product(scan_prod,a)
         if (a EQ scan_prod) then
            print*, "MPI can succesfully scan_prod the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_prod the type VAR_TYPE on master"
            print*, a
            print*, scan_prod 
         end if
      else if (rank == 1) then
         a = scan_prod
         b = recv
         mpi.scan_product(a)
         if (a EQ b) then
            print*, "MPI can succesfully scan_prod the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_prod the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_prod routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: template
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_prod :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = recv
         mpi.scan_product(scan_prod,a)
         if (all(a EQ scan_prod)) then
            print*, "MPI can succesfully scan_prod the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_prod the type VAR_TYPE on master"
            print*, a
            print*, scan_prod 
         end if
      else if (rank == 1) then
         a = scan_prod
         b = recv
         mpi.scan_product(a)
         if (all(a EQ b)) then
            print*, "MPI can succesfully scan_prod the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_prod the type VAR_TYPE on non-master"
            print*, a
            print*, b
         end if
      end if

   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_prod(rank,mpi,scan_prod,recv) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_prod array routines and print to the terminal the results of
   ! the test.
   end

!====
! Max
!====

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: template
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = reduce_max
         mpi.reduce_max(a,root=1)
      else if (rank == 1) then
         a = reduce_max
         b = recv
         mpi.reduce_max(b,root=1)
         if (b EQ test) then
            print*, "MPI can succesfully reduce_max the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_max the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_max routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: template
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_max
         mpi.reduce_max(a,1)
      else if (rank == 1) then
         a = reduce_max
         b = recv
         mpi.reduce_max(b,1)
         if (all(b EQ test)) then
            print*, "MPI can succesfully reduce_max the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_max the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_max(rank,mpi,reduce_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_max array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Allmax
!=======

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: template
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = parallel_max
         b = a
         mpi.parallel_maximum(a,b)
         if (b EQ test) then
            print*, "MPI can succesfully parallel_max the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_max the type VAR_TYPE on master"
            print*, a
            print*, test
         end if
      else if (rank == 1) then
         a = parallel_max
         b = recv
         mpi.parallel_maximum(b)
         if (b EQ test) then
            print*, "MPI can succesfully parallel_max the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_max the type VAR_TYPE on non-master"
            print*, a
            print*, test
         end if
      end if


   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_max routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: template
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = parallel_max
         b = a
         mpi.parallel_maximum(a,b)
         if (all(b EQ test)) then
            print*, "MPI can succesfully parallel_max the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_max the type VAR_TYPE on master"
            print*, a
            print*, test
         end if
      else if (rank == 1) then
         a = parallel_max
         b = recv
         mpi.parallel_maximum(b)
         if (all(b EQ test)) then
            print*, "MPI can succesfully parallel_max the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_max the type VAR_TYPE on non-master"
            print*, a
            print*, test
         end if
      end if

   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_max(rank,mpi,parallel_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_max array routines and print to the terminal the results of
   ! the test.
   end

!=============
! Maximum Scan
!=============

   test_scan_max(rank,mpi,scan_max,recv,test) ::: template
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = scan_max
         b = test
         mpi.scan_maximum(a,b)
         if (b EQ scan_max) then
            print*, "MPI can succesfully scan_max the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_max the type VAR_TYPE on master"
            print*, b
            print*, scan_max
         end if
      else if (rank == 1) then
         b = recv
         mpi.scan_maximum(recv,b)
         if (b EQ test) then
            print*, "MPI can succesfully scan_max the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_max the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if


   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_max routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: template
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_max,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = scan_max
         b = test
         mpi.scan_maximum(a,b)
         if (all(b EQ a)) then
            print*, "MPI can succesfully scan_max the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_max the type VAR_TYPE on master"
            print*, a
            print*, b
         end if
      else if (rank == 1) then
         b = recv
         mpi.scan_maximum(recv,b)
         if (all(b EQ test)) then
            print*, "MPI can succesfully scan_max the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_max the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_max(rank,mpi,scan_max,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_max array routines and print to the terminal the results of
   ! the test.
   end

!====
! Min
!====

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: template
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = reduce_min
         mpi.reduce_min(a,root=1)
      else if (rank == 1) then
         a = reduce_min
         b = recv
         mpi.reduce_min(b,root=1)
         if (b EQ test) then
            print*, "MPI can succesfully reduce_min the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_min the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the reduce_min routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: template
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = reduce_min
         mpi.reduce_min(a,1)
      else if (rank == 1) then
         a = reduce_min
         b = recv
         mpi.reduce_min(b,1)
         if (all(b EQ test)) then
            print*, "MPI can succesfully reduce_min the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_min the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_min(rank,mpi,reduce_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the reduce_min array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Allmin
!=======

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: template
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = parallel_min
         b = a
         mpi.parallel_minimum(a)
         if (a EQ test) then
            print*, "MPI can succesfully parallel_min the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_min the type VAR_TYPE on master"
            print*, a
            print*, test
         end if
      else if (rank == 1) then
         a = parallel_min
         b = recv
         mpi.parallel_minimum(b,a)
         if (a EQ test) then
            print*, "MPI can succesfully parallel_min the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_min the type VAR_TYPE on master"
            print*, a
            print*, test
         end if
      end if


   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the parallel_min routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: template
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      parallel_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = parallel_min
         b = a
         mpi.parallel_minimum(a)
         if (all(a EQ test)) then
            print*, "MPI can succesfully parallel_min the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_min the type VAR_TYPE on master"
            print*, a
            print*, test
         end if
      else if (rank == 1) then
         a = parallel_min
         b = recv
         mpi.parallel_minimum(b,a)
         if (all(a EQ test)) then
            print*, "MPI can succesfully parallel_min the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_min the type VAR_TYPE on non-master"
            print*, a
            print*, test
         end if
      end if

   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end


   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_min(rank,mpi,parallel_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the parallel_min array routines and print to the terminal the results of
   ! the test.
   end

!=============
! Minimum Scan
!=============

   test_scan_min(rank,mpi,scan_min,recv,test) ::: template
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE
      
      if(rank == 0) then
         a = scan_min
         b = test
         mpi.scan_minimum(a,b)
         if (b EQ scan_min) then
            print*, "MPI can succesfully scan_min the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_min the type VAR_TYPE on master"
            print*, b
            print*, scan_min
         end if
      else if (rank == 1) then
         b = recv
         mpi.scan_minimum(recv,b)
         if (b EQ test) then
            print*, "MPI can succesfully scan_min the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_min the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if


   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>INT, EQ=>==)
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>REAL, EQ=>==)
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>CPX, EQ=>==)
   ! Test the scan_min routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: template
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      scan_min,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      a,b  :: VAR_TYPE@ 
      
      if(rank == 0) then
         a = scan_min
         b = test
         mpi.scan_minimum(a,b)
         if (all(b EQ a)) then
            print*, "MPI can succesfully scan_min the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_min the type VAR_TYPE on master"
            print*, a
            print*, b
         end if
      else if (rank == 1) then
         b = recv
         mpi.scan_minimum(recv,b)
         if (all(b EQ test)) then
            print*, "MPI can succesfully scan_min the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_min the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end


   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_min(rank,mpi,scan_min,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{CPX}, EQ=>==)
   ! Test the scan_min array routines and print to the terminal the results of
   ! the test.
   end

!=======
! Maxloc
!=======

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: template
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_maxloc,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      var  :: VAR_TYPE@ 
      
     if(rank == 0) then
         mpi.reduce_maxloc(reduce_maxloc,root=1)
      else if (rank == 1) then
         mpi.reduce_maxloc(recv,root=1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully reduce_maxloc the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_maxloc the type VAR_TYPE"
            print*, test
            print*, recv
         end if
      end if

   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_maxloc(rank,mpi,reduce_maxloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_maxloc array routines and print to the terminal the results of
   ! the test.
   end


!=======
! Minloc
!=======

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: template
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      reduce_minloc,test :: VAR_TYPE, INOUT
      recv :: VAR_TYPE, INOUT
      var  :: VAR_TYPE@ 
      
     if(rank == 0) then
         mpi.reduce_minloc(reduce_minloc,root=1)
      else if (rank == 1) then
         mpi.reduce_minloc(recv,root=1)
         if (all(recv EQ test)) then
            print*, "MPI can succesfully reduce_minloc the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_minloc the type VAR_TYPE"
            print*, test
            print*, recv
         end if
      end if

   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT4{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end


   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{INT}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_minloc(rank,mpi,reduce_minloc,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT5{REAL}, EQ=>==)
   ! Test the reduce_minloc array routines and print to the terminal the results of
   ! the test.
   end

!====
! Lor
!====

   test_reduce_lor(rank,mpi,send,recv,test) 
   ! Test the reduce_lor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.reduce_lor(send,root=1)
      else if (rank == 1) then
         mpi.reduce_lor(recv,root=1,lor=b)
         if (b EQV test) then
            print*, "MPI can succesfully reduce_lor the type BIN"
         else
            print*, "MPI failed to reduce_lor the type BIN"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: template
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.reduce_lor(send,root=1)
      else if (rank == 1) then
         b=send
         mpi.reduce_lor(recv,root=1,lor=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully reduce_lor the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_lor the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the reduce_lor array routines and print to the terminal the results of
   ! the test.
   end

!=======
! AllLor
!=======

   test_parallel_or(rank,mpi,send,recv,test) 
   ! Test the parallel_or routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.parallel_or(send)
         if (send EQV test) then
            print*, "MPI can succesfully parallel_lor the type BIN on master"
         else
            print*, "MPI failed to parallel_lor the type BIN on master"
            print*, send
            print*, test
         end if
      else if (rank == 1) then
         mpi.parallel_or(recv,lor=b)
         if (b EQV test) then
            print*, "MPI can succesfully parallel_lor the type BIN on non-master"
         else
            print*, "MPI failed to parallel_lor the type BIN on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_parallel_or(rank,mpi,send,recv,test) ::: template
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.parallel_or(send)
         if (all(send EQV test)) then
            print*, "MPI can succesfully parallel_lor the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_lor the type VAR_TYPE on master"
            print*, send
            print*, test
         end if
      else if (rank == 1) then
         b=send
         mpi.parallel_or(recv,lor=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully parallel_lor the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_lor the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_parallel_or(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_or(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_or(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the parallel_or array routines and print to the terminal the results of
   ! the test.
   end

!=========
! Scan Lor
!=========

   test_scan_lor(rank,mpi,send,recv,test) 
   ! Test the scan_lor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.scan_lor(send,b)
         if (send EQV b) then
            print*, "MPI can succesfully scan_lor the type BIN on master"
         else
            print*, "MPI failed to scan_lor the type BIN on master"
            print*, send
            print*, b
         end if
      else if (rank == 1) then
         mpi.scan_lor(recv,lor=b)
         if (b EQV test) then
            print*, "MPI can succesfully scan_lor the type BIN on non-master"
         else
            print*, "MPI failed to scan_lor the type BIN on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_lor(rank,mpi,send,recv,test) ::: template
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.scan_lor(send,b)
         if (all(send EQV test)) then
            print*, "MPI can succesfully scan_lor the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_lor the type VAR_TYPE on master"
            print*, send
            print*, b
         end if
      else if (rank == 1) then
         b=send
         mpi.scan_lor(recv,lor=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully scan_lor the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_lor the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the scan_lor array routines and print to the terminal the results of
   ! the test.
   end

!=====
! Land
!=====

   test_reduce_land(rank,mpi,send,recv,test) 
   ! Test the reduce_land routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.reduce_land(send,root=1)
      else if (rank == 1) then
         mpi.reduce_land(recv,root=1,land=b)
         if (b EQV test) then
            print*, "MPI can succesfully reduce_land the type BIN"
         else
            print*, "MPI failed to reduce_land the type BIN"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_land(rank,mpi,send,recv,test) ::: template
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.reduce_land(send,root=1)
      else if (rank == 1) then
         b=send
         mpi.reduce_land(recv,root=1,land=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully reduce_land the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_land the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the reduce_land array routines and print to the terminal the results of
   ! the test.
   end

!========
! AllLand
!========

   test_parallel_and(rank,mpi,send,recv,test) 
   ! Test the parallel_and routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.parallel_and(send)
         if (send EQV test) then
            print*, "MPI can succesfully parallel_land the type BIN on master"
         else
            print*, "MPI failed to parallel_land the type BIN on master"
            print*, send
            print*, test
         end if
      else if (rank == 1) then
         mpi.parallel_and(recv,land=b)
         if (b EQV test) then
            print*, "MPI can succesfully parallel_land the type BIN on non-master"
         else
            print*, "MPI failed to parallel_land the type BIN on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_parallel_and(rank,mpi,send,recv,test) ::: template
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.parallel_and(send)
         if (all(send EQV test)) then
            print*, "MPI can succesfully parallel_land the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_land the type VAR_TYPE on master"
            print*, send
            print*, test
         end if
      else if (rank == 1) then
         b=send
         mpi.parallel_and(recv,land=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully parallel_land the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_land the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_parallel_and(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_and(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_and(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the parallel_and array routines and print to the terminal the results of
   ! the test.
   end

!==========
! Scan Land
!==========

   test_scan_land(rank,mpi,send,recv,test) 
   ! Test the scan_land routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.scan_land(send,b)
         if (send EQV b) then
            print*, "MPI can succesfully scan_land the type BIN on master"
         else
            print*, "MPI failed to scan_land the type BIN on master"
            print*, send
            print*, b
         end if
      else if (rank == 1) then
         mpi.scan_land(recv,land=b)
         if (b EQV test) then
            print*, "MPI can succesfully scan_land the type BIN on non-master"
         else
            print*, "MPI failed to scan_land the type BIN on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_land(rank,mpi,send,recv,test) ::: template
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         b = test
         mpi.scan_land(send,b)
         if (all(send EQV b)) then
            print*, "MPI can succesfully scan_land the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_land the type VAR_TYPE on master"
            print*, send
            print*, b
         end if
      else if (rank == 1) then
         b=send
         mpi.scan_land(recv,land=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully scan_land the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_land the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_land(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the scan_land array routines and print to the terminal the results of
   ! the test.
   end

!=====
! Lxor
!=====

   test_reduce_lxor(rank,mpi,send,recv,test) 
   ! Test the reduce_lxor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.reduce_lxor(send,root=1)
      else if (rank == 1) then
         mpi.reduce_lxor(recv,root=1,lxor=b)
         if (b EQV test) then
            print*, "MPI can succesfully reduce_lxor the type BIN"
         else
            print*, "MPI failed to reduce_lxor the type BIN"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: template
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.reduce_lxor(send,root=1)
      else if (rank == 1) then
         b=send
         mpi.reduce_lxor(recv,root=1,lxor=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully reduce_lxor the type VAR_TYPE"
         else
            print*, "MPI failed to reduce_lxor the type VAR_TYPE"
            print*, b
            print*, test
         end if
      end if

   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_reduce_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the reduce_lxor array routines and print to the terminal the results of
   ! the test.
   end

!========
! AllLxor
!========

   test_parallel_xor(rank,mpi,send,recv,test) 
   ! Test the parallel_xor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.parallel_xor(send)
         if (send EQV test) then
            print*, "MPI can succesfully parallel_lxor the type BIN on master"
         else
            print*, "MPI failed to parallel_lxor the type BIN on master"
            print*, send
            print*, test
         end if
      else if (rank == 1) then
         mpi.parallel_xor(recv,lxor=b)
         if (b EQV test) then
            print*, "MPI can succesfully parallel_lxor the type BIN on non-master"
         else
            print*, "MPI failed to parallel_lxor the type BIN on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: template
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.parallel_xor(send)
         if (all(send EQV test)) then
            print*, "MPI can succesfully parallel_lxor the type VAR_TYPE on master"
         else
            print*, "MPI failed to parallel_lxor the type VAR_TYPE on master"
            print*, send
            print*, test
         end if
      else if (rank == 1) then
         b=send
         mpi.parallel_xor(recv,lxor=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully parallel_lxor the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to parallel_lxor the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
   end

   test_parallel_xor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the parallel_xor array routines and print to the terminal the results of
   ! the test.
   end

!=========
! Scan Lxor
!=========

   test_scan_lxor(rank,mpi,send,recv,test) 
   ! Test the scan_lxor routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: BIN, INOUT
      b  :: BIN
      
      if(rank == 0) then
         mpi.scan_lxor(send,b)
         if (send EQV b) then
            print*, "MPI can succesfully scan_lxor the type BIN on master"
         else
            print*, "MPI failed to scan_lxor the type BIN on master"
            print*, send
            print*, b
         end if
      else if (rank == 1) then
         mpi.scan_lxor(recv,lxor=b)
         if (b EQV test) then
            print*, "MPI can succesfully scan_lxor the type BIN on non-master"
         else
            print*, "MPI failed to scan_lxor the type BIN on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: template
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      send,recv,test :: VAR_TYPE, INOUT
      b  :: VAR_TYPE@
      
      if(rank == 0) then
         mpi.scan_lxor(send,b)
         if (all(send EQV test)) then
            print*, "MPI can succesfully scan_lxor the type VAR_TYPE on master"
         else
            print*, "MPI failed to scan_lxor the type VAR_TYPE on master"
            print*, send
            print*, b
         end if
      else if (rank == 1) then
         b=send
         mpi.scan_lxor(recv,lxor=b)
         if (all(b EQV test)) then
            print*, "MPI can succesfully scan_lxor the type VAR_TYPE on non-master"
         else
            print*, "MPI failed to scan_lxor the type VAR_TYPE on non-master"
            print*, b
            print*, test
         end if
      end if

   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>VEC{BIN})
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT{BIN})
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
   end

   test_scan_lxor(rank,mpi,send,recv,test) ::: get_from(TEST_PARALLEL, VAR_TYPE=>MAT3{BIN})
   ! Test the scan_lxor array routines and print to the terminal the results of
   ! the test.
   end

!========
! Barrier
!========

   test_barrier(rank,mpi) 
   ! Test the barrier routine and print to the terminal the results of
   ! the test.
      self :: INOUT
      mpi :: SYSTEM, INOUT
      rank :: INT, IN
      a,b  :: INT
      time2,time1 :: REAL
      
      if(rank == 0) then
         call sleep(1)
         mpi.barrier
      else if (rank == 1) then
         mpi.wtime(time1)
         mpi.barrier
         mpi.wtime(time2)
         if(time2-time1>1) print*, "Barrier and wtime both function correctly"
      end if

   end


end
