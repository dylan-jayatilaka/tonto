!==============================================================================-
!
! MOLECULE.GEM: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Patrick Cassam-Chenai
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.gem.foo $
!==============================================================================-


module MOLECULE.GEM

   implicit none

contains

! ============================================
! Geminal Mean Field Configuration Interaction
! ============================================

   read_geminal_mf_scheme ::: leaky 
   ! Read in geminal mean field scheme options

   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT

     .geminal_mf_scheme.create
     .geminal_mf_scheme.set_defaults(.n_a,.n_bf,.name,.BASE:nuclear_repulsion_energy)
     .geminal_mf_scheme.read_keywords

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     ! this routine stops here in most cases
     if(.geminal_mf_scheme.readin_scheme) then
       .geminal_mf_scheme.read_scheme
     end

     if(.geminal_mf_scheme.make_singlet_extremals) then

       n_bf = .n_bf
       make_integrals = .geminal_mf_scheme.make_integrals
       readin_mos     = .geminal_mf_scheme.readin_mos

       if (make_integrals) then

         ! First create the MO integrals on disk
         v.create(n_bf,n_bf,n_bf,n_bf)
         .FOCK:make_ERI_integrals(v)

         new_n_bf = .geminal_mf_scheme.n_orbitals
         DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

         eri_archive.set(.name,"h_integrals")

         if (readin_mos) then

           if (new_n_bf==n_bf) then
             .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           else
             .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           end

         else

           if (new_n_bf==n_bf) then
             .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           else
             .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           end

         end

         v.destroy      

         stdout.text(" ")
         stdout.text("an integral file has been saved on disk")
         stdout.text(" ")

       else

         stdout.text(" ")
         stdout.text("using old integral file")
         stdout.text(" ")

       end

       .geminal_mf_scheme.spectrum.make_singlet_extremals

     end

   end

   do_geminal_mf_scheme ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.geminal_mf_scheme.created,"no geminal_mf_scheme info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     do_electric_dipole :: BIN

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     do_electric_dipole = any(.geminal_mf_scheme.do_electric_dipole)
     if (do_electric_dipole) then
       .geminal_mf_scheme.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
     end

     make_integrals = .geminal_mf_scheme.make_integrals
     readin_mos     = .geminal_mf_scheme.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)

       new_n_bf = .geminal_mf_scheme.n_orbitals
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if(new_n_bf==n_bf)then
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if(new_n_bf==n_bf)then
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

     .geminal_mf_scheme.do_gmf_auto

   end

   restart_geminal_mf_scheme ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.geminal_mf_scheme.created,"no geminal_mf_scheme info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     do_electric_dipole :: BIN

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     n_bf = .n_bf

     do_electric_dipole = any(.geminal_mf_scheme.do_electric_dipole)
     if (do_electric_dipole) then
       .geminal_mf_scheme.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
     end

     make_integrals = .geminal_mf_scheme.make_integrals
     readin_mos     = .geminal_mf_scheme.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)

       new_n_bf = .geminal_mf_scheme.n_orbitals

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if(new_n_bf==n_bf)then
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if(new_n_bf==n_bf)then
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text("Warning: a restart job may failed")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

     .geminal_mf_scheme.restart_gmf_auto

   end

   read_pauli_block_geminals ::: leaky 
   ! Read in pauli_block_geminals info
   !
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")
   !
!   random_guess, hf_guess :: BIN

     stdout.text(" ")
     stdout.text(" ")
     stdout.text("================================")
     stdout.text("Pauli block geminals calculation")
     stdout.text("================================")
!     stdout.text(" ")

     .pauli_block_geminals.create
     .pauli_block_geminals.check_spin_multiplicity(.spin_multiplicity)
 !    .pauli_block_geminals.set_defaults(n_geminals=.n_a,n_blocks=.n_a+(.n_bf-.n_a+1)/2,mat_size=.n_bf,mol_name=.name,bra_is_ket=TRUE)
     !.pauli_block_geminals.set_defaults(n_geminals=.n_a,n_blocks=.n_a+(.n_bf-.n_a+1)/2,mat_size=.n_bf,mol_name=.name)
     .pauli_block_geminals.set_defaults(.n_e, .n_bf, .name, .BASE:nuclear_repulsion_energy)
     .pauli_block_geminals.create(.pauli_block_geminals.bra_set.vec,.pauli_block_geminals.n_geminals)
     .pauli_block_geminals.create(.pauli_block_geminals.ket_set.vec,.pauli_block_geminals.n_geminals)
  !   .pauli_block_geminals.bra_set.type_nb.create(.pauli_block_geminals.n_blocks)
  !   .pauli_block_geminals.ket_set.type_nb.create(.pauli_block_geminals.n_blocks)
     .pauli_block_geminals.read_keywords

! davide: 03-10-2019
!!!!!!!!!!!!!!!!!!
!     random_guess = (.pauli_block_geminals.guess_type == "random" OR .pauli_block_geminals.guess_type == "hf-random") 
!     hf_guess = (.pauli_block_geminals.guess_type == "hf")
!     !
!     if (random_guess) then
!        .pauli_block_geminals.random_geminals_generator
!     else if (hf_guess) then
!        .pauli_block_geminals.guess_geminals_hf
!     end
!!     if (random_guess) .pauli_block_geminals.random_geminals_generator
!!     if (.pauli_block_geminals.guess_type == "random") .pauli_block_geminals.random_geminals_generator
!!!!!!!!!!!!!!!!!!
! de
! davide: 18-11-2019
     !!!
     ! select routine(s) to be called on the basis of the input guess type
     select case (.pauli_block_geminals.guess_type)
     case("readin")
         stdout.text(" ")
         stdout.text("Bra set:")
         .pauli_block_geminals.write_pbt_set(.pauli_block_geminals.bra_set)
         if (NOT .pauli_block_geminals.bra_is_ket) then
            stdout.text(" ")
            stdout.text("Ket set:")
            .pauli_block_geminals.write_pbt_set(.pauli_block_geminals.ket_set)
         end
     case("hf")
        .pauli_block_geminals.guess_geminals_hf
     case("hf-random")
        .pauli_block_geminals.random_geminals_generator
     case("random")
        .pauli_block_geminals.random_geminals_generator
     case default
        stdout.text("Error in routine read_pauli_block_geminals:")
        stdout.text("unknown string to select the guess type.")
        stop
     end
     !!!
! de

     if (.pauli_block_geminals.gen_block) .pauli_block_geminals.initialize_GD2

!! davide: 03-10-2019
!      if (.pauli_block_geminals.guess_type == "random") .pauli_block_geminals.random_geminals_generator
!! de

! davide: 26-10-2018
     .pauli_block_geminals.check_size
     .pauli_block_geminals.check_block_sizes
! de
! davide: 12-11-2018
     .pauli_block_geminals.check_blocks_order
     !.pauli_block_geminals.check_size1_blocks
 !    .pauli_block_geminals.check_nonzero_1ortho_blocks_position
! de
!! davide: 08-11-2018
!     .pauli_block_geminals.check_bra_ket_homogeneity
!! de
! davide: 01-11-2018/03-11-2018
    ! .pauli_block_geminals.check_ortho
    ! .pauli_block_geminals.check_model_constraints
! de
! davide: 30-10-2018
     .pauli_block_geminals.normalize_gem
! de
     .pauli_block_geminals.set_matrix_form
!     .pauli_block_geminals.make_trace

! davide: 31-10-2018
     .pauli_block_geminals.find_nonzero_coef
! de
! davide: 11-11-2018
     .pauli_block_geminals.make_int_term_list
! de
   end

   do_PBG_energy ::: leaky 
   ! compute the electronic energy for a set of Pauli block geminals
   ! (PBG)

   ENSURE(.pauli_block_geminals.created,"no pauli_block_geminals info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     mat_size :: INT
     overlap :: REAL
     ham :: REAL
     S_mat :: MAT{REAL}*
!     do_electric_dipole :: BIN
     timer :: TIME
     timer_ov :: TIME
     timer_1rdm :: TIME
     timer_2rdm :: TIME
     timer_ham :: TIME
     timer_grad :: TIME
     !calc_gradient :: BIN
     !nonzero_only_1ortho :: BIN

     stdout.text(" ")
     stdout.text("==================")
     stdout.text("Energy calculation")
     stdout.text("==================")

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

!     do_electric_dipole = any(.pauli_block_geminals.do_electric_dipole)
!     if (do_electric_dipole) then
!        .pauli_block_geminals.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
!     end

     make_integrals =.pauli_block_geminals.make_integrals
     readin_mos     =.pauli_block_geminals.readin_mos


     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)
       .pauli_block_geminals.add_core = TRUE

       new_n_bf = .pauli_block_geminals.mat_size
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         stdout.text(" ")
         if (new_n_bf==n_bf)then
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if (new_n_bf==n_bf)then
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end


     timer.start_timing

     !
     ! step 0: read in and store the integrals
     !
     mat_size=.pauli_block_geminals.mat_size
     eri_archive.set(.pauli_block_geminals.name,"h_integrals")
     .pauli_block_geminals.ijkl_integrals.create(mat_size,mat_size,mat_size,mat_size)
     eri_archive.read(.pauli_block_geminals.ijkl_integrals)
     
     !
     ! step 1: calculation of the wavefunction squared norm
     !
     timer_ov.start_timing
     .pauli_block_geminals.calc_overlap_integral(overlap)
     timer_ov.stop_timing
     stdout.show("Time taken (in sec) ov: ",timer_ov.elapsed_time_s,14)
     .pauli_block_geminals.overlap = overlap
     !
     ! step 2: calculation of the 1-electron density matrix (1RDM)
     !         (the 1RDM is not used in the calculation of the energy)
     !
     timer_1rdm.start_timing
     .pauli_block_geminals.calc_1rdm_gen
     timer_1rdm.stop_timing
     stdout.show("Time taken (in sec) 1rdm: ",timer_1rdm.elapsed_time_s,14)
     !
     ! step 3: calculation of the 2-electron density matrix (2RDM)
     !
     timer_2rdm.start_timing
     if (.pauli_block_geminals.calc_gradient) then
        ! if the calculation of the gradient is requested
        ! (in addition to the energy)
        stdout.text(" ")
        stdout.text("Calculation of the energy gradient will be performed")
        stdout.text(" ")
        .pauli_block_geminals.initialize_energy_gradient
        .pauli_block_geminals.calc_2rtm_epi2o(make_grad=TRUE)
     else
        ! if only the energy has to be computed
        .pauli_block_geminals.calc_2rtm_epi2o
     end
     timer_2rdm.stop_timing
     stdout.show("Time taken (in sec) 2rdm: ",timer_2rdm.elapsed_time_s,14)
     !
     ! step 4: calculation of the electronic energy
     !
     timer_ham.start_timing
     .pauli_block_geminals.make_ham_expect_val(ham) 
     timer_ham.stop_timing
     stdout.show("Time taken (in sec) ham: ",timer_ham.elapsed_time_s,14)
     !
     ! step 5: calculation of the energy gradient WRT the block
     !         coefficients (if requested)
     !
     if (.pauli_block_geminals.calc_gradient) then
        timer_grad.start_timing
        .pauli_block_geminals.calc_energy_gradient(wrt_arg=TRUE)
        timer_grad.stop_timing
        stdout.show("Time taken (in sec) grad: ",timer_grad.elapsed_time_s,14)
     end
     !
     ! destroy matrix of integrals
     .pauli_block_geminals.ijkl_integrals.destroy

     timer.stop_timing
     stdout.text(" ")
     stdout.show("Time taken (in sec) : ",timer.elapsed_time_s,14)
     stdout.show("Time taken : ",timer.elapsed_time5,8)
     stdout.text(" ")

   end

   do_PBG_optimization ::: leaky 
   ! perform the optimization of the block coefficients 
   ! of the Pauli block geminals

   ENSURE(.pauli_block_geminals.created,"no pauli_block_geminals info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     mat_size :: INT
     S_mat :: MAT{REAL}*
!     do_electric_dipole :: BIN

     ! starting optimization of block coefficients
     stdout.text(" ")
     stdout.text("==================================")
     stdout.text("Optimization of block coefficients")
     stdout.text("==================================")

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

!     do_electric_dipole = any(.pauli_block_geminals.do_electric_dipole)
!     if (do_electric_dipole) then
!        .pauli_block_geminals.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
!     end

     make_integrals =.pauli_block_geminals.make_integrals
     readin_mos     =.pauli_block_geminals.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)
       .pauli_block_geminals.add_core = TRUE

       new_n_bf = .pauli_block_geminals.mat_size
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then
         stdout.text(" ")
         if (new_n_bf==n_bf)then
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end
       else
         if (new_n_bf==n_bf)then
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end
       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end


     !
     ! step 0: read in and store the integrals
     !
     mat_size=.pauli_block_geminals.mat_size
     eri_archive.set(.pauli_block_geminals.name,"h_integrals")
     .pauli_block_geminals.ijkl_integrals.create(mat_size,mat_size,mat_size,mat_size)
     eri_archive.read(.pauli_block_geminals.ijkl_integrals)
     
     !
     ! call the routine for optimization of block coefficients
     !
     .pauli_block_geminals.optimize_coef
     !
     ! destroy matrix of integrals
     .pauli_block_geminals.ijkl_integrals.destroy
   end

end
