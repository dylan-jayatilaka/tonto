!==============================================================================-
!
! MOLECULE.GEM: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Patrick Cassam-Chenai
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.gem.foo $
!==============================================================================-


module MOLECULE.GEM

   implicit none

contains

! ============================================
! Geminal Mean Field Configuration Interaction
! ============================================

   read_geminal_mf_scheme ::: leaky 
   ! Read in geminal mean field scheme options

   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT

     .geminal_mf_scheme.create
     .geminal_mf_scheme.set_defaults(.n_a,.n_bf,.name,.BASE:nuclear_repulsion_energy)
     .geminal_mf_scheme.read_keywords

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     ! this routine stops here in most cases
     if(.geminal_mf_scheme.readin_scheme) then
       .geminal_mf_scheme.read_scheme
     end

     if(.geminal_mf_scheme.make_singlet_extremals) then

       n_bf = .n_bf
       make_integrals = .geminal_mf_scheme.make_integrals
       readin_mos     = .geminal_mf_scheme.readin_mos

       if (make_integrals) then

         ! First create the MO integrals on disk
         v.create(n_bf,n_bf,n_bf,n_bf)
         .FOCK:make_ERI_integrals(v)

         new_n_bf = .geminal_mf_scheme.n_orbitals
         DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

         eri_archive.set(.name,"h_integrals")

         if (readin_mos) then

           if (new_n_bf==n_bf) then
             .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           else
             .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           end

         else

           if (new_n_bf==n_bf) then
             .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           else
             .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           end

         end

         v.destroy      

         stdout.text(" ")
         stdout.text("an integral file has been saved on disk")
         stdout.text(" ")

       else

         stdout.text(" ")
         stdout.text("using old integral file")
         stdout.text(" ")

       end

       .geminal_mf_scheme.spectrum.make_singlet_extremals

     end

   end

   do_geminal_mf_scheme ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.geminal_mf_scheme.created,"no geminal_mf_scheme info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     do_electric_dipole :: BIN

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     do_electric_dipole = any(.geminal_mf_scheme.do_electric_dipole)
     if (do_electric_dipole) then
       .geminal_mf_scheme.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
     end

     make_integrals = .geminal_mf_scheme.make_integrals
     readin_mos     = .geminal_mf_scheme.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)

       new_n_bf = .geminal_mf_scheme.n_orbitals
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if(new_n_bf==n_bf)then
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if(new_n_bf==n_bf)then
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

     .geminal_mf_scheme.do_gmf_auto

   end

   restart_geminal_mf_scheme ::: leaky 
   ! perform a geminal mean field calculation

   ENSURE(.geminal_mf_scheme.created,"no geminal_mf_scheme info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     do_electric_dipole :: BIN

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

     n_bf = .n_bf

     do_electric_dipole = any(.geminal_mf_scheme.do_electric_dipole)
     if (do_electric_dipole) then
       .geminal_mf_scheme.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
     end

     make_integrals = .geminal_mf_scheme.make_integrals
     readin_mos     = .geminal_mf_scheme.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)

       new_n_bf = .geminal_mf_scheme.n_orbitals

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         if(new_n_bf==n_bf)then
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
           .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if(new_n_bf==n_bf)then
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
           .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.geminal_mf_scheme.add_core,new_n_bf=new_n_bf)
           if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text("Warning: a restart job may failed")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end

     .geminal_mf_scheme.restart_gmf_auto

   end

   read_pauli_block_geminals ::: leaky 
   ! Read in pauli_block_geminals info
   !
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")
   !
   random_guess, hf_guess :: BIN

     stdout.text(" ")
     stdout.text(" ")
     stdout.text("================================")
     stdout.text("Pauli block geminals calculation")
     stdout.text("================================")
!     stdout.text(" ")

     .pauli_block_geminals.create
     .pauli_block_geminals.check_spin_multiplicity(.spin_multiplicity)
 !    .pauli_block_geminals.set_defaults(n_geminals=.n_a,n_blocks=.n_a+(.n_bf-.n_a+1)/2,mat_size=.n_bf,mol_name=.name,bra_is_ket=TRUE)
     !.pauli_block_geminals.set_defaults(n_geminals=.n_a,n_blocks=.n_a+(.n_bf-.n_a+1)/2,mat_size=.n_bf,mol_name=.name)
     .pauli_block_geminals.set_defaults(.n_e, .n_bf, .name, .BASE:nuclear_repulsion_energy)
     .pauli_block_geminals.create(.pauli_block_geminals.bra_set.vec,.pauli_block_geminals.n_geminals)
     .pauli_block_geminals.create(.pauli_block_geminals.ket_set.vec,.pauli_block_geminals.n_geminals)
  !   .pauli_block_geminals.bra_set.type_nb.create(.pauli_block_geminals.n_blocks)
  !   .pauli_block_geminals.ket_set.type_nb.create(.pauli_block_geminals.n_blocks)
     .pauli_block_geminals.read_keywords

! davide: 03-10-2019
!!!!!!!!!!!!!!!!!!
!     random_guess = (.pauli_block_geminals.guess_type == "random" OR .pauli_block_geminals.guess_type == "hf-random") 
!     hf_guess = (.pauli_block_geminals.guess_type == "hf")
!     !
!     if (random_guess) then
!        .pauli_block_geminals.random_geminals_generator
!     else if (hf_guess) then
!        .pauli_block_geminals.guess_geminals_hf
!     end
!!     if (random_guess) .pauli_block_geminals.random_geminals_generator
!!     if (.pauli_block_geminals.guess_type == "random") .pauli_block_geminals.random_geminals_generator
!!!!!!!!!!!!!!!!!!
! de
! davide: 18-11-2019
     !!!
     ! select routine(s) to be called on the basis of the input guess type
     select case (.pauli_block_geminals.guess_type)
     case("readin")
         stdout.text(" ")
         stdout.text("Bra set:")
         .pauli_block_geminals.write_pbt_set(.pauli_block_geminals.bra_set)
         if (NOT .pauli_block_geminals.bra_is_ket) then
            stdout.text(" ")
            stdout.text("Ket set:")
            .pauli_block_geminals.write_pbt_set(.pauli_block_geminals.ket_set)
         end
     case("hf")
        .pauli_block_geminals.guess_geminals_hf
     case("hf-random")
        .pauli_block_geminals.random_geminals_generator
     case("random")
        .pauli_block_geminals.random_geminals_generator
     case default
        stdout.text("Error in routine read_pauli_block_geminals:")
        stdout.text("unknown string to select the guess type.")
        stop
     end
     !!!
! de

     if (.pauli_block_geminals.gen_block) .pauli_block_geminals.initialize_GD2

!! davide: 03-10-2019
!      if (.pauli_block_geminals.guess_type == "random") .pauli_block_geminals.random_geminals_generator
!! de

! davide: 26-10-2018
     .pauli_block_geminals.check_size
     .pauli_block_geminals.check_block_sizes
! de
! davide: 12-11-2018
     .pauli_block_geminals.check_blocks_order
     !.pauli_block_geminals.check_size1_blocks
 !    .pauli_block_geminals.check_nonzero_1ortho_blocks_position
! de
!! davide: 08-11-2018
!     .pauli_block_geminals.check_bra_ket_homogeneity
!! de
! davide: 01-11-2018/03-11-2018
    ! .pauli_block_geminals.check_ortho
    ! .pauli_block_geminals.check_model_constraints
! de
! davide: 30-10-2018
     .pauli_block_geminals.norm_gem
! de
!! davide: 09-11-2018
!     .pauli_block_geminals.prep_nonzero_coef_ind
!! de

     .pauli_block_geminals.set_matrix_form
!     .pauli_block_geminals.make_trace

! davide: 31-10-2018
     .pauli_block_geminals.find_nonzero_coef
! de
! davide: 11-11-2018
     .pauli_block_geminals.make_int_term_list
! de
   end

   do_PBG_energy ::: leaky 
   ! compute the electronic energy for a set of Pauli block geminals
   ! (PBG)

   ENSURE(.pauli_block_geminals.created,"no pauli_block_geminals info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     overlap :: REAL
     ham :: REAL
     nb_pauli_blocks,i :: INT
     S_mat :: MAT{REAL}*
!     do_electric_dipole :: BIN
     norm :: REAL
     timer :: TIME
     timer_ov :: TIME
     timer_1rdm :: TIME
     timer_2rdm :: TIME
     timer_ham :: TIME
     timer_grad :: TIME
     !calc_gradient :: BIN
     !nonzero_only_1ortho :: BIN

     stdout.text(" ")
     stdout.text("==================")
     stdout.text("Energy calculation")
     stdout.text("==================")

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

!     do_electric_dipole = any(.pauli_block_geminals.do_electric_dipole)
!     if (do_electric_dipole) then
!        .pauli_block_geminals.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
!     end

     make_integrals =.pauli_block_geminals.make_integrals
     readin_mos     =.pauli_block_geminals.readin_mos


     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)
       .pauli_block_geminals.add_core = TRUE

       new_n_bf = .pauli_block_geminals.mat_size
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then

         stdout.text(" ")
         if (new_n_bf==n_bf)then
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       else

         if (new_n_bf==n_bf)then
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end

       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end


! davide: 04-11-2019

     timer.start_timing
     
     timer_ov.start_timing
     !
     ! step 1: calculation of the wavefunction squared norm
     !
     .pauli_block_geminals.calc_overlap_integral(overlap)
     !
     timer_ov.stop_timing
     stdout.show("Time taken (in sec) ov: ",timer_ov.elapsed_time_s,14)
     .pauli_block_geminals.overlap = overlap
     !
!    !!!
     timer_1rdm.start_timing
!    !!!
     !
     ! step 2: calculation of the 1-electron density matrix (1RDM)
     !         (the 1RDM is not used in the calculation of the energy)
     !
     .pauli_block_geminals.calc_1rdm_gen
     !
!    !!!
     timer_1rdm.stop_timing
     stdout.show("Time taken (in sec) 1rdm: ",timer_1rdm.elapsed_time_s,14)
     timer_2rdm.start_timing
     !!!
!     ! check if the calculation of the gradient is requested
!     calc_gradient = FALSE
!     if (.pauli_block_geminals.calc_gradient) then
!        .pauli_block_geminals.check_if_nonzero_only_1ortho(nonzero_only_1ortho)
!        if (nonzero_only_1ortho) then
!        !if (.pauli_block_geminals.n_2D_blocks == 0) then
!           calc_gradient = TRUE
!           stdout.text(" ")
!           stdout.text("Calculation of the energy gradient will be performed")
!           stdout.text(" ")
!        else
!           stdout.text(" ")
!           stdout.text("Calculation of the energy derivatives with respect to")
!           stdout.text("the 2D-block coefficients is not implemented yet:")
!           stdout.text("the energy gradient will not be computed")
!           stdout.text(" ")
!        end
!     end
!     !
!     ! step 3: calculation of the 2-electron density matrix (2RDM)
!     !
!     if (calc_gradient) then
!        ! if the calculation of the gradient is requested
!        ! (in addition to the energy)
!        .pauli_block_geminals.calc_2rdm_gen_grd
!     else
!        ! if only the energy has to be computed
!        .pauli_block_geminals.calc_2rdm_gen
!     end
!     !
!!    !!!
     !!!
     !
     ! step 3: calculation of the 2-electron density matrix (2RDM)
     !
     if (.pauli_block_geminals.calc_gradient) then
        ! if the calculation of the gradient is requested
        ! (in addition to the energy)
        stdout.text(" ")
        stdout.text("Calculation of the energy gradient will be performed")
        stdout.text(" ")
        .pauli_block_geminals.calc_2rdm_gen_grd
     else
        ! if only the energy has to be computed
        .pauli_block_geminals.calc_2rdm_gen
        stdout.show("Number of non-trivial reduced overlaps calculated: ",.pauli_block_geminals.red_overlap_calc_2rdm)
     end

     !
     !!!
     timer_2rdm.stop_timing
     stdout.show("Time taken (in sec) 2rdm: ",timer_2rdm.elapsed_time_s,14)
!    !!!
     !
     timer_ham.start_timing
     !
     ! step 4: calculation of the electronic energy
     !
     .pauli_block_geminals.make_hamiltonian(ham) 
     !
     timer_ham.stop_timing
     stdout.show("Time taken (in sec) ham: ",timer_ham.elapsed_time_s,14)
     !
     ! step 5: calculation of the energy gradient WRT the block
     !         coefficients (if requested)
     !
!     if (calc_gradient) then
     if (.pauli_block_geminals.calc_gradient) then
        !!!
        timer_grad.start_timing
        !!!
        .pauli_block_geminals.calc_energy_gradient
        !!!
        timer_grad.stop_timing
        stdout.show("Time taken (in sec) grad: ",timer_grad.elapsed_time_s,14)
        !!!
     end
     !
     timer.stop_timing
     stdout.text(" ")
     stdout.show("Time taken (in sec) : ",timer.elapsed_time_s,14)
     stdout.show("Time taken : ",timer.elapsed_time5,8)
     stdout.text(" ")
! de

   end

!   do_PBG_energy ::: leaky 
!   ! perform a geminal mean field calculation
!
!   ENSURE(.pauli_block_geminals.created,"no pauli_block_geminals info")
!   ENSURE(.atom.created,"no atom info")
!   ENSURE(.basis_info_made,"no basis info")
!
!     v :: MAT4{REAL}*
!     eri_archive :: ARCHIVE
!     make_integrals, readin_mos :: BIN
!     n_bf, new_n_bf :: INT
!     overlap :: REAL
!     ham :: REAL
!     nb_pauli_blocks,i :: INT
!     S_mat :: MAT{REAL}*
!!     do_electric_dipole :: BIN
!     norm :: REAL
!     timer :: TIME
!     timer_ov :: TIME
!     timer_1rdm :: TIME
!     timer_2rdm :: TIME
!     timer_ham :: TIME
!     gen_routines :: BIN
!     calc_gradient :: BIN
!
!     ! starting calculation of the (electronic) energy
!     stdout.text(" ")
!     stdout.text("==================")
!     stdout.text("Energy calculation")
!     stdout.text("==================")
!
!     n_bf = .n_bf
!
!     ! Ensure 1-electron integrals
!     .INTS:make_overlap_matrix
!     .SCF:make_core_matrix
!
!!     do_electric_dipole = any(.pauli_block_geminals.do_electric_dipole)
!!     if (do_electric_dipole) then
!!        .pauli_block_geminals.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
!!     end
!
!     make_integrals =.pauli_block_geminals.make_integrals
!     readin_mos     =.pauli_block_geminals.readin_mos
!
!
!     if (make_integrals) then
!
!       ! First create the MO integrals on disk
!       v.create(n_bf,n_bf,n_bf,n_bf)
!       .FOCK:make_ERI_integrals(v)
!       .pauli_block_geminals.add_core = TRUE
!
!       new_n_bf = .pauli_block_geminals.mat_size
!       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")
!
!       eri_archive.set(.name,"h_integrals")
!
!       if (readin_mos) then
!
!         stdout.text(" ")
!         if (new_n_bf==n_bf)then
!            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,S_new=S_mat)
!!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
!         else
!            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf,S_new=S_mat)
!!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
!         end
!
!       else
!
!         if (new_n_bf==n_bf)then
!            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core)
!!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
!         else
!            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf)
!!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
!         end
!
!       end
!
!       v.destroy      
!
!       stdout.text(" ")
!       stdout.text("an integral file has been saved on disk")
!       stdout.text(" ")
!
!     else
!
!       stdout.text(" ")
!       stdout.text("using old integral file")
!       stdout.text(" ")
!
!     end
!
!
!! davide: 19-11-2018
!
!     timer.start_timing
!     
!     timer_ov.start_timing
!     ! step 1
!     .pauli_block_geminals.calc_overlap_integral(overlap)
!     !
!     timer_ov.stop_timing
!     stdout.show("Time taken (in sec) ov: ",timer_ov.elapsed_time_s,14)
!     .pauli_block_geminals.overlap = overlap
!     !
!!     if (NOT .pauli_block_geminals.gen_block) then
!!     timer_1rdm.start_timing
!!        ! step 2
!!        .pauli_block_geminals.calc_1rdm
!!        !
!!     timer_1rdm.stop_timing
!!     stdout.show("Time taken (in sec) 1rdm: ",timer_1rdm.elapsed_time_s,14)
!!     timer_2rdm.start_timing
!!        ! step 3
!!        .pauli_block_geminals.calc_2rdm
!!        !
!!     timer_2rdm.stop_timing
!!     stdout.show("Time taken (in sec) 2rdm: ",timer_2rdm.elapsed_time_s,14)
!!     else
!!        ! steps 2 and 3
!!        .pauli_block_geminals.calc_1rdm_gen
!!        .pauli_block_geminals.calc_2rdm_gen
!!        !
!!     end
!     !
!     !
!     gen_routines = (.pauli_block_geminals.gen_block OR .pauli_block_geminals.calc_gradient)
!!     if (.pauli_block_geminals.gen_block) then
!     if (gen_routines) then
!        !
!        ! if 2D-3typ blocks are present or the calculation of the
!        ! gradient is requested (in addition to the energy)
!        !
!!       !!!
!        timer_1rdm.start_timing
!!       !!!
!        ! step 2
!        .pauli_block_geminals.calc_1rdm_gen
!        !
!!       !!!
!        timer_1rdm.stop_timing
!        stdout.show("Time taken (in sec) 1rdm: ",timer_1rdm.elapsed_time_s,14)
!        timer_2rdm.start_timing
!!       !!!
!        ! step 3
!!!!        .pauli_block_geminals.calc_2rdm_gen
!        !!!
!        calc_gradient = FALSE
!        if (.pauli_block_geminals.calc_gradient) then
!           if (.pauli_block_geminals.n_2D_blocks == 0) then
!              calc_gradient = TRUE
!              stdout.text(" ")
!              stdout.text("Calculation of the energy gradient will be performed")
!              stdout.text(" ")
!           else
!              stdout.text(" ")
!              stdout.text("Calculation of the energy derivatives with respect to")
!              stdout.text("the 2D-block coefficients is not implemented yet:")
!              stdout.text("the energy gradient will not be computed")
!              stdout.text(" ")
!           end
!        end
!        !
!        if (calc_gradient) then
!           .pauli_block_geminals.calc_2rdm_gen_grd
!        else
!           .pauli_block_geminals.calc_2rdm_gen
!        end
!        !!!
!        !
!!       !!!
!        timer_2rdm.stop_timing
!        stdout.show("Time taken (in sec) 2rdm: ",timer_2rdm.elapsed_time_s,14)
!!       !!!
!     else
!        !
!        ! if only 2D-4typ blocks are present (in addition to the
!        ! 1D blocks), and the calculation of the gradient is not
!        ! requested
!        !
!!       !!!
!        timer_1rdm.start_timing
!!       !!!
!        ! step 2
!        .pauli_block_geminals.calc_1rdm
!        !
!!       !!!
!        timer_1rdm.stop_timing
!        stdout.show("Time taken (in sec) 1rdm: ",timer_1rdm.elapsed_time_s,14)
!        timer_2rdm.start_timing
!!       !!!
!        ! step 3
!        .pauli_block_geminals.calc_2rdm
!        !
!!       !!!
!        timer_2rdm.stop_timing
!        stdout.show("Time taken (in sec) 2rdm: ",timer_2rdm.elapsed_time_s,14)
!!       !!!
!     end
!     !
!     timer_ham.start_timing
!     ! step 4
!     .pauli_block_geminals.make_hamiltonian(ham) 
!     !
!     timer_ham.stop_timing
!     stdout.show("Time taken (in sec) ham: ",timer_ham.elapsed_time_s,14)
!     timer.stop_timing
!     stdout.text(" ")
!     stdout.show("Time taken (in sec) : ",timer.elapsed_time_s,14)
!     stdout.show("Time taken : ",timer.elapsed_time5,8)
!     stdout.text(" ")
!     !!!
!!     if (.pauli_block_geminals.calc_gradient) then
!     if (calc_gradient) then
!        .pauli_block_geminals.calc_energy_gradient
!     end
!     !!!
!!     stop  
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!     ! generation of a second set of geminals
!!     .pauli_block_geminals.destroy_nonzero_coef
!!     !
!!     .pauli_block_geminals.random_geminals_generator
!!     .pauli_block_geminals.norm_gem
!!     !
!!     stop  
!!     .pauli_block_geminals.set_matrix_form
!!     .pauli_block_geminals.find_nonzero_coef
!!     .pauli_block_geminals.make_int_term_list
!!     !.pauli_block_geminals.calc_overlap_integral
!!
!!     .pauli_block_geminals.calc_overlap_integral(overlap)
!!     .pauli_block_geminals.overlap = overlap
!!     .pauli_block_geminals.calc_1rdm
!!     .pauli_block_geminals.calc_2rdm   
!!     .pauli_block_geminals.make_hamiltonian(ham)  
!!
!!     !stop
!!! de
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   end

   do_PBG_optimization ::: leaky 
   ! perform the optimization of the block coefficients 
   ! of the Pauli block geminals

   ENSURE(.pauli_block_geminals.created,"no pauli_block_geminals info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(.basis_info_made,"no basis info")

     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     make_integrals, readin_mos :: BIN
     n_bf, new_n_bf :: INT
     overlap :: REAL
     ham :: REAL
     nb_pauli_blocks,i :: INT
     S_mat :: MAT{REAL}*
!     do_electric_dipole :: BIN
     norm :: REAL
     timer :: TIME
     timer_ov :: TIME
     timer_1rdm :: TIME
     timer_2rdm :: TIME
     timer_ham :: TIME

     ! starting optimization of block coefficients
     stdout.text(" ")
     stdout.text("==================================")
     stdout.text("Optimization of block coefficients")
     stdout.text("==================================")

     n_bf = .n_bf

     ! Ensure 1-electron integrals
     .INTS:make_overlap_matrix
     .SCF:make_core_matrix

!     do_electric_dipole = any(.pauli_block_geminals.do_electric_dipole)
!     if (do_electric_dipole) then
!        .pauli_block_geminals.spectrum.nuclear_electric_dipole = .BASE:nuclear_dipole_moment
!     end

     make_integrals =.pauli_block_geminals.make_integrals
     readin_mos     =.pauli_block_geminals.readin_mos

     if (make_integrals) then

       ! First create the MO integrals on disk
       v.create(n_bf,n_bf,n_bf,n_bf)
       .FOCK:make_ERI_integrals(v)
       .pauli_block_geminals.add_core = TRUE

       new_n_bf = .pauli_block_geminals.mat_size
       DIE_IF(new_n_bf>n_bf OR new_n_bf<0,"invalid orbital number")

       eri_archive.set(.name,"h_integrals")

       if (readin_mos) then
         stdout.text(" ")
         if (new_n_bf==n_bf)then
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals
         else
            .FOCK:make_read_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf,S_new=S_mat)
!            if (do_electric_dipole) .FOCK:make_read_MO_EDM_integrals(new_n_bf=new_n_bf)
         end
       else
         if (new_n_bf==n_bf)then
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals
         else
            .FOCK:make_MO_ERI_integrals(v,eri_archive,add_core=.pauli_block_geminals.add_core,new_n_bf=new_n_bf)
!            if(do_electric_dipole) .FOCK:make_MO_EDM_integrals(new_n_bf=new_n_bf)
         end
       end

       v.destroy      

       stdout.text(" ")
       stdout.text("an integral file has been saved on disk")
       stdout.text(" ")

     else

       stdout.text(" ")
       stdout.text("using old integral file")
       stdout.text(" ")

     end


! davide: 03-11-2019
     !
     ! call the routine for optimization of block coefficients
     !
     .pauli_block_geminals.optimize_coef
! de

   end

end
