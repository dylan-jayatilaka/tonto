!==================================================================
!
! MOLECULE.TD: Time-dependent procedures
!
! Copyright (C) Dylan Jayatilaka (2024)
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================


module MOLECULE.TD

   implicit none

contains

!  ====
!  CPHF
!  ====

   make_perturbed_densities(D,U,MO,no) ::: leaky. PURE
   ! Make the perturbed densities "D" from the "U" matrices by back
   ! transforming with the "MO" from occupied orbital "no".
      self :: IN
      D :: MAT3{REAL}, OUT
      U :: MAT3{REAL}, IN
      MO :: MAT{REAL}, IN
      no :: INT, optional, IN

   ENSURE(D.dim3==U.dim3,"incompatible D and U")
   ENSURE(D.dim1==.n_bf AND D.dim2==.n_bf,"wrong size, D")
   ENSURE(MO.is_square AND MO.dim1==.n_bf,"wrong size, MO")

      i :: INT

      if (present(no)) then

         ENSURE(no>0,"n_occ must be positive")
         ENSURE(no<=.n_bf,"n_occ must not exceed n_bf")
         do i = 1,U.dim3
            U(:,:,i).back_transform_to(D(:,:,i),MO(:,no+1:),MO(:,1:no))
            D(:,:,i).symmetrize
         end

      else

         do i = 1,U.dim3
            U(:,:,i).back_transform_to(D(:,:,i),MO)
            D(:,:,i).symmetrize
         end

      end

      D = FOUR*D

   end

   set_CPHF_DIIS ::: leaky, PURE
   ! Set up the DIIS archives for a CPHF calculations.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scf data")

      tol :: REAL

      ! Set up DIIS
      tol = .scfdata.SCF_DIIS.convergence_tolerance
      .scfdata.SCF_DIIS.set_defaults
      .scfdata.SCF_DIIS.set_save_iteration(0)
      .scfdata.SCF_DIIS.set_start_iteration(2)
      .scfdata.SCF_DIIS.set_convergence_tolerance(tol)

   end

   solve_CPHF_equations(U,rhs) ::: private
   ! Solve the coupled-perturbed Hartree-Fock (CPHF) equations. The
   ! result is the derivative MO coefficients "U" (virtual-occupied
   ! block) and "rhs" is the right hand side of the CPHF equations
   ! (virtual-occupied block). The convergence tolerance and the
   ! number of iterations are controlled via the scfdata block, since
   ! this is a self consistent procedure.
      self :: INOUT
      U    :: MAT3{REAL}, INOUT
      rhs  :: MAT3{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.MOs.allocated,"no MOs")
   ENSURE(.MOs.r.allocated,"no restricted MOs")
   ENSURE(U.dim1==(.n_bf-.n_a),  "wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,          "wrong size, U, dimension 2")
   ENSURE(rhs.dim1==(.n_bf-.n_a),"wrong size, rhs, dimension 1")
   ENSURE(rhs.dim2==.n_a,        "wrong size, rhs dimension 2")
   ENSURE(U.dim3==rhs.dim3,"incompatible sizes, U and rhs")

      Ev, Eo  :: VEC{REAL}@
      par,err :: VEC{REAL}@
      U_vo       :: MAT3{REAL}@
      U_ao,J,K,W :: MAT{REAL}@
      MOv, MOo   :: MAT{REAL}@
      no,nv,n_pert,n_vo, n :: INT
      tol0,test,delta :: REAL
      use_DIIS :: BIN
      arch :: ARCHIVE

      ! Dimensions
      no = .n_a
      nv = .n_bf - .n_a
      n_vo   = nv*no
      n_pert = U.dim3
      tol0   = TOL(6)

      ! Assign MO's, orbital ranges
      MOv = .MOs.r(:,no+1:  )
      MOo = .MOs.r(:,   1:no) 
      Ev  = .MO_energies.r(no+1:  )
      Eo  = .MO_energies.r(   1:no)

      ! Read/initialize U's
      .:initialize_Us(U,rhs,Ev,Eo,tol0)

      ! Allocate temporaries
      U_vo.create(nv,no,n_pert)
      U_ao.create(.n_bf,.n_bf)
      W.create(nv,no)
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      par.create(n_vo)
      err.create(n_vo)

      ! Use DIIS?
      use_DIIS = .scfdata.using_CP_DIIS

      ! Set initial convergence data/DIIS
      .scfdata.update_CP_difference(ZERO)
      .scfdata.set_DIIS_error(ZERO)
      if (use_DIIS) .scfdata.reset_CP(n_pert)

      ! Banner & tabular output
      .scfdata.put_CP_banner
      .scfdata.put_CP_options
      .scfdata.set_CP_table
      .scfdata.put_CP_table_head
      .scfdata.put_CP_table_body_and_footer

      ! Begin iterations
      do

         U_vo  = U
         test  = ZERO
         delta = ZERO

         ! For each perturbation, update U(:,:,n)
         do n = 1,n_pert

            ! U(MO) -> U(AO)
            U(:,:,n).back_transform_to(U_ao,MOv,Moo)
            U_ao.symmetrize

            ! Make A.U (AO) -> A.U (MO) = W
            .FOCK:make_r_JK_engine(J,K,U_ao)
            U_ao = FOUR*J - TWO*K
            .BASE:remove_dependence_from_r(U_ao)
            U_ao.change_basis_to(W,MOv,Moo)

            ! DIIS extrapolation on AU (MO)
            if (use_DIIS) then
               par = reshape(W,[n_vo])
               W.plus_difference_product_with(U(:,:,n),Ev,Eo,tol0) ! W <- H
               err = reshape(W-rhs(:,:,n),[n_vo])                  ! H - rhs
               .scfdata.CP_DIIS(n).extrapolate(par,err,n_vo)
               W   = reshape(par,[nv,no])                          ! W <- AU
               test = max(test,.scfdata.CP_DIIS(n).error_length)
            end

            ! Update U, U <- (rhs - W)/D
            W = rhs(:,:,n) - W
            U(:,:,n) = ZERO
            U(:,:,n).plus_difference_divisor_with(W,Ev,Eo,tol0)    ! W <- H

         end
           
         ! Delta is max |diff|
         delta = max(delta,maxval(abs(U-U_vo)))

         ! Update data
         .scfdata.update_iteration
         .scfdata.update_DIIS_from_CP_DIIS
         .scfdata.update_CP_difference(delta)
         .scfdata.SCF_DIIS.set_error_length(test)
         .scfdata.set_DIIS_error(test)

         ! Put table
         .scfdata.put_CP_table_body_and_footer(flush=TRUE)

         ! Write archive for restart
         arch.set(.name,"U_electric_dipole",genre="r")
         arch.write(U)

         if (.scfdata.SCF_done) exit

      end ! iterative cycle

      ! Clean-up
      .scfdata.SCF_DIIS.destroy_ptr_part
      .scfdata.CP_DIIS.destroy
      err.destroy
      par.destroy
      K.destroy
      J.destroy
      W.destroy
      U_ao.destroy
      U_vo.destroy

   end

   initialize_Us(U,rhs,Ev,Eo,tol0) ::: private
   ! Initialize the U matrices
      self :: INOUT
      U    :: MAT3{REAL}, OUT
      rhs  :: MAT3{REAL}, IN
      Ev   :: VEC{REAL}, IN
      Eo   :: VEC{REAL}, IN
      tol0 :: REAL, IN

      arch :: ARCHIVE
      n :: INT

      if (.scfdata.initial_Us=="r") then

         ! Read or calculate initial approximation for U
         stdout.flush
         stdout.text("As requested from scfdata, reading U's from disk ...")
         arch.set(.name,"U_electric_dipole",genre="r")
         arch.read(U)

      else

         ! Set SOS initial guess
         U = ZERO
         do n = 1,U.dim3
            U(:,:,n).plus_difference_divisor_with(rhs(:,:,n),Ev,Eo,tol0)
         end

      end

   end

!   make_A_times_U(AU,U) ::: private
!   ! Make the full A times U matrix in the MO basis
!      self :: INOUT
!      AU :: MAT3{REAL}, OUT
!      U  :: MAT3{REAL}, IN
!
!   ENSURE(.scfdata.allocated,"no scf data")
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.allocated,"no atom info")
!   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
!   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
!   ENSURE(AU.dim1==.n_bf,"wrong size, AU")
!   ENSURE(AU.dim2==.n_bf,"wrong size, AU")
!   ENSURE(U.dim3==AU.dim3,"incompatible sizes, U and AU")
!
!      U_ao,J,K :: MAT{REAL}@
!      MOv, MOo :: MAT{REAL}@
!      n :: INT
!
!      U_ao.create(.n_bf,.n_bf)
!      J.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!
!      MOv = .MOs.r(:,.n_a+1:)
!      MOo = .MOs.r(:,:.n_a) 
!
!      do n = 1,U.dim3
!         U(:,:,n).back_transform_to(U_ao,Mov,MOo)
!         U_ao.symmetrize                   ! U -> AO basis
!         .FOCK:make_r_JK_direct(J,K,U_ao)  ! A times U (INOUT)
!         AU(:,:,n) = FOUR*J - TWO*K
!         AU(:,:,n).change_basis_using(.MOs.r)
!      end
!
!      ! Clean
!      K.destroy
!      J.destroy
!      U_ao.destroy
!
!,   end

   add_A_times_U(AU,U) ::: private
   ! Add the full A matrix times the full U matrix to "AU". "U" is the
   ! virtual-occupied block of the full U matrix.
      self :: INOUT
      AU :: MAT3{REAL}, OUT
      U  :: MAT3{REAL}, IN

   ENSURE(.scfdata.allocated,"no scf data")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom info")
   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
   ENSURE(AU.dim1==.n_bf,"wrong size, AU")
   ENSURE(AU.dim2==.n_bf,"wrong size, AU")
   ENSURE(U.dim3==AU.dim3,"incompatible sizes, U and AU")

      J,K,W :: MAT{REAL}@
      MOv, MOo :: MAT{REAL}@
      n :: INT


      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      W.create(.n_bf,.n_bf)

      MOv = .MOs.r(:,.n_a+1:)
      MOo = .MOs.r(:,:.n_a) 

      do n = 1,U.dim3
         U(:,:,n).back_transform_to(W,MOv,MOo)
         W.symmetrize                  ! U -> AO basis
         .FOCK:make_r_JK_direct(J,K,W) ! INOUT
         W = FOUR*J - TWO*K            ! W = A times U
         W.change_basis_using(.MOs.r)
         AU(:,:,n) = AU(:,:,n) + W
      end

      ! Clean
      W.destroy
      K.destroy
      J.destroy

   end

!  ===============
!  Davidson solver
!  ===============

   test_MGS_QR
   ! Test orthogonalisation routines for Davidson diagonaliser.
      self :: INOUT

      V, Q, R :: MAT{REAL}@
      dim     :: INT
      n_keep  :: INT

      ! Sizes
      dim    = 10 
      n_keep =  5

      ! Number Davidson vectors to keep.
      V.create(dim,n_keep)

      ! Initial
      call random_number(V)

      stdout.text("V:")
      stdout.put(V)

      Q.create(dim,n_keep)
      R.create(n_keep,n_keep)

      V.modified_Gram_Schmidt_QR(Q,R)

      stdout.flush
      stdout.text("========================")
      stdout.text("modified Gram-Schmidt QR")
      stdout.text("========================")
      stdout.flush

      stdout.text("Q:")
      stdout.put(Q)

      stdout.text("Q^T Q:")
      stdout.put(matmul(transpose(Q),Q))

      stdout.text("R:")
      stdout.put(R)

      stdout.text("QR - V:")
      stdout.put(matmul(Q,R) - V)

      stdout.flush
      stdout.text("==============")
      stdout.text("Householder QR")
      stdout.text("==============")
      stdout.flush

      V.Householder_QR(Q,R)

      stdout.text("Q:")
      stdout.put(Q)

      stdout.text("Q^T Q:")
      stdout.put(matmul(transpose(Q),Q))

      stdout.text("R:")
      stdout.put(R)

      stdout.text("QR - V:")
      stdout.put(matmul(Q,R) - V)

   end

   test_Davidson_CPS_6
   ! Test the Davidson algorithm with the example in section 6 of
   ! Crouzeix et al (2006) Inria RR 1353
      self :: INOUT

      A    :: MAT{REAL}@
      evec :: MAT{REAL}@
      eval :: VEC{REAL}@
      d, n_eig,n_keep,maxit, i,j :: INT

      ! Sizes
      d = 30
      n_eig  = 2
      n_keep = 8 
      maxit  = 50

      ! Set up
      A.create(d,d)
      eval.create(d)
      evec.create(d,d)

      A = ZERO
      do i = 1,d
         A(i  ,i  ) = i
         if (i>1) then
            A(i-1,i  ) = HALF
            A(i  ,i-1) = HALF
         end
         if (i<d) then
            A(i+1,i  ) = HALF
            A(i  ,i+1) = HALF
         end
      end
      A(1,d) = HALF
      A(d,1) = HALF

      stdout.flush
      stdout.text("===========")
      stdout.text("Jacobi eigs")
      stdout.text("===========")
      stdout.flush

      A.diagonalize_Jacobi(eval,evec)

      stdout.flush
      stdout.text("eval:")
      stdout.put(eval(1:n_eig))

      stdout.text("evec:")
      stdout.put(evec(:,1:n_eig))

      eval.destroy
      evec.destroy

    ! A.diagonalize_Davidson(eval,evec,n_eig,n_keep,maxit,tolconv=TOL(7))
      .TD::diagonalize_Davidson(A,eval,evec,n_eig,n_keep,maxit,tolcon=TOL(7))

      stdout.flush
      stdout.text("===============")
      stdout.text("Davidson test 6")
      stdout.text("===============")
      stdout.flush

      stdout.flush
      stdout.text("eval:")
      stdout.put(eval)

      stdout.flush
      stdout.text("evec:")
      stdout.put(evec)

      stdout.flush
      stdout.text("evec^T evec:")
      stdout.put(matmul(transpose(evec),evec))

   end

   diagonalize_Davidson(A,eval,evec,n_eig,n_keep,maxit,tolcon)
   ! Davidson diagonaliser for matrix "A".
   ! See Crouzeix et al (2006) Inria RR 1353
   ! Step numbers & symbols below mostly from p. 5 Crouzeix.
      A :: MAT{REAL}, IN
      eval   :: VEC{REAL}@, OUT ! The "n" eigenvalues
      evec   :: MAT{REAL}@, OUT ! The "n" eigenvector columns
      n_eig  :: INT, IN         ! No. of eigenvalues wanted, "n"
      n_keep :: INT, OUT        ! No. of trial vector sets kept
      maxit  :: INT, IN         ! Max. no. of iterations allowed
      tolcon :: REAL, IN        ! Max. residual vec norm, to end

   ENSURE(n_keep>=3,"Must store minimum 2+1=3 trial vector sets")

      R :: MAT{REAL}@     ! Ritz vectors <- becomes "evec"
      V :: MAT{REAL}@     ! V(:,n)       <- the Davidson trial vectors
      W :: MAT{REAL}@     ! W(:,n)       <- A.V
      H :: MAT{REAL}@     ! A            <- in basis "V"
      T   :: VEC{REAL}@   ! New direction, T
      rvl :: VEC{REAL}@   ! Length of the residual vectors
      iter,n_tr :: INT
      d,n,f,l,i :: INT
      converged :: BIN
      too_many  :: BIN
      collapse  :: BIN
      bot :: REAL

      ! Sizes
      d = A.dim1            ! "d" could be big!
      n = n_eig             ! Usually n << d

      ! Best vectors
      R.create(d,n)         ! Will be "evec"
      eval.create(n*n_keep) ! Will shrink to "n"

      ! Residue vector length
      rvl.create(n) 

      ! Davidson vectors "V"
      V.create(d,n*n_keep)  ! Need all in memory???
      W.create(d,n*n_keep)  ! Space for product A*V, worst case
      T.create(d)           ! Space for new directions

      stdout.flush
      stdout.text("=====================")
      stdout.text("Davidson diagonalizer")
      stdout.text("=====================")
      stdout.flush
      stdout.show("Dimension of matrix            ",d)
      stdout.show("No. of eigenvalues wanted      ",n)
      stdout.show("Max. trial vector sets kept + 1",n_keep)
      stdout.show("Max. no. of iterations         ",maxit)
      stdout.show("Tolerance for convergence      ",tolcon)

      ! Initialize
      V.to_unit_mx          ! Initial guess
      iter = 0              ! Overall iteration count
      n_tr = 0              ! No. of trial vector sets
      converged = FALSE
      too_many  = FALSE

      do 

         ! Iteration & no. of trial vector sets (-1)
         iter = iter + 1
         n_tr = n_tr + 1

         ! First & last trial vector columns
         l = n*(n_tr-1)
         f = l + 1
         l = l + n

         ! 1. Expensive step, extends W
         ! Replace with low-mem matrix product
         W(:,f:l) = matmul(A,V(:,f:l))

         ! 2. Expand Rayleigh matrix
         H.expand(l,l)
         evec.create(l,l)
         H(f:l,:) = matmul( transpose(V(:,f:l)) , W(:,1:l) )
         H.symmetric_reflect(set_upper=TRUE)

         ! 3. Diagonalise (increasing eigenvalues)
         H.diagonalize_Jacobi(eval(1:l),evec)

         ! 4. Lowest Ritz vectors
         R = matmul(V(:,1:l),evec(:,1:n))

         ! Too many iters? Collapse space?
         too_many = iter>maxit; if (too_many) exit 
         collapse = n_tr==n_keep

         stdout.flush
         stdout.text("=========")
         stdout.show("iter      ",iter)
         stdout.show("n_tr      ",n_tr)
         stdout.show("collapse? ",collapse)
         stdout.show("too many? ",too_many)
         stdout.show("f         ",f)
         stdout.show("l         ",l)

         if (too_many) then

            ! Save to disk?
            evec.destroy
            H.destroy

         else if (collapse) then

            ! Restart with Ritz vector
            n_tr = 0
            V(:,1:n) = R
          ! V(:,1:n).Householder_QR ! Needed?

            ! Note: clean both
            evec.destroy
            H.destroy

         else 

            ! 5-7. Get residual & new direction T, per-column
            do i = 1,n
        
               ! 5. Residual T & its length
               T = eval(i)*R(:,i) - matmul(W(:,1:l),evec(:,i)) 
               rvl(i) = norm2(T)
        
               ! 6. Precondition
               bot = eval(i) - H(i,i)
               if (abs(bot) < 0.001d0) bot = bot + TOL(2)
               bot= ONE/bot

               ! 7a. Set new direction t
               V(:,l+i) = bot*T
        
            end

         stdout.flush
         stdout.show("conv      ",maxval(abs(rvl)))
         stdout.flush
         stdout.text("eval:")
         stdout.put(eval(1:n))
        
            ! Finished?
            converged = all(rvl<tolcon); if (converged) exit
          
            ! 7. Orthonormalize vectors V
            V(:,1:l+n).modified_Gram_Schmidt_QR
          ! V(:,1:l+n).Householder_QR 
        
            ! Clean up
            evec.destroy

         end

      end

      ENSURE(converged,"No convergence")
      ENSURE(NOT too_many,"Too many iterations")

      ! Clean up
      evec.destroy
      H.destroy
      T.destroy
      W.destroy
      V.destroy
      rvl.destroy

      ! Recover solution
      call move_alloc(R,evec)
      eval.shrink(n)

   end

!  ===================================
!  Two-electron integrals for checking
!  ===================================

   make_VOVO_ERIs(v)
   ! Calculate the VOVO electron repulsion integrals (ERI's) from the
   ! AO integrals
      self :: IN
      v :: MAT4{REAL}, OUT

      MO :: MAT{REAL}@
      a,b,c,d :: INT

      MO = .MOs.r

      v = ZERO
      .:make_ERI_integrals(v)

      do a = 1,.n_bf
         v(a,a,:,:).change_basis_using(MO)
         do b = 1,a-1
            v(a,b,:,:).change_basis_using(MO)
            v(b,a,:,:) = v(a,b,:,:)
         end
      end

      do c = 1,.n_bf
         v(:,:,c,c).change_basis_using(MO)
         do d = 1,c-1
            v(:,:,c,d).change_basis_using(MO)
            v(:,:,d,c) = v(:,:,c,d)
         end
      end

      MO.destroy

   end

end
