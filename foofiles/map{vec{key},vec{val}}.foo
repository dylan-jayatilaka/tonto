!---------------------------------------------------------------------------
!
! MAP{VEC{KEY},VEC{VAL}} : 
!
! This is a virtual module.
!
! A map (or associative array) with VEC{KEY} keys and VEC{VAL} values.
!
! Copyright (C) Dylan Jayatilaka, 2002
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
! 
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
! 
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

virtual module MAP{VEC{KEY},VEC{VAL}}

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   create(n_size,keydim,valdim) ::: leaky, PURE
   ! Create the map with key array and value array with length
   ! "n_size".  The dimension of each key is "keydim". The dimension
   ! of each values is "valdim"
      self :: allocatable, OUT
      n_size,keydim,valdim :: INT, IN

      .create

      .n_keys = 0
      .n_size = n_size

      .keys.create(keydim,n_size)
      .values.create(valdim,n_size)

   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts
      self :: INOUT

      .keys.destroy
      .values.destroy

   end

!  ===
!  Set
!  ===

   set_defaults ::: PURE
   ! Set defaults
      self :: INOUT

      .n_keys = 0
      .n_size = 0
      .reverse_search = FALSE

   end

   set_reverse_search(value) ::: PURE
   ! Set the .reverse_search switch to "value". This determines
   ! whether the search through the keys arrays occurs in reverse
   ! order, which may be useful if you know that the most recent keys
   ! added are more likely to contain the values you are looking for.
      self :: INOUT
      value :: BIN, IN

      .reverse_search = value

   end

!  ======================
!  Resize, append, delete
!  ======================

   shrink ::: leaky, PURE
   ! Shrinks the size of the keys and values arrays to dimension
   ! ".n_keys", *only* when ".n_size" is bigger than the number of
   ! keys stored.  Contents are retained. This is used to save memory.
      self :: INOUT

   ENSURE(.n_size>0,"size of map is 0")

      if (.n_size<=.n_keys) return

      .shrink(.n_keys)

   end

   shrink(n_size) ::: leaky, PURE
   ! Shrinks the size of the keys and values arrays to dimension
   ! "n_size".  Contents are retained, where possible.
      self :: INOUT
      n_size :: INT, IN

   ENSURE(.n_size>0,"size of map is 0")

      .n_keys = min(.n_keys,n_size) ! ???

      .n_size = n_size ! ???

      .keys.shrink_columns(n_size)
      .values.shrink_columns(n_size)

   end

   expand(n_size) ::: leaky, PURE
   ! Expands the size of the keys and values arrays to dimension
   ! "n_size".  Contents are retained.  
      self :: INOUT
      n_size :: INT, IN

   ENSURE(n_size>.n_size,"keys is already big enough")
   ENSURE(n_size>0,"keys and values not created")

      .n_size = n_size

      .keys.expand_columns(n_size)
      .values.expand_columns(n_size)

   end

   resize(n_size) ::: leaky, PURE
   ! Resize the size of the keys and values arrays to dimension
   ! "n_size".  Contents are retained.  
      self :: INOUT
      n_size :: INT, IN

      .n_size = n_size

      if(n_size>.n_size) then
         .expand(n_size)
      else if(n_size<.n_size) then
         .shrink(n_size)
      end

   end

   append_pair(key,value) ::: leaky, PURE
   ! Append the "key" and the corresponding "value" to the map table.
   ! If the .keys or .values arrays are too small, they are doubled in size.
      self :: INOUT
      key :: VEC{KEY}, IN
      value :: VEC{VAL}, IN

      n :: INT

      n = .n_keys + 1

      if (n<=0) return
      if (n>.n_size) .expand(2*n)

      .n_keys = n

      .keys(:,n)   = key
      .values(:,n) = value

   end

   set(key,value) ::: leaky, PURE
   ! Append the "key" and the corresponding "value" to the map table.
   ! If the .keys or .values arrays are too small, they are doubled in
   ! size.
      self :: INOUT
      key :: VEC{KEY}, IN
      value :: VEC{VAL}, IN

      .append_pair(key,value)

   end

   append_pairs(keys,values) ::: leaky, PURE
   ! Append the "keys" and the corresponding "values" to the map
   ! table.  If the .keys or .values arrays are too small, they are
   ! doubled in size.
      self :: INOUT
      keys :: MAT{KEY}, IN
      values :: MAT{VAL}, IN

   ENSURE(keys.dim2==values.dim,"keys and values must have same length")

      new,f,l :: INT

      new = keys.dim2

      if (.n_keys+new>.n_size) .expand(2*(.n_keys+new))

      f = .n_keys + 1
      l = .n_keys + new

      .n_keys = l

      .keys(:,f:l) = keys
      .values(:,f:l) = values

   end

   set(keys,values) ::: leaky, PURE
   ! Append the "keys" and the corresponding "values" to the map
   ! table.  If the .keys or .values arrays are too small, they are
   ! doubled in size.
      self :: INOUT
      keys :: MAT{KEY}, IN
      values :: MAT{VAL}, IN

   ENSURE(keys.dim2==values.dim,"keys and values must have same length")

      .append_pairs(keys,values)

   end

   delete(key,has_key) ::: PURE
   ! Delete the "key" and the corresponding "value" from the map
   ! table.  A fatal error occurs if the "key" is not there, unless
   ! "has_key" is present.  If it is present, "has_key" is set to TRUE
   ! if element *was* there (after the delete operation it is not
   ! there!), otherwise it is set false.  There is no change made to
   ! the size of the map table.
      self :: INOUT
      key :: VEC{KEY}, IN
      has_key :: BIN, optional, OUT

   ENSURE(NOT (.index_of_key(key)<=0 AND NOT present(has_key)), "has_key must be present when key does not occur")

      i :: INT

      i = .index_of_key(key)

      if (i>0) then

         if (present(has_key)) has_key = TRUE
         .delete_item(i)

      else

         if (present(has_key)) has_key = FALSE

      end

   end

   delete_item(index) ::: PURE
   ! Delete element "index" from the map table.  No change is made to
   ! the size of the map table.
      self :: INOUT
      index :: INT, IN

   ENSURE(index>0,"index must be positive")
   ENSURE(index<=.n_keys,"index must be less than number of keys")

      i,n :: INT

      i = index
      n = .n_keys - 1

      .keys(:,i:n) = .keys(:,i+1:.n_keys)
      .values(:,i:n) = .values(:,i+1:.n_keys)

      .n_keys = n

   end

   delete_items(list) ::: PURE
   ! Delete elements "list" from the map table.  No change is made to
   ! the size of the map table.
      self :: INOUT
      list :: VEC{INT}, IN

   ENSURE(all(list>0),"list elements must be positive")
   ENSURE(all(list<=.n_keys),"list elements must be less than number of keys")

      k,i0,i1,k0,k1,n :: INT
      indx :: VEC{INT}@

      indx = list
      indx.quick_sort

      i1 = indx(1) - 1

      do k = 1,indx.dim-1

         k0 = indx(k) 
         k1 = indx(k+1) 
         
         n  = k1 - k0 - 1
         i0 = i1 + 1
         i1 = i1 + n
         
         if (n<=0) cycle
         
         ! stdout.text(trim(i0.to_str)//"-"//trim(i1.to_str)// &
         !     " <- "//trim((k0+1).to_str)//"-"//trim((k1-1).to_str))
         
         .keys(:,i0:i1)   = .keys(:,k0+1:k1-1)
         .values(:,i0:i1) = .values(:,k0+1:k1-1)

      end

        k0 = indx(indx.dim) 

        n  = .n_keys - k0
        i0 = i1 + 1
        i1 = i1 + n

        ! stdout.text(trim(i0.to_str)//"-"//trim(i1.to_str)// &
        !     " <- "//trim((k0+1).to_str)//"-"//trim(.n_keys.to_str))

        if (n>0) then
        .keys(:,i0:i1)   = .keys(:,k0+1:)
        .values(:,i0:i1) = .values(:,k0+1:)
        end

      .n_keys = .n_keys - indx.dim

   end

!  ===================
!  Search and retrieve
!  ===================

   index_of_key(key) result (res) ::: PURE
   ! Returns the index of any key which matches "key" in the map. If
   ! there is no match, then the result is 0.
      self :: IN
      key :: VEC{KEY}, IN
      res :: INT

      i :: INT

      res = 0

      if (.reverse_search) then

         do i = .n_keys,1,-1
            if (any(key/=.keys(:,i))) cycle
            res = i
            exit
         end

      else

         do i = 1,.n_keys
            if (any(key/=.keys(:,i))) cycle
            res = i
            exit
         end

      end

   end

   has_key(key,index) result (res)
   ! Returns TRUE if the map contains a specific "key". If present,
   ! "index" is set to the index of that key.
      key :: VEC{KEY}, IN
      index :: INT, optional, OUT
      res :: BIN

      i :: INT

      i = .index_of_key(key) 

      res = i > 0

      if (present(index)) index = i

   end

   value_for_key(key,has_key,index) result (res)
   ! Returns the value corresponding to the map "key". If "has_key" is
   ! not present, an error is generated if no matching "key" can be
   ! found in the map; if it is present, it is set to TRUE if the the
   ! key is present, or FALSE otherwise. If "index" is present, then
   ! it is set to the value of the index of "key" in the map table.
      self :: IN
      key :: VEC{KEY}, IN
      has_key :: BIN, optional, OUT
      index :: INT, optional, OUT
      res :: VEC{VAL}(size(.values,1))

   ENSURE(NOT (.index_of_key(key)<=0 AND NOT present(has_key)), "has_key must be present when key does not occur")

      i :: INT

      i = .index_of_key(key)

      if (i>0) then

        if (present(has_key)) has_key = TRUE
        res = .values(:,i)

      else

        if (present(has_key)) has_key = FALSE

      end

      if (present(index)) index = i

   end

   value_for_item(index) result (res)
   ! Returns the "index"-th element in the map table. 
      self :: IN
      index :: INT, IN
      res :: VEC{VAL}(size(.values,1))

   ENSURE(index<=.n_keys,"index out of range")
   ENSURE(index>0,"index out of range")

      res = .values(:,index)

   end
      
end 
