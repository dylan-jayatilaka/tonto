!==================================================================
!
! MOLECULE.XTAL: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================

module MOLECULE.XTAL

   implicit none

contains

!  ========
!  Read CIF
!  ========

   read_CIF ::: leaky
   ! Read in CIF information, reset name of job to cif file name
      self :: INOUT

      if (.cif.deallocated) .cif.create

      .cif.read_keywords
      .cif.update

   end

   read_CIF_atoms(cif) ::: leaky
   ! Read atom position covariances, and pisitions from a "cif", and
   ! reset and bond lengths, and *if* the crystal is there, make
   ! crystal fragment atom info.
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Open the CIF
      if (NOT cif.file.is_open) cif.open

      ! Read covariances from refinement?
      ! Make sure to read refinement settings
      .XTAL:read_CIF_covariances(cif)

      ! Read in the atoms. No bond length reset.
      .XTAL:read_CIF_atoms_only(cif)

      ! Only continue if there are some atoms ...
      if (.crystal.deallocated) return

      ! Set cartesian atom and crystal info. 
      ! Bond lengths may be reset in here.
      .XTAL:reset_CIF_atoms_and_crystal(cif)

      ! Make the esds (if covariances were read)
      .XTAL:read_CIF_crystal_esds(cif)

   end

   read_CIF_atoms_only(cif) ::: leaky
   ! Read atom info from a "cif". Do not reset bond lengths.
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Open the CIF
      if (NOT cif.file.is_open) cif.open

      ! Clean up any old atoms
      .atom.destroy

      ! Read the atoms from the CIF & set covariances
      .atom.read_CIF(cif)

      ! Set defaults and bases
      .spin_multiplicity = .INQ:default_spin_multiplicity

      ! Finalize
      .BASE:update_atom_and_basis_info

      ! Finalize this, maybe
      .XTAL:update_CIF_atom_pADPs

      if (.crystal.allocated) then
         .crystal.asymmetric_unit_source = "from-cif"
      end

   end

   update_CIF_atom_pADPs ::: leaky, private
   ! Update any pADPs for the atoms in the light of any *new* crystal
   ! information.
      self :: INOUT

      ! Set the atom covariances (for errors)
      ! This is for cartesian cif2 only
      if (.crystal.allocated) then
      if (.crystal.xray_data.allocated) then
      if (.crystal.xray_data.fragment_covariance_mx.allocated) then
         .atom.set_pADP_errors_to(.crystal.xray_data.fragment_covariance_mx,H_U_iso=FALSE)
      end
      end
      end

   end

   read_CIF_covariances(cif) ::: private, leaky
   ! Read the CIF covariances and set pADP esds.
   ! This routine gets the no. of pADPs from the (square root) of the
   ! length of the covariance matrices.
   ! NOTE: covariances assumed to only be in CIF2 (cartesian) files
   ! NOTE: this is not enough, we need to read refinement settings to
   !       get the nPADPs (number of refined parameters) correct.
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      label :: STR
      fcov_there,fcov_inputted :: BIN
      acov_there,acov_inputted :: BIN

      ! Basic sanity
      if (NOT cif.use_CIF2) return
      if (.crystal.deallocated) return
      if (.crystal.xray_data.deallocated) return

      ! If covariances already there, assume they are OK
      acov_there = .crystal.xray_data.covariance_mx.allocated
      fcov_there = .crystal.xray_data.fragment_covariance_mx.allocated
      if (acov_there AND fcov_there) return

      ! Open the CIF if needed
      if (NOT cif.file.is_open) cif.open

      ! Below needs to be modified to remove duplicate looped
      ! item search when blank-labelled covariance is not needed

      ! Asymmetric covariance there?
      label = "_asym_unit"
      cif.find_item(trim(label)//"_covariance_mx",acov_there)

      acov_inputted = FALSE

      if (acov_there) then
         ! Read it: Should we be creating x_ray_data?
         if (.crystal.xray_data.deallocated) .crystal.xray_data.create
         cif.read_CIF_covariance(trim(label),.crystal.xray_data.covariance_mx)
         acov_inputted = TRUE
      end

      ! Fragment covariance there?
      label = "_fragment"
      cif.find_looped_item(trim(label)//"_covariance_mx",fcov_there)

      fcov_inputted = FALSE

      if (fcov_there) then
         ! Read it
         if (.crystal.xray_data.deallocated) .crystal.xray_data.create
         cif.read_CIF_covariance(trim(label),.crystal.xray_data.fragment_covariance_mx)
         fcov_inputted = TRUE

    ! else if (acov_there) then
    !    ! Read it
    !    if (.crystal.xray_data.deallocated) .crystal.xray_data.create
    !    .set_frag_from_asym_cov_mx

      end

   end

   read_CIF_crystal(cif) ::: leaky
   ! Read crystal unit cell and spacegroup information (but NOT atom
   ! positions) from a CIF file called "cif", and then produce the
   ! atom and crystal informational arrays.
   ! NOTE: only to be called after reading .atom's from the CIF,
   ! see the routine below.
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Read in the only crystal information
      .XTAL:read_CIF_crystal_only(cif)

      ! Only continue if there are some atoms ...
      if (.atom.deallocated) return

      ! Update
      .XTAL:update_CIF_crystal_atoms(cif)

   end

   read_CIF_crystal_only(cif) ::: leaky
   ! Read from a "cif" crystal unit cell and spacegroup information,
   ! and any covariance matrices from a refinement -- but *NOT* atom
   ! positions. 
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Create the crystal; it shouldn't really exist beforehand
      WARN_IF(.crystal.allocated,"crystal data already defined!")
      if (.crystal.deallocated) .crystal.create

      ! Read in the crystal from the CIF
      .crystal.read_CIF_spacegroup_and_cell(cif)

      ! Read covariances from refinement?
      ! Make sure they are inputed there.
      .XTAL:read_CIF_covariances(cif)

   end

   update_CIF_crystal_atoms(cif) ::: leaky
   ! Update the any hydrogen-atom bond lengths and remake
   ! any crystal fragmemnt_atom info.
   ! NOTE: only to be called after reading .atom's from the CIF
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Only continue if there are some atoms ...
      if (.atom.deallocated) return

      ! Set cartesian atom and crystal info. 
      ! Bond lengths may be reset in here.
      .XTAL:reset_CIF_atoms_and_crystal(cif)

      ! Make the esds (if covariances were read)
      .XTAL:read_CIF_crystal_esds(cif)

   end

   read_CIF_crystal_esds(cif) ::: leaky, private
   ! Read the CIF covariances and set pADP esds.
      self :: INOUT
      cif :: CIF, INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      fcov_there :: BIN
      acov_there :: BIN

      if (.crystal.deallocated) return
      if (.crystal.xray_data.deallocated) return

      ! Open the CIF if needed
      if (NOT cif.file.is_open) cif.open

      acov_there = .crystal.xray_data.covariance_mx.allocated
      fcov_there = .crystal.xray_data.fragment_covariance_mx.allocated

      if (fcov_there) then
      if (acov_there) then
      if (.crystal.fragment_atom.allocated) then
       ! .crystal.set_frag_from_asym_cov_mx
         .crystal.set_fragment_esds(.crystal.fragment_atom)
         .crystal.set_fragment_esds(.atom) 
      end
      end
      end

   end

   reset_CIF_atoms_and_crystal(cif) ::: private, leaky
   ! Set the atom and crystal fragment_atom info.
   ! If requested in cif= { ... }, reset H atom bond lengths.
      self :: INOUT
      cif :: CIF, IN

   ENSURE(.atom.allocated,"no atoms")

      H_bond_length :: VEC{REAL}@
      has_Hs,reset :: BIN

      ! Is crystal there?
      if (.crystal.deallocated) return
      if (NOT .crystal.spacegroup.analyzed) return

      ! Must be cartesian
      .SET:resolve_axis_system

      if (.atom.has_all_Hs_single_bonded(has_Hs)) then

         ! Reset H bond lengths the simple way.
         ! If disordered, the disordered atoms must
         ! be proximate to their bonded neighbours.
         if (has_Hs) then
         if (cif.apply_bond_length) then 
            if (cif.apply_BH_bond_length) .atom.set_bond_lengths(5,1,cif.BH_bond_length)
            if (cif.apply_CH_bond_length) .atom.set_bond_lengths(6,1,cif.CH_bond_length)
            if (cif.apply_NH_bond_length) .atom.set_bond_lengths(7,1,cif.NH_bond_length)
            if (cif.apply_OH_bond_length) .atom.set_bond_lengths(8,1,cif.OH_bond_length)
            .crystal.destroy_asymmetric_unit
         end
         end

      else

         ! There are floating hydrogens or multiple bonded H's ...
         ! Uses the crystal to reset the hydrogen bond lengths.
         ! Uses UC conn. table to skip multiple-bonded H atoms.
         H_bond_length.create(5,8)
         H_bond_length(5) =  cif.BH_bond_length
         H_bond_length(6) =  cif.CH_bond_length
         H_bond_length(7) =  cif.NH_bond_length
         H_bond_length(8) =  cif.OH_bond_length

         ! Remake fragment data?
         .crystal.reset_H_bond_lengths_in(.atom,H_bond_length,reset)
         H_bond_length.destroy

         ! Return if nothing was done
         if (NOT reset AND .crystal.asymmetric_unit_atom.allocated) then
            return
         end

         if (.atom.has_disorder) then
            WARN("DISORDERED ASYMMETRIC CELL MAY BE PRUNED")
            WARN("SOME ATOM INFORMATION MAY BE LOST")
         end

         .crystal.destroy_asymmetric_unit

      end

      ! Re-analyze the fragment symmetry information
      ! Maybe not all things in here need doing again ...
      .crystal.update_fragment_info(.atom)

      ! Finalize atoms & groups as well
      .BASE:update_atom_and_basis_info

   end

!   create_cluster_mol ::: leaky, public
!   ! Create a new "self" by generating a real molecular cluster from
!   ! information stored in .cluster information object.  The original
!   ! molecule replaced by the m-th molecular fragment in the .cluster
!   ! object.
!      self :: IN
!
!      mol :: MOLECULE
!      m :: INT
!
!      stdin.read(m)
!
!      .XTAL:create_cluster_mol(m, mol)
!
!   end

!   create_cluster_mol(m, mol) ::: leaky, public
!   ! Create a new "self" by generating a real molecular cluster from
!   ! information stored in .cluster information object.  The original
!   ! molecule replaced by the defragmented cluster, while the m-th
!   ! molecular fragment in the .cluster is in mol
!   ! -- This routine does not make sense, it does two unrelated things
!   ! -- dylan
!   ! OK - it seems to generate all molecules in a cluster, but it
!   ! keeps re-making the cluster, which is very wasteful, so that was
!   ! confusing ... can be easily fixed by factoring that part out of
!   ! this routine. -- remove for now ...
!      self :: allocatable, INOUT
!      m    :: INT, IN
!      mol  :: MOLECULE, OUT
!
!   ENSURE(.crystal.allocated,"no crystal data")
!   ENSURE(.cluster.allocated,"no cluster data")
!   ENSURE(.cluster.info_made,"no cluster data")
!
!      stdout.flush
!      stdout.text("Expanding cluster, creating molecule m = "//trim(m.to_str))
!
!      ! Destroy previously saved molecule
!      ! (In case this is in a loop)
!
!      ! Reset .atom list to molecule m
!      .atom.destroy
!      .cluster.create_atom_list(.atom)
!
!      ! Finalize basis on new .atom list
!      .BASE:update_atom_and_basis_info
!
!      ! Make new crystal mapping info for this fragment
!      .crystal.update_fragment_info(.atom)
!
!      ! Save this molecule & get a clean new molecule
!      .SET:set_molecule_from_atom_group(m, mol) ! NOT PURE
!
!      ! If a CIF exists, copy that
!      if (.cif.allocated) mol.cif = .cif
!
!      ! Saved crystal is the same
!      mol.crystal = .crystal
!      mol.cluster = .cluster
!      mol.crystal.update_fragment_info(mol.atom)
!
!   end

!   create_HS_cluster ::: leaky
!   ! Create a cluster from the molecules which touch the Hirshfeld
!   ! surface in isosurface. It is assumed there is a .saved.cluster
!   ! and that the current .atom's correspond to it (i.e. this is
!   ! called after a standard HS job).
!      self :: PTR
!
!   ENSURE(.saved.crystal.allocated,"no crystal data")
!   ENSURE(.saved.cluster.allocated,"no cluster data")
!   ENSURE(.saved.cluster.info_made,"no cluster data")
!   ENSURE(.saved.atom.allocated,"no atoms")
!   ENSURE(.atom.allocated,"no atoms")
!   ENSURE(.isosurface.allocated,"no isosurface")
!
!      surface_atoms :: VEC{INT}@
!      atom :: VEC{ATOM}*
!      n :: INT
!
!      ! Get surface atoms
!      n = .saved.atom.dim
!      surface_atoms = .isosurface.surface_group_atom_indices(.atom(n+1:))
!      surface_atoms = surface_atoms + n
!
!      ! Append them to the fragment
!      .atom.destroy_bases
!      atom = .atom(1:n)
!      atom.append(.atom(surface_atoms))
!
!      surface_atoms.destroy
!
!      ! Base crystal on this fragment
!      .atom.destroy
!      .atom => atom
!      .crystal.update_fragment_info(atom)
!      .crystal.set_destroy_fragment_atom(TRUE)
!
!      ! Make the new HS-contact-group-cluster
!      .cluster.destroy
!      .cluster.create(.crystal)
!      .cluster.set_generation_method("fragment")
!      .cluster.set_defragment(TRUE)
!      .cluster.make_info
!      .cluster.create_atom_list(atom)
!      .cluster.destroy
!
!      ! Set the completed-group atom list
!    ! .atom.destroy ! will destroy as part of crystal
!      .atom => atom
!
!      ! Base crystal on this cluster
!      .crystal.destroy_asymmetric_unit
!      .crystal.destroy_fragment_data
!      .crystal.update_fragment_info(.atom,assign_atom=TRUE)
!
!      ! Change name to reflect atom-list change
!      .name = trim(.saved.name) // "_HS_cluster"
!
!      ! Finalize atom info
!      .BASE:update_atom_and_basis_info
!
!   end

!  ===========================
!  Fourier transform integrals
!  ===========================

   make_ft(res,dens,k_pts) ::: PURE
   ! Return "res", the Fourier transform of a density described by an
   ! AO density matrix "dens" evaluated at some reflections "k_pts".
   ! NOTE: Includes *temperature* and *partition* factors in here.
      self  :: IN
      res   :: VEC{CPX}, OUT
      dens  :: MAT{REAL}, IN
      k_pts :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(res.dim==k_pts.dim1,  "res and k_pts, incomptabile")

      k_max,k,fa,fb,la,lb,na,nb,q,atom_a,atom_b :: INT
      FT_ab :: MAT3{CPX}@
      cutoff :: REAL
      sh :: SHELL2

      k_max = k_pts.dim1
      cutoff = TOL(10)/.n_shell_pairs

      res = ZERO

      parallel do q = 1,.n_shell_pairs

         ! Get shell pairs
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then

            ! Too small
            sh.destroy_ptr_part

         else 

            ! Make the FT - includes thermal smearing
            FT_ab.create(k_max,na,nb)
            .XTAL:make_FT_pair(FT_ab,k_pts,sh,atom_a,atom_b)
           
            ! Trace with density matrix
            ! Count off-diagonals twice
            if (fa/=fb) then 
              do k = 1,k_max
                 res(k) = res(k) + TWO*sum(FT_ab(k,:,:)*dens(fa:la,fb:lb))
              end
            else
              do k = 1,k_max
                 res(k) = res(k) +     sum(FT_ab(k,:,:)*dens(fa:la,fb:lb))
              end
            end
           
            ! Clean
            FT_ab.destroy
            sh.destroy_ptr_part

         end

      end

      PARALLEL_SUM(res)

   end

   make_ft(res,dens,k_pts) ::: PURE
   ! Return "res", the Fourier transform of a density described by an
   ! AO density matrix "dens" evaluated at some reflections "k_pts".
   ! NOTE: Includes temperature factors hidden in here
      self  :: IN
      res   :: VEC{CPX}, OUT
      dens  :: MAT{CPX}, IN
      k_pts :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")
   ENSURE(res.dim==k_pts.dim1,  "res and k_pts, incomptabile")

      k_max,k,fa,fb,la,lb,na,nb,q,atom_a,atom_b :: INT
      FT_ab :: MAT3{CPX}@
      cutoff :: REAL
      sh :: SHELL2

      k_max = k_pts.dim1
      cutoff = TOL(10)/.n_shell_pairs

      res = ZERO

      do q = 1,.n_shell_pairs

         ! Get shell pairs
         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then

            ! Too small
            sh.destroy_ptr_part

         else 

            ! Make the FT - includes thermal smearing
            FT_ab.create(k_max,na,nb)
            .XTAL:make_FT_pair(FT_ab,k_pts,sh,atom_a,atom_b)
           
            ! Trace with density matrix
            ! Count off-diagonals twice
            if (fa/=fb) then 
               do k = 1,k_max
                  res(k) = res(k) + TWO*FT_ab(k,:,:).trace_product_with(dens(fb:lb,fa:la))
               end
            else
               do k = 1,k_max
                  res(k) = res(k) +     FT_ab(k,:,:).trace_product_with(dens(fb:lb,fa:la))
               end
            end
           
            ! Clean
            FT_ab.destroy
            sh.destroy_ptr_part

         end

      end

   end

   make_FT_gc(res,dens,k_pts) ::: PURE
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)].
      self  :: IN
      res   :: VEC{CPX}, OUT
      dens  :: MAT{CPX}, IN
      k_pts :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      k_max,q,k,n_bf :: INT
      FT_ab :: MAT3{CPX}@
      fa,la,na,atom_a :: INT
      fb,lb,nb,atom_b :: INT
      dens_ba_aa,dens_ba_bb :: MAT{CPX}@
      dens_ba_ab,dens_ba_ba :: MAT{CPX}@
      cutoff :: REAL
      sh :: SHELL2

      n_bf   = .n_bf
      k_max  = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then
            sh.destroy_ptr_part
            cycle
         end

         ! FT integrals
         FT_ab.create(k_max,na,nb)
         .XTAL:make_FT_pair(FT_ab,k_pts,sh,atom_a,atom_b)

         ! DM blocks
         dens_ba_aa = dens(fb     :lb     ,fa     :la     )
         dens_ba_ab = dens(fb     :lb     ,fa+n_bf:la+n_bf)
         dens_ba_ba = dens(fb+n_bf:lb+n_bf,fa     :la     )
         dens_ba_bb = dens(fb+n_bf:lb+n_bf,fa+n_bf:la+n_bf)

         if (fa/=fb) then ! count off-diagonals twice.
            do k = 1,k_max
               res(k) = res(k) + TWO*FT_ab(k,:,:).trace_product_with(dens_ba_aa)
               res(k) = res(k) + TWO*FT_ab(k,:,:).trace_product_with(dens_ba_ab)
               res(k) = res(k) + TWO*FT_ab(k,:,:).trace_product_with(dens_ba_ba)
               res(k) = res(k) + TWO*FT_ab(k,:,:).trace_product_with(dens_ba_bb)
            end
         else
            do k = 1,k_max
               res(k) = res(k) + FT_ab(k,:,:).trace_product_with(dens_ba_aa)
               res(k) = res(k) + FT_ab(k,:,:).trace_product_with(dens_ba_ab)
               res(k) = res(k) + FT_ab(k,:,:).trace_product_with(dens_ba_ba)
               res(k) = res(k) + FT_ab(k,:,:).trace_product_with(dens_ba_bb)
            end
         end

         FT_ab.destroy
         sh.destroy_ptr_part

      end

   end


   make_FT_deriv_U(res,dens,k_pts) ::: PURE
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [k_max,n_atom*6]
      self  :: IN
      dens  :: MAT{REAL}, IN
      k_pts :: MAT{REAL}, IN
      res   :: MAT{CPX}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      FT_ab2,tmp1,tmp2,tmpa1,tmpa2,tmpa3,tmpa4,tmpa5,tmpa6 :: CPX
      k_max,k,fa,fb,la,lb,na,nb,q,atom_a,atom_b,basea,baseb :: INT
      delta,g,separation,x,y,z,z2 :: REAL
      diff :: VEC{REAL}(3)
      FT_ab :: MAT3{CPX}@
      dens_ba :: MAT{REAL}@
      cutoff :: REAL
      sh :: SHELL2

      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)
         
         if (sh.skip_ft(cutoff)) then
            sh.destroy_ptr_part
            cycle
         end
         
         FT_ab.create(k_max,na,nb)
         .XTAL:make_FT_pair(FT_ab,k_pts,sh,atom_a,atom_b)
         
         dens_ba = dens(fb:lb,fa:la)
         
         ! Count off-diagonals twice.
         if (fa/=fb) FT_ab = TWO * FT_ab 
         

         ! k_pts is 2pi * Bh so formula was divided by 4pi^2.
         diff = .atom(atom_a).position - .atom(atom_b).position
         separation = diff.norm
         g = HALF
         if (separation > 2.5d0) g=QUARTER
         g = g * (-HALF) 
         
         basea = (atom_a-1) * 6
         
         if (atom_a==atom_b) then
         
            delta = TWO * g

            do k = 1,k_max

               FT_ab2 = FT_ab(k,:,:).trace_product_with(dens_ba) * delta

               x = k_pts(k,1) ! SBh_x
               y = k_pts(k,2) ! SBh_y
               z = k_pts(k,3) ! SBh_z

               tmp1 = FT_ab2 * x
               tmp2 = FT_ab2 * y
               z2   = TWO * z

               res(basea+1,k) = res(basea+1,k) + tmp1 * x
               res(basea+2,k) = res(basea+2,k) + tmp1 * y * TWO
               res(basea+3,k) = res(basea+3,k) + tmp1 * z2
               res(basea+4,k) = res(basea+4,k) + tmp2 * y
               res(basea+5,k) = res(basea+5,k) + tmp2 * z2
               res(basea+6,k) = res(basea+6,k) + FT_ab2 * z * z

            end
         
         else
         
            baseb = (atom_b-1) * 6

            do k = 1,k_max

               FT_ab2 = FT_ab(k,:,:).trace_product_with(dens_ba) * g

               x = k_pts(k,1)           ! SBh_x
               y = k_pts(k,2)           ! SBh_y
               z = k_pts(k,3)           ! SBh_z

               tmp1 = FT_ab2 * x
               tmp2 = FT_ab2 * y
               z2   = TWO * z

               tmpa1 = tmp1 * x
               tmpa2 = tmp1 * y * TWO
               tmpa3 = tmp1 * z2
               tmpa4 = tmp2 * y
               tmpa5 = tmp2 * z2
               tmpa6 = FT_ab2 * z * z

               res(basea+1,k) = res(basea+1,k) + tmpa1
               res(basea+2,k) = res(basea+2,k) + tmpa2
               res(basea+3,k) = res(basea+3,k) + tmpa3
               res(basea+4,k) = res(basea+4,k) + tmpa4
               res(basea+5,k) = res(basea+5,k) + tmpa5
               res(basea+6,k) = res(basea+6,k) + tmpa6
               res(baseb+1,k) = res(baseb+1,k) + tmpa1
               res(baseb+2,k) = res(baseb+2,k) + tmpa2
               res(baseb+3,k) = res(baseb+3,k) + tmpa3
               res(baseb+4,k) = res(baseb+4,k) + tmpa4
               res(baseb+5,k) = res(baseb+5,k) + tmpa5
               res(baseb+6,k) = res(baseb+6,k) + tmpa6

            end

         end
         
         FT_ab.destroy
         sh.destroy_ptr_part

      end

   end

   make_FT_deriv_U(res,dens,k_pts) ::: PURE
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [k_max,n_atom*6]
      self  :: IN
      dens  :: MAT{CPX}, IN
      k_pts :: MAT{REAL}, IN
      res   :: MAT{CPX}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,  "no atom list")

      FT_ab2,tmp1,tmp2 :: CPX
      k_max,k,fa,fb,la,lb,na,nb,q :: INT
      atom_a,atom_b,basea,baseb   :: INT
      delta,g,separation,x,y,z    :: REAL
      diff    :: VEC{REAL}(3)
      FT_ab   :: MAT3{CPX}@
      dens_ba :: MAT{CPX}@
      cutoff  :: REAL
      sh :: SHELL2

      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      do q = 1, .n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)
         
         if (sh.skip_ft(cutoff)) then
            sh.destroy_ptr_part
            cycle
         end
         
         FT_ab.create(k_max,na,nb)
         .XTAL:make_FT_pair(FT_ab,k_pts,sh,atom_a,atom_b)
         
         dens_ba = dens(fb:lb,fa:la)

         ! Count off-diagonals twice.
         if (fa/=fb) FT_ab = TWO*FT_ab 
         
         ! k_pts is 2pi * Bh so formula was divided by 4pi^2.
         diff = .atom(atom_a).position-.atom(atom_b).position
         separation = diff.norm
         g = HALF
         if (separation > 2.5d0) g=QUARTER
         g = g * (-HALF) 
         
         basea = (atom_a-1) * 6
         if (atom_a==atom_b) then
         
            delta = TWO * g

            do k = 1,k_max

               FT_ab2 = FT_ab(k,:,:).trace_product_with(dens_ba) * delta

               x = k_pts(k,1)           ! SBh_x
               y = k_pts(k,2)           ! SBh_y
               z = k_pts(k,3)           ! SBh_z
               tmp1 = FT_ab2 * x
               tmp2 = FT_ab2 * y

               res(basea+1,k) = res(basea+1,k) + tmp1 * x
               res(basea+2,k) = res(basea+2,k) + tmp1 * y
               res(basea+3,k) = res(basea+3,k) + tmp1 * z
               res(basea+4,k) = res(basea+4,k) + tmp2 * y
               res(basea+5,k) = res(basea+5,k) + tmp2 * z
               res(basea+6,k) = res(basea+6,k) + FT_ab2 * z * z

            end
         
         else
         
            baseb = (atom_b-1) * 6
            do k = 1,k_max

               FT_ab2 = FT_ab(k,:,:).trace_product_with(dens_ba) * g

               x = k_pts(k,1)           ! SBh_x
               y = k_pts(k,2)           ! SBh_y
               z = k_pts(k,3)           ! SBh_z

               tmp1 = FT_ab2 * x
               tmp2 = FT_ab2 * y

               res(basea+1,k) = res(basea+1,k) + tmp1 * x
               res(basea+2,k) = res(basea+2,k) + tmp1 * y
               res(basea+3,k) = res(basea+3,k) + tmp1 * z
               res(basea+4,k) = res(basea+4,k) + tmp2 * y
               res(basea+5,k) = res(basea+5,k) + tmp2 * z
               res(basea+6,k) = res(basea+6,k) + FT_ab2 * z * z
               res(baseb+1,k) = res(baseb+1,k) + tmp1 * x
               res(baseb+2,k) = res(baseb+2,k) + tmp1 * y
               res(baseb+3,k) = res(baseb+3,k) + tmp1 * z
               res(baseb+4,k) = res(baseb+4,k) + tmp2 * y
               res(baseb+5,k) = res(baseb+5,k) + tmp2 * z
               res(baseb+6,k) = res(baseb+6,k) + FT_ab2 * z * z

            end
         end
         
         FT_ab.destroy
         sh.destroy_ptr_part

      end

   end


   make_FT_pair(FT_ab,k_pts,sh,atom_a,atom_b) ::: PURE
   ! Make the FT for one pair of gaussians.
   ! Includes *partitioning and *temperature factors*.
      self  :: IN
      FT_ab :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, IN
      sh    :: SHELL2, IN
      atom_a,atom_b :: INT, IN

   ENSURE(.crystal.allocated,"no crystal data")

      is_zero :: BIN
      TF :: MAT3{REAL}@
      part, Ua,Ub :: MAT{REAL}@
      model :: STR

      ! Partition factors
      part.create(sh.a.n_cc,sh.b.n_cc)
      .XTAL:make_partition_factors(part,sh,atom_a,atom_b,is_zero)

      if (NOT is_zero) then

         ! Get thermal factors "TF"
         TF.create(k_pts.dim1,sh.a.n_cc,sh.b.n_cc)
         Ua = .atom(atom_a).ADP_tensor
         Ub = .atom(atom_b).ADP_tensor
         model = .crystal.temperature_factor_model
         sh.make_temperature_factors(TF,model,k_pts,Ua,Ub)

         ! Do thermal *and* partition factor
         sh.make_ft(FT_ab,k_pts,TF,part)

         TF.destroy

      else

        FT_ab = ZERO

      end

      part.destroy

   end

   FT_for_a_in_pair_ab(FT,k1,k2,k3,sh,atom_a,atom_b) ::: PURE
   ! Make FT(h) the fourier transform with respect to a list of
   ! k points (k1,k2,k3) of an atom-A partitioned SHELL2 shellpair
   ! "sh" centered on "atom_a" and "atom_b".
   ! function FT of the shell gaussian gaussians.
   ! Includes partitioning and thermal smearing.
      self :: IN
      FT :: MAT3{CPX}, OUT
      k1,k2,k3 :: VEC{REAL}, IN
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN

   ENSURE(.crystal.allocated,"no crystal data")

      is_zero :: BIN
      p :: MAT{REAL}@
      k_max :: INT

      k_max = k1.dim

      p.create(sh.a.n_cc,sh.b.n_cc)

      ! Partition factors
      .XTAL:make_partition_factors(p,sh,atom_a,atom_b,is_zero)

      sh.make_FT_parted(FT,k1,k2,k3,p)

      p.destroy

   end

!  ============
!  Partitioning
!  ============

   make_partition_factors(part,sh,atom_a,atom_b,is_zero) ::: PURE
   ! Make the partitition factors "part" over the contractions in a
   ! SHELL2 "sh" on centers "atom_a" and "atom_b" and for a particular
   ! thermal ".crystal.xray_data.partition_model",.
      self :: IN
      part :: MAT{REAL}, OUT
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN
      is_zero :: BIN, optional, OUT

   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(.crystal.xray_data.allocated,"no crystal data")

      ra,rb,fa,fb :: REAL

      ! Get the rep. factors
      ! These are n_A and n_B in JG (2001) paper
      ra = .crystal.repetition_factor(atom_a)
      rb = .crystal.repetition_factor(atom_b)

      if (present(is_zero)) then
        if (ra<1 AND rb<1) then
          is_zero = TRUE
          return
        else
          is_zero = FALSE
        end
      end

      ! The f's are the reciprocal of the n's
      ! If any n is zero tat region is disregarded.
      if (ra<1) then; fa = ZERO
      else;           fa = ONE/ra
      end

      if (rb<1) then; fb = ZERO
      else;           fb = ONE/rb
      end

      select case (trim(.crystal.xray_data.partition_model))
      case ("none       "); part = ONE
      case ("tc-mulliken"); part = HALF * (fa + fb)
      case ("tc-tanaka  "); sh.make_Tanaka_partition(part,fa,fb)
      end

   end

   make_partition_factors(part,sh,ra,rb,is_zero) ::: PURE
   ! Make the partitition factors "part" over the contractions in a
   ! SHELL2 "sh" with repetition or site symmetry factors "ra" 
   ! and "rb".
      self :: IN
      part :: MAT{REAL}, OUT
      sh :: SHELL2, IN
      ra,rb :: REAL, IN
      is_zero :: BIN, optional, OUT

   ENSURE(.crystal.allocated,"no crystal data")

      fa,fb :: REAL

      if (present(is_zero)) then
        if (ra<1 AND rb<1) then
          is_zero = TRUE
          return
        else
          is_zero = FALSE
        end
      end

      ! The f's are the reciprocal of the n's
      ! If any n is zero tat region is disregarded.
      if (ra<1) then; fa = ZERO
      else;           fa = ONE/ra
      end

      if (rb<1) then; fb = ZERO
      else;           fb = ONE/rb
      end

      ! Tanaka method only for now ...
      sh.make_Tanaka_partition(part,fa,fb)

   end

!  ================
!  Thermal smearing
!  ================

!   make_temperature_factors(TF,k_pts,a,b,sh) ::: PURE
!   ! Makes the temperature factors "TF" for every pair of the
!   ! contraction coefficients.  Dimensions of "res" are
!   ! [k_max,.a.n_cc,.b.n_cc].
!      self :: IN
!      TF :: MAT3{REAL}, OUT
!      k_pts :: MAT{REAL}, IN
!      a,b :: INT, IN
!      sh :: SHELL2, IN
!
!   ENSURE(NOT .crystal.xray_data.allocated,"no crystal.data")
!
!      Ua,Ub,Uab :: MAT{REAL}(3,3)
!      S,US,diff :: VEC{REAL}(3)
!      separation,bondlength,Ta,Tb,g :: REAL
!      k :: INT
!
!      select case (trim(.crystal.temperature_factor_model))
!
!      case ("none      ")
!
!         TF = ONE
!
!      case ("tc-coppens") 
!      
!         ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
!         Ua = -HALF * .atom(a).ADP_tensor
!         Ub = -HALF * .atom(b).ADP_tensor
!
!         do k = 1,k_pts.dim1
!            S = k_pts(k,:)
!            US = matmul(Ua,S)
!            Ta = dot_product(S,US)
!            US = matmul(Ub,S)
!            Tb = dot_product(S,US)
!            TF(k,:,:) = HALF*(exp(Ta)+exp(Tb))
!         end
!
!      case ("tc-stewart") 
!      
!         ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4]
!         Ua   = .atom(a).ADP_tensor
!         Ub   = .atom(b).ADP_tensor
!         Uab  = Ua + Ub
!         diff = .atom(a).position-.atom(b).position
!
!         bondlength = 2.5
!         separation = diff.norm
!         g = HALF
!         if (separation > bondlength) g = QUARTER
!
!         Uab = -HALF * g * Uab    
!
!         do k = 1,k_pts.dim1
!            S = k_pts(k,:)
!            US = matmul(Uab,S)
!            Ta = dot_product(S,US)
!            TF(k,:,:) = exp(Ta)
!         end
!
!      case ("tc-tanaka ") 
!      
!         ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
!         Ua = .atom(a).ADP_tensor
!         Ub = .atom(b).ADP_tensor
!         sh.make_Tanaka_temperature_factors(TF,k_pts,Ua,Ub)
!
!      end
!
!   end

!   FT_thermally_smear(FT_ab,k_pts,a,b)
!   ! Thermally smear the fourier transform integrals "FT_ab" evaluated
!   ! on "k_pts" for shell pair (ab) centered on atoms "a" and "b" .
!      self :: IN
!      FT_ab :: MAT3{CPX}, INOUT
!      k_pts :: MAT{REAL}, IN
!      a,b :: INT, IN
!
!      Ua,Ub,Uab :: MAT{REAL}(3,3)
!      S,US,diff :: VEC{REAL}(3)
!      separation,bondlength,Ta,Tb,g :: REAL
!      k,k_max :: INT
!
!      k_max = k_pts.dim1
!
!      select case (trim(.crystal.temperature_factor_model))
!
!      case ("none      ")
!
!      case ("tc-coppens") 
!      
!         ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
!         Ua = -HALF * .atom(a).ADP_tensor
!         Ub = -HALF * .atom(b).ADP_tensor
!
!         do k = 1,k_max
!            S = k_pts(k,:)
!            US = matmul(Ua,S)
!            Ta = dot_product(S,US)
!            US = matmul(Ub,S)
!            Tb = dot_product(S,US)
!            FT_ab(k,:,:) = FT_ab(k,:,:) * HALF*(exp(Ta)+exp(Tb))
!         end
!
!      case ("tc-stewart") 
!      
!         ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
!         Ua = .atom(a).ADP_tensor
!         Ub = .atom(b).ADP_tensor
!         Uab = Ua + Ub
!         diff = .atom(a).position-.atom(b).position
!
!         bondlength = 2.5e0
!         separation = diff.norm
!         g = HALF
!         if (separation > bondlength) g=QUARTER
!
!         Uab = -HALF * g * Uab
!
!         do k = 1,k_max
!            S = k_pts(k,:)
!            US = matmul(Uab,S)
!            Ta = dot_product(S,US)
!            FT_ab(k,:,:) = exp(Ta)*FT_ab(k,:,:)
!         end
!
!      case ("tc-tanaka") 
!      
!         ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
!         DIE("cannot thermally smear at contracted level.")
!
!      case default
!         DIE("unknown model, "//trim(.crystal.temperature_factor_model))
!
!      end
!
!   end

!  ==================
!  Archived integrals
!  ==================

   get_FT_ints
   ! Get the fourier transform of the overlap integrals.
   ! If the archive file exists, read it; otherwise make it.
      self :: IN

      arch :: ARCHIVE

      arch.set(.name,"FT_ints")
      if (NOT arch.exists) .XTAL:make_FT_ints

   end

   make_FT_ints
   ! Make Fourier transform of the overlap integrals on an archive
      self :: IN

   ENSURE(.crystal.allocated, "no crystal")

      arch :: ARCHIVE
      k_pts :: MAT{REAL}@
      fa,la,na :: INT
      fb,lb,nb :: INT
      q,atom_a,atom_b :: INT
      n_refl,n_uniq   :: INT
      FT_ab_eq, FT_ab :: MAT3{CPX}@
      sh :: SHELL2

      arch.set(.name,"FT_ints")
      arch.open_for("write-only")

      n_refl = .crystal.xray_data.reflections.dim
      n_uniq = .crystal.n_unique_SF_k_pts

      k_pts.create(n_uniq,3)
      .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)

      do q = 1,.n_shell_pairs

         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         FT_ab_eq.create(n_uniq,na,nb)
         FT_ab.create(n_refl,na,nb)

         .XTAL:make_FT_pair(FT_ab_eq,k_pts,sh,atom_a,atom_b)

         .crystal.spacegroup.sum_unique_sf_ints(FT_ab,FT_ab_eq,.crystal.xray_data.reflections)

         arch.Bfile.write(FT_ab)

         FT_ab.destroy
         FT_ab_eq.destroy
         sh.destroy_ptr_part

      end

      k_pts.destroy
      arch.close

   end

!  =====================
!  PND structure factors
!  =====================

!   put_PND_sf
!   ! Output the magnetic structure factors
!      self :: IN
!      .crystal.put_PND_sf(.name)
!   end
!
!   make_PND_scalar_magnetic_sf
!   ! Make the PND scalar magnetic structure factors and assign them
!   ! To the crystal objects structure factors for analysis
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.data_exists, "no reflection data")
!      FM_s, FM_l, FM_r, Fc :: VEC{CPX}*
!      n_refl :: INT
!      arch :: ARCHIVE
!      .crystal.assign_pnd
!      n_refl = .crystal.n_refl
!      Fc.create(n_refl)
!      ! Spin contribution
!      .make_PND_spin_sf
!      FM_s.create(n_refl)
!      arch.set(.name,"PND_spin_sf")
!      arch.read(FM_s)
!      ! Orbital contribution
!    ! .make_PND_nabla_sf
!    ! FM_l.create(n_refl)
!    ! arch.set(.name,"PND_nabla_sf")
!    ! arch.read(FM_l)
!      ! Diamagnetic contribution
!    ! .make_PND_r_sf
!    ! FM_r.create(n_refl)
!    ! arch.set(.name,"PND_r_sf")
!    ! arch.read(FM_r)
!      ! Make F_calc
!      Fc = FM_s ! + FM_l ! + FM_r
!      arch.set(.name,"PND_scalar_magnetic_sf")
!      arch.write(Fc)
!      .crystal.xray_data.reflections.set_F_calc(Fc)
!      .crystal.xray_data.make_F_predicted
!    ! FM_r.destroy
!    ! FM_l.destroy
!      FM_s.destroy
!      Fc.destroy
!   end
!
!   make_PND_spin_sf
!   ! Make the PND structure factors
!   ENSURE(.density_mx.allocated, "no density")
!      genre :: STR
!      genre = .density_mx.spinorbital_genre
!      select case (genre)
!      case ("u "); .make_u_PND_spin_sf
!      case ("gc"); .make_gc_PND_spin_sf
!      case default
!         DIE("not implemented for "//trim(genre))
!      end
!   end
!
!   make_u_PND_spin_sf
!   ! Make the scalar spin magnetic structure factors assuming an applied field
!   ! in the z direction, and assuming an unrestricted density matrix exists.
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.density_mx.allocated, "no density")
!   ENSURE(.density_mx.alpha.allocated, "no density")
!      arch :: ARCHIVE
!      fac,ans :: REAL
!      d_aa,d_bb :: MAT{REAL}*
!      FT_ab :: MAT4{CPX}*
!      FM :: VEC{CPX}*
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_FT_spin_ints")
!      if (NOT arch.exists) .make_PND_FT_spin_ints
!      arch.open_for("read-only",type="real")
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb)
!         FT_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
!         arch.Bfile.read(FT_ab)
!         d_aa => .density_mx.alpha(fb:lb,fa:la)
!         d_bb => .density_mx.beta( fb:lb,fa:la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            ans = ans +    FT_ab(i,:,:,3).trace_product_with(d_aa)
!            ans = ans -    FT_ab(i,:,:,3).trace_product_with(d_bb)
!            FM(i) = FM(i) + fac*ans
!         end
!         FT_ab.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_spin_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   make_gc_PND_spin_sf
!   ! Make the scalar spin magnetic structure factors assuming an applied field
!   ! in the z direction, and assuming a general complex denisty matrix exists
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.density_mx.allocated, "no density")
!   ENSURE(.density_mx.general_complex.allocated, "no density")
!      arch :: ARCHIVE
!      fac,ans :: REAL
!      d_aa,d_bb,d_ba :: MAT{CPX}*
!      FT_ab :: MAT4{CPX}*
!      FM :: VEC{CPX}*
!      ci :: CPX
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_FT_spin_ints")
!      if (NOT arch.exists) .make_PND_FT_spin_ints
!      arch.open_for("read-only",type="real")
!      ci = (ZERO,ONE)
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb)
!         FT_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
!         arch.Bfile.read(FT_ab)
!         d_aa => .density_mx.general_complex(      fb:      lb,      fa:      la)
!         d_bb => .density_mx.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
!         d_ba => .density_mx.general_complex(.n_bf+fb:.n_bf+lb,      fa:      la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            ans =          FT_ab(i,:,:,1).trace_product_with(d_ba)
!            ans = ans - ci*FT_ab(i,:,:,2).trace_product_with(d_ba)
!            ans = ans +    FT_ab(i,:,:,3).trace_product_with(d_aa)
!            ans = ans -    FT_ab(i,:,:,3).trace_product_with(d_bb)
!            FM(i) = FM(i) + fac*ans
!         end
!         FT_ab.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_spin_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   get_PND_FT_spin_ints
!   ! Get the PND ft spin integrals on disk if they don't already exist
!      arch :: ARCHIVE
!      arch.set(.name,"PND_FT_spin_ints")
!      if (NOT arch.exists) .make_PND_FT_spin_ints
!   end
!
!   make_PND_FT_spin_ints
!   ! Make the fourier transform of the PND spin integrals on the archive
!   ENSURE(.crystal.allocated, "no crystal")
!      arch :: ARCHIVE
!      k_pts :: MAT{REAL}*
!      sh :: SHELL2*
!      FT_ab_eq :: MAT3{CPX}*
!      FT_ab :: MAT4{CPX}*
!      q,fa,la,fb,lb,atom_a,atom_b :: INT
!      arch.set(.name,"PND_FT_spin_ints")
!      arch.open_for("write-only",type="cpx")
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb,atom_a,atom_b)
!         FT_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp)
!         .XTAL:make_FT_pair(FT_ab_eq,k_pts,sh,atom_a,atom_b)
!         FT_ab.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp,3)
!         .crystal.sum_PND_spin_ints(FT_ab,FT_ab_eq)
!         arch.Bfile.write(FT_ab)
!         FT_ab.destroy
!         FT_ab_eq.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      k_pts.destroy
!      arch.close
!   end
!
!   make_PND_nabla_sf
!   ! Make PND nabla structure factors
!   ENSURE(.density_mx.allocated, "no density")
!      genre :: STR
!      genre = .density_mx.spinorbital_genre
!      select case (genre)
!      case ("gc"); .make_gc_PND_nabla_sf
!      case default
!         DIE("not implemented for "//trim(genre))
!      end
!   end
!
!   make_gc_PND_nabla_sf
!   ! Make the scalar nabla magnetic structure factors assuming an applied field
!   ! in the z direction, and assuming a general complex density exists
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.density_mx.allocated, "no density")
!   ENSURE(.density_mx.general_complex.allocated, "no density")
!      arch :: ARCHIVE
!      fac :: REAL
!      dens :: MAT{CPX}*
!      FT_ab_z :: MAT3{CPX}*
!      FM :: VEC{CPX}*
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_FT_nabla_ints")
!      if (NOT arch.exists) .make_PND_FT_nabla_ints
!      arch.open_for("read-only",type="real")
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb)
!         FT_ab_z.create(k_max,sh.a.n_comp,sh.b.n_comp)
!         arch.Bfile.read(FT_ab_z)
!         dens.create(sh.b.n_comp,sh.a.n_comp)
!         dens =        .density_mx.general_complex(      fb:      lb,      fa:      la)
!         dens = dens + .density_mx.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            FM(i) = FM(i) + fac*FT_ab_z(i,:,:).trace_product_with(dens)
!         end
!         dens.destroy
!         FT_ab_z.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_nabla_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   get_PND_FT_nabla_ints
!   ! Get the PND ft nabla integrals on disk if they don't already exist
!      arch :: ARCHIVE
!      arch.set(.name,"PND_FT_nabla_ints")
!      if (NOT arch.exists) .make_PND_FT_nabla_ints
!   end
!
!   make_PND_FT_nabla_ints
!   ! Make the fourier transform of the nabla integrals on the archive
!   ENSURE(.crystal.allocated, "no crystal")
!      arch :: ARCHIVE
!      k_pts :: MAT{REAL}*
!      sh :: SHELL2*
!      FT_ab_eq :: MAT4{CPX}*
!      FT_ab_z :: MAT3{CPX}*
!      q,fa,la,fb,lb,atom_a,atom_b :: INT
!      arch.set(.name,"PND_FT_nabla_ints")
!      arch.open_for("write-only",type="cpx")
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb,atom_a,atom_b)
!         FT_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp,3)
!         .make_FT_nabla_pair(FT_ab_eq,k_pts,sh,atom_a,atom_b)
!       ! sh.make_FT_nabla(FT_ab_eq,k_pts)
!       ! .FT_thermally_smear(FT_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
!       ! .FT_thermally_smear(FT_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
!       ! .FT_thermally_smear(FT_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
!         FT_ab_z.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp)
!         .crystal.sum_PND_nabla_ints(FT_ab_z,FT_ab_eq)
!         arch.Bfile.write(FT_ab_z)
!         FT_ab_z.destroy
!         FT_ab_eq.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      k_pts.destroy
!      arch.close
!   end
!
!   make_FT_nabla_pair(FT_ab,k_pts,sh,atom_a,atom_b)
!   ! Make_ft for one pair of gaussians.
!   ! Includes partitioning, dispersion and thermal smearing.
!      FT_ab :: MAT4{CPX}
!      k_pts :: MAT{REAL}, IN
!      sh :: SHELL2, IN
!      atom_a,atom_b :: INT, IN
!   ENSURE(.crystal.allocated,"no crystal data")
!       t :: MAT3{REAL}*
!       p :: MAT{REAL}*
!      k_max :: INT
!      k_max = size(k_pts,1)
!      t.create(k_max,sh.a.n_cc,sh.b.n_cc)
!      .make_temperature_factors(t,k_pts,atom_a,atom_b,sh)
!      p.create(sh.a.n_cc,sh.b.n_cc)
!      .make_partition_factors(p,sh,atom_a,atom_b)
!      sh.make_FT_nabla(FT_ab,k_pts,t,p)
!      p.destroy
!      t.destroy
!   end
!
!   make_PND_r_sf
!   ! Make the scalar dipole magnetic structure factors assuming an applied field
!   ! in the z direction
!   ENSURE(.crystal.allocated, "no crystal")
!      arch :: ARCHIVE
!      fac,ans :: REAL
!      d_aa,d_bb :: MAT{CPX}*
!      FT_ab :: MAT4{CPX}*
!      FM :: VEC{CPX}*
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_FT_r_ints")
!      if (NOT arch.exists) .make_PND_FT_r_ints
!      arch.open_for("read-only",type="real")
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb)
!         FT_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
!         arch.Bfile.read(FT_ab)
!         d_aa => .density_mx.general_complex(      fb:      lb,      fa:      la)
!         d_bb => .density_mx.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            ans =       fac*FT_ab(i,:,:,3).trace_product_with(d_aa)
!            ans = ans + fac*FT_ab(i,:,:,3).trace_product_with(d_bb)
!            FM(i) = FM(i) + ans
!         end
!         FT_ab.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_r_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   get_PND_FT_r_ints
!   ! Get the PND ft r integrals on disk if they don't already exist
!      arch :: ARCHIVE
!      arch.set(.name,"PND_FT_r_ints")
!      if (NOT arch.exists) .make_PND_FT_r_ints
!   end
!
!   make_PND_FT_r_ints
!   ! Make the fourier transform of the dipole "r" integrals on the archive
!   ENSURE(.crystal.allocated, "no crystal")
!   ENSURE(.crystal.data_exists, "no structure factor data")
!      arch :: ARCHIVE
!      k_pts :: MAT{REAL}*
!      sh :: SHELL2*
!      FT_ab_eq, FT_ab :: MAT4{CPX}*
!      q,fa,la,fb,lb,atom_a,atom_b,n_refl :: INT
!      n_refl = .crystal.n_refl
!      arch.set(.name,"PND_FT_r_ints")
!      arch.open_for("write-only",type="cpx")
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
!      sh.create
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb,atom_a,atom_b)
!         FT_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp,3)
!         sh.make_FT_r(FT_ab_eq,k_pts)
!         .FT_thermally_smear(FT_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
!         .FT_thermally_smear(FT_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
!         .FT_thermally_smear(FT_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
!         FT_ab.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
!         .crystal.sum_FT_r_ints(FT_ab,FT_ab_eq,.B_field)
!         arch.Bfile.write(FT_ab)
!         FT_ab.destroy
!         FT_ab_eq.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      k_pts.destroy
!      arch.close
!   end
!
!   make_PND_fit_ints(ints,lambda)
!   ! Make the PND constraint integrals on the archive
!      ints :: MAT{CPX}, target
!      lambda :: REAL
!      spin_archive,nabla_archive :: ARCHIVE
!      Fc,F_exp,F_sigma :: VEC{REAL}*
!      ints_aa,ints_bb,ints_ba :: MAT{CPX}*
!      nabla_z :: MAT3{CPX}*
!      spin :: MAT4{CPX}*
!      sh :: SHELL2*
!      ci :: CPX
!      fac,fac1 :: REAL
!      i,q,fa,la,fb,lb,n_bf,n_refl :: INT
!      .get_PND_FT_spin_ints
!      .get_PND_FT_nabla_ints
!      .get_PND_FT_r_ints
!      spin_archive.set(.name,"PND_FT_spin_ints")
!      nabla_archive.set(.name,"PND_FT_nabla_ints")
!    ! r_archive.set(.name,"PND_FT_r_ints")
!      spin_archive.open_for("read-only",type="real")
!    ! r_archive.open_for("read-only",type="real")
!      ci = (ZERO,ONE)
!      n_bf   =  .n_bf
!      n_refl =  .crystal.n_refl
!      Fc.create(n_refl)
!      F_exp.create(n_refl)
!      F_sigma.create(n_refl)
!      Fc = abs(.crystal.F_calc)
!      F_exp  = .crystal.F_exp
!      F_sigma  = .crystal.F_sigma
!      ints = ZERO
!      sh.create
!      fac1 = TWO*lambda/n_refl
!      do q = 1,.n_shell_pairs
!         .SET:set_shell2_from(q,sh,fa,la,fb,lb)
!         spin.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
!         spin_archive.Bfile.read(spin)
!         ints_aa => ints(     fa:     la,     fb:     lb)
!         ints_bb => ints(n_bf+fa:n_bf+la,n_bf+fb:n_bf+lb)
!         ints_ba => ints(n_bf+fa:n_bf+la,     fb:     lb)
!         do i = 1,n_refl
!            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
!            ints_ba = ints_ba +    fac*spin(i,:,:,1)
!            ints_ba = ints_ba + ci*fac*spin(i,:,:,2)
!            ints_aa = ints_aa +    fac*spin(i,:,:,3)
!            ints_bb = ints_bb -    fac*spin(i,:,:,3)
!         end
!         spin.destroy
!         nabla_z.create(n_refl,sh.a.n_comp,sh.b.n_comp)
!         nabla_archive.Bfile.read(nabla_z)
!         do i = 1,n_refl
!            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
!            ints_aa = ints_aa + fac*nabla_z(i,:,:)
!            ints_bb = ints_bb + fac*nabla_z(i,:,:)
!         end
!         nabla_z.destroy
!       ! r.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
!       ! r_archive.Bfile.read(r)
!       ! do i = 1,n_refl
!       !    fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i)*)
!       !    ints_aa = ints_aa + fac*r(i,:,:,3)
!       !    ints_bb = ints_bb + fac*r(i,:,:,3)
!       ! end
!       ! r.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      ints.make_hermitian
!    ! r_archive.close
!      nabla_archive.close
!      spin_archive.close
!      F_sigma.destroy
!      F_exp.destroy
!      Fc.destroy
!   end

! ===========
! Development
! ===========

! Much of this commented, for reinstatement? -- dyhlan

!   get_X_structure_factors_test
!   ! Make the X-ray structure factors for this molecule.
!      self :: INOUT
!
!!   ENSURE(.crystal.allocated, "no crystal")
!!   ENSURE(.crystal.xray_data.allocated, "no x-ray reflection data")
!!   ENSURE(.density_mx.allocated, "no density matrix")
!
!      sf_eq,Fc :: VEC{CPX}@
!      k_pts :: MAT{REAL}@
!
!      .crystal.assign_xray
!
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
!
!      .BASE:make_r_density_mx
!
!      sf_eq.create(k_pts.dim1)
!      sf_eq = IMAGIFY(ZERO)
!      .XTAL:make_FT_test(sf_eq,.density_mx.restricted,k_pts)
!      k_pts.destroy
!
!      if (.scfdata.allocated) then
!      if (.scfdata.spinorbital_genre=="u") then
!         .density_mx.destroy("r")
!      end
!      end
!
!      Fc.create(.crystal.n_refl)
!      .crystal.spacegroup.sum_unique_sf(Fc,sf_eq,.crystal.xray_data.reflections)
!      sf_eq.destroy
!
!      ! Dispersion correction into Fc
!      if (.crystal.xray_data.add_dispersion_to_F_calc) .crystal.add_dispersion_correction(Fc)
!
!      ! Set the calculated SF's
!      .crystal.xray_data.reflections.set_F_calc(Fc)
!      Fc.destroy
!
!      .crystal.xray_data.make_F_predicted
!
!      .crystal.put_reflection_data
!
!
!   end

!   put_PCE_X_structure_factors
!   ! Make the relativistic PCE structure factors for this molecule.
!      self :: INOUT
!
!      sf_eq,Fc :: VEC{CPX}@
!      k_pts :: MAT{REAL}@
!
!      Fc.create(.crystal.n_refl)
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!
!      .crystal.assign_xray
!      .crystal.xray_data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)
!      .BASE:make_r_density_mx
!
!      sf_eq.create(k_pts.dim1)
!      sf_eq = (ZERO,ZERO)
!      select case (.scfdata.relativity_kind)
!      case ("douglas-kroll-hess"); .XTAL:make_FT_DKH(sf_eq,.density_mx.restricted,k_pts)
!      case ("dkh");                .XTAL:make_FT_DKH(sf_eq,.density_mx.restricted,k_pts)
!      case ("iotc");               .XTAL:make_FT_IOTC(sf_eq,.density_mx.restricted,k_pts)
!      case default;                .XTAL:make_FT_test(sf_eq,.density_mx.restricted,k_pts)
!      end
!
!      if (.scfdata.allocated) then
!      if (.scfdata.lllllpinorbital_genre=="u") then
!         .density_mx.destroy("r")
!      end
!      end
!      k_pts.destroy
!
!      .crystal.spacegroup.sum_unique_sf(Fc,sf_eq,.crystal.xray_data.reflections)
!      sf_eq.destroy
!
!      ! Dispersion correction into Fc
!      if (.crystal.add_dispersion_to_F_calc) .crystal.add_dispersion_correction(Fc)
!
!      ! Set the calculated SF's
!      .crystal.xray_data.reflections.set_F_calc(Fc)
!      Fc.destroy
!
!      .crystal.xray_data.make_F_predicted
!
!      .crystal.put_reflection_data
!
!   end

!   make_FT_test_1(sf,D,k_pts)
!   ! make the structure factor (only one)
!      sf :: CPX
!      D :: MAT{REAL}, IN
!      k_pts :: VEC{REAL}, IN
!
!      n_gcm :: INT
!      i,j,k_max :: INT
!      g :: CPX
!      m_out :: MAT{INT}*
!      GG,FT_hkl,buco :: MAT{CPX}*
!      MM,S,R :: MAT{REAL}*
!   !  P2,Ap,Ep :: VEC{REAL}*
!
!      k_max = size(k_pts,1)
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!
!      R.destroy
!
!      MM.create(.n_prim,.n_bf)
!      .BASE:make_normalised_contraction_mx(MM)
!
!      FT_hkl.create(.n_bf,.n_bf)
!      GG.create(.n_prim,.n_prim)
!      buco.create(.n_bf,.n_prim)
!
!     ! do n = 1,k_max
!
!         ! here it comes babes.  point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to its non-relativistic counterpart is really not
!         ! effective :(
!         .XTAL:make_primitive_FT_mx(GG,k_pts(1),k_pts(2),k_pts(3))
!         buco.to_product_of(MM,GG,transpose_a=TRUE)
!         FT_hkl.to_product_of(buco,MM)
!         .XTAL:make_part_and_therm_smear(FT_hkl,k_pts(:))
!
!         g = (ZERO,ZERO) !???
!         do i=1,.n_bf
!         do j=1,.n_bf
!            g = g + D(i,j)*FT_hkl(i,j)  !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
!         end do
!         end do
!
!         sf = g
!
!    !  end do
!
!      MM.destroy
!      buco.destroy
!
!      ! unfortunatelly the PCE corrected orbitals lose phase :(
!   !  if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!   !     PPZPP.destroy
!   !  end if
!
!      S.destroy
! !    Z.destroy
! !    PZP.destroy
!      GG.destroy
! !    YU.destroy
! !    Ap.destroy
! !    Ep.destroy
! !    P2.destroy
!      m_out.destroy
!      FT_hkl.destroy
!
!   end

!   make_FT_test(sf,D,k_pts) ::: PURE
!   ! make the PCE corrected structure factors
!      sf :: VEC{CPX}
!      D :: MAT{REAL}, IN
!      k_pts :: MAT{REAL}, IN
!
!      n_gcm :: INT
!      n,i,j,k_max :: INT
!      g :: CPX
!      m_out :: MAT{INT}*
!      GG,FT_hkl,buco :: MAT{CPX}*
!      MM,YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
!      P2,Ap,Ep :: VEC{REAL}*
!
!      k_max = size(k_pts,1)
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!
!      R.destroy
!
!      MM.create(.n_prim,.n_bf)
!      .BASE:make_normalised_contraction_mx(MM)
!
!      FT_hkl.create(.n_bf,.n_bf)
!      GG.create(.n_prim,.n_prim)
!      buco.create(.n_bf,.n_prim)
!
!      do n = 1,k_max
!
!         ! here it comes babes.  point for point the density will be on
!         ! and on calculated I am sincerely sorry, but the code
!         ! comparing to its non-relativistic counterpart is really not
!         ! effective :(
!         .XTAL:make_primitive_FT_mx(GG,k_pts(n,1),k_pts(n,2),k_pts(n,3))
!         buco.to_product_of(MM,GG,transpose_a=TRUE)
!         FT_hkl.to_product_of(buco,MM)
!         .XTAL:make_part_and_therm_smear(FT_hkl,k_pts(n,:))
!
!         g = (ZERO,ZERO) !???
!         do i=1,.n_bf
!         do j=1,.n_bf
!            g = g + D(i,j)*FT_hkl(i,j)  !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
!         end do
!         end do
!
!         sf(n) = g
!
!      end do
!
!      MM.destroy
!      buco.destroy
!
!      ! unfortunatelly the PCE corrected orbitals lose phase :(
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!         PPZPP.destroy
!      end if
!
!      S.destroy
!      Z.destroy
!      PZP.destroy
!      GG.destroy
!      YU.destroy
!      Ap.destroy
!      Ep.destroy
!      P2.destroy
!      m_out.destroy
!      FT_hkl.destroy
!
!   end

!   make_FT_DKH(sf,D,k_pts) ::: PURE
!   ! make the PCE corrected structure factors
!      sf :: VEC{CPX}
!      D :: MAT{REAL}, IN
!      k_pts :: MAT{REAL}, IN
!
!      n_gcm,met :: INT
!      n,i,j,k_max :: INT
!      g :: CPX
!      m_out :: MAT{INT}@
!      GG,FT_hkl :: MAT{CPX}@
!      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}@
!      P2,Ap,Ep :: VEC{REAL}@
!
!      k_max = k_pts.dim1
!
!      ! the method is for the PCE corr is sfs
!      met = 1
!
!      m_out.create(.n_prim,.n_prim)
!      .REL:get_n_gcm(m_out,n_gcm)
!
!      R.create(.n_prim,.n_prim)
!      .REL:make_primitive_overlap_mx(R)
!
!      S.create(n_gcm,n_gcm)
!      .REL:get_da_gcm_now(R,S,m_out)
!
!      R.destroy
!
!      YU.create(n_gcm,n_gcm)
!      Ap.create(n_gcm)
!      Ep.create(n_gcm)
!      P2.create(n_gcm)
!
!      .REL:make_DKH_mxs(YU,Ap,Ep,P2)
!
!      Z.create(n_gcm,n_gcm)
!      PZP.create(n_gcm,n_gcm)
!      .REL:make_DKH_mxs2(Z,PZP,YU)
!
!      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
!         PPZPP.create(n_gcm,n_gcm)
!         .REL:make_DKH_mxs4(PPZPP,YU)
!      end if
!
!      FT_hkl.create(.n_bf,.n_bf)
!
!      do n = 1,k_max
!
!        ! here it comes babes.  point for point the density will be on
!        ! and on calculated I am sincerely sorry, but the code
!        ! comparing to its non-relativistic counterpart is really not
!        ! effective :(
!        .XTAL:make_PCE_off(FT_hkl,YU,Ap,Ep,P2,k_pts(n,1),k_pts(n,2),k_pts(n,3),m_out,n_gcm,S,Z,PZP,met,PPZPP)
!
!        .XTAL:make_part_and_therm_smear(FT_hkl,k_pts(n,:))
!
!        g = (ZERO,ZERO) !???
!
!        do i=1,.n_bf
!        do j=1,.n_bf
!           g = g + D(i,j)*FT_hkl(i,j)  !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
!        end do
!        end do
!
!        sf(n) = g
!
!     end do
!
!     ! unfortunatelly the PCE corrected orbitals lose phase :(
!     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
!        PPZPP.destroy
!     end if
!
!     FT_hkl.destroy
!     S.destroy
!     Z.destroy
!     PZP.destroy
!     GG.destroy
!     YU.destroy
!     Ap.destroy
!     Ep.destroy
!     P2.destroy
!     m_out.destroy
!
!   end

!   make_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,met,PPZPP)
!   ! correct the picture change
!   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
!   ! this routine is based on the make_DKH_1e_mx(H) routine
!      GG :: MAT{CPX}, OUT
!      YU :: MAT{REAL}, IN
!      Ap,Ep,P2 :: VEC{REAL}, IN
!      xx,yy,zz :: REAL, IN
!      m_out :: MAT{INT}, IN
!      n_gcm :: INT, IN
!      S,sZ,sPZP :: MAT{REAL}, IN
!      met :: INT, optional, IN
!      PPZPP :: MAT{REAL}, optional, IN
!
!      c :: REAL
!      i,j,k :: INT
!      R,D,PDP,PPDPP,Ac,T,TX,X,buco :: MAT{CPX}*
!      WW,W2 :: MAT{REAL}*
!      A,B,Z,PZP :: MAT{REAL}*
!      M :: MAT{REAL}*
!
!      !!!  the density operator X !!!
!      R.create(.n_prim,.n_prim)
!
!      ! it do not exist in the moment
!      select case (met)
!         case(1)
!            .XTAL:make_primitive_FT_mx(R,xx,yy,zz)
!         case default
!            DIE("unknown value of method ")
!      end
!
!      D.create(n_gcm,n_gcm)
!      ! put the potential energy matrix into the n_gcm non-redundant space
!      .REL:get_da_gcm_now(R,D,m_out)
!
!      Ac.create(n_gcm,n_gcm)
!      Ac.to_product_of(YU,D,transpose_a=TRUE)
!      D.to_product_of(Ac,YU)
!
!      !!!  PDP MATRIX  !!!
!      select case (met)
!         case(1)
!            .REL:make_primitive_pftp_mx(R,xx,yy,zz)
!         case default
!            DIE("unknown value of method ")
!      end
!
!     PDP.create(n_gcm,n_gcm)
!     .REL:get_da_gcm_now(R,PDP,m_out)
!     Ac.to_product_of(YU,PDP,transpose_a=TRUE)
!     PDP.to_product_of(Ac,YU)
!
!     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
!        DIE("the <ppftpp> are not finished switch the use_ppzpp off")
!     end if
!
!     !!! A-O LETS GO !!!
!
!     c = SPEED_OF_LIGHT_AU
!     do i=1,n_gcm
!     do j=1,n_gcm
!        D(i,j)   = Ap(i)*D(i,j)*Ap(j)
!        PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))
!     end
!     end
!
!     A.create(n_gcm,n_gcm)
!     B.create(n_gcm,n_gcm)
!
!     if (.scfdata.DK1_PCE) then
!
!        A = ZERO
!        B = ZERO
!
!        do i = 1,n_gcm
!           B(i,i)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
!           A(i,i)=ONE/B(i,i)
!        end do
!
!        T.create(n_gcm,n_gcm)
!        T = matmul(sPZP, matmul(A,PDP) )
!        T = T - matmul(sPZP,D)
!        T = T - matmul(sZ,PDP)
!        T = T + matmul(sZ, matmul(B,D) )
!        T = T + matmul(D, matmul(B,sZ) )
!        T = T - matmul(PDP,sZ)
!        T = T - matmul(D,sPZP)
!        T = T + matmul(PDP, matmul(A,sPZP) )
!
!        if(.scfdata.using_SO_FDFF) then
!           DIE("using_SO_FDFF not to be used with PCE corr of ft ")
!        end if
!
!        if (.scfdata.DK2_PCE) then
!
!           !!! W1W1
!           X.create(n_gcm,n_gcm)
!           TX.create(n_gcm,n_gcm)
!           WW.create(n_gcm,n_gcm)
!
!           WW =    - matmul(sZ, matmul(B,sZ) )
!           WW = WW + matmul(sPZP,sZ)
!           WW = WW + matmul(sZ,sPZP)
!           WW = WW - matmul(sPZP, matmul(A,sPZP) )
!
!
!           X  = D + PDP
!           TX = HALF*(matmul(WW,X)+matmul(X,WW))
!
!           WW.destroy
!
!           Z.create(n_gcm,n_gcm)
!           PZP.create(n_gcm,n_gcm)
!
!           if (.scfdata.using_ppzpp) then
!
!              ! use the second derivatives in the [W1,[W1,X(even,0)]]
!              ! and [W2,X(odd,0)] terms
!
!              do i=1,n_gcm
!              do j=1,n_gcm
!                 PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 )
!                 Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
!                 PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
!              end do
!              end do
!
!              X  = PPDPP + PDP
!              TX = TX - matmul(sPZP,matmul(A,matmul(X,sZ)))
!              TX = TX + matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
!              TX = TX + matmul(sZ,matmul(X,sZ))
!              TX = TX - matmul(sZ,matmul(X, matmul(A,sPZP)))
!              PPDPP.destroy
!              X.destroy
!
!              !!!  The -[W2,X(odd,0)] terms
!              W2.create(n_gcm,n_gcm)
!              W2 = ZERO
!              do i = 1,n_gcm
!              do j = 1,n_gcm
!              do k = 1,n_gcm
!                 W2(i,j) = W2(i,j)                        &
!                    + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
!                    - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
!                    - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)  &
!                    + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!              end do
!              TX = TX + matmul(W2,PDP)
!
!              W2=ZERO
!              do i=1,n_gcm
!              do j=1,n_gcm
!              do k=1,n_gcm
!                 W2(i,j) = W2(i,j)                        &
!                    + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                    - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                    - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
!                    + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!              end do
!              TX = TX + matmul(PDP,W2)
!
!              W2=ZERO
!              do i=1,n_gcm
!              do j=1,n_gcm
!              do k=1,n_gcm
!                 W2(i,j) = W2(i,j)                        &
!                    -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                    +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
!                    +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
!                    -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!              end do
!              TX = TX + matmul(D,W2)
!
!              W2=ZERO
!              do i=1,n_gcm
!              do j=1,n_gcm
!              do k=1,n_gcm
!                 W2(i,j) = W2(i,j)                         &
!                   -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
!                   +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
!                   +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
!                   -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)
!              end do
!              end do
!              end do
!              TX = TX + matmul(W2,D)
!
!           else
!
!              ! the second derivatives are not used in the
!              ! [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms
!
!              X.destroy
!              do i=1,n_gcm
!              do j=1,n_gcm
!                 Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
!                 PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
!              end do
!              end do
!
!              TX = TX - matmul(sPZP,matmul(A,matmul(PDP,sZ)))
!              TX = TX - matmul(sPZP,matmul(D,matmul(B,sZ)))
!              TX = TX + matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
!              TX = TX + matmul(sPZP, matmul(D,sPZP))
!              TX = TX + matmul(sZ,matmul(PDP,sZ))
!              TX = TX + matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
!              TX = TX - matmul(sZ,matmul(PDP, matmul(A,sPZP)))
!              TX = TX - matmul(sZ,matmul(B, matmul(D,sPZP)))
!
!              !!!  The [W2,X(odd,0)] terms
!              !   the second derivatives are not used
!              W2.create(n_gcm,n_gcm)
!              W2 = ZERO
!              W2 =    matmul( sPZP, matmul(A, matmul(PZP,A) ) )
!              W2 = W2 + matmul( sPZP, Z )
!              W2 = W2 - matmul( sZ, ( matmul(PZP,A) ) )
!              W2 = W2 - matmul( sZ, ( matmul(B,Z) ) )
!              W2 = W2 - matmul( Z,  matmul(sPZP,A)  )
!              W2 = W2 - matmul( PZP,  matmul(sPZP,A)  )
!              W2 = W2 + matmul( Z,  sZ  )
!              W2 = W2 + matmul( PZP,  sZ  )
!              do i=1,n_gcm
!              do j=1,n_gcm
!                 W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!
!              TX = TX + matmul(W2,PDP)
!
!              W2 = ZERO
!              W2 =    matmul( sZ, Z )
!              W2 = W2 + matmul( sZ, PZP )
!              W2 = W2 - matmul( matmul(A,sPZP), Z )
!              W2 = W2 - matmul( matmul(A,sPZP), PZP )
!              W2 = W2 - matmul( matmul(A,PZP)  ,   sZ)
!              W2 = W2 - matmul( matmul(Z,B)  ,   sZ)
!              W2 = W2 + matmul( matmul(A,matmul(PZP,A)) , sPZP)
!              W2 = W2 + matmul( Z , sPZP)
!              do i=1,n_gcm
!              do j=1,n_gcm
!                 W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!
!              TX = TX +matmul(PDP,W2)
!
!              W2 = ZERO
!              W2 = W2 - matmul( matmul(B,sZ), Z )
!              W2 = W2 - matmul( matmul(B,sZ), PZP )
!              W2 = W2 + matmul( sPZP  ,   Z )
!              W2 = W2 + matmul( sPZP  , PZP )
!              W2 = W2 + matmul( PZP   ,  sZ )
!              W2 = W2 + matmul( matmul(B,matmul(Z,B)) , sZ)
!              W2 = W2 - matmul( matmul(PZP,A) , sPZP )
!              W2 = W2 - matmul( matmul(B,Z) , sPZP )
!              do i=1,n_gcm
!              do j=1,n_gcm
!                 W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!
!              TX = TX + matmul(D,W2)
!
!              W2 = ZERO
!              W2 = W2 - matmul( sPZP  , matmul(A,PZP) )
!              W2 = W2 - matmul( sPZP  , matmul(Z,B) )
!              W2 = W2 + matmul( sZ    , PZP)
!              W2 = W2 + matmul( sZ    , matmul( B, matmul(Z,B) ) )
!              W2 = W2 + matmul( Z , sPZP  )
!              W2 = W2 + matmul( PZP , sPZP  )
!              W2 = W2 - matmul( Z ,  matmul(sZ,B) )
!              W2 = W2 - matmul( PZP ,  matmul(sZ,B) )
!              do i=1,n_gcm
!              do j=1,n_gcm
!                 W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) )
!              end do
!              end do
!
!              TX = TX + matmul(W2,D)
!
!            end if
!
!            W2.destroy
!            Z.destroy
!            PZP.destroy
!
!         end if
!      end if
!
!      A.destroy
!
!      D = D + PDP
!      PDP.destroy
!
!      if (.scfdata.DK1_PCE) then
!         D = D + T
!         T.destroy
!      end if
!
!      if(.scfdata.DK2_PCE)then
!         D = D + TX
!         TX.destroy
!      end if
!
!      B.to_product_of(S,YU)
!
!      Ac.to_product_of(B,D)
!      D.to_product_of(Ac,B,transpose_b=TRUE)
!
!      Ac.destroy
!      B.destroy
!
!      !!! moving back to tonto style primitive basis sets
!      ! put the Fock matrix back to the space .n_prim space
!      .REL:get_back_prim_now(D,R,m_out)
!      D.destroy
!
!      !!! moving back to contracted basis sets
!      M.create(.n_prim,.n_bf)
!      .BASE:make_normalised_contraction_mx(M)
!      buco.create(.n_bf,.n_prim)
!      buco.to_product_of(M,R,transpose_a=TRUE)
!      R.destroy
!
!      GG.to_product_of(buco,M)
!
!      M.destroy
!      buco.destroy
!
!   end

!   make_FT_IOTC(sf,D,k_pts)
!   ! make the PCE corrected structure factors
!   !
!       sf :: VEC{CPX}
!       D :: MAT{REAL}, IN
!       k_pts :: MAT{REAL}, IN
!       n_gcm :: INT
!       n,i,j,k,k_max :: INT
!       g :: CPX
!       c,alpha,alpha2 :: REAL
!       m_out :: MAT{INT}*
!       FT_hkl :: MAT{CPX}*
!       Y,U,YU,T,A,S,R,Z,PZP :: MAT{REAL}*
!       Yr,O,SOx,SOy,SOz :: MAT{REAL}*
!       P2,Ap,E,p,ep,bp :: VEC{REAL}*
!
!      k_max = size(k_pts,1)
!      ! the method is for the PCE corr is sfs
!     R.create(.n_prim,.n_prim)
!    .REL:make_primitive_overlap_mx(R)
!     m_out.create(.n_prim,.n_prim)
!    .REL:make_ready_da_gcm_tr2(m_out,n_gcm)
!!    .make_ready_da_gcm_tr(R,m_out,n_gcm)
!! put the overlap matrix into the n_gcm non-redundant space
!     S.create(n_gcm,n_gcm)
!     .REL:get_da_gcm_now(R,S,m_out)
!
!     Y.create(n_gcm,n_gcm)
!     Y.to_inverse_sqrt_of(S)
!
!!!!  KINETIC ENERGY MATRIX !!!
!     R=ZERO
!     .REL:make_primitive_kinetic_mx(R)
!     T.create(n_gcm,n_gcm)
!! put the kinetic energy matrix into the n_gcm non-redundant space
!     .REL:get_da_gcm_now(R,T,m_out)
!
!     A.create(n_gcm,n_gcm)
!     A.to_product_of(Y,T)
!     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
!     U.create(n_gcm,n_gcm)
!     P2.create(n_gcm)
!     T.solve_symmetric_eigenproblem(P2,U)
!     P2= TWO * P2
!     YU.create(n_gcm,n_gcm)
!     YU.to_product_of(Y,U)
!     T.destroy
!     Y.destroy
!     U.destroy
!
!!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
!     R=ZERO
!     .REL:make_primitive_nuclear_mx(R)
!     Z.create(n_gcm,n_gcm)
!! put the potential energy matrix into the n_gcm non-redundant space
!     .REL:get_da_gcm_now(R,Z,m_out)
!
!     A.to_product_of(YU,Z,transpose_a=TRUE)
!     Z.to_product_of(A,YU)
!
!!!!  PZP MATRIX  !!!
!     SOx.create(.n_prim,.n_prim)
!     SOy.create(.n_prim,.n_prim)
!     SOz.create(.n_prim,.n_prim)
!     R=ZERO
!         .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
!       SOx.destroy
!       SOy.destroy
!       SOz.destroy
!
!     PZP.create(n_gcm,n_gcm)
!! put the PZP matrix into the n_gcm non-redundant space
!     .REL:get_da_gcm_now(R,PZP,m_out)
!
!     A.to_product_of(YU,PZP,transpose_a=TRUE)
!     PZP.to_product_of(A,YU)
!     R.destroy
!
!!!! A-O LETS GO !!!
!     c = SPEED_OF_LIGHT_AU
!     alpha = ONE/c
!     alpha2= alpha*alpha
!
!     E.create(n_gcm)
!     p.create(n_gcm)
!     ep.create(n_gcm)
!     Ap.create(n_gcm)
!     bp.create(n_gcm)
!
!     E=ZERO
!     p=ZERO
!     ep=ZERO
!     Ap=ZERO
!     bp=ZERO
!
!     do i = 1,n_gcm
!
!       E(i)= c * sqrt(P2(i) + c * c)
!       p(i)=sqrt(P2(i))
!       ep(i)=sqrt(ONE+P2(i)*alpha2)
!       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )
!       bp(i)=ONE/(ep(i)+ONE)
!
!     end
!    P2.destroy
!
!     do i=1,n_gcm
!       do j=1,n_gcm
!
!        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
!        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
!
!       end
!     end
!
!     Yr.create(n_gcm,n_gcm)
!     Yr=ZERO
!
!    .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
!
!     ! The normalzation matrix
!     O.create(n_gcm,n_gcm)
!     O=ZERO
!     do i=1,n_gcm
!       O(i,i)=ONE
!       do j=1,n_gcm
!         do k=1,n_gcm
!           O(i,j)=O(i,j)+Yr(k,i)*Yr(k,j)
!         end do
!       end do
!     end do
!
!     A.to_inverse_sqrt_of(O)
!     O=A
!     Z.destroy
!     PZP.destroy
!     A.destroy
!
!! hkl ft starts here
!     FT_hkl.create(.n_bf,.n_bf)
!     sf=(ZERO,ZERO)
!     FT_hkl=(ZERO,ZERO)
!
!     parallel do n = 1,k_max
!        FT_hkl=(ZERO,ZERO)
!       .XTAL:make_IOTC_FT_PCE_off(FT_hkl,Yr,YU,Ap,bp,p,k_pts(n,1),k_pts(n,2),k_pts(n,3),m_out,n_gcm,S,O)
!
!       .XTAL:make_part_and_therm_smear(FT_hkl,k_pts(n,:))
!
!        g=(ZERO,ZERO) !???
!
!        do i=1,.n_bf
!           do j=1,.n_bf
!               g = g + D(i,j)*FT_hkl(i,j)  !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
!           end do
!        end do
!
!        sf(n)=g
!     end
!
!     if (DO_IN_PARALLEL) then
!        PARALLEL_SUM(sf)
!     end
!
!
!    S.destroy
!    O.destroy
!    YU.destroy
!    Yr.destroy
!    Ap.destroy
!    E.destroy
!    p.destroy
!    bp.destroy
!    ep.destroy
!    m_out.destroy
!    FT_hkl.destroy
!
!   end

!   make_IOTC_FT_PCE_off(GG,Yr,YU,Ap,bp,p,xx,yy,zz,m_out,n_gcm,S,O)
!   ! correct the picture change
!   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
!   ! this routine is based on the make_r_DKH_mx(H) routine
!        GG :: MAT{CPX} , OUT
!        Yr,YU :: MAT{REAL}
!        Ap,bp,p :: VEC{REAL}
!        xx,yy,zz :: REAL
!        m_out :: MAT{INT}
!        n_gcm :: INT
!        S,O :: MAT{REAL}
!
!        i,j :: INT
!        D,PDP,R :: MAT{CPX}*
!        A,B,buco :: MAT{CPX}*
!        M :: MAT{REAL}*
!
!!!!  the density operator X !!!
!     R.create(.n_prim,.n_prim)
!     R=(ZERO,ZERO)
!! it do not exist in the moment
!     .XTAL:make_primitive_FT_mx(R,xx,yy,zz)
!     D.create(n_gcm,n_gcm)
!     D=(ZERO,ZERO)
!! put the potential energy matrix into the n_gcm non-redundant space
!     .REL:get_da_gcm_now(R,D,m_out)
!
!     A.create(n_gcm,n_gcm)
!     A.to_product_of(YU,D,transpose_a=TRUE)
!     D.to_product_of(A,YU)
!
!!!!  PDP MATRIX  !!!
!     R=(ZERO,ZERO)
!     .XTAL:make_primitive_pftp_mx(R,xx,yy,zz)
!
!     PDP.create(n_gcm,n_gcm)
!     PDP=(ZERO,ZERO)
!! put the PDP matrix into the n_gcm non-redundant space
!     .REL:get_da_gcm_now(R,PDP,m_out)
!     A=(ZERO,ZERO)
!     A.to_product_of(YU,PDP,transpose_a=TRUE)
!     PDP.to_product_of(A,YU)
!
!!   if( .scfdata.using_ppzpp)then
!!      R=(ZERO,ZERO)
!!      .make_primitive_ppDpp_mx(R,xx,yy,zz)
!!      PPDPP.create(n_gcm,n_gcm)
!!      .get_da_gcm_now(R,PPDPP,m_out)
!!      A=(ZERO,ZERO)
!!      A.to_product_of(YU,PPDPP,transpose_a=TRUE)
!!      PPDPP.to_product_of(A,YU)
!!  end if
!
!!!! A-O LETS GO !!!
!
!     do i=1,n_gcm
!       do j=1,n_gcm
!
!        D(i,j) = Ap(i)*D(i,j)*Ap(j)
!        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
!
!       end
!     end
!
!     B.create(n_gcm,n_gcm)
!     B=(ZERO,ZERO)
!     ::build_da_IOTC_ft(B,Yr,PDP,D,p,bp,n_gcm)
!
!     D=(ZERO,ZERO)
!     A.to_product_of(O,B)
!     D.to_product_of(A,O)
!
!     PDP.destroy
!
!     B=(ZERO,ZERO)
!     B.to_product_of(S,YU)
!
!     A=(ZERO,ZERO)
!     A.to_product_of(B,D)
!     D.to_product_of(A,B,transpose_b=TRUE)
!
!     A.destroy
!     B.destroy
!
!!!! moving back to tonto style primitive basis sets
!     R=(ZERO,ZERO)
!! put the Fock matrix back to the space .n_prim space
!     .REL:get_back_prim_now(D,R,m_out)
!     D.destroy
!
!!!! moving back to contracted basis sets
!     M.create(.n_prim,.n_bf)
!     .BASE:make_normalised_contraction_mx(M)
!     buco.create(.n_bf,.n_prim)
!     buco.to_product_of(M,R,transpose_a=TRUE)
!     R.destroy
!
!     GG.to_product_of(buco,M)
!
!     M.destroy
!     buco.destroy
!   end

!   build_da_IOTC_ft(F,Yr,PAP,A,p,bp,n_gcm) ::: selfless
!   ! build the IOTC Y matrix
!      F :: MAT{CPX}, OUT
!      Yr :: MAT{REAL}, IN
!      PAP,A :: MAT{CPX}, IN
!      p,bp :: VEC{REAL}, IN
!      n_gcm :: INT, IN
!
!      i,j,dim :: INT
!      c,alpha,alpha2,alpha3,alpha4 :: REAL
!      AAA,F1R,F1L,F2 :: MAT{CPX}*
!
!      c = SPEED_OF_LIGHT_AU
!      alpha = ONE/c
!      alpha2= alpha*alpha
!      alpha3= alpha2*alpha
!      alpha4= alpha3*alpha
!
!      dim=n_gcm
!
!      F1L.create(dim,dim);F1R.create(dim,dim);F2.create(dim,dim)
!      AAA.create(dim,dim)
!
!      do i = 1,dim
!      do j = 1,dim
!        AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
!      end do
!      end do
!
!      do i = 1,dim
!      do j = 1,dim
!         F(i,j)   =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
!         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )
!         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
!         F2(i,j)  =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
!      end
!      end
!
!     AAA.to_product_of(Yr,F1L,transpose_a=TRUE)
!     F = F + AAA + matmul(F1R,Yr)
!     AAA.to_product_of(Yr,F2,transpose_a=TRUE)
!     F = F + matmul(AAA,Yr)
!
!     AAA.destroy
!
!     F1L.destroy
!     F1R.destroy
!     F2.destroy
!
!   end


!   make_primitive_FT_mx(FT,h1,h2,h3) ::: PURE
!   ! The primitive "FT" matrix for a reflection [h1,h2,h3]
!      self :: IN
!      FT   :: MAT{CPX}, OUT
!      h1,h2,h3 :: REAL, IN
!
!   ENSURE(FT.is_square, "FT must be square")
!   ENSURE(FT.dim1==.n_prim, "wrong size, FT")
!
!     frst,last,at,l :: VEC{INT}@
!     ex :: VEC{REAL}@
!     FT_ab :: MAT{CPX}@
!     nps,a,b,fa,la,fb,lb :: INT
!     G :: GAUSSIAN2
!     p,t :: REAL
!     k_vec :: VEC{REAL}(3)
!
!     ! Make the indexing arrays
!     .atom.make_primitive_limits(frst,last,at,l,ex)
!
!     nps = frst.dim
!
!     do a = 1,nps
!
!        G.a.set_l(l(a))
!        G.a.set_position(.atom(at(a)).position)
!        G.a.set_exponent(ex(a))
!        fa = frst(a)
!        la = last(a)
!
!        do b = 1,a
!
!           G.b.set_l(l(b))
!           G.b.set_position(.atom(at(b)).position)
!           G.b.set_exponent(ex(b))
!           fb = frst(b)
!           lb = last(b)
!
!           ! Partitioning and thermal smearing
!           ! part=gaussian / thermal=tanaka are done here
!           select case (trim(.crystal.temperature_factor_model))
!
!           case ("none     ")
!              p = ONE
!
!           case ("tc-tanaka") 
!              ! tf = exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
!              k_vec = [h1, h2, h3]
!              .XTAL:thermal_Tanaka(p,G,k_vec,a,b)
!
!           end
!
!           t = ONE
!
!           FT_ab.create(la-fa+1,lb-fb+1)
!           FT_ab = (ZERO,ZERO)
!
!           if ((fa-la)==0 AND (fb-lb)==0) then
!              G.make_normalised_FT_00(FT_ab,h1,h2,h3)
!           else
!              ! Cleaner newer version
!              G.make_normalised_FT_v2(FT_ab,h1,h2,h3,.use_spherical_basis) 
!           end if
!
!           ! Perhaps the thermal smearing should come after building
!           ! the whole sf-matrix?
!           FT(fa:la,fb:lb) = FT_ab*p*t
!
!           FT_ab.destroy
!
!        end
!
!     end
!
!     ! Clean up indexing arrays
!     ex.destroy
!     l.destroy
!     at.destroy
!     last.destroy
!     frst.destroy
!
!     ! Make a symmetric matrix
!     FT.symmetric_reflect
!
!   end

!   make_primitive_pftp_mx(FT,h1,h2,h3) ::: PURE
!   ! The primitive "FT" matrix for reflection [h1,h2,h3]
!      self :: IN
!      FT   :: MAT{CPX}, OUT
!      h1,h2,h3 :: REAL, IN
!
!   ENSURE(FT.is_square, "ft must be square")
!   ENSURE(FT.dim1==.n_prim, "wrong size, ft")
!
!     frst,last,at,l :: VEC{INT}@
!     ex :: VEC{REAL}@
!     FT_ab :: MAT{CPX}@
!     nps,a,b,fa,la,fb,lb :: INT
!     G :: GAUSSIAN2
!     p,t :: REAL
!
!     ! Make the indexing arrays
!     .atom.make_primitive_limits(frst,last,at,l,ex)
!
!     nps = frst.dim
!
!     do a = 1,nps
!
!        G.a.set_l(l(a))
!        G.a.set_position(.atom(at(a)).position)
!        G.a.set_exponent(ex(a))
!        fa = frst(a)
!        la = last(a)
!
!        do b = 1,a
!
!           G.b.set_l(l(b))
!           G.b.set_position(.atom(at(b)).position)
!           G.b.set_exponent(ex(b))
!           fb = frst(b)
!           lb = last(b)
!
!           ! partitioning and thermal smearing
!           p = ONE
!           t = ONE
!
!           FT_ab.create(la-fa+1,lb-fb+1)
!           FT_ab = (ZERO,ZERO)
!
!           G.make_normalised_pftp_v2(FT_ab,h1,h2,h3,.use_spherical_basis) ! cleaner newer version
!
!           ! Perhaps the thermal smearing should come after building
!           ! the whole sf-matrix?
!           FT(fa:la,fb:lb) = FT_ab*p*t
!
!           FT_ab.destroy
!
!        end
!
!     end
!
!     ! Clean up indexing arrays
!     ex.destroy
!     l.destroy
!     at.destroy
!     last.destroy
!     frst.destroy
!
!     ! Make a symmetric matrix
!     FT.symmetric_reflect
!
!   end

!   make_part_and_therm_smear(FT,k_vec) ::: PURE
!   ! Calculate the primitive "FT" matrix for reflection "k_vec"
!      self  :: IN
!      FT    :: MAT{CPX}, OUT
!      k_vec :: VEC{REAL}, IN
!
!      q,fa,la,na,fb,lb,nb,atom_a,atom_b,ag,bg :: INT
!      sh :: SHELL2
!      is_zero :: BIN
!      t :: MAT{REAL}@
!      p :: MAT{REAL}@
!
!      do q = 1,.n_shell_pairs
!
!         .SET:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)
!
!         p.create(la-fa+1,lb-fb+1)
!         .XTAL":make_partition_factors(p,sh,atom_a,atom_b,is_zero)
!
!         t.create(la-fa+1,lb-fb+1)
!         .XTAL:make_PCE_temperature_factors(t,k_vec,atom_a,atom_b)
!
!         do bg = 1,lb-fb+1
!         do ag = 1,la-fa+1
!            FT(fa-1+ag,fb-1+bg) = FT(fa-1+ag,fb-1+bg)*p(ag,bg)*t(ag,bg)
!         end do
!         end do
!
!
!         t.destroy
!         p.destroy
!         sh.destroy_ptr_part
!
!      end do
!
!      FT.symmetric_reflect
!
!   end

!   make_PCE_temperature_factors(res,k_vec,a,b) ::: PURE
!   ! Makes the thermal smearing correction term.  Note that res is
!   ! done over the contraction coefficients. Dimensions of "res"
!   ! are [.a.n_cc,.b.n_cc].
!      self :: IN
!      res :: MAT{REAL}, OUT
!      k_vec :: VEC{REAL}, IN
!      a,b :: INT, IN
!
!      Ua,Ub,Uab :: MAT{REAL}(3,3)
!      S,US :: VEC{REAL}(3)
!      separation,bondlength,Ta,Tb,g :: REAL
!      diff :: VEC{REAL}(3)
!
!      select case (trim(.crystal.temperature_factor_model))
!
!      case ("none      ")
!         res = ONE
!
!      case ("tc-coppens") 
!         ! tf = HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
!         Ua = -HALF * .atom(a).ADP_tensor
!         Ub = -HALF * .atom(b).ADP_tensor
!         S  = k_vec(:)
!         US = matmul(Ua,S); Ta = S.dot(US)
!         US = matmul(Ub,S); Tb = S.dot(US)
!         res = HALF*(exp(Ta)+exp(Tb))
!
!      case ("tc-stewart") 
!         ! tf = exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4]
!         bondlength = 2.5
!         Ua = .atom(a).ADP_tensor
!         Ub = .atom(b).ADP_tensor
!         Uab = Ua + Ub
!         diff = .atom(a).position-.atom(b).position
!         separation = diff.norm
!         g = HALF
!         if (separation>bondlength) g=QUARTER
!         Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
!         S = k_vec(:)
!         US = matmul(Uab,S)
!         Ta = S.dot(US)
!         res = exp(Ta)
!
!    ! case default
!    !    DIE("unknown model:"//trim(.crystal.temperature_factor_model))
!
!      end
!
!   end

!   thermal_Tanaka(res,G,k_vec,a,b) ::: PURE
!   ! Makes the thermal smearing correction term.  Note that res is
!   ! done over the contraction coefficients. Dimensions of "res"
!   ! are [.a.n_cc,.b.n_cc].
!      self  :: IN
!      res   :: REAL, OUT
!      G     :: GAUSSIAN2, IN
!      k_vec :: VEC{REAL}, IN
!      a,b   :: INT, IN
!
!      Ua,Ub :: MAT{REAL}(3,3)
!      ea,eb,U11,U22,U33,U21_12,U31_13,U32_23 :: REAL
!      U,Ub_eb,Ua_ea :: MAT{REAL}(3,3)
!      S1,S2,S3 :: REAL
!
!      !!  WARN("tanaka model is going in the ordinary way, not sure about any PCE in it !!!")
!      !!  stdout.flush
!      Ua = .atom(a).ADP_tensor
!      Ub = .atom(b).ADP_tensor
!
!      ! It is currently a problem without atom_data
!      !  ea = G.a.set_exponent(ex(a))
!      ea = G.a.exponent
!      Ua_ea = ea * Ua
!
!      eb = G.b.exponent
!      Ub_eb = eb * Ub
!
!      U = - HALF * (Ua_ea + Ub_eb) / (ea + eb)
!
!      U11    = U(1,1)
!      U22    = U(2,2)
!      U33    = U(3,3)
!      U21_12 = U(2,1) + U(1,2)
!      U31_13 = U(3,1) + U(1,3)
!      U32_23 = U(3,2) + U(2,3)
!
!      S1 = k_vec(1)
!      S2 = k_vec(2)
!      S3 = k_vec(3)
!
!      ! S.U.S has been expanded to save multiplies and array accesses.
!      res = exp(S1*(S1*U11+S2*U21_12+S3*U31_13)+S2*(S2*U22+S3*U32_23)+S3*S3*U33)
!
!   end

end

