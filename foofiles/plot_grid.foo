!---------------------------------------------------------------------
!
! PLOT_GRID: for cartesian grid generation, e.g. for plots or surfaces.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------

module PLOT_GRID

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   create(atom) ::: leaky
   ! Create object
      self :: PTR
      atom :: VEC{ATOM}*

      .create
      .set_atom_defaults(atom)

   end

   create_copy(grid) ::: leaky
   ! Create a grid object which is a duplicate of grid.
      self :: PTR
      grid :: PLOT_GRID, IN
      .create
      .copy(grid)
   end

   copy(grid)
   ! Copy the contents of grid to self.
      grid :: PLOT_GRID, IN
      self = grid
      .nullify_ptr_part
      if (grid.atom.associated)              .atom.copy(grid.atom)
      if (grid.bond_density_atom.associated) .bond_density_atom.copy(grid.bond_density_atom)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part ::: pure
   ! Nullify the pointer parts
      self :: INOUT

      nullify(.plot_kinds)
      nullify(.plot_kinds_units)

      nullify(.atom)
      nullify(.center_atoms)
      nullify(.bond_density_atom)

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts

      .plot_kinds.destroy
      .plot_kinds_units.destroy

      nullify(.atom) ! do not destroy
      .center_atoms.destroy
      .bond_density_atom.destroy

   end

!  ============
!  Set routines
!  ============

   set_defaults ::: PURE
   ! Set up a default grid.
      self :: INOUT

      .plot_kind             = " "
                             
      .orbital               = 0
      .HOMO_orbital          = 0
      .LUMO_orbital          = -1

      .projection_direction  = [ZERO,ZERO,ZERO]

      .center                = ZERO
      .offset                = ZERO
      .center_atom           = 0
                             
      .x_atom_1              = 0
      .x_atom_2              = 0
      .y_atom_1              = 0
      .y_atom_2              = 0
                             
      .x_axis(:)             = PLOT_GRID_X_AXIS
      .y_axis(:)             = PLOT_GRID_Y_AXIS
      .z_axis(:)             = PLOT_GRID_Z_AXIS
                             
      .n_x                   = PLOT_GRID_NX
      .n_y                   = PLOT_GRID_NY
      .n_z                   = PLOT_GRID_NZ
      .width(:)              = PLOT_GRID_WIDTH
      .width(3)              = ZERO    ! assume a planar plot
      .del_x                 = .width(1)/(PLOT_GRID_NX - 1)
      .del_y                 = .del_x
      .del_z                 = .del_x
      .x_width_set           = FALSE   ! These are set false only if the widths
      .y_width_set           = FALSE   ! are explicitly read in
      .z_width_set           = FALSE

      .use_bounding_box      = FALSE
      .box_center            = ZERO
      .box_widths            = PLOT_GRID_WIDTH
      .box_scale_factor      = ONE
      .box_axes(:,1)         = PLOT_GRID_X_AXIS
      .box_axes(:,2)         = PLOT_GRID_Y_AXIS
      .box_axes(:,3)         = PLOT_GRID_Z_AXIS
      .use_unit_cell_as_bbox = FALSE

      .origin_atom           = FALSE

      .x_axis_defined        = FALSE
      .y_axis_defined        = FALSE
      .z_axis_defined        = FALSE
                             
      .desired_separation    = ZERO
      .points_filename       = "no_made-up_points"
                             
      .plot_units            = " "
      .plot_format           = " "
                             
      .use_plot_max          = FALSE
      .use_plot_min          = FALSE
      .plot_max              = ZERO
      .plot_min              = ZERO
                             
      .contour_min_value     = ZERO
      .contour_max_value     = ZERO

      .contour_min_color.set([253,114,121])
      .contour_mid_color.set([255,255,255])
      .contour_max_color.set([125,114,216])
      .contour_color_scale   = " "

      .contour_scale         = "log"
      .contour_increment     = ZERO
      .contour_line_width    = 1.25d0
      .contour_fade_factor   = 0.8d0
      .contour_tic_dps       = 2
      .contour_font_size     = 9
      .use_colorbox_scale    = TRUE
      .use_ruler_scale       = TRUE

      nullify(.atom)
      nullify(.bond_density_atom)

   end

   set_defaults(atom) ::: public
   ! Set up atom defaults. "atom" is used to define an xyz bounding
   ! box for the molecule.
      self :: INOUT
      atom :: VEC{ATOM}*

      .set_defaults
      .set_atom_defaults(atom)

   end

   reset_defaults ::: PURE
   ! Reset a default grid. The only difference to set_defaults is that
   ! the bounding box and box_axes are not set again.
      self :: INOUT

      .plot_kind      = " "

      .orbital        = 0
      .HOMO_orbital   = 0
      .LUMO_orbital   = -1

      .center         = ZERO
      .offset         = ZERO
      .center_atom    = 0

      .x_atom_1       = 0
      .x_atom_2       = 0
      .y_atom_1       = 0
      .y_atom_2       = 0

      .n_x            = PLOT_GRID_NX
      .n_y            = PLOT_GRID_NY
      .n_z            = PLOT_GRID_NZ
      .width          = PLOT_GRID_WIDTH
      .width(3)       = ZERO    ! assume a planar plot

      .del_x          = .width(1)/(PLOT_GRID_NX - 1)
      .del_y          = .del_x
      .del_z          = .del_x

      .x_width_set    = FALSE   ! These are set TRUE only if the widths
      .y_width_set    = FALSE   ! are explicitly read in
      .z_width_set    = FALSE

      .x_axis_defined = FALSE
      .y_axis_defined = FALSE
      .z_axis_defined = FALSE

      .desired_separation = ZERO

      .origin_atom        = FALSE
                         
      .plot_units         = " "
      .plot_format        = " "
      .points_filename    = "no_made-up_points"

   end

   set_for_marching_cubes ::: PURE
   ! Update and set the grid data to be consistent with the
   ! (non-recursive) marching cubes algorithm. Essentially, a
   ! gridpoint is added along all dimensions.
      self :: INOUT

      .n_x = .n_x + 2
      .n_y = .n_y + 2
      .n_z = .n_z + 2

   ENSURE(.n_x>=4,"not enough x points for marching cube isosurface algorithm")
   ENSURE(.n_y>=4,"not enough y points for marching cube isosurface algorithm")
   ENSURE(.n_z>=4,"not enough z points for marching cube isosurface algorithm")

      ! center remains the same, extra points added around edges
      .width(1)  = .width(1)  + 2*.del_x
      .width(2)  = .width(2)  + 2*.del_y
      .width(3)  = .width(3)  + 2*.del_z

      .origin = .origin - .del_x*.x_axis
      .origin = .origin - .del_y*.y_axis
      .origin = .origin - .del_z*.z_axis

      .n_pt = .n_x*.n_y*.n_z

   end

   set_plot_label(label) ::: pure
   ! Set the plot label.
      self :: INOUT
      label :: STR, IN

      .plot_label = label

   end

   set_plot_kind(kind) ::: PURE
   ! Set the plot kind to be a certain "kind"
      self :: INOUT
      kind :: STR, IN

      .plot_kind = kind
      .plot_kind.to_lower_case

   end

   set_plot_format(plot_format)
   ! Set the plot kind to be a certain "kind"
      self :: INOUT
      plot_format :: STR, IN

      .plot_format = plot_format
      .plot_format.to_lower_case
      select case (.plot_format)
         case ("all")
         case ("contour")
         case ("cube")
         case ("drishti")
         case ("gaussian")
         case ("gaussian.cube")
         case ("cell.cube")
         case ("gnuplot")
         case ("gnuplot.contour")
         case ("gnuplot.log_contour")
         case ("gnuplot.pos_log_contour")
         case ("mathematica")
         case ("spackman")
         case ("vapor")
         case ("vtk")
         case ("xcrysden")
         case ("xdgraph")
         case default; UNKNOWN(.plot_format)
      end

   end

   set_plot_units(units) ::: PURE
   ! Set the plot "units".
      self :: INOUT
      units :: STR, IN

      .plot_units = units
      .plot_units.to_lower_case

      ENSURE(.plot_units.is_known_unit,"unknown unit specified")

   end

   set_atom_defaults(atom) ::: PURE
   ! Set up atom defaults. "atom" is used to define an xyz bounding
   ! box for the molecule.
      self :: INOUT
      atom :: VEC{ATOM}*

      if (associated(atom)) then
         .atom => atom
         .set_bbox_with_shape_axes(atom)
      end

   end

   set_bbox_with_current_axes(atom) ::: PURE
   ! Set a bounding box to the plot axes, with the current center,
   ! with widths based on the "atom" list. NOTE: This is activated
   ! with the use_bounding_box_and_axes= option.
      self :: INOUT
      atom :: VEC{ATOM}, IN

   ENSURE(.x_or_y_or_z_axes_defined,"you must have already defined some axes!")

      sa :: MAT{REAL}(3,3)

      .use_bounding_box = TRUE

      ! Make shape moments and axes; keep order
      sa = .plot_axes

      ! Set box axes/center
      .box_axes   = sa
      .box_center = .center

      ! Set bounding box
      .box_widths = atom.bounding_box_widths(sa)
      .box_widths = .box_scale_factor*.box_widths

   end

   set_bbox_with_shape_axes(atom) ::: PURE
   ! Set up a bounding box based on the "atom" list and ensure that
   ! the x-y-z axis widths x-y-z go longest to shortest.
   ! NOTE: This is set with a use_bounding_box_and_axes= option.
      self :: INOUT
      atom :: VEC{ATOM}, IN

   ENSURE(NOT .x_or_y_or_z_axes_defined,"you already defined some axes!")

      sm :: VEC{REAL}(3)
      sa :: MAT{REAL}(3,3)
      order :: VEC{INT}(3)

      .use_bounding_box = TRUE

      ! Make shape moments and axes; keep order
      atom.make_shape_moments(sm,sa)

      ! Set bounding box
      .box_widths = atom.bounding_box_widths(sa)
      .box_widths = .box_scale_factor*.box_widths

      ! Make the x-axis the longest
      .box_widths.quick_sort(order,decreasing_order=TRUE)

      ! Swap
      sm = sm(order)
      sa = sa(:,order)
      if (sa.determinant<ZERO) sa(:,3) = -sa(:,3)

      ! Set (swap) box axes/center 
      .box_widths = .box_widths(order)
      .box_axes   = sa
      .box_center = atom.center_of_atoms

   end

   set_points_widths_origin ::: pure
   ! Set the number of points along the x axis to be odd. Evaluate the
   ! grid point separation .del_x from the current x_width, .width(1);
   ! from this separation, evaluate the number of points along the y
   ! and z axes; adjust the y and z widths to be an exact multiple of
   ! .del_x; finally, set the origin once the widths are known.
      self :: INOUT

      ! Make # of x axis points odd ...
      .n_x = 2*(.n_x/2) + 1

      if (.n_x>1) then
         .del_x = .width(1)/(.n_x-1)
         .del_y = .del_x
         .del_z = .del_x
      else if (.n_x==1) then
         .width = ZERO
      end

      ! Adjust y width to the nearest grid point
      .n_y  = nint(.width(2)/.del_x)
      .n_y = 2*(.n_y/2) + 1
      .width(2) = .del_x*(.n_y-1)

      ! Adjust z width to the nearest grid point
      .n_z = nint(.width(3)/.del_x)
      .n_z = 2*(.n_z/2) + 1
      .width(3) = .del_x*(.n_z-1)

      .n_pt = .n_x*.n_y*.n_z

      .set_origin

   end

   set_desired_separation(del) ::: PURE
   ! Set the (approximate) desired separation "del" between grid points along an
   ! axis direction.  The *actual* separation used may not be the inputted
   ! separation, but may be slightly smaller: the current .x_width is used to
   ! work out the number of points along the x_axis which is then used to work
   ! out the actual .del.  NOTE: After this routine the y and z widths are
   ! changed to be the nearest multiple of "del" (actually, ".del") that exceeds
   ! their current value.
      self :: INOUT
      del :: REAL, IN

   ENSURE(del>0,"del must be positive")

      .desired_separation = del

      .n_x = ceiling(.width(1)/del)
      .n_y = ceiling(.width(2)/del)
      .n_z = ceiling(.width(3)/del)

      .set_points_widths_origin

   end

   set_center_from_atom_list(atom) ::: PURE
   ! Set the .center of the grid data from an "atom" list. The .origin of the
   ! plot isd also set using the current plot widths and plot center.
      self :: INOUT
      atom :: VEC{ATOM}, IN

   ENSURE(.center_atom/=0,"no center_atom")

      .center = atom(.center_atom).position

      .set_origin

   end

   set_offset_to_center_of(atom) ::: PURE
   ! Set the .offset to the center of an "atom" list. The .origin of
   ! the plot is also set updated.
      self :: INOUT
      atom :: VEC{ATOM}, IN

      val :: VEC{REAL}(3)

      val = atom.center_of_atoms

      .set_offset(val)

   end

   set_offset(val) ::: pure
   ! Offset the .center by .offset along the current axes.
      self :: INOUT
      val :: VEC{REAL}(3), IN

      .offset = val

      .set_center_from_offset

   end

   set_offset_cube(val) ::: pure
   ! Offset the .center by .offset along the current axes.
      self :: INOUT
      val :: VEC{REAL}(3), IN

      .offset = val

      .set_center_cube_from_offset

   end

   set_center_from_offset ::: pure
   ! Offset the .center by .offset along the current axes.
      self :: INOUT

      .center = .center + .offset(1)*.x_axis
      .center = .center + .offset(2)*.y_axis
      .center = .center + .offset(3)*.z_axis

      .set_origin

   end

   set_center_cube_from_offset ::: pure
   ! Offset the .center by .offset along the current axes.
      self :: INOUT

      .center = .center + .offset(1)*.x_axis*BOHR_PER_ANGSTROM
      .center = .center + .offset(2)*.y_axis*BOHR_PER_ANGSTROM
      .center = .center + .offset(3)*.z_axis*BOHR_PER_ANGSTROM

      .set_origin

   end
   set_center_to_center_of(atom) ::: PURE
   ! Set the .center to the center of an "atom" list. The .origin of
   ! the plot is also set updated.
      self :: INOUT
      atom :: VEC{ATOM}, IN

      .center = atom.center_of_atoms

      .set_origin

   end

   set_origin ::: pure
   ! Set the origin of the plot (the bottom, front, left-hand corner). It is
   ! equal to the .center of the plot minus half the (current) .widths along the
   ! (current) x, y, and z axes.
      self :: INOUT

      if (.origin_atom) then

        .origin = .center

      else

        .origin = .center
        .origin = .origin -.width(1)*HALF*.x_axis
        .origin = .origin -.width(2)*HALF*.y_axis
        .origin = .origin -.width(3)*HALF*.z_axis

      end

   end

   set_x_axis_from_atom_list(atom) ::: PURE
   ! Set the x-axis of the grid data from an "atom" list. If the .x_width has
   ! not been explicitly set, it is set to twice the length between the atom
   ! separation (because probably the user wants to see at least those atoms in
   ! his plot!).
      self :: INOUT
      atom :: VEC{ATOM}, IN

   ENSURE(.x_atom_1/=0,"no x_atom_1")
   ENSURE(.x_atom_2/=0,"no x_atom_2")

      .x_axis = atom(.x_atom_2).position - atom(.x_atom_1).position

      if (NOT .x_width_set) then
         .width(1) = FOUR*.x_axis.norm
         if (NOT .y_width_set) .width(2) = .width(1)
         .set_points_widths_origin
      end

      .set_xyz_axes_from_x_axis

   end

   set_y_axis_from_atom_list(atom) ::: PURE
   ! Set the y-axis of the grid data from an "atom" list. If the .y_width has
   ! not been explicitly set, it is set to twice the length between the atom
   ! separation (because probably the user wants to see at least those atoms in
   ! his plot!).
      self :: INOUT
      atom :: VEC{ATOM}, IN

   ENSURE(.y_atom_1/=0,"no y_atom_1")
   ENSURE(.y_atom_2/=0,"no y_atom_2")

      .y_axis = atom(.y_atom_2).position - atom(.y_atom_1).position

      if (NOT .y_width_set) then
         if (.x_axis_defined) then; .width(2) = .width(1)
         else;                      .width(2) = FOUR*.y_axis.norm
         end
         .set_points_widths_origin
      end

      .set_xyz_axes_from_y_axis

   end

   set_z_axis_from_atom_list(atom) ::: PURE
   ! Set the z-axis of the grid data from an "atom" list. If the .z_width has
   ! not been explicitly set, it is set to twice the length between the atom
   ! separation (because probably the user wants to see at least those atoms in
   ! his plot!).
      self :: INOUT
      atom :: VEC{ATOM}, IN

   ENSURE(.z_atom_1/=0,"no z_atom_1")
   ENSURE(.z_atom_2/=0,"no z_atom_2")

      .z_axis = atom(.z_atom_2).position - atom(.z_atom_1).position

      if (NOT .z_width_set) then
         if (.x_axis_defined) then; .width(3) = .width(1)
         else;                      .width(3) = FOUR*.z_axis.norm
         end
         .set_points_widths_origin
      end

      .set_xyz_axes_from_z_axis

   end

   set_xyz_axes_from_x_axis ::: PURE
   ! Set the x,y,z axes of the grid given a new x_axis vector. Also set the
   ! origin since that is dependent on the axes.
      self :: INOUT

      .x_axis.normalise

      if (.z_axis_defined) then

       ! WARN_IF(.x_axis_defined,"orthonormalizing x axis to z, but x_axis was defined!")
       ! WARN_IF(.y_axis_defined,"orthonormalizing y axis to z, but y_axis was defined!")
         .orthonormalize_x_y_to_z_axis

      else

       ! WARN_IF(.y_axis_defined,"orthonormalizing y axis to x, but y_axis was defined!")
         .orthonormalize_y_z_to_x_axis

      end

      .set_origin

   end

   set_xyz_axes_from_y_axis  ::: PURE
   ! Set the x,y,z axes of the grid given a new y_axis vector. Also set the
   ! origin since that is dependent on the axes.
      self :: INOUT

      .y_axis.normalise

      ENSURE(NOT .y_axis.same_as(.x_axis),"y_axis is the same as x_axis")

    ! WARN_IF(.y_axis_defined,"orthonormalizing y axis to x, but y_axis was defined!")
    ! WARN_IF(.z_axis_defined,"orthonormalizing z axis to x, but z_axis was defined!")
      .orthonormalize_y_z_to_x_axis

      .set_origin

   end

   set_xyz_axes_from_z_axis ::: PURE
   ! Set the x,y,z axes of the grid given a new z_axis vector. Also set the
   ! origin since that is dependent on the axes.
      self :: INOUT

   ENSURE(NOT .z_axis_defined,"z_axis already explicitly defined")
 ! WARN_IF(.x_or_y_axes_defined,"x/y axis to be orthonormalised to z axis")

      .z_axis.normalise
      .orthonormalize_x_y_to_z_axis
      .set_origin

   end

   orthonormalize_x_y_to_z_axis ::: private, PURE
   ! Orthonormalise the x and y axes to the z axis.
      self :: INOUT

      dot :: REAL

      ! Make sure x and z are different
      if (.x_axis.same_as(.z_axis)) .x_axis = .y_axis

      ! Orthonormalize x_axis to z_axis
      dot = dot_product(.z_axis,.x_axis)
      .x_axis = .x_axis - dot*.z_axis
      .x_axis.normalise
      ENSURE(NOT .x_axis.is_zero,"x_axis is same as z_axis!")

      ! Now define y axis
      .y_axis.to_cross_product_of(.z_axis,.x_axis)

   end

   orthonormalize_y_z_to_x_axis ::: private, PURE
   ! Orthonormalise the x and y axes to the z axis.
      self :: INOUT

      dot :: REAL

      ! Make sure y and x are different
      if (.y_axis.same_as(.x_axis)) .y_axis = .z_axis

      ! Orthogonalise y_axis to x_axis
      dot = dot_product(.x_axis,.y_axis)
      .y_axis = .y_axis - dot*.x_axis
      .y_axis.normalise
      ENSURE(NOT .y_axis.is_zero,"y_axis is same as x_axis!")

      ! Now define z axis
      .z_axis.to_cross_product_of(.x_axis,.y_axis)

   end

   set_bbox_from_unit_cell(unit_cell,recenter) ::: PURE
   ! Use the "unit_cell" to set the bounding box. This bounding box
   ! has equal numbers of divisions along each axis to allow for a
   ! recursive marching cube algorithm. This means that the
   ! separations along each axis may be different. Note that the axes
   ! may not be orthogonal.
      self :: INOUT
      unit_cell :: UNIT_CELL, IN
      recenter :: BIN, optional, IN

      new_center :: BIN

      .box_axes = unit_cell.direct_matrix

      new_center = TRUE
      if (present(recenter)) new_center = recenter

      if (new_center) then
         .center.to_product_of(.box_axes,[HALF,HALF,HALF]+.offset)
      end

      ! Widths are unit cell side lenths
      .width(1) = .box_axes(:,1).norm
      .width(2) = .box_axes(:,2).norm
      .width(3) = .box_axes(:,3).norm

      ! Normalise the box axes
      .box_axes(:,1) = .box_axes(:,1)/.width(1)
      .box_axes(:,2) = .box_axes(:,2)/.width(2)
      .box_axes(:,3) = .box_axes(:,3)/.width(3)

      ! Set plot axes
      .x_axis = .box_axes(:,1)
      .y_axis = .box_axes(:,2)
      .z_axis = .box_axes(:,3)

      ! Scale by requested factor
      .width = .box_scale_factor*.width

      ! Set odd points
      if (.desired_separation>ZERO) then
         .n_x = ceiling(.width(1)/.desired_separation)
         .n_y = ceiling(.width(2)/.desired_separation)
         .n_z = ceiling(.width(3)/.desired_separation)
      end

      .set_box_from_widths

   end

   set_box_from_widths ::: pure
   ! Forces the number of points in the three directions to be odd
   ! Calculates the separations from these.
      self :: INOUT

!     .n_x = 2*(.n_x/2) + 3
!     .n_y = 2*(.n_y/2) + 3
!     .n_z = 2*(.n_z/2) + 3

      .n_pt = .n_x*.n_y*.n_z

      if (.n_x>1) then;       .del_x = .width(1)/(.n_x)
      else if (.n_x==1) then; .width = ZERO
      end

      if (.n_y>1) then;       .del_y = .width(2)/(.n_y)
      else if (.n_y==1) then; .width = ZERO
      end

      if (.n_z>1) then;       .del_z = .width(3)/(.n_z)
      else if (.n_z==1) then; .width = ZERO
      end

!     if (.n_x>1) then;       .del_x = .width(1)/(.n_x-1)
!     else if (.n_x==1) then; .width = ZERO
!     end

!     if (.n_y>1) then;       .del_y = .width(2)/(.n_y-1)
!     else if (.n_y==1) then; .width = ZERO
!     end

!     if (.n_z>1) then;       .del_z = .width(3)/(.n_z-1)
!     else if (.n_z==1) then; .width = ZERO
!     end

      .set_origin

   end

   set_cube_from_widths   ::: pure
   ! Set a plot grid which is a cube from the different widths for each
   ! axis (as specified). These means that the separations on each
   ! axis will be different. NOTE: that the axes need not be orthogonal.
      self :: INOUT

      .n_x = 2*(.n_x/2) + 1               ! Make # of axis points odd ...
      .n_y = .n_x                         ! Set other points from x
      .n_z = .n_x                         ! Equal points in all directions

      .n_pt = .n_x*.n_y*.n_z

      if (.n_x>1) then

         .del_x = .width(1)/(.n_x-1)
         .del_y = .width(2)/(.n_y-1)
         .del_z = .width(3)/(.n_z-1)

      else if (.n_x==1) then

         .width = ZERO

      end

      .set_origin

   end

   set_contour_scale(val) ::: PURE
   ! Set the conour range scale mapping.
      self :: INOUT
      val :: STR, IN

   ENSURE(val.is_one_of(["linear      ","log         ","negative-log","positive-log"]),"unknown option: "//trim(val))

      .contour_scale = val

   end

   set_contour_min_value(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.contour_min_value), pure
   ! Generic set
   end

   set_contour_max_value(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.contour_max_value), pure
   ! Generic set
   end

   set_contour_increment(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.contour_increment), pure
   ! Generic set
   end

   set_contour_line_width(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.contour_line_width), pure
   ! Generic set
   end

   set_contour_fade_factor(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.contour_fade_factor), pure
   ! Generic set
   end

   set_contour_tic_dps(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.contour_tic_dps), pure
   ! Generic set
   end

   set_contour_font_size(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.contour_font_size), pure
   ! Generic set
   end

   set_contour_color_scale(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.contour_scale), pure
   ! Generic set
   end

   set_use_colorbox_scale(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_colorbox_scale), pure
   ! Generic set
   end

   set_use_ruler_scale(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_ruler_scale), pure
   ! Generic set
   end

!  ==============
!  Bond alignment
!  ==============

   use_bond_axis_as_z_axis
   ! Align the bond axis (given in .bond_density_atoms) onto the z
   ! axis. Also print the positions of the bond axis atoms B and A and
   ! the neighbouring atoms of atom A in anticlockwise direction,
   ! along with the atomic numbers and rotation angles.

      pos :: MAT{REAL}*
      Z   :: VEC{INT}*
      theta :: VEC{REAL}*
      i :: INT

      ! Get the positions
      .get_bond_atoms_on_z_axis(pos,Z,theta)

      ! Print the positions of the atoms A, B and
      ! neighbour atoms n1,n2, .... in anticlockwise order
      stdout.text("Rotated positions of atoms B, A, n1, n2 ...")
      stdout.text("relative to the plot origin")
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         stdout.put(theta(i))
         stdout.flush
      end

      ! Clean up
      theta.destroy
      Z.destroy
      pos.destroy

   end

   get_bond_atoms_on_z_axis(pos,Z,theta) ::: leaky
   ! Get "pos", the positions of the atoms on the bond axis, aligned
   ! so that the bond axis is on the z axis. The atom positions are in
   ! the order B, A, followed by the neighbours of atom A, in
   ! anticlockwise order. Also get the atomic numbers "Z"
   ! corresponding to the atom positions in "pos", and the
   ! corresponding rotation angles "theta" around the bond axis
   ! NOTE: the routine sets the plot width to be the AB bond length
   ! times the .box_scale_factor
      pos :: MAT{REAL}*
      Z   :: VEC{INT}*
      theta :: VEC{REAL}*

   ENSURE(.bond_density_atom.associated,"no bond_density_atoms")
   ENSURE(.bond_density_atom.dim==3,"must have 3 bond_density_atoms")
   ENSURE(.x_atom_1/=0 AND .x_atom_2/=0,"must have x axis atoms")
   ENSURE(.atom.associated,"must have a list of atoms")

      a,b,c,n,i :: INT
      x,y,d_max :: REAL
      na,order :: VEC{INT}*
      v :: VEC{REAL}(3)
      R :: MAT{REAL}(3,3)

      ! Get a, b, c atoms
      a = .bond_density_atom(1)
      b = .bond_density_atom(2)
      c = .bond_density_atom(3) ! this must be either a or b

      ! If the third bond atom c is equal to b, swap
      ! a and b so that atom a has neighbours.
      if (c==b) then
         b = a
         a = c
      end

      ! Get the neighbours of A
      na => .atom.neighbours_of(a)

      ! Get the plot axes. First make the z axis
      .z_axis = .atom(b).position - .atom(a).position
      .z_axis.normalise

      ! Make the x axis orthogonal to z axis
      .x_axis = .atom(.x_atom_2).position - .atom(.x_atom_1).position
      .x_axis = .x_axis - dot_product(.x_axis,.z_axis)*.z_axis
      .x_axis.normalise

      ! Now make the y axis
      .y_axis = .z_axis.cross(.x_axis)

      ! Set the center of the plot to be atom a position
      .center = .atom(a).position

      ! Get the plot with as 2 times the largest bond
      ! length to the central atom a
    ! n = na.dim
    ! d_max = ZERO
    ! do i = 1,n
    !    d_max = max(d_max,.atom.bond_distance(a,na(i)))
    ! end
    ! .width(1) = 2*d_max
    ! .width(2) = 2*d_max
    ! .width(3) = 2*d_max

      ! Make the plot size 2 times the bond length
      d_max = .atom.bond_distance(a,b)
      .width(1) = .box_scale_factor*d_max
      .width(2) = .box_scale_factor*d_max
      .width(3) = .box_scale_factor*d_max

      .set_points_widths_origin
      .x_width_set = TRUE
      .y_width_set = TRUE
      .z_width_set = TRUE

      ! Remove atom B from the neighbours of A
      na.prune(b)

      ! Allocate space for positions, atomic numbers, angles
      n = na.dim
      pos.create(3,n+2)
      Z.create(n+2)
      theta.create(n)

      ! Get the cos and sin of the neighbours
      ! and sort into anticlockwise order
      order.create(n)
      if (n>0) then
         do i = 1,n
            v = .atom(na(i)).position - .atom(a).position
            v.normalise
            x = dot_product(v,.x_axis)
            y = dot_product(v,.y_axis)
            theta(i) = atan2(y,x)*DEGREE_PER_RADIAN
         end
         theta.quick_sort(order)
         theta = theta(order)
         na = na(order)
      end
      order.destroy

      ! Make the rotation matrix which rotates the bond
      ! axis to the z axis
      R(1,:) = .x_axis
      R(2,:) = .y_axis
      R(3,:) = .z_axis

      ! Get the rotated position of atom B
      v = .atom(b).position - .center
      pos(:,1).to_product_of(R,v)
      Z(1) = .atom(b).atomic_number

      ! Get the rotated position of atom A
      v = .atom(a).position - .center
      pos(:,2).to_product_of(R,v)
      Z(2) = .atom(a).atomic_number

      ! Get the rotated position of neighbours of atom A
      if (n>0) then
         do i = 1,n
            v = .atom(na(i)).position - .center
            pos(:,i+2).to_product_of(R,v)
            Z(i+2) = .atom(na(i)).atomic_number
         end
      end

      ! Add the theta angles for the B and A atoms
      theta.prepend([ZERO,ZERO])

      ! Clean up
      na.destroy

   end

   align_to_bond
   ! Make the rotation matrix R which aligns the bond axis given in
   ! .bond_density_atoms along the z axis
   ! WARNING: do not set n_points in the input after this routine

      pos,pos0,pos0r,pos_keep,p :: MAT{REAL}*
      Z,Z0   :: VEC{INT}*
      theta,theta0 :: VEC{REAL}*
      x,y :: VEC{REAL}(3)
      R :: MAT{REAL}(3,3)
      found :: BIN
      word :: STR
      fac_z,fac_r,r_ab,r_ab0,d2,angle,a,b,c,dist2,an,top,bot :: REAL
      n,i,s :: INT

      ! Get the positions
      .get_bond_atoms_on_z_axis(pos,Z,theta)

      ! Print out again the bond atom positions
      stdout.text("Rotated positions of bond atoms B, A, n1, n2 ...(N')")
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         stdout.put(theta(i))
         stdout.flush
      end

      ! Get the number of atoms including A and B
      n = Z.dim
      ENSURE(n>1,"must have at least two atoms!")

      ! Create space for reference positions, atomic numbers,
      ! and angles
      pos0.create(3,n)
      Z0.create(n)
      theta0.create(n)

      ! Read in the reference positions we align to
      stdin.read(word)
      ENSURE(word=="{","missing open curly bracket?")
      do i = 1,n
         stdin.read(pos0(:,i))
         stdin.read(Z0(i))
         stdin.read(theta0(i))
      end
      stdin.read(word)
      ENSURE(word=="}","missing close curly bracket?")

      ! Print out again the reference positions
      stdout.text("Rotated positions of REFERENCE bond atoms ... (N0)")
      do i = 1,Z0.dim
         stdout.put(pos0(1,i))
         stdout.put(pos0(2,i))
         stdout.put(pos0(3,i))
         stdout.put(Z0(i))
         stdout.put(theta0(i))
         stdout.flush
      end

      ! Find the cyclic permutation shift that causes the atomic
      ! numbers Z to match the reference ones in Z0
      found = FALSE
      do s = 0,n-3
         if (any(cshift(Z(3:),s)/=Z0(3:))) cycle
         found = TRUE
         exit
      end
      DIE_IF(NOT found,"a matching shift was not found!")
      stdout.show("shift left/up      =",s)

      Z(3:)     = cshift(Z(3:),s)
      theta(3:) = cshift(theta(3:),s)
      pos(:,3:) = cshift(pos(:,3:),s,dim=2)

      pos_keep.create_copy(pos)

      ! Print out again the bond atom positions
      stdout.text("Cyclic shifted neighbour positions ...")
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         stdout.put(theta(i))
         stdout.flush
      end

      ! Work out at the optimum rotation angle which rotates N0 to N'
      a =      VEC{REAL}:sum_elements((pos0(1,3:)*pos0(1,3:) + pos0(2,3:)*pos0(2,3:) + pos0(3,3:)*pos0(3,3:)) ) &
        +      VEC{REAL}:sum_elements(( pos(1,3:)* pos(1,3:) +  pos(2,3:)* pos(2,3:) +  pos(3,3:)* pos(3,3:)) ) &
        -  TWO*VEC{REAL}:sum_elements(pos(3,3:)*pos0(3,3:))
      b = -TWO*VEC{REAL}:sum_elements(pos(1,3:)*pos0(1,3:)) - TWO*VEC{REAL}:sum_elements(pos(2,3:)*pos0(2,3:))
      c = -TWO*VEC{REAL}:sum_elements(pos(2,3:)*pos0(1,3:)) + TWO*VEC{REAL}:sum_elements(pos(1,3:)*pos0(2,3:))
      angle = atan(c/b)
      stdout.show("a =",a)
      stdout.show("b =",b)
      stdout.show("c =",c)

      ! Does this have a negative second derivative?
      ! If not, add pi to the solution
      d2 = -b*cos(angle) - c*sin(angle)
      if (d2<ZERO) angle = angle + PI
      dist2 = a + b*cos(angle) + c*sin(angle)
      stdout.show("rotation angle converting reference to this geometry (degrees) =",angle*DEGREE_PER_RADIAN)
      stdout.show("distance2                                                      =",dist2)

      ! Now, rotate the x and y plot axes by the angle
      x =  cos(angle)*.x_axis + sin(angle)*.y_axis
      y = -sin(angle)*.x_axis + cos(angle)*.y_axis
      .x_axis = x
      .y_axis = y

      ! Get the matrix which rotates reference (N0)
      ! to this position (N')
      R(:,3) = [ZERO,ZERO,ONE]
      R(3,:) = [ZERO,ZERO,ONE]
      R(1,1) = cos(angle); R(1,2) = -sin(angle)
      R(2,1) = sin(angle); R(2,2) =  cos(angle)

      stdout.text("Matrix which rotates reference (N0) to this position (N'):")
      stdout.put(R)

      ! Print out again the bond atom positions
      ! and check squared distance
      stdout.text("Rotated neighbour positions (R^T N') which match scaled reference (N0)")
      p.create_copy(pos)
      pos.to_product_of(R,p,transpose_a=TRUE)
      p.destroy
      dist2 = ZERO
      do i = 1,Z.dim
         stdout.put(pos(1,i))
         stdout.put(pos(2,i))
         stdout.put(pos(3,i))
         stdout.put(Z(i))
         if (i>2) then
         stdout.put(theta(i)-angle*DEGREE_PER_RADIAN)
         dist2 = dist2 + VEC{REAL}:sum_elements((pos(:,i) - pos0(:,i))*(pos(:,i)-pos0(:,i)))
         else
         stdout.put(theta(i))
         end
         stdout.flush
      end
      stdout.show("distance2 (should be same as above)                            =",dist2)

      ! Get the z scale factor which scales reference N0
      ! to *this* geonmetry N'
      r_ab  = pos(3,1)  - pos(3,2)
      r_ab0 = pos0(3,1) - pos0(3,2)
      fac_z = r_ab/r_ab0
      stdout.show("Z scale factor scaling N0 to N1 =",fac_z)

      ! Get the radial scale factor from the
      ! rotated reference atom positions
      if (n==2) then
         fac_r = ONE        ! no neighbours
      else
         top = ZERO
         bot = ZERO
         do i = 3,n
            top = top + dot_product(pos0(1:2,i),pos(1:2,i))
            bot = bot + dot_product(pos0(1:2,i),pos0(1:2,i))
         end
         fac_r = top/bot
      end
      stdout.show("radial scale factor =",fac_r)

      ! Rotate and stretch reference positions "pos0" so they
      ! match this set of positions "pos"
      ! No need to rotate as the plot axes are rotated
      ! to simulate a rotation of this molecule

      pos0r.create(3,pos0.dim2)
      pos0r.to_product_of(R,pos0)

      ! Scale pos0
      pos0(3  ,:) = pos0(3  ,:)*fac_z
      pos0(1:2,:) = pos0(1:2,:)*fac_r

      ! Scale pos0r
      pos0r(3  ,:) = pos0r(3  ,:)*fac_z
      pos0r(1:2,:) = pos0r(1:2,:)*fac_r

      ! Now, scale the radial plot widths to match
      ! the reference positions
      .width(1) = .width(1)*fac_r
      .width(2) = .width(2)*fac_r
      .width(3) = .width(3)
      .x_width_set = TRUE
      .y_width_set = TRUE
      .z_width_set = TRUE

      ! Make sure axes widths, etc, are OK. Checked.
      ! This grid has unequal spacings in z, y and x
      ! WARNING: do not set n_points after this routine
    ! .set_points_widths_origin
      .n_x = 2*(.n_x/2) + 1
      if (.n_x>1) then
         .del_x = .width(1)/(.n_x-1)
         .del_y = .width(2)/(.n_y-1)
         .del_z = .width(3)/(.n_z-1)
      else if (.n_x==1) then
         .width = ZERO
      end
      .n_pt = .n_x*.n_y*.n_z
      .set_origin

      ! Print out the scaled reference atom positions
      ! "pos0" in cube file format ...
      stdout.text("Scaled, rotated reference positions (R N0) which match original positions (N')")
      stdout.text("Place these in the cube file")
      stdout.save                    ! Save settings
      stdout.set_real_style("e")     ! Gaussian format
      stdout.set_real_width(13)
      stdout.set_real_precision(5)
      dist2 = ZERO
      do i = 1,Z.dim
         stdout.put(Z0(i))           ! Z
         an = Z0(i)
         stdout.put(an,precision=1)  ! Charge
         stdout.put(pos0(1,i))       ! Pos in plot grid axis system
         stdout.put(pos0(2,i))
         stdout.put(pos0(3,i))
         stdout.flush
         if (i>2) then
         dist2 = dist2 + VEC{REAL}:sum_elements((pos0r(:,i) - pos_keep(:,i))*(pos0r(:,i)-pos_keep(:,i)))
         end
      end
      stdout.unsave                  ! Put back settings
      stdout.show("distance2 (should be smaller than above)                       =",dist2)

      ! Clean up
      theta0.destroy; Z0.destroy; pos0.destroy; pos0r.destroy
      theta.destroy;  Z.destroy;  pos.destroy; pos_keep.destroy

   end

!  ==============
!  Atom positions
!  ==============

   get_rotated_atom_positions(pos) ::: leaky
   ! Calculate the atom positions "pos" which have been shifted to the
   ! grid center and rotated to the grid axes.
      pos :: MAT{REAL}*

   ENSURE(.atom.associated,"no atoms!")

      p :: MAT{REAL}*
      axes :: MAT{REAL}(3,3)
      limits :: VEC{REAL}(3)
      a,n :: INT

      ! No of atoms
      n = .atom.dim

      ! Create positions (leaky)
      pos.create(3,n)

      ! Shift atom positions
      do a = 1,n
         pos(:,a) = .atom(a).position - .center
      end

      ! Rotate positions into plot grid axis
      axes = .transposed_plot_axes
      p.create(3,n)
      p.to_product_of(axes,pos)
      pos = p
      p.destroy

      ! Adjust positions to be within plot box width
      limits = .width*HALF
      do a = 1,n
         where (pos(:,a)>+limits) pos(:,a) = +limits
         where (pos(:,a)<-limits) pos(:,a) = -limits
      end

   end

   get_rotoranged_atom_positions(math_pos,z_range,valid) ::: leaky
   ! Calculate the positions "math_pos" of the valid atoms which have
   ! been rotated and shifted and scaled into grid point coordinates.
   ! Valid atoms are those which are within "z_range" of the plot
   ! plane; the indices of the valid atoms are stored in "valid"
      math_pos :: MAT{REAL}*
      z_range :: REAL, IN
      valid :: VEC{INT}*
   ENSURE(.atom.associated,"no atoms!")
   ENSURE(z_range>ZERO,"z_range must be non-negative")
   ENSURE(valid.disassociated,"valid array already allocated")

      scale_factor,p :: VEC{REAL}(3)
      tr :: MAT{REAL}(3,3)
      pos :: MAT{REAL}*
      n,nv,a,i :: INT

      ! Get shifted atom positions
      n = .atom.dim
      pos.create(n,3)
      do a = 1, n
         pos(a,:) = .atom(a).position - .origin    !shift
      end

      ! Rotate positions into plot grid axis
      tr = .transposed_plot_axes
      do a = 1, n
         p = pos(a,:)
         pos(a,:).to_product_of(tr,p)
      end

      ! Reject atoms far from plot plane, get valid atoms
      valid.create(0)
      do a = 1, n
        ! if ( abs(pos(a,z)) > z_range) cycle
         if ( abs(pos(a,3)) > z_range) cycle
         valid.append(a)
      end

      ! Create list of valid atoms positions
      nv = valid.dim
      math_pos.create(nv,3)
      i = 0
      do a = 1, n
         if ( abs(pos(a,3)) > z_range) cycle
         i = i + 1
         math_pos(i,:) = pos(a,:)
      end

      ! Finally, scale positions
      scale_factor(1) = (.n_x - ONE) / .width(1)
      scale_factor(2) = (.n_y - ONE) / .width(2)
      scale_factor(3) = ZERO
      do a = 1,nv
         math_pos(a,:) = scale_factor * math_pos(a,:) + ONE ! since plot begins at 1
      end

      pos.destroy

   end

!  ===============
!  Inquiry methods
!  ===============

   atom_data_used result (res) ::: pure
   ! Return TRUE if atom-based data was used to specify plot axes.
      self :: IN
      res :: BIN

      res = .center_atoms.associated OR .x_atom_1/=0 OR .y_atom_1 /=0

   end

   x_or_y_axes_defined result (res) ::: pure
   ! Return TRUE if the x or y axes have been explicitly inputted.
      self :: IN
      res :: BIN

      res = .x_axis_defined OR .y_axis_defined

   end

   x_or_y_or_z_axes_defined result (res) ::: pure
   ! Return TRUE if any of the x or y or z axes have been explicitly
   ! inputted.
      self :: IN
      res :: BIN

      res = .x_axis_defined OR .y_axis_defined OR .z_axis_defined

   end

   has_orthogonal_plot_axes result (res) ::: pure
   ! Return TRUE if the plot axes are orthogonal
      self :: IN
      res :: BIN

      dot :: REAL

      dot = dot_product(.x_axis,.y_axis)
      res = dot.is_zero
      if (NOT res) return

      dot = dot_product(.x_axis,.z_axis)
      res = dot.is_zero
      if (NOT res) return

      dot = dot_product(.y_axis,.z_axis)
      res = dot.is_zero

   end

   has_equal_spacing result (res) ::: pure
   ! Return TRUE if the plot spacings are all equal
      self :: IN
      res :: BIN

      res = .del_x.equals(.del_y)
      if (NOT res) return

      res = .del_x.equals(.del_z)
      if (NOT res) return

      res = .del_y.equals(.del_z)

   end

   plot_axes result (res) ::: pure
   ! Return the plot axes as a matrix.
      self :: IN
      res :: MAT{REAL}(3,3)

      res(:,1) = .x_axis
      res(:,2) = .y_axis
      res(:,3) = .z_axis

   end

   transposed_plot_axes result (res) ::: pure
   ! Return the transposed plot axis matrix.
      self :: IN
      res :: MAT{REAL}(3,3)

      res(1,:) = .x_axis
      res(2,:) = .y_axis
      res(3,:) = .z_axis

   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                         ")  ! exit case
         case ("align_to_bond=            "); .align_to_bond
         case ("bond_density_atoms=       "); .read_bond_density_atoms
         case ("box_scale_factor=         "); .read_box_scale_factor
         case ("center=                   "); .read_center
         case ("centre=                   "); .read_center
         case ("center_atom=              "); .read_center_atom
         case ("center_atoms=             "); .read_center_atoms
         case ("centre_atom=              "); .read_center_atom
         case ("centre_atoms=             "); .read_center_atoms
         case ("contour_color_scale=      "); .read_contour_color_scale
         case ("contour_tic_dps=          "); .read_contour_tic_dps
         case ("contour_fade_factor=      "); .read_contour_fade_factor
         case ("contour_font_size=        "); .read_contour_font_size
         case ("contour_increment=        "); .read_contour_increment
         case ("contour_line_width=       "); .read_contour_line_width
         case ("contour_max_color=        "); .read_contour_max_color
         case ("contour_max_value=        "); .read_contour_max_value
         case ("contour_mid_color=        "); .read_contour_mid_color
         case ("contour_min_color=        "); .read_contour_min_color
         case ("contour_min_value=        "); .read_contour_min_value
         case ("contour_scale=            "); .read_contour_scale
         case ("crystal_plane=            "); .read_z_axis
         case ("cube_scale_factor=        "); .read_cube_scale_factor
         case ("desired_separation=       "); .read_desired_separation
         case ("electric_potential_method="); .read_electric_potential_method
         case ("homo_orbital_plus=        "); .read_HOMO_orbital_plus
         case ("homo_orbital_minus=       "); .read_HOMO_orbital_minus
         case ("kind=                     "); .read_plot_kind
         case ("kinds=                    "); .read_plot_kinds
         case ("lumo_orbital_plus=        "); .read_LUMO_orbital_plus
         case ("max_x_points=             "); .read_max_x_points
         case ("min_x_points=             "); .read_min_x_points
         case ("n_points=                 "); .read_x_points
         case ("n_all_points=             "); .read_all_points
         case ("normal=                   "); .read_z_axis
         case ("offset=                   "); .read_offset
         case ("offset_cube=              "); .read_offset_cube
         case ("orbital=                  "); .read_orbital
         case ("origin_atom=              "); .read_origin_atom
         case ("plot_format=              "); .read_plot_format
         case ("plot_kind=                "); .read_plot_kind
         case ("plot_kinds=               "); .read_plot_kinds
         case ("plot_kinds_units=         "); .read_plot_kinds_units
         case ("plot_label=               "); .read_plot_label
         case ("plot_max=                 "); .read_plot_max
         case ("plot_min=                 "); .read_plot_min
         case ("plot_units=               "); .read_plot_units
         case ("projection_direction=     "); .read_projection_direction
         case ("put                       "); .put
         case ("units=                    "); .read_plot_units
         case ("use_bbox                  "); .use_bbox_with_current_axes
         case ("use_bbox_with_shape_axes  "); .use_bbox_with_shape_axes
         case ("use_bcube                 "); .use_bcube_with_current_axes
         case ("use_bcube_with_shape_axes "); .use_bcube_with_shape_axes
         case ("use_bond_axis_as_z_axis   "); .use_bond_axis_as_z_axis
         case ("use_bounding_box          "); .use_bbox_with_current_axes
         case ("use_bounding_box_and_axes "); .use_bbox_with_shape_axes
         case ("use_bounding_cube         "); .use_bcube_with_current_axes
         case ("use_bounding_cube_and_axes"); .use_bcube_with_shape_axes
         case ("use_colorbox_scale=       "); .read_use_colorbox_scale
         case ("use_plot_max=             "); .read_use_plot_max
         case ("use_plot_min=             "); .read_use_plot_min
         case ("use_ruler_scale=          "); .read_use_ruler_scale
         case ("use_unit_cell_as_bbox     "); .use_unit_cell_as_bbox = TRUE
         case ("x_axis=                   "); .read_x_axis
         case ("x_axis_atoms=             "); .read_x_axis_atoms
         case ("x_axis_atom_list=         "); .read_x_axis_atom_list
         case ("x_points=                 "); .read_x_points
         case ("x_width=                  "); .read_x_width
         case ("y_axis=                   "); .read_y_axis
         case ("y_axis_atoms=             "); .read_y_axis_atoms
         case ("y_axis_atom_list=         "); .read_y_axis_atom_list
         case ("y_width=                  "); .read_y_width
         case ("z_axis=                   "); .read_z_axis
         case ("z_width=                  "); .read_z_width
         case ("3d_points_filename=       "); .read_points_filename
         case default;                    UNKNOWN(word)
      end

   end

   read_plot_units
   ! Read the units to which the plot should be converted to.
      self :: INOUT

      units :: STR

      stdin.read(units)

      .set_plot_units(units)

   end

   read_plot_kinds_units ::: leaky
   ! Read a string vector which describes the units to be used
   ! for each of the plot_kinds_units
      stdin.read(.plot_kinds_units)
      .plot_kinds_units.to_lower_case
   end

   read_plot_format
   ! Read the units to which the plot should be converted to.
      self :: INOUT

      plot_format :: STR

      stdin.read(plot_format)
      .set_plot_format(plot_format)

   end

   read_plot_max
   ! Read the plot maximum to use
      stdin.read_quantity(.plot_max)
      .use_plot_max = TRUE
   end

   read_plot_min
   ! Read the plot minimum to use
      stdin.read_quantity(.plot_min)
      .use_plot_min = TRUE
   end

   read_use_plot_max
   ! Read whether to use the plot maximum
      stdin.read(.use_plot_max)
   end

   read_use_plot_min
   ! Read whether to use the plot minimum
      stdin.read(.use_plot_min)
   end

   read_plot_kind
   ! Read in the plot kind
      kind :: STR
      stdin.read(kind)
      .set_plot_kind(kind)
   end

   read_plot_kinds ::: leaky
   ! Read in the plot kind

      n :: INT

      stdin.read_ptr(.plot_kinds)

      .plot_kinds.to_lower_case

      n = .plot_kinds.dim
      .plot_kinds_units.create(n)
      .plot_kinds_units = " "

   end

   read_plot_label
   ! Read in the plot label
      label :: STR
      stdin.read(label)
      .set_plot_label(label)
   end

   read_desired_separation
   ! Read the (approximate) desired separation between grid points along an axis
   ! direction.  The number of x points for the plot is adjusted so that the
   ! *actual* separation is less than the inputted separation. NOTE: the current
   ! .x_width is used to calculate the number of points.
      self :: INOUT
   
   ENSURE(.n_x>1,"# of x_points must be greater than 1")

      del :: REAL

   WARN_IF(NOT .x_width_set,"default x_width used to calculate # of x_points")

      stdin.read_quantity(del)

      .set_desired_separation(del)

   end

   read_electric_potential_method
   ! Read a string representing which method to use when calculating
   ! electric potential on the generated isosurface
      self :: INOUT

      stdin.read(.electric_potential_method)

   end

   read_max_x_points
   ! Read the *maximum number* of x points to be used for the plot.
   ! The number of points is adjusted to be no more than this.
      max_n_x :: INT
      stdin.read(max_n_x)
      if (.n_x<=max_n_x) return
      .n_x = max_n_x
      WARN_IF(.n_x.is_even,"resetting to nearest odd number")
      .set_points_widths_origin
   end

   read_min_x_points
   ! Read the *minimum number* of x points to be used for the plot.
      min_n_x :: INT
      stdin.read(min_n_x)
      if (min_n_x<=.n_x) return
      .n_x = min_n_x
      WARN_IF(.n_x.is_even,"resetting to nearest odd number")
      .set_points_widths_origin
   end

   read_all_points 
   ! Read the number of x y and z points for the plot. This is the precision
   ! of the plot.
      grid_points :: VEC{INT}(3)

      stdin.read(grid_points)

      .n_x = grid_points(1)
      .n_y = grid_points(2)
      .n_z = grid_points(3)

      ENSURE( .n_x>0,"number of x_points must be positive")
      ENSURE( .n_y>0,"number of y_points must be positive")
      ENSURE( .n_z>0,"number of z_points must be positive")
!     grid_points.destroy
!     .plot_grid.destroy

   end

   read_x_points
   ! Read the number of x points for the plot. This is the precision
   ! of the plot.
      stdin.read(.n_x)
      ENSURE( .n_x>0,"number of x_points must be positive")
      WARN_IF(.n_x.is_even,"resetting to nearest odd number")
      .set_points_widths_origin
   end

   read_offset
   ! Read a 3-vector, used to offset the plot along.
      self :: INOUT

      val :: VEC{REAL}(3)

      stdin.read_quantity(val)

      .set_offset(val)

   end

   read_offset_cube
   ! Read a 3-vector, used to offset the plot along.
      self :: INOUT

      val :: VEC{REAL}(3)

      stdin.read_quantity(val)

      .set_offset_cube(val)

   end

   read_orbital
   ! Read the orbital to plot out
      self :: INOUT

      stdin.read(.orbital)

   end

   read_origin_atom
   ! Read whether the centre atom should be the origin of the plot
   ! default FALSE
      stdin.read(.origin_atom)
   end

   read_HOMO_orbital_plus
   ! Read the HOMO orbital to plot out. This is actually the index "n", where
   ! the orbital plotted out is "HOMO+n". The default value for n is 0, i.e. the
   ! HOMO is plotted out.
      self :: INOUT

      stdin.read(.HOMO_orbital)
      ENSURE(.HOMO_orbital<=0,"HOMO orbital must be less than or equal to zero")

   end

   read_HOMO_orbital_minus
   ! Read the minus HOMO orbital to plot out. This actually the index "n" where
   ! the orbital to be plotted out is "HOMO-n". The default value for n is 0,
   ! i.e. the HOMO is plotted out.
      self :: INOUT

      orb :: INT

      stdin.read(orb)

      .HOMO_orbital = -orb
      ENSURE(.HOMO_orbital<=0,"HOMO orbital must be less than or equal to zero")

   end

   read_LUMO_orbital_plus
   ! Read the LUMO orbital to plot out. This is actually the index "n" where the
   ! orbital to be plotted out is "LUMO+n". The default value of n is -1, and
   ! the HOMO is plotted out by default; if thgis routine is called then the
   ! value must be non-zero and we know that the LUMO value was set.
      self :: INOUT

      stdin.read(.LUMO_orbital)
      ENSURE(.LUMO_orbital>=0,"LUMO orbital must be greater than or equal to zero")

      .HOMO_orbital = .LUMO_orbital + 1

   end

   read_center_atom
   ! Read the center atom of the plot
      self :: INOUT

      stdin.read(.center_atom)

      .set_center_from_atom_list(.atom)

   end

   read_center_atoms ::: leaky
   ! Make the center of the plot to be the center of the list of atom indices.
   ENSURE(.atom.associated,"atom list not present")
      i,n :: INT

      ! Read the center atoms list (leaky)
      .center_atoms.destroy
      stdin.read_ptr(.center_atoms)
      ENSURE(.center_atoms.dim>0,"no atoms specified in input")

      ! Get the center
      .center = ZERO
      n = .center_atoms.dim
      do i = 1,n
         .center = .center + .atom(.center_atoms(i)).position
      end
      .center = .center/REALIFY(n)

      ! Set the origin
      .set_origin

   end

   read_center
   ! Read the center position of the plot. Also adjust the origin of the plot.
      stdin.read_quantity(.center)
      .set_origin
   end

   read_x_axis
   ! Read the x axis vector of the plot. Normally, the y and z axes are defined
   ! to be orthogonal to the inputted axes, based on the defualt axis settings.
   ! However, if the z axis has been explicitly defined before hand, then the x
   ! and y axes are orthogonalised to it.

      stdin.read(.x_axis)

      .x_axis_defined = TRUE

      .set_xyz_axes_from_x_axis

   end

   read_x_axis_atoms
   ! Read the atoms which define the x axis vector of the plot. If the z axis
   ! has been defined, then the x_axis is orthogonalised to it. Otherwise the y
   ! and z axes are orthogonalised to this vector.
      stdin.read(.x_atom_1)
      stdin.read(.x_atom_2)
      DIE_IF(.x_atom_1==.x_atom_2,"cannot specify same x axis atoms")
      .x_axis_defined = TRUE
      .set_x_axis_from_atom_list(.atom)
   end

   read_x_axis_atom_list
   ! Make the x-axis along the mean of two lists of atoms.

   ENSURE(.atom.associated,"atom list not present")

      atom_list :: VEC{INT}*
      pos1,pos2 :: VEC{REAL}(3)
      i :: INT

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos1 = ZERO
      do i=1,atom_list.dim
         pos1 = pos1 + .atom(atom_list(i)).position
      end
      pos1 = pos1/atom_list.dim
      atom_list.destroy

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos2 = ZERO
      do i=1,atom_list.dim
         pos2 = pos2 + .atom(atom_list(i)).position
      end
      pos2 = pos2/atom_list.dim
      atom_list.destroy

      .x_axis = pos2 - pos1

      .x_axis_defined = TRUE

      if (NOT .x_width_set) then
         .width(1) = FOUR*.x_axis.norm
         .set_points_widths_origin
      end

      .set_xyz_axes_from_x_axis


   end

   read_y_axis
   ! Read the y axis vector of the plot. It is an error to use this command if
   ! the .z_axis has already been inputted, because the .y_axis is made
   ! orthogonal to the x_axis and z_axis. Even if the z_axis has not been
   ! defined, the y_axis is made orthogonal to the x_axis.
      stdin.read(.y_axis)
      .y_axis_defined = TRUE
      .set_xyz_axes_from_y_axis
   end

   read_y_axis_atoms
   ! Read the atoms which define the y axis vector of the plot. It is an error
   ! to use this command if the .z_axis has already been inputted, because the
   ! .y_axis is made orthogonal to the x_axis and z_axis. Even if the z_axis has
   ! not been
      stdin.read(.y_atom_1)
      stdin.read(.y_atom_2)
      DIE_IF(.y_atom_1==.y_atom_2,"cannot specify same y axis atoms")
      .y_axis_defined = TRUE
      .set_y_axis_from_atom_list(.atom)
   end

   read_y_axis_atom_list
   ! Make the y-axis along the mean of two lists of atoms.
   ENSURE(.atom.associated,"atom list not present")
      atom_list :: VEC{INT}*
      pos1,pos2 :: VEC{REAL}(3)
      i :: INT

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos1 = ZERO
      do i=1,atom_list.dim
         pos1 = pos1 + .atom(atom_list(i)).position
      end
      pos1 = pos1/atom_list.dim
      atom_list.destroy

      stdin.read_ptr(atom_list)
      ENSURE(atom_list.dim>0,"no atoms specified in input")

      pos2 = ZERO
      do i=1,atom_list.dim
         pos2 = pos2 + .atom(atom_list(i)).position
      end
      pos2 = pos2/atom_list.dim
      atom_list.destroy

      .y_axis = pos2 - pos1

      .y_axis_defined = TRUE

      if (NOT .y_width_set) then
         .width(2) = FOUR*.y_axis.norm
         .set_points_widths_origin
      end

      .set_xyz_axes_from_y_axis

   end

   read_z_axis
   ! Read the z axis of the plot. NOTE: If it is inputted, the current x and y
   ! axes are made orthogonal to it.
      stdin.read(.z_axis)
      .z_axis_defined = TRUE
      .set_xyz_axes_from_z_axis
   end

   read_z_axis_atoms
   ! Read the atoms which define the z axis vector of the plot.
      stdin.read(.z_atom_1)
      stdin.read(.z_atom_2)
      DIE_IF(.z_atom_1==.z_atom_2,"cannot specify same z axis atoms")
      .z_axis_defined = TRUE
      .set_z_axis_from_atom_list(.atom)
   end

   read_x_width
   ! Read the x width of the plot
      stdin.read_quantity(.width(1))
      .set_points_widths_origin
      .x_width_set = TRUE
   end

   read_y_width
   ! Read the y width of the plot
      stdin.read_quantity(.width(2))
      .set_points_widths_origin
      .y_width_set = TRUE
   end

   read_z_width
   ! Read the z width of the plot. This is normally 0.
      stdin.read_quantity(.width(3))
      .set_points_widths_origin
      .z_width_set = TRUE
   end

   read_bond_density_atoms ::: leaky
   ! Read bond density atoms
      n_atom :: INT

      .bond_density_atom.destroy
      stdin.read_ptr(.bond_density_atom)

      ! Check
      n_atom = .bond_density_atom.dim
      ENSURE(n_atom>=1 AND n_atom<=3,"wrong length for bond_density_atoms")
      if (n_atom==3) then
      ENSURE(any(.bond_density_atom(1:2)==.bond_density_atom(3)),"atom 3 unmatching")
      end

   end

   read_box_scale_factor
   ! Read the bounding box scale factor and apply it immediately.
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .set_box_scale_factor(val)

      .set_box_axes

   end

   read_cube_scale_factor
   ! Read the bounding box scale factor and apply it immediately.
      self :: INOUT

      val :: REAL

      stdin.read(val)
      .set_box_scale_factor(val)

      .set_cube_scale_factor(val)

   end

   read_projection_direction
   ! Read the directionb to prject the vectors onto
      stdin.read(.projection_direction)
      .projection_direction.normalise
   end

   read_points_filename
   ! Read 3D points grid filename
      stdin.read(.points_filename)
   end

   read_3D_grid(pt) ::: leaky
   ! Read Cassam-Chenai's 3D grid
      self :: PTR
      pt :: MAT{REAL}*, OUT
      ENSURE(.associated, "no grid")
      textfile :: TEXTFILE*
      i :: INT

      ! Open the file for reading
      textfile.create(.points_filename)
      textfile.open_for("read")

      ! Read them in
      pt.create(.n_pt,3)
      do i = 1,.n_pt
         read(textfile.unit,*) pt(i,:)
      !  print *, "pt(i,:) = ",pt(i,:)
      end

      textfile.close
      textfile.destroy

   end

   read_contour_min_value ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_contour_min_value), private
   ! Generic read and set a quantity with units
   end

   read_contour_max_value ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_contour_max_value), private
   ! Generic read and set a quantity with units
   end

   read_contour_increment ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_contour_increment), private
   ! Generic read and set a quantity with units
   end

   read_contour_min_color ::: private
   ! Read the color used for the minimum-value contour
      .contour_min_color.read
   end

   read_contour_max_color ::: private
   ! Read the color used for the maximum-value contour
      self :: INOUT

      .contour_max_color.read

   end

   read_contour_mid_color ::: private
   ! Read the color used for the mid-value contour, usually the
   ! zero-value contour
      .contour_mid_color.read
   end

   read_contour_color_scale ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_contour_color_scale), private
   ! Generic read and set
   end

   read_contour_line_width ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_contour_line_width), private
   ! Generic read and set a quantity with units
   end

   read_contour_tic_dps ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_contour_tic_dps), private
   ! Generic read and set
   end

   read_contour_font_size ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_contour_font_size), private
   ! Generic read and set
   end

   read_contour_fade_factor ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_contour_fade_factor), private
   ! Generic read and set a quantity with units
   end

   read_use_colorbox_scale ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_colorbox_scale), private
   ! Generic read and set
   end

   read_use_ruler_scale ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_ruler_scale), private
   ! Generic read and set
   end

   read_contour_scale ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_contour_scale), private
   ! Generic read and set
   end

!  ============
!  Bounding box
!  ============

   set_box_scale_factor(factor) ::: PURE
   ! Set the bounding box scale factor
      self :: INOUT
      factor :: REAL, IN

      .box_scale_factor = factor

   ENSURE(.box_scale_factor>ZERO,"scale factor not positive")

   end

   set_box_axes ::: private, PURE
   ! Set box axes -- they might have different widths.
      self :: INOUT

      if (.x_or_y_or_z_axes_defined) then; .use_bbox_with_current_axes
      else;                                .use_bbox_with_shape_axes
      end

   end

   set_cube_scale_factor(factor) ::: PURE
   ! Set the bounding cube scale factor
      self :: INOUT
      factor :: REAL, IN

      .set_box_scale_factor(factor)

      .set_cube_axes

   end

   set_cube_axes ::: private, PURE
   ! Set cube axes
      self :: INOUT

      if (.x_or_y_or_z_axes_defined) then; .use_bcube_with_current_axes
      else;                                .use_bcube_with_shape_axes
      end

   end

   use_bbox_with_current_axes ::: private, PURE
   ! Use a bounding box axes and widths coming from the current
   ! user-specified axes
      self :: INOUT

      .set_bbox_with_current_axes(.atom)

      .center = .box_center
      .width  = .box_widths
      .x_axis = .box_axes(:,1)
      .y_axis = .box_axes(:,2)
      .z_axis = .box_axes(:,3)

      .set_points_widths_origin

   end

   use_bbox_with_shape_axes ::: private, PURE
   ! Use a bounding box axes and widths coming from the principal axes
   ! of the shape tensor (the inertia tensor with unit atomic masses).
      self :: INOUT

      .set_bbox_with_shape_axes(.atom)

      .center = .box_center
      .width  = .box_widths
      .x_axis = .box_axes(:,1)
      .y_axis = .box_axes(:,2)
      .z_axis = .box_axes(:,3)

      .set_points_widths_origin

   end

   use_bcube_with_current_axes ::: PURE
   ! Use a bounding cube from the current axes. The box width are
   ! taken to be the maximum of the three widths along current axes.
      self :: INOUT

      .set_bbox_with_current_axes(.atom)

      .center = .box_center

      .width  = maxval(.box_widths)
      .n_x    = maxval([.n_x,.n_y,.n_z])
      .n_y    = .n_x
      .n_z    = .n_x

      .x_axis = .box_axes(:,1)
      .y_axis = .box_axes(:,2)
      .z_axis = .box_axes(:,3)

      .set_points_widths_origin

   end

   use_bcube_with_shape_axes ::: PURE
   ! Use a bounding cube from the current shape tensor. The box width
   ! is taken to be the maximum of the three widths.
      self :: INOUT

      .set_bbox_with_shape_axes(.atom)

      .center = .box_center
      .width  = maxval(.box_widths)
      .x_axis = .box_axes(:,1)
      .y_axis = .box_axes(:,2)
      .z_axis = .box_axes(:,3)

      .set_points_widths_origin

   end

!   use_unit_cell_as_bbox
!   ! Use the unit cell as the bounding box.  This sets a switch and
!   ! the axes must be obtained afterwards from a supplied cell.
!       .use_unit_cell_as_bbox = TRUE
!   end

!   widths_were_set result (res)
!   ! Return TRUE if any of the widths were inputted.
!      res :: BIN
!      res =  .x_width_set &
!          OR .y_width_set &
!          OR .z_width_set
!   end

!   read_crystal_plane(in,unit_cell)
!   ! To read in a vector which describes a plane in the crystal.
!   ! The vector is the normal of the plane.
!     in :: INPUT
!     unit_cell :: UNIT_CELL, IN
!     in.read( .z_axis )
!     .z_axis.rotate(unit_cell.cell_matrix)
!     .z_axis.normalise
!     .x_axis.normalise
!     .y_axis.to_cross_product_of( .z_axis, .x_axis)
!     .y_axis.normalise
!     .x_axis.to_cross_product_of( .y_axis, .z_axis)
!     .x_axis.normalise
!   end

!  ================
!  Make grid points
!  ================

   make_points(x_pt,y_pt,z_pt) ::: PURE
   ! Make a list of the grid points
      self :: IN
      x_pt,y_pt,z_pt :: VEC{REAL}, OUT

   ENSURE(x_pt.dim==.n_pt,"x_pt not correct size")
   ENSURE(y_pt.dim==.n_pt,"y_pt not correct size")
   ENSURE(z_pt.dim==.n_pt,"z_pt not correct size")

      x1,x2,x3,y1,y2,y3,z1,z2,z3 :: REAL
      ox,oy,oz :: REAL
      ix,iy,iz,i,t2,t3 :: INT

      ox = .origin(1)
      oy = .origin(2)
      oz = .origin(3)

      x1 = .del_x*.x_axis(1)
      x2 = .del_x*.x_axis(2)
      x3 = .del_x*.x_axis(3)

      y1 = .del_y*.y_axis(1)
      y2 = .del_y*.y_axis(2)
      y3 = .del_y*.y_axis(3)

      z1 = .del_z*.z_axis(1)
      z2 = .del_z*.z_axis(2)
      z3 = .del_z*.z_axis(3)

      t2 = .n_x*.n_y

      do i = 1,.n_pt

         iz = (i-1)/t2
         t3 = i - iz*t2
         iy = (t3-1)/.n_x
         ix = t3 - iy*.n_x - 1

         x_pt(i) = ox + ix*x1 + iy*y1 + iz*z1
         y_pt(i) = oy + ix*x2 + iy*y2 + iz*z2
         z_pt(i) = oz + ix*x3 + iy*y3 + iz*z3

      end

   end

   make_points(pt,first,last) ::: PURE
   ! Return a list of the grid points in "pt". Will return a subset of
   ! the grid points from "first" to "last", if these options
   ! are provided.
      self :: IN
      first,last :: INT, optional, IN
      pt :: MAT{REAL}, OUT

   ENSURE(.n_x/=0,"zero number of x points")
   ENSURE(.n_y/=0,"zero number of y points")

      x1,x2,x3,y1,y2,y3,z1,z2,z3 :: REAL
      ox,oy,oz :: REAL
      ix,iy,iz,i,f,l,t2,t3 :: INT

      f = 1
      if (present(first)) f = first

      l = pt.dim1
      if (present(last))  l = last

      ox = .origin(1)
      oy = .origin(2)
      oz = .origin(3)

      x1 = .del_x*.x_axis(1)
      x2 = .del_x*.x_axis(2)
      x3 = .del_x*.x_axis(3)

      y1 = .del_y*.y_axis(1)
      y2 = .del_y*.y_axis(2)
      y3 = .del_y*.y_axis(3)

      z1 = .del_z*.z_axis(1)
      z2 = .del_z*.z_axis(2)
      z3 = .del_z*.z_axis(3)

      t2 = .n_x*.n_y

      do i = f,l

         iz = (i-1)/t2
         t3 = i - iz*t2
         iy = (t3-1)/.n_x
         ix = t3 - iy*.n_x - 1

         pt(i,1) = ox + ix*x1 + iy*y1 + iz*z1
         pt(i,2) = oy + ix*x2 + iy*y2 + iz*z2
         pt(i,3) = oz + ix*x3 + iy*y3 + iz*z3

      end

   end

   make_points(pt,fx,lx,fy,ly,fz,lz) ::: PURE
   ! Return a list of the grid points in "pt" in grid xyz order, starting from
   ! the first and last x, y, and z points: "fx", "lx", "fy", "ly", "fz", "lz"
   ! respectively
      self :: IN
      pt :: MAT{REAL}, OUT
      fx,lx,fy,ly,fz,lz :: INT, IN

   ENSURE(pt.dim1==(lx-fx+1)*(ly-fy+1)*(lz-fz+1),"wrong 1st dimension, pt")
   ENSURE(pt.dim2==3,"wrong 2nd dimension, pt")

      x1,x2,x3,y1,y2,y3,z1,z2,z3 :: REAL
      ox,oy,oz :: REAL
      x,y,z,ix,iy,iz,i :: INT

      ox = .origin(1)
      oy = .origin(2)
      oz = .origin(3)

      x1 = .del_x*.x_axis(1)
      x2 = .del_x*.x_axis(2)
      x3 = .del_x*.x_axis(3)

      y1 = .del_y*.y_axis(1)
      y2 = .del_y*.y_axis(2)
      y3 = .del_y*.y_axis(3)

      z1 = .del_z*.z_axis(1)
      z2 = .del_z*.z_axis(2)
      z3 = .del_z*.z_axis(3)

      i = 0

      do z = fz,lz
      do y = fy,ly
      do x = fx,lx

         ix = x - 1
         iy = y - 1
         iz = z - 1
         i  = i + 1

         pt(i,1) = ox + ix*x1 + iy*y1 + iz*z1
         pt(i,2) = oy + ix*x2 + iy*y2 + iz*z2
         pt(i,3) = oz + ix*x3 + iy*y3 + iz*z3

      end
      end
      end

   end

   point(x,y,z) result (res) ::: PURE
   ! Return one particular point "res" of the grid, given by grid coordinates
   ! "x", "y", and "z". (1,1,1) is the bottom (front) left hand corner.
      self  :: IN
      x,y,z :: INT, IN
      res   :: VEC{REAL}(3)

      x1,x2,x3,y1,y2,y3,z1,z2,z3,ox,oy,oz :: REAL
      ix,iy,iz :: INT

      ox = .origin(1)
      oy = .origin(2)
      oz = .origin(3)

      x1 = .del_x*.x_axis(1)
      x2 = .del_x*.x_axis(2)
      x3 = .del_x*.x_axis(3)

      y1 = .del_y*.y_axis(1)
      y2 = .del_y*.y_axis(2)
      y3 = .del_y*.y_axis(3)

      z1 = .del_z*.z_axis(1)
      z2 = .del_z*.z_axis(2)
      z3 = .del_z*.z_axis(3)

      ix = x - 1
      iy = y - 1
      iz = z - 1

         res(1) = ox + ix*x1 + iy*y1 + iz*z1
         res(2) = oy + ix*x2 + iy*y2 + iz*z2
         res(3) = oz + ix*x3 + iy*y3 + iz*z3

   end

   make_cube_of_points(p,f,l,del_x,del_y,del_z,x,y,z,eval) ::: public, PURE
   ! Return a cube of points "p" where the cube edge points start from
   ! index "f" and end at index "l", and each point separated by
   ! distance "del_x", "del_y", "del_z" along a grid axis direction
   ! (these are *not* the same as the grid .del's).  The (0,0,0) point
   ! of the cube "p" corresponds to the plot grid coordinates "x", "y",
   ! "z", which are numbered from 0 (normally the first point is
   ! numbered from 1; these are grid coords in .del_x, .dely, .del_z).
   ! The axes of the cube are given by the plot grid axes.
      self  :: IN
      f,l,x,y,z :: INT, IN
      p :: MAT{REAL}(3,*), OUT
      del_x,del_y,del_z :: REAL, IN
      eval :: VEC{BIN}(*), optional, IN

      x1,x2,x3,y1,y2,y3,z1,z2,z3,ox,oy,oz :: REAL
      ix,iy,iz,k :: INT

      ! Plot grid axes times plot grid del's
      x1 = .del_x*.x_axis(1); x2 = .del_x*.x_axis(2); x3 = .del_x*.x_axis(3)
      y1 = .del_y*.y_axis(1); y2 = .del_y*.y_axis(2); y3 = .del_y*.y_axis(3)
      z1 = .del_z*.z_axis(1); z2 = .del_z*.z_axis(2); z3 = .del_z*.z_axis(3)

      ! Cube origin in plotrgrid coords
      ox = .origin(1) + x*x1 + y*y1 + z*z1
      oy = .origin(2) + x*x2 + y*y2 + z*z2
      oz = .origin(3) + x*x3 + y*y3 + z*z3

      ! Plotgrid axes times cube del's
      x1 = del_x*.x_axis(1); x2 = del_x*.x_axis(2); x3 = del_x*.x_axis(3) !
      y1 = del_y*.y_axis(1); y2 = del_y*.y_axis(2); y3 = del_y*.y_axis(3)
      z1 = del_z*.z_axis(1); z2 = del_z*.z_axis(2); z3 = del_z*.z_axis(3)

      if (NOT present(eval)) then

         k = 0
         do iz = f,l
         do iy = f,l
         do ix = f,l
            k = k + 1
            p(1,k) = ox + ix*x1 + iy*y1 + iz*z1
            p(2,k) = oy + ix*x2 + iy*y2 + iz*z2
            p(3,k) = oz + ix*x3 + iy*y3 + iz*z3
         end
         end
         end

      else

         k = 0
         do iz = f,l
         do iy = f,l
         do ix = f,l
            k = k + 1
            if (NOT eval(k)) cycle
            p(1,k) = ox + ix*x1 + iy*y1 + iz*z1
            p(2,k) = oy + ix*x2 + iy*y2 + iz*z2
            p(3,k) = oz + ix*x3 + iy*y3 + iz*z3
         end
         end
         end

      end

   end

   make_math_pos(math_pos,z_range,valid) ::: leaky
   ! Calculate the positions "math_pos" of the valid atoms which have
   ! been rotated and shifted and scaled into grid point coordinates.
   ! Valid atoms are those which are within "z_range" of the plot
   ! plane; the indices of the valid atoms are stored in "valid"
      math_pos :: MAT{REAL}*
      z_range :: REAL, IN
      valid :: VEC{INT}*

   ENSURE(.atom.associated,"no atoms!")
   ENSURE(z_range>ZERO,"z_range must be non-negative")
   ENSURE(valid.disassociated,"valid array already allocated")

      scale_factor,p :: VEC{REAL}(3)
      tr :: MAT{REAL}(3,3)
      pos :: MAT{REAL}*
      n,nv,a,i :: INT

      ! Get shifted atom positions
      n = .atom.dim
      pos.create(n,3)
      do a = 1, n
         pos(a,:) = .atom(a).position - .origin    !shift
      end

      ! Rotate positions into plot grid axis
      tr = .transposed_plot_axes
      do a = 1, n
         p = pos(a,:)
         pos(a,:).to_product_of(tr,p)
      end

      ! Reject atoms far from plot plane, get valid atoms
      valid.create(0)
      do a = 1, n
        ! if ( abs(pos(a,z)) > z_range) cycle
         if ( abs(pos(a,3)) > z_range) cycle
         valid.append(a)
      end

      ! Create list of valid atoms positions
      nv = valid.dim
      math_pos.create(nv,3)
      i = 0
      do a = 1, n
         if ( abs(pos(a,3)) > z_range) cycle
         i = i + 1
         math_pos(i,:) = pos(a,:)
      end

      ! Finally, scale positions
      scale_factor(1) = (.n_x - ONE) / .width(1)
      scale_factor(2) = (.n_y - ONE) / .width(2)
      scale_factor(3) = ZERO
      do a = 1,nv
         math_pos(a,:) = scale_factor * math_pos(a,:) + ONE ! since plot begins at 1
      end

      pos.destroy

   end

!  ======
!  Output
!  ======

   put(title)
   ! Put the grid data to "stdout"
      self :: IN
      title :: STR, optional, IN

      axes :: MAT{REAL}(3,3)
      length,wid :: INT
      heading :: STR

      heading = "Plot grid data"
      if (present(title)) heading = title
      length = len_trim(heading)

      stdout.flush
      stdout.text(repeat("=",length))
      stdout.text(trim(heading))
      stdout.text(repeat("=",length))
      stdout.flush
      stdout.text("All coordinates are in au.")
      stdout.flush

      ! What is it?
      stdout.show("Kind of plot            =", .plot_kind)
      if (.orbital /= 0) &
      stdout.show("Plot orbital no.        =", .orbital)

      ! Point info ...
      stdout.flush
      stdout.text("No. of points:")
      stdout.show("Number of X grid points =",.n_x)
      stdout.show("Number of Y grid points =",.n_y)
      stdout.show("Number of Z grid points =",.n_z)
      stdout.show("Total number of points  =",.n_pt)
      stdout.show("Point separation (del)  =",.del_x)

      ! Nice width
      axes = .plot_axes
      wid  = maxval(len_trim(axes.to_str("f",50,stdout.real_precision))) + 1
      axes = .plot_axes

      ! Centering
      stdout.flush
      stdout.text("Plot centering (xyz) :")
      stdout.show("Plot center point       =",.center,width=wid)
      if (NOT .offset.is_zero) &
      stdout.show("Center offset           =",.offset,width=wid)
      stdout.show("Bottom-left-front point =",.origin,width=wid)

      ! Plot axes
      stdout.flush
      stdout.text("Plot widths & axes:")
      if (.use_bounding_box) &
      stdout.show("Bounding box used?      =",.use_bounding_box)

      stdout.show("Widths                  =",.width,wid)
      stdout.show("Axis vector columns     =",axes(1,:),width=wid)
      stdout.show("                        =",axes(2,:),width=wid)
      stdout.show("                        =",axes(3,:),width=wid)

      ! Atom-based data
      if (.atom_data_used) then

      stdout.flush
      stdout.text("Atom-based specifications:")

      if (.center_atoms.associated) then
      stdout.show("Center atoms list       =",.center_atoms.to_concatenated_str)
      else if (.center_atom/=0) then
      stdout.show("Center atom             =",.center_atom)
      end

      if (.x_atom_1/=0) then
      stdout.show("X axis atom 1           =",.x_atom_1)
      stdout.show("X axis atom 2           =",.x_atom_2)
      end

      if (.y_atom_1/=0) then
      stdout.show("Y axis atom 1           =",.y_atom_1)
      stdout.show("Y axis atom 2           =",.y_atom_2)
      end

      end

   end

   put_minimal
   ! Put minimal *angstrom*
      self :: IN

      fac :: REAL

      fac = ANGSTROM_PER_BOHR

      stdout.show("No. of X grid points     =",.n_x)
      stdout.show("No. of Y grid points     =",.n_y)
      stdout.show("No. of Z grid points     =",.n_z)
      stdout.show("Total no. of points      =",.n_pt)
      stdout.show("X point separation       =",.del_x*fac)
      stdout.show("Y point separation       =",.del_y*fac)
      stdout.show("Z point separation       =",.del_z*fac)

   end

end
