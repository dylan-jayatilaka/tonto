! json.foo
! Module for printing and/or reading JSON data
! This module uses nonstandard JSON, only for complex numbers.
! They will be formatted as follows: (Re, Im)
! Created Mon 11 Aug 2014 15:04:32 WST

module JSON

    implicit none

    out :: TEXTFILE@, public

contains

!  ==========
!  Allocation
!  ==========

   create(file_name) ::: leaky, PURE
   ! Allocate an object
      self :: allocatable, OUT
      file_name :: STR, optional, IN

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

#ifdef USE_PRECONDITIONS
      allocate(self,stat=status)
      ENSURE(status==0,"error in allocating memory")
#else
      allocate(self)
#endif

       if (present(file_name)) .set_name(file_name)
       .out.create(.name)
       .out.set_column_spacing(1)
       .out.set_using_fields(FALSE)

   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

!  ===========
!  Set methods
!  ===========

   set_name(file_name)
   ! Set the file name
       self :: INOUT
       file_name :: STR, IN

   ENSURE(file_name/=" ","name is blank!")

       .name = file_name 

   end

   set_defaults
   ! Set defaults
       .name = "out.json"
       .margin = 0
   end

!  =====
!  Write
!  =====

   write_start 
   ! Write opening brace
      self :: INOUT

      .out.open(for="write")
      .out.text("{")
      .margin = .margin + 2
      .out.set_margin_width(.margin)

   end

   write_end
   ! Write closing brace
      self :: INOUT

      .margin = .margin - 2
      .out.set_margin_width(.margin)
      .out.flush
      .out.text("}")
      .out.close

   end

   write_cpx(c)
   ! Write a CPX "value" the right way.
      self :: INOUT
      value :: CPX, IN

      s :: STR(16)
      r, i :: REAL

      r = RE(value)
      i = IM(value)
      write (s, '(1x, 1("(", F5.2) , 1(",", F5.2, ")"))') r, i
      .out.put(s)
   
   end

   write_vec(v, separator) ::: template
   ! Write a vector "v" using a "separator" (if needed)
      self :: INOUT
      v :: V?, IN
      separator :: STR, optional, IN
 ! WARN_IF(v.dim == 0, "Zero sized dimension!")

      i   :: INT
      sep :: STR

      sep = ', '                         ! Magic constant
      if (present(separator)) sep = separator

      .out.put('\[ ')
      do i = 1, v.dim
         if (i>1)         .out.put(sep)
         if (mod(i,5)==0) .out.text(" ") ! Magic number
         .out.put(v(i))
      end
      .out.put('\]')
      .out.flush

   end

   write_vec(v, separator) ::: get_from(JSON, V?=>VEC{STR})
   ! Write a vector "v" using a "separator" (if needed)
   end

   write_vec(v, separator) ::: get_from(JSON, V?=>VEC{REAL})
   ! Write a vector "v" using a "separator" (if needed)
   end

   write_vec(v, separator) ::: get_from(JSON, V?=>VEC{INT})
   ! Write a vector "v" using a "separator" (if needed)
   end

   write_vec(v, separator)
   ! Write a vector "v" using a "separator" (if needed)
      self :: INOUT
      v    :: VEC{CPX}, IN
      separator :: STR, optional, IN
 ! WARN_IF(v.dim == 0, "Zero sized dimension!")

      i   :: INT
      sep :: STR

      sep = ', '
      if (present(separator)) sep = separator

      .out.put('\[ ')
      do i = 1, dim
         if (i>1)         .out.put(sep)
         if (mod(i,7)==0) .out.text(" ")
         end
         .write_cpx(v(i))
      end
      .out.put('\]')
      .out.flush

   end

!  ===========
!  Put entries
!  ===========

   put_entry(name, value) ::: template
   ! Put entry "name" to have "value"
      self :: INOUT
      value :: T?
      name :: STR

      .out.put('"')
      .out.put(name)
      .out.put('": ')
      .out.put(value)
      .out.flush

   end

   put_entry(name, value) ::: get_from(JSON, T?=>STR)
   ! Put entry "name" to have "value"
   end

   put_entry(name, value) ::: get_from(JSON, T?=>INT)
   ! Put entry "name" to have "value"
   end
  
   put_entry(name, value) ::: get_from(JSON, T?=>REAL)
   ! Put entry "name" to have "value"
   end

   put_entry(name, value)
   ! Put entry "name" to have CPX "value"
      self :: INOUT
      name :: STR
      value :: CPX

      .out.put('"')
      .out.put(name)
      .out.put('" : ')
      .write_cpx(value)
      .out.flush

   end


   put_entry(name, v, separator) ::: template
   ! Put "name" to have vector value "v" with "separator" (if needed)
      self :: INOUT
      v    :: V?, IN
      name :: STR, IN
      separator :: STR, optional, IN

      .out.put('"')
      .out.put(name)
      .out.put('": ')
      .write_vec(value, separator)
      .out.text(" ")

   end

   put_entry(name, v, separator) ::: get_from(JSON, V?=>VEC{STR})
   ! Put "name" to have vector value "v" with "separator" (if needed)
   end

   put_entry(name, v, separator) ::: get_from(JSON, V?=>VEC{REAL})
   ! Put "name" to have vector value "v" with "separator" (if needed)
   end

   put_entry(name, v, separator) ::: get_from(JSON, V?=>VEC{INT})
   ! Put "name" to have vector value "v" with "separator" (if needed)
   end

   put_entry(name, v, separator) ::: get_from(JSON, V?=>VEC{CPX})
   ! Put "name" to have vector value "v" with "separator" (if needed)
   end

end
