!===============================================================================
!
! MOLECULE.PLOT: An object representation of a molecule.
!
! These are plot-controlling procedures. Most of the actual grids are
! made in .GRid .
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996-2012
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: $
!===============================================================================

module MOLECULE.PLOT

   implicit none

contains

!  ========
!  2D plots
!  ========

   plot ::: leaky
   ! Do one of the many kinds of plot calculations
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")

      ! Set up
      .:set_up_for_plot(.plot_grid.plot_kind)

      ! Use unit cell as bbox if requested
      if (.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         ENSURE(.crystal.associated,"no crystal or unit cell for plot!")
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)
      end

      ! See plot_grid parameters
      .plot_grid.put

      ! Do the plot
      .:do_plot

   end

   plots ::: leaky
   ! Do one of the many kinds of plot calculations
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.plot_grid.plot_kinds.associated, "no multiple plot_kinds!")

      i :: INT

      ! Loop over plots and do each one
      do i = 1,.plot_grid.plot_kinds.dim
         .plot_grid.set_plot_kind( .plot_grid.plot_kinds(i))
         .plot_grid.set_plot_units(.plot_grid.plot_kinds_units(i))
         .:plot
      end

      ! Reset to blank
      .plot_grid.set_plot_kind(" ")
      .plot_grid.set_plot_units(" ")

   end

   do_plot ::: leaky
   ! Do one of the many kinds of plot calculations. These are usually
   ! 2D plots but they can be rectilinear volumetric plots, depending
   ! on how .plot_grid was defined by the user.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")

      name :: STR
      grid :: VEC{REAL}@
      pt :: MAT{REAL}@

      ! Make the grid points
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make the property values.
      grid.create(.plot_grid.n_pt)
      .GRID:make_prop_values(grid,pt)

      ! Print out
      name = .plot_grid.plot_file_name(.n_a)
      .GRID:dump_plot_grid(grid,name)

      ! Clean up
      pt.destroy
      grid.destroy

   end


   plot_fragments
   ! Do the summed-fragment property density on ".plot_grid".
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.atom_group.associated,"no atom_group info")
   ENSURE(.crystal.associated,"no crystal")

      ! Use unit cell as bbox if requested
      if (.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         ENSURE(.crystal.associated,"no crystal or unit cell for plot!")
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)
      end

      ! See plot_grid parameters
      .plot_grid.put

      ! Do the plot
      .:do_fragment_plot

   end

   do_fragment_plot
   ! Do the summed-fragmened  property density on ".plot_grid" using
   ! the molecules in .atom_group(:).mol.
      self :: INOUT

   ENSURE(.plot_grid.associated, "no grid")
   ENSURE(.atom_group.associated,"no atom_group info")
   ENSURE(.crystal.associated,"no crystal")

      mol :: MOLECULE*
      name :: STR
      grid, frag :: VEC{REAL}@
      pt :: MAT{REAL}@
      g :: INT

      ! Make the grid points
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      frag.create(.plot_grid.n_pt)

      ! Initialise
      grid = ZERO

      do g = 1,.atom_group.dim

         ! Set up a molecule for this group of atoms
         mol => .atom_group(g).mol
         DIE_IF(mol.disassociated,"molecule group "//trim(g.to_str)//" not defined!")

         ! Skip SCF for atoms without electrons
         ! Question: any plots which work with no electrons?
         if (mol.BASE:no_of_electrons < 1) cycle

         ! Do the plot for this fragment
         ! Use the parent .plot_grid
         mol.plot_grid => .plot_grid
         mol.:set_up_for_plot(mol.plot_grid.plot_kind)
         mol.GRID:make_prop_values(frag,pt)
         nullify(mol.plot_grid)

         ! Add up this contribution
         grid = grid + frag

      end

      ! Print out
      name = .plot_grid.plot_file_name(.n_a)
      .GRID:dump_plot_grid(grid,name)

      ! Clean up
      pt.destroy
      grid.destroy

   end

!  ===============
!  Isosurface plot
!  ===============

   isosurface_plot ::: leaky
   ! Do one of the many kinds of isosurface plot calculations
      self :: PTR

   ENSURE(.isosurface.associated,"no isosurface")

      ! Set up
      .:set_up_for_plot(.isosurface.property)

      ! Save self for selfless function calls
      .BASE:set_saved_self

      ! Do the plot
      .GRID:do_isosurface_plot

   end

   saved_isosurface_plot ::: leaky
   ! Do an isosurface plot using the CURRENT .isosurface information
   ! with the .saved molecule atom list, density functions, MOs, etc.
      self :: PTR

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.saved.associated,"no saved molecule")

      saved_isosurface :: ISOSURFACE*

      ! Set .saved.isosurface to be current .isosurface
      saved_isosurface  => .saved.isosurface
      .saved.isosurface => .isosurface

      ! Set up
      .saved.:set_up_for_plot(.isosurface.property)

      ! Set saved_self to be .saved molecule
      .saved.BASE:set_saved_self

      ! Do the plot -- current molecule isosurface
      .saved.GRID:do_isosurface_plot

      ! Put back the saved isosurface the way it was
      .saved.isosurface => saved_isosurface

   end

!  ==============================
!  Plot property on an isosurface
!  ==============================

   plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface - useful for mapping properties on a surface.
      self :: PTR

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no surface_property given!")

      ! Set up
      .:set_up_for_plot(.isosurface.surface_property)

      ! Save self for selfless function calls
      .BASE:set_saved_self

      ! Do the plot
      .GRID:do_plot_property_on_isosurface

   end

   saved_plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface - for mapping properties on a surface - but using the
   ! CURRENT .isosurface. information with the .saved molecule atom
   ! list, density functions, MO's.
      self :: PTR

   ENSURE(.isosurface.associated,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no surface_property given!")
   ENSURE(.saved.associated,"no saved molecule")

      saved_isosurface :: ISOSURFACE*

      ! Set .saved.isosurface to be current .isosurface
      saved_isosurface  => .saved.isosurface
      .saved.isosurface => .isosurface

      ! Set up
      .saved.:set_up_for_plot(.isosurface.surface_property)

      ! Save self for selfless function calls
      .saved.BASE:set_saved_self

      ! Do the plot -- current molecule isosurface
      .saved.GRID:do_plot_property_on_isosurface

      ! Put back the saved isosurface the way it was
      .saved.isosurface => saved_isosurface

   end

!  ====================
!  Set-up info for plot
!  ====================

   set_up_for_plot(plot_kind) ::: leaky
   ! Do plot-specific initialization
      self :: INOUT
      plot_kind :: STR, IN

      ! Make the becke grids & overlapping atoms
      .:set_becke_grid_for_plot(plot_kind)

      ! Set atom plot info for deformation densities
      .:set_ANOs_for_plot(plot_kind)

      ! Set interpolators for stockholder or promolecule plots
      .:set_interpolators_for_plot(plot_kind)

      ! Set up densities & integrals for plot
      .:set_integrals_for_plot(plot_kind)

      ! Make sure group densities & MOs are there
      ! Warining: not for summed fragments plots
      .:set_group_densities_for_plot(plot_kind)

      ! Assign natural orbitals
      .BASE:assign_NOs_to_MOs

   end

   set_interpolators_for_plot(plot_kind) ::: private, leaky
   ! Set the interpolator info for all the atoms if the "plot_kind" is such
   ! that interpolation tables could be beneficial. This should be called just
   ! prior to doing the plot to take advantage of speed-ups.
      plot_kind :: STR, IN

      do_interpolator :: BIN

      do_interpolator = plot_kind      =="promolecule_density" &
                     OR plot_kind(1:11)=="stockholder"         &
                     OR plot_kind(1:11)=="deformation"       

      if (NOT do_interpolator) return

      ENSURE(.atom.associated,"no atom list")

      ! Get interpolators.
      select case (.atom(1).basis_kind)

      case ("slater")
         ENSURE(.slaterbasis.associated,"no slater bases")
         .GRID:make_slater_interpolators

      case ("coppens")
         ENSURE(.coppensbasis.associated,"no coppens bases")
         .GRID:make_coppens_interpolators

      case ("gaussian")
         ENSURE(.basis.associated,"no gaussian bases")
         .SCF:make_ANO_data

      end

   end

   set_ANOs_for_plot(plot_kind) ::: private, leaky
   ! Set the ANO info for all the atoms if the "plot_kind" is such
   ! that the ANO data must be made.
      plot_kind :: STR, IN

      if (plot_kind(1:11)=="deformation" OR plot_kind(1:4)=="e_hf") then

         ! If we get here, the ANO information will be used
         .SCF:make_ANO_data

      else if (plot_kind(1:5)=="bond_") then

         .SCF:make_ANO_data

       ! ! If we get here, the spherically averaged atom information will be used
       ! .make_spherical_atoms

      else if (plot_kind=="hirshfeld_atom_grid") then

         ! should be in set_up becke grid?
         .SCF:make_Hirshfeld_inputs(skip_NOs=TRUE)

      end

   end

   set_becke_grid_for_plot(plot_kind) ::: private, leaky
   ! Set up the Becke grid info only for those plots which actually
   ! need it.
      plot_kind :: STR, IN

      do_it :: BIN

      do_it = FALSE

      select case (plot_kind)
      case("adp                                 "); do_it = FALSE
      case("adp_probability_grid                "); do_it = FALSE
      case("anharmonic_adp_correction           "); do_it = FALSE
      case("b_field                             "); do_it = FALSE
      case("b_l_field                           "); do_it = FALSE
      case("b_s_field                           "); do_it = FALSE
      case("binding_function_wang_peng          "); do_it = FALSE
      case("bond_electron_density               "); do_it = TRUE
      case("bond_weight                         "); do_it = FALSE
      case("crystal_error_map                   "); do_it = FALSE
      case("current_density                     "); do_it = FALSE
      case("deformation_bond_density            "); do_it = TRUE
      case("deformation_density                 "); do_it = TRUE
      case("deformation_dft_eff_potential       "); do_it = TRUE
      case("deformation_dft_energy              "); do_it = TRUE
      case("deformation_dft_xc_potential        "); do_it = TRUE
      case("deformation_electric_potential      "); do_it = TRUE
      case("deformation_g_kinetic_energy        "); do_it = TRUE
      case("deformation_g_kirzhnits             "); do_it = TRUE
      case("deformation_h_dft_energy            "); do_it = TRUE
      case("deformation_h_from_virial           "); do_it = TRUE
      case("deformation_h_kirzhnits             "); do_it = TRUE
      case("deformation_k_kinetic_energy        "); do_it = TRUE
      case("deformation_laplacian               "); do_it = TRUE
      case("deformation_v_from_virial           "); do_it = TRUE
      case("deformation_v_kirzhnits             "); do_it = TRUE
      case("deformation_reduced_g_kinetic_energy"); do_it = TRUE
      case("deformation_reduced_h_from_virial   "); do_it = TRUE
      case("deformation_reduced_k_kinetic_energy"); do_it = TRUE
      case("deformation_reduced_v_from_virial   "); do_it = TRUE
      case("dft_eff_potential                   "); do_it = TRUE
      case("dft_energy                          "); do_it = TRUE
      case("dft_xc_potential                    "); do_it = TRUE
      case("div_jp                              "); do_it = FALSE
      case("electric_potential                  "); do_it = FALSE
      case("multipole_electric_potential        "); do_it = FALSE
      case("electric_polarisation_density       "); do_it = TRUE
      case("electric_polarization_density       "); do_it = TRUE
      case("electron_density                    "); do_it = FALSE
      case("elf                                 "); do_it = FALSE
      case("e_hf_density_from_rho               "); do_it = FALSE
      case("eli_d                               "); do_it = FALSE
    ! case("energy_density_from_rho             "); do_it = TRUE
      case("fermi_mobility                      "); do_it = FALSE
      case("g_kinetic_energy                    "); do_it = FALSE
      case("g_kirzhnits                         "); do_it = FALSE
      case("grad_rho_on_rho                     "); do_it = FALSE
      case("group_product_electric_field_grid   "); do_it = FALSE
      case("group_product_esp_grid              "); do_it = FALSE
      case("h_dft_energy                        "); do_it = FALSE
      case("h_kirzhnits                         "); do_it = FALSE
      case("h_from_virial                       "); do_it = FALSE
      case("hirshfeld_atom_grid                 "); do_it = FALSE
      case("hirshfeld_density                   "); do_it = FALSE
      case("hirshfeld_weight                    "); do_it = FALSE
      case("interaction_density                 "); do_it = FALSE
      case("j                                   "); do_it = FALSE
      case("jd                                  "); do_it = FALSE
      case("jp                                  "); do_it = FALSE
      case("k_kinetic_energy                    "); do_it = FALSE
      case("kramers_spin_density                "); do_it = FALSE
      case("laplacian                           "); do_it = FALSE
      case("local_ionisation_energy             "); do_it = FALSE
      case("local_virial_ratio                  "); do_it = FALSE
      case("lol                                 "); do_it = FALSE
      case("negative_laplacian                  "); do_it = FALSE
      case("noncollinear_spin_density           "); do_it = FALSE
      case("normalized_g_from_virial            "); do_it = FALSE
      case("normalized_h_from_virial            "); do_it = FALSE
      case("normalized_v_from_virial            "); do_it = FALSE
    ! case("orbital_current_density             "); do_it = FALSE
      case("orbital_density                     "); do_it = FALSE
      case("orbital                             "); do_it = FALSE
      case("oscillator_orbital                  "); do_it = FALSE
      case("promolecule_density                 "); do_it = FALSE
      case("product_electric_field_grid         "); do_it = FALSE
      case("product_esp_grid                    "); do_it = FALSE
      case("reduced_g_kinetic_energy            "); do_it = TRUE
      case("reduced_h_from_virial               "); do_it = TRUE
      case("reduced_k_kinetic_energy            "); do_it = TRUE
      case("reduced_v_from_virial               "); do_it = TRUE
      case("residual_density_map                "); do_it = FALSE
      case("roby-gould_ano_density              "); do_it = FALSE
      case("roby-gould_covalent_orbital         "); do_it = FALSE
      case("roby-gould_ionic_orbital            "); do_it = FALSE
      case("roby-gould_nao_density              "); do_it = FALSE
      case("solenoidal_jp                       "); do_it = FALSE
    ! case("spin_current_density                "); do_it = FALSE
      case("spin_density                        "); do_it = FALSE
      case("spherical_atom_density              "); do_it = FALSE
      case("stockholder_density                 "); do_it = FALSE
      case("stockholder_weight                  "); do_it = FALSE
      case("test_sphere_on_atom_1               "); do_it = FALSE
      case("true_fermi_mobility                 "); do_it = FALSE
      case("tsirelson_elf                       "); do_it = FALSE
      case("v_kirzhnits                         "); do_it = FALSE
      case("v_from_virial                       "); do_it = FALSE
      case default;                UNKNOWN(plot_kind)
      end

      if (do_it) .GRID:set_up_becke_grid

   end

   set_integrals_for_plot(plot_kind) ::: private, leaky
   ! Set the required integrals for the "plot_kind".
      self :: INOUT
      plot_kind :: STR, IN

      select case (plot_kind)

      case ("true_fermi_mobility_grid")
         .INTS:make_kinetic_energy_mx
         .INTS:make_nuclear_attraction_mx

      case ("jp    ", "div_jp" )
         .BASE:make_ao_density_matrix
         .INTS:make_overlap_matrix
         .BASE:make_restricted_complex_NOs

      case ("jp_irrotational", "jp_solendoidal")
         .BASE:make_ao_density_matrix
         ENSURE(.density_matrix.is_allocated_with_genre("restricted_complex"),"no restrtd cmplx DM")

      case ("electric_potential" &
           ,"e_field_magnitude " &
           ,"deformation_electric_potential")
         .BASE:make_ao_density_matrix

      end


   end

   set_group_densities_for_plot(plot_kind) ::: private, leaky
   ! Set the fragment group densities for the plot.
   ! This does an SCF for each fragment - expensive!
      self :: INOUT
      plot_kind :: STR, IN

      select case (plot_kind)

      case ("interaction_density")
         .SCF:fragment_SCF
         .BASE:assign_NOs_to_MOs
     
      end


   end

!  ========================
!  On Kramers pairs density
!  ========================

   plot_ku_density
   ! we will produce kramers pairs matrix here and send it to grid
   !
      genre :: STR
      KUu  :: MAT{REAL}*
      KUgc :: MAT{CPX}*

      ! Get the genre
      genre = " "
      if (.scfdata.associated) then
         genre = .scfdata.spinorbital_kind
      else if (.density_matrix.allocated) then
         genre = .density_matrix.spinorbital_kind
      end

      stdout.flush
      stdout.flush
      stdout.text("Now we start to work on the unpaired electron density")
      stdout.text("Orbital after orbital .....")

      select case (genre)
         case ("unrestricted")
            KUu.create(.n_a,.n_b)
            KUu=ZERO
            .PROP:get_kramers_pairs(KUu)
            .GRID:make_ku_spin_density_grid_u(KUu)
            KUu.destroy
         case ("general_complex")
            KUgc.create(.n_e,.n_e)
            KUgc=(ZERO,ZERO)
            .PROP:get_kramers_pairs(KUgc)
            .GRID:make_ku_spin_density_grid_gc(KUgc)
            KUgc.destroy
         case default
           DIE(" only unrestricted or gchf spin density is available !")
      end

   end

   make_ku_density_grid(rho_grid,pt)
   ! we will produce kramers pairs matrix here and send it to grid
   !
      rho_grid :: VEC{REAL}
      pt       :: MAT{REAL}

      genre :: STR
      KUu   :: MAT{REAL}*
      KUgc  :: MAT{CPX}*

      ! Get the genre
      genre = " "
      if (.scfdata.associated) then
         genre = .scfdata.spinorbital_kind
      else if (.density_matrix.allocated) then
         genre = .density_matrix.spinorbital_kind
      end

      stdout.flush
      stdout.flush
      stdout.text("Now we start to work on the unpaired electron density")
      stdout.text("Orbital after orbital .....")

      select case (genre)
         case ("unrestricted")
            KUu.create(.n_a,.n_b)
            KUu=ZERO
            .PROP:get_kramers_pairs(KUu)
            .GRID:make_ku_density_grid_u(rho_grid,pt,KUu)
            KUu.destroy
         case ("general_complex")
            KUgc.create(.n_e,.n_e)
            KUgc=(ZERO,ZERO)
            .PROP:get_kramers_pairs(KUgc)
            .GRID:make_ku_density_grid_gc(rho_grid,pt,KUgc)
            KUgc.destroy
         case default
           DIE(" only unrestricted or gchf spin density is available !")
      end

   end

end
