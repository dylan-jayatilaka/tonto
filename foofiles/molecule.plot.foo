!===============================================================================
!
! MOLECULE.PLOT: An object representation of a molecule.
!
! These are plot-controlling procedures. Most of the actual grids are
! made in .GRid .
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996-2012
! Copyright (C) Dylan Jayatilaka 2012-
! Copyright (C) Dylan Jayatilaka 2021
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!===============================================================================

module MOLECULE.PLOT

   implicit none

contains

!  =================================
!  2D plane or 3D cube or cell plots
!  =================================

   plot ::: leaky
   ! Do one of the many kinds of plot calculations
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")

      ! Set up
      .:set_up_for_plot(.plot_grid.plot_kind)

      ! Use unit cell as bbox if requested
      if (.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         ENSURE(.crystal.allocated,"no crystal or unit cell for plot!")
         .plot_grid.set_box_scale_factor(ONE)
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)
      end

      ! Use unit cell as bbox if requested
      if (.plot_grid.plot_kind=="crystal23_electron_density") then
         WARN("resetting plot axes, plot widths from unit cell")
         ENSURE(.crystal.allocated,"no crystal or unit cell for plot!")
         .plot_grid.set_box_scale_factor(ONE)
       ! .plot_grid.set_desired_separation(0.1*BOHR_PER_ANGSTROM)
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)
      end

      ! See plot_grid parameters
      .plot_grid.put

      ! Do the plot
      .:do_plot

   end

   do_plot ::: leaky
   ! Do one of the many kinds of plot calculations and write out the
   ! plot property into a file. These are usually 2D plots but they
   ! can be rectilinear volumetric plots, depending on how .plot_grid
   ! was defined by the user.
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")

      name :: STR
      grid :: VEC{REAL}@

      ! Property values.
      grid.create(.plot_grid.n_pt)

      ! Do the plot
      .:do_plot(grid)

      ! Print out
      name = .plot_grid.plot_file_name(.n_a)
      .PUT:dump_plot_grid(grid,name)

      ! Clean up
      grid.destroy

   end

   do_plot(grid) ::: leaky
   ! Do one of the many kinds of plot calculations and store the
   ! property values in "grid". These are usually 2D plots but they
   ! can be rectilinear volumetric plots, depending on how .plot_grid
   ! was defined by the user.
      self :: INOUT
      grid :: VEC{REAL}, OUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(grid.dim==.plot_grid.n_pt, "no grid")

      pt :: MAT{REAL}@

      ! Make the grid points
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make the property values.
      .GRID:make_prop_values(grid,pt)

      ! Clean up
      pt.destroy

   end


   plots ::: leaky
   ! Do one of the many kinds of plot calculations
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.plot_grid.plot_kinds.allocated, "no multiple plot_kinds!")

      i :: INT

      ! Loop over plots and do each one
      do i = 1,.plot_grid.plot_kinds.dim
         .plot_grid.set_plot_kind( .plot_grid.plot_kinds(i))
         .plot_grid.set_plot_units(.plot_grid.plot_kinds_units(i))
         .:plot
      end

      ! Reset to blank
      .plot_grid.set_plot_kind(" ")
      .plot_grid.set_plot_units(" ")

   end


   plot_fragments
   ! Do the summed-fragment property density on ".plot_grid".
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.crystal.allocated,"no crystal")

      ! Use unit cell as bbox if requested
      if (.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         ENSURE(.crystal.allocated,"no crystal or unit cell for plot!")
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)
      end

      ! See plot_grid parameters
      .plot_grid.put

      ! Do the plot
      .:do_fragment_plot

   end

   do_fragment_plot ::: leaky
   ! Do the summed-fragmened  property density on ".plot_grid" using
   ! the molecules in .atom_group(:).mol.
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no grid")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.crystal.allocated,"no crystal")

    ! seitz :: MAT3{REAL}@
    ! shift :: MAT{INT}@
      pt :: MAT{REAL}@
    ! mx,dcm,coords :: MAT{REAL}@
    ! grid,frag :: VEC{REAL}@
      coa :: VEC{REAL}(3)
    ! trans :: VEC{REAL}(3)
    ! parent,symop :: VEC{INT}@
    ! s,n_mols, p :: INT
      g :: INT
    ! name :: STR
    ! mol :: MOLECULE@
    ! same :: BIN

      ! Reset plot grid to group center?
      g = .plot_grid.group
      if (g>0) then
         coa = .mol(g).atom.center_of_atoms
         .plot_grid.destroy
         .plot_grid.create(.mol(g).atom)
         .plot_grid.set_center(coa)
         .plot_grid.use_bbox_with_shape_axes
      end

      ! Make the grid points
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Make cluster (molecules) around plot grid
      .cluster.destroy
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.set_generation_method("fragment") ! ?
      .cluster.set_defragment(TRUE)
      .cluster.update_info
      .cluster.put
    ! .XTAL:create_cluster

    ! .crystal.make_plot_info(pt,parent,symop,shift) 
    ! 
    ! DIE_IF(parent.deallocated,"no molecules inthe plot!")

    ! ! No. of molecules near the plot grid
    ! n_mols = parent.dim

    ! ! Cartesian rotation matrices
    ! seitz = .crystal.xyz_seitz_matrices

    ! ! Direct space unit cell matrix
    ! dcm = .crystal.unit_cell.direct_mx

    ! ! Make space for grid values and grid points
    ! grid.create(.plot_grid.n_pt)
    ! frag.create(.plot_grid.n_pt)
    ! coords.create(3,0)

    ! ! Initialise
    ! grid = ZERO

    ! do p = 1,n_mols
    ! 
    !    ! Which group does p belong to?
    !    g = .atom_group.group_for_atom(p)

    !    ! Clone molecule
    !    mol.SET:create
    !    .SET:set_molecule_from_atom_group(g,mol,FALSE)

    !    ! Set to be group name (for reading archive)
    !    mol.SET:set_name(.atom_group(g).name)

    !    ! Set up plot - maybe read archive for MO's?
    !    mol.plot_grid => .plot_grid
    !    mol.:set_up_for_fragment_plot(.plot_grid.plot_kind)
    ! 
    !    ! Rotate it
    !    s = symop(p)
    !    mol.BASE:rotate_by(seitz(1:3,1:3,s))

    !    ! Translate it
    !    trans = matmul(dcm,shift(:,p))
    !    mol.atom.translate_by(trans)

    !    ! CHeck here if the atoms are in the same space NOTE this may
    !    ! not work for disordered molecules
    !    same = FALSE
    !    mx.create(3,mol.atom.dim)
    !    mol.atom.put_coordinates_to(mx,positions_as_rows=FALSE)
    !    
    !    same = mx.has_any_column_from(coords)
    !    
    !    ! If it isn't the same, add it to the list
    !    if (NOT same) coords.append_column(mx(:,1))
    !    
    !    ! Clean up in each iteration
    !    mx.destroy
    !    
    !    ! Don't proceed if molecule is already plotted
    !    if (same) cycle

    !    ! Skip SCF for atoms without electrons
    !    ! Question: any plots which work with no electrons?
    !    if (mol.BASE:no_of_electrons < 1) cycle

    !    ! Do the plot for this fragment
    !    ! Use the parent .plot_grid
    !    mol.GRID:make_prop_values(frag,pt)
    !    nullify(mol.plot_grid)

    !    ! Add up this contribution
    !    grid = grid + frag

    !    ! Clean up mol
    !    mol.atom.nullify_ptr_part ! do not destroy these
    !    nullify(mol.basis)        ! do not destroy this
    !    nullify(mol.slaterbasis)  ! do not destroy this
    !    nullify(mol.coppensbasis) ! do not destroy this
    !    mol.SET:destroy

    ! end

    ! ! Print out
    ! name = .plot_grid.plot_file_name(.n_a)
    ! .PUT:dump_plot_grid(grid,name)

      ! Clean up
    ! seitz.destroy
    ! grid.destroy
      pt.destroy

   end

   test_plot_info
   ! Test tlot the unit cell density
     self :: INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.crystal.allocated,"no crystal info")
   ENSURE(NOT .crystal.cluster_info_made,"cluster info already made!")

      pt :: MAT{REAL}@
      shift :: MAT{INT}@
      parent, symop :: VEC{INT}@
      i,p,g :: INT

   ! .crystal.destroy_fragment_data
   ! .crystal.make_fragment_data(.atom,assign_atom=TRUE)

   ! .crystal.set_generation_method("for_unit_cell_density") 

     pt.create(.plot_grid.n_pt,3)
     .plot_grid.make_points(pt)

     .plot_grid.put

     .crystal.set_atom_density_cutoff(1.0d-3) 
     .crystal.make_plot_info(pt,parent,symop,shift)

     if (parent.allocated) then

        do i = 1, parent.dim
            p = parent(i)
            g = .atom_group.group_for_atom(p)
            stdout.text("The group for atom "//trim(p.to_str)//" is "//trim(g.to_str))
            stdout.show("parent     =",p)
            stdout.show("symop      =",symop(i))
            stdout.show("With shift =",shift(:,i))
        end

     end

   ! .crystal.put_cluster_info

   end

!  ===============
!  Isosurface plot
!  ===============

   isosurface_plot ::: leaky
   ! Do one of the many kinds of isosurface plot calculations
      self :: target, INOUT

   ENSURE(.isosurface.allocated,"no isosurface")

      ! Set up
      .:set_up_for_plot(.isosurface.property)

      ! Save self for selfless function calls
    ! .SET:set_saved_self

      ! Do the plot
      .GRID:do_isosurface_plot

   end

   saved_isosurface_plot ::: leaky
   ! Do an isosurface plot using the CURRENT .isosurface information
   ! *AND* using the .saved molecule, density functions, MOs, etc.
   ! Results placed in .saved.isosurface.
      self :: target, INOUT

   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.saved.allocated,"no saved molecule")

    ! keep :: ISOSURFACE@
    ! has_saved_iso :: BIN

      ! Keep any previous .saved.isosurface
    ! has_saved_iso = allocated(.saved.isosurface)
    ! if (has_saved_iso) then
    ! call move_alloc(.saved.isosurface,keep)
    ! end

      ! Set .saved.isosurface to be current .isosurface
      .saved.isosurface = .isosurface

      ! Set up
      .saved.:set_up_for_plot(.isosurface.property)

      ! Set saved_self to be .saved molecule
    ! .saved.SET:set_saved_self

      ! Do the plot -- current molecule isosurface
      .saved.GRID:do_isosurface_plot

      ! Put back the .saved.isosurface the way it was
    ! if (has_saved_iso) then
    ! call move_alloc(keep,.saved.isosurface)
    ! end

   end

!  ==============================
!  Plot property on an isosurface
!  ==============================

   plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface - useful for mapping properties on a surface.
      self :: target, INOUT

   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no surface_property given!")

      ! Set up
      .:set_up_for_plot(.isosurface.surface_property)

      ! Save self for selfless function calls
    ! .SET:set_saved_self

      ! Do the plot
      .GRID:do_plot_property_on_isosurface

   end

   saved_plot_on_isosurface ::: leaky
   ! Plot a density function on an existing isosurface - for mapping
   ! properties on a surface - but using the CURRENT .isosurface *AND*
   ! using information from the .saved molecule atom list, density
   ! functions, MO's. Results placed in .saved.isosurface.
      self :: INOUT

   ENSURE(.isosurface.allocated,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no surface_property given!")
   ENSURE(.saved.allocated,"no saved molecule")

    ! keep :: ISOSURFACE@
    ! has_saved_iso :: BIN

      ! Keep any previous .saved.isosurface
    ! has_saved_iso = allocated(.saved.isosurface)
    ! if (has_saved_iso) then
    ! call move_alloc(.saved.isosurface,keep)
    ! end

      ! Set .saved.isosurface to be current .isosurface
      .saved.isosurface = .isosurface

      ! Set up
      .saved.:set_up_for_plot(.isosurface.surface_property)

    ! ! Set saved_self to be .saved molecule
    ! .saved.SET:set_saved_self

      ! Do the plot -- current molecule isosurface
      .saved.GRID:do_plot_property_on_isosurface

      ! Put back the saved isosurface the way it was
    ! if (has_saved_iso) then
    ! call move_alloc(keep,.saved.isosurface)
    ! end

   end

!  ====================
!  Set-up info for plot
!  ====================

   set_up_for_plot(plot_kind) ::: leaky
   ! Do plot-specific initialization
      self :: INOUT
      plot_kind :: STR, IN

      ! Make the becke grids & overlapping atoms
      .:set_becke_grid_for_plot(plot_kind)

      ! Set atom plot info for deformation densities
      .:set_ANOs_for_plot(plot_kind)

      ! Set interpolators for stockholder or promolecule plots
      .:set_interpolators_for_plot(plot_kind)

      ! Set up densities & integrals for plot
      .:set_integrals_for_plot(plot_kind)

      ! Make sure group densities & MOs are there
      ! Warining: not for summed fragments plots
      .:set_group_densities_for_plot(plot_kind)

      ! Assign natural orbitals
      if (.MOs.allocated) then
         .BASE:assign_NOs_to_MOs
      end

   end

   set_up_for_fragment_plot(plot_kind) ::: leaky
   ! Do plot-specific initialization
      self :: INOUT
      plot_kind :: STR, IN

      ! Make the becke grids & overlapping atoms
      .:set_becke_grid_for_plot(plot_kind)

      ! Set atom plot info for deformation densities
      .:set_ANOs_for_plot(plot_kind)

      ! Set interpolators for stockholder or promolecule plots
      .:set_interpolators_for_plot(plot_kind)

      ! Set up densities & integrals for plot
      .:set_integrals_for_plot(plot_kind)

      ! Make sure group densities & MOs are there
      ! Warining: not for summed fragments plots
      .:set_group_densities_for_plot(plot_kind)

      ! Assign natural orbitals
      .READ:read_scf_archives ! Note may cause issues, but probably not

   end

   set_interpolators_for_plot(plot_kind) ::: private, leaky
   ! Set the interpolator info for all the atoms if the "plot_kind" is such
   ! that interpolation tables could be beneficial. This should be called just
   ! prior to doing the plot to take advantage of speed-ups.
      plot_kind :: STR, IN

      do_interpolator :: BIN

      do_interpolator = plot_kind      =="promolecule_density" &
                     OR plot_kind(1:11)=="stockholder"         &
                     OR plot_kind(1:11)=="deformation"       

      if (NOT do_interpolator) return

      ENSURE(.atom.allocated,"no atom list")

      ! Get interpolators.
      select case (.atom(1).basis_kind)

      case ("slater")
         ENSURE(.slaterbasis.allocated,"no slater bases")
         .GRID:make_slater_interpolators

      case ("coppens")
         ENSURE(.coppensbasis.allocated,"no coppens bases")
         .GRID:make_coppens_interpolators

      case ("gaussian")
         ENSURE(.basis.allocated,"no gaussian bases")
         .SCF:make_ANO_data

      end

   end

   set_ANOs_for_plot(plot_kind) ::: private, leaky
   ! Set the ANO info for all the atoms if the "plot_kind" is such
   ! that the ANO data must be made.
      plot_kind :: STR, IN

      if (plot_kind(1:11)=="deformation" OR plot_kind(1:4)=="e_hf") then

         ! If we get here, the ANO information will be used
         .SCF:make_ANO_data

      else if (plot_kind(1:5)=="bond_") then

         .SCF:make_ANO_data

       ! ! If we get here, the spherically averaged atom information will be used
       ! .make_spherical_atoms

      else if (plot_kind=="hirshfeld_atom_grid") then

         ! should be in set_up becke grid?
         .SCF:make_HA_inputs(skip_NOs=TRUE)

      end

   end

   set_becke_grid_for_plot(plot_kind) ::: private, leaky
   ! Set up the Becke grid info only for those plots which actually
   ! need it.
      plot_kind :: STR, IN

      do_it :: BIN

      do_it = FALSE

      select case (plot_kind)
      case("adp                                 "); do_it = FALSE
      case("adp_probability_grid                "); do_it = FALSE
      case("anharmonic_adp_correction           "); do_it = FALSE
      case("b_field                             "); do_it = FALSE
      case("b_l_field                           "); do_it = FALSE
      case("b_s_field                           "); do_it = FALSE
      case("binding_function_wang_peng          "); do_it = FALSE
      case("bond_electron_density               "); do_it = TRUE
      case("bond_weight                         "); do_it = FALSE
      case("crystal_error_map                   "); do_it = FALSE
      case("crystal23_electron_density          "); do_it = FALSE
      case("current_density                     "); do_it = FALSE
      case("deformation_bond_density            "); do_it = TRUE
      case("deformation_density                 "); do_it = TRUE
      case("deformation_dft_eff_potential       "); do_it = TRUE
      case("deformation_dft_energy              "); do_it = TRUE
      case("deformation_dft_xc_potential        "); do_it = TRUE
      case("deformation_electric_potential      "); do_it = TRUE
      case("deformation_g_kinetic_energy        "); do_it = TRUE
      case("deformation_g_kirzhnits             "); do_it = TRUE
      case("deformation_h_dft_energy            "); do_it = TRUE
      case("deformation_h_from_virial           "); do_it = TRUE
      case("deformation_h_kirzhnits             "); do_it = TRUE
      case("deformation_k_kinetic_energy        "); do_it = TRUE
      case("deformation_laplacian               "); do_it = TRUE
      case("deformation_v_from_virial           "); do_it = TRUE
      case("deformation_v_kirzhnits             "); do_it = TRUE
      case("deformation_reduced_g_kinetic_energy"); do_it = TRUE
      case("deformation_reduced_h_from_virial   "); do_it = TRUE
      case("deformation_reduced_k_kinetic_energy"); do_it = TRUE
      case("deformation_reduced_v_from_virial   "); do_it = TRUE
      case("dft_eff_potential                   "); do_it = TRUE
      case("dft_energy                          "); do_it = TRUE
      case("dft_xc_potential                    "); do_it = TRUE
      case("div_jp                              "); do_it = FALSE
      case("electric_potential                  "); do_it = FALSE
      case("multipole_electric_potential        "); do_it = FALSE
      case("electric_polarisation_density       "); do_it = TRUE
      case("electric_polarization_density       "); do_it = TRUE
      case("electron_density                    "); do_it = FALSE
      case("elf                                 "); do_it = FALSE
      case("e_hf_density_from_rho               "); do_it = FALSE
      case("eli_d                               "); do_it = FALSE
    ! case("energy_density_from_rho             "); do_it = TRUE
      case("fermi_mobility                      "); do_it = FALSE
      case("g_kinetic_energy                    "); do_it = FALSE
      case("g_kirzhnits                         "); do_it = FALSE
      case("grad_rho_on_rho                     "); do_it = FALSE
      case("group_product_electric_field_grid   "); do_it = FALSE
      case("group_product_esp_grid              "); do_it = FALSE
      case("h_dft_energy                        "); do_it = FALSE
      case("h_kirzhnits                         "); do_it = FALSE
      case("h_from_virial                       "); do_it = FALSE
      case("hirshfeld_atom_grid                 "); do_it = FALSE
      case("hirshfeld_density                   "); do_it = FALSE
      case("hirshfeld_weight                    "); do_it = FALSE
      case("interaction_density                 "); do_it = FALSE
      case("j                                   "); do_it = FALSE
      case("jd                                  "); do_it = FALSE
      case("jp                                  "); do_it = FALSE
      case("k_kinetic_energy                    "); do_it = FALSE
      case("kramers_spin_density                "); do_it = FALSE
      case("laplacian                           "); do_it = FALSE
      case("local_ionisation_energy             "); do_it = FALSE
      case("local_virial_ratio                  "); do_it = FALSE
      case("lol                                 "); do_it = FALSE
      case("negative_laplacian                  "); do_it = FALSE
      case("noncollinear_spin_density           "); do_it = FALSE
      case("normalized_g_from_virial            "); do_it = FALSE
      case("normalized_h_from_virial            "); do_it = FALSE
      case("normalized_v_from_virial            "); do_it = FALSE
    ! case("orbital_current_density             "); do_it = FALSE
      case("orbital_density                     "); do_it = FALSE
      case("orbital                             "); do_it = FALSE
      case("oscillator_orbital                  "); do_it = FALSE
      case("promolecule_density                 "); do_it = FALSE
      case("product_electric_field_grid         "); do_it = FALSE
      case("product_esp_grid                    "); do_it = FALSE
      case("reduced_g_kinetic_energy            "); do_it = TRUE
      case("reduced_h_from_virial               "); do_it = TRUE
      case("reduced_k_kinetic_energy            "); do_it = TRUE
      case("reduced_v_from_virial               "); do_it = TRUE
      case("residual_density                    "); do_it = FALSE
      case("roby-gould_ano_density              "); do_it = FALSE
      case("roby-gould_covalent_orbital         "); do_it = FALSE
      case("roby-gould_ionic_orbital            "); do_it = FALSE
      case("roby-gould_nao_density              "); do_it = FALSE
      case("solenoidal_jp                       "); do_it = FALSE
    ! case("spin_current_density                "); do_it = FALSE
      case("spin_density                        "); do_it = FALSE
      case("spherical_atom_density              "); do_it = FALSE
      case("stockholder_density                 "); do_it = FALSE
      case("stockholder_weight                  "); do_it = FALSE
      case("test_sphere_on_atom_1               "); do_it = FALSE
      case("true_fermi_mobility                 "); do_it = FALSE
      case("tsirelson_elf                       "); do_it = FALSE
      case("v_kirzhnits                         "); do_it = FALSE
      case("v_from_virial                       "); do_it = FALSE
      case default;                UNKNOWN(plot_kind)
      end

      if (do_it) .GRID:set_up_becke_grid

   end

   set_integrals_for_plot(plot_kind) ::: private, leaky
   ! Set the required integrals for the "plot_kind".
      self :: INOUT
      plot_kind :: STR, IN

      select case (plot_kind)

      case ("true_fermi_mobility_grid")
         .INTS:make_kinetic_energy_mx
         .INTS:make_nuclear_attraction_mx

    ! case ("jp    ", "div_jp" )
    !    .BASE:make_r_density_mx
    !    .INTS:make_overlap_mx
    !    .BASE:make_restricted_complex_NOs

    ! case ("jp_irrotational", "jp_solendoidal")
    !    .BASE:make_r_density_mx
    !    ENSURE(.density_mx.is_allocated_with_genre("restricted_complex"),"no restrtd cmplx DM")

      case ("electric_potential" &
           ,"e_field_magnitude " &
           ,"deformation_electric_potential")
         .BASE:make_r_density_mx

      end


   end

   set_group_densities_for_plot(plot_kind) ::: private, leaky
   ! Set the fragment group densities for the plot.
   ! This does an SCF for each fragment - expensive!
      self :: INOUT
      plot_kind :: STR, IN

      select case (plot_kind)

      case ("interaction_density")
         .SCF:fragment_SCF
         .BASE:assign_NOs_to_MOs
     
      end


   end

!  ========================
!  On Kramers pairs density
!  ========================

   plot_ku_density
   ! we will produce kramers pairs matrix here and send it to grid
      self :: INOUT

      genre :: STR
      KUu  :: MAT{REAL}@
      KUgc :: MAT{CPX}@

      ! Get the genre
      genre = " "
      if (.scfdata.allocated) then
         genre = .scfdata.spinorbital_genre
      else if (.density_mx.allocated) then
         genre = .density_mx.genre
      end

      stdout.flush
      stdout.flush
      stdout.text("Now we start to work on the unpaired electron density")
      stdout.text("Orbital after orbital .....")

      select case (genre)
         case ("unrestricted")
            KUu.create(.n_a,.n_b)
            KUu=ZERO
            .PROP:get_kramers_pairs(KUu)
            .GRID:make_ku_spin_density_grid_u(KUu)
            KUu.destroy
         case ("general_complex")
            KUgc.create(.n_e,.n_e)
            KUgc=(ZERO,ZERO)
            .PROP:get_kramers_pairs(KUgc)
            .GRID:make_ku_spin_density_grid_gc(KUgc)
            KUgc.destroy
         case default
           DIE(" only unrestricted or gchf spin density is available !")
      end

   end

   make_ku_density_grid(rho_grid,pt)
   ! we will produce kramers pairs matrix here and send it to grid
   !
      rho_grid :: VEC{REAL}
      pt       :: MAT{REAL}

      genre :: STR
      KUu   :: MAT{REAL}@
      KUgc  :: MAT{CPX}@

      ! Get the genre
      genre = " "
      if (.scfdata.allocated) then
         genre = .scfdata.spinorbital_genre
      else if (.density_mx.allocated) then
         genre = .density_mx.genre
      end

      stdout.flush
      stdout.flush
      stdout.text("Now we start to work on the unpaired electron density")
      stdout.text("Orbital after orbital .....")

      select case (genre)
         case ("unrestricted")
            KUu.create(.n_a,.n_b)
            KUu=ZERO
            .PROP:get_kramers_pairs(KUu)
            .GRID:make_ku_density_grid_u(rho_grid,pt,KUu)
            KUu.destroy
         case ("general_complex")
            KUgc.create(.n_e,.n_e)
            KUgc=(ZERO,ZERO)
            .PROP:get_kramers_pairs(KUgc)
            .GRID:make_ku_density_grid_gc(rho_grid,pt,KUgc)
            KUgc.destroy
         case default
           DIE(" only unrestricted or gchf spin density is available !")
      end

   end

end
