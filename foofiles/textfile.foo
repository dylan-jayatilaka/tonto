!=====================================================================
!
! TEXTFILE
!
! This is for text-based files. It uses a line-oriented, sequential
! advancing approach for input and output. It can handle input from
! standard input "stdin", and output to standard output "stdout",
! which are one-off objects stored in this module.
!
! You cannot open a TEXTFILE simultaneously for input and output.
!
! Line analysis and output is done using a BUFFER object. Note that
! the input buffer is limited to string of size BSTR_SIZE, set in the
! "macros" file.
!
! A line count is maintained to allow back-tracking to previous lines,
! and particular items on each line. This is useful for input.
!
! For output, items can be put in columns of a specified width, with
! double precision numbers having a specified precision, and a
! specified "style" specified by fortran conventions. This is useful
! for dynamic tables, which the user can change at run time. Rewind
! and backtracking are not allowed for output files.
!
! It is possible to redirect the input or output to a new file
! using the "redirect" command. The previous file can be recovered
! using the "revert" command; or it will revert back automatically to
! the previous file if the redirected file ends. It is also possible
! to redirect input to an internal file. This is useful for processing
! a quoted list of text as if it were an embedded file. Output to an
! internal file is not allowed.
!
! The system information in "tonto" is updated whenever a I/O operation
! or a buffer operation is performed.
!
! Copyright (C) Dylan Jayatilaka, 1999
! Copyright (C) Dylan Jayatilaka, 2024
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!======================================================================

module TEXTFILE

   implicit none

   ! Std in, out, error files
   stdin  :: TEXTFILE@, public 
   stdout :: TEXTFILE@, public
   stderr :: TEXTFILE@, public

contains

!  ====================
!  Allocation std files
!  ====================

   create_stdin ::: selfless, public, leaky
   ! Create a the standard input file object, if needed.

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

      if (stdin.deallocated) then

         ! Allocate
#ifdef USE_PRECONDITIONS
         allocate(stdin,stat=status)
         ENSURE(status==0,"error in allocating stdin")
#else
         allocate(stdin)
#endif

         ! Reset some defaults
         stdin.name   = "stdin"
         stdin.action = "read"
         stdin.unit   = tonto.stdin_unit

      end

   end

   create_stdout ::: selfless, public, leaky
   ! Create a standard output file object.

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

      if (stdout.deallocated) then

         ! Allocate
#ifdef USE_PRECONDITIONS
         allocate(stdout,stat=status)
         ENSURE(status==0,"error in allocating stdout")
#else
         allocate(stdout)
#endif

         ! Reset some defaults
         stdout.name   = "stdout"
         stdout.action = "write"
         stdout.unit   = tonto.stdout_unit

      end

      stdout.clear_and_put_margin

   end

   create_stderr ::: selfless, public, leaky
   ! Create a standard output file object.

#ifdef USE_PRECONDITIONS
      status :: INT
#endif

      if (stderr.deallocated) then

         ! Allocate
#ifdef USE_PRECONDITIONS
         allocate(stderr,stat=status)
         ENSURE(status==0,"error in allocating stderr")
#else
         allocate(stderr)
#endif
         ! Reset some defaults
         stderr.name   = "stderr"
         stderr.action = "write"
         stderr.unit   = tonto.stderr_unit
      end

      stderr.clear_and_put_margin

   end

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, private, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   create(name) ::: leaky
   ! Create a textfile, and optionally set the name. Does not open the file.
      self :: allocatable, OUT
      name :: STR, IN

      .create

      ! Set the name
      .set_name(name)

      ! Get ready to write
      .clear_and_put_margin ! <<< IMPURE

   end

   create(internal) ::: leaky
   ! Create an internal textfile
      self     :: allocatable, OUT
      internal :: VEC{STR}, IN

      .create

      ! Reset some defaults
      .action      = "read"
      .no_of_lines = size(internal)
      .unit        = 0

      ! Set internal file
      .name        = "internal"
      .internal    = internal

      ! Get ready to read
      .read_line ! <<< IMPURE

   end

   destroy_replacement_list ::: leaky, PURE
   ! Destroy the .replacement_list; needed if set_replacement_list is used
      self :: INOUT
       .style.replacement_list.destroy
      .buffer.replacement_list.destroy
   end

!  ===================
!  Saving and unsaving
!  ===================

   save_style ::: PURE
   ! Save style settings. NOTE: can only be used once.
      self :: INOUT
      .saved_style = .style
   end

   unsave_style ::: PURE
   ! Restore saved style settings. NOTE: can only be used once.
      self :: INOUT
      .style = .saved_style
   end

!  ========================
!  File redirect and revert
!  ========================

   redirect(name) ::: leaky
   ! Save or push "self" in ".saved" and open new textfile "name".
   ! This is used for input, or output redirection.  The new file
   ! retains the output style settings of the cuurent file.
      self :: allocatable, INOUT
      name :: STR, IN

      saved :: TEXTFILE@

      ! Keep self in saved
      call move_alloc(self,saved)

      ! New self "name"
      .create(name)

      ! .saved component of new self is the old self
      .saved = saved

      ! New style is same as original
      .style = saved.style

      ! Open the new file
      .open_for(saved.action)

   end

   redirect(internal) ::: leaky
   ! Save or push "self" in ".saved" and open a new internal textfile.
   ! This is used *only* for input redirection.
      self :: allocatable, INOUT
      internal :: VEC{STR}, IN

      saved :: TEXTFILE@

      ! Keep self in saved
      call move_alloc(self,saved)

      ! New self "name"
      .create(internal)

      ! .saved component of new self is the old self
      .saved = saved

      ! New style is same as original
      .style = saved.style

   end

   revert ::: leaky
   ! Revert to the previously redirected textfile, but keep *current*
   ! style settings, including e.g. any default_units settings.
      self :: allocatable, INOUT

   ENSURE(.saved.allocated,"no previous settings")

      saved :: TEXTFILE@

      ! Keep .saved file
      call move_alloc(.saved,saved)

      ! Set .saved style to current settings
      saved.style = self.style

      ! Soft-ending
      saved.IO_status = -1

      ! Close external files or destroy internal file
      if (.internal.allocated) then; .internal.destroy
      else;                          .close
      end
      .destroy

      ! Restore self
      call move_alloc(saved,self)

   end

!  =======
!  Opening
!  =======

   open_for(action) ::: public
   ! Open the textfile for "action" either "read" or "write".
     self :: INOUT
     action :: STR, IN

     select case (action)
     case("read      ","reading   ","read-only ") ; .open_for_read
     case("write     ","writing   ","write-only") ; .open_for_write
     case default; UNKNOWN(action)
     end

   end

   open_for_read ::: private
   ! Open the input file. The input file object must already be
   ! created. The file is positioned at the first line.
      self :: INOUT

   DIE_IF(NOT .exists, "not an existing file!")
   ENSURE(.internal.deallocated,"no need to open an internal file")

      .action = "read"

      ! Open the file & set unit number
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         open(file=trim(.name),    &
              newunit=.unit,       &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.IO_status)
      end

      ! Broadcast & check for fail
      PARALLEL_BROADCAST(.unit,tonto.master_processor)
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening old file: "//trim(.name))

      ! Set no of lines in the file & rewind
      .set_no_of_lines

   end

   open_for_write ::: private
   ! Open the output file for writing
      self :: INOUT

   ENSURE(.internal.deallocated,"no need to open an internal file")
      
      if (.exists) then; .open_old_file_for_write
      else;              .open_new_file_for_write
      end

   end

   open_old_file_for_write ::: private
   ! Open an old output file for writing
      self :: INOUT

   DIE_IF(NOT .exists, "not an existing file!")
   ENSURE(.internal.deallocated,"no need to open an internal file")

      .action = "write"

      ! Open the file & set unit number
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         open(file=trim(.name),    &
              newunit=.unit,       &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.IO_status)
      end if

      ! Broadcast & check for fail
      PARALLEL_BROADCAST(.unit,tonto.master_processor)
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening old file: "//trim(.name))

      .clear_and_put_margin

   end

   open_new_file_for_write ::: private
   ! Open an new output file for writing
      self :: INOUT

   DIE_IF(.exists, "output file exists!")
   ENSURE(.internal.deallocated,"no need to open an internal file")

      .action = "write"

      ! Open the file & set unit number
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         open(file=trim(.name) ,   &
              newunit=.unit,       &
              status="new",        &
              access="sequential", &
              form="formatted",    &
              iostat=.IO_status)
      end if

      ! Broadcast & check for fail
      PARALLEL_BROADCAST(.unit,tonto.master_processor)
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening new file "//trim(.name))

   end

!  ==================
!  Closing & deleting
!  ==================

   close
   ! Close the input file, if opened.
      self :: INOUT

   DIE_IF(NOT .exists, "not an existing file!")

      opened :: BIN

      ! Check if unit is opened
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         inquire(unit=.unit,iostat=.IO_status,opened=opened)
      end

      ! Failure?
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening new file "//trim(.name))

      ! Close the file
      if (IO_IS_ALLOWED) then
      if (opened) then
         close(unit=.unit)
      end
      end

   end

   close_and_delete
   ! Close the input file and delete it from the file system
      self :: INOUT

   DIE_IF(NOT .exists, "not an existing file!")

      ! Close & delete the file
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         close(unit=.unit,iostat=.IO_status,status="delete")
      end

      ! Failure?
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening new file "//trim(.name))

   end

   delete
   ! Delete the input file from the file system
      self :: INOUT

      ! Open file: is this needed?
      if (NOT .is_open) .open_for("read")

      .close_and_delete

   end

!  =========================================
!  Set comment, quote and specials character
!  =========================================

   set_name(name)
   ! Set the file name
      self :: INOUT
      name :: STR, IN

   DIE_IF(name==" ","name is blank!")

      .name = name

   end

   set_no_of_lines ::: private
   ! Set the number of lines in the file
      self :: INOUT

   DIE_IF(NOT .exists,  "file " //trim(.name) //" does not exist!")
   DIE_IF(NOT .is_open, "file " //trim(.name) //" is not opened!")
   DIE_IF(.action/="read","has not been opened for reading")

      l :: INT
      line :: STR(len=8)

      ! Read the lines until done i.e. failed
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         l = 0
         do
            line = " "
            read(.unit,fmt="(a)",iostat=.IO_status) line
            l = l + 1
            if (.IO_status/=0) exit
         end
      end

      ! Broadcast - but don't check .IO_status!
      PARALLEL_BROADCAST(l,tonto.master_processor)

      ! Set the number of lines.
      ! WARNING: this assumes the fail happens after
      ! the stop record, so we have to move before that.
      .no_of_lines = l - 1

      ! Rewind the file
      .rewind

   end

   reset_IO_status ::: pure
   ! Reset manually the IO_status if it is safe to do so.
      self :: INOUT

      .IO_status = 0

   end

!  =========================================
!  Set comment, quote and specials character
!  =========================================

   set_comment_chars(val) ::: PURE
   ! Set the characters which represent comment characters.
      self :: INOUT
      val  :: STR, IN
       .style.set_comment_chars(val)
      .buffer.set_comment_chars(val)
   end

   set_quote_chars(val) ::: PURE
   ! Set the characters which represent the quotes.
      self :: INOUT
      val  :: STR, IN
       .style.set_quote_chars(val)
      .buffer.set_quote_chars(val)
   end

   set_list_delimiters(val) ::: pure
   ! Set the two open- and close- characters which delimit a list.
      self :: INOUT
      val  :: STR(len=2), IN
      .style.set_list_delimiters(val)
   end

   set_ignore_unmatched_quotes(val) ::: pure
   ! Set whether to ignore unmatched quotes when processing input.
      self :: INOUT
      val :: BIN, IN
       .style.set_ignore_unmatched_quotes(val)
      .buffer.set_ignore_unmatched_quotes(val)
   end

   set_eliminate_specials(val) ::: PURE
   ! Set the list of characters which should be treated as whitespace.
      self :: INOUT
      val  :: BIN, IN
       .style.set_eliminate_specials(val)
      .buffer.set_eliminate_specials(val)
   end

   set_replacement_list(list) ::: leaky, PURE
   ! The first column in "list" is the character to be replaced, and
   ! the second column is the character it should be replaced with.
   ! Set the replacement_list.
      self :: INOUT
      list :: MAT{STR}@, IN
       .style.set_replacement_list(list)
      .buffer.set_replacement_list(list)
   end

!  ==========
!  Set format
!  ==========

   set_using_fields(val) ::: PURE
   ! Set whether to use fields of fixed width or not.
      self :: INOUT
      val :: BIN, IN
      .style.set_using_fields(val)
   end

   set_spacing(val) ::: PURE
   ! Set the spacing between fields.
      self :: INOUT
      val :: INT, IN
      .style.set_spacing(val)
   end

   set_n_fields_per_line(val) ::: PURE
   ! Set the number of fields per file.
      self :: INOUT
      val :: INT, IN
      .style.set_n_fields_per_line(val)
   end

   set_int_width(val) ::: PURE
   ! Set the width of an integer field.
      self :: INOUT
      val :: INT, IN
      .style.set_int_width(val)
   end

   set_real_width(val) ::: PURE
   ! Set the width of an integer field.
      self :: INOUT
      val :: INT, IN
      .style.set_real_width(val)
   end

   set_real_precision(val) ::: PURE
   ! Set the real precision i.e. no of decimal places.
      self :: INOUT
      val :: INT, IN
      .style.set_real_precision(val)
   end

   set_real_fortran_fmt(val) ::: PURE
   ! Set the fortran format style string
      self :: INOUT
      val :: STR, IN
      .style.set_real_fortran_fmt(val)
   end

   set_line_fortran_fmt(fmt) ::: PURE
   ! Set the line format from fortran format string "fmt". 
   ! It should include the number of fields e.g. "5f10.3". 
   ! The style must be an allowed fortran real style like "f".
      self :: INOUT
      fmt :: STR, IN
      .style.set_line_fortran_fmt(fmt)
   end

   set_margin_width(val) ::: PURE
   ! Set the width of the margin in the buffer.
      self :: INOUT
      val :: INT, IN
      .style.set_margin_width(val)
   end

   set_using_array_labels(val) ::: PURE
   ! Set whether to use numbered columns, or row labels, on matrix or
   ! vector output.
      self :: INOUT
      val  :: BIN, IN
      .style.set_using_array_labels(val)
   end

   set_default_units(units) ::: PURE
   ! Set the .default_units to "units". This is reset back to 1
   ! after a particular number has been read and converted.
      self  :: INOUT
      units :: STR, IN
      .style.set_default_units(units)
   end


   real_format(n_fields,fmt,width,precision,with_parenthesis) result (res) ::: PURE
   ! Return real "<n_fields><fmt><width>.<precision>" fortran format
   ! string, like "5f10.3", for use in writing real quantities.
      self :: IN
      n_fields  :: INT, optional, IN
      fmt       :: STR, optional, IN
      width     :: INT, optional, IN
      precision :: INT, optional, IN
      with_parenthesis :: BIN, optional, IN
      res :: STR

      n,w,p :: INT
      s :: STR

      n = .style.n_fields_per_line
      if (present(n_fields)) n = n_fields

      s = .style.real_fortran_fmt
      if (present(fmt)) s = fmt

      w = .style.real_width
      if (present(width)) w = width

      p = .style.real_precision
      if (present(precision)) p = precision

      res = trim(n.to_str)
      res = trim(res) // trim(s)
      res = trim(res) // trim(w.to_str)
      res = trim(res) // "."
      res = trim(res) // trim(p.to_str)

      if (present(with_parenthesis)) then
      if (with_parenthesis) then
      res = "(" // trim(res) // ")"
      end
      end

   end

   int_format(n_fields,width,with_parenthesis) result (fmt) ::: PURE
   ! Return integer "<n_fields>i<width>" fortran format string, like
   ! "5i10", for use in writing integer quantities.
      self :: IN
      n_fields :: INT, optional, IN
      width :: INT, optional, IN
      with_parenthesis :: BIN, optional, IN
      fmt :: STR

      n,w :: INT

      n = .style.n_fields_per_line
      if (present(n_fields)) n = n_fields

      w = .style.int_width
      if (present(width)) w = width

      fmt = trim(n.to_str)
      fmt = trim(fmt) // "i"
      fmt = trim(fmt) // trim(w.to_str)

      if (present(with_parenthesis)) then
      if (with_parenthesis) then
      fmt = "(" // trim(fmt) // ")"
      end
      end

   end

!  ===================
!  Read format options
!  ===================

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process a command "keyword" from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR
      sty :: STR
      bin :: BIN
      val :: INT

      word = keyword
      word.to_lower_case

      select case (word)
      case ("int_width=            "); stdin.read(val); .set_int_width(val)
      case ("fortran_line_fmt=     "); stdin.read(sty); .set_line_fortran_fmt(sty)
      case ("fortran_real_fmt=     "); stdin.read(sty); .set_real_fortran_fmt(sty)
      case ("line_fmt=             "); stdin.read(sty); .set_line_fortran_fmt(sty)
      case ("line_format=          "); stdin.read(sty); .set_line_fortran_fmt(sty)
      case ("line_fortran_fmt=     "); stdin.read(sty); .set_line_fortran_fmt(sty)
      case ("margin_width=         "); stdin.read(val); .set_margin_width(val)
      case ("n_fields_per_line=    "); stdin.read(val); .set_n_fields_per_line(val)
      case ("no_of_fields_per_line="); stdin.read(val); .set_n_fields_per_line(val)
      case ("precision=            "); stdin.read(val); .set_real_precision(val)
      case ("real_fortran_fmt=     "); stdin.read(sty); .set_real_fortran_fmt(sty)
      case ("real_precision=       "); stdin.read(val); .set_real_precision(val)
      case ("real_style=           "); stdin.read(sty); .set_real_fortran_fmt(sty)
      case ("real_width=           "); stdin.read(val); .set_real_width(val)
      case ("use_array_labels=     "); stdin.read(bin); .set_using_array_labels(bin)
      case ("using_fields=         "); stdin.read(bin); .set_using_fields(bin)
      case ("using_array_labels=   "); stdin.read(bin); .set_using_array_labels(bin)
      case default;                  UNKNOWN(word)
      end

   end

!  ====================
!  File inquiry methods
!  ====================

   exists(name) result (res)
   ! Returns true if the file exists on the file system.
   ! Uses "name" if present, otherwise ".name".
      self :: IN
      name :: STR, optional, IN
      res :: BIN

      if (present(name)) then

         if (IO_IS_ALLOWED) then
            inquire(file=trim(name),exist=res)
         end
         PARALLEL_BROADCAST(res,tonto.master_processor)

      else

         if (IO_IS_ALLOWED) then
            inquire(file=trim(.name),exist=res)
         end
         PARALLEL_BROADCAST(res,tonto.master_processor)

      end

   end

   is_open result (res)
   ! Returns true if the file has been opened
      self :: IN
      res :: BIN

      if (.unit==TEXTFILE_STDIN_UNIT OR .unit==TEXTFILE_STDOUT_UNIT) then

         res = TRUE ! not needed for stdin, stdout

      else

        if (IO_IS_ALLOWED) then
           inquire(file=.name,opened=res)
         ! inquire(unit=.unit,opened=res)
        end

      end
      PARALLEL_BROADCAST(res,tonto.master_processor)

   end

   is_open_io result (res)
   ! Returns true if the file has been opened
      self :: IN
      res :: BIN

      if (.unit==TEXTFILE_STDIN_UNIT OR .unit==TEXTFILE_STDOUT_UNIT) then

         res = TRUE ! not needed for stdin, stdout

      else

        if (IO_IS_ALLOWED) then
           inquire(file=.name,opened=res)
         ! inquire(unit=.unit,opened=res)
        end

      end

   end

   unit_used result (res)
   ! Returns true if the file unit is in use
      self :: IN
      res :: BIN

      if (IO_IS_ALLOWED) then
        inquire(unit=.unit,opened=res)
      end
      PARALLEL_BROADCAST(res,tonto.master_processor)

   end

   at_end_of_file result (res)
   ! Read a line into the buffer from the input file and see if it is
   ! at the end of file. This is an explicit test, not just a viewing
   ! of ".IO_status".  NOTE: If all lines to the end of file are
   ! empty, then the result is also true.
      self :: INOUT
      res :: BIN

   ENSURE(.action=="read","file does not have read status")

      word :: STR
      ignore :: BIN

      ! Save ignore EOF status
      ignore = .ignore_EOF
      .ignore_EOF = TRUE

      ! Read a word ...
      .read(word)

      ! Is it the end of file?
      res = .end_of_file

      ! Reset .IO_status and move back
      .IO_status = 0
      .move_to_previous_item

      ! Put back ignore EOF status
      .ignore_EOF = ignore

   end

   end_of_file result (res) ::: pure
   ! See if .IO_status/=0, indicating the end of file has been found.
      self :: IN
      res :: BIN

      res = .IO_status/=0

   end

   reverted result (res) ::: pure
   ! See if .IO_status/=0, indicating an internal file has ended
   ! i.e. a soft ending).
      self :: IN
      res :: BIN

      res = .IO_status/=0

   end

!  ===========
!  Read a line
!  ===========

   read_line
   ! Read a line into the buffer.
      self :: INOUT

      if (.internal.allocated) then; .read_line_internal
      else;                          .read_line_external
      end

   end

   read_line_internal ::: private
   ! Read a line into the buffer from the internal file. If the file
   ! ends, this routine dies, UNLESS (1) .ignore_EOF is set,
   ! in which case another succesive failure to read a line will
   ! generate an error (this prevents infinite read loops, and is also
   ! useful for testing whether at the end of a file), OR (2) there is
   ! a .saved file, in which case the current file reverts to the
   ! saved file, and an attempt is made to read from that saved file.
      self :: INOUT

   ENSURE(.internal.allocated,"no internal file")

      string :: STR(len=BSTR_SIZE)

      ! Update
      .update_system_info

      if (.record<size(.internal)) then

         ! No errors.
         .IO_status = 0
         .record    = .record + 1
         string     = .internal(.record)
         .buffer.set_and_analyze(string)

      else

         ! At end of file.
         .IO_status = 1
         if (.ignore_EOF) then
            ! Next time don't ignore eof
            .ignore_EOF = FALSE
         else
            ! WTF?
            .read_line_bad_eof
         end

      end

      ! Update
      .update_system_info

   end

   read_line_external ::: private
   ! Read a line into the buffer from the input file. If the file
   ! ends, this routine dies, UNLESS
   ! (1) .ignore_EOF is set, in which case another succesive
   !     failure to read a line will generate an error (this prevents
   !     infinite read loops, and is also useful for testing whether
   !     at the end of a file), OR
   ! (2) there is a .saved file, in which case the current file
   !     reverts to the saved file, and an attempt is made to read
   !     that saved file.
      self :: INOUT

   ENSURE(.is_open,"file is not open")

      string :: STR(len=BSTR_SIZE)

      ! Update
      .update_system_info

      ! Read a line
      .IO_status = 0
      string = " "
      if (IO_IS_ALLOWED) then
         read(unit=.unit,iostat=.IO_status,fmt="(a)") string
      end

      ! Broadcast
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      PARALLEL_BROADCAST(string,tonto.master_processor)

      ! Is the read OK?
      select case (.IO_status)

      case (0)

            ! No errors. Analyze the line
            .buffer.set_and_analyze(string)
            .record = .record + 1

      case (TEXTFILE_IOSTAT_EOF)

         if (.ignore_EOF) then

            ! Status still indicates EOF
            ! Do an explicit backspace
            ! No need to (and don't) check .IO_status
            if (IO_IS_ALLOWED) then
               backspace(unit=.unit)
            end

         else

            ! Unexpected EOF
            .read_line_bad_eof

         end

      case default

         ! Some error, but not end of file.
         DIE("read error")

      end

      ! Update
      .update_system_info

   end

   read_line_bad_eof ::: private
   ! Reading a line encountered an unexpected EOF.
      self :: IN

      if(.saved.allocated) then; DIE("did you forget to set ignore_EOF?")
      else;                      DIE("unexpected end of file")
      end

   end

   update_line ::: private
   ! Get the next non-exhausted line if the current one is
   ! exhausted---and in this case, the buffer pointer is positioned
   ! before the first line item.  This routine performs a reversion if
   ! there is a .saved file.

      do

         ! Any items to read?
         if (.buffer.not_exhausted) exit

         ! No items: read new line
         .read_line

         ! Error: no more lines to read
         if (.end_of_file) exit

      end

   end

   revert_line ::: private
   ! Revert back to the previous non-exhausted line in the input file
   ! if the current buffer pointer is before the first item; and in
   ! this case, the buffer pointer is repositioned *after* the last
   ! line item.

      ! Any previous line items?
      if (.next_line_item>1) return

      ! No previous items: back to non-blank line
      do
         .backspace_line
         if (.buffer.not_exhausted) exit
      end

      ! Move *after* last item on non-blank line
      .move_to_line_item(.last_line_item+1)

   end

!  ========================
!  File rewind, move to end
!  ========================

   rewind
   ! Rewind the input file, reading the first line for read-only files.
      self :: INOUT

      if (.internal.allocated) then; .rewind_internal
      else;                          .rewind_external
      end

      select case (.action)
      case("read      ","reading   ","read-only ")
      case("write     ","writing   ","write-only")
      case default; UNKNOWN(.action)
      end

   end

   rewind_internal ::: private, PURE
   ! Rewind the input file, but do not read a line.
      self :: INOUT

      .record = 0
      .IO_status = 0

   end

   rewind_external ::: private
   ! Rewind the input file, but do not read a line.
      self :: INOUT

      ! Update
      .update_system_info

      ! Rewind
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         rewind(unit=.unit,iostat=.IO_status)
      end

      ! Failure?
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening new file "//trim(.name))

      ! All good: set line no.
      .record = 0

   end

   move_to_end
   ! Move to the end of the input file
      self :: INOUT

      if (.internal.allocated) then; .move_to_end_internal
      else;                          .move_to_end_external
      end

   end

   move_to_end_internal ::: private
   ! Move to the end of the input file
      self :: INOUT

      .record = size(.internal)-1

      .read_line

   end

   move_to_end_external ::: private
   ! Move to the end of the input file
      self :: INOUT

      ! Update
      .update_system_info

      ! Read till failure
      do

         ! Read a line
         .IO_status = 0
         if (IO_IS_ALLOWED) then
            read(unit=.unit, iostat=.IO_status, fmt="()")
         end
         PARALLEL_BROADCAST(.IO_status,tonto.master_processor)

         ! Failed?
         if (.IO_status/=0) exit

         ! Increment line no.
         .record = .record + 1

      end

      ! At the EOF: backspace twice
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         backspace(unit=.unit,iostat=.IO_status)
         backspace(unit=.unit,iostat=.IO_status)
      end
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)

      ! Set the record
      .record = max(0,.record-1)

      ! Get the last line
      .read_line

   end

!  =================
!  Skip file records
!  =================

   skip_line
   ! Skip the next line in the input file
      self :: INOUT

      record :: INT

      record = .record + 1
      .move_to_record(record)

   end

   backspace_line
   ! Move to the previous line
      self :: INOUT

      record :: INT

      record = .record - 1
      .move_to_record(record)

   end

   move_to_line(line)
   ! Make sure that "line" was the last one processed
   ! in the input file
      self :: INOUT
      line :: INT, IN

      .move_to_record(line)

   end

   move_to_record(rec)
   ! Move to the requested record "rec" in the input file.
   ! and read it into the buffer. Set .record to the
   ! last processed record.
      self :: INOUT
      rec :: INT, IN

   ENSURE(rec>=0,"line number must be non-negative")

      if (.internal.allocated) then; .move_to_record_internal(rec)
      else;                          .move_to_record_external(rec)
      end

   end

   move_to_record_internal(rec) ::: private
   ! Move to the requested record "rec" in the internal file.
   ! and read it into the buffer. Set .record to the
   ! last processed record.
      self :: INOUT
      rec :: INT, IN

   ENSURE(rec>=0,"record number must be non-negative")
   ENSURE(rec<=size(.internal),"record outside file range")

      .record = rec - 1

      .read_line

   end

   move_to_record_external(rec) ::: private
   ! Move to the requested record "rec" in the input file.
   ! and read it into the buffer. Set .record to the
   ! last processed record.
      self :: INOUT
      rec :: INT, IN

   ENSURE(rec>=0,"record number must be non-negative")

      ! Update
      .update_system_info

      if (rec<(.record+1)) then

         ! Go backwards
         do
            .move_to_back_record
            if (rec==(.record+1)) exit
         end

      else if (rec>(.record+1)) then

         ! Go forwards
         do
           .move_to_next_record
           if (rec==(.record+1)) exit
         end

      end

      ! Read it
      .read_line

   end

   move_to_back_record ::: private
   ! Backspace a record. Skip system info update.
      self :: INOUT

      .IO_status = 0
      if (IO_IS_ALLOWED) then
         backspace(unit=.unit,iostat=.IO_status)
      end

      ! Failure?
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening new file "//trim(.name))

      ! Next record
      .record = .record - 1

   end

   move_to_next_record ::: private
   ! Forward space a record. Skip system info update.
      self :: INOUT

      ! Read a line
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         read(unit=.unit,fmt="()",iostat=.IO_status)
      end

      ! Failure?
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      DIE_IF(.IO_status/=0,"error opening new file "//trim(.name))

      ! Next record
      .record = .record + 1

   end

   increment_record ::: private
   ! Increment the .record counter for the file
      self :: INOUT

      record :: INT

      record = .record + 1

   end

!  ===========
!  Line search
!  ===========

!  Consider slurping whole file into memory?

   look_for_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)
   ! Scan through the file for an "item". If present:
   ! . Starting at line "from"  inclusive
   ! . Ending at line "until" inclusive
   ! . Ending at any token which *begins* with "end_tokens"
   ! . With "item" matching exactly, if "exact_match" is TRUE
   ! . With "item" head-matching,    if "head_match" is TRUE
   ! . Return cursor to orginal line, if "return_cursor" is TRUE
   ! . Return without error, with "found" TRUE if "item" was found
      self  :: INOUT
      item  :: STR, IN
      from  :: INT, IN, optional
      until :: INT, IN, optional
      end_tokens  :: VEC{STR}, IN, optional
      exact_match :: BIN, IN, optional
      head_match  :: BIN, IN, optional
      return_cursor :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record :: INT
      word :: STR
      fnd,exact,head,put_back,has_item,has_end,match :: BIN
      i :: INT

      ! Look from .record or "from"
      start_record = .record
      if (present(from)) start_record = from

      ! Look until EOF or "until"
      if (present(until)) then
         ENSURE(until>=start_record,"ending line must be greater than starting line")
      end

      ! Item to match exactly?
      exact = FALSE
      if (present(exact_match)) exact = exact_match

      ! Item to match token head only?
      head = FALSE
      if (present(head_match))  head = head_match
      if (head) exact = FALSE

      ! Rewind afterwards?
      put_back = FALSE
      if (present(return_cursor)) put_back = return_cursor

      ! Move to start
      .move_to_record(start_record)

      ! Initialize
      .ignore_EOF = TRUE
      fnd = FALSE

      ! Loop over file lines
      if (NOT .end_of_file) then

        ! Now do the search here ...
        line_search: do

           ! Item found?
           has_item = .buffer.string.includes(item)

           ! End token found?
           has_end = FALSE
           if (present(end_tokens)) then
           if (.record>start_record) then
              has_end = .buffer.string.includes_any_in(end_tokens)
           end
           end

           if (has_item OR has_end) then

              ! Find the matching token
              do i = 1,.buffer.n_items

                 .get_next_item(word)

                 if (has_item) then

                    ! What kind of match was it?
                    if (head) then;       match = word.includes(item,at_start=TRUE)
                    else if (exact) then; match = word==item
                    else;                 match = word.includes(item)
                    end

                    if (match) then
                       fnd = TRUE
                       exit line_search
                    end

                 end

                 if (has_end) then
                 if (end_tokens.has_any_included_in(word,at_start=TRUE)) then
                       fnd = TRUE
                       exit line_search
                 end
                 end

              end

           end

           if (present(until)) then
              if (.record==until) exit line_search
           end

           .read_line

           if (.end_of_file) exit line_search

        end do line_search

      end

      if (present(found)) found = fnd
      if (NOT fnd AND put_back) .move_to_record(start_record)

      .ignore_EOF = FALSE

   end

   look_backwards_for_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)
   ! Scan *backwards* through the file for an "item". If present:
   ! . Starting at line "from"  inclusive
   ! . Ending at line "until" inclusive
   ! . Ending at any token which *begins* with "end_tokens"
   ! . With "item" matching exactly, if "exact_match" is TRUE
   ! . With "item" head-matching,    if "head_match" is TRUE
   ! . Return cursor to orginal line, if "return_cursor" is TRUE
   ! . Return without error, with "found" TRUE if "item" was found
      item  :: STR, IN
      from  :: INT, IN, optional
      until :: INT, IN, optional
      end_tokens  :: VEC{STR}, IN, optional
      exact_match :: BIN, IN, optional
      head_match  :: BIN, IN, optional
      return_cursor :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record,end_record :: INT
      word :: STR
      fnd,exact,head,put_back,has_item,has_end,match :: BIN
      i :: INT

      ! Look from .record or "from"
      start_record = .record
      if (present(from)) start_record = from

      ! Look until SOF or "until"
      end_record = 1
      if (present(until)) end_record = until
      ENSURE(end_record<=start_record,"ending line must be smaller than starting line")

      ! Item to match exactly?
      exact = FALSE
      if (present(exact_match)) exact = exact_match

      ! Item to match token head only?
      head = FALSE
      if (present(head_match))  head = head_match
      if (head) exact = FALSE

      ! Rewind afterwards?
      put_back = FALSE
      if (present(return_cursor)) put_back = return_cursor

      ! Move to start
      .move_to_record(start_record)

      ! Initialise
      .ignore_EOF = TRUE
      fnd = FALSE

      if (NOT .end_of_file) then

        .move_to_last_item_on_line

        ! Search for tokens ...
        line_search: do

           ! Item found?
           has_item = .buffer.string.includes(item)

           ! End token found?
           has_end = FALSE
           if (present(end_tokens)) then
           if (.record>start_record) then
              has_end = .buffer.string.includes_any_in(end_tokens)
           end
           end

           if (has_item OR has_end) then

              ! Look backwards ...
              do i = .buffer.n_items,1,-1

                 .move_to_line_item(i)
                 .get_next_item(word)

                 if (has_item) then

                    ! What kind of match was it?
                    if (head) then;       match = word.includes(item,at_start=TRUE)
                    else if (exact) then; match = word==item
                    else;                 match = word.includes(item)
                    end

                    ! Found a match
                    if (match) then
                       fnd = TRUE
                       exit line_search
                    end

                 end

                 if (has_end) then
                 if (end_tokens.has_any_included_in(word,at_start=TRUE)) then
                      fnd = TRUE
                      exit line_search
                 end
                 end

              end

           end

           if (.record==end_record) exit line_search

           ! Move to previous line
           .backspace_line

        end do line_search

      end

      if (present(found)) found = fnd

      if (NOT fnd AND put_back) .move_to_record(start_record)

      .ignore_EOF = FALSE

   end

   look_for_any_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)
   ! Scan through the file for *any* in "item". If present:
   ! . Starting at line "from"  inclusive
   ! . Ending at line "until" inclusive
   ! . Ending at any token which *begins* with "end_tokens"
   ! . With "item" matching exactly, if "exact_match" is TRUE
   ! . With "item" head-matching,    if "head_match" is TRUE
   ! . Return cursor to orginal line, if "return_cursor" is TRUE
   ! . Return without error, with "found" TRUE if "item" was found
      item  :: VEC{STR}, IN
      from  :: INT, IN, optional
      until :: INT, IN, optional
      end_tokens  :: VEC{STR}, IN, optional
      exact_match :: BIN, IN, optional
      head_match  :: BIN, IN, optional
      return_cursor :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record :: INT
      word :: STR
      fnd,exact,head,put_back,has_item,has_end,match :: BIN
      i,j :: INT

      ! Look from .record or "from"
      start_record = .record
      if (present(from)) start_record = from

      ! Look until EOF or "until"
      if (present(until)) then
         ENSURE(until>=start_record,"ending line must be greater than starting line")
      end

      ! Item to match exactly?
      exact = FALSE
      if (present(exact_match)) exact = exact_match

      ! Item to match token head only?
      head = FALSE
      if (present(head_match))  head = head_match
      if (head) exact = FALSE

      ! Rewind afterwards?
      put_back = FALSE
      if (present(return_cursor)) put_back = return_cursor

      ! Move to start
      .move_to_record(start_record)

      ! Initialize
      .ignore_EOF = TRUE
      fnd = FALSE

      if (NOT .end_of_file) then

         line_search: do

            ! Item found?
            has_item = .buffer.string.includes_any_in(item)

            ! End token found?
            has_end = FALSE
            if (present(end_tokens))  then
            if (.record>start_record) then
               has_end = .buffer.string.includes_any_in(end_tokens)
            end
            end

            if (has_item OR has_end) then

               ! Find the matching token
               do i = 1,.buffer.n_items

                  .get_next_item(word)

                  if (has_item) then

                     ! What kind of match was it?
                     match = FALSE
                     if (head) then
                        do j = 1,item.dim
                           match = word.includes(item(j),at_start=TRUE)
                           if (match) exit
                        end
                     else if (exact) then
                        do j = 1,item.dim
                           match = word==item(j)
                           if (match) exit
                        end
                     else ! partial
                        do j = 1,item.dim
                           match = word.includes(item(j))
                           if (match) exit
                        end
                     end

                     ! Found a match
                     if (match) then
                        fnd = TRUE
                        exit line_search
                     end

                  end

                  if (has_end) then
                  if (end_tokens.has_any_included_in(word,at_start=TRUE)) then
                        exit line_search
                  end
                  end

               end

            end

            if (present(until)) then
               if (.record==until) exit line_search
            end

            .read_line

            if (.end_of_file) exit line_search

         end do line_search

      end

      if (present(found)) found = fnd
      if (NOT fnd AND put_back) .move_to_record(start_record)

      .ignore_EOF = FALSE

   end

   look_for(item,from,until,first,found)
   ! Scans through the file for a line which includes string "item".  If there,
   ! the file record is left at the first line at which the match occured.  If
   ! no match is found, the file is rewound to the initial line before the
   ! search.  If "from" is present then it is used as the start line for the
   ! search, and if "item" is not found the file record is returned to that
   ! line.  If "until" is present then matches to these tokens are used to
   ! indicate the end of search condition for "item". If "first" is present and
   ! TRUE, then the item is matched only if it is the first non-blank token in
   ! the input, and likewise the search is terminated only when the "until"
   ! tokens are the first characters in the input. If "found" is present, it is
   ! set TRUE when the item is found, else FALSE.
      item :: STR, IN
      from :: INT, IN, optional
      until :: VEC{STR}, IN, optional
      first :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record :: INT
      fnd :: BIN

      start_record = .record
      if (present(from)) start_record = from

      ! Move to start
      .move_to_record(start_record)

      ! Initialize
      .ignore_EOF = TRUE
      fnd = FALSE

      line_search: do

         ! NOTE: below should be a method of buffer
         if (item.is_included_in(.buffer.string,first)) then
            fnd = TRUE
            exit line_search
         end

         if (present(until)) then
         if (.record>start_record) then
         if (until.has_any_included_in(.buffer.string,first)) then
            .move_to_record(start_record)
            fnd = FALSE
            exit line_search
         end
         end
         end

         .read_line

         if (.end_of_file) then
            .move_to_record(start_record)
            fnd = FALSE
            exit line_search
         end

      end do line_search

      if (present(found)) found = fnd

      .ignore_EOF = FALSE

   end

   look_backwards_for(item,from,until,first,found)
   ! Scans backward through the file for a line which includes string "item".
   ! If there, the file record is left at the first line at which the match
   ! occured.  If no match is found, the file is rewound to the initial line
   ! before the search.  If "from" is present then it is used as the start line
   ! for the search, and if "item" is not found the file record is returned to
   ! that line.  If "until" is present then matches to these tokens are used to
   ! indicate the end of search condition for "item". If "first" is present and
   ! TRUE, then the item is matched only if it is the first non-blank token in
   ! the input, and likewise the search is terminated only when the "until"
   ! tokens are the first characters in the input. If "found" is present, it is
   ! set TRUE when the item is found, else FALSE.
      item :: STR, IN
      from :: INT, IN, optional
      until :: VEC{STR}, IN, optional
      first :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record :: INT
      fnd :: BIN

      ! Look from .record or "from"
      start_record = .record
      if (present(from)) start_record = from

      ! Move to start
      .move_to_record(start_record)

      ! Initialize
      .ignore_EOF = TRUE
      fnd = FALSE

      do

         ! NOTE: below should be a method of buffer
         if (item.is_included_in(.buffer.string,first)) then
            fnd = TRUE
            exit
         end

         ! Start of the file?
         if (.record==1) then
            .move_to_record(start_record)
            fnd = FALSE
            exit
         end

         .backspace_line

         if (present(until)) then
         if (.record<start_record) then
         if (until.has_any_included_in(.buffer.string,first)) then
            .move_to_record(start_record)
            fnd = FALSE
            exit
         end
         end
         end

      end

      if (present(found)) found = fnd

      .ignore_EOF = FALSE

   end

   has_string(search) result (res)
   ! Returns TRUE if the file contains string "search". The file is returned
   ! to its original line number after this routine.
      search :: STR, IN

      res :: BIN
      update_record :: INT
      found :: BIN

      update_record = .record

      .rewind

      .ignore_EOF = TRUE
      found = FALSE

      do

         if (search.is_included_in(.buffer.string)) then
            found = TRUE
            exit
         end

         .read_line

         if (.end_of_file) exit

      end

      .move_to_record(update_record)

      .ignore_EOF = FALSE

      res = found

   end

!  ====================
!  Item inquiry methods
!  ====================

   next_line_item result (res) ::: pure
   ! Return the index of the next item to be processed on the line
      self :: IN
      res :: INT

      res = .buffer.next_item_number

   end

   previous_line_item  result (res) ::: pure
   ! Return the index of the previous item to be processed on the line
      self :: IN
      res :: INT

      res = .buffer.item_index

   end

   last_line_item  result (res) ::: pure
   ! Return the index of the final item on the line
      self :: IN
      res :: INT
      res = .buffer.n_items

   end

   n_line_items result (res) ::: pure
   ! Return the number of items on the line
      self :: IN
      res :: INT

      res = .buffer.n_items

   end

   at_end_of_line result (res) ::: pure
   ! Return TRUE if at the end of the line
      self :: IN
      res :: BIN

      res = .buffer.item_index==.buffer.n_items

   end

   line_number result (res) ::: pure
   ! Return the input file line number which is being processed
      self :: IN
      res :: INT

      res = .record

   end

   buffer_string result (res) ::: pure
   ! Put a string into the buffer
      self :: IN
      res :: STR(len=BSTR_SIZE)
      res = .buffer.buffer_string
   end

   rest_of_line result (res)
   ! If there is anything left on the input line, then it is returned, else
   ! nothing is returned.  Record moves to the next line.
      res :: STR

   ENSURE(.action=="read","file does not have read action!")

      if (NOT .buffer.empty) then

         res = .buffer.string(.buffer.item_end+1: )
         .read_line

      else

         res = " "
         .read_line

      end

   end

   buffer_exhausted result (res) ::: pure
   ! Return whether the buffer is exhausted
     self :: IN
     res :: BIN

     res = .buffer.exhausted

   end

!  ============
!  Read an item
!  ============

   get_next_item(word) ::: private
   ! Get the next item in the file
      word :: STR
      .update_line
      .buffer.get(word)
   end

   next_item result(word) ::: leaky
   ! Read a str from the input file and return it but
   ! *do not advance the cursor*. Use next_str for that.
      self :: INOUT
      word :: STR

      .read(word)
      .move_to_previous_item

   end

   next_str result(word) ::: leaky
   ! Read a str from the input file and return it and advance the cursor
      word :: STR
      .read(word)
   end

!  ==================
!  Skip/move to items
!  ==================

   skip_next_item ::: leaky
   ! Move to (i.e. just after) the next item in the input file.
      .update_line
      .buffer.skip_item
   end

   skip_next_items(n) ::: leaky
   ! Skip several items.
      n :: INT, IN
      i :: INT
      do i = 1,n
         .skip_next_item
      end
   end

   move_to_previous_item
   ! Move to (i.e. before) the previous item in the input file.
   ! Backspace a line if required.
      self :: INOUT

      .revert_line

      ! Move to the last read item
      .move_to_previous_item_on_line

   end

   move_to_last_item_on_line
   ! Move the cursor over to the beginning of the last item on the line
      item :: INT
      item = .last_line_item
      .move_to_line_item(item)
   end

   move_to_previous_item_on_line
   ! Move the cursor over to the beginning of the previous item on the
      item :: INT
      item = .previous_line_item
      .move_to_line_item(item)
   end

   move_to_line_item(number)
   ! Move the cursor over to the beginning of the item with index "number"
   ! on the current line. (More accurately: after the end of the previous item
   ! on the current line. So if there are "nitems" on the line you can move to
   ! "nitem+1" if you want to, and that will be the end of the line).
      self :: INOUT
      number :: INT, IN

      ! Update
      .update_system_info

      .buffer.move_to_item(number)

   end

!  ====================
!  Read a built-in TYPE
!  ====================

   read(value) ::: template
   ! Read a built-in type into "value".
      self :: INOUT
      value :: VALUE?, OUT

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get(value)

   end

   read(value) ::: get_from(TEXTFILE, VALUE?=>STR)
   ! Read a built-in type into "value".
   end

   read(value) ::: get_from(TEXTFILE, VALUE?=>BIN)
   ! Read a built-in type into "value".
   end

   read(value) ::: get_from(TEXTFILE, VALUE?=>INT)
   ! Read a built-in type into "value".
   end

   read(value) ::: get_from(TEXTFILE, VALUE?=>REAL)
   ! Read a built-in type into "value".
   end

   read(value,format)
   ! Read a formatted INT into "value". Does not check the end of line!
      value :: INT, OUT
      format :: STR, IN

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get(value,format)

   end

   read(value,format)
   ! Read a formatted REAL into "value". Does not check the end of line!
      value :: REAL, OUT
      format :: STR, IN

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get(value,format)

   end

   read(value,error)
   ! Read a REAL into "value" and also associated "error", 
   ! which appears in parentheses after it.
      value :: REAL, OUT
      error :: REAL, OUT

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get_imprecise_real(value,error)

   end

   read(value) ::: get_from(TEXTFILE, VALUE?=>CPX)
   ! Read a built-in type into "value".
   end

!  =============================
!  Read a built-in TYPE quantity
!  =============================

   read_quantity(value) ::: template
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier.
      self :: INOUT
      value :: VALUE?, OUT

   ENSURE(.action=="read","file does not have read action!")

      units :: STR
      known_unit :: BIN

      ! Read the value
      .read(value)

      ! Convert from assumed default units
      if (.style.default_units/=" ") &
        value.convert_from(.style.default_units)

      ! Check for explicit units
      if (NOT .at_end_of_file) then

        ! Is there a known unit next?
        .read(units)
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .style.default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then; value.convert_from(units)
        else;                 .move_to_previous_item
        end

      end

      ! Reset default units
      .style.default_units = " "

   end

   read_quantity(value) ::: get_from(TEXTFILE, VALUE?=>INT)
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier.
   end

   read_quantity(value) ::: get_from(TEXTFILE, VALUE?=>REAL)
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier.
   end

   read_quantity(value,error)
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier.
      value :: REAL, OUT
      error :: REAL, OUT

   ENSURE(.action=="read","file does not have read action!")

      units :: STR
      known_unit :: BIN

      ! Read the value & error
      .read(value,error)

      ! Convert from assumed default units
      if (.style.default_units/=" ") then
         value.convert_from(.style.default_units)
         error.convert_from(.style.default_units)
      end

      ! Check for explicit units
      if (NOT .at_end_of_file) then

        ! Is there a known unit next?
        .read(units)
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .style.default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then
           value.convert_from(units)
           error.convert_from(units)
        else
           .move_to_previous_item
        end

      end

      ! Reset default units
      .style.default_units = " "

   end

!  ==============
!  Read VEC{TYPE}
!  ==============

   read(v) ::: template
   ! Read in a vector sequentially. Line breaks are not significant.
      self :: INOUT
      v :: V?, OUT

      i :: INT

      do i = 1,v.dim
         .read(v(i))
      end

   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{STR})
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{BIN})
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{INT})
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{REAL})
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{CPX})
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v,e)
   ! Read in a vector sequentially. Line breaks are not significant.
      v :: VEC{REAL}, OUT
      e :: VEC{REAL}, OUT

      i :: INT

      do i = 1,v.dim
         .read(v(i),e(i))
      end

   end

!  =========================
!  Read VEC{TYPE} quantities
!  =========================

   read_quantity(v) ::: template
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier.
      self :: INOUT
      v :: V?, OUT

      units :: STR
      known_unit :: BIN

      ! Read the vector
      .read(v)

      ! Convert from assumed default units
      if (.style.default_units/=" ") &
         v.convert_from(.style.default_units)

      ! Check for explicit units
      if (NOT .at_end_of_file) then

        ! Is there a known unit next?
        .read(units)
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .style.default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then; v.convert_from(units)
        else;                 .move_to_previous_item
        end

      end

      ! Reset default units
      .style.default_units = " "

   end

   read_quantity(v) ::: get_from(TEXTFILE, V?=>VEC{INT})
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier.
   end

   read_quantity(v) ::: get_from(TEXTFILE, V?=>VEC{REAL})
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier.
   end

   read_quantity(v,e)
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier.
      v :: VEC{REAL}, OUT
      e :: VEC{REAL}, OUT

      units :: STR
      known_unit :: BIN

      ! Read the vector
      .read(v,e)

      ! Convert from assumed default units
      if (.style.default_units/=" ") then
         v.convert_from(.style.default_units)
         e.convert_from(.style.default_units)
      end

      ! Check for explicit units
      if (NOT .at_end_of_file) then

        ! Is there a known unit next?
        .read(units)
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .style.default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then
           v.convert_from(units)
           e.convert_from(units)
        else
           .move_to_previous_item
        end

      end

      ! Reset default units
      .style.default_units = " "

   end

!!  ===============
!!  Read VEC{TYPE}*
!!  ===============

   list_length(op,cl) result (res) ::: leaky, private
   ! Return the size of the list, by reading the input after an
   ! initial opening bracket "{" until a *matching* end bracket "}"
   ! token is found. Line breaks are not significant. "op" and "cl"
   ! are optional opening/closing delimniters, default "{" and "}".
      self :: INOUT
      op,cl :: STR, optional, IN
      res :: INT

      line,item, n :: INT
      op_del,cl_del :: STR
      word :: STR

      ! Set optional delimiters
      op_del = "{"
      cl_del = "}"
      if (present(op)) op_del = op
      if (present(cl)) cl_del = cl

      ! Store original pos
      line = .line_number
      item = .next_line_item

      ! Read open brace
      .read(word)
      ENSURE(word==op_del,"list does not begin with "//trim(op_del))

      ! Count the items
      n = 0
      res = 0
      do
         .read(word)
         if (word==op_del) n = n + 1         ! Allow open delim in list
         if (word==cl_del AND n==0) exit     ! Found cl_del but empty list
         if (word==cl_del AND n>0) n = n - 1 ! Found cl_del non-empty
         res = res + 1
      end

      ! Reinstate original position
      .move_to_line(line)
      .move_to_line_item(item)

   end


!   read_ptr(v) ::: template
!   ! Read in a vector pointer "v" sequentially. Line breaks are not
!   ! significant. The "v" vector pointer is created.
!      self :: INOUT
!      v :: V?*
!
!      dim :: INT
!      word :: STR
!
!      ! Find out the list length
!      dim = .list_length
!      v.create(dim)
!
!      ! Read opening brace
!      .read(word)
!      ENSURE(word=="{","list does not begin with a {")
!
!      ! Read vector
!      .read(v)
!
!      ! Read closing brace
!      .read(word)
!      ENSURE(word=="}","list does not end with a }")
!
!   end
!
!   read_ptr(v) ::: get_from(TEXTFILE, V?=>VEC{STR}), leaky
!   ! Read in a vector pointer "v" sequentially. Line breaks are not
!   ! significant. The "v" vector pointer is created.
!   end
!
!   read_ptr(v) ::: get_from(TEXTFILE, V?=>VEC{BIN}), leaky
!   ! Read in a vector pointer "v" sequentially. Line breaks are not
!   ! significant. The "v" vector pointer is created.
!   end
!
!   read_ptr(v) ::: leaky
!   ! Read in a fancy vector pointer "v" sequentially. Fancy because a
!   ! looping construct in understood. Line breaks are not significant.
!   ! The "v" vector pointer is created.
!      self :: INOUT
!      v :: VEC{INT}*
!
!      dim,f,l,i :: INT
!      word,first,second :: STR
!
!      ! Read opening brace and first two items
!      .read(word)
!      ENSURE(word=="{","list does not begin with a {")
!      .read(first)
!      .read(second)
!
!      ! If second item is looping construct ..
!      if (second=="...") then
!
!         ! Read last index & create "v"
!         .read(l)
!         f = first.to_int
!         dim = l - f + 1
!         v.create(abs(dim))
!
!         ! Define sequental "v"
!         if (dim>0) then; v = [ (i, i=f,l)    ]
!         else           ; v = [ (i, i=f,l,-1) ]
!         end
!
!         ! Read closing brace
!         .read(word)
!         ENSURE(word=="}","list does not end with a {")
!
!      ! Plain old VEC{INT}*
!      else
!
!         ! Backtrack before "{"
!         .move_to_previous_item
!         .move_to_previous_item
!         .move_to_previous_item
!
!         ! Read "v" in
!         .read_ptr_helper(v)
!
!      end
!
!   end
!
!   read_ptr_helper(v) ::: get_from(TEXTFILE:read_ptr, V?=>VEC{INT}), leaky
!   ! Read in a vector pointer "v" sequentially. Line breaks are not
!   ! significant. The "v" vector pointer is created.
!   end
!
!   read_ptr(v) ::: get_from(TEXTFILE, V?=>VEC{REAL}), leaky
!   ! Read in a vector pointer "v" sequentially. Line breaks are not
!   ! significant. The "v" vector pointer is created.
!   end
!
!   read_ptr(v) ::: get_from(TEXTFILE, V?=>VEC{CPX}), leaky
!   ! Read in a vector pointer "v" sequentially. Line breaks are not
!   ! significant. The "v" vector pointer is created.
!   end

!  ===============
!  Read VEC{TYPE}@
!  ===============

   read_all(v,op,cl) ::: template, leaky
   ! Read in an allocatable vector "v" sequentially. Line breaks are
   ! not significant. "v" is created. "op" and "cl" are optional
   ! opening and closing delimiters, by default "{" and "}".
      self :: INOUT
      v :: V?@, OUT
      op :: STR, optional, IN
      cl :: STR, optional, IN

      dim :: INT
      op_del,cl_del :: STR
      word :: STR

      ! Set optional delimiters
      op_del = "{"
      cl_del = "}"
      if (present(op)) op_del = op
      if (present(cl)) cl_del = cl

      ! Find out the list length
      dim = .list_length(op,cl)
      v.create(dim)

      ! Read opening brace
      .read(word)
      ENSURE(word==op_del,"list does not begin with a {")

      ! Read vector
      .read(v)

      ! Read closing brace
      .read(word)
      ENSURE(word==cl_del,"list does not end with a }")

   end

   read_all(v,op,cl) ::: get_from(TEXTFILE, V?=>VEC{STR}), leaky
   ! Read in an allocatable vector "v" sequentially. Line breaks are
   ! not significant. "v" is created. "op" and "cl" are optional
   ! opening and closing delimiters, by default "{" and "}".
   end

   read_all(v,op,cl) ::: get_from(TEXTFILE, V?=>VEC{BIN}), leaky
   ! Read in an allocatable vector "v" sequentially. Line breaks are
   ! not significant. "v" is created. "op" and "cl" are optional
   ! opening and closing delimiters, by default "{" and "}".
   end

   read_all(v,op,cl) ::: leaky
   ! Read in an allocatable vector "v" sequentially. Fancy because a
   ! looping construct is recognised. Line breaks are not significant.
   ! "v" is created. "op" and "cl" are optional opening and closing
   ! delimiters, by default "{" and "}".
      self :: INOUT
      v :: VEC{INT}@, OUT
      op :: STR, optional, IN
      cl :: STR, optional, IN

      dim,f,l,i :: INT
      word,first,second :: STR
      op_del,cl_del :: STR

      ! Set optional delimiters
      op_del = "{"
      cl_del = "}"
      if (present(op)) op_del = op
      if (present(cl)) cl_del = cl

      ! Read opening brace and first two items
      .read(word)
      ENSURE(word==op_del,"list does not begin with a "//trim(op_del))
      .read(first)
      .read(second)

      ! If second item is looping construct ..
      if (second=="...") then

         ! Read last index & create "v"
         .read(l)
         f = first.to_int
         dim = l - f + 1
         v.create(abs(dim))

         ! Define sequental "v"
         if (dim>0) then; v = [ (i, i=f,l)    ]
         else           ; v = [ (i, i=f,l,-1) ]
         end

         ! Read closing brace
         .read(word)
         ENSURE(word==cl_del,"list does not end with a "//trim(cl_del))

      ! Plain old VEC{INT}*
      else

         ! Backtrack before openeing delimiter
         .move_to_previous_item
         .move_to_previous_item
         .move_to_previous_item

         ! Read "v" in
         .read_all_helper(v,op,cl)

      end

   end

   read_all_helper(v,op,cl) ::: get_from(TEXTFILE:read_all, V?=>VEC{INT}), leaky
   ! Read in an allocatable vector "v" sequentially. Line breaks are
   ! not significant. "v" is created. "op" and "cl" are optional
   ! opening and closing delimiters, by default "{" and "}".
   end

   read_all(v,op,cl) ::: get_from(TEXTFILE, V?=>VEC{REAL}), leaky
   ! Read in an allocatable vector "v" sequentially. Line breaks are
   ! not significant. "v" is created. "op" and "cl" are optional
   ! opening and closing delimiters, by default "{" and "}".
   end

   read_all(v,op,cl) ::: get_from(TEXTFILE, V?=>VEC{CPX}), leaky
   ! Read in an allocatable vector "v" sequentially. Line breaks are
   ! not significant. "v" is created. "op" and "cl" are optional
   ! opening and closing delimiters, by default "{" and "}".
   end

!  ========================
!  Read VEC{TYPE}* quantity
!  ========================
!
!   read_ptr_quantity(v) ::: template
!   ! Read in a vector pointer quantity (with units) sequentially.
!   ! Line breaks are not significant.  WARNING: You must *not* be at
!   ! the end of file to use this routine, since it will try to read
!   ! the next token after the vector as a units specifier.
!      self :: INOUT
!      v :: V?*
!
!      units :: STR
!      known_unit :: BIN
!
!      ! Read the vector pointer
!      .read_ptr(v)
!
!      ! Convert from assumed default units
!      if (.style.default_units/=" ") &
!         v.convert_from(.style.default_units)
!
!      ! Check for explicit units
!      if (NOT .at_end_of_file) then
!
!        ! Is there a known unit next?
!        .read(units)
!        known_unit = units.is_known_unit
!
!        ! Has conversion already been done?
!        DIE_IF(known_unit AND .style.default_units/=" ","two units specified!")
!
!        ! Convert from known units if we can ...
!        ! Or move back to where we were
!        if (known_unit) then; v.convert_from(units)
!        else;                 .move_to_previous_item
!        end
!
!      end
!
!      ! Reset default units
!      .style.default_units = " "
!
!   end
!
!   read_ptr_quantity(v) ::: get_from(TEXTFILE, V?=>VEC{REAL}), leaky
!   ! Read in a vector pointer quantity (with units) sequentially.
!   ! Line breaks are not significant.  WARNING: You must *not* be at
!   ! the end of file to use this routine, since it will try to read
!   end

!  ========================
!  Read VEC{TYPE}@ quantity
!  ========================

   read_all_quantity(v) ::: template
   ! Read in an allocatable vector quantity (with units) sequentially.
   ! Line breaks are not significant.  WARNING: You must *not* be at
   ! the end of file to use this routine, since it will try to read
   ! the next token after the vector as a units specifier.
      self :: INOUT
      v :: V?@, OUT

      units :: STR
      known_unit :: BIN

      ! Read the vector pointer
      .read_all(v)

      ! Convert from assumed default units
      if (.style.default_units/=" ") then
         v.convert_from(.style.default_units)
      end

      ! Check for explicit units
      if (NOT .at_end_of_file) then

        ! Is there a known unit next?
        .read(units)
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .style.default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then; v.convert_from(units)
        else;                 .move_to_previous_item
        end

      end

      ! Reset default units
      .style.default_units = " "

   end

   read_all_quantity(v) ::: get_from(TEXTFILE, V?=>VEC{REAL}), leaky
   ! Read in an allocatable vector quantity (with units) sequentially.
   ! Line breaks are not significant.  WARNING: You must *not* be at
   ! the end of file to use this routine, since it will try to read
   end

!  ===========================
!  Read VEC{T1}, VEC{T2} pairs
!  ===========================

   read_pair(v1,v2) ::: template
   ! Read in a pair of vectors sequentially, alternating. Line breaks
   ! are not significant.
      self :: INOUT
      v1 :: V1?, OUT
      v2 :: V2?, OUT

   ENSURE(v1.dim==v2.dim,"incompatible vectors")

      i :: INT

      do i = 1,v1.dim
         .read(v1(i))
         .read(v2(i))
      end

   end

   read_pair(v1,v2) ::: get_from(TEXTFILE, V1?=>VEC{INT}, V2?=>VEC{INT})
   ! Read in a pair of vectors sequentially, alternating. Line breaks
   ! are not significant.
   end

   read_pair(v1,v2) ::: get_from(TEXTFILE, V1?=>VEC{REAL}, V2?=>VEC{REAL})
   ! Read in a pair of vectors sequentially, alternating. Line breaks
   ! are not significant.
   end

!  Read VEC{T1}, VEC{T2}, VEC{T3} triples

   read_triple(v1,v2,v3) ::: template
   ! Read in a triple of vectors sequentially, alternating. Line
   ! breaks are not significant.
      self :: INOUT
      v1 :: V1?, OUT
      v2 :: V2?, OUT
      v3 :: V3?, OUT

   ENSURE(v1.dim==v2.dim,"incompatible vectors")
   ENSURE(v1.dim==v3.dim,"incompatible vectors")

      i :: INT

      do i = 1,v1.dim
         .read(v1(i))
         .read(v2(i))
         .read(v3(i))
      end

   end

   read_triple(v1,v2,v3) ::: get_from(TEXTFILE, V1?=>VEC{REAL}, V2?=>VEC{REAL}, V3?=>VEC{REAL})
   ! Read in a triple of vectors sequentially, alternating. Line
   ! breaks are not significant.
   end

!  ==============
!  Read MAT{TYPE}
!  ==============

   read(mx,by_column) ::: template
   ! Read in matrix "mx" by row. If "by_column" is present and TRUE it
   ! is read in sequentially by column. Line breaks not significant.
      self :: INOUT
      mx :: MX?, OUT
      by_column :: BIN, optional

      i,j :: INT
      read_by_column :: BIN

      ! Get input order
      read_by_column = FALSE
      if (present(by_column)) read_by_column = by_column

      ! Read by column or (default) by row
      if (read_by_column) then
         do j = 1,mx.dim2
         do i = 1,mx.dim1
            .read(mx(i,j))
         end
         end
      else
         do i = 1,mx.dim1
         do j = 1,mx.dim2
            .read(mx(i,j))
         end
         end
      end

   end

   read(mx,by_column) ::: get_from(TEXTFILE, MX?=>MAT{STR})
   ! Read in matrix "mx" by row. If "by_column" is present and TRUE it
   ! is read in sequentially by column. Line breaks not significant.
   end

   read(mx,by_column) ::: get_from(TEXTFILE, MX?=>MAT{BIN})
   ! Read in matrix "mx" by row. If "by_column" is present and TRUE it
   ! is read in sequentially by column. Line breaks not significant.
   end

   read(mx,by_column) ::: get_from(TEXTFILE, MX?=>MAT{INT})
   ! Read in matrix "mx" by row. If "by_column" is present and TRUE it
   ! is read in sequentially by column. Line breaks not significant.
   end

   read(mx,by_column) ::: get_from(TEXTFILE, MX?=>MAT{REAL})
   ! Read in matrix "mx" by row. If "by_column" is present and TRUE it
   ! is read in sequentially by column. Line breaks not significant.
   end

   read(mx,format,items_per_line)
   ! Read a formatted matrix "mx" with fortran "format" and a given
   ! number of "items_per_line". Extra line items are skipped!
     mx :: MAT{REAL}, OUT
     format :: STR, IN
     items_per_line :: INT, IN

     i,j,n :: INT

     .buffer.move_to_item(1)

     do i = 1,mx.dim1

        ! Read a row i
        n = 0
        do j = 1,mx.dim2
           .read(mx(i,j),format)
           n = n + 1
           if (n==items_per_line) exit
        end

        ! Next non-empty line
        do
           .read_line
           if (NOT .buffer.empty) exit
        end

     end

   end

   read(mx,by_column) ::: get_from(TEXTFILE, MX?=>MAT{CPX})
   ! Read in matrix "mx" by row. If "by_column" is present and TRUE it
   ! is read in sequentially by column. Line breaks not significant.
   end

!  ===============
!  Read MAT{TYPE}*
!  ===============

   get_mx_shape(dim) ::: private
   ! Returns dim(1) as the number of lines which are not blank, and
   ! dim(2) as the number of items per line between an opening and
   ! closing brace. It is an error if there are a different number of
   ! items per line on every non-blank line.
      self :: INOUT
      dim :: VEC{INT}(2), OUT

      line,item,first_line :: INT
      word :: STR
      dim1,dim2 :: INT

      ! Store initial position
      item = .next_line_item
      line = .line_number

      ! Opening brace?
      .read(word)
      ENSURE(word=="{","list does not begin with a {")

      ! Initialize
      dim1 = 0
      dim2 = 0
      dim = [dim1,dim2]

      ! First token. Return if closing brace
      .read(word)
      if (word == "}") return

      ! Line on which first item lies; at least one row
      first_line = .line_number
      dim1 = 1

      ! The number of columns; it shouldn't change
      dim2 = .n_line_items
      dim(2) = dim2

      ! Opening { is on the same line as first item
      if (first_line==line) dim2 = dim2 - 1

      ! Process all lines
      do

         ! Next line
         .skip_line

         ! Skip empty lines
         if (.n_line_items==0) cycle

         ! Exit if first item of next non-blank line
         ! is closing brace
         .read(word)
         if (word == "}") exit

         ! If not empty and not clsing brace, add another row
         dim1 = dim1 + 1
         dim2 = .n_line_items

         ! If non matching dim2, it must be a closing brace
         ! (if so, exit) it is an error if not the same
         if (dim2>dim(2)) then
            dim2 = dim(2)
            .move_to_line_item(dim2+1)
            DIE_IF(.next_item/="}","different number of line items on succesive lines")
            exit
         else
            DIE_IF(dim2/=dim(2),"different number of line items on succesive lines")
         end
      end

      ! Return to initial position
      .move_to_line(line)
      .move_to_line_item(item)

      ! Set the shape
      dim = [dim1,dim2]

   end

!
!   read_ptr(mx) ::: template
!   ! Read in a matrix pointer "mx" sequentially. The shape is
!   ! induced from the formatting. Line breaks are significant!
!      self :: INOUT
!      mx :: MX?*
!
!      word :: STR
!      dim :: VEC{INT}(2)
!
!      ! Get the shape
!      .get_mx_shape(dim)
!
!      ! Opening brace
!      .read(word)
!      ENSURE(word=="{","matrix does not begin with a {")
!
!      ! Read the matrix
!      mx.create(dim(1),dim(2))
!      .read(mx)
!
!      ! Closing brace
!      .read(word)
!      ENSURE(word=="}","expecting close bracket symbol: }")
!
!   end
!
!   read_ptr(mx) ::: get_from(TEXTFILE, MX?=>MAT{STR}), leaky
!   ! Read in a matrix pointer "mx" sequentially. The shape is
!   ! induced from the formatting. Line breaks are significant!
!   end
!
!   read_ptr(mx) ::: get_from(TEXTFILE, MX?=>MAT{BIN}), leaky
!   ! Read in a matrix pointer "mx" sequentially. The shape is
!   ! induced from the formatting. Line breaks are significant!
!   end
!
!   read_ptr(mx) ::: get_from(TEXTFILE, MX?=>MAT{INT}), leaky
!   ! Read in a matrix pointer "mx" sequentially. The shape is
!   ! induced from the formatting. Line breaks are significant!
!   end
!
!   read_ptr(mx) ::: get_from(TEXTFILE, MX?=>MAT{REAL}), leaky
!   ! Read in a matrix pointer "mx" sequentially. The shape is
!   ! induced from the formatting. Line breaks are significant!
!   end
!
!   read_ptr(mx) ::: get_from(TEXTFILE, MX?=>MAT{CPX}), leaky
!   ! Read in a matrix pointer "mx" sequentially. The shape is
!   ! induced from the formatting. Line breaks are significant!
!   end

!  ===============
!  Read MAT{TYPE}@
!  ===============

   read_all(mx) ::: template
   ! Read in a allocatable matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are significant!
      self :: INOUT
      mx :: MX?@, OUT

      word :: STR
      dim :: VEC{INT}(2)

      ! Get the shape
      .get_mx_shape(dim)

      ! Opening brace
      .read(word)
      ENSURE(word=="{","matrix does not begin with a {")

      ! Read the matrix
      mx.create(dim(1),dim(2))
      .read(mx)

      ! Closing brace
      .read(word)
      ENSURE(word=="}","expecting close bracket symbol: }")

   end

   read_all(mx) ::: get_from(TEXTFILE, MX?=>MAT{STR}), leaky
   ! Read in a allocatable matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are significant!
   end

   read_all(mx) ::: get_from(TEXTFILE, MX?=>MAT{BIN}), leaky
   ! Read in a allocatable matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are significant!
   end

   read_all(mx) ::: get_from(TEXTFILE, MX?=>MAT{INT}), leaky
   ! Read in a allocatable matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are significant!
   end

   read_all(mx) ::: get_from(TEXTFILE, MX?=>MAT{REAL}), leaky
   ! Read in a allocatable matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are significant!
   end

   read_all(mx) ::: get_from(TEXTFILE, MX?=>MAT{CPX}), leaky
   ! Read in a allocatable matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are significant!
   end

!  =====================
!  Read VEC{EVEC{TYPE}}@
!  =====================

   read(v) ::: template
   ! Read in an VEC{EVEC{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
      self :: INOUT
      v :: V?, OUT

      i :: INT

      do i = 1,v.dim
         .read_all(v(i).element)
      end

   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{EVEC{INT}}), leaky
   ! Read in an VEC{EVEC{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{EVEC{REAL}}), leaky
   ! Read in an VEC{EVEC{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end


   list_list_length_all result (res) ::: leaky, private
   ! Return the size of an VEC{EVEC{INT}} list, by reading the input
   ! until an end bracket "}" token is found. Line breaks are not
   ! significant.
      self :: INOUT
      res :: INT

      line,item :: INT
      word :: STR
      v :: VEC{STR}@

      ! Store original pos
      line = .line_number
      item = .next_line_item

      ! Read opening brace
      .read(word)
      ENSURE(word=="{","list does not begin with {")

      ! Count enclosed lists
      res = 0
      do
         .read(word)
         if (word=="}") exit
         .move_to_previous_item
         .read_all(v)
         v.destroy
         res = res + 1
      end

      ! Reinstate original position
      .move_to_line(line)
      .move_to_line_item(item)

   end


   read_all(v) ::: template
   ! Read in a VEC{EVEC{TYPE}}@ "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
      self :: INOUT
      v :: V?@, OUT

      word :: STR
      dim :: INT

      ! Find out the list length
      dim = .list_list_length_all
      v.create(dim)

      ! Read opening brace
      .read(word)
      ENSURE(word=="{","list does not begin with a {")

      ! Read vector
      .read(v)

      ! Read closing brace
      .read(word)
      ENSURE(word=="}","list does not end with a {")

   end

   read_all(v) ::: get_from(TEXTFILE, V?=>VEC{EVEC{INT}}), leaky
   ! Read in a VEC{EVEC{TYPE}}@ "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

   read_all(v) ::: get_from(TEXTFILE, V?=>VEC{EVEC{REAL}}), leaky
   ! Read in a VEC{EVEC{TYPE}}@ "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

!  ====================
!  Read VEC{EMAT{TYPE}}
!  ====================

   read(v) ::: template
   ! Read in an VEC{EMAT{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
      self :: INOUT
      v :: V?, OUT

      i :: INT

      do i = 1,v.dim
         .read_all(v(i).element)
      end

   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{EMAT{INT}}), leaky
   ! Read in an VEC{EMAT{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

   read(v) ::: get_from(TEXTFILE, V?=>VEC{EMAT{REAL}}), leaky
   ! Read in an VEC{EMAT{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

!  ===============
!  Read MAT3{TYPE}
!  ===============

   read(mx) ::: template
   ! Read a MAT3{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
      self :: INOUT
      mx :: MX?, OUT

      i1,i2,i3, j1,j2,j3 :: INT

      do i1 = 1,mx.dim1
      do i2 = 1,mx.dim2
      do i3 = 1,mx.dim3
         .read(j1)
         .read(j2)
         .read(j3)
         .read(mx(j1,j2,j3))
      end
      end
      end

   end

   read(mx) ::: get_from(TEXTFILE, MX?=>MAT3{REAL})
   ! Read a MAT3{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

   read(mx) ::: get_from(TEXTFILE, MX?=>MAT3{CPX})
   ! Read a MAT3{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

!  ===============
!  Read MAT4{TYPE}
!  ===============

   read(mx) ::: template
   ! Read a MAT4{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
      self :: INOUT
      mx :: MX?, OUT

      i1,i2,i3,i4, j1,j2,j3,j4 :: INT

      do i1 = 1,mx.dim1
      do i2 = 1,mx.dim2
      do i3 = 1,mx.dim3
      do i4 = 1,mx.dim4
         .read(j1)
         .read(j2)
         .read(j3)
         .read(j4)
         .read(mx(j1,j2,j3,j4))
      end
      end
      end
      end

   end

   read(mx) ::: get_from(TEXTFILE, MX?=>MAT4{REAL})
   ! Read a MAT4{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

   read(mx) ::: get_from(TEXTFILE, MX?=>MAT4{CPX})
   ! Read a MAT4{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

!  ===============
!  Read MAT5{TYPE}
!  ===============

   read(mx) ::: template
   ! Read a MAT5{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
      self :: INOUT
      mx :: MX?, OUT

      i1,i2,i3,i4,i5, j1,j2,j3,j4,j5 :: INT

      do i1 = 1,mx.dim1
      do i2 = 1,mx.dim2
      do i3 = 1,mx.dim3
      do i4 = 1,mx.dim4
      do i5 = 1,mx.dim5
         .read(j1)
         .read(j2)
         .read(j3)
         .read(j4)
         .read(j5)
         .read(mx(j1,j2,j3,j4,j5))
      end
      end
      end
      end
      end

   end

   read(mx) ::: get_from(TEXTFILE, MX?=>MAT5{REAL})
   ! Read a MAT5{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

   read(mx) ::: get_from(TEXTFILE, MX?=>MAT5{CPX})
   ! Read a MAT5{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

!  ==========================
!  Read OPVECTOR and OPMATRIX
!  ==========================

   read(v,genre) ::: leaky
   ! Read OPVECTOR "v"
      self :: INOUT
      v :: OPVECTOR, INOUT
      genre :: STR, optional, IN

      vgenre :: STR

      if (present(genre)) then; vgenre = genre
      else;                     vgenre = v.genre
      end

      select case (vgenre)

      case ("r ")
         v.destroy("r ")
         v.create("r ")
         .look_for("Restricted part:",from=1)
         .read_line
         .read(v.r)

      case ("u ")
         v.destroy("u ")
         v.create("u ")
         .look_for("Alpha part:",from=1)
         .read_line
         .read(v.a)
         .look_for("Beta part:",from=1)
         .read_line
         .read(v.b)

      case default
         DIE("unknown genre, "//trim(vgenre))

      end

   end

   read(mx,genre,by_column) ::: leaky
   ! Read OPMATRIX "mx".
      self :: INOUT
      mx :: OPMATRIX, INOUT
      genre :: STR, optional, IN
      by_column :: BIN, optional, IN

      mxgenre :: STR

      if (present(genre)) then; mxgenre = genre
      else;                     mxgenre = mx.genre
      end

      select case (mxgenre)

      case ("r ")
         mx.destroy("r ")
         mx.create("r ")
         .look_for("Restricted part:")
         .read_line
         .read(mx.r,by_column)

      case ("u ")
         mx.destroy("u ")
         mx.create("u ")
         .look_for("Alpha part:")
         .read_line
         .read(mx.a,by_column)
         .look_for("Beta part:")
         .read_line
         .read(mx.b, by_column)

      case ("gc")
         mx.destroy("gc")
         mx.create("gc")
         .look_for("General complex part:")
         .read_line
         .read(mx.gc,by_column)

      case default
         DIE("unknown genre, "//trim(mxgenre))

      end

   end

!  ===============
!  Output routines
!  ===============

!  Clearing, flushing, tabbing, dashing & plain text line

   clear_and_put_margin ::: PURE
   ! Clear the buffer and put a margin in
      self :: INOUT

       .buffer.clear

       if (.style.margin_width==0) return
       if (.buffer.item_start>0)   return

       .buffer.put(repeat(" ",.style.margin_width))

   end

!  This important routine actually writes to the file

   flush
   ! Flush the buffer to the output file
      self :: INOUT

   ENSURE(.action=="write","file does not have write action!")

      ! Write the buffer.string
      .IO_status = 0
      if (IO_IS_ALLOWED) then
         ENSURE(.is_open_io,"file "//trim(.name)//" is not open!")
         write(unit=.unit,iostat=.IO_status,fmt="(a)") trim(.buffer.string)
         DIE_IF(.IO_status>0,"flush error")
         TONTO_FLUSH_BUFFER(.unit)
         .clear_and_put_margin
         .record = .record + 1
      end

      ! Failure?
      PARALLEL_BROADCAST(.IO_status,tonto.master_processor)
      PARALLEL_BROADCAST(.record,tonto.master_processor)
      DIE_IF(.IO_status>0,"flush error")

      ! Flush - seems to cause problems with MPI
   !  TONTO_FLUSH_BUFFER(.unit)

      ! Write margin
      .clear_and_put_margin

   end

   flush(times)
   ! Flush the buffer multiple times to get extra carriage returns
     self :: INOUT
     times :: INT, IN

     i :: INT

     do i = 1,times
        .flush
     end

   end

   tab(real_fields,int_fields,bin_fields,width)
   ! Tab across the specified number of fields in the output buffer
   ! "real_fields", "int_fields" and "bin_fields" refer to the number of
   ! real, integer and logical fields to tab; "width" is the width of spaces
   ! to tab.
      self :: INOUT
      real_fields :: INT, optional, IN
      int_fields :: INT, optional, IN
      bin_fields :: INT, optional, IN
      width :: INT, optional, IN

      if (present(real_fields)) .buffer.put(repeat(repeat(" ",.style.real_width),real_fields))
      if (present( int_fields)) .buffer.put(repeat(repeat(" ",.style.int_width) , int_fields))
      if (present( bin_fields)) .buffer.put(repeat(repeat(" ",.style.int_width) , bin_fields))
      if (present(width))       .buffer.put(repeat(" ",width))

   end

   dash(symbol,real_fields,int_fields,bin_fields,width)
   ! Put a dashed line into the buffer. "real_fields", "int_fields" and
   ! "bin_fields" refer to the number of real, integer and logical fields
   ! to draw the line over; "width" is the width of characters to draw the
   ! dashed line.
      self :: INOUT
      symbol :: STR(len=1), optional, IN
      real_fields :: INT, optional, IN
      int_fields :: INT, optional, IN
      bin_fields :: INT, optional, IN
      width :: INT, optional, IN

      dsh :: STR(len=1)

      dsh = "-"
      if (present(symbol)) dsh = symbol

      if (present(real_fields)) .buffer.put(repeat(dsh,.style.real_width*real_fields))
      if (present( int_fields)) .buffer.put(repeat(dsh,.style.int_width *int_fields))
      if (present( bin_fields)) .buffer.put(repeat(dsh,.style.int_width *bin_fields))
      if (present(width))       .buffer.put(repeat(dsh,width))

      .flush

   end

   text(string,real_width,int_width,flush)
   ! Put text into the output buffer as is and flush, unless
   ! flush is present and FALSE. You can specify widths too.
      self :: INOUT
      string :: STR, IN
      real_width :: BIN, optional, IN
      int_width :: BIN, optional, IN
      flush :: BIN, optional, IN

      int_string  :: STR(len=.style.int_width)
      real_string :: STR(len=.style.real_width)
      use_real_width,use_int_width,do_flush :: BIN

      use_real_width = FALSE
      if (present(real_width)) use_real_width = real_width

      use_int_width = FALSE
      if (present(int_width)) use_int_width = int_width

      do_flush = TRUE
      if (present(flush)) do_flush = flush

      if (use_real_width AND len(string)<=.style.real_width) then
         real_string = string
         .buffer.put(real_string)
      else if (use_int_width AND len(string)<=.style.int_width) then
         int_string = string
         .buffer.put(int_string)
      else
         .buffer.put(string)
      end

      if (do_flush) .flush

   end

!  ===========================
!  Put TYPE methods (no flush)
!  ===========================

!  Most everything is converted to a string and put into the buffer,
!  so comes through the important routine below, which is quite slow.

   put(string,left,center,int_width,width,blank)
   ! Put a "string" into the output buffer; if it is too big, put as is.
   ! NOTE: Head space is never altered, but trailing spaces are trimmed.
   ! . "left" ........ left justifies output         (default: right justified)
   ! . "center" ...... centers the output            (overrides "left")
   ! . "int_width" ... field width set to .int_width (default: .real_width)
   ! . "width" ....... sets field width in chars     (overrides "int_width")
   ! . "blank" ....... sets the field to be blank    (overrides everything)
      self :: INOUT
      string :: STR, IN
      left :: BIN, optional, IN
      center :: BIN, optional, IN
      int_width :: BIN, optional, IN
      width :: INT, optional, IN
      blank :: BIN, optional, IN

      tmpcpy :: STR
      wid,len :: INT
      leftify,centrify,blnk :: BIN

      if (NOT .style.using_fields) then

         ! Put string as is, separated by a space
         ! Head space preserved, trailing space trimmed
         if (.buffer.item_end==0) then; .buffer.put(trim(string))
         else;                          .buffer.put(" "//trim(string))
         end

      else

         ! Get the field width
         wid = .style.real_width
         if (present(int_width)) then
         if (int_width) then
            wid = .style.int_width
         end
         end
         if (present(width)) wid = width

         ! Whether to left-justify
         leftify = FALSE
         if (present(left)) leftify = left

         ! Whether to center
         centrify = FALSE
         if (present(center)) centrify = center

         ! Blank?
         blnk = FALSE
         if (present(blank)) then
         if (blank) then
            blnk = blank
         end
         end

         ! Sanity check
         DIE_IF(leftify AND centrify,"too many justifications")

         ! The actual string lenth
         len = len_trim(string)

         if (blnk) then

            ! Fill the field with a blank of withd "width"
            .buffer.put(repeat(" ",wid))

         else if (len>wid) then

            ! If string too long, just put it in, with a space in
            ! front (unless it is the first item).
            if (.buffer.item_end==0) then; .buffer.put(trim(string))
            else;                          .buffer.put(" "//trim(string))
            end

         else if (len==wid) then

            if (present(width)) then

               ! If it just fits, and the user specified the character
               ! width, put it in just as the user wanted
               .buffer.put(trim(string))

            else

               ! If it just fits, and the user didn't specify width,
               ! put it in with a spacer in front
               .buffer.put(" "//trim(string))

            end

         else if (centrify) then

            ! Centered
            tmpcpy = string
            tmpcpy(1:wid).center_justify
            .buffer.put(tmpcpy(1:wid))

         else

            ! Finally: put it in with the specified width
            ! This works for blanks too ...
            .buffer.put(string.to_str(wid,leftify))

         end

      end

   end

   put(value,left,center,real_width,width,blank) ::: template
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! . "real_width" sets width to .real_width (default width is .int_width)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
   ! . "blank" ....... sets the field to be blank  (overrides everything)
      self :: INOUT
      value :: VALUE?, IN
      left :: BIN, optional, IN
      center :: BIN, optional, IN
      real_width :: BIN, optional, IN
      width :: INT, optional, IN
      blank :: BIN, optional, IN

      int_width :: BIN

      int_width = TRUE
      if (present(real_width)) int_width = NOT real_width

      ! Change to string, and put it out
      .put(value.to_str,left,center,int_width,width,blank)

   end

   put(value,left,center,real_width,width,blank) ::: get_from(TEXTFILE:put, VALUE?=>BIN)
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! . "real_width" sets width to .real_width (default width is .int_width)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
   ! . "blank" ....... sets the field to be blank  (overrides everything)
   end

   put(value,left,center,real_width,width,blank) ::: get_from(TEXTFILE:put, VALUE?=>INT)
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! . "real_width" sets width to .real_width (default width is .int_width)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
   ! . "blank" ....... sets the field to be blank  (overrides everything)
   end

   put_bit_string(value,left,center,int_width,width,blank)
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "int_width" sets width to .int_width (default width is .real_width)
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
   ! . "blank" ....... sets the field to be blank  (overrides everything)
      self :: INOUT
      value :: INT, IN
      left :: BIN, IN, optional
      center :: BIN, IN, optional
      int_width :: BIN, IN, optional
      width :: INT, IN, optional
      blank :: BIN, optional, IN

      ! Change to string, and put it out
      .put(value.to_bit_string,left,center,int_width,width,blank)

   end

!  ==============
!  Put REAL & CPX
!  ==============

   put(value,left,center,int_width,fmt,width,precision) ::: template
   ! Put a real or complex "value" into the output buffer.
   ! If present and TRUE:
   ! . "left"   will left justify the string  (default: right-justified)
   ! . "center" will center the string        (default: left-justified)
   ! . "int_width" sets width to .int_width   (default: .real_width)
   ! If present:
   ! . "fmt"   sets the fortran fmt           (default: .real_fortran_fmt)
   ! . "width" sets the field_width           (default: .real_width)
   ! . "precision" sets the precision         (default: .real_precision)
      self :: INOUT
      value     :: VALUE?, IN
      left      :: BIN, IN, optional
      center    :: BIN, IN, optional
      int_width :: BIN, IN, optional
      fmt       :: STR, IN, optional
      width     :: INT, IN, optional
      precision :: INT, IN, optional

      sty :: STR
      wid0,wid,pre,nf :: INT

      ! Defaults
      sty = .style.real_fortran_fmt
      wid = .style.real_width
      pre = .style.real_precision

      ! Set int_width option
      if (present(int_width)) then
      if (int_width) then
         wid = .style.int_width
         pre = 3
      end
      end

      ! Sensible width
      wid0 = wid

      ! Set options
      if (present(fmt))       sty = fmt
      if (present(width))     wid = width
      if (present(precision)) pre = precision

      ! Sensible width
      if (wid>0) wid0 = wid


      ! Change to string, and put it out
      nf = value.no_of_fields_per_value
      .put(value.to_str(sty,wid0,pre,left),left,center,FALSE,width=nf*wid)

   end

   put(value,left,center,int_width,fmt,width,precision) ::: get_from(TEXTFILE, VALUE?=>REAL)
   ! Put a real or complex "value" into the output buffer.
   ! If present and TRUE:
   ! . "left"   will left justify the string  (default: right-justified)
   ! . "center" will center the string        (default: left-justified)
   ! . "int_width" sets width to .int_width   (default: .real_width)
   ! If present:
   ! . "fmt"   sets the fortran fmt           (default: .real_fortran_fmt)
   ! . "width" sets the field_width           (default: .real_width)
   ! . "precision" sets the precision         (default: .real_precision)
   end

   put(value,left,center,int_width,fmt,width,precision) ::: get_from(TEXTFILE, VALUE?=>CPX)
   ! Put a real or complex "value" into the output buffer.
   ! If present and TRUE:
   ! . "left"   will left justify the string  (default: right-justified)
   ! . "center" will center the string        (default: left-justified)
   ! . "int_width" sets width to .int_width   (default: .real_width)
   ! If present:
   ! . "fmt"   sets the fortran fmt           (default: .real_fortran_fmt)
   ! . "width" sets the field_width           (default: .real_width)
   ! . "precision" sets the precision         (default: .real_precision)
   end

!  ==============================
!  Put imprecise REAL(WITH_ERROR)
!  ==============================

   put(value,error,int_width,width,precision,max_cb,two_digit_error)
   ! Put a real "value" into the output buffer which has "error".
   ! You can specify the "width" (defualt .real_width) or the
   ! maximum "precision". The decimal points are lined up.
   ! WARNING: Make sure the error is larger than the precision!
      self  :: INOUT
      value :: REAL, IN
      error :: REAL, IN
      int_width :: BIN, optional, IN
      width :: INT, optional, IN
      precision :: INT, optional, IN
      max_cb :: INT, optional, IN
      two_digit_error :: BIN, optional, IN

      wid,pre :: INT
      valstr :: STR

      ! Defaults
      wid = .style.real_width
      pre = .style.real_precision

      ! Set int_width option
      if (present(int_width)) then
      if (int_width) then
         wid = .style.int_width
         pre = 3
      end
      end

      ! Set options
      if (present(width))     wid = width
      if (present(precision)) pre = precision

      ! Change to string, put out like 1.002(19)
      value.get_str(valstr(1:wid),error,wid,pre,max_cb,two_digit_error) ! aligned
      .buffer.put(valstr(1:wid))

   end

!  =============
!  Put VEC{TYPE}
!  =============

   put(v,by_row,by_column,left,width,auto_width) ::: template
   ! Put VEC{TYPE} into the output buffer
      self :: INOUT
      v :: V?, IN
      by_row :: BIN, optional, IN
      by_column :: BIN, optional, IN
      left :: BIN, optional, IN
      width :: INT, optional, IN
      auto_width :: BIN, optional, IN

   ENSURE(NOT (present(by_row) AND present(by_column)),"row and column options present!")

      i,dim, iwid,rwid,nfpv, block,n_block,fields,f,l :: INT
      column,auto :: BIN

      ! Vector length
      dim = v.dim
      WARN_IF(dim==0,"zero sized dimension!")

      ! Extract options
      column = TRUE
      if (present(by_row))    column = NOT by_row
      if (present(by_column)) column = by_column

      iwid = dim.str_length + .style.spacing
      rwid = .style.real_width
      if (present(width)) rwid = width
      nfpv = v(1).no_of_fields_per_value

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides width
      if (auto) v.get_max_str_length(rwid ARG?,.style.spacing)

      if (column) then

         ! Put vector "v" as vertical column
         if (.style.using_array_labels) then

            ! With labels
            do i = 1,dim
               .put(i,left,width=nfpv*iwid)
               .put(v(i),left,width=rwid)
               .flush
            end

         else

            ! No labels
            do i = 1,dim
               .put(v(i),left,width=rwid)
               .flush
            end

         end

      else

         fields = .style.n_fields_per_line
         if (fields==0) fields = dim
         n_block = int((dim-0.1)/fields) + 1

         ! Put vector "v" as horizontal row
         if (.style.using_array_labels) then

            ! Use labels
            do block = 1,n_block
               f = 1 + fields*(block-1)
               l = min(f+fields-1,dim)
               if (block>1) .flush
               do i = f,l
                  .put(i,left,width=nfpv*rwid)
               end
               .flush(2)
               do i = f,l
                  .put(v(i),left,width=rwid)
               end
               .flush
            end

         else

            ! NO labels
            do block = 1,n_block
               f = 1 + fields*(block-1)
               l = min(f+fields-1,dim)
               if (block>1) .flush
               do i = f,l
                  .put(v(i),left,width=rwid)
               end
            end
            .flush

         end

      end

   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, V?=>VEC{STR}, ARG?=>)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, V?=>VEC{BIN}, ARG?=>)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, V?=>VEC{INT}, ARG?=>)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, V?=>VEC{REAL}, ARG?=>,.style.real_precision)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, V?=>VEC{CPX}, ARG?=>,.style.real_precision)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,row_label,col_label,left) ::: template
   ! Put VEC{TYPE} into output as column, with "row_labels" and a
   ! single "col_label".
      self :: INOUT
      v :: V?, IN
      row_label :: VEC{STR}, IN
      col_label :: STR, IN
      left :: BIN, IN, optional

      wid,widc,widr, i :: INT

      ! Warning ...
      WARN_IF(v.dim==0,"zero sized dimensiont!")

      ! Get the width
      row_label.get_max_str_length(widr,.style.spacing)
      col_label.get_str_length(widc,spaces=0)
      wid  = max(widr,widc,.style.real_width)

      ! Tab column width & put column label
      .tab(width=wid)
      .put(col_label,left,width=wid)
      .flush(2)

      ! Put vector "v" as vertical column
      do i = 1,v.dim
         .put(row_label(i),left,width=wid)
         .put(v(i),left,width=wid)
         .flush
      end

   end

   put(v,row_label,col_label,left) ::: get_from(TEXTFILE), V?=>VEC{REAL})
   ! Put VEC{TYPE} into output as column, with "row_labels" and a
   ! single "col_label".
   end

!  These routines avoid the buffer.string and output directly to the file.

   parallel_put(v)
   ! Parallel put VEC{INT} "v" directly into the output file.
      self :: INOUT
      v :: VEC{INT}, IN

      i :: INT
      fmt :: STR

      ! One element per line
      fmt = .int_format(n_fields=1 &
                       ,width   =2*.style.int_width &
                       ,with_parenthesis=TRUE)

      ! Write the array
      do i = 1,v.dim
         write(unit=.unit,fmt=fmt) v(i)
         .increment_record
      end

   end

   parallel_put(v)
   ! Parallel put VEC{INT} "v" directly into the output file.
      self :: INOUT
      v :: VEC{REAL}, IN

      i :: INT
      fmt :: STR

      ! One element per line
      fmt = .real_format(n_fields =1 &
                        ,width    =2*.style.real_width &
                        ,precision=2*.style.real_precision &
                        ,with_parenthesis=TRUE)

      ! Write the array
      do i = 1,v.dim
         write(unit=.unit,fmt=fmt) v(i)
         .increment_record
      end

   end

   parallel_put(v)
   ! Parallel put VEC{INT} "v" directly into the output file.
      self :: INOUT
      v :: VEC{CPX}, IN

      i :: INT
      fmt :: STR

      ! One element per line
      fmt = .real_format(n_fields =2 &
                        ,width    =2*.style.real_width &
                        ,precision=2*.style.real_precision &
                        ,with_parenthesis=TRUE)

      ! Write the array
      do i = 1,v.dim
         write(unit=.unit,fmt=fmt) v(i)
         .increment_record
      end

   end

!  =============
!  Put MAT{TYPE}
!  =============

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: template
   ! Put MAT{TYPE} into the output buffer
      self :: INOUT
      mx :: MX?, IN
      by_row :: BIN, IN, optional
      by_column :: BIN, IN, optional
      transpose :: BIN, IN, optional
      left :: BIN, IN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

   ENSURE(NOT (present(by_row) AND present(by_column)),"row and column options present!")

      row,column,trans,auto :: BIN
      i,j,dim1,dim2,maxdim, iwid,rwid,nfpv, block,n_block,fields,f,l :: INT

      ! Dimensions
      WARN_IF(any(shape(mx)==0),"zero sized dimensions present!")
      dim1 = mx.dim1
      dim2 = mx.dim2

      ! Extract options
      row = FALSE
      if (present(by_row)) row = by_row

      column = FALSE
      if (present(by_column)) column = by_column

      trans = FALSE
      if (present(transpose)) trans = transpose

      ! Width
      maxdim = max(dim1,dim2)
      iwid   = maxdim.str_length + .style.spacing
      rwid   = .style.real_width
      if (present(width)) rwid = width
      nfpv   = mx(1,1).no_of_fields_per_value

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides real_width
      if (auto) mx.get_max_str_length(rwid ARG?,.style.spacing)

      ! No of fields per line
      fields = .style.n_fields_per_line

      if (column) then

         ! Put columns as rows, new line for new column
         ! ... if needed
         if (fields==0) fields = dim1
         do j = 1,dim2
            do i = 1,dim1
               .put(mx(i,j),left,width=rwid)
               if(mod(i,fields)==0) .flush
            end
            if(mod(i,fields)/=0) .flush
         end

      else if (row) then

         ! Put as rows, new line for new row
         if (fields==0) fields = dim2
         do i = 1,dim1
            do j = 1,dim2
               .put(mx(i,j),left,width=rwid)
               if(mod(j,fields)==0) .flush
            end
            if(mod(j,fields)/=0) .flush
         end

      else

         if (NOT trans) then ! NO TRANSPOSE

            if (NOT .style.using_fields) then

               do i = 1,dim1
                  do j = 1,dim2
                     .put(mx(i,j),left,width=rwid)
                  end
                  .flush
               end

            else

               if (fields==0) fields = dim2
               n_block = int((dim2-0.1)/fields) + 1

               if (.style.using_array_labels) then

                  ! Put in row & column labels
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim2)
                     if (block>1) .flush
                     .tab(width=iwid)
                     do j = f,l
                        .put(j,left,width=nfpv*rwid)
                     end
                     .flush(2)
                     do i = 1,dim1
                        .put(i,left,width=iwid)
                        do j = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end

               else

                  ! NO row & column labels
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim2)
                     if (block>1) .flush
                     do i = 1,dim1
                        .tab(width=iwid)
                        do j = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end

               end

            end

         else ! TRANSPOSE

            if (NOT .style.using_fields) then

               do j = 1,dim2
                  do i = 1,dim1
                     .put(mx(i,j),left,width=rwid)
                  end
                  .flush
               end

            else

               if (fields==0) fields = dim1
               n_block = int((dim1-0.1)/fields) + 1

               if (.style.using_array_labels) then

                  ! Put in row & column labels
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim1)
                     if (block>1) .flush
                     .tab(width=iwid)
                     do i = f,l
                        .put(i,left,width=nfpv*rwid)
                     end
                     .flush(2)
                     do j = 1,dim2
                        .put(j,left,width=iwid)
                        do i = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end

               else

                  ! NO row & column labels
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim1)
                     if (block>1) .flush
                     do j = 1,dim2
                        .tab(int_fields=1)
                        do i = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end

               end

            end

         end

      end

   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT{STR}, ARG?=>)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT{BIN}, ARG?=>)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT{INT}, ARG?=>)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT{REAL}, ARG?=>,.style.real_precision)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT{CPX}, ARG?=>,.style.real_precision)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,row_label,col_label,left) ::: template
   ! Put MAT{TYPE} into output with "row_labels" and "column_labels"
      self :: INOUT
      mx :: MX?, IN
      row_label :: VEC{STR}, IN
      col_label :: VEC{STR}, IN
      left :: BIN, IN, optional

      wid,widc,widr, i,j,block,n_block,fields,f,l :: INT

      ! Warning ...
      WARN_IF(any(shape(mx)==0),"zero sized dimensions present!")

      ! Get the width
      row_label.get_max_str_length(widr,.style.spacing)
      col_label.get_max_str_length(widc,.style.spacing)
      wid  = max(widr,widc,.style.real_width)

      ! No of fields per line
      fields = .style.n_fields_per_line
      if (fields==0) fields = mx.dim2

      ! No of matrix column-blocks
      n_block = int((fields-0.1)/fields) + 1

      ! Put in (row and column-labeled) column-blocks
      l = 0
      do block = 1,n_block

         ! First and last columns
         f = l + 1
         l = min(l+fields,mx.dim2)

         ! New block requires new line
         if (block>1) .flush

         ! Tab column width
         .tab(width=wid)

         ! Column labels
         do j = f,l
            .put(col_label(j),left,width=wid)
         end
         .flush(2)

         ! The rows of the matrix
         do i = 1,mx.dim1

            ! The row label
            .put(row_label(i),left,width=wid)

            ! The row of the matrix
            do j = f,l
               .put(mx(i,j),left,width=wid)
            end
            .flush

         end

      end

   end

   put(mx,row_label,col_label,left) ::: get_from(TEXTFILE, MX?=>MAT{REAL})
   ! Put MAT{TYPE} into output with "row_labels" and "column_labels"
   end

!  These routines avoid the buffer.string and output directly to the file.

   parallel_put(mx)
   ! Parallel put MAT{INT} "mx" directly into the output file.
   ! Column order assumed.
      self :: INOUT
      mx :: MAT{INT}, IN

      i,j :: INT
      fmt :: STR

      ! One element per line
      fmt = .int_format(n_fields=1 &
                       ,width   =2*.style.int_width &
                       ,with_parenthesis=TRUE)

      ! Write the array
      do j = 1,mx.dim2
      do i = 1,mx.dim1
         write(unit=.unit,fmt=fmt) mx(i,j)
         .increment_record
      end
      end

   end

   parallel_put(mx)
   ! Parallel put MAT{REAL} "mx" directly into the output file.
   ! Column order assumed.
      self :: INOUT
      mx :: MAT{REAL}, IN

      i,j :: INT
      fmt :: STR

      ! One element per line
      fmt = .real_format(n_fields =1 &
                        ,width    =2*.style.real_width &
                        ,precision=2*.style.real_precision &
                        ,with_parenthesis=TRUE)

      ! Write the array
      do j = 1,mx.dim2
      do i = 1,mx.dim1
         write(unit=.unit,fmt=fmt) mx(i,j)
         .increment_record
      end
      end

   end

   parallel_put(mx)
   ! Parallel put MAT{CPX} "mx" directly into the output file.
   ! Column order assumed.
      self :: INOUT
      mx :: MAT{CPX}, IN

      i,j :: INT
      fmt :: STR

      ! One element per line
      fmt = .real_format(n_fields =2 &
                        ,width    =2*.style.real_width &
                        ,precision=2*.style.real_precision &
                        ,with_parenthesis=TRUE)

      ! Write the array
      do j = 1,mx.dim2
      do i = 1,mx.dim1
         write(unit=.unit,fmt=fmt) mx(i,j)
         .increment_record
      end
      end

   end

!  ==============
!  Put MAT3{TYPE}
!  ==============

   put(mx,by_dim3_matrices,width,auto_width) ::: template
   ! Put a MAT3{TYPE} into the output buffer flat style
      mx :: MX?, IN
      by_dim3_matrices :: BIN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

      dim1,dim2,dim3,maxdim,rwid,iwid,i1,i2,i3 :: INT
      by_d3_matrices,auto :: BIN

      ! Dimensions
      WARN_IF(any(shape(mx)==0),"zero sized dimensions present!")
      dim1 = mx.dim1
      dim2 = mx.dim2
      dim3 = mx.dim3

      ! Extract options
      by_d3_matrices = FALSE
      if (present(by_dim3_matrices)) by_d3_matrices = by_dim3_matrices

      ! Width
      maxdim = max(dim1,dim2,dim3)
      iwid   = maxdim.str_length + .style.spacing
      rwid   = .style.real_width
      if (present(width)) rwid = width

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides width
      if (auto) mx.get_max_str_length(rwid ARG?,.style.spacing)

      if (by_d3_matrices) then

         do i3 = 1,dim3
         do i2 = 1,dim2
         do i1 = 1,dim1
            .put(i1,width=iwid)
            .put(i2,width=iwid)
            .put(i3,width=iwid)
            .put(mx(i1,i2,i3),width=rwid)
            .flush
         end
         end
         end

      else

         do i3 = 1,dim3
            stdout.flush
            stdout.show("matrix =",i3)
            stdout.flush
            .put(mx(:,:,i3),width=rwid)
         end

      end

   end

   put(mx,by_dim3_matrices,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT3{INT}, ARG?=>)
   ! Put a MAT3{TYPE} into the output buffer flat style
   end

   put(mx,by_dim3_matrices,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT3{REAL}, ARG?=>,.style.real_precision)
   ! Put a MAT3{TYPE} into the output buffer flat style
   end

   put(mx,by_dim3_matrices,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT3{CPX}, ARG?=>,.style.real_precision)
   ! Put a MAT3{TYPE} into the output buffer flat style
   end

!  ==============
!  Put MAT4{TYPE}
!  ==============

   put(mx,by_matrices,width,auto_width) ::: template
   ! Put a MAT4{TYPE} into the output buffer
      self :: INOUT
      mx :: MX?, IN
      by_matrices :: BIN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

      dim1,dim2,dim3,dim4,maxdim,rwid,iwid,i1,i2,i3,i4 :: INT
      do_matrices,auto :: BIN

      ! Dimensions
      WARN_IF(any(shape(mx)==0),"zero sized dimensions present!")
      dim1 = mx.dim1
      dim2 = mx.dim2
      dim3 = mx.dim3
      dim4 = mx.dim4

      ! Extract options
      do_matrices = TRUE
      if (present(by_matrices)) do_matrices = by_matrices

      ! Width
      maxdim = max(dim1,dim2,dim3,dim4)
      iwid   = maxdim.str_length + .style.spacing
      rwid   = .style.real_width
      if (present(width)) rwid = width

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides width
      if (auto) mx.get_max_str_length(rwid ARG?,.style.spacing)

      if (do_matrices) then

         do i4 = 1,dim4
         do i3 = 1,dim3
            stdout.flush
            stdout.text("matrix = (:,:,"//trim(i3.to_str)//","//trim(i4.to_str)//")")
            stdout.flush
            .put(mx(:,:,i3,i4),width=rwid)
         end
         end

      else

         do i4 = 1,dim4
         do i3 = 1,dim3
         do i2 = 1,dim2
         do i1 = 1,dim1
            .put(i1,width=iwid)
            .put(i2,width=iwid)
            .put(i3,width=iwid)
            .put(i4,width=iwid)
            .put(mx(i1,i2,i3,i4),width=rwid)
            .flush
         end
         end
         end
         end

      end

   end

   put(mx,by_matrices,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT4{INT}, ARG?=>)
   ! Put a MAT4{TYPE} into the output buffer
   end

   put(mx,by_matrices,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT4{REAL}, ARG?=>,.style.real_precision)
   ! Put a MAT4{TYPE} into the output buffer
   end

   put(mx,by_matrices,width,auto_width) ::: get_from(TEXTFILE, MX?=>MAT4{CPX}, ARG?=>,.style.real_precision)
   ! Put a MAT4{TYPE} into the output buffer
   end

!  ==============
!  Put MAT5{TYPE}
!  ==============

   put(mx) ::: template
   ! Put a MAT5{TYPE} into the output buffer flat style
      self :: INOUT
      mx :: MX?, IN

      i1,i2,i3,i4,i5 :: INT

   WARN_IF(any(shape(mx)==0),"there are zero sized dimensions")

      do i5 = 1,mx.dim5
      do i4 = 1,mx.dim4
      do i3 = 1,mx.dim3
      do i2 = 1,mx.dim2
      do i1 = 1,mx.dim1
         .put(i1)
         .put(i2)
         .put(i3)
         .put(i4)
         .put(i5)
         .put(mx(i1,i2,i3,i4,i5))
         .flush
      end
      end
      end
      end
      end

   end

   put(mx) ::: get_from(TEXTFILE, MX?=>MAT5{INT})
   ! Put a MAT5{TYPE} into the output buffer flat style
   end

   put(mx) ::: get_from(TEXTFILE, MX?=>MAT5{REAL})
   ! Put a MAT5{TYPE} into the output buffer flat style
   end

   put(mx) ::: get_from(TEXTFILE, MX?=>MAT5{CPX})
   ! Put a MAT5{TYPE} into the output buffer flat style
   end

!  ===================
!  Put VEC{EMAT{TYPE}}
!  ===================

   put(v) ::: template
   ! Put a VEC{EMAT{TYPE}} list into the output buffer
      self :: INOUT
      v :: V?, IN

      i :: INT
      using_array_labels :: BIN

      ! Save label status
      using_array_labels = .style.using_array_labels
      .set_using_array_labels(FALSE)

      do i = 1,v.dim
         .text("Matrix "//trim(i.to_str)//":")
         .put(v(i).element,by_row=TRUE)
      end

      ! Restore labels
      .set_using_array_labels(using_array_labels)

   end

   put(v) ::: get_from(TEXTFILE, V?=>VEC{EMAT{INT}})
   ! Put a VEC{EMAT{TYPE}} list into the output buffer
   end

   put(v) ::: get_from(TEXTFILE, V?=>VEC{EMAT{REAL}})
   ! Put a VEC{EMAT{TYPE}} list into the output buffer
   end

!  =========================
!  Put OPVECTOR and OPMATRIX
!  =========================

   put(v)
   ! Outputs the OPVECTOR "v"
     v :: OPVECTOR, IN

     if (v.r.allocated) then
       .flush
       .text("Restricted part:")
       .flush(2)
       .put(v.r)
     end

     if (v.a.allocated) then
       .flush
       .text("Alpha part:")
       .flush(2)
       .put(v.a)
     end

     if (v.b.allocated) then
       .flush
       .text("Beta part:")
       .put(v.b)
     end

   end

   put(mx,by_row,by_column)
   ! Outputs the OPMATRIX "mx"
     mx :: OPMATRIX, IN
     by_row :: BIN, IN, optional
     by_column :: BIN, IN, optional

     if (mx.r.allocated) then
       .flush
       .text("Restricted part:")
       .flush(2)
       .put(mx.r,by_row,by_column)
     end

     if (mx.a.allocated) then
       .flush
       .text("Alpha part:")
       .flush(2)
       .put(mx.a,by_row,by_column)
     end

     if (mx.b.allocated) then
       .flush
       .text("Beta part:")
       .flush(2)
       .put(mx.b,by_row,by_column)
     end

     if (mx.gc.allocated) then
       .flush
       .text("General complex part:")
       .flush(2)
       .put(mx.gc,by_row,by_column)
     end

   end

! Miscellaneous

   put_ppm(mx)
   ! Creates a ppm file from a 3*w*h array of RGB
   ! values and write to disk

     mx :: MAT3{INT}
     ENSURE(minval(mx)>=0, "rgb values should be positive")
     ENSURE(mx.dim1==3, "array should have dimensions 3*w*h")

     i,w,h,k,m :: INT

     i = maxval(mx)
     w = mx.dim2
     h = mx.dim3

     .text("P3")
     .put(w); .flush
     .put(h); .flush
     .put(i); .flush

     do k=1,h
       do m=1,w
         .put(mx(1,m,k))
         .put(mx(2,m,k))
         .put(mx(3,m,k))
         .flush
       end
     end

   end

!  =================
!  Show TYPE methods
!  =================

   show(pretext,value,width,dots) ::: template
   ! Put a left-justfied formatted "value" into the output buffer with
   ! some descriptive "pretext".
      self :: INOUT
      pretext :: STR, IN
      value :: VALUE?, IN
      width :: INT, IN, optional
      dots  :: BIN, IN, optional

      description :: STR(len=(len(pretext)+3))
      do_dots :: BIN

      do_dots = TRUE
      if (present(dots)) do_dots = dots

      if (do_dots) then

         ! Modify the description pretext
         description = " "
         description = pretext
         description.replace_end_from(" =",".",plus=1)

         ! Show it
         .text(description,flush=FALSE)

      else

         ! Show it
         .text(pretext,flush=FALSE)

      end

      ! Put the value
      if (present(width)) then; .put(value,width=width)
      else;                     .put(value,left=TRUE,width=0)
      end

      .flush

   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, VALUE?=>STR)
   ! Put a left-justfied formatted "value" into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, VALUE?=>BIN)
   ! Put a left-justfied formatted "value" into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, VALUE?=>INT)
   ! Put a left-justfied formatted "value" into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value,width,precision,right,dots) ::: template
   ! Put a left-justfied formatted "value" into the output buffer with
   ! descriptive "pretext" and nondefault "width" and "precision".
      self :: INOUT
      pretext :: STR, IN
      value :: VALUE?, IN
      width :: INT, IN, optional
      precision :: INT, IN, optional
      right :: BIN, IN, optional
      dots  :: BIN, IN, optional

      description :: STR(len=(len(pretext)+3))
      do_dots,do_right :: BIN

      do_right = FALSE
      if (present(right)) do_right = right

      do_dots = TRUE
      if (present(dots)) do_dots = dots

      if (do_dots) then

         ! Modify the description pretext
         description = " "
         description = pretext
         description.replace_end_from(" =",".",plus=1)

         ! Show it
         .text(description,flush=FALSE)

      else

         ! Show it
         .text(pretext,flush=FALSE)

      end

      ! Put the value
      if (present(width)) then; .put(value,width=width,precision=precision)
      else if (do_right) then;  .put(value,precision=precision)
      else;                     .put(value,left=TRUE,width=0,precision=precision)
      end

      .flush

   end

   show(pretext,value,width,precision,right,dots) ::: get_from(TEXTFILE, VALUE?=>REAL)
   ! Put a left-justfied formatted "value" into the output buffer with
   ! descriptive "pretext" and nondefault "width" and "precision".
   end

   show(pretext,value,width,precision,right,dots) ::: get_from(TEXTFILE, VALUE?=>CPX)
   ! Put a left-justfied formatted "value" into the output buffer with
   ! descriptive "pretext" and nondefault "width" and "precision".
   end

   show(pretext,value,error,width,precision,dots)
   ! Put a left-justfied formatted "value" into the output buffer with
   ! some descriptive "pretext".
      self :: INOUT
      pretext :: STR, IN
      value :: REAL, IN
      error :: REAL, IN
      width :: INT, optional, IN
      precision :: INT, optional, IN
      dots  :: BIN, optional, IN

      description :: STR(len=(len(pretext)+3))
      do_dots :: BIN

      do_dots = TRUE
      if (present(dots)) do_dots = dots

      if (do_dots) then

         ! Modify the description pretext
         description = " "
         description = pretext
         description.replace_end_from(" =",".",plus=1)

         ! Show it
         .text(description,flush=FALSE)

      else

         ! Show it
         .text(pretext,flush=FALSE)

      end

      ! Put the value
      .put(value,error,width=width,precision=precision)

      ! Put
      .flush

   end

   show_bit_string(pretext,value,width)
   ! Put a formatted INT as a binary number into the output buffer,
   ! with descriptive "pretext".
      pretext :: STR
      value :: INT
      width :: INT, optional

      .text(pretext,flush=FALSE)
      if (present(width)) then; .put_bit_string(value,width=width)
      else;                     .put_bit_string(value,width=.style.real_width)
      end
      .flush

   end

!  ===============
!  Show two TYPE's
!  ===============

   show(pretext,val1,val2) ::: template
   ! Put two scalars "val1", "val2" into the output buffer, with
   ! descriptive "pretext" before.
      self :: INOUT
      pretext :: STR, IN
      val1,val2 :: VAL?, IN

      .text(pretext,flush=FALSE)
      .put(val1)
      .put(val2)
      .flush

   end

!   show(pretext,val1,val2) ::: get_from(TEXTFILE, VAL?=>INT)
!   ! Put two scalars "val1", "val2" into the output buffer, with
!   ! descriptive "pretext" before.
!   end

!   show(pretext,val1,val2) ::: get_from(TEXTFILE, VAL?=>REAL)
!   ! Put two scalars "val1", "val2" into the output buffer, with
!   ! descriptive "pretext" before.
!   end

!  =================
!  Show three TYPE's
!  =================

   show(pretext,val1,val2,val3,tol) ::: template
   ! Put three scalar "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
      self :: INOUT
      pretext :: STR, IN
      val1,val2,val3 :: VAL?, IN
      tol :: INT, IN, optional

      tol_save :: INT

      .text(pretext,flush=FALSE)

      if (present(tol)) then

         tol_save=.style.real_precision
         .style.real_precision=tol
         .put(val1,width=.style.real_width)
         .put(val2,width=.style.real_width)
         .put(val3,width=.style.real_width)
         .style.real_precision=tol_save

      else

         .put(val1,width=.style.real_width)
         .put(val2,width=.style.real_width)
         .put(val3,width=.style.real_width)

      end

      .flush

   end

   show(pretext,val1,val2,val3,tol) ::: get_from(TEXTFILE, VAL?=>BIN)
   ! Put three scalar "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
   end

   show(pretext,val1,val2,val3,tol) ::: get_from(TEXTFILE, VAL?=>INT)
   ! Put three scalar "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
   end

   show(pretext,val1,val2,val3,tol) ::: get_from(TEXTFILE, VAL?=>REAL)
   ! Put three scalar "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
   end

!  ==============
!  Show VEC{TYPE}
!  ==============

   show(pretext,value,width,dots) ::: template
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
      self :: INOUT
      pretext :: STR, IN
      value :: V?, IN
      width :: INT, IN, optional
      dots  :: BIN, IN, optional

      description :: STR(len=(len(pretext)+3))
      i :: INT
      do_dots :: BIN

      do_dots = TRUE
      if (present(dots)) do_dots = dots

      if (do_dots) then

         ! Modify the description pretext
         description = " "
         description = pretext
         description.replace_end_from(" =",".",plus=1)

         ! Show it
         .text(description,flush=FALSE)

       else

         ! Show it
         .text(pretext,flush=FALSE)

       end

      ! Put the values
      if (present(width)) then
         do i = 1,value.dim
            .put(value(i),width=width)
         end
      else
         .put(value.to_concatenated_str(separator=" "),left=TRUE)
      end
      .flush

   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, V?=>VEC{STR})
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, V?=>VEC{BIN})
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, V?=>VEC{INT})
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

   show(pretext,value,width,dots) ::: get_from(TEXTFILE, V?=>VEC{REAL})
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

!  =================
!  Dump TYPE methods
!  =================

   dump(varname,value) ::: template
   ! Dump a "value" with variable name "varname".
      self :: INOUT
      varname :: STR, IN
      value :: VALUE?, IN

      .text(trim(varname)//":VALUE? =",flush=FALSE)
      .put(value,left=TRUE,width=0)
      .flush

   end

   dump(varname,value) ::: get_from(TEXTFILE, VALUE?=>STR)
   ! Dump a "value" with variable name "varname".
   end

   dump(varname,value) ::: get_from(TEXTFILE, VALUE?=>BIN)
   ! Dump a "value" with variable name "varname".
   end

   dump(varname,value) ::: get_from(TEXTFILE, VALUE?=>INT)
   ! Dump a "value" with variable name "varname".
   end

   dump(varname,value) ::: template
   ! Dump a REAL/CPX "value" with variable name "varname".
      self :: INOUT
      varname :: STR, IN
      value :: VALUE?, IN

      .text(trim(varname)//":VALUE? = ",flush=FALSE)
      .put(value,left=TRUE,fmt="e",width=TEXTFILE_REAL_WIDTH,precision=TEXTFILE_REAL_PRECISION)
      .flush

   end

   dump(varname,value) ::: get_from(TEXTFILE, VALUE?=>REAL)
   ! Dump a REAL/CPX "value" with variable name "varname".
   end

   dump(varname,value) ::: get_from(TEXTFILE, VALUE?=>CPX)
   ! Dump a REAL/CPX "value" with variable name "varname".
   end

!  ==============================
!  Dump VEC{TYPE} without pretext
!  ==============================

   dump(v) ::: template
   ! Dump a non-numeric vector "v" without any description
      self :: INOUT
      v :: V?, IN

      dim,n_block,block,fields, i,f,l :: INT

      dim     = v.dim
      fields  = TEXTFILE_N_FIELDS_PER_LINE
      n_block = int((dim-0.1)/fields) + 1

      do block = 1,n_block
         f = 1 + fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         do i = f,l
            .put(v(i),left=TRUE,width=0)
         end
      end

      .flush

   end

   dump(v) ::: get_from(TEXTFILE, V?=>VEC{STR})
   ! Dump a non-numeric vector "v" without any description
   end

   dump(v) ::: get_from(TEXTFILE, V?=>VEC{BIN})
   ! Dump a non-numeric vector "v" without any description
   end

   dump(v) ::: get_from(TEXTFILE, V?=>VEC{INT})
   ! Dump a non-numeric vector "v" without any description
   end

   dump(v) ::: template
   ! Dump a numeric vector "v" without any description
      self :: INOUT
      v :: V?, IN

      dim,n_block,block,fields, i,f,l :: INT

      dim     = v.dim
      fields  = TEXTFILE_N_FIELDS_PER_LINE
      n_block = int((dim-0.1)/fields) + 1

      do block = 1,n_block
         f = 1 + fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         do i = f,l
            .put(v(i),fmt="e",width=TEXTFILE_REAL_WIDTH,precision=TEXTFILE_REAL_PRECISION)
         end
      end

      .flush

   end

   dump(v) ::: get_from(TEXTFILE, V?=>VEC{REAL})
   ! Dump a numeric vector "v" without any description
   end

   dump(v) ::: get_from(TEXTFILE, V?=>VEC{CPX})
   ! Dump a numeric vector "v" without any description
   end

!  ==============
!  Dump VEC{TYPE}
!  ==============

   dump(varname,v,all) ::: template
   ! Dump a vector "v" with variable name "varname".
      self :: INOUT
      varname :: STR, IN
      v :: V?, IN
      all :: BIN, optional, IN

      dim :: INT
      is_all :: BIN

      ! Is this a pointer?
      is_all = FALSE
      if (present(all)) is_all = all

      ! Variable declaration
      if (is_all) then; stdout.text(trim(varname)//":VEC{V?}@ = {")
      else;             stdout.text(trim(varname)//":VEC{V?} = {")
      end

      ! Dimension
      dim = v.dim
      .text(" dimension = "//trim(dim.to_str))

      ! Dump vector
      .dump(v)

      .text("}")

   end

   dump(varname,v,all) ::: get_from(TEXTFILE, V?=>VEC{STR})
   ! Dump a vector "v" with variable name "varname".
   end

   dump(varname,v,all) ::: get_from(TEXTFILE, V?=>VEC{BIN})
   ! Dump a vector "v" with variable name "varname".
   end

   dump(varname,v,all) ::: get_from(TEXTFILE, V?=>VEC{INT})
   ! Dump a vector "v" with variable name "varname".
   end

   dump(varname,v,all) ::: get_from(TEXTFILE, V?=>VEC{REAL})
   ! Dump a vector "v" with variable name "varname".
   end

   dump(varname,v,all) ::: get_from(TEXTFILE, V?=>VEC{CPX})
   ! Dump a vector "v" with variable name "varname".
   end

!  ==============
!  Dump MAT{TYPE}
!  ==============

   dump(varname,mx,all) ::: template
   ! Dump a matrix "mx" with variable name "varname".
      self :: INOUT
      varname :: STR, IN
      mx :: MAT{MX?}, IN
      all :: BIN, optional, IN

      dim,dim1,dim2 :: INT
      is_all :: BIN
      v :: VEC{MX?}@

      ! Is this a pointer?
      is_all = FALSE
      if (present(all)) is_all = all

      ! Variable declaration
      if (is_all) then; stdout.text(trim(varname)//":MAT{TYPE}@ = {")
      else;             stdout.text(trim(varname)//":MAT{TYPE} = {")
      end

      ! Dimensions
      dim  = mx.dim
      dim1 = mx.dim1
      dim2 = mx.dim2
      .text("dimensions = "//trim(dim1.to_str)//" "//trim(dim2.to_str))

      ! Dump array as vector
      v.create(dim)
      v = reshape(mx,[dim])
      .dump(v)
      v.destroy

      .text("}")

   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>STR)
   ! Dump a matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>BIN)
   ! Dump a matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>INT)
   ! Dump a matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>REAL)
   ! Dump a matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>CPX)
   ! Dump a matrix "mx" with variable name "varname".
   end

!  ===============
!  Dump MAT3{TYPE}
!  ===============

   dump(varname,mx,all) ::: template
   ! Dump a 3d matrix "mx" with variable name "varname".
      self :: INOUT
      varname :: STR, IN
      mx :: MAT3{MX?}, IN
      all :: BIN, optional, IN

      dim,dim1,dim2,dim3 :: INT
      is_all :: BIN
      v :: VEC{MX?}@

      ! Is this a pointer?
      is_all = FALSE
      if (present(all)) is_all = all

      ! Variable declaration
      if (is_all) then; stdout.text(trim(varname)//":MAT3{TYPE}@ = {")
      else;             stdout.text(trim(varname)//":MAT3{TYPE} = {")
      end

      ! Dimensions
      dim  = mx.dim
      dim1 = mx.dim1
      dim2 = mx.dim2
      dim3 = mx.dim3
      .text(" dimensions = "//trim(dim1.to_str)//" "//trim(dim2.to_str//" "//trim(dim3.to_str)))

      ! Dump array as vector
      v.create(dim)
      v = reshape(mx,[dim])
      .dump(v)
      v.destroy

      .text("}")

   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>BIN)
   ! Dump a 3d matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>INT)
   ! Dump a 3d matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>REAL)
   ! Dump a 3d matrix "mx" with variable name "varname".
   end

   dump(varname,mx,all) ::: get_from(TEXTFILE, MX?=>CPX)
   ! Dump a 3d matrix "mx" with variable name "varname".
   end

!  =================
!  Dump allocatables
!  =================

   dmpa(varname,value) ::: template
   ! Dump an allocatable "value" with variable name "varname".
      self :: INOUT
      varname :: STR, IN
      value :: VALUE?@, IN

      if (value.deallocated) then
         .text(trim(varname)//":VALUE?@ = null")
      else
         .dump(varname,value,all=TRUE)
      end

   end

!  ===============
!  Dump VEC{TYPE}*
!  ===============
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{STR})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{BIN})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{INT})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{REAL})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{CPX})
!   ! Dump a pointer "value" with variable name "varname".
!   end

!  ===============
!  Dump VEC{TYPE}@
!  ===============

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{STR})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{BIN})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{INT})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{REAL})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>VEC{CPX})
   ! Dump an allocatable "value" with variable name "varname".
   end

!  ===============
!  Dump MAT{TYPE}*
!  ===============
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{STR})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{BIN})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{INT})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{REAL})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{CPX})
!   ! Dump a pointer "value" with variable name "varname".
!   end

!  ===============
!  Dump MAT{TYPE}@
!  ===============

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{STR})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{BIN})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{INT})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{REAL})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT{CPX})
   ! Dump an allocatable "value" with variable name "varname".
   end

!  ================
!  Dump MAT3{TYPE}*
!  ================

!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{BIN})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{INT})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{REAL})
!   ! Dump a pointer "value" with variable name "varname".
!   end
!
!   dmpp(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{CPX})
!   ! Dump a pointer "value" with variable name "varname".
!   end

!  ================
!  Dump MAT3{TYPE}@
!  ================

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{BIN})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{INT})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{REAL})
   ! Dump an allocatable "value" with variable name "varname".
   end

   dmpa(varname,value) ::: get_from(TEXTFILE, VALUE?=>MAT3{CPX})
   ! Dump an allocatable "value" with variable name "varname".
   end

!  ==========================
!  Dump OPVECTOR and OPMATRIX
!  ==========================

   increment_margin_width(val) ::: PURE
   ! Increment the width of the margin in the buffer to "val"
      self :: INOUT
      val :: INT, IN

      .style.margin_width = .style.margin_width + val

      ! Put the margin if needed
      .clear_and_put_margin

   end

   dump(varname,v,all)
   ! Dump an OPVECTOR with variable name "varname".
      varname :: STR, IN
      v   :: OPVECTOR, IN
      all :: BIN, optional, IN

      is_all :: BIN

      ! Is this a pointer?
      is_all = FALSE
      if (present(all)) is_all = all

      ! Variable declaration
      if (is_all) then; stdout.text(trim(varname)//":OPVECTOR@ = {")
      else;             stdout.text(trim(varname)//":OPVECTOR  = {")
      end

      .increment_margin_width(1)

      ! Dump
      .dump("n_bf",v.n_bf)
      .dump("r   ",v.r)
      .dump("a   ",v.a)
      .dump("b   ",v.b)
      .dump("g   ",v.g)

      .increment_margin_width(-1)
      .flush

      .text("}")

   end

   dump(varname,mx,all)
   ! Dump an OPMATRIX with variable name "varname".
      varname :: STR, IN
      mx  :: OPMATRIX, IN
      all :: BIN, optional, IN

      is_all :: BIN

      ! Is this a pointer?
      is_all = FALSE
      if (present(all)) is_all = all

      ! Variable declaration
      if (is_all) then; stdout.text(trim(varname)//":OPMATRIX@ = {")
      else;             stdout.text(trim(varname)//":OPMATRIX  = {")
      end

      .increment_margin_width(1)

      ! Dump
      .dump("n_bf",mx.n_bf)
      .dump("r   ",mx.r)
      .dump("a   ",mx.a)
      .dump("b   ",mx.b)
      .dump("gc  ",mx.gc)
      .dump("tri ",mx.tri)
      .dump("sqr ",mx.sqr)

      .increment_margin_width(-1)
      .flush

      .text("}")

   end

!  ================
!  Output self info
!  ================

   put
   ! Put some information on file "stdout"
      self :: IN

      stdout.show("Name       =",.name)
      stdout.show("I/O action =",.action)
      stdout.show("Unit       =",.unit)
      stdout.show("Line       =",.record)
      stdout.show("Buffer     =",trim(.buffer.string))
      stdout.show("Cursor pos =",trim(.buffer.cursor_pointer))

   end

   put_output_format
   ! Put more information on file "stdout"
      self :: IN

      stdout.show("Name               =",.name)
      stdout.show("I/O action         =",.action)
      stdout.show("Unit               =",.unit)
      stdout.show("int_width          =",.style.int_width)
      stdout.show("margin_width       =",.style.margin_width)
      stdout.show("n_fields_per_line  =",.style.n_fields_per_line)
      stdout.show("real_fortran_fmt   =",.style.real_fortran_fmt)
      stdout.show("real_width         =",.style.real_width)
      stdout.show("real_precision     =",.style.real_precision)
      stdout.show("using_array_labels =",.style.using_array_labels)
      stdout.show("using_fields       =",.style.using_fields)

   end

!  ===============
!  System routines
!  ===============

   update_system_info ::: private
   ! Let the tonto system know info about the file being read,
   ! in case of error.
     self :: target

#ifndef NO_TONTO_SYSTEM_CALLS
     tonto.io_file => self
#endif

   end

end
