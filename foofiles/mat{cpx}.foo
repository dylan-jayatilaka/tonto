!===================================================================
! complex matrix operations :: MAT{CPX} ...
!
! Copyright (C) Dylan Jayatilaka, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module MAT{CPX}

   implicit none

   interface trace_of_product_with
      trace_product_with
   end

   interface diagonal_set_to
      set_diagonal_to
   end

   interface diagonal_plus
      increment_diagonal_by
   end

   interface diagonal_times
      scale_diagonal_by
   end

   interface diagonal_max_abs
      max_abs_diagonal_element
   end

contains

!  ==========
!  Allocation
!  ==========

   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Allocate a matrix with the given dimensions
   end

   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Allocate a matrix with the given bounds
   end

   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Allocate object with the given array bounds
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

! Old

   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Create a matrix with the given dimensions
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Create a matrix with the specified "bounds" for each dimension
   end

   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Create a matrix with the given dimensions
   end

   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Create a matrix with the specified bounds for each dimension
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Create a matrix with the given bounds for all dimensions
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object. This version does not destroy pointer parts.
   end

!  ====
!  Copy
!  ====

   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Create a replica copy of matrix
   end

!  ============================
!  Size-of and shape operations
!  ============================

   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
   end

   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
   end

   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
   end

   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
   end

   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Returns TRUE if the matrix is square
   end

!  =======================
!  Shrinking and expansion
!  =======================

   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Shrink allocatable self to have upper bounds dim1 x dim2.
   end

   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Shrink columns of allocatable self to upper bound dim2.
   end

   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}, INIT?=>ZERO), leaky, PURE
   ! Expand allocatable self to dim1 x dim2.
   ! New elements are initialised.
   end

   expand_rows(dim1) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Expands the rows of allocatable self to upper bound dim1.
   ! New elements are zeroed.
   end

   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Expand columns of allocatable self to upper bound dim2.
   ! New elements are zeroed.
   end

   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Append the columns "cols" onto end of allocatable self.
   end

   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Append the column "col" onto end of allocatable self.
   end

   prune_column(col) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Prune the column with index "col".
   end

! Old

!  =======================
!  Shrinking and expansion
!  =======================

   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Shrinks self to dimension dim1xdim2.  Contents are retained.
   end

   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Expands self to dimension dim1xdim2.  Contents are retained.
   end

   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Shrinks columns of self to dimension dim2. Contents are retained.
   end

   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Expands the columns self to dim2.  Contents are retained.
   end

   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Append the columns "cols" onto the end of self.
   end

   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Append the column "col" onto the end of self.
   end


!  ====================
!  Comparison functions
!  ====================

   equals(b) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Check if the matrix is the same as "b".
   end

   same_as(b,eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Check if the matrix is the same as "b", within "eps".
   end

!  =================
!  Inquiry functions
!  =================

   is_diagonal(eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" is a diagonal matrix to within
   ! tolerance "eps" (if present).
   end

   has_unit_diagonal(eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" has 1's as diagonal elements to within
   ! tolerance "eps" (if present).
   end

   has_minus_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" has -1's as diagonal elements
   end

   is_unit_matrix(eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" is the unit matrix to within
   ! tolerance "eps" (if present).
   end

   is_inversion_matrix result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" is an inversion matrix
   ! i.e. minus the unit matrix
   end

   is_symmetric result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" is a symmetric matrix
   end

   is_antisymmetric result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" is an antisymmetric matrix
   end

   is_zero(eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return TRUE is "self" is the zero matrix, i.e. every element is zero.
   ! If present, "eps" is used to decide when a small number is zero.
   end

   is_hermitian(tol) result (res) ::: PURE
   ! Returns TRUE if the matrix is hermitian. You can set the tolerance "tol"
   ! for comparison.
      self :: IN
      res :: BIN
      tol :: REAL, optional, IN

      res = .is_square AND .same_as(transpose(conjg(self)),tol)

   end

   is_antihermitian(tol) result (res) ::: PURE
   ! Returns TRUE if the matrix is antihermitian. You can set the tolerance
   ! "tol" for comparison.
      self :: IN
      res :: BIN
      tol :: REAL, optional, IN

      res = .is_square AND .same_as(-transpose(conjg(self)),tol)

   end

!  =================
!  Column operations
!  =================

   has_column(c,eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Returns TRUE if the matrix "self" has a column "c", with "eps" tolerance.
   end

   index_for_column(c,eps) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the index of the first column in "self" which matches "c",
   ! within tolerance "eps", or else return 0 for no match.
   end

   indices_for_column(c,eps) result (res) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Return the indices of columns in "self" which match "c",
   ! within tolerance "eps", or else return 0 for no match.
   end


   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC}), PURE
   ! Swap columns "col1" and "col2" of self
   end

   swap_columns(list) ::: get_from(MAT{INTRINSIC}), PURE
   ! Sequentially swap all columns in a column "list",
   ! self(:,i)      = self(:,list(i))
   ! self(:,col(i)) = self(:,i)
   end

   reverse_column_order ::: get_from(MAT{INTRINSIC}), PURE
   ! Reverse the order of the columns of self.
   end


   column_norms result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the norms of every column
   end

   get_column_norms(res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the norms of every column
   end

   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the dot products of every column with itself.
   ! Good for testing distances without using a sqrt.
   end

   index_of_minimum_column_norm result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Return the column index of the column with the *minimum* norm.
   end

   max_abs_column_difference result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the maximum of the absolute difference between all the column vector
   ! pairs of the matrix.
   end


   mean_column_vector result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the mean of the column vectors.
   end

   sum_column_vectors result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Sum the column vectors (i.e. rows) in "self".
   end

!  ==============
!  Row operations
!  ==============

   sum_row_vectors result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Sum the row vectors (i.e. columns) in "self".
   end

!  ==========================================
!  Matrix algebra and vector space operations
!  ==========================================

   determinant result (res) ::: get_from(MAT{INTRINSIC}), recursive, PURE
   ! Return the determinant
   end

   adjugate(i,j) result (res) ::: get_from(MAT{INTRINSIC}), leaky, PURE
   ! Return the adjugate of a matrix
   end


   sum_elements result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Return the sum of the elements in "self"
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR?=>VEC{CPX}, RES?=>CPX), PURE
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR?=>VEC{REAL}, RES?=>CPX), PURE
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
   end


   rotate(v) ::: get_from(MAT{INTRINSIC}), PURE
   ! Rotate vector "v" by self
   end


   to_unit_matrix ::: get_from(MAT{INTRINSIC}), pure
   ! Set "self" to the unit matrix
   end


   zero_small_values(eps) ::: get_from(MAT{INTRINSIC}), pure
   ! Zero elements of the matrix which are less than "eps" in magnitude
   end


   set_to(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), PURE
   ! Set self to "a"
   end

   set_to(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}), PURE
   ! Set self to "a"
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), PURE
   ! Self becomes the transpose of "a"
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}), PURE
   ! Self becomes the transpose of "a"
   end

   to_transpose ::: get_from(MAT{INTRINSIC}), PURE
   ! Self becomes its own transpose.
   end


   plus(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), PURE
   ! Add to self the matrix "a"
   end

   plus(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}), PURE
   ! Add to self the matrix "a"
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), PURE
   ! Subtract from self the matrix "a"
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}), PURE
   ! Subtract from self the matrix "a"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}, FAC?=>CPX), PURE
   ! Set "self" to matrix "at" scaled by "fac"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}, FAC?=>REAL), PURE
   ! Set "self" to matrix "at" scaled by "fac"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, FAC?=>CPX), PURE
   ! Set "self" to matrix "at" scaled by "fac"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, FAC?=>REAL), PURE
   ! Set "self" to matrix "at" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}, FAC?=>CPX), PURE
   ! Add to "self" matrix "a" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}, FAC?=>REAL), PURE
   ! Add to "self" matrix "a" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, FAC?=>CPX), PURE
   ! Add to "self" matrix "a" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, FAC?=>REAL), PURE
   ! Add to "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}, FAC?=>CPX), PURE
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}, FAC?=>REAL), PURE
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, FAC?=>CPX), PURE
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, FAC?=>REAL), PURE
   ! Subtract from "self" matrix "a" scaled by "fac"
   end


   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB?=>REAL), PURE
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   end

   to_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}), PURE
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
   end

   to_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}), PURE
   ! Set "self" to the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end

   to_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}), PURE
   ! Set "self" to the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end


   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB?=>REAL), PURE
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   end

   plus_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}), PURE
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
   end

   plus_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}), PURE
   ! Add to "self" the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end

   plus_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}), PURE
   ! Add to "self" the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end


   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB?=>REAL, FAC?=>CPX), PURE
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB?=>REAL, FAC?=>REAL), PURE
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end


   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB?=>REAL, FAC?=>CPX), PURE
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB?=>REAL, FAC?=>REAL), PURE
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end


   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, DIAG?=>VEC{CPX}), PURE
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, DIAG?=>VEC{REAL}), PURE
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG?=>VEC{CPX}), PURE
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG?=>VEC{REAL}), PURE
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG?=>VEC{CPX}, A?=>MAT{REAL}), PURE
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG?=>VEC{REAL}, A?=>MAT{REAL}), PURE
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG?=>VEC{CPX}), PURE
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG?=>VEC{REAL}), PURE
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
   end

!  ================
!  Trace operations
!  ================

   trace result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Return the trace of self
   end

   trace_product_with(a,transpose_a,dagger_a) result (res) ::: get_from(MAT{INTRINSIC}, A?=>MAT{CPX}), pure
   ! Return the trace of the product of "self" with matrix "a",
   ! and if "dagger_a" is present and TRUE, then dagger "a".
   end

   trace_product_with(a,transpose_a) result (res) ::: get_from(MAT{INTRINSIC}, A?=>MAT{REAL}, RES?=>REAL, CAST=>REALIFY), pure
   ! Return the trace of the product of "self" with matrix "a",
   ! and if "transpose_a" is present and TRUE, then transpose "a".
   end

   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the trace of the product of "self" with matrices "a", "b" and "c".
   end

   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the trace of the product of "self" with matrices "a", "b" ... "e".
   end

   dot(a) result (res) ::: pure
   ! Synonym for trace_product_with(a) ... Return the trace of the product of
   ! "self" with matrix "a". This is really intended for use with symmetric
   ! matrices only.
      self :: IN
      a :: MAT{CPX}, IN
      res :: CPX

      res = .trace_product_with(a,dagger_a=TRUE)

   end

!  ========================
!  Change of basis routines
!  ========================

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A), PURE
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{REAL}), PURE
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V?=>VEC{CPX}), PURE
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V?=>VEC{REAL}), PURE
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
   end

   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR?=>VEC{CPX}), PURE
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
   end

   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR?=>VEC{REAL}), PURE
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
   end

   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A), PURE
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
   end

   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{REAL}), PURE
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
   end

   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR?=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A), PURE
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
   end

   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR?=>MAT{REAL}), PURE
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
   end

   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B), PURE
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
   end

   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{REAL}), PURE
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
   end

   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B), PURE
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
   end

   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{REAL}), PURE
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
   end

   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR?=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B), PURE
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
   end

   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR?=>MAT{REAL}), PURE
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
   end

!   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{CPX})
!   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
!   end

!   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V?=>MAT{REAL})
!   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
!   end

!  ==========================
!  Operations on the diagonal
!  ==========================

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D?=>VEC{CPX}), PURE
   ! Converts the diagonal vector "d" to matrix "self".
   end

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D?=>VEC{REAL}), PURE
   ! Converts the diagonal vector "d" to matrix "self".
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D?=>VEC{CPX}), PURE
   ! Set the diagonal of "self" to vector "d"
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D?=>VEC{REAL}), PURE
   ! Set the diagonal of "self" to vector "d"
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL?=>CPX), PURE
   ! Set the diagonal of "self" to "val"
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL?=>REAL), PURE
   ! Set the diagonal of "self" to "val"
   end

   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D?=>VEC{CPX}, CAST?=>), PURE
   ! Get the diagonal elements of "self" in vector "d"
   end

   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D?=>VEC{REAL}, CAST?=>REALIFY), PURE
   ! Get the diagonal elements of "self" in vector "d"
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL?=>CPX), PURE
   ! Add "val" to the diagonal of "self"
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL?=>REAL), PURE
   ! Add "val" to the diagonal of "self"
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC?=>CPX), PURE
   ! Weight the diagonal elements of "self" by "fac"
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC?=>REAL), PURE
   ! Weight the diagonal elements of "self" by "fac"
   end

   zero_diagonal ::: get_from(MAT{INTRINSIC}), PURE
   ! Zero the diagonal elements of "self"
   end

   zero_off_diagonal ::: get_from(MAT{INTRINSIC}), PURE
   ! Zero the off diagonal elements of "self"
   end

   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Get the maximum absolute value of the diagonal elements of the self matrix
   end

!  ========================
!  Symmetrising and folding
!  ========================

   symmetrize ::: get_from(MAT{INTRINSIC}), PURE
   ! Set self to half of itself plus half its transpose, i.e.
   ! self = 1/2 (self + self^T)
   end

   antisymmetrize ::: get_from(MAT{INTRINSIC}), PURE
   ! Set self to half of itself minus half its transpose, i.e.
   ! self = 1/2 (self - self^T)
   end

   symmetric_fold ::: get_from(MAT{INTRINSIC}), PURE
   ! Add the upper triangle of "self" into the lower triangle
   end

   antisymmetric_fold ::: get_from(MAT{INTRINSIC}), PURE
   ! Subtract the upper triangle of "self" into the lower triangle
   end

   symmetric_reflect ::: get_from(MAT{INTRINSIC}), PURE
   ! Make the upper triangle of "self" the same as the lower triangle
   end

   antisymmetric_reflect ::: get_from(MAT{INTRINSIC}), PURE
   ! Make the upper triangle of "self" the negative of the lower triangle and
   ! make the diagonal zero.
   end

   symmetric_fold_to_triangle(tr) ::: get_from(MAT{INTRINSIC}), PURE
   ! Add the upper triangle of "self" into the lower triangle and return
   ! the lower triangle "tr" as a vector across rows.
   end

   hermitianize ::: PURE
   ! Set self to half of itself plus half its dagger, i.e.
   ! self = 1/2 (self + self^dagger)
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      i,j :: INT
      val :: CPX

      do i = 1,.dim1
      do j = 1,i
         val = HALF*(self(i,j)+conjg(self(j,i)))
         self(i,j) = val
         self(j,i) = conjg(val)
      end
      end

   end

   antihermitianize ::: PURE
   ! Set self to half of itself minus half its dagger, i.e.
   ! self = 1/2 (self - self^dagger)
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      i,j :: INT
      val :: CPX

      do i = 1,.dim1
      do j = 1,i
         val = HALF*(self(i,j)-conjg(self(j,i)))
         self(i,j) =  val
         self(j,i) = -conjg(val)
      end
      end

   end

   hermitian_fold ::: PURE
   ! Add the hermitian conjugate of the upper half of the matrix into its lower
   ! half, and make the diagonal real.
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      i,j :: INT

      do i = 1,.dim1
         do j = 1,i-1
            self(i,j) = self(i,j) + conjg(self(j,i))
         end
         self(i,i) = REALIFY(self(i,i))
      end

   end

   antihermitian_fold ::: PURE
   ! Subtract the hermitian conjugate of the upper half of the matrix into its
   ! lower half, and make the diagonal complex
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      i,j :: INT

      do i = 1,.dim1
         do j = 1,i
            self(i,j) = self(i,j)-conjg(self(j,i))
         end
         self(i,i) = HALF*self(i,i)
      end

   end

   make_hermitian ::: PURE
   ! Make the upper half of self hermitian with respect to the lower half
      self :: INOUT

     ENSURE(.is_square,"non-square matrix")

      i,j :: INT

      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = conjg(self(i,j))
         end
      end

      do i = 1,.dim1
         self(i,i) = REALIFY(self(i,i))
      end

   end

   hermitian_reflect ::: PURE
   ! Make the upper half of self hermitian with respect
   ! to the lower half
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      i,j :: INT

      do i = 1,.dim1
      do j = 1,i-1
         self(j,i) = conjg(self(i,j))
      end
      end

      do i = 1,.dim1
         self(i,i) = REALIFY(self(i,i))
      end

   end

   make_antihermitian ::: PURE
   ! Make the upper half of self anti-hermitian with respect
   ! to the lower half
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      i,j :: INT

      do i = 1,.dim1
      do j = 1,i-1
         self(j,i) = -conjg(self(i,j))
      end
      end

      do i = 1,.dim1
         self(i,i) = HALF*(self(i,i)-conjg(self(i,i)))
      end

   end

   antihermitian_reflect ::: PURE
   ! Make the upper half of self anti-hermitian with respect
   ! to the lower half
      self :: INOUT

   ENSURE(.is_square,"non-square matrix")

      dim1,i,j :: INT

      dim1 = .dim1

      do i = 1,dim1
      do j = 1,i-1
         self(j,i) = -conjg(self(i,j))
      end
      end

      do i = 1,.dim1
         self(i,i) = HALF*(self(i,i)-conjg(self(i,i)))
      end

   end

!  ======================================
!  Compression and uncompression routines
!  ======================================

   zip_matrix_to(v) ::: get_from(MAT{INTRINSIC}), pure
   ! Converts matrix "self" to the vector "v", where vectors are
   ! stored in column order
   end

   unzip_vector(v) ::: get_from(MAT{INTRINSIC}), pure
   ! Converts the vector "v" into a matrix "self".
   end

   zip_lower_triangles_to(sq) ::: pure
   ! Compresses the hermitian matrix self to vector "sq". First comes the
   ! lower half of the real part, then lower half of the imaginary part.
      self :: IN
      sq :: VEC{REAL}, OUT

      i,j,ij :: INT

      ij = 0

      ! Real part
      do i = 1,.dim1
         do j = 1,i
            sq(ij+j) = REALIFY(self(i,j))
         end
         ij = ij+i
      end

      ! Imaginary part
      do i = 1,.dim1
         do j = 1,i-1
            sq(ij+j) = aimag(self(i,j))
         end
         ij = ij+i-1
      end

   end

   hermitian_unzip_triangles(sq) ::: PURE
   ! Uncompress the vector "sq" to a hermitian matrix assuming the lower half
   ! of the real part comes first, then the lower half of the imaginary part.
      self :: OUT
      sq :: VEC{REAL}, IN

      i,j,ij :: INT
      val :: REAL

      ij = 0
      do i = 1,.dim1
         do j = 1,i
            val = sq(ij+j)
            self(i,j) = val
            self(j,i) = val
         end
         ij = ij+i
      end

      do i = 1,.dim1
         do j = 1,i-1
            val = sq(ij+j)
            self(i,j) = self(i,j) + IMAGIFY(val)
            self(j,i) = self(j,i) - IMAGIFY(val)
         end
         ij = ij+i-1
      end

   end

   antihermitian_unzip_triangles(sq) ::: PURE
   ! Uncompress the vector "sq" to a hermitian matrix assuming the lower half
   ! of the real part comes first, then the lower half of the imaginary part.
      self :: OUT
      sq :: VEC{REAL}, IN

      i,j,ij :: INT
      val :: REAL

      ij = 0
      do i = 1,.dim1
         do j = 1,i
            val = sq(ij+j)
            self(i,j) =  val
            self(j,i) = -val
         end
         ij = ij+i
      end

      do i = 1,.dim1
         do j = 1,i-1
            val = sq(ij+j)
            self(i,j) =  self(i,j) + IMAGIFY(val)
            self(j,i) =  self(j,i) + IMAGIFY(val)
         end
         ij = ij+i-1
      end

   end

   zip_lower_triangle_to(tr) ::: get_from(MAT{INTRINSIC}), pure
   ! Converts the lower triangle of "self" to the vector "tr"
   ! using row order.
   end

   unzip_lower_triangle(tr) ::: get_from(MAT{INTRINSIC}), pure
   ! Converts the triangle "tr" into a lower triangular matrix "self".
   end

   hermitian_unzip_triangle(tr) ::: pure
   ! Converts the triangle "tr" into the hermitian matrix "self".
   ! WARNING: won't work for symmetric matrices
   ! WARNING: Note the missing "s" on triangle, to avoid name clash
      self :: OUT
      tr :: VEC{CPX}, IN

      i,j,ij :: INT
      val :: CPX

      ij = 0
      do i = 1,.dim1
         do j = 1,i
            val = tr(ij+j)
            self(i,j) =       val
            self(j,i) = conjg(val)
         end
         ij = ij+i
      end

   end

   tri_size result (ltr) ::: get_from(MAT{INTRINSIC}), pure
   ! Returns the size of the lower triangle needed to store self.
   end

!  =================
!  Orthogonalisation
!  =================

   schmidt_orthonormalise(scale) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" metric. If
   ! "scale" is present, it is set to the product of the normalisation
   ! factors used to normalise each column after the Schmidt
   ! procedure.
   end

   schmidt_orthonormalise(S,scale) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric. If "scale" is present, it is set to the product of the
   ! normalisation factors used to normalise each column after the Schmidt
   ! procedure.
   end

   reverse_schmidt_orthonormalise(S) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric.
   end

   reverse_schmidt_orthogonalise ::: get_from(MAT{INTRINSIC}, CAST=>REALIFY)
   ! Schmidt orthonormalise the column vectors in "self" using unit metric.
   end

   symmetrically_orthonormalise(S) ::: get_from(MAT{INTRINSIC})
   ! Symmetrically orthonormalise the column vectors in "self" using
   ! "S" as the metric, which must be real and positive definite.
   end

   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC}), PURE
   ! Rearrange the order of the columns of self so that the largest magnitude
   ! elements in each column occur along the diagonal. If "permutation" is
   ! present, it is the array which achieves this ordering, i.e. at the end of
   ! the routine, what is done is: self = self(:,permutation).
   end

!  =====================
!  Eigenproblem routines
!  =====================

   make_real_eigenproblem(eigenvalues,eigenvectors,eps)
   ! Diagonalises "self" using only real algebra
   !
   !     (A+iB)*(u+iv)=l*(u+iv)
   !
   ! 1:  |A -B| * |u| = l * |u|
   ! i:  |B  A|   |v|       |v|
   !
   !      UNTESTED
   !
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      eps :: REAL, optional

  ENSURE(.is_hermitian, "self is not symmetrix")
  ENSURE(eigenvalues.dim==.dim1,"wrong size, eigenvalues")
  ENSURE(eigenvectors.is_square, "eigenvectors are not square")
  ENSURE(eigenvalues.dim1>=.dim1,"wrong size, eigenvectors")

      dim,i,j,l  :: INT
      accuracy,diff :: REAL
      W :: MAT{CPX}*
      W2,Wt,evec2 :: MAT{REAL}*
      eval2,temp2 :: VEC{REAL}*
      indices :: VEC{INT}*
      II :: CPX

      accuracy = TOL(12)
      if (present(eps)) accuracy = eps

      W.create_copy(self)
      dim=W.dim1
      Wt.create(dim,dim)
      W2.create(2*dim,2*dim)
      Wt=real(W)
      W2(1:dim,1:dim)=Wt
      W2(dim+1:2*dim,dim+1:2*dim)=Wt
      Wt=aimag(W)
      W2(dim+1:2*dim,1:dim)=Wt
      W2(1:dim,dim+1:2*dim)=-Wt
      Wt.destroy
      W.destroy

      evec2.create(2*dim,2*dim)
      evec2=ZERO
      eval2.create(2*dim)
      eval2=ZERO

      W2.solve_symmetric_eigenproblem(eval2,evec2)
      W2.destroy

!      stdout.flush
!      stdout.text("eval2")
!      stdout.put(eval2)
!      stdout.flush
!      stdout.text("evec2")
!      stdout.put(evec2)
!      stdout.flush

      indices.create(2*dim)
      indices=0
    !  do i = 1,2*dim
    !  indices(i)=0
    !  end

      temp2.create(2*dim)

      l=1
      II=(ZERO,ONE)
      do i = 1,2*dim-1

        if(indices(i)==1)cycle
        ! assign the eigenvalue & vector which has indices(i)/=0
        eigenvalues(l)=eval2(i)
        eigenvectors(:,l)=evec2(1:dim,i)+II*evec2(dim+1:2*dim,i)
        l=l+1
        ENSURE( l-1<dim+1 ," l greater than dim ")
        do j = i+1,2*dim
          if(indices(j)==1)cycle
          ! we test for the same eigenvalue (but which might be
          ! degenerate
   !       if ( abs(eval2(i)-eval2(j)) < accuracy ) then
          if ( abs(eval2(i)-eval2(j)) < abs(eval2(i)-ONE)*TOL(4) ) then
            diff=ZERO
   !         temp=ZERO
            temp2(1:dim)=-evec2(dim+1:2*dim,j)
            temp2(dim+1:2*dim)=evec2(1:dim,j)
            diff= dot_product(evec2(:,i),temp2) - ONE
            if ( abs(diff) < accuracy ) then
            ! we have found the appropriate vector
              indices(j)=1
              exit
            end
   !       else
   !          exit
          end if
        end

      end

!      stdout.flush
!      stdout.text("indeces")
!      stdout.put(indices)
!      stdout.flush
!      stdout.text("eigenvalues")
!      stdout.put(eigenvalues)
!      stdout.flush
!      stdout.text("eigenvectors")
!      stdout.put(eigenvectors)
!      stdout.flush

     evec2.destroy
     eval2.destroy
     temp2.destroy
     indices.destroy

   end

   diagonalize_by_jacobi(eigenvalues,eigenvectors,eps,max_iterations) ::: PURE
   ! Diagonalises "self" using the Jacobi rotations method. Returns the
   ! "eigenvalues". Input the accuracy "eps" or the maximum number of iterations
   ! "max_iter", if desired.
      self :: IN
      eigenvalues :: VEC{REAL}, OUT
      eigenvectors :: MAT{CPX}, OUT
      eps :: REAL, optional, IN
      max_iterations :: INT, optional, IN

  ENSURE(.is_hermitian, "self is not hermitian")
  ENSURE(eigenvalues.dim==.dim1,"wrong size, eigenvalues")
  ENSURE(eigenvectors.is_square, "eigenvectors are not square")
  ENSURE(eigenvalues.dim1>=.dim1,"wrong size, eigenvectors")

      i,j,iter,max_iter  :: INT
      accuracy,tol :: REAL
      done :: BIN
      W :: MAT{CPX}*
      indices :: VEC{INT}*

      accuracy = TOL(12)
      if (present(eps)) accuracy = eps
      max_iter = 750
      if (present(max_iterations)) max_iter = max_iterations

      W.create_copy(self)
      eigenvectors.to_unit_matrix

      iter = 0
      do

        iter = iter + 1
        ENSURE(iter<=max_iter,"too many iterations")

        if (iter>max_iter) exit
        tol = accuracy
        done = TRUE
        do i = 1,.dim1
        do j = 1,i-1
        !   if (abs(W(i,j))<tol) cycle
           if (abs(real(W(i,j)))<tol AND abs(aimag(W(i,j)))<tol &
           AND iter>4 ) cycle
           done = FALSE
           W.jacobi_rotation(i,j,eigenvectors)
        end
        end
        done = done AND iter>3
        if (done) exit
      end

      W.put_diagonal_to(eigenvalues)
      W.destroy

      allocate(indices(.dim1))
      eigenvalues.quick_sort(indices)

      eigenvalues  = eigenvalues(indices)
      eigenvectors = eigenvectors(:,indices)

      deallocate(indices)
   end

   jacobi_rotation(p,q,v) ::: pure
   ! Do a two dimensional Jacobi rotation in the plane of "p" and "q" so as to
   ! eliminate the off diagonal element self(p,q) and also update the rotation
   ! matrix "v". NOTE: self must be symmetric
      self :: INOUT
      p,q :: INT, IN
      v :: MAT{CPX}, INOUT

      i :: INT
      s_pp,s_qq,s_pq,tau,s_ip,s_iq,r_ip,r_iq,ph,pc :: CPX
      a_pq,theta,t,c,s :: REAL

      s_pp = self(p,p)
      s_qq = self(q,q)
      s_pq = self(p,q)
      a_pq = abs(s_pq)

      theta = REALIFY(s_qq-s_pp)/(TWO*a_pq)

      t = ONE/(abs(theta)+sqrt(theta*theta+ONE))
      if (theta<ZERO) t = -t

      c = ONE/sqrt(t*t+ONE)
      s = t*c
      tau = s/(ONE+c)
      ph = s_pq/a_pq
      pc = conjg(ph)

      do i = 1,.dim1
         s_ip = self(i,p)
         s_iq = self(i,q)
         r_ip = s_ip - s*(pc*s_iq+tau*s_ip)
         r_iq = s_iq + s*(ph*s_ip-tau*s_iq)
         self(i,p) = r_ip
         self(p,i) = r_ip
         self(i,q) = r_iq
         self(q,i) = r_iq
      end

      self(p,p) = s_pp - t*pc*s_pq
      self(q,q) = s_qq + t*pc*s_pq
      self(p,q) = ZERO
      self(q,p) = ZERO

      do i = 1,.dim1
         s_ip = v(i,p)
         s_iq = v(i,q)
         v(i,p) = s_ip - s*(pc*s_iq+tau*s_ip)
         v(i,q) = s_iq + s*(ph*s_ip-tau*s_iq)
      end

   end

   solve_hermitian_eigenproblem(eigenvalues,eigenvectors,routine)
   ! Solve the hermitian eigenvalue problem for self
      self :: IN
      eigenvalues :: VEC{REAL}, OUT
      eigenvectors :: MAT{CPX}, OUT
      routine :: STR, optional, IN

      .solve_H_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine)

   end

   solve_H_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine) ::: private
   ! Solve the hermitian eigenvalue problem for self. LAPACK version.
      self :: IN
      eigenvalues :: VEC{REAL}, OUT
      eigenvectors :: MAT{CPX}, OUT
      routine :: STR, optional, IN

   ENSURE(.is_square,"non-square matrix")
   ENSURE(eigenvalues.dim>=.dim1,"supplied eigenvalue array too small")
   ENSURE(eigenvectors.dim>=self.dim,"supplied eigenvector array too small")
   
      rout :: STR
      ap,W :: VEC{CPX}*
      RW :: VEC{REAL}*
      dim,info :: INT

      rout = "zhpev"
      if (present(routine)) rout = routine

      dim = .dim1

      select case (rout)

        case ("zheev")
          W.create(dim*dim)
          RW.create(3*dim)
          eigenvectors.set_to(self)
          info = 0

          call zheev("V","L",dim,eigenvectors,dim,eigenvalues,W,dim*dim,RW,info)

          RW.destroy
          W.destroy
          ENSURE(info==0,"no solution, error found, info="//trim(info.to_str))

        case ("zhpev")
          ap.create(dim*(dim+1)/2)
          self.zip_lower_triangle_to(ap)
          W.create(2*dim)
          RW.create(3*dim)

          call zhpev("V","U",dim,ap,eigenvalues,eigenvectors,dim,W,RW,info)

          RW.destroy
          W.destroy
          ap.destroy
          ENSURE(info==0,"no solution, error found, info="//trim(info.to_str))

      end

   end

!  ========
!  Cholesky
!  ========

   cholesky_decomposition(tr) ::: get_from(MAT{INTRINSIC})
   ! Decompose self into lower triangular matrices "L"
   !   self = L L^T or self = L L^\dagger
   ! where L is a lower triangular matrix stored as an array
   ! going across the rows i.e. (1,1), (2,1), (2,2), (3,1) ...
   end

   cholesky_decomposition(L) ::: get_from(MAT{INTRINSIC})
   ! Decompose self into lower triangular matrices "L"
   !   self = L L^T or self = L L^\dagger
   end


! ==========================================================
! Matrix functions: square roots, inverses, and exponentials
! ==========================================================

   to_sqrt_of(R)
   ! self = sqrt(R), cannot have R=self
      self :: OUT
      R :: MAT{CPX}, IN

   ENSURE(.is_hermitian,"not hermitian")

      evec :: MAT{CPX}* DEFAULT_NULL
      eval :: VEC{REAL}* DEFAULT_NULL
      d,i,j,k :: INT
      temp :: REAL
      val :: CPX

      d = R.dim1
      eval.create(d)
      evec.create(d,d)

      R.solve_hermitian_eigenproblem(eval,evec)

      do i = 1,d
         temp = eval(i)
         if (temp <= ZERO) then
           WARN("non-positive eigenvalue, " // trim(temp.to_str("e15.8")))
         end
         eval(i) = sqrt(abs(temp))
      end

      do i = 1,d
      do j = 1,d
         val = IMAGIFY(ZERO)
         do k = 1,d
            val = val + evec(i,k)*eval(k)*conjg(evec(j,k))
         end
         self(i,j) = val
      end
      end

      evec.destroy
      eval.destroy

   end

   to_inverse_sqrt_of(R,tol) ::: PURE
   ! self = sqrt(R)^(-1), cannot have R=self
      self :: OUT
      R :: MAT{CPX}, IN
      tol :: REAL, optional, IN

      eval :: VEC{REAL}@
      evec :: MAT{CPX}@ 
      ev   :: VEC{CPX}@ 
      d,i,j,k :: INT
      eps,temp :: REAL
      val :: CPX

      eps = TOL(15)
      if (present(tol)) eps = tol

      d = R.dim1
      ev.create(d)      ! WTF? Why is ev complex?
      eval.create(d)
      evec.create(d,d)

      R.diagonalize_by_jacobi(eval,evec,eps)

      do i = 1,d

         temp = eval(i)

         if (abs(temp)<eps) then
            ev(i) = (ZERO,ZERO)
          ! WARN("linear dependence for the eigenvalue, " // trim(temp.to_str("e15.8")))
          ! WARN("the inverse made to ZERO")
         else
            if (temp<ZERO) then
               ev(i) = (ZERO,ONE)/sqrt(-temp)
             ! WARN("non-positive eigenvalue, " // trim(temp.to_str("e15.8")))
             ! WARN("non-positive definite mx")
            else 
               ev(i) = (ONE,ZERO)/sqrt(temp)
            end
         end

      end

      do i = 1,d
      do j = 1,d
         val = IMAGIFY(ZERO)
         do k = 1,d
            val = val + evec(i,k)*ev(k)*conjg(evec(j,k))
         end
         self(i,j) = val
      end
      end

      evec.destroy
      eval.destroy
      ev.destroy

   end

   to_inverse_sqrt_of_2(R,tol)
   ! self = sqrt(R)^(-1), cannot have R=self
      R :: MAT{CPX}
      tol :: REAL, optional

      evec :: MAT{CPX}* DEFAULT_NULL
      eval :: VEC{REAL}* DEFAULT_NULL
      ev :: VEC{CPX}* DEFAULT_NULL
      d,i,j,k :: INT
      eps,temp :: REAL
      val :: CPX

      eps = TOL(15)
      if (present(tol)) eps = tol

      d = R.dim1
      ev.create(d)
      eval.create(d)
      evec.create(d,d)
      eval=ZERO
      evec=(ZERO,ZERO)

!     R.diagonalize_by_jacobi(eval,evec,eps)
      R.make_real_eigenproblem(eval,evec)

      do i = 1,d

         temp = eval(i)

         if (abs(temp)<eps) then
            ev(i) = (ZERO,ZERO)
            WARN("linear dependence for the eigenvalue, " // trim(temp.to_str("e15.8")))
            WARN("the inverse made to ZERO")
         else
            if (temp<ZERO) then
              ev(i) = (ZERO,ONE)/sqrt(-temp)
              WARN("non-positive eigenvalue, " // trim(temp.to_str("e15.8")))
              WARN("non-positive definite mx")
            else;                 ev(i) = (ONE,ZERO)/sqrt(temp)
            end
         end

      end

      do i = 1,d
      do j = 1,d
         val = IMAGIFY(ZERO)
         do k = 1,d
            val = val + evec(i,k)*ev(k)*conjg(evec(j,k))
         end
         self(i,j) = val
      end
      end

      evec.destroy
      eval.destroy
      ev.destroy

   end

   to_power_series_inverse_of(S,tol,max_it) ::: get_from(MAT{INTRINSIC}), PURE
   ! Set self to the power series inverse square root of "S".
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
   end

   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it) ::: get_from(MAT{INTRINSIC})
   ! Set self to the inverse square root of "S", a matrix which is required to
   ! have a unit diagonal. The method uses a binomial power series expansion.
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
   end

   to_exponential_of(X,tol) ::: get_from(MAT{INTRINSIC})
   ! Exponentiate the matrix "X" using a power series expansion, self = exp(X),
   end

   exponentiate_to(U,tol) ::: get_from(MAT{INTRINSIC}), PURE
   ! Exponentiate the matrix self using a power series expansion, U = exp(self),
   ! so that the maximum deviation from the exact answer is less than "tol"
   ! if present.
   end

   antisymmetric_exponential_to(U,eval,evec) ::: get_from(MAT{INTRINSIC}, EIGEN?=>solve_hermitian_eigenproblem)
   ! Make unitary matrix U = exp(self) where "self" must be antisymmetric.
   ! Uses the formula:  exp A = V (cos P) V^t + V (sin P)/P V^t A
   !                        P = sqrt diag(eig(A^t A))
   ! (c) dylan jayatilaka, university of western australia, 1993
   ! WARNING: Untested in TONTO and looks wrong.
   end

!  =============
!  String widths
!  =============

   str_lengths(dp,spaces) result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Returns the minimal string lengths, with optional extra "spaces"
   end

   get_max_str_length(msl,max_dp,spaces) ::: get_from(MAT{INTRINSIC}), pure
   ! Return "msl" the maximum of the string lengths, keeping "max_dp"
   ! decimal places and including extra "spaces"
   end

!  ===================
!  Spin-orbital blocks
!  ===================

!  Spin block returning routines

   aa_block result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return allocatable the alpha-alpha sector of the matrix
   end

   ba_block result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return allocatable the beta-alpha sector of the matrix
   end

   ab_block result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the allocatable alpha-beta sector of the matrix
   end

   bb_block result (res) ::: get_from(MAT{INTRINSIC}), PURE
   ! Return the allocatable beta-beta sector of the matrix
   end

!  Spin block PTR returning routines

   aa_block_ptr result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the pointer alpha-alpha sector of the matrix
   end

   ba_block_ptr result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the pointer beta-alpha sector of the matrix
   end

   ab_block_ptr result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the pointer alpha-beta sector of the matrix
   end

   bb_block_ptr result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the pointer beta-beta sector of the matrix
   end

!  Spin block set routines

   set_aa_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   set_ba_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Set the beta-alpha sector of the matrix to "X"
   end

   set_ab_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Set the alpha-beta sector of the matrix to "X"
   end

   set_bb_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Set the beta-beta sector of the matrix to "X"
   end


   set_aa_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   set_ba_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Set the beta-alpha sector of the matrix to "X"
   end

   set_ab_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Set the alpha-beta sector of the matrix to "X"
   end

   set_bb_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Set the beta-beta sector of the matrix to "X"
   end


!   set_aa_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
!   ! Set the alpha-alpha sector of the matrix to "X"
!   end
!
!   set_ba_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
!   ! Set the beta-alpha sector of the matrix to "X"
!   end
!
!   set_ab_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
!   ! Set the alpha-beta sector of the matrix to "X"
!   end
!
!   set_bb_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
!   ! Set the beta-beta sector of the matrix to "X"
!   end


   set_aa_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   set_ba_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Set the beta-alpha sector of the matrix to "X"
   end

   set_ab_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Set the alpha-beta sector of the matrix to "X"
   end

   set_bb_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Set the beta-beta sector of the matrix to "X"
   end


!   set_aa_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
!   ! Set the alpha-alpha sector of the matrix to "X"
!   end
!
!   set_ba_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
!   ! Set the beta-alpha sector of the matrix to "X"
!   end
!
!   set_ab_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
!   ! Set the alpha-beta sector of the matrix to "X"
!   end
!
!   set_bb_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
!   ! Set the beta-beta sector of the matrix to "X"
!   end


   set_aa_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   set_ba_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Set the beta-alpha sector of the matrix to "X"
   end

   set_ab_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Set the alpha-beta sector of the matrix to "X"
   end

   set_bb_block_to(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Set the beta-beta sector of the matrix to "X"
   end

!  Spin block put routines

   put_aa_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, CAST?=>), PURE
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   put_ba_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, CAST?=>), PURE
   ! Put the beta-alpha sector of the matrix to "X"
   end

   put_ab_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, CAST?=>), PURE
   ! Put the alpha-beta sector of the matrix to "X"
   end

   put_bb_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, CAST?=>), PURE
   ! Put the beta-beta sector of the matrix to "X"
   end


   put_aa_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, CAST?=>REALIFY), PURE
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   put_ba_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, CAST?=>REALIFY), PURE
   ! Put the beta-alpha sector of the matrix to "X"
   end

   put_ab_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, CAST?=>REALIFY), PURE
   ! Put the alpha-beta sector of the matrix to "X"
   end

   put_bb_block_to(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, CAST?=>REALIFY), PURE
   ! Put the beta-beta sector of the matrix to "X"
   end

!  Spin block plus routines

   aa_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   ba_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Add "X" to the beta-alpha sector of the matrix
   end

   ab_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Add "X" to the alpha-beta sector of the matrix
   end

   bb_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX), PURE
   ! Add "X" to the beta-beta sector of the matrix
   end


   aa_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   ba_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Add "X" to the beta-alpha sector of the matrix
   end

   ab_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Add "X" to the alpha-beta sector of the matrix
   end

   bb_block_plus(X) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL), PURE
   ! Add "X" to the beta-beta sector of the matrix
   end


   aa_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   ba_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
   ! Add "X" to the beta-alpha sector of the matrix
   end

   ab_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
   ! Add "X" to the alpha-beta sector of the matrix
   end

   bb_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>CPX), PURE
   ! Add "X" to the beta-beta sector of the matrix
   end


   aa_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   ba_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Add "X" to the beta-alpha sector of the matrix
   end

   ab_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Add "X" to the alpha-beta sector of the matrix
   end

   bb_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>CPX, FAC?=>REAL), PURE
   ! Add "X" to the beta-beta sector of the matrix
   end


   aa_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   ba_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
   ! Add "X" to the beta-alpha sector of the matrix
   end

   ab_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
   ! Add "X" to the alpha-beta sector of the matrix
   end

   bb_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>CPX), PURE
   ! Add "X" to the beta-beta sector of the matrix
   end


   aa_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   ba_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Add "X" to the beta-alpha sector of the matrix
   end

   ab_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Add "X" to the alpha-beta sector of the matrix
   end

   bb_block_plus(X,fac) ::: get_from(MAT{INTRINSIC}, TYPE?=>REAL, FAC?=>REAL), PURE
   ! Add "X" to the beta-beta sector of the matrix
   end

end
