!==================================================================
!
! TD_DATA
!
! For doing time-dependent SCF calculations. Either DFT or HF.
!
! Copyright (C) Dylan Jayatilaka (2024)
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================

module TD_DATA

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .MOs.destroy 

      .ov.destroy
      .vo.destroy

   end

!  ===============================================
!  Set defaults, reset, update and realted methods
!  ===============================================

   set_defaults ::: leaky, PURE
   ! Set default SCF data values
      self :: INOUT

      ! Tolerances
      .tol_D        = TOL(2)
      .tol_P        = TOL(2)
      .tol_davidson = TOL(2)

      .iteration      = 0
      .min_iterations = 1
      .max_iterations = 3

   end

   set_defaults(n_bf,n_a,n_b,n_occ,n_vir,MOs,MO_energies) ::: leaky, PURE
   ! Set default SCF data values
      self  :: INOUT
      n_bf  :: INT, IN
      n_a   :: INT, IN
      n_b   :: INT, IN
      n_occ :: INT, IN
      n_vir :: INT, IN
      MOs   :: MAT{REAL}, IN
      MO_energies :: VEC{REAL}, IN

      .set_defaults

      .n_bf  = n_bf
      .n_a   = n_a
      .n_b   = n_b
      .n_occ = n_occ
      .n_vir = n_vir

      .MOs   = MOs
      .eig   = MO_energies

   end

   set_max_keep(val) ::: PURE
   ! Set maximum number of eigensolutions to keep.
      self :: INOUT
      val  :: INT, IN

   ENSURE(val>0,"max_keep must be +ve")
   ENSURE(val>.n_eig,"max_keep must be more than n_eig")

      .max_keep = val

   end

   set_method(val) ::: PURE
   ! Set the type of calculation method.
      self :: INOUT
      val  :: STR, IN

   ENSURE(val.is_one_of(["rtd","rhf"]),"unknown method")

      .method = val

   end

   set_n_eig(val) ::: PUREr
   ! Set number of eigensolutions to serach for.
      self :: INOUT
      val  :: INT, IN

   ENSURE(val>0,"n_eig must be +ve")

      .n_eig = val

   end

   set_tol_D(val) ::: PURE
   ! Set double-excitation determinant energy selection tolerance
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>ZERO,"tol must be +ve")

      .tol_D = val

   end

   set_tol_davidson(val) ::: PURE!
   ! Set Davidson iteration convergence tolerance on eigenvectors
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>ZERO,"tol must be +ve")

      .tol_davidson = val

   end

   set_tol_P(val) ::: PURE
   ! Set the density matrix change tolerance for convergence.
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>ZERO,"tol must be +ve")

      .tol_P = val

   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process a command "keyword". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("max_keep=     "); .read_max_keep
      case ("n_eig=        "); .read_n_eig
      case ("tol_d=        "); .read_tol_D
      case ("tol_davidson= "); .read_tol_davidson
      case ("tol_p=        "); .read_tol_P
      case default;            UNKNOWN(word)
      end

   end

   read_max_keep ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_max_keep), private
   ! Generic read and set a quantity with units
   end

   read_method
   ! Read and set the type of calculation "method"
      self :: INOUT

      val :: STR

      stdin.read(val)
      .set_method(val)

   end

   read_n_eig ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_n_eig), private
   ! Generic read and set a quantity with units
   end

   read_tol_D ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_tol_D), private
   ! Generic read and set a quantity with units
   end

   read_tol_davidson ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_tol_davidson), private
   ! Generic read and set a quantity with units
   end

   read_tol_P ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_tol_P), private
   ! Generic read and set a quantity with units
   end

 !  =======
 !  Methods
 !  =======

   no_of_singles result(res) ::: PURE
   ! The number of single excitations which satisfy the tol_window
   ! excitation window.
      self :: IN
      res  :: INT

      e_i,e_a, val :: REAL
      i,a :: INT

      res = 0

      do i = 1,.n_occ
         e_i = .eig(i)
         do a = .n_occ+1,.n_vir
            e_a = .eig(a)
            val = e_a - e_i
            if (val<.tol_window) then
               res = res + 1
            end
         end
      end

   end

   sort_singles ::: leaky, PURE
   ! Sorts the single excitations by smallest energy difference, and
   ! keeps the order in an array.
      self :: INOUT

      i,a,ai, n :: INT
      e_i,e_a,val :: REAL
      ind :: VEC{INT}@

      n = .no_of_singles

      ! Create the o-v indices array
      .single.create(n,2)

      ! Get the energy differences
      .deltaE.create(n)
      ai = 0
      do i = 1,.n_occ
         e_i = .eig(i)
         do a = .n_occ+1,.n_vir
            e_a = .eig(a)
            val = e_a - e_i
            if (val<.tol_window) then
               ai = ai + 1
               .deltaE(ai) = val
               .single(ai,1) = a
               .single(ai,2) = i
            end
         end
      end

      ! Sort
      ind.create(n)
      .deltaE.quick_sort(ind)

      ! Reorder
      .deltaE = .deltaE(ind)
      .single(:,1) = .single(ind,1)
      .single(:,2) = .single(ind,2)

   end

 !  ===============
 !  Output routines
 !  ===============

   put_banner ::: selfless
   ! Prints out the coupled-perturbed banner
      self :: IN

      stdout.flush
      stdout.text("==================")
      stdout.text("Time-dependent SCF")
      stdout.text("==================")
      stdout.flush

   end

   put_options
   ! Prints out a summary of what options are stored in scfdata
      self :: IN

      ::put_banner

      stdout.flush
      stdout.show("Method                    =", .method)

      stdout.flush
      stdout.text("Dimensions")
      stdout.flush
      stdout.show("n_a                       ", .n_a)
      stdout.show("n_b                       ", .n_a)
      stdout.show("n_occ                     ", .n_occ)
      stdout.show("n_vir                     ", .n_occ)

      stdout.flush
      stdout.text("Toreances & iterations:")
      stdout.flush
      stdout.set_real_fortran_fmt("e")
      stdout.show("Excitation window         =", .tol_window)
      stdout.show("Doubles selection tol     =", .tol_D)
      stdout.show("|Delta P| convergence tol =", .tol_P)
      stdout.show("Davidson  convergence tol =", .tol_davidson)
      stdout.show("Minimum # of iterations   =", .min_iterations)
      stdout.show("Maximum # of iterations   =", .max_iterations)

   end

   put_singles
   ! Print out the sorted singles states.
      self :: INOUT

      table :: VEC{TABLE_COLUMN}@

      stdout.flush
      stdout.text("=============================")
      stdout.text("Single excitation state order")
      stdout.text("=============================")

      table.create(3)

      table(1).set_heading("Occ")
      table(2).set_heading("Vir")
      table(3).set_heading("Delta E")

      table(1).set_values(.single(:,2))
      table(2).set_values(.single(:,1))
      table(3).set_values(.deltaE)

      table.put(label_rows=TRUE)

      table.destroy

   end

end
