!==================================================================
!
! TD_DATA
!
! For doing time-dependent SCF calculations. Either DFT or HF.
!
! Copyright (C) Dylan Jayatilaka (2024)
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================

module TD_DATA

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .MOs.destroy 

      .ov.destroy
      .vo.destroy

   end

!  ===============================================
!  Set defaults, reset, update and realted methods
!  ===============================================

   set_defaults ::: leaky, PURE
   ! Set default SCF data values
      self :: INOUT

      ! Tolerances
      .tol_D        = TOL(2)
      .tol_P        = TOL(2)
      .tol_davidson = TOL(2)

      .iteration      = 0
      .min_iterations = 1
      .max_iterations = 3

   end

   set_defaults(n_bf,n_a,n_b,n_occ,n_vir,MOs,MO_energies) ::: leaky, PURE
   ! Set default SCF data values
      self  :: INOUT
      n_bf  :: INT, IN
      n_a   :: INT, IN
      n_b   :: INT, IN
      n_occ :: INT, IN
      n_vir :: INT, IN
      MOs   :: MAT{REAL}, IN
      MO_energies :: VEC{REAL}, IN

      .set_defaults

      .n_bf  = n_bf
      .n_a   = n_a
      .n_b   = n_b
      .n_occ = n_occ
      .n_vir = n_vir

      .MOs   = MOs
      .E     = MO_energies

   end

   set_max_keep(val) ::: PURE
   ! Set maximum number of eigensolutions to keep.
      self :: INOUT
      val  :: INT, IN

   ENSURE(val>0,"max_keep must be +ve")
   ENSURE(val>.n_eig,"max_keep must be more than n_eig")

      .max_keep = val

   end

   set_n_eig(val) ::: PUREr
   ! Set number of eigensolutions to serach for.
      self :: INOUT
      val  :: INT, IN

   ENSURE(val>0,"n_eig must be +ve")

      .n_eig = val

   end

   set_tol_D(val) ::: PURE
   ! Set double-excitation determinant energy selection tolerance
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>ZERO,"tol must be +ve")

      .tol_D = val

   end

   set_tol_davidson(val) ::: PURE!
   ! Set Davidson iteration convergence tolerance on eigenvectors
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>ZERO,"tol must be +ve")

      .tol_davidson = val

   end

   set_tol_P(val) ::: PURE
   ! Set the density matrix change tolerance for convergence.
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>ZERO,"tol must be +ve")

      .tol_P = val

   end

!   set_table ::: leaky, PURE
!   ! Set up the SCF table
!      self :: INOUT
!
!      ! Initialize save margin note data
!      .table_info.destroy
!      .table_info.create(1,20)
!      .set_margin_info
!
!      ! Set table headings
!      if (NOT .fitting) then
!
!         .table.create(5)
!         .table(1).set_heading("Iter")
!         .table(2).set_heading("Energy")
!         .table(2).set_subhead("  E/au")
!         .table(3).set_heading("Delta")
!         .table(3).set_subhead("E")
!         .table(4).set_heading("  DIIS  ")
!         .table(4).set_subhead("Gradient")
!         .table(5).set_width(0)
!
!         ! Table widths
!         .table(1).set_width_from(.max_iterations)
!         .table(2).set_width_from(.energy)
!         .table(3).set_width_from(.energy)
!         .table(4).set_width_from(.energy)
!         .table(5).force_width(0)
!         .table(5).set_left(TRUE)
!         .table(5).set_list_as_column(TRUE)
!
!      else
!
!         .table.create(8)
!         .table(1).set_heading("Iter")
!         .table(2).set_heading("Lambda")
!         .table(2).set_subhead("   L  ")
!         .table(3).set_heading("chi2")
!         .table(4).set_heading("Energy")
!         .table(4).set_subhead(" E/au ")
!         .table(5).set_heading("Penalty")
!         .table(5).set_subhead("E+L*chi2")
!         .table(6).set_heading("Delta")
!         .table(6).set_subhead("penalty")
!         .table(7).set_heading("  DIIS  ")
!         .table(7).set_subhead("Gradient")
!
!         ! Table widths
!         .table(1).set_width_from(.max_iterations)
!         .table(2).set_width_from(.lambda)
!         .table(3).set_width_from(TEN**3*.penalty)
!         .table(4).set_width_from(.energy)
!         .table(5).set_width_from(.fit_value)
!         .table(6).set_width_from(.fit_value)
!         .table(7).set_width_from(.energy)
!         .table(8).force_width(0)
!         .table(8).set_left(TRUE)
!         .table(8).set_list_as_column(TRUE)
!
!      end
!
!   end
!
!   set_CP_table ::: leaky, PURE
!   ! Set up the CP table
!      self :: INOUT
!
!      ! Initialize save margin note data
!      .table_info.destroy
!      .table_info.create(1,20)
!      .set_margin_info
!
!      ! Set table headings
!      .table.create(4)
!      .table(1).set_heading("Iter")
!      .table(2).set_heading("      max")
!      .table(2).set_subhead("|Delta U|")
!      .table(3).set_heading("max DIIS")
!      .table(3).set_subhead("   error")
!      .table(4).set_width(0)
!
!      ! Table widths
!      .table(1).set_width_from(.max_iterations)
!      .table(2).set_width_from(1.0d4)
!      .table(3).set_width_from(1.0d4)
!      .table(4).force_width(0)
!      .table(4).set_left(TRUE)
!      .table(4).set_list_as_column(TRUE)
!
!   end
!
!   set_margin_info(n_notes) ::: PURE
!   ! Set the margin information "info" for the SCF iterations
!   ! This usesd SAVE vafiables, so is not PURE.
!      self :: INOUT
!      n_notes :: INT, optional, OUT
!
!      n,i,s :: INT
!
!      ! Initialize saved switches
!      if (.iteration <= 0) then
!         .delta_E_converged = FALSE
!         .damping_on        = FALSE
!         .damping_off       = FALSE
!         .level_shift_on    = FALSE
!         .level_shift_off   = FALSE
!         .DIIS_converged    = FALSE
!         .DIIS_saving       = FALSE
!         .DIIS_started      = FALSE
!         .DIIS_used_up      = FALSE
!      end
!
!      ! Initialize info
!      n = 0
!      .table_info(1)[:] = " "
!
!      ! No notes ...
!      if (.SCF_done) return
!
!      ! Set margin info ...
!      if (NOT .delta_E_converged AND .delta_converged AND .iteration>0) then
!         n = n + 1
!         .table_info(1)[n] = " *Difference has converged"
!         .delta_E_converged = TRUE
!      end
!
!      if (NOT .DIIS_converged AND .SCF_DIIS.is_converged) then
!         n = n + 1
!         .table_info(1)[n] = " *Gradient has converged"
!         .DIIS_converged = TRUE
!      end
!
!      if (.apply_damping AND NOT .damping_on) then
!         n = n + 1
!         .table_info(1)[n] = " *Damping on"
!         .damping_on = TRUE
!      else if (NOT .apply_damping AND NOT .damping_off) then
!         n = n + 1
!         .table_info(1)[n] = " *Damping was off"
!         .damping_off = TRUE
!      end
!
!      if (.apply_level_shifting AND NOT .level_shift_on) then
!         n = n + 1
!         .table_info(1)[n] = " *Levelshift on"
!         .level_shift_on = TRUE
!      else if (NOT .apply_level_shifting AND NOT .level_shift_off) then
!         n = n + 1
!         .table_info(1)[n] = " *Levelshift was off"
!         .level_shift_off = TRUE
!      end
!
!      if (.using_DIIS) then
!
!         if (.SCF_DIIS.saved_iteration==0 AND NOT .DIIS_saving) then
!            n = n + 1
!            .table_info(1)[n] = " *DIIS starts saving now"
!            .DIIS_saving = TRUE
!         end
!
!         if (.SCF_DIIS.actual_iteration==0 AND NOT .DIIS_started) then
!            n = n + 1
!            .table_info(1)[n] = " *DIIS extrapolates now"
!            .DIIS_started = TRUE
!         end
!
!         if (.SCF_DIIS.subspace_saturated AND .DIIS_used_up) then
!            n = n + 1
!            i = .SCF_DIIS.replaced_iteration
!            s = .SCF_DIIS.new
!            .table_info(1)[n] = " *DIIS replaced saved #"//trim(s.to_str)//" iter #"//trim(i.to_str)
!         end
!
!         if (.SCF_DIIS.kept<=2 AND .DIIS_used_up) then
!            n = n + 1
!            i = .SCF_DIIS.iter_4(1) - 1
!            s = .SCF_DIIS.new
!            if (.SCF_DIIS.kept==1) then
!            .table_info(1)[n] = " *DIIS stuck, total reset"
!            else
!            .table_info(1)[n] = " *DIIS stuck, kept saved #"//trim(s.to_str)//" iter #"//trim(i.to_str)
!            end
!            .DIIS_used_up = FALSE
!         end
!
!         ! This must come last
!         if (.SCF_DIIS.subspace_saturated AND NOT .DIIS_used_up) then
!            n = n + 1
!            .table_info(1)[n] = " *DIIS subspace is saturated"
!            .DIIS_used_up = TRUE
!         end
!
!      end
!
!      if (present(n_notes)) n_notes = n
!
!   end
!
!   reset_Davidson ::: PURE
!   ! Reset the "n_pert" CPHF DIIS extrapolators
!      self :: INOUT
!
!   end

!  =============
!  Input methods
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process a command "keyword". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("max_keep=     "); .read_max_keep
      case ("n_eig=        "); .read_n_eig
      case ("tol_d=        "); .read_tol_D
      case ("tol_davidson= "); .read_tol_davidson
      case ("tol_p=        "); .read_tol_P
      case default;            UNKNOWN(word)
      end

   end

   read_max_keep ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_max_keep), private
   ! Generic read and set a quantity with units
   end

   read_n_eig ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_n_eig), private
   ! Generic read and set a quantity with units
   end

   read_tol_D ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_tol_D), private
   ! Generic read and set a quantity with units
   end

   read_tol_davidson ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_tol_davidson), private
   ! Generic read and set a quantity with units
   end

   read_tol_P ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_tol_P), private
   ! Generic read and set a quantity with units
   end

 !  ===============
 !  Output routines
 !  ===============

   put_banner
   ! Prints out the coupled-perturbed banner
      self :: IN

      stdout.flush
      stdout.text("==================")
      stdout.text("Time-dependent SCF")
      stdout.text("==================")
      stdout.flush

   end

   put_options
   ! Prints out a summary of what options are stored in scfdata
      self :: IN

      stdout.show("Method                    =", .method)

      stdout.flush
      stdout.text("Dimensions")
      stdout.flush
      stdout.show("n_a                       ", .n_a)
      stdout.show("n_b                       ", .n_a)
      stdout.show("n_occ                     ", .n_occ)
      stdout.show("n_vir                     ", .n_occ)

      stdout.flush
      stdout.text("Toreances & iterations:")
      stdout.flush
      stdout.set_real_fortran_fmt("e")
      stdout.show("Doubles selection tol     =", .tol_D)
      stdout.show("|Delta P| convergence tol =", .tol_P)
      stdout.show("Davidson  convergence tol =", .tol_davidson)
      stdout.show("Minimum # of iterations   =", .min_iterations)
      stdout.show("Maximum # of iterations   =", .max_iterations)

   end

!   put_CP_table_body_and_footer(flush)
!   ! Print out the CP results for the current iteration. 
!   ! If converged, print out footer as well.
!   ! NOTE: must have called put_CP_table_head before!
!      self :: INOUT
!      flush :: BIN, optional, IN
!
!      if (NOT .output) return
!
!      if (NOT .SCF_done) then
!
!         ! Set margin notes ...
!         .set_margin_info
!
!         ! Set table body (leaky)
!         if (NOT .fitting) then
!            .table(1).set_values([.iteration])
!            .table(2).set_values([.delta])
!            .table(3).set_values([.DIIS_error])
!            .table(4).set_values(.table_info)
!            .table(4).force_width(0)
!         end
!
!         ! Put out the body
!         if (.iteration>0) .table.put_body
!
!         ! Clear columns for next time (UNleaky!)
!         .table.clear_columns
!
!      else ! the SCF is done ...
!
!         .table.put_footer
!        
!         stdout.flush
!         if (.converged) then; stdout.text("Converged")
!         else;                 stdout.text("NOT Converged")
!         end
!        
!         .table.put_body
!         .table.put_footer(flush=flush)
!
!      end
!
!   end

end
