!-------------------------------------------------------------------------------
!
! ATOM: can be a quantum mechanical atom, with a basis set
!       or a molecular mechanical atom with a force field potential
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: atom.foo 4409 2014-06-10 03:32:55Z durhammike $
!-------------------------------------------------------------------------------

module ATOM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!  ===============
!  Data statements
!  ===============

   !  The Periodic Table

   element_symbols :: VEC{STR}(len=2,118)

   data element_symbols/ &
    "H ",                                                                                "He", &
    "Li","Be",                                                  "B ","C ","N ","O ","F ","Ne", &
    "Na","Mg",                                                  "Al","Si","P ","S ","Cl","Ar", &
    "K ","Ca","Sc","Ti","V ","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr", &
    "Rb","Sr","Y ","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I ","Xe", &
    "Cs","Ba","La",     "Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu", &
                   "Hf","Ta","W ","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn", &
    "Fr","Ra","Ac",     "Th","Pa","U ","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr", &
                   "Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Ut","Fl","Up","Lv","Us","Uo"/

   element_names :: VEC{STR}(len=13,118)

   data element_names/ &
    "Hydrogen     ","Helium       ", &
    "Lithium      ","Beryllium    ", &
    "Boron        ","Carbon       ","Nitrogen     ","Oxygen       ","Fluorine     ","Neon         ", &
    "Sodium       ","Magnesium    ", &
    "Aluminium    ","Silicon      ","Phosphorous  ","Sulfur       ","Chlorine     ","Argon        ", &
    "Potassium    ","Calcium      ", &
    "Scandium     ","Titanium     ","Vanadium     ","Chromium     ","Manganese    ", &
    "Iron         ","Cobalt       ","Nickel       ","Copper       ","Zinc         ", &
    "Gallium      ","Germanium    ","Arsenic      ","Selinium     ","Bromine      ","Krypton      ", &
    "Rubidium     ","Strontium    ", &
    "Yttrium      ","Zirconium    ","Niobium      ","Molybdenum   ","Technitium   ", &
    "Ruthenium    ","Rhodium      ","Palladium    ","Silver       ","Cadmium      ", &
    "Indium       ","Tin          ","Antimony     ","Tellurium    ","Iodine       ","Xenon        ", &
    "Cesium       ","Barium       ", &
    "Lanthanum    ", &
    "Cerium       ","Praseodymium ","Neodymium    ","Promethium   ","Samarium     ","Europium     ","Gadolinium   ", &
    "Terbium      ","Dysprosium   ","Holmium      ","Erbium       ","Thulium      ","Ytterbium    ","Lutetium     ", &
                    "Haffnium     ","Tantalum     ","Tangsten     ","Rhenium      ", &
    "Osmium       ","Iridium      ","Platinum     ","Gold         ","Mercury      ", &
    "Thallium     ","Lead         ","Bismuth      ","Polonium     ","Astatine     ","Radon        ", &
    "Francium     ","Radium       ", &
    "Actinium     ", &
    "Thorium      ","Protactinium ","Uranium      ","Neptunium    ","Plutonium    ","Americium    ","Curium       ", &
    "Berkellium   ","Californium  ","Einsteinium  ","Fermium      ","Mendelevium  ","Nobelium     ","Lawrencium   ", &
                    "Rutherfordium","Dubnuim      ","Seaborgium   ","Bohrium      ", &
    "Hassium      ","Meitnerium   ","Darmstadtium ","Roentgenium  ","Copernicum   ", &
    "Ununtrium    ","Flerovium    ","Ununpentium  ","Livermorium  ","Ununseptium  ","Ununoctium   "/

   !  Bragg-Slater radii taken from Aaron Lee's code
   !  WARNING: this is in Angstroms!

   bragg_slater_radii :: VEC{REAL}(54)

   data bragg_slater_radii/ &
      0.35d0,                                          0.35d0, &
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, &
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, &
      2.20d0,1.80d0, &
                    1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,1.40d0,1.35d0,1.35d0,1.35d0,1.35d0, &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, &
      1.30d0,1.30d0, &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0, &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0  /

   atom_bonded_range_factor :: REAL = ATOM_BONDED_RANGE_FACTOR
   atom_vdw_bonded_range_pc :: REAL = 10.0d0

   ! Covalent radii, where do they come from? in Angstrom x 100

   covalent_radii_invariom :: VEC{INT}(109)

   data covalent_radii_invariom/ &
      37,                                                                                   0, &
      123,  90,                                                    80,  77,  74,  71,  72,   0, &
      154, 136,                                                   118, 111, 106, 102,  99,   0, &
      203, 174, 144, 132, 122, 118, 117, 117, 116, 115, 117, 125, 126, 122, 120, 116, 114,   0, &
      218, 191, 162, 145, 134, 130, 127, 125, 125, 128, 134, 148, 144, 141, 140, 136, 133,   0, &
      235, 198, &
               169, 165, 165, 164, 164, 162, 185, 161, 159, 159, 157, 157, 156, 170, &
               156, 144, 134, 130, 128, 126, 127, 130, 134, 149, 148, 147, 146, 146, 145,   0, &
       0,   0, &
               188, 165, 161, 142, 130, 151, 182,   0,   0,   0,   0,   0,   0,   0, &
                 0,   0,   0,   0,   0,   0,   0 /

   ! Allred-Rochow electronegativities, where do they come from?
   ! Values x 100

   allred_rochow_electronegs :: VEC{INT}(85)

   data allred_rochow_electronegs/ &
      220,                                                                                 550, &
      97, 147,                                                   201, 250, 307, 350, 440, 480, &
      101, 123,                                                   147, 174, 206, 244, 283, 320, &
      91, 104, 120, 132, 145, 156, 160, 164, 170, 175, 175, 166, 182, 202, 220, 248, 274, 290, &
      89,  99, 111, 122, 123, 130, 136, 142, 145, 130, 142, 146, 149, 172, 182, 201, 221, 240, &
      86,  97, &
               108, 108, 107, 107, 107, 107, 110, 111, 110, 110, 110, 111, 111, 106, &
               114, 123, 133, 140, 146, 152, 155, 142, 142, 144, 144, 155, 167, 176, 190 /

   covalent_radii_ccdc :: VEC{REAL}(110)

   data covalent_radii_ccdc/ &
      0.23d0, 1.50d0, 1.28d0, 0.96d0, 0.83d0, 0.68d0, 0.68d0, 0.68d0, 0.64d0, 1.50d0, &
      1.66d0, 1.41d0, 1.21d0, 1.20d0, 1.05d0, 1.02d0, 0.99d0, 1.51d0, 2.03d0, 1.76d0, &
      1.70d0, 1.60d0, 1.53d0, 1.39d0, 1.61d0, 1.52d0, 1.26d0, 1.24d0, 1.32d0, 1.22d0, &
      1.22d0, 1.17d0, 1.21d0, 1.22d0, 1.21d0, 1.50d0, 2.20d0, 1.95d0, 1.90d0, 1.75d0, &
      1.64d0, 1.54d0, 1.47d0, 1.46d0, 1.45d0, 1.39d0, 1.45d0, 1.44d0, 1.42d0, 1.39d0, &
      1.39d0, 1.47d0, 1.40d0, 1.50d0, 2.44d0, 2.15d0, 2.07d0, 2.04d0, 2.03d0, 2.01d0, &
      1.99d0, 1.98d0, 1.98d0, 1.96d0, 1.94d0, 1.92d0, 1.92d0, 1.89d0, 1.90d0, 1.87d0, &
      1.87d0, 1.75d0, 1.70d0, 1.62d0, 1.51d0, 1.44d0, 1.41d0, 1.36d0, 1.50d0, 1.32d0, &
      1.45d0, 1.46d0, 1.48d0, 1.40d0, 1.21d0, 1.50d0, 2.60d0, 2.21d0, 2.15d0, 2.06d0, &
      2.00d0, 1.96d0, 1.90d0, 1.87d0, 1.80d0, 1.69d0, 1.54d0, 1.83d0, 1.50d0, 1.50d0, &
      1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0  /

   ! Van der Waals radii from CCDC, in Angstrom

   vdw_radii_ccdc :: VEC{REAL}(110)

   data vdw_radii_ccdc/ &
      1.09d0, 1.40d0, 1.82d0, 2.00d0, 2.00d0, 1.70d0, 1.55d0, 1.52d0, 1.47d0, 1.54d0, &
      2.27d0, 1.73d0, 2.00d0, 2.10d0, 1.80d0, 1.80d0, 1.75d0, 1.88d0, 2.75d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.63d0, 1.40d0, 1.39d0, &
      1.87d0, 2.00d0, 1.85d0, 1.90d0, 1.85d0, 2.02d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.63d0, 1.72d0, 1.58d0, 1.93d0, 2.17d0, &
      2.00d0, 2.06d0, 1.98d0, 2.16d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.72d0, 1.66d0, 1.55d0, &
      1.96d0, 2.02d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 1.86d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0 /

   ! Abundance weighted atomic masses taken from the WWW to be the
   ! same as Turbomol. This should be updated to a proper source.

   atomic_masses :: VEC{REAL}(92)

   data atomic_masses/ &
       1.007970d0,   4.002600d0, &
       6.939000d0,   9.012200d0,  10.811000d0,  12.011150d0,  14.006700d0,  15.999400d0,  18.998400d0,  20.183000d0, &
      22.989800d0,  24.312000d0,  26.981500d0,  28.086000d0,  30.973800d0,  32.064000d0,  35.453000d0,  39.948000d0, &
      39.102000d0,  40.080000d0, &
                    44.956000d0,  47.900000d0,  50.942000d0,  51.996000d0,  54.938000d0, &
                    55.850000d0,  58.933200d0,  58.710000d0,  63.540000d0,  65.370000d0, &
                                  69.720000d0,  72.590000d0,  74.921600d0,  78.960000d0,  79.909000d0,  83.800000d0, &
      85.470000d0,  87.620000d0,  &
                    88.905000d0,  91.220000d0,  92.906000d0,  95.940000d0,  99.000000d0, &
                   101.070000d0, 102.905000d0, 106.400000d0, 107.870000d0, 112.400000d0, &
                                 114.820000d0, 118.690000d0, 121.750000d0, 127.600000d0, 126.904000d0, 131.300000d0, &
      132.905000d0, 137.330000d0, &
                   138.910000d0, 140.115000d0, 140.908000d0, 144.240000d0, 146.920000d0, 150.360000d0, 151.965000d0, &
                   157.250000d0, 158.925000d0, 162.500000d0, 164.930000d0, 167.260000d0, 168.930000d0, 173.040000d0, &
                   174.970000d0, 178.490000d0, 180.950000d0, 183.850000d0, 186.210000d0, &
                   190.200000d0, 192.220000d0, 195.080000d0, 196.070000d0, 200.590000d0, &
                                 204.380000d0, 207.200000d0, 208.980000d0, 208.980000d0, 209.990000d0, 222.020000d0, &
      223.020000d0, 226.030000d0, &
                   227.030000d0, 232.040000d0, 231.040000d0, 238.030000d0/

   ! Abundance-weighted coherent neutron scattering lengths in fm
   ! taken from: International Tables for Crystallography, Vol. C,
   ! 2004, Table 4.2.6.8 pp 255-257

   neutron_scattering_lengths :: VEC{REAL}(95)

   data neutron_scattering_lengths/ &
      -3.7390d0,  3.2600d0, &
      -1.9000d0,  7.7900d0,  5.3000d0,  6.6460d0,  9.3600d0,  5.8030d0,  5.6540d0,  4.5470d0, &
       3.6300d0,  5.3750d0,  3.4490d0,  4.1490d0,  5.1300d0,  2.8470d0,  9.5770d0,  1.9090d0, &
       3.7100d0,  4.9000d0, &
                 12.2900d0, -3.4380d0,  -.3824,  3.6350d0, -3.7300d0, &
                  9.5400d0,  2.5000d0, 10.3000d0,  7.7180d0,  5.6890d0, &
                             7.2879d0,  8.1929d0,  6.5800d0,  7.9700d0,  6.7950d0,  7.8000d0, &
       7.0800d0,  7.0200d0, &
                  7.7500d0,  7.1600d0,  7.0540d0,  6.9500d0,  6.8000d0, &
                  7.2100d0,  5.8800d0,  5.9100d0,  5.9220d0,  5.1000d0, &
                             4.0650d0,  6.2257d0,  5.5700d0,  5.8000d0,  5.2800d0,  4.8500d0, &
       5.4200d0,  5.0600d0, &
                  8.2400d0,  4.8400d0,  4.4500d0,  7.6900d0, 12.6000d0,  4.2000d0,  6.7300d0, &
                  9.5000d0,  7.3800d0, 16.9000d0,  8.0800d0,  8.0300d0,  7.0700d0, 12.4100d0, &
                  7.2100d0,  7.7700d0,  6.9100d0,  4.7700d0,  9.2000d0, &
                 11.0000d0, 10.6000d0,  9.6000d0,  7.6300d0, 12.6920d0, &
                             8.7760d0,  9.4017d0,  8.5307d0,  0.0000d0,  0.0000d0,  0.0000d0, &
       0.0000d0, 10.0000d0, &
                  0.0000d0, 10.6300d0,  9.1000d0,  8.4170d0, 10.5500d0, 14.1000d0,  8.3000d0/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Cr wavelength = 2.289620 A.

   dispersion_correction_Cr :: VEC{CPX}(92)

   data dispersion_correction_Cr/ &
    (  0.0d0   ,  0.0d0   ), (  0.0d0   ,  0.0d0   ), (  0.0023d0,  0.0008d0), (  0.0083d0,  0.0033d0), (  0.0190d0,  0.0094d0), &
    (  0.0364d0,  0.0213d0), (  0.0606d0,  0.0416d0), (  0.0928d0,  0.0731d0), (  0.1324d0,  0.1192d0), (  0.1793d0,  0.1837d0), &
    (  0.2295d0,  0.2699d0), (  0.2778d0,  0.3812d0), (  0.3260d0,  0.5212d0), (  0.3647d0,  0.6921d0), (  0.3898d0,  0.8984d0), &
    (  0.3899d0,  1.1410d0), (  0.3508d0,  1.4222d0), (  0.2609d0,  1.7458d0), (  0.0914d0,  2.1098d0), ( -0.1987d0,  2.5138d0), &
    ( -0.6935d0,  2.9646d0), ( -1.6394d0,  3.4538d0), ( -4.4818d0,  0.4575d0), ( -2.1308d0,  0.5468d0), ( -1.5980d0,  0.6479d0), &
    ( -1.2935d0,  0.7620d0), ( -1.0738d0,  0.8897d0), ( -0.9005d0,  1.0331d0), ( -0.7338d0,  1.1930d0), ( -0.6166d0,  1.3712d0), &
    ( -0.4989d0,  1.5674d0), ( -0.3858d0,  1.7841d0), ( -0.2871d0,  2.0194d0), ( -0.1919d0,  2.2784d0), ( -0.1095d0,  2.5578d0), &
    ( -0.0316d0,  2.8669d0), (  0.0247d0,  3.1954d0), (  0.1037d0,  3.6029d0), (  0.1263d0,  3.9964d0), (  0.1338d0,  4.4226d0), &
    (  0.1211d0,  4.8761d0), (  0.0801d0,  5.3484d0), ( -0.0025d0,  5.8597d0), ( -0.1091d0,  6.4069d0), ( -0.2630d0,  6.9820d0), &
    ( -0.4640d0,  7.5938d0), ( -0.7387d0,  8.2358d0), ( -1.1086d0,  8.9174d0), ( -1.5975d0,  9.6290d0), ( -2.2019d0, 10.3742d0), &
    ( -3.0637d0, 11.1026d0), ( -4.2407d0, 11.8079d0), ( -5.6353d0, 12.6156d0), ( -8.1899d0, 11.7407d0), (-10.3310d0, 12.8551d0), &
    (-11.0454d0, 10.0919d0), (-12.8190d0,  3.5648d0), ( -9.3304d0,  3.8433d0), ( -7.9841d0,  4.1304d0), ( -7.1451d0,  4.4278d0), &
    ( -6.5334d0,  4.7422d0), ( -6.0570d0,  5.0744d0), ( -5.6630d0,  5.4178d0), ( -5.3778d0,  5.7756d0), ( -5.0951d0,  6.1667d0), &
    ( -4.8149d0,  6.5527d0), ( -4.5887d0,  6.9619d0), ( -4.4106d0,  7.3910d0), ( -4.2698d0,  7.8385d0), ( -4.1523d0,  8.2969d0), &
    ( -4.0630d0,  8.7649d0), ( -4.0564d0,  9.2832d0), ( -3.9860d0,  9.8171d0), ( -3.9270d0, 10.3696d0), ( -3.9052d0, 10.9346d0), &
    ( -3.9016d0, 11.5251d0), ( -3.9049d0, 12.1453d0), ( -3.9435d0, 12.7910d0), ( -3.9908d0, 13.4551d0), ( -4.1029d0, 14.1473d0), &
    ( -4.2233d0, 14.8643d0), ( -4.4167d0, 15.5987d0), ( -4.6533d0, 16.3448d0), ( -4.9604d0, 17.1410d0), ( -5.3399d0, 17.9390d0), &
    ( -5.7275d0, 18.7720d0), ( -6.2180d0, 19.6009d0), ( -6.7502d0, 20.4389d0), ( -7.4161d0, 21.3053d0), ( -8.2118d0, 22.2248d0), &
    ( -9.4459d0, 23.1548d0), ( -9.9362d0, 23.1239d0)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Cu wavelength = 1.540520 A.

   dispersion_correction_Cu :: VEC{CPX}(92)

   data dispersion_correction_Cu/ &
    (  0.0000d0,  0.0000d0), (  0.0000d0,  0.0000d0), (  0.0008d0,  0.0003d0), (  0.0038d0,  0.0014d0), (  0.0090d0,  0.0039d0), &
    (  0.0181d0,  0.0091d0), (  0.0311d0,  0.0180d0), (  0.0492d0,  0.0322d0), (  0.0727d0,  0.0534d0), (  0.1019d0,  0.0833d0), &
    (  0.1353d0,  0.1239d0), (  0.1719d0,  0.1771d0), (  0.2130d0,  0.2455d0), (  0.2541d0,  0.3302d0), (  0.2955d0,  0.4335d0), &
    (  0.3331d0,  0.5567d0), (  0.3639d0,  0.7018d0), (  0.3843d0,  0.8717d0), (  0.3868d0,  1.0657d0), (  0.3641d0,  1.2855d0), &
    (  0.3119d0,  1.5331d0), (  0.2191d0,  1.8069d0), (  0.0687d0,  2.1097d0), ( -0.1635d0,  2.4439d0), ( -0.5299d0,  2.8052d0), &
    ( -1.1336d0,  3.1974d0), ( -2.3653d0,  3.6143d0), ( -3.0029d0,  0.5091d0), ( -1.9646d0,  0.5888d0), ( -1.5491d0,  0.6778d0), &
    ( -1.2846d0,  0.7763d0), ( -1.0885d0,  0.8855d0), ( -0.9300d0,  1.0051d0), ( -0.7943d0,  1.1372d0), ( -0.6763d0,  1.2805d0), &
    ( -0.5657d0,  1.4385d0), ( -0.4688d0,  1.6079d0), ( -0.3528d0,  1.8200d0), ( -0.2670d0,  2.0244d0), ( -0.1862d0,  2.2449d0), &
    ( -0.1121d0,  2.4826d0), ( -0.0483d0,  2.7339d0), (  0.0057d0,  3.0049d0), (  0.0552d0,  3.2960d0), (  0.0927d0,  3.6045d0), &
    (  0.1215d0,  3.9337d0), (  0.1306d0,  4.2820d0), (  0.1185d0,  4.6533d0), (  0.0822d0,  5.0449d0), (  0.0259d0,  5.4591d0), &
    ( -0.0562d0,  5.8946d0), ( -0.1759d0,  6.3531d0), ( -0.3257d0,  6.8362d0), ( -0.5179d0,  7.3500d0), ( -0.7457d0,  7.9052d0), &
    ( -1.0456d0,  8.4617d0), ( -1.4094d0,  9.0376d0), ( -1.8482d0,  9.6596d0), ( -2.4164d0, 10.2820d0), ( -3.1807d0, 10.9079d0), &
    ( -4.0598d0, 11.5523d0), ( -5.3236d0, 12.2178d0), ( -8.9294d0, 11.1857d0), ( -8.8380d0, 11.9157d0), ( -9.1472d0,  9.1891d0), &
    ( -9.8046d0,  9.8477d0), (-14.9734d0,  3.7046d0), ( -9.4367d0,  3.9380d0), ( -8.0393d0,  4.1821d0), ( -7.2108d0,  4.4329d0), &
    ( -6.6179d0,  4.6937d0), ( -6.1794d0,  4.9776d0), (  5.7959d0,  5.2718d0), ( -5.4734d0,  5.5774d0), ( -5.2083d0,  5.8923d0), &
    ( -4.9801d0,  6.2216d0), ( -4.7710d0,  6.5667d0), ( -4.5932d0,  6.9264d0), ( -4.4197d0,  7.2980d0), ( -4.2923d0,  7.6849d0), &
    ( -4.1627d0,  8.0900d0), ( -4.0753d0,  8.5060d0), ( -4.0111d0,  8.9310d0), ( -3.9670d0,  9.3834d0), ( -3.9588d0,  9.8433d0), &
    ( -3.9487d0, 10.3181d0), ( -3.9689d0, 10.8038d0), ( -4.0088d0, 11.2969d0), ( -4.0794d0, 11.7994d0), ( -4.1491d0, 12.3296d0), &
    ( -4.2473d0, 12.8681d0), ( -4.3638d0, 13.4090d0)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Mo wavelength = 0.709260 A.

   dispersion_correction_Mo :: VEC{CPX}(92)

   data dispersion_correction_Mo/ &
    (  0.0000d0,  0.0000d0), (  0.0000d0,  0.0000d0), ( -0.0003d0,  0.0001d0), (  0.0005d0,  0.0002d0), (  0.0013d0,  0.0007d0),  &
    (  0.0033d0,  0.0016d0), (  0.0061d0,  0.0033d0), (  0.0106d0,  0.0060d0), (  0.0171d0,  0.0103d0), (  0.0259d0,  0.0164d0),  &
    (  0.0362d0,  0.0249d0), (  0.0486d0,  0.0363d0), (  0.0645d0,  0.0514d0), (  0.0817d0,  0.0704d0), (  0.1023d0,  0.0942d0),  &
    (  0.1246d0,  0.1234d0), (  0.1484d0,  0.1585d0), (  0.1743d0,  0.2003d0), (  0.2009d0,  0.2494d0), (  0.2262d0,  0.3064d0),  &
    (  0.2519d0,  0.3716d0), (  0.2776d0,  0.4457d0), (  0.3005d0,  0.5294d0), (  0.3209d0,  0.6236d0), (  0.3368d0,  0.7283d0),  &
    (  0.3463d0,  0.8444d0), (  0.3494d0,  0.9721d0), (  0.3393d0,  1.1124d0), (  0.3201d0,  1.2651d0), (  0.2839d0,  1.4301d0),  &
    (  0.2307d0,  1.6083d0), (  0.1547d0,  1.8001d0), (  0.0499d0,  2.0058d0), ( -0.0929d0,  2.2259d0), ( -0.2901d0,  2.4595d0),  &
    ( -0.5574d0,  2.7079d0), ( -0.9393d0,  2.9676d0), ( -1.5307d0,  3.2498d0), ( -2.7962d0,  3.5667d0), ( -2.9673d0,  0.5597d0),  &
    ( -2.0727d0,  0.6215d0), ( -1.6857d0,  0.6857d0), ( -1.4390d0,  0.7593d0), ( -1.2594d0,  0.8363d0), ( -1.1178d0,  0.9187d0),  &
    ( -0.9988d0,  1.0072d0), ( -0.8971d0,  1.1015d0), ( -0.8075d0,  1.2024d0), ( -0.7276d0,  1.3100d0), ( -0.6537d0,  1.4246d0),  &
    ( -0.5866d0,  1.5461d0), ( -0.5308d0,  1.6751d0), ( -0.4742d0,  1.8119d0), ( -0.4205d0,  1.9578d0), ( -0.3680d0,  2.1192d0),  &
    ( -0.3244d0,  2.2819d0), ( -0.2871d0,  2.4523d0), ( -0.2486d0,  2.6331d0), ( -0.2180d0,  2.8214d0), ( -0.1943d0,  3.0179d0),  &
    ( -0.1753d0,  3.2249d0), ( -0.1638d0,  3.4418d0), ( -0.1578d0,  3.6682d0), ( -0.1653d0,  3.9035d0), ( -0.1723d0,  4.1537d0),  &
    ( -0.1892d0,  4.4098d0), ( -0.2175d0,  4.6783d0), ( -0.2586d0,  4.9576d0), ( -0.3139d0,  5.2483d0), ( -0.3850d0,  5.5486d0),  &
    ( -0.4720d0,  5.8584d0), ( -0.5830d0,  6.1852d0), ( -0.7052d0,  6.5227d0), ( -0.8490d0,  6.8722d0), ( -1.0185d0,  7.2310d0),  &
    ( -1.2165d0,  7.6030d0), ( -1.4442d0,  7.9887d0), ( -1.7033d0,  8.3905d0), ( -2.0133d0,  8.8022d0), ( -2.3894d0,  9.2266d0),  &
    ( -2.8358d0,  9.6688d0), ( -3.3944d0, 10.1111d0), ( -4.1077d0, 10.2566d0), ( -5.1210d0, 11.0496d0), ( -7.9122d0,  9.9777d0),  &
    ( -8.0659d0, 10.4580d0), ( -7.2224d0,  7.7847d0), ( -6.7704d0,  8.1435d0), ( -6.8494d0,  8.5178d0), ( -7.2400d0,  8.8979d0),  &
    ( -8.0334d0,  9.2807d0), ( -9.6767d0,  9.6646d0)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Ag wavelength = 0.559360 A.

   dispersion_correction_Ag :: VEC{CPX}(92)

   data dispersion_correction_Ag/ &
    (  0.0000d0,  0.0000d0), (  0.0000d0,  0.0000d0), ( -0.0004d0,  0.0000d0), (  0.0001d0,  0.0001d0), (  0.0004d0,  0.0004d0),  &
    (  0.0015d0,  0.0009d0), (  0.0030d0,  0.0019d0), (  0.0056d0,  0.0036d0), (  0.0096d0,  0.0061d0), (  0.0152d0,  0.0098d0),  &
    (  0.0218d0,  0.0150d0), (  0.0298d0,  0.0220d0), (  0.0406d0,  0.0313d0), (  0.0522d0,  0.0431d0), (  0.0667d0,  0.0580d0),  &
    (  0.0826d0,  0.0763d0), (  0.0998d0,  0.0984d0), (  0.1191d0,  0.1249d0), (  0.1399d0,  0.1562d0), (  0.1611d0,  0.1926d0),  &
    (  0.1892d0,  0.2348d0), (  0.2060d0,  0.2830d0), (  0.2276d0,  0.3376d0), (  0.2496d0,  0.3992d0), (  0.2704d0,  0.4681d0),  &
    (  0.2886d0,  0.5448d0), (  0.3050d0,  0.6296d0), (  0.3147d0,  0.7232d0), (  0.3240d0,  0.8257d0), (  0.3242d0,  0.9375d0),  &
    (  0.3179d0,  1.0589d0), (  0.3016d0,  1.1903d0), (  0.2758d0,  1.3314d0), (  0.2367d0,  1.4831d0), (  0.1811d0,  1.6452d0),  &
    (  0.1067d0,  1.8192d0), (  0.0068d0,  2.0025d0), ( -0.1172d0,  2.2025d0), ( -0.2879d0,  2.4099d0), ( -0.5364d0,  2.6141d0),  &
    ( -0.8282d0,  2.8404d0), ( -1.2703d0,  3.0978d0), ( -2.0087d0,  3.3490d0), ( -5.3630d0,  3.6506d0), ( -2.5280d0,  0.5964d0),  &
    ( -1.9556d0,  0.6546d0), ( -1.6473d0,  0.7167d0), ( -1.4396d0,  0.7832d0), ( -1.2843d0,  0.8542d0), ( -1.1587d0,  0.9299d0),  &
    ( -1.0547d0,  1.0104d0), ( -0.9710d0,  1.0960d0), ( -0.8919d0,  1.1868d0), ( -0.8200d0,  1.2838d0), ( -0.7527d0,  1.3916d0),  &
    ( -0.6940d0,  1.5004d0), ( -0.6411d0,  1.6148d0), ( -0.5890d0,  1.7358d0), ( -0.5424d0,  1.8624d0), ( -0.5012d0,  1.9950d0),  &
    ( -0.4626d0,  2.1347d0), ( -0.4287d0,  2.2815d0), ( -0.3977d0,  2.4351d0), ( -0.3741d0,  2.5954d0), ( -0.3496d0,  2.7654d0),  &
    ( -0.3302d0,  2.9404d0), ( -0.3168d0,  3.1241d0), ( -0.3091d0,  3.3158d0), ( -0.3084d0,  3.5155d0), ( -0.3157d0,  3.7229d0),  &
    ( -0.3299d0,  3.9377d0), ( -0.3548d0,  4.1643d0), ( -0.3831d0,  4.3992d0), ( -0.4201d0,  4.6430d0), ( -0.4693d0,  4.8944d0),  &
    ( -0.5280d0,  5.1558d0), ( -0.5977d0,  5.4269d0), ( -0.6812d0,  5.7081d0), ( -0.7638d0,  5.9978d0), ( -0.8801d0,  6.2989d0),  &
    ( -1.0117d0,  6.6090d0), ( -1.1676d0,  6.9287d0), ( -1.3494d0,  7.2566d0), ( -1.5613d0,  7.5986d0), ( -1.8039d0,  7.9509d0),  &
    ( -2.0847d0,  8.3112d0), ( -2.4129d0,  8.6839d0), ( -2.8081d0,  9.0614d0), ( -3.2784d0,  9.4502d0), ( -3.8533d0,  9.8403d0),  &
    ( -4.6067d0, 10.2413d0), ( -5.7225d0, 10.6428d0)/

   ! Spackman's a-coefficients for the dispersion part of the
   ! atom-atom potentials (in au).  Unknown values assigned 0.000
   ! Hydrogen a-coefficient is for the xi = 1.24 contraction
   ! (Hydrogen xi = 1.00 has a a-coefficient of 2.549 au ... not reported in table)
   ! See Spackman M. A. (1986) J. Chem. Phys. 85 p. 6579

   Spackman86_a_6_disp_coeff :: VEC{REAL}(110), public

   data Spackman86_a_6_disp_coeff / &
      1.337d0,  0.000d0,  0.000d0,  0.000d0,  9.740d0,  7.029d0,  5.240d0,  4.204d0,  3.233d0,  0.000d0, &
      0.000d0,  0.000d0, 21.491d0, 16.726d0, 13.261d0, 11.633d0,  9.611d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
     22.981d0, 19.744d0, 15.908d0, 14.799d0, 12.920d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0 /

   ! Spackman's b- and c-coefficients for fitting exp-6 functional
   ! form to the Gordon-Kim repulsive potentials (in au and au-1
   ! respectively). Unknown values assigned 0.0000.
   ! Hydrogen b-coefficient is for the xi=1.24 contraction
   ! (Hydrogen xi = 1.00 has a b-coefficient of 1.2010 au ... not reported in table)
   ! (Hydrogen xi = 1.00 has a c-coefficient of 0.685 au-1 ... not reported in table)
   ! See Spackman M. A. (1986) J. Chem. Phys. 85 p. 6579

   Spackman86_b_exp_prefactor :: VEC{REAL}(110), public
   Spackman86_c_exp_exponent  :: VEC{REAL}(110), public

   data Spackman86_b_exp_prefactor/ &
      1.6615d0,  0.0000d0,  0.0000d0,  0.0000d0,  3.4281d0,  5.8459d0,  9.2090d0,  9.8367d0, 11.3149d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  3.2590d0,  6.1511d0, 10.6743d0, 14.3528d0, 19.8508d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
     13.3691d0, 15.0062d0, 21.5022d0, 19.7261d0, 25.9946d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0 /

   data Spackman86_c_exp_exponent/ &
      0.871d0, 0.000d0, 0.000d0, 0.000d0, 0.642d0, 0.793d0, 0.939d0, 1.005d0, 1.092d0, 0.000d0, &
      0.000d0, 0.000d0, 0.565d0, 0.653d0, 0.757d0, 0.829d0, 0.916d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.754d0, 0.772d0, 0.836d0, 0.838d0, 0.899d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0 /

   ! a-coefficients for dispersion term of atom-atom potentials (au)
   ! These are related to Grimme's C6 coefficients, where a = sqrt(C6).
   ! Coefficients for H-Xe defined. Unknown values assigned 0.00.
   ! See Grimme S. (2006) J. Comp. Chem. 27(15) p. 1787
   ! 
   !  0.14,   0.08,  1.61,  1.61,  3.13,  1.75,  1.23,  0.70,  0.75,  0.63, 
   !  5.71,   5.71, 10.79,  9.23,  7.84,  5.57,  5.07,  4.61, 10.80, 10.80, 
   !  10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80,
   !  16.99, 17.10, 16.37, 12.64, 12.47, 12.01, 24.67, 24.67, 24.67, 24.67, 
   !  24.67, 24.67, 24.67, 24.67, 24.67, 24.67, 24.67, 24.67, 37.32, 38.71, 
   !  38.44, 31.74, 31.50, 29.99


   Grimme06_a_6_disp_coeff :: VEC{REAL}(110), public

   data Grimme06_a_6_disp_coeff / &
       1.56d0,  1.18d0,  5.28d0,  5.28d0,  7.37d0,  5.51d0,  4.62d0,  3.48d0,  3.61d0,  3.31d0, &
       9.95d0,  9.95d0, 13.68d0, 12.65d0, 11.66d0,  9.83d0,  9.38d0,  8.94d0, 13.69d0, 13.69d0, &
      13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, &
      17.17d0, 17.22d0, 16.85d0, 14.81d0, 14.71d0, 14.43d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, &
      20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 25.44d0, 25.91d0, &
      25.82d0, 23.46d0, 23.37d0, 22.81d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, 0.00d0,  0.00d0,  0.00d0 /

   ! placeholder value of 2.0 angstrom for those not int the Grimme06 paper
   ! Note that thes are also in bohr/au
   ! These are essentially vdw radii
   Grimme06_r_0_disp_coeff :: VEC{REAL}(110), public

   data Grimme06_r_0_disp_coeff / &
       1.892d0, 1.912d0, 1.559d0, 2.661d0, 2.806d0, 2.744d0, 2.640d0, 2.536d0, 2.432d0, 2.349d0, &
       2.162d0, 2.578d0, 3.097d0, 3.243d0, 3.222d0, 3.180d0, 3.097d0, 3.014d0, 2.806d0, 2.785d0, &
       2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, &
       3.118d0, 3.264d0, 3.326d0, 3.347d0, 3.305d0, 3.264d0, 3.076d0, 3.035d0, 3.097d0, 3.097d0, &
       3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.160d0, 3.409d0, &
       3.555d0, 3.575d0, 3.575d0, 3.555d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0 /

   ! Atomic Polarizabilities (au)
   ! "Atomic Polarizabilities and Hyperpolarizabilities: A Critical Compilation."
   ! A. J. Thakkar and C. Lupinetti, in Atoms, Molecules and Clusters in Electric Fields. 
   ! Theoretical Approaches to the Calculation of Electric Polarizability
   ! pp. 505-529, Edited by G. Maroulis, Imperial College Press, London (2006)
   ! Hydrogen polarizability is for the xi = 1.00 contraction
   ! (Hydrogen xi = 1.24 has a polarizability of 1.90 au ... not reported in table)
   ! Values up to and including Nobelium. Post-Nobelium elements assigned a value of 0.00.

   Thakkar_atomic_polarizability :: VEC{REAL}(110), public

   data Thakkar_atomic_polarizability / &
     4.50d0,   1.38d0, 164.04d0,  37.74d0,  20.43d0,  11.67d0,   7.26d0,   5.24d0,   3.70d0,   2.66d0, &
   162.88d0,  71.22d0,  57.79d0,  37.17d0,  24.93d0,  19.37d0,  14.57d0,  11.09d0, 291.10d0, 157.90d0, &
   142.30d0, 114.30d0,  97.30d0,  94.70d0,  75.50d0,  63.90d0,  57.70d0,  51.10d0,  45.50d0,  38.35d0, &
    52.91d0,  40.80d0,  29.80d0,  26.24d0,  21.13d0,  16.80d0, 316.20d0, 199.00d0, 153.00d0, 121.00d0, &
   106.00d0,  86.00d0,  77.00d0,  65.00d0,  58.00d0,  32.00d0,  52.46d0,  47.55d0,  68.67d0,  57.30d0, &
    42.20d0,  38.10d0,  32.98d0,  27.06d0, 396.00d0, 273.50d0, 210.00d0, 200.00d0, 190.00d0, 212.00d0, &
   203.00d0, 194.00d0, 187.00d0, 159.00d0, 172.00d0, 165.00d0, 159.00d0, 153.00d0, 147.00d0, 145.30d0, &
   148.00d0, 109.00d0,  88.00d0,  75.00d0,  65.00d0,  57.00d0,  51.00d0,  44.00d0,  36.06d0,  34.73d0, &
    71.72d0,  60.05d0,  48.60d0,  43.62d0,  40.73d0,  33.18d0, 315.20d0, 246.20d0, 217.00d0, 217.00d0, &
   171.00d0, 153.00d0, 167.00d0, 165.00d0, 157.00d0, 155.00d0, 153.00d0, 138.00d0, 133.00d0, 161.00d0, &
   123.00d0, 118.00d0,   0.00d0,   0.00d0,   0.00d0,   0.00d0, 0.00d0,   0.00d0,   0.00d0,   0.00d0 /

   ! Table of isotope masses and abundances taken from NIST
   !
   !    http://www.nist.gov/pml/data/comp.cfm
   !
   ! According to the blurb on the site:
   !
   ! The atomic weights are available for elements 1 through 118 and
   ! isotopic compositions or abundances are given when appropriate.
   ! The atomic weights data were published by M.E. Weiser and M.
   ! Berglund in Atomic Weights of the Elements 2007, and the
   ! isotopic compositions data were published by J.K. Böhlke, J.R.
   ! de Laeter, P. De Bièvre, H. Hidaka, H.S. Peiser, K.J.R.
   ! Rosman, and P.D.P. Taylor in Isotopic Compositions of the
   ! Elements, 2001. The relative atomic masses of the isotopes data
   ! were published by G.  Audi, A.H. Wapstra, and C. Thibault
   ! in The 2003 Atomic Mass Evaluation.  These data have been
   ! compiled from the above sources for the user's convenience and
   ! does not represent a critical evaluation by the NIST Physical
   ! Measurement Laboratory.

   isotope_data :: MAT{REAL}(4,355)

   ! Notes
   ! . Column 1: atomic number
   ! . Column 2: atomic mass number i.e. no of protons and ! neutrons
   ! . Column 3: isotope mass. Negative number means not available.
   ! . Column 4: natural abundance. Negative means most stable form.

   data isotope_data/ &
     0,   1,  1.008664915700d0, -1.00000000d0, & ! neutron mass
     1,   1,  1.007825032070d0,  0.99988500d0, &
     1,   2,  2.014101777800d0,  0.00011500d0, &
     1,   3,  3.016049277700d0,  0.00000000d0, &
     2,   3,  3.016029319100d0,  0.00000134d0, &
     2,   4,  4.002603254150d0,  0.99999866d0, &
     3,   6,  6.015122795000d0,  0.07590000d0, &
     3,   7,  7.016004550000d0,  0.92410000d0, &
     4,   9,  9.012182200000d0,  1.00000000d0, &
     5,  10,  10.01293700000d0,  0.19900000d0, &
     5,  11,  11.00930540000d0,  0.80100000d0, &
     6,  12,  12.00000000000d0,  0.98930000d0, &
     6,  13,  13.00335483780d0,  0.01070000d0, &
     6,  14,  14.00324198900d0,  0.00000000d0, &
     7,  14,  14.00307400480d0,  0.99636000d0, &
     7,  15,  15.00010889820d0,  0.00364000d0, &
     8,  16,  15.99491461956d0,  0.99757000d0, &
     9,  17,  16.99913170000d0,  0.00038000d0, &
     9,  18,  17.99916100000d0,  0.00205000d0, &
     9,  19,  18.99840322000d0,  1.00000000d0, &
    10,  20,  19.99244017540d0,  0.90480000d0, &
    10,  21,  20.99384668000d0,  0.00270000d0, &
    10,  22,  21.99138511400d0,  0.09250000d0, &
    11,  23,  22.98976928090d0,  1.00000000d0, &
    12,  24,  23.98504170000d0,  0.78990000d0, &
    12,  25,  24.98583692000d0,  0.10000000d0, &
    12,  26,  25.98259292900d0,  0.11010000d0, &
    13,  27,  26.98153863000d0,  1.00000000d0, &
    14,  28,  27.97692653250d0,  0.92223000d0, &
    14,  29,  28.97649470000d0,  0.04685000d0, &
    14,  30,  29.97377017000d0,  0.03092000d0, &
    15,  31,  30.97376163000d0,  1.00000000d0, &
    16,  32,  31.97207100000d0,  0.94990000d0, &
    16,  33,  32.97145876000d0,  0.00750000d0, &
    16,  34,  33.96786690000d0,  0.04250000d0, &
    16,  36,  35.96708076000d0,  0.00010000d0, &
    17,  35,  34.96885268000d0,  0.75760000d0, &
    17,  37,  36.96590259000d0,  0.24240000d0, &
    18,  36,  35.96754510600d0,  0.00336500d0, &
    18,  38,  37.96273240000d0,  0.00063200d0, &
    18,  40,  39.96238312250d0,  0.99600300d0, &
    19,  39,  38.96370668000d0,  0.93258100d0, &
    19,  40,  39.96399848000d0,  0.00011700d0, &
    19,  41,  40.96182576000d0,  0.06730200d0, &
    20,  40,  39.96259098000d0,  0.96941000d0, &
    20,  42,  41.95861801000d0,  0.00647000d0, &
    20,  43,  42.95876660000d0,  0.00135000d0, &
    20,  44,  43.95548180000d0,  0.02086000d0, &
    20,  46,  45.95369260000d0,  0.00004000d0, &
    20,  48,  47.95253400000d0,  0.00187000d0, &
    21,  45,  44.95591190000d0,  1.00000000d0, &
    22,  46,  45.95263160000d0,  0.08250000d0, &
    22,  47,  46.95176310000d0,  0.07440000d0, &
    22,  48,  47.94794630000d0,  0.73720000d0, &
    22,  49,  48.94787000000d0,  0.05410000d0, &
    22,  50,  49.94479120000d0,  0.05180000d0, &
    23,  50,  49.94715850000d0,  0.00250000d0, &
    23,  51,  50.94395950000d0,  0.99750000d0, &
    24,  50,  49.94604420000d0,  0.04345000d0, &
    24,  52,  51.94050750000d0,  0.83789000d0, &
    24,  53,  52.94064940000d0,  0.09501000d0, &
    24,  54,  53.93888040000d0,  0.02365000d0, &
    25,  55,  54.93804510000d0,  1.00000000d0, &
    26,  54,  53.93961050000d0,  0.05845000d0, &
    26,  56,  55.93493750000d0,  0.91754000d0, &
    26,  57,  56.93539400000d0,  0.02119000d0, &
    26,  58,  57.93327560000d0,  0.00282000d0, &
    27,  59,  58.93319500000d0,  1.00000000d0, &
    28,  58,  57.93534290000d0,  0.68076900d0, &
    28,  60,  59.93078640000d0,  0.26223100d0, &
    28,  61,  60.93105600000d0,  0.01139900d0, &
    28,  62,  61.92834510000d0,  0.03634500d0, &
    28,  64,  63.92796600000d0,  0.00925600d0, &
    29,  63,  62.92959750000d0,  0.69150000d0, &
    29,  65,  64.92778950000d0,  0.30850000d0, &
    30,  64,  63.92914220000d0,  0.48268000d0, &
    30,  66,  65.92603340000d0,  0.27975000d0, &
    30,  67,  66.92712730000d0,  0.04102000d0, &
    30,  68,  67.92484420000d0,  0.19024000d0, &
    30,  70,  69.92531930000d0,  0.00631000d0, &
    31,  69,  68.92557360000d0,  0.60108000d0, &
    31,  71,  70.92470130000d0,  0.39892000d0, &
    32,  70,  69.92424740000d0,  0.20380000d0, &
    32,  72,  71.92207580000d0,  0.27310000d0, &
    32,  73,  72.92345890000d0,  0.07760000d0, &
    32,  74,  73.92117780000d0,  0.36720000d0, &
    32,  76,  75.92140260000d0,  0.07830000d0, &
    33,  75,  74.92159650000d0,  1.00000000d0, &
    34,  74,  73.92247640000d0,  0.00890000d0, &
    34,  76,  75.91921360000d0,  0.09370000d0, &
    34,  77,  76.91991400000d0,  0.07630000d0, &
    34,  78,  77.91730910000d0,  0.23770000d0, &
    34,  80,  79.91652130000d0,  0.49610000d0, &
    34,  82,  81.91669940000d0,  0.08730000d0, &
    35,  79,  78.91833710000d0,  0.50690000d0, &
    35,  81,  80.91629060000d0,  0.49310000d0, &
    36,  78,  77.92036480000d0,  0.00355000d0, &
    36,  80,  79.91637900000d0,  0.02286000d0, &
    36,  82,  81.91348360000d0,  0.11593000d0, &
    36,  83,  82.91413600000d0,  0.11500000d0, &
    36,  84,  83.91150700000d0,  0.56987000d0, &
    36,  86,  85.91061073000d0,  0.17279000d0, &
    37,  85,  84.91178973800d0,  0.72170000d0, &
    37,  87,  86.90918052700d0,  0.27830000d0, &
    38,  84,  83.91342500000d0,  0.00560000d0, &
    38,  86,  85.90926020000d0,  0.09860000d0, &
    38,  87,  86.90887710000d0,  0.07000000d0, &
    38,  88,  87.90561210000d0,  0.82580000d0, &
    39,  89,  88.90584830000d0,  1.00000000d0, &
    40,  90,  89.90470440000d0,  0.51450000d0, &
    40,  91,  90.90564580000d0,  0.11220000d0, &
    40,  92,  91.90504080000d0,  0.17150000d0, &
    40,  94,  93.90631520000d0,  0.17380000d0, &
    40,  96,  95.90827340000d0,  0.02800000d0, &
    41,  93,  92.90637810000d0,  1.00000000d0, &
    42,  92,  91.90681100000d0,  0.14770000d0, &
    42,  94,  93.90508830000d0,  0.09230000d0, &
    42,  95,  94.90584210000d0,  0.15900000d0, &
    42,  96,  95.90467950000d0,  0.16680000d0, &
    42,  97,  96.90602150000d0,  0.09560000d0, &
    42,  98,  97.90540820000d0,  0.24190000d0, &
    42, 010,  99.90747700000d0,  0.09670000d0, &
    43,  97,  96.90636500000d0,  0.00000000d0, &
    43,  98,  97.90721600000d0,  0.00000000d0, &
    43,  99,  98.90625470000d0, -1.00000000d0, &
    44,  96,  95.90759800000d0,  0.05540000d0, &
    44,  98,  97.90528700000d0,  0.01870000d0, &
    44,  99,  98.90593930000d0,  0.12760000d0, &
    44, 100,  99.90421950000d0,  0.12600000d0, &
    44, 101,  100.9055821000d0,  0.17060000d0, &
    44, 102,  101.9043493000d0,  0.31550000d0, &
    44, 104,  103.9054330000d0,  0.18620000d0, &
    45, 103,  102.9055040000d0,  1.00000000d0, &
    46, 102,  101.9056090000d0,  0.01020000d0, &
    46, 104,  103.9040360000d0,  0.11140000d0, &
    46, 105,  104.9050850000d0,  0.22330000d0, &
    46, 106,  105.9034860000d0,  0.27330000d0, &
    46, 108,  107.9038920000d0,  0.26460000d0, &
    46, 110,  109.9051530000d0,  0.11720000d0, &
    47, 107,  106.9050970000d0,  0.51839000d0, &
    47, 109,  108.9047520000d0,  0.48161000d0, &
    48, 106,  105.9064590000d0,  0.01250000d0, &
    48, 108,  107.9041840000d0,  0.00890000d0, &
    48, 110,  109.9030021000d0,  0.12490000d0, &
    48, 111,  110.9041781000d0,  0.12800000d0, &
    48, 112,  111.9027578000d0,  0.24130000d0, &
    48, 113,  112.9044017000d0,  0.12220000d0, &
    48, 114,  113.9033585000d0,  0.28730000d0, &
    48, 116,  115.9047560000d0,  0.07490000d0, &
    49, 113,  112.9040580000d0,  0.04290000d0, &
    49, 115,  114.9038780000d0,  0.95710000d0, &
    50, 112,  111.9048180000d0,  0.00970000d0, &
    50, 114,  113.9027790000d0,  0.00660000d0, &
    50, 115,  114.9033420000d0,  0.00340000d0, &
    50, 116,  115.9017410000d0,  0.14540000d0, &
    50, 117,  116.9029520000d0,  0.07680000d0, &
    50, 118,  117.9016030000d0,  0.24220000d0, &
    50, 119,  118.9033080000d0,  0.08590000d0, &
    50, 120,  119.9021947000d0,  0.32580000d0, &
    50, 122,  121.9034390000d0,  0.04630000d0, &
    50, 124,  123.9052739000d0,  0.05790000d0, &
    51, 121,  120.9038157000d0,  0.57210000d0, &
    51, 123,  122.9042140000d0,  0.42790000d0, &
    52, 120,  119.9040200000d0,  0.00090000d0, &
    52, 122,  121.9030439000d0,  0.02550000d0, &
    52, 123,  122.9042700000d0,  0.00890000d0, &
    52, 124,  123.9028179000d0,  0.04740000d0, &
    52, 125,  124.9044307000d0,  0.07070000d0, &
    52, 126,  125.9033117000d0,  0.18840000d0, &
    52, 128,  127.9044631000d0,  0.31740000d0, &
    52, 130,  129.9062244000d0,  0.34080000d0, &
    53, 127,  126.9044730000d0,  1.00000000d0, &
    54, 124,  123.9058930000d0,  0.00095200d0, &
    54, 126,  125.9042740000d0,  0.00089000d0, &
    54, 128,  127.9035313000d0,  0.01910200d0, &
    54, 129,  128.9047794000d0,  0.26400600d0, &
    54, 130,  129.9035080000d0,  0.04071000d0, &
    54, 131,  130.9050824000d0,  0.21232400d0, &
    54, 132,  131.9041535000d0,  0.26908600d0, &
    54, 134,  133.9053945000d0,  0.10435700d0, &
    54, 136,  135.9072190000d0,  0.08857300d0, &
    55, 133,  132.9054519330d0,  1.00000000d0, &
    56, 130,  129.9063208000d0,  0.00106000d0, &
    56, 132,  131.9050613000d0,  0.00101000d0, &
    56, 134,  133.9045084000d0,  0.02417000d0, &
    56, 135,  134.9056886000d0,  0.06592000d0, &
    56, 136,  135.9045759000d0,  0.07854000d0, &
    56, 137,  136.9058274000d0,  0.11232000d0, &
    56, 138,  137.9052472000d0,  0.71698000d0, &
    57, 138,  137.9071120000d0,  0.00090000d0, &
    57, 139,  138.9063533000d0,  0.99910000d0, &
    58, 136,  135.9071720000d0,  0.00185000d0, &
    58, 138,  137.9059910000d0,  0.00251000d0, &
    58, 140,  139.9054387000d0,  0.88450000d0, &
    58, 142,  141.9092440000d0,  0.11114000d0, &
    59, 141,  140.9076528000d0,  1.00000000d0, &
    60, 142,  141.9077233000d0,  0.27200000d0, &
    60, 143,  142.9098143000d0,  0.12200000d0, &
    60, 144,  143.9100873000d0,  0.23800000d0, &
    60, 145,  144.9125736000d0,  0.08300000d0, &
    60, 146,  145.9131169000d0,  0.17200000d0, &
    60, 148,  147.9168930000d0,  0.05700000d0, &
    60, 150,  149.9208910000d0,  0.05600000d0, &
    61, 145,  144.9127490000d0, -1.00000000d0, &
    61, 147,  146.9151385000d0,  0.00000000d0, &
    62, 144,  143.9119990000d0,  0.03070000d0, &
    62, 147,  146.9148979000d0,  0.14990000d0, &
    62, 148,  147.9148227000d0,  0.11240000d0, &
    62, 149,  148.9171847000d0,  0.13820000d0, &
    62, 150,  149.9172755000d0,  0.07380000d0, &
    62, 152,  151.9197324000d0,  0.26750000d0, &
    62, 154,  153.9222093000d0,  0.22750000d0, &
    63, 151,  150.9198502000d0,  0.47810000d0, &
    63, 153,  152.9212303000d0,  0.52190000d0, &
    64, 152,  151.9197910000d0,  0.00200000d0, &
    64, 154,  153.9208656000d0,  0.02180000d0, &
    64, 155,  154.9226220000d0,  0.14800000d0, &
    64, 156,  155.9221227000d0,  0.20470000d0, &
    64, 157,  156.9239601000d0,  0.15650000d0, &
    64, 158,  157.9241039000d0,  0.24840000d0, &
    64, 160,  159.9270541000d0,  0.21860000d0, &
    65, 159,  158.9253468000d0,  1.00000000d0, &
    66, 156,  155.9242830000d0,  0.00056000d0, &
    66, 158,  157.9244090000d0,  0.00095000d0, &
    66, 160,  159.9251975000d0,  0.02329000d0, &
    66, 161,  160.9269334000d0,  0.18889000d0, &
    66, 162,  161.9267984000d0,  0.25475000d0, &
    66, 163,  162.9287312000d0,  0.24896000d0, &
    66, 164,  163.9291748000d0,  0.28260000d0, &
    67, 165,  164.9303221000d0,  1.00000000d0, &
    68, 162,  161.9287780000d0,  0.00139000d0, &
    68, 164,  163.9292000000d0,  0.01601000d0, &
    68, 166,  165.9302931000d0,  0.33503000d0, &
    68, 167,  166.9320482000d0,  0.22869000d0, &
    68, 168,  167.9323702000d0,  0.26978000d0, &
    68, 170,  169.9354643000d0,  0.14910000d0, &
    69, 169,  168.9342133000d0,  1.00000000d0, &
    70, 168,  167.9338970000d0,  0.00130000d0, &
    70, 170,  169.9347618000d0,  0.03040000d0, &
    70, 171,  170.9363258000d0,  0.14280000d0, &
    70, 172,  171.9363815000d0,  0.21830000d0, &
    70, 173,  172.9382108000d0,  0.16130000d0, &
    70, 174,  173.9388621000d0,  0.31830000d0, &
    70, 176,  175.9425717000d0,  0.12760000d0, &
    71, 175,  174.9407718000d0,  0.97410000d0, &
    71, 176,  175.9426863000d0,  0.02590000d0, &
    72, 174,  173.9400460000d0,  0.00160000d0, &
    72, 176,  175.9414086000d0,  0.05260000d0, &
    72, 177,  176.9432207000d0,  0.18600000d0, &
    72, 178,  177.9436988000d0,  0.27280000d0, &
    72, 179,  178.9458161000d0,  0.13620000d0, &
    72, 180,  179.9465500000d0,  0.35080000d0, &
    73, 180,  179.9474648000d0,  0.00012000d0, &
    73, 181,  180.9479958000d0,  0.99988000d0, &
    74, 180,  179.9467040000d0,  0.00120000d0, &
    74, 182,  181.9482042000d0,  0.26500000d0, &
    74, 183,  182.9502230000d0,  0.14310000d0, &
    74, 184,  183.9509312000d0,  0.30640000d0, &
    74, 186,  185.9543641000d0,  0.28430000d0, &
    75, 185,  184.9529550000d0,  0.37400000d0, &
    75, 187,  186.9557531000d0,  0.62600000d0, &
    76, 184,  183.9524891000d0,  0.00020000d0, &
    76, 186,  185.9538382000d0,  0.01590000d0, &
    76, 187,  186.9557505000d0,  0.01960000d0, &
    76, 188,  187.9558382000d0,  0.13240000d0, &
    76, 189,  188.9581475000d0,  0.16150000d0, &
    76, 190,  189.9584470000d0,  0.26260000d0, &
    76, 192,  191.9614807000d0,  0.40780000d0, &
    77, 191,  190.9605940000d0,  0.37300000d0, &
    77, 193,  192.9629264000d0,  0.62700000d0, &
    78, 190,  189.9599320000d0,  0.00014000d0, &
    78, 192,  191.9610380000d0,  0.00782000d0, &
    78, 194,  193.9626803000d0,  0.32967000d0, &
    78, 195,  194.9647911000d0,  0.33832000d0, &
    78, 196,  195.9649515000d0,  0.25242000d0, &
    78, 198,  197.9678930000d0,  0.07163000d0, &
    79, 197,  196.9665687000d0,  1.00000000d0, &
    80, 196,  195.9658330000d0,  0.00150000d0, &
    80, 198,  197.9667690000d0,  0.09970000d0, &
    80, 199,  198.9682799000d0,  0.16870000d0, &
    80, 200,  199.9683260000d0,  0.23100000d0, &
    80, 201,  200.9703023000d0,  0.13180000d0, &
    80, 202,  201.9706430000d0,  0.29860000d0, &
    80, 204,  203.9734939000d0,  0.06870000d0, &
    81, 203,  202.9723442000d0,  0.29520000d0, &
    81, 205,  204.9744275000d0,  0.70480000d0, &
    82, 204,  203.9730436000d0,  0.01400000d0, &
    82, 206,  205.9744653000d0,  0.24100000d0, &
    82, 207,  206.9758969000d0,  0.22100000d0, &
    82, 208,  207.9766521000d0,  0.52400000d0, &
    83, 209,  208.9803987000d0,  1.00000000d0, &
    84, 209,  208.9824304000d0,  0.00000000d0, &
    84, 210,  209.9828737000d0, -1.00000000d0, &
    85, 210,  209.9871480000d0, -1.00000000d0, &
    85, 211,  210.9874963000d0,  0.00000000d0, &
    86, 211,  210.9906010000d0,  0.00000000d0, &
    86, 220,  220.0113940000d0,  0.00000000d0, &
    86, 222,  222.0175777000d0,  0.00000000d0, &
    87, 223,  223.0197359000d0,  0.00000000d0, &
    88, 223,  223.0185022000d0,  0.00000000d0, &
    88, 224,  224.0202118000d0,  0.00000000d0, &
    88, 226,  226.0254098000d0, -1.00000000d0, &
    88, 228,  228.0310703000d0,  0.00000000d0, &
    89, 227,  227.0277521000d0, -1.00000000d0, &
    90, 230,  230.0331338000d0,  0.00000000d0, &
    90, 232,  232.0380553000d0,  1.00000000d0, &
    91, 231,  231.0358840000d0,  1.00000000d0, &
    92, 233,  233.0396352000d0,  0.00000000d0, &
    92, 234,  234.0409521000d0,  0.00005400d0, &
    92, 235,  235.0439299000d0,  0.00720400d0, &
    92, 236,  236.0455680000d0,  0.00000000d0, &
    92, 238,  238.0507882000d0,  0.99274200d0, &
    93, 236,  236.0465700000d0,  0.00000000d0, &
    93, 237,  237.0481734000d0, -1.00000000d0, &
    94, 238,  238.0495599000d0,  0.00000000d0, &
    94, 239,  239.0521634000d0,  0.00000000d0, &
    94, 240,  240.0538135000d0,  0.00000000d0, &
    94, 241,  241.0568515000d0,  0.00000000d0, &
    94, 242,  242.0587426000d0,  0.00000000d0, &
    94, 244,  244.0642040000d0, -1.00000000d0, &
    95, 241,  241.0568291000d0,  0.00000000d0, &
    95, 243,  243.0613811000d0, -1.00000000d0, &
    96, 243,  243.0613891000d0,  0.00000000d0, &
    96, 244,  244.0627526000d0,  0.00000000d0, &
    96, 245,  245.0654912000d0,  0.00000000d0, &
    96, 246,  246.0672237000d0,  0.00000000d0, &
    96, 247,  247.0703540000d0, -1.00000000d0, &
    96, 248,  248.0723490000d0,  0.00000000d0, &
    97, 247,  247.0703070000d0, -1.00000000d0, &
    97, 249,  249.0749867000d0,  0.00000000d0, &
    98, 249,  249.0748535000d0,  0.00000000d0, &
    98, 250,  250.0764061000d0,  0.00000000d0, &
    98, 251,  251.0795870000d0, -1.00000000d0, &
    98, 252,  252.0816260000d0,  0.00000000d0, &
    99, 252,  252.0829800000d0, -1.00000000d0, &
   100, 257,  257.0951050000d0, -1.00000000d0, &
   101, 258,  258.0984310000d0, -1.00000000d0, &
   101, 260,  260.1036500000d0,  0.00000000d0, &
   102, 259,  259.1010300000d0, -1.00000000d0, &
   103, 262,  262.1096300000d0, -1.00000000d0, &
   104, 265,  265.1167000000d0, -1.00000000d0, &
   105, 268,  268.1254500000d0, -1.00000000d0, &
   106, 271,  271.1334700000d0, -1.00000000d0, &
   107, 272,  272.1380300000d0, -1.00000000d0, &
   108, 270,  270.1346500000d0, -1.00000000d0, &
   109, 276,  276.1511600000d0, -1.00000000d0, &
   110, 281,  281.1620600000d0, -1.00000000d0, &
   111, 280,  280.1644700000d0, -1.00000000d0, &
   112, 285,  285.1741100000d0, -1.00000000d0, &
   113, 284,  284.1780800000d0, -1.00000000d0, &
   114, 289,  289.1872800000d0, -1.00000000d0, &
   115, 288,  288.1924900000d0, -1.00000000d0, &
   116, 293, -293.0000000000d0, -1.00000000d0, &
   117, 292,  292.2075500000d0, -1.00000000d0, &
   118, 294, -294.0000000000d0, -1.00000000d0  /

   saved_self :: ATOM*, private  DEFAULT_NULL

contains

!  ==================
!  Allocation methods
!  ==================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the atom
   ! WARNING: all of these are usually pointer assigned in MOLECULE
   ! when defining the (spherically averaged) atomic natural orbitals.
   ! Therefore, the appropriate MOLECULE destructor should be called
   ! before using this routine.

      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      nullify(.pADP_vector)
      nullify(.pADP_errors)

      nullify(.atomic_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)

      nullify(.interpolator)

      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.precomputed_basis_shellpair)

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of an atom
   ! WARNING: take care using this, you may need
   ! a unique-atom or all-atom destruction for the
   ! different pointer parts depending on how they
   ! were created.

      ! Never destroy these ... they are always
      ! resolved outside the atom object.
      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      ! WARNING: this may not be correct
      ! The destroy should be done outside of this module
      if (.kind==0 OR .is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy

         .interpolator.destroy

         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

      else

         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)

         nullify(.interpolator)

         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

      end

      ! Do always destroy these
      .pADP_vector.destroy
      .pADP_errors.destroy

   end

   destroy_ANOs ::: leaky
   ! Destroy the (unique-atom) ANO pointer parts
   ! (and related info)
   DIE_IF(.kind==0,"The kind has not been set")

      if (NOT .ANOs_made) return

      if (.is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy

      else

         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)

      end

      .ANOs_made = FALSE

   end

   destroy_ANO_interpolators ::: leaky
   ! Destroy the (unique-atom) ANO interpolators
   DIE_IF(.kind==0,"The kind has not been set")

      if (NOT .ANO_interpolators_made) return

      if (.is_unique_kind) then; .interpolator.destroy
      else;                      nullify(.interpolator)
      end

      .ANO_interpolators_made = FALSE

   end

   destroy_spherical_atom_data ::: leaky
   ! Destroy the (non-unique) ANO pointer parts

      if (NOT .spherical_atom_data_made) return

      .atomic_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy

      .interpolator.destroy

      .spherical_atom_data_made = FALSE

   end

   destroy_interpolators ::: leaky
   ! Destroy the (non-unique) interpolators

      if (NOT .interpolators_made) return

      .interpolator.destroy

      .interpolators_made = FALSE

   end

   destroy_shell_info ::: leaky
   ! Destroy the (unique-atom) shell info
   DIE_IF(.kind==0,"The kind has not been set")

      if (NOT .shell_info_made) return

      if (.is_unique_kind) then

         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

      else

         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

      end

      .shell_info_made = FALSE

   end

!  ====
!  Copy
!  ====

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(atom) ::: leaky
   ! Make self to be a copy of atom.
   ! WARNING: This method only nullifies pointer parts. It is your
   ! responsibility to destroy pointer parts (if you want to) before
   ! calling this method.
      atom :: ATOM, IN

      self = atom

      .nullify_ptr_part

      ! Copy the pADP data
      if (atom.pADP_vector.created)     .pADP_vector.create_copy(atom.pADP_vector)
      if (atom.pADP_errors.created)     .pADP_errors.create_copy(atom.pADP_errors)

      ! Re-assign bases
      if (atom.basis.created)           .basis        => atom.basis
      if (atom.slaterbasis.created)     .slaterbasis  => atom.slaterbasis
      if (atom.coppensbasis.created)    .coppensbasis => atom.coppensbasis

      ! Re-assign unique-atom ANO data
      .copy_ANOs(atom)
      .copy_ANO_interpolators(atom)
      .copy_shell_info(atom)

      ! Re-assign unique-atom ANO data
      .copy_spherical_atom_data(atom)
      .copy_interpolators(atom)

      ! Set kind via VEC{ATOM}:update?
      ! Do it yourself if you want to
    ! .kind = 0

   end

   copy_ANOs(atom) ::: leaky
   ! Copy the (unique-atom) ANO pointer parts (and related info)
      atom :: ATOM, IN

      if (NOT atom.ANOs_made) return

      if (.kind==0 OR .is_unique_kind) then

         .atomic_orbitals.create_copy(atom.atomic_orbitals)
         .density_matrix.create_copy(atom.density_matrix)
         .natural_orbitals.create_copy(atom.natural_orbitals)
         .occupation_numbers.create_copy(atom.occupation_numbers)

      else

         .atomic_orbitals    => atom.atomic_orbitals
         .density_matrix     => atom.density_matrix
         .natural_orbitals   => atom.natural_orbitals
         .occupation_numbers => atom.occupation_numbers

      end

      ! Kinds may not be sequential
      .ANOs_made = TRUE

   end

   copy_ANO_interpolators(atom) ::: leaky
   ! Copy the (unique-atom) ANO interpolators
      atom :: ATOM, IN

      if (NOT atom.ANO_interpolators_made) return

      if (.kind==0 OR .is_unique_kind) then

         .interpolator.destroy
         .interpolator.create_copy(atom.interpolator)

      else

         nullify(.interpolator)
         .interpolator => atom.interpolator

      end

      ! Kinds may not be sequential
      .ANO_interpolators_made = TRUE

   end

   copy_shell_info(atom) ::: leaky
   ! Destroy the (unique-atom) shell info
      atom :: ATOM, IN

      if (NOT atom.shell_info_made) return

      if (.kind==0 OR .is_unique_kind) then

         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

         .first_basis_fn_for_shell.create_copy(atom.first_basis_fn_for_shell)
         .last_basis_fn_for_shell.create_copy(atom.last_basis_fn_for_shell)
         .precomputed_basis_shellpair.create_copy(atom.precomputed_basis_shellpair)

      else

         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

         .first_basis_fn_for_shell    => atom.first_basis_fn_for_shell
         .last_basis_fn_for_shell     => atom.last_basis_fn_for_shell
         .precomputed_basis_shellpair => atom.precomputed_basis_shellpair

      end

      ! Kinds may not be sequential
      .shell_info_made = TRUE

   end

   copy_spherical_atom_data(atom) ::: leaky
   ! Copy the (non-unique) ANO pointer parts
      atom :: ATOM, IN

      if (NOT atom.spherical_atom_data_made) return

      .atomic_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy

      .atomic_orbitals.create_copy(atom.atomic_orbitals)
      .density_matrix.create_copy(atom.density_matrix)
      .natural_orbitals.create_copy(atom.natural_orbitals)
      .occupation_numbers.create_copy(atom.occupation_numbers)

      .interpolator.destroy
      .interpolator.create_copy(atom.interpolator)

      ! Kinds may not be sequential
      .spherical_atom_data_made = TRUE

   end

   copy_interpolators(atom) ::: leaky
   ! Destroy the (non-unique) interpolators
      atom :: ATOM

      if (NOT atom.interpolators_made) return

      .interpolator.destroy
      .interpolator.create_copy(atom.interpolator)

      ! Kinds may not be sequential
      .interpolators_made = TRUE

   end

!  ===========
!  Set methods
!  ===========

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self. This version has self a target.
   end

   set_defaults
   ! Set a default atom

      .label = "?"
      .tag = " "

      .atomic_number   = 0
      .nuclear_charge  = ZERO
      .oxidation_state = 0

      .mass_number     = 0
      .mass            = ZERO

      .set_position([ ZERO,ZERO,ZERO ])
      .set_position_error([ ZERO,ZERO,ZERO ])

      .group  = 0

      .site_occupancy = ONE
      .site_disorder_group = 0

      ! ADP
      .U_iso = ZERO
      .set_ADP_tensor(ZERO)
      .pos_axis_system  = "cartesian"
      .ADP_axis_system  = "cartesian"
      .ADPn_axis_system = "cartesian"

      ! Charges
      .charge                = ZERO
      .dipole                = ZERO
      .quadrupole            = ZERO
      .spin                  = ZERO
      .spin_dipole           = ZERO
      .spin_quadrupole       = ZERO
      .charge_polarisability = ZERO
      .dipole_polarisability = ZERO

      ! Basis
      .basis_label        = " "
      .basis_kind         = " "
      .slaterbasis_label  = " "
      .coppensbasis_label = " "
      .kind               = 0
      .is_unique_kind     = FALSE

      ! ANO
      .energy                   = ZERO
      .ANOs_made                = FALSE
      .spherical_atom_data_made = FALSE

      ! Interpolator
      .use_interpolator       = TRUE
      .ANO_interpolators_made = FALSE
      .interpolators_made     = FALSE

      .shell_info_made = FALSE

      ! Protien defaults
      .invariom_label          = " "
      .protein_strand          = 0
      .residue_atom_code       = " "
      .residue_code            = " "
      .residue_sequence_number = 0

      ! MM
      .mm_forcefield_name         = " "
      .mm_atom_type               = " "
      .mm_charge                  = ZERO
      .restraining_position       = [ ZERO,ZERO,ZERO ]
      .restraining_force_constant = ZERO

   end

!  ============================
!  Set labels, dummies, charges
!  ============================

   set_atom_data_from_label(label)
   ! Set the atom data such as its label, atomic_number, mass_number,
   ! nuclear_charge and atomic mass.
      label :: STR

      Z :: INT

      if (label.is_int) then

         ! Integer label must be the atomic number
         Z = label.to_int
         .set_atomic_number(Z)

      else if (label(1:2)==ATOM_DUMMY_CHARGE_INPUT_SYMBOL) then

         ! This is a dummy charge, e.g Q:-0.3
         .set_dummy_charge(label)

      else

         ! Valid chemical symbol at start, followed by other stuff ...
         .set_label(label)

      end

   end

   set_label(label) ::: private
   ! Set the atom "label" and related variables
      self :: INOUT
      label :: STR

   DIE_IF(NOT label(1:1).is_alphabetical,"unacceptable atom symbol: "// trim(label))

      lensym :: INT
      symbol :: STR(len=2)

      ! Set the tag - may not be unique
      .tag = label

      ! Label ends on nonalphabetical character
      lensym = label.index_of_nonalphabetical - 1

      ! Check label is no more than two character long
      DIE_IF(lensym>2,"unacceptable atom symbol: "// trim(label(1:lensym)))

      ! lensym could be negative -- if no nonalphabetical chars!
      if (lensym<0) lensym = len_trim(label)

      ! Recheck label is no more than two character long
      DIE_IF(lensym>2,"unacceptable atom symbol: "// trim(label(1:lensym)))

      ! Get chemical symbol
      symbol = label(1:lensym)
      symbol(1:1).to_upper_case
      if (lensym>1 AND symbol(2:2).is_upper_case) symbol(2:2).to_lower_case

      ! Set label
      .label = symbol

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ! Set atomic number and mass
      .set_mass
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!

   end

   set_mass ::: private
   ! Set the atomic mass from the .label and .mass_number
      self :: INOUT

   ENSURE(.label/="?" AND .label/=" ","label not set")

      symbol :: STR
      Z :: INT

      symbol = .label

      ! Assign atomic number from symbol
      select case (symbol(1:2))

         case ("El")
            ! An electron
            .atomic_number  = -1
            .nuclear_charge = -ONE
            ! Mass of electron in C12 mass units
            .mass           = MASS_OF_ELECTRON_SI/AMU_SI

         case("D")
            ! Dueterium
            .atomic_number  = 1
            .mass_number    = 2
            .nuclear_charge = ONE
            .mass           = ::mass_of_isotope(Z=1,A=2)

         case("T")
            ! This is dueterium/tritium
            .atomic_number  = 1
            .mass_number    = 2
            .nuclear_charge = ONE
            .mass           = ::mass_of_isotope(Z=1,A=3)

         case default
            ! Regular element
            Z = element_symbols(1:).index_of(symbol(1:2))
            DIE_IF(Z==0,"unknown element symbol: "//trim(symbol))
            .atomic_number  = Z
            .nuclear_charge = Z*ONE
            .mass           = ATOM::mass(self)

      end

   end

   set_dummy_charge(label)
   ! Set a dummy charge (integer) and related variables
      label :: STR
   DIE_IF(label(1:2)/=ATOM_DUMMY_CHARGE_INPUT_SYMBOL,"invalid q-charge label: "//trim(label(1:2)))
   DIE_IF(NOT label(3:).is_real,"invalid q-charge: "//trim(label(3:)))

      .label          = ATOM_DUMMY_CHARGE_LABEL
      .atomic_number  = 0
      .nuclear_charge = label(3:).to_real ! extract the charge

   end

   set_atomic_number(val)
   ! Set the atomic number (integer) and related variables
      val :: INT

   DIE_IF(val<=0 OR val>118,"unknown atomic number: "//trim(val.to_str))

      .atomic_number  = val
      .nuclear_charge = val
      .label          = .chemical_symbol

      .set_mass

   end

   set_mass_number(val)
   ! Set the atomic mass number. If the mass number is zero the
   ! atom is assumed to have an abunfance weighted mass, otherwise
   ! its mass is worked out from the isotope table
      self :: INOUT
      val :: INT

   DIE_IF(val<=0 OR val>118,"unknown atomic number: "//trim(val.to_str))
   DIE_IF(.atomic_number==0,"set mass number *after* atomic number")

      .mass_number = val
      .mass        = ATOM::mass(self)

   end

   set_nuclear_charge(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.nuclear_charge)
   ! Generic set
   end

   set_oxidation_state(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.oxidation_state)
   ! Generic set
   end

!  =============
!  Set positions
!  =============

   set_position(val) ::: pure
   ! Set positions. Also set the pADP_vector *only* if created.
   ! NOTE: Do you need to set the axis system too?
      self :: INOUT
      val :: VEC{REAL}(3), IN

      .position = val

      if (.pADP_vector.created) .pADP_vector(1:3) = val

   end

   set_position_error(val) ::: pure
   ! Set position error. Also set the pADP_error *only* if created.
   ! NOTE: Do you need to set the axis system too?
      self :: INOUT
      val :: VEC{REAL}(3), IN

      .position_error = val

      if (.pADP_errors.created) .pADP_errors(1:3) = val

   end

!  ========
!  Set ADPs
!  ========

   set_U_iso(val)
   ! Set U_iso only
   ! NOTE: Do you need to set the .ADP_axis_system too?
      val :: REAL, IN
      .U_iso = val
   end

   set_ADP_tensor(val) ::: pure
   ! Set the ADP tensor.  Also set the pADP_vector *only* if created.
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      val :: REAL, IN

      .ADP_tensor = val

      if (.pADP_vector.created) .pADP_vector(4:9) = val

   end

   set_ADP_tensor(val) ::: pure
   ! Set the ADP tensor.  Also set the pADP_vector if created.
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      val :: MAT{REAL}(3,3), IN

      ! Set tensor
      .ADP_tensor = val

      ! Set *only* the ADP part of pADP
      if (.pADP_vector.created) then
         .pADP_vector(4) = val(1,1)
         .pADP_vector(5) = val(2,2)
         .pADP_vector(6) = val(3,3)
         .pADP_vector(7) = val(1,2)
         .pADP_vector(8) = val(1,3)
         .pADP_vector(9) = val(2,3)
      end

   end

   set_ADP_tensor(val)
   ! Set from vector in the order xx, yy, zz, xy, xz, yz.
   ! Also set the pADP_vector if created.
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      val :: VEC{REAL}, IN

   DIE_IF(val.dim/=6,"val: wrong size")

      ! Set symmetric tensor
      .ADP_tensor(1,1) = val(1)
      .ADP_tensor(2,2) = val(2)
      .ADP_tensor(3,3) = val(3)
      .ADP_tensor(1,2) = val(4)
      .ADP_tensor(2,1) = val(4)
      .ADP_tensor(1,3) = val(5)
      .ADP_tensor(3,1) = val(5)
      .ADP_tensor(2,3) = val(6)
      .ADP_tensor(3,2) = val(6)

      ! Set *all* ADP parameters
      if (.pADP_vector.created) .set_ADP2_vector_to(val)

   end

!  ===============
!  Set axis system
!  ===============

   set_axis_system(word)
   ! Set the axis system type to "word".
   ! Currently allowed is: "cartesian" or "crystal".
      self :: INOUT
      word :: STR, IN

      .set_pos_axis_system(word)
      .set_ADP_axis_system(word)
      .set_ADPn_axis_system(word)

   end

   set_pos_axis_system(word)
   ! Set the position axis system type to "word".
   ! Currently allowed is: "cartesian" or "crystal".
   ! NOTE: all .ADP_axis_system's are changed too.
      self :: INOUT
      word :: STR, IN

      .pos_axis_system  = word

      select case (word)
         case ("cartesian")
         case ("crystal  ")
         case default
            UNKNOWN(word)
      end

   end

   set_ADP_axis_system(word)
   ! Set **all** the ADP axis systems to "word".
   ! Currently allowed, is: "cartesian" or "crystal".
      word :: STR, IN

      .ADP_axis_system  = word

      select case (word)
         case ("cartesian")
         case ("crystal  ")
         case default
            UNKNOWN(word)
      end

   end

   set_ADPn_axis_system(word)
   ! Set the ADPn axis systems to "word".
   ! Currently allowed, is: "cartesian" or "crystal".
      word :: STR, IN

      .ADPn_axis_system = word

      select case (word)
         case ("cartesian")
         case ("crystal  ")
         case default
            UNKNOWN(word)
      end

   end

!  =======================================
!  Parameter vector (position/ADP) setting
!  =======================================

! Put tensors

   put_ADP2_to(adp2,fac)
   ! Put the ADP2s into the "adp2" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp2 :: MAT{REAL}(3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=9,"pADP_vector too small")

      fac2 :: REAL
      v2   :: VEC{REAL}(6)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_2_to_lower_pyramid(.pADP_vector( 4: 9),v2)

      ! Uncompress lower pyramid -> tensor
      adp2.uncompress_from_pyramid(v2)

      DIE_IF(NOT adp2.same_as(.ADP_tensor),"inconsistent ADP_vector and ADP_tensor")

      if (present(fac)) then

         fac2 = fac*fac
         adp2 = fac2*adp2

      end

   end

   put_ADP3_to(adp3,fac)
   ! Put the ADP3s into the "adp3" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp3 :: MAT3{REAL}(3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      fac3 :: REAL
      v3   :: VEC{REAL}(10)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_3_to_lower_pyramid(.pADP_vector(10:19),v3)

      ! Uncompress lower pyramid -> tensor
      adp3.uncompress_from_pyramid(v3)

      ! Change units
      if (present(fac)) then
         fac3 = fac*fac*fac
         adp3 = fac3*adp3
      end

   end

   put_ADP4_to(adp4,fac)
   ! Put the ADP4s into the "adp4" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp4 :: MAT4{REAL}(3,3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=34,"pADP_vector too small")

      fac4 :: REAL
      v4   :: VEC{REAL}(15)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_4_to_lower_pyramid(.pADP_vector(20:34),v4)

      ! Uncompress lower pyramid -> tensor
      adp4.uncompress_from_pyramid(v4)

      ! Change units
      if (present(fac)) then
         fac4 = fac*fac*fac*fac
         adp4 = fac4*adp4
      end

   end

! Reset

   reset_pADPs_and_errors(dim) ::: leaky
   ! Reset the positional-ADP parameters and errors to size "dim".
   ! NOTE: the pADPs and errors are *expanded*.
      self :: INOUT
      dim  :: INT, IN

      X,dX :: VEC{REAL}*
      n :: INT

      ! Create pADPs, and set to existing pADPs
      if (.pADP_vector.destroyed OR .pADP_errors.destroyed) then

         ! Space for X, dX
         n = .no_of_pADPs
          X.create(n)
         dX.create(n)

         ! Get existing pADPs in X
         ! (From e.g. .position)
         .put_pADP_vector_to(X)
         dX = ZERO

         ! Create pADPs (leaky)
         .pADP_errors.destroy
         .pADP_vector.destroy
         .pADP_vector.create(n)
         .pADP_errors.create(n)

         ! Set the pADPs and errors
         .set_pADP_vector_to(X)
         .set_pADP_errors_to(dX)

         ! Clean
         dX.destroy
          X.destroy

      end

      ! Expand if necessary.
      ! New (if any) values to zero.
      if (dim>.pADP_vector.dim) then
         .pADP_vector.resize(dim,init=ZERO)
         .pADP_errors.resize(dim,init=ZERO)
      end

   end

! Set vector

   set_pADP_vector_to(X)
   ! Set the pADP vector from vector "X".
   ! NOTE: Also sets positions and ADP_tensor.
   ! NOTE: "X" musts be correct size.
      self :: INOUT
      X :: VEC{REAL}, IN

   DIE_IF(X.dim<9,"X too small")

      ! Set positions
      .position(1) = X(1)
      .position(2) = X(2)
      .position(3) = X(3)

      ! Set ADP tensor
      .ADP_tensor(1,1) = X(4)
      .ADP_tensor(2,2) = X(5)
      .ADP_tensor(3,3) = X(6)
      .ADP_tensor(1,2) = X(7)
      .ADP_tensor(2,1) = X(7)
      .ADP_tensor(1,3) = X(8)
      .ADP_tensor(3,1) = X(8)
      .ADP_tensor(2,3) = X(9)
      .ADP_tensor(3,2) = X(9)

      ! Set. Must be correct size
      if (.pADP_vector.created) then
         DIE_IF(.pADP_vector.dim/=X.dim,"wrong size, X")
         .pADP_vector = X
      end

   end

   set_ADP2_vector_to(U)
   ! Set the ADP2s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<9,"pADP_vector: wrong size")
   DIE_IF(U.dim/=6,"wrong size, U")

      .pADP_vector( 4: 9) = U( 1: 6)

   end

   set_ADP3_vector_to(U)
   ! Set the ADP3s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<19,"no pADP3s")
   DIE_IF(U.dim/=10,"wrong size, U")

      .pADP_vector(10:19) = U( 1:10)

   end

   set_ADP4_vector_to(U)
   ! Set the ADP4s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<34,"no pADP4s")
   DIE_IF(U.dim/=15,"wrong size, U")

      .pADP_vector(20:34) = U( 1:15)

   end

! Set tensors

   set_ADP3_vector_to(adp3)
   ! Set the ADP3s from the "adp3" tensor into the pADP_vector.
      self :: INOUT
      adp3 :: MAT3{REAL}(3,3,3), OUT

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      v3,w3 :: VEC{REAL}(10)

      ! Compress tensor -> lower pyramid
      adp3.compress_to_pyramid(v3)

      ! Reorder from lower pyramid -> lexical
      GAUSSIAN_DATA:lower_pyramid_to_lexical_3(v3,w3)

      ! Set it
      .set_ADP3_vector_to(w3)

   end

   set_ADP4_vector_to(adp4)
   ! Set the ADP4s into the "adp3" tensor from the pADP_vector.
      self :: INOUT
      adp4 :: MAT4{REAL}(3,3,3,3), OUT

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      v4,w4 :: VEC{REAL}(15)

      ! Compress tensor -> lower pyramid
      adp4.compress_to_pyramid(v4)

      ! Reorder from lower pyramid -> lexical
      GAUSSIAN_DATA:lower_pyramid_to_lexical_4(v4,w4)

      ! Set it
      .set_ADP4_vector_to(w4)

   end

! Set errors

   set_pADP_errors_to(dX)
   ! Set the parameter errors (positions and ADPs) to "dX".
   ! NOTE: The pADP's and errors must be already created
   ! NOTE: "dX" must be correct size.
      self :: INOUT
      dX :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim/=dX.dim,"wrong size, dX")

      .pADP_errors = dX

   end

   set_ADP2_errors_to(dU)
   ! Set the second-order ADP errors from vector "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<9,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=6,"wrong size, dU")

      .pADP_errors( 4: 9) = dU( 1: 6)

   end

   set_ADP3_errors_to(dU)
   ! Set the ADP3 errors from vector "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<19,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=10,"wrong size, dU")

      .pADP_errors(10:19) = dU( 1:10)

   end

   set_ADP4_errors_to(dU)
   ! Set the ADP4 errors from "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<34,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=15,"wrong size, dU")

      .pADP_errors(20:34) = dU( 1:15)

   end

! Put vector

   put_pos_vector_to(X,fac)
   ! Put the pisition vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(X.dim/=3,"wrong size, X")

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1)     =      .position(1)
         X(2)     =      .position(2)
         X(3)     =      .position(3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(X(1:3)),"inconsistent position and pADP_vector")
         end

      else ! Change length units

         ! Set from position
         X(1)     = fac *.position(1)
         X(2)     = fac *.position(2)
         X(3)     = fac *.position(3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(X(1:3)/fac ),"inconsistent position and pADP_vector")
         end

      end

   end

   put_pADP_vector_to(X,fac)
   ! Put the pADP vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1)     =      .position(1)
         X(2)     =      .position(2)
         X(3)     =      .position(3)

         ! Set from ADP_tensor
         X(4)     =      .ADP_tensor(1,1)
         X(5)     =      .ADP_tensor(2,2)
         X(6)     =      .ADP_tensor(3,3)
         X(7)     =      .ADP_tensor(1,2)
         X(8)     =      .ADP_tensor(1,3)
         X(9)     =      .ADP_tensor(2,3)

         ! Set remaining ADPs
         if (.pADP_vector.created) then

         ENSURE(.pADP_vector(1:3).equals(X(1:3)),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)),"inconsistent ADP_tensor and pADP_vector")

         if (.pADP_vector.dim>=19) then
         DIE_IF(X.dim<19,"wrong size, X")
         X(10:19) =      .pADP_vector(10:19)
         end

         if (.pADP_vector.dim>=34) then
         DIE_IF(X.dim<34,"wrong size, X")
         X(20:34) =      .pADP_vector(20:34)
         end

         end

      else ! Change length units

         ! Length scales
         fac2     = fac *fac
         fac3     = fac *fac2
         fac4     = fac *fac3

         ! Set from position
         X(1)     = fac *.position(1)
         X(2)     = fac *.position(2)
         X(3)     = fac *.position(3)

         ! Set from ADP_tensor
         X(4)     = fac2*.ADP_tensor(1,1)
         X(5)     = fac2*.ADP_tensor(2,2)
         X(6)     = fac2*.ADP_tensor(3,3)
         X(7)     = fac2*.ADP_tensor(1,2)
         X(8)     = fac2*.ADP_tensor(1,3)
         X(9)     = fac2*.ADP_tensor(2,3)

         ! Set remaining ADPs
         if (.pADP_vector.created) then

         ENSURE(.pADP_vector(1:3).equals(X(1:3)/fac ),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)/fac2),"inconsistent ADP_tensor and pADP_vector")

         if (.pADP_vector.dim>=19) then
         DIE_IF(X.dim<19,"wrong size, X")
         X(10:19) = fac3*.pADP_vector(10:19)
         end

         if (.pADP_vector.dim>=34) then
         DIE_IF(X.dim<34,"wrong size, X")
         X(20:34) = fac4*.pADP_vector(20:34)
         end

         end

      end

   end

   put_pADP2_vector_to(X,fac)
   ! Put the pADP2 vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(X.dim/=9,"wrong size, X")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1)     =      .position(1)
         X(2)     =      .position(2)
         X(3)     =      .position(3)

         ! Set from ADP_tensor
         X(4)     =      .ADP_tensor(1,1)
         X(5)     =      .ADP_tensor(2,2)
         X(6)     =      .ADP_tensor(3,3)
         X(7)     =      .ADP_tensor(1,2)
         X(8)     =      .ADP_tensor(1,3)
         X(9)     =      .ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(X(1:3)),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)),"inconsistent ADP_tensor and pADP_vector")
         end

      else ! Change length units

         ! Length scales
         fac2     = fac *fac

         ! Set from position
         X(1)     = fac *.position(1)
         X(2)     = fac *.position(2)
         X(3)     = fac *.position(3)

         ! Set from ADP_tensor
         X(4)     = fac2*.ADP_tensor(1,1)
         X(5)     = fac2*.ADP_tensor(2,2)
         X(6)     = fac2*.ADP_tensor(3,3)
         X(7)     = fac2*.ADP_tensor(1,2)
         X(8)     = fac2*.ADP_tensor(1,3)
         X(9)     = fac2*.ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(X(1:3)/fac ),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)/fac2),"inconsistent ADP_tensor and pADP_vector")
         end

      end

   end

   put_ADP2_vector_to(U,fac)
   ! Put the second-order ADPs into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim/=6,"wrong size, U")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from ADP tensor
         U(1)     =      .ADP_tensor(1,1)
         U(2)     =      .ADP_tensor(2,2)
         U(3)     =      .ADP_tensor(3,3)
         U(4)     =      .ADP_tensor(1,2)
         U(5)     =      .ADP_tensor(1,3)
         U(6)     =      .ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(4:9).equals(U(1:6)),"inconsistent ADP_tensor and pADP_vector")
         end

      else ! Change length units

         ! Length scales
         fac2     = fac *fac

         ! Set from ADP tensor
         U(1)     = fac2*.ADP_tensor(1,1)
         U(2)     = fac2*.ADP_tensor(2,2)
         U(3)     = fac2*.ADP_tensor(3,3)
         U(4)     = fac2*.ADP_tensor(1,2)
         U(5)     = fac2*.ADP_tensor(1,3)
         U(6)     = fac2*.ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(4:9).equals(U(1:6)/fac2),"inconsistent ADP_tensor and pADP_vector")
         end

      end

   end

   put_ADP3_vector_to(U,fac)
   ! Put the ADP3s into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<19,"no pADP3s")
   DIE_IF(U.dim/=10,"wrong size, U")

      fac2,fac3 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         U( 1:10) =      .pADP_vector(10:19)

      else ! Change length units

         ! Length scales
         fac2     = fac *fac
         fac3     = fac *fac2

         U( 1:10) = fac3*.pADP_vector(10:19)

      end

   end

   put_ADP4_vector_to(U,fac)
   ! Put the ADP4s into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<34,"no pADP4s")
   DIE_IF(U.dim/=15,"wrong size, U")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         U( 1:15) =      .pADP_vector(20:34)

      else ! Change length units

         ! Length scales
         fac2     = fac *fac
         fac3     = fac *fac2
         fac4     = fac *fac3

         U( 1:15) = fac4*.pADP_vector(20:34)

      end

   end

! Put errors

   put_pos_errors_to(dX,fac)
   ! Put the position errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(dX.dim/=3,"wrong size, dX")

      dX = ZERO

      ! Return if there are no errors
      if (.pADP_errors.destroyed) return

      ! In atomic units
      if (NOT present(fac)) then

         ! Copy all errors
         dX( 1: 3) =      .pADP_errors( 1: 3)

      else ! Change length units

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)

      end

   end

   put_pADP_errors_to(dX,fac)
   ! Put the pADP errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim/=dX.dim,"wrong size, dX")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Copy all errors
         dX( 1: 3) =      .pADP_errors( 1: 3)
         dX( 4: 9) =      .pADP_errors( 4: 9)

         if (.pADP_errors.dim>=19) then
         dX(10:19) =      .pADP_errors(10:19)
         end

         if (.pADP_errors.dim>=34) then
         dX(20:34) =      .pADP_errors(20:34)
         end

      else ! Change length units

         ! Length scales
         fac2      = fac *fac
         fac3      = fac *fac2
         fac4      = fac *fac3

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)
         dX( 4: 9) = fac2*.pADP_errors( 4: 9)

         if (.pADP_errors.dim>=19) then
         dX(10:19) = fac3*.pADP_errors(10:19)
         end

         if (.pADP_errors.dim>=34) then
         dX(20:34) = fac4*.pADP_errors(20:34)
         end

      end

   end

   put_pADP2_errors_to(dX,fac)
   ! Put the pADP2 errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<9,"wrong size, pADP_errors")
   DIE_IF(dX.dim/=9,"wrong size, dX")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Copy all errors
         dX( 1: 3) =      .pADP_errors( 1: 3)
         dX( 4: 9) =      .pADP_errors( 4: 9)

      else ! Change length units

         ! Length scales
         fac2      = fac *fac

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)
         dX( 4: 9) = fac2*.pADP_errors( 4: 9)

      end

   end

   put_ADP2_errors_to(dU,fac)
   ! Put the second-order ADP errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<9,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=6,"wrong size, dU")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1: 6) =      .pADP_errors( 4: 9)

      else ! Change length units

         fac2      = fac *fac

         dU( 1: 6) = fac2*.pADP_errors( 4: 9)

      end


   end

   put_ADP3_errors_to(dU,fac)
   ! Put the ADP3 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<19,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=10,"wrong size, dU")

      fac2,fac3 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1:10) =      .pADP_errors(10:19)

      else ! Change length units

         ! Length scales
         fac2      = fac *fac
         fac3      = fac *fac2

         dU( 1:10) = fac3*.pADP_errors(10:19)

      end


   end

   put_ADP4_errors_to(dU,fac)
   ! Put the ADP4 errors into "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<34,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=15,"wrong size, dU")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1:15) =      .pADP_errors(20:34)

      else ! Change length units

         ! Length scales
         fac2      = fac *fac
         fac3      = fac *fac2
         fac4      = fac *fac3

         dU( 1:15) = fac4*.pADP_errors(20:34)

      end


   end

! Put labels

   put_pos_labels_to(lab)
   ! Set the poisition labels for parameter with
   ! index "par_index"
      lab :: VEC{STR}(3)

      i :: INT

      do i = 1,3
         lab(i) = .pADP_label(i)
      end

   end

   put_pADP_labels_to(lab)
   ! Set positional-ADP labels for parameter with index "par_index"
      lab :: VEC{STR}

      i,n :: INT

      n = .no_of_pADPs

      do i = 1,n
         lab(i) = "U_"//trim(.pADP_index_label(i))
      end

   end

   put_ADP2_labels_to(lab)
   ! Set the second order ADP labels for parameter with
   ! index "par_index"
      lab :: VEC{STR}(6)

      i :: INT

      do i = 1,6
         lab(i) = .ADP_label(i)
      end

   end

   put_ADP3_labels_to(lab)
   ! Set the ADP3 labels for parameter with index "par_index"
      lab :: VEC{STR}(10)

      i :: INT

      do i = 1,10
         lab(i) = .ADP3_label(i)
      end

   end

   put_ADP4_labels_to(lab)
   ! Set the ADP4 labels for parameter with index "par_index"
      lab :: VEC{STR}(15)

      i :: INT

      do i = 1,15
         lab(i) = .ADP4_label(i)
      end

   end

! Transform

   transform_pADP_vector_with(R)
   ! Transform the pADP vector, using the rotation matrix "R".
   ! e.g. transformed = R . pos
   ! NOTE: this works even if pADP_vector is *not* created,
   ! then it works on the positions and ADPs.
      R :: MAT{REAL}(3,3), IN

   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      W :: MAT{REAL}*
      X,U :: VEC{REAL}*

      ! Create
      X.create(.no_of_pADPs)

      ! Transform position
      if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(.position),"pADP_vector /= position")
      end
      X(1:3).to_product_of(R,.position)

      ! Transform ADP's
      W.create(6,6)
      GAUSSIAN_DATA:symmetric_tensor_2_product_mx(W,R)
      U.create(6)
      .put_ADP2_vector_to(U)
      X(4:9).to_product_of(W,U)
      U.destroy
      W.destroy

      ! Transform ADP3's
      if (.pADP_vector.created) then
      if (.pADP_vector.dim>=19) then
      W.create(10,10)
      GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,R)
      X(10:19).to_product_of(W,.pADP_vector(10:19))
      W.destroy
      end
      end

      ! Transform ADP4's
      if (.pADP_vector.created) then
      if (.pADP_vector.dim>=34) then
      W.create(15,15)
      GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,R)
      X(20:34).to_product_of(W,.pADP_vector(20:34))
      W.destroy
      end
      end

      ! Set pADPs
      .set_pADP_vector_to(X)

      ! Clean
      X.destroy

   end

!  ===============
!  Set atom groups
!  ===============

   set_isotropic_ADP
   ! Set the ADP to be isotropic.

      val :: REAL
      ADP :: MAT{REAL}(3,3)

      ! The averaged trace
      val = THIRD * (.ADP_tensor(1,1)+.ADP_tensor(2,2)+.ADP_tensor(3,3))

      ! Make it isotropic
      ADP      = ZERO
      ADP(1,1) = val
      ADP(2,2) = val
      ADP(3,3) = val

      .set_ADP_tensor(ADP)

   end

   set_group(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.group), pure
   ! Generic set
   end

!  ==================
!  Set site occupancy
!  ==================

   set_site_occupancy(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.site_occupancy), pure
   ! Generic set
   end

   set_site_disorder_group(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.site_disorder_group), pure
   ! Generic set
   end

!  =====================
!  Set atomic properties
!  =====================

   set_charge(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.charge), pure
   ! Generic set
   end

   set_dipole(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.dipole), pure
   ! Generic set
   end

   set_quadrupole(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.quadrupole), pure
   ! Generic set
   end

   set_spin(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.spin), pure
   ! Generic set
   end

   set_spin_dipole(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.spin_dipole), pure
   ! Generic set
   end

   set_spin_quadrupole(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.spin_quadrupole), pure
   ! Generic set
   end

   set_charge_polarisability(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.charge_polarisability), pure
   ! Generic set
   end

   set_dipole_polarisability(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.dipole_polarisability), pure
   ! Generic set
   end

   set_energy(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.energy), pure
   ! Generic set
   end

   set_atom_bonded_range_factor(fac) ::: selfless
   ! Set the range factor to decide when atoms are bonded.
      fac :: REAL
   ENSURE(fac>ZERO,"range factor must be grreater than zero")
      atom_bonded_range_factor = fac
   end

   set_covalent_radii_ccdc
   ! Set the the covalent radii for a given atomic number.
      an :: INT
      new_radius :: REAL

      if (FALSE) self = self

      stdin.read(an)
      ENSURE(an>0 AND an<111,"atomic number out of range")
      stdin.read_quantity(new_radius)

      covalent_radii_ccdc(an) = new_radius*ANGSTROM_PER_BOHR

   end

   set_vdw_radii_ccdc
   ! Set the the VDW radii for a given atomic number.
      an :: INT
      new_radius :: REAL

      if (FALSE) self = self

      stdin.read(an)
      ENSURE(an>0 AND an<111,"atomic number out of range")
      stdin.read_quantity(new_radius)

      vdw_radii_ccdc(an) = new_radius*ANGSTROM_PER_BOHR

   end

!  ==============
!  Set basis info
!  ==============

   set_basis_kind(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.basis_kind), pure
   ! Generic set
   end

   set_basis_label(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.basis_label), pure
   ! Generic set
   end

   set_slaterbasis_label(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.slaterbasis_label), pure
   ! Generic set
   end

   set_coppensbasis_label(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.coppensbasis_label), pure
   ! Generic set
   end

!  ============================
!  Set atom (unique) kind index
!  ============================

   set_kind(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.kind)
   ! Generic set
   end

   set_is_unique_kind(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.is_unique_kind)
   ! Generic set
   end

!  ================================
!  Set ANO data and shell info made
!  ================================

   set_ANOs_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.ANOs_made)
   ! Generic set
   end

   set_spherical_atom_data_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.spherical_atom_data_made)
   ! Generic set
   end

   set_shell_info_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.shell_info_made)
   ! Generic set
   end

!  =======================
!  Set interpolators made?
!  =======================

   set_use_interpolator(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_interpolator)
   ! Generic set
   end

   set_ANO_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.ANO_interpolators_made)
   ! Generic set
   end

   set_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.interpolators_made)
   ! Generic set
   end

!  ============
!  I/O Routines
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR, IN
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}                            ")  ! exit case
         case ("adp_axis_system=             "); .read_ADP_axis_system
         case ("adp_tensor=                  "); .read_ADP_tensor
         case ("adp2_tensor=                 "); .read_ADP_tensor
         case ("adp3_tensor=                 "); .read_ADP3_tensor
         case ("adp4_tensor=                 "); .read_ADP4_tensor
         case ("axis_system=                 "); .read_axis_system
         case ("basis_label=                 "); .read_basis_label
         case ("b_eq=                        "); .read_B_iso
         case ("b_iso=                       "); .read_B_iso
         case ("charge=                      "); .read_charge
         case ("coppensbasis_label=          "); .read_coppensbasis_label
         case ("dipole=                      "); .read_dipole
         case ("group=                       "); .read_group
         case ("junk=                        "); .read_junk
         case ("label=                       "); .read_label
         case ("mass_number=                 "); .read_mass_number
         case ("mm_atom_type=                "); .read_mm_atom_type
         case ("mm_charge=                   "); .read_mm_charge
         case ("mm_forcefield_name=          "); .read_mm_forcefield_name
         case ("nuclear_charge=              "); .read_nuclear_charge
         case ("oxidation_state=             "); .read_oxidation_state
         case ("pdb_input_line=              "); .read_pdb_input_line
         case ("pos=                         "); .read_position ! deprecated
         case ("position=                    "); .read_position
         case ("put                          "); .put
         case ("put_interpolator             "); .put_interpolator
         case ("residue_atom_code=           "); .read_residue_atom_code
         case ("residue_code=                "); .read_residue_code
         case ("restraining_position=        "); .read_restraining_position
         case ("restraining_force_constant=  "); .read_restraining_force
         case ("residue_sequence_number=     "); .read_residue_sequence_number
         case ("set_covalent_radii_ccdc      "); .set_covalent_radii_ccdc
         case ("set_vdw_radii_ccdc           "); .set_vdw_radii_ccdc
         case ("site_disorder_group=         "); .read_site_disorder_group
         case ("site_occupancy=              "); .read_site_occupancy
         case ("slaterbasis_label=           "); .read_slaterbasis_label
         case ("thermal_axis_system=         "); .read_ADP_axis_system ! deprecated
         case ("thermal_tensor=              "); .read_ADP_tensor ! deprecated
         case ("u_eq=                        "); .read_U_iso
         case ("u_iso=                       "); .read_U_iso
         case ("u_tensor=                    "); .read_ADP_tensor
         case ("u2_tensor=                   "); .read_ADP_tensor
         case ("u3_tensor=                   "); .read_ADP3_tensor
         case ("u4_tensor=                   "); .read_ADP4_tensor
         case ("units=                       "); .read_units
         case  default;                        UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_group
   ! Read the index which describes the group the atom belongs to.
      stdin.read(.group)
   end

   read_position ::: leaky
   ! Read in the position. The pADP_vector is set also.
      pos :: VEC{REAL}(3)

      ! Read
      stdin.read_quantity(pos)

      ! Set
      .reset_pADPs_and_errors(9)
      .set_position(pos)

   end

   read_label
   ! Read an ATOM label.
      self :: IN
      label :: STR

      stdin.read(label)
      .set_atom_data_from_label(label)

   end

   read_mass_number
   ! Read the neutron mass number
      self :: INOUT
      n :: INT

      stdin.read(n)
      .set_mass_number(n)

   end

   read_charge
   ! Read the charge
      stdin.read(.charge)
   end

   read_nuclear_charge
   ! Read the charge
      stdin.read(.nuclear_charge)
   end

   read_dipole
   ! Read the dipole
      stdin.read_quantity(.dipole)
   end

   read_oxidation_state
   ! Read the oxidation state
      stdin.read(.oxidation_state)
   end

   read_residue_atom_code
   ! Read the atom code describing where in the residue this atom
   ! resides (case sensitive).
      stdin.read(.residue_atom_code)
   end

   read_residue_code
   ! Read the residue name that this atom belongs to.
      stdin.read(.residue_code)
   end

   read_pdb_input_line
   ! Read a line in the PDB input style
      word :: STR
      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="atom","PDB line does not begin with 'atom'")
      .read_residue_atom_code
      .read_residue_code
      .read_residue_sequence_number
      .read_position
      .read_junk
      .read_junk
      .read_label
   end

   read_residue_sequence_number
   ! Read the residue sequence number of the atom in the molecule
      stdin.read(.residue_sequence_number)
   end

   read_mm_atom_type
   ! Read the atom type potential, used to define the force field potential
      stdin.read(.mm_atom_type)
   end

   read_mm_charge
   ! Read the MM charge on this atom
      stdin.read(.mm_charge)
   end

   read_mm_forcefield_name
   ! Read the MM forcefield name for this atom
      stdin.read(.mm_forcefield_name)
   end

   read_restraining_position
   ! Read the restraining position
      stdin.read_quantity(.restraining_position)
   end

   read_restraining_force
   ! Read the restrain force constant for this atom
      stdin.read_quantity(.restraining_force_constant)
   end

   read_site_disorder_group
   ! Read the site disorder group, used mainly for crystallographic applications.
      stdin.read(.site_disorder_group)
      DIE_IF(.site_disorder_group<0,"site_disorder_group must be non -ve")
   end

   read_site_occupancy
   ! Read the site occupancy, used mainly for crystallographic applications.
      stdin.read(.site_occupancy)
      DIE_IF(.site_occupancy<=ZERO,"site_occupancy must be +ve")
      DIE_IF(.site_occupancy> ONE ,"site_occupancy must be less than one")
   end

   read_axis_system
   ! Read a string which describes the axis system. Currently allowed is
   ! "cartesian" or "crystal". NOTE: .ADP_axis_system is changed too.

      word :: STR

      stdin.read(word)

      .set_axis_system(word)

   end

   read_ADP_axis_system
   ! Read a string which describes the ADP (thermal tensor) axis system.
   ! Currently allowed, is "cartesian" or "crystal".

      word :: STR

      stdin.read(word)

      .set_ADP_axis_system(word)

   end

   read_basis_label ::: leaky
   ! Read the basis set label from "stdin" which will be used to match
   ! a basis set to ... the element symbol will be prepended.

      stdin.read(.basis_label)

      ! If no element symbol, prepend it
    ! if (.basis_label.does_not_include(':')) then
    !    .basis_label = trim(.chemical_symbol) // ':' // trim(.basis_label)
    ! end

   end

   read_slaterbasis_label ::: leaky
   ! Read the slater basis set label from "stdin" which will be used
   ! to match a basis set to ... the element symbol may be prepended

      stdin.read(.slaterbasis_label)

      ! If no element symbol, prepend it
      if (.basis_label.does_not_include(':')) then
         .basis_label = trim(.generic_chemical_symbol) // ':' // trim(.basis_label)
      end

   end

   read_coppensbasis_label ::: leaky
   ! Read the Coppens basis set label from "stdin" which will be used to match a
   ! basis set to ... (in fact there is only one coppens basis type)

      stdin.read(.coppensbasis_label)

      ! If no element symbol, prepend it
      if (.basis_label.does_not_include(':')) then
         .basis_label = trim(.generic_chemical_symbol) // ':' // trim(.basis_label)
      end

   end

   read_U_iso
   ! Read the isotropic thermal parameters from "stdin".  NOTE: units are
   ! Bohr^2, not Angstrom^2.
      stdin.read_quantity(.U_iso)
   end

   read_B_iso
   ! Read the isotropic B factor.NOTE: units are Bohr^2, not Angstrom^2.
      B_iso :: REAL

      ! Read
      stdin.read_quantity(B_iso)

      ! Set
      .U_iso = B_iso/(EIGHT*PI*PI)

   end

   read_ADP_tensor ::: leaky
   ! Read the ADP (thermal) from "stdin". These are assumed to be in the
   ! cartesian axis system, and in bohr^2.  The expansion of the thermal
   ! smearing temperature factor term is:
   !              TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where (h) are the miller indices and (a^*) are the reciprocal lattice
   ! constants in angstrom^{-2}.
   ! NOTE: The pADP_vector/pADP_errors are set also.
      ADP :: VEC{REAL}(6)

      ! Read elements in lexical order
      stdin.read_quantity(ADP)

      ! Set the tensor
      .reset_pADPs_and_errors(9)
      .set_ADP_tensor(ADP)

   end

   read_ADP3_tensor ::: leaky
   ! Read the third-order ADP (thermal) tensor, assumed to be in the
   ! cartesian axis system, and in bohr^2. The interpretation of these
   ! coefficients as Gram-Charlier, Edgeworth, cumulants or other is
   ! not specified.
      tensor :: VEC{REAL}(10)

      ! Read elements in lexical order
      stdin.read_quantity(tensor)

      ! Set the tensor
      .reset_pADPs_and_errors(19)
      .set_ADP3_vector_to(tensor)

   end

   read_ADP4_tensor ::: leaky
   ! Read the fourth-order ADP (thermal) tensor, assumed to be in the
   ! cartesian axis system, and in bohr^2. The interpretation of these
   ! coefficients as Gram-Charlier, Edgeworth, cumulants or other is
   ! not specified.
      tensor :: VEC{REAL}(15)

      ! Read elements in lexical order
      stdin.read_quantity(tensor)

      ! Set the tensor
      .reset_pADPs_and_errors(34)
      .set_ADP4_vector_to(tensor)

   end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   ENSURE(keys.created,"no keys")
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!  ===================
!  Axis change methods
!  ===================

   change_axis_system_to(axis_system,cell)
   ! Change the axis system for the position *and* ADP tensors to
   ! "axis_system", either "crystal" or "cartesian". "cell" has the
   ! unit cell axis system.
   ! NOTE: Errors are *not* transformed since that needs covariances.
   !       The errors must be transformed outside this routine.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      .change_axis_system_to_v1(axis_system,cell)

   end

   change_axis_system_to_v1(axis_system,cell)
   ! Change the axis system for the position *and* ADP tensors to "axis_system",
   ! either "crystal" or "cartesian". "cell" holds the unit cell axis system
   ! information. Specify the "form" for the anharmonic ADPs.
   ! NOTE: Errors are *not* transformed since that needs covariances.
   !       The errors must be transformed outside this routine.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      .change_pos_axis_system_to(axis_system,cell)
      .change_ADP2_tensor_to(axis_system,cell)
      .change_ADPn_tensor_to_v1(axis_system,cell)

   end

   change_axis_system_to_v2(axis_system,cell)
   ! Change the axis system for the position *and* ADP tensors to "axis_system",
   ! either "crystal" or "cartesian". "cell" holds the unit cell axis system
   ! information. Specify the "form" for the anharmonic ADPs.
   ! NOTE: Errors are *not* transformed since that needs covariances.
   !       The errors must be transformed outside this routine.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      .change_pos_axis_system_to(axis_system,cell)
      .change_ADP2_tensor_to(axis_system,cell)
      .change_ADPn_tensor_to_v2(axis_system,cell)

   end


   change_pos_axis_system_to(axis_system,cell)
   ! Change atom positions to a new "axis_system".
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      pos :: VEC{REAL}(3)

      select case (axis_system)

         case ("cartesian")

            if (.pos_axis_system=="cartesian") return

            pos.to_product_of(cell.direct_matrix,.position)
            .set_position(pos)
            .pos_axis_system = "cartesian"

         case ("crystal  ")

            if (.pos_axis_system=="crystal") return

            pos.to_product_of(cell.inverse_matrix,.position)
            .set_position(pos)
            .pos_axis_system = "crystal"

         case default
            UNKNOWN(axis_system)

      end

   end


   change_ADP_axis_system_to(axis_system,cell)
   ! Change *all* ADP tensor to the desired "axis_system". The axes
   ! are described by the unit "cell". 
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      .change_ADP_axis_system_to_v1(axis_system,cell)

   end

   change_ADP_axis_system_to_v1(axis_system,cell) ::: private
   ! Change *all* ADP tensor to the desired "axis_system". The axes
   ! are described by the unit "cell". 
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      .change_ADP2_tensor_to(axis_system,cell)
      .change_ADPn_tensor_to_v1(axis_system,cell)

   end

!   change_ADP_axis_system_to_v2(axis_system,cell) ::: private
!   ! Change *all* ADP tensor to the desired "axis_system". The axes
!   ! are described by the unit "cell". 
!      self :: INOUT
!      axis_system :: STR, IN
!      cell :: UNIT_CELL, IN
!
!      .change_ADP2_tensor_to(axis_system,cell)
!      .change_ADPn_tensor_to_v2(axis_system,cell)
!
!   end


   change_ADP2_tensor_to(axis_system,cell)
   ! Change ADP2/s axis system into the "axis_system" frame.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      ADP :: MAT{REAL}(3,3)
      chk :: BIN
      val :: REAL

      chk = FALSE

      select case (axis_system)

         case ("cartesian")

            if (.ADP_axis_system=="cartesian") return

            ! Convert U_iso to an ADP and use it if necessary
            if (.U_iso>ZERO) then

               if (.ADP_tensor.is_zero) then

                  ! Note: U_iso/U_eq is always in cartesian system
                  ! Change ADP to crystal axis system
                  ADP.to_unit_matrix
                  ADP = ADP*.U_iso
                  ADP.change_basis_using(cell.reciprocal_U_matrix)
                  .set_ADP_tensor(ADP)

               else

                  ! ADP exists already
                  ! Check U_iso later ...
                  chk = TRUE

               end

            end

            ! Change to cartesians !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            .ADP_tensor.change_basis_to(ADP,cell.direct_U_matrix)
            .set_ADP_tensor(ADP)
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

            ! Set U_iso.
            ! Could also check if the supplied U_iso was correct
            if (chk) then
               val = THIRD*.ADP_tensor.trace
               .U_iso = val
            end

            ! Set axis system
            .ADP_axis_system = "cartesian"

         case ("crystal")

            if (.ADP_axis_system=="crystal") return

            .ADP_tensor.change_basis_to(ADP,cell.reciprocal_U_matrix)
            .set_ADP_tensor(ADP)

            ! Set axis system
            .ADP_axis_system = "crystal"

         case default
            UNKNOWN(axis_system)

      end

   end


   change_ADPn_tensor_to_v1(axis_system,cell) ::: private
   ! Change ADPn vector to the "axis_system" frame.
   ! If "crystal",  then dimensionless Gram-Charlier is made.
   ! Checked on SO2, 15/02/16 against v2 code.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      W :: MAT{REAL}*
      pADP :: VEC{REAL}*

      select case (axis_system)

         case ("cartesian")

            if (.ADPn_axis_system=="cartesian") return

            .ADPn_axis_system = "cartesian"

            if (NOT .has_ADP3s) return

            ! Transform ADP3's
            W.create(10,10)
            pADP.create(10)
            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,transpose(cell.direct_matrix))
            pADP.to_product_of(W,.pADP_vector(10:19))
            .pADP_vector(10:19) = pADP
            pADP.destroy
            W.destroy

            if (NOT .has_ADP4s) return

            ! Transform ADP4's
            W.create(15,15)
            pADP.create(15)
            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,transpose(cell.direct_matrix))
            pADP.to_product_of(W,.pADP_vector(20:34))
            .pADP_vector(20:34) = pADP
            pADP.destroy
            W.destroy

         case ("crystal")

            if (.ADPn_axis_system=="crystal") return

            .ADPn_axis_system = "crystal"

            if (NOT .has_ADP3s) return

            ! Transform ADP3's
            W.create(10,10)
            pADP.create(10)
            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,cell.reciprocal_matrix)
            pADP.to_product_of(W,.pADP_vector(10:19))
            .pADP_vector(10:19) = pADP
            pADP.destroy
            W.destroy

            if (NOT .has_ADP4s) return

            ! Transform ADP4's
            W.create(15,15)
            pADP.create(15)
            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,cell.reciprocal_matrix)
            pADP.to_product_of(W,.pADP_vector(20:34))
            .pADP_vector(20:34) = pADP
            pADP.destroy
            W.destroy

         case default
            UNKNOWN(axis_system)

      end

   end

!   change_ADPn_tensor_to_v1(axis_system,cell) ::: private
!   ! Change ADPn vector to the "axis_system" frame.
!   ! NOTE: Unlike the ADP2's, in the "crystal" axis_system these are
!   ! reported in dimensionless Gram-Charlier "g" form. For
!   ! consistency, we also produce them in dimensioned "u" form
!   ! which have reciprocal lengths in them like the IUCr ADPs
!   ! in the crystal axis system.  However, internally, and during the
!   ! refinement, the axis_system is always "cartesian" and Bohr units.
!      self :: INOUT
!      axis_system :: STR, IN
!      cell :: UNIT_CELL, IN
!
!      W :: MAT{REAL}*
!      pADP :: VEC{REAL}*
!      fac1,fac3,fac4 :: REAL
!
!      fac1 = ANGSTROM_PER_BOHR
!      fac3 = ANGSTROM_PER_BOHR**3
!      fac4 = ANGSTROM_PER_BOHR**4
!
!
!      select case (axis_system)
!
!         case ("cartesian")
!
!            if (.ADPn_axis_system=="cartesian") return
!
!            .ADPn_axis_system = "cartesian"
!
!            if (NOT .has_ADP3s) return
!
!            ! Transform ADP3's
!            W.create(10,10)
!            pADP.create(10)
!            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,transpose(cell.direct_matrix))
!            pADP.to_product_of(W,.pADP_vector(10:19))
!
!        stdout.text("crystal -> cartn:")
!        stdout.text("D:")
!        stdout.put(cell.direct_matrix*fac1)
!        stdout.text("old pADP:")
!        stdout.put(.pADP_vector(10:19)*1000)
!        stdout.text("new pADP:")
!        stdout.put(pADP*1000*fac3)
!
!            .pADP_vector(10:19) = pADP
!            pADP.destroy
!            W.destroy
!
!            if (NOT .has_ADP4s) return
!
!            ! Transform ADP4's
!            W.create(15,15)
!            pADP.create(15)
!            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,transpose(cell.direct_matrix))
!            pADP.to_product_of(W,.pADP_vector(20:34))
!            .pADP_vector(20:34) = pADP
!            pADP.destroy
!            W.destroy
!
!         case ("crystal")
!
!            if (.ADPn_axis_system=="crystal") return
!
!            .ADPn_axis_system = "crystal"
!
!            if (NOT .has_ADP3s) return
!
!            ! Transform ADP3's
!            W.create(10,10)
!            pADP.create(10)
!            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,cell.reciprocal_matrix)
!            pADP.to_product_of(W,.pADP_vector(10:19))
!
!        stdout.text("cartn -> crystal:")
!        stdout.text("D*:")
!        stdout.put(cell.reciprocal_matrix/fac1)
!        stdout.text("old pADP:")
!        stdout.put(.pADP_vector(10:19)*1000*fac3)
!        stdout.text("new pADP:")
!        stdout.put(pADP*1000)
!
!            .pADP_vector(10:19) = pADP
!            pADP.destroy
!            W.destroy
!
!            if (NOT .has_ADP4s) return
!
!            ! Transform ADP4's
!            W.create(15,15)
!            pADP.create(15)
!            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,cell.reciprocal_matrix)
!            pADP.to_product_of(W,.pADP_vector(20:34))
!            .pADP_vector(20:34) = pADP
!            pADP.destroy
!            W.destroy
!
!         case default
!            UNKNOWN(axis_system)
!
!      end
!
!   end

   change_ADPn_tensor_to_v2(axis_system,cell) ::: private
   ! Change ADPn vector to the "axis_system" frame.
   ! NOTE: Unlike the ADP2's, in the "crystal" axis_system these are
   ! reported in dimensionless Gram-Charlier "g" form. For
   ! consistency, we also produce them in dimensioned "u" form
   ! which have reciprocal lengths in them like the IUCr ADPs
   ! in the crystal axis system.  However, internally, and during the
   ! refinement, the axis_system is always "cartesian" and Bohr units.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN

      adp3,new3 :: MAT3{REAL}(3,3,3)
      adp4,new4 :: MAT4{REAL}(3,3,3,3)

      select case (axis_system)

         case ("cartesian") ! Change INTO cartesian FROM crystal

            if (.ADPn_axis_system=="cartesian") return

            .ADPn_axis_system = "cartesian"

            if (NOT .has_ADP3s) return

            .put_ADP3_to(adp3)
            adp3.back_transform_to(new3,cell.direct_matrix)
            .set_ADP3_vector_to(new3)

            if (NOT .has_ADP4s) return

            .put_ADP4_to(adp4)
            adp4.back_transform_to(new4,cell.direct_matrix)
            .set_ADP4_vector_to(new4)

         case ("crystal")  ! Change INTO crystal FROM cartesian

            if (.ADPn_axis_system=="crystal") return

            .ADPn_axis_system = "crystal"

            if (NOT .has_ADP3s) return

            .put_ADP3_to(adp3)
            adp3.change_basis_to(new3,cell.reciprocal_matrix)
            .set_ADP3_vector_to(new3)

            if (NOT .has_ADP4s) return

            .put_ADP4_to(adp4)
            adp4.change_basis_to(new4,cell.reciprocal_matrix)
            .set_ADP4_vector_to(new4)

         case default
            UNKNOWN(axis_system)

      end

   end

!   change_ADPn_tensor_to_v2(axis_system,cell) ::: private
!   ! Change ADPn vector to the "axis_system" frame.
!   ! NOTE: Unlike the ADP2's, in the "crystal" axis_system these are
!   ! reported in dimensionless Gram-Charlier "g" form. For
!   ! consistency, we also produce them in dimensioned "u" form
!   ! which have reciprocal lengths in them like the IUCr ADPs
!   ! in the crystal axis system.  However, internally, and during the
!   ! refinement, the axis_system is always "cartesian" and Bohr units.
!      self :: INOUT
!      axis_system :: STR, IN
!      cell :: UNIT_CELL, IN
!
!      adp3,new3 :: MAT3{REAL}(3,3,3)
!      adp4,new4 :: MAT4{REAL}(3,3,3,3)
!      fac1,fac3,fac4 :: REAL
!
!      fac1 = ANGSTROM_PER_BOHR
!      fac3 = ANGSTROM_PER_BOHR**3
!      fac4 = ANGSTROM_PER_BOHR**4
!
!
!      select case (axis_system)
!
!         case ("cartesian")
!
!            if (.ADPn_axis_system=="cartesian") return
!
!            .ADPn_axis_system = "cartesian"
!
!            if (NOT .has_ADP3s) return
!
!            .put_ADP3_to(adp3)
!        stdout.text("crystal -> cartn:")
!        stdout.text("Dstar:")
!        stdout.put(cell.direct_matrix*fac1)
!        stdout.text("adp3:")
!        stdout.put(adp3*1000)
!            adp3.back_transform_to(new3,cell.direct_matrix)
!        stdout.text("new3:")
!        stdout.put(new3*fac3*1000)
!            .set_ADP3_vector_to(new3)
!
!            if (NOT .has_ADP4s) return
!
!            .put_ADP4_to(adp4)
!      ! stdout.text("adp4:")
!      ! stdout.put(adp4*10000)
!            adp4.back_transform_to(new4,cell.direct_matrix)
!      ! stdout.text("new4:")
!      ! stdout.put(new4*fac4*10000)
!            .set_ADP4_vector_to(new4)
!
!         case ("crystal")
!
!            if (.ADPn_axis_system=="crystal") return
!
!            .ADPn_axis_system = "crystal"
!
!            if (NOT .has_ADP3s) return
!
!            .put_ADP3_to(adp3)
!
!        stdout.text("cartn -> crystal:")
!        stdout.text("D* in Angstrom-1:")
!        stdout.put(cell.reciprocal_matrix/fac1)
!        stdout.text("adp3 in A^3:")
!        stdout.put(adp3*fac3*1000)
!
!            adp3.change_basis_to(new3,cell.reciprocal_matrix)
!        stdout.text("new3:")
!        stdout.put(new3*1000)
!            .set_ADP3_vector_to(new3)
!
!            if (NOT .has_ADP4s) return
!
!            .put_ADP4_to(adp4)
!      ! stdout.text("adp4 in A^4:")
!      ! stdout.put(adp4*fac4*10000)
!            adp4.change_basis_to(new4,cell.reciprocal_matrix)
!      ! stdout.text("new4:")
!      ! stdout.put(new4*10000)
!            .set_ADP4_vector_to(new4)
!
!         case default
!            UNKNOWN(axis_system)
!
!      end
!
!   end


   change_coordinate_axes(axes)
   ! Change the coordiantes and ADP (thermal) tensors to be expressed
   ! in terms of a new set of orthogonal "axes". We must be n the
   ! cartesian axis system.
      axes :: MAT{REAL}(3,3), IN

   ENSURE(.pos_axis_system=="cartesian","positions must be in cartesian axis system")
   ENSURE(.ADP_axis_system=="cartesian","U's must be in cartesian axis system")
   DIE_IF(.has_ADP3s,"does not work for U3's yet")
   DIE_IF(.has_ADP4s,"does not work for U4's yet")

      pos :: VEC{REAL}(3)
      ADP :: MAT{REAL}(3,3)

      pos.to_product_of(axes,.position)
      .set_position(pos)

      ! WARNING: this may not be correct
      .ADP_tensor.change_basis_to(ADP,axes)
      .set_ADP_tensor(ADP)

   end


!  ========================
!  Basis resolution methods
!  ========================

   resolve_basis(basis,suffix,found) ::: template
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
      basis :: VEC{BASIS?}*
      suffix :: STR, optional
      found :: BIN, optional

   DIE_IF(basis.destroyed,"no basis")

      library_label, symbol :: STR
      fnd :: BIN

      fnd = FALSE

      ! First, try matching the basis from the "suffix"
      ! e.g. like "Mg:STO-3G"
      if (present(suffix)) then
      if (suffix/=" ") then

         ! This makes "Mg:STO-3G"
         library_label = .library_basis_label(suffix)

         ! Pointer assign into "basis"
         TO?.resolve_by_label(library_label,basis,clobber=TRUE,found=fnd)

         ! Set the basis label
         if (fnd) LABEL? = library_label

      end
      end

      ! Next, try matching the basis to an existing label, if there ...
      if (NOT fnd AND LABEL?/=" ") then
         TO?.resolve_by_label(LABEL?,basis,clobber=TRUE,found=fnd)
      end

      ! Last chance: try (minimal) matching using only the chemical symbol ...
      if (NOT fnd) then

         symbol = trim(.generic_chemical_symbol)//":"

         ! Pointer assign into "basis"
         TO?.resolve_by_label(symbol,basis,clobber=TRUE,minmatch=TRUE,found=fnd)

         ! Set the basis label
         if (fnd) LABEL? = TO?.label

      end

      if (present(found)) found = fnd

   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS?=>BASIS, TO?=>.basis, LABEL?=>.basis_label)
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS?=>SLATERBASIS, TO?=>.slaterbasis, LABEL?=>.slaterbasis_label)
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS?=>COPPENSBASIS, TO?=>.coppensbasis, LABEL?=>.coppensbasis_label)
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

!  =========================
!  Atom-kind inquiry methods
!  =========================

   has_a_dummy_label result (res) ::: elemental
   ! Return TRUE if this has a dummy charge label (charged or not,
   ! with basis set or not)
      self :: IN
      res :: BIN
      res = .label==ATOM_DUMMY_CHARGE_LABEL
   end

   is_a_dummy_atom result (res) ::: elemental
   ! Return TRUE if this is a dummy atom (no charge, no basis)
      self :: IN
      res :: BIN

      res = .has_a_dummy_label AND .nuclear_charge==ZERO AND .basis.destroyed

   end

   is_a_nondummy_atom result (res) ::: elemental
   ! Return TRUE if this is a *not* dummy atom
      self :: IN
      res :: BIN
      res = NOT .has_a_dummy_label OR .nuclear_charge/=ZERO OR .basis.created
   end

   is_a_ghost_atom result (res) ::: elemental
   ! Return TRUE if this is a ghost atom
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge==ZERO AND .has_basis
   end

   is_a_point_charge result (res) ::: elemental
   ! Return TRUE if this is a point-charge (no basis set)
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge>ZERO AND .basis.destroyed
   end

   is_a_pseudo_atom result (res) ::: elemental
   ! Return TRUE if this is a pseudo atom without integral charge
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND NOT .nuclear_charge.is_int AND .has_basis
   end

   is_same_kind_as(atom) result (res) ::: pure
   ! Return TRUE if self is the same kind of atom as "atom". The
   ! position and label are not compared since the same kind of atom
   ! can have a different position and label.  To check if the basis
   ! set is the same, only the label is used.
      self :: IN
      atom :: ATOM, IN
      res :: BIN

      bases_created,coppens_created,slater_created :: BIN
      bases_destroyed,coppens_destroyed,slater_destroyed :: BIN
      mixed :: BIN

      ! Which kind of bases created?
      bases_created     = .basis.created        AND atom.basis.created
      coppens_created   = .coppensbasis.created AND atom.coppensbasis.created
      slater_created    = .slaterbasis.created  AND atom.slaterbasis.created

      ! Which kind of bases destroyed?
      bases_destroyed   = .basis.destroyed        AND atom.basis.destroyed
      coppens_destroyed = .coppensbasis.destroyed AND atom.coppensbasis.destroyed
      slater_destroyed  = .slaterbasis.destroyed  AND atom.slaterbasis.destroyed

      ! Mixed bases?
      mixed = NOT (bases_created   OR bases_destroyed)   OR &
              NOT (coppens_created OR coppens_destroyed) OR &
              NOT (slater_created  OR slater_destroyed)

      ! Set same kind
      if (mixed) then

         res = FALSE

      else

         ! Set here ...
         res = .atomic_number==atom.atomic_number
         if (bases_created)   res = res AND .basis.label       ==atom.basis.label
         if (coppens_created) res = res AND .coppensbasis.label==atom.coppensbasis.label
         if (slater_created)  res = res AND .slaterbasis.label ==atom.slaterbasis.label

      end

   end

   is_xtal_identical_to(atom) result (res) ::: elemental
   ! Return true if self and "atom" are crystallographically i.e.
   ! identical based on occupancy and atomic number *and* position.
      self :: IN
      atom :: ATOM, IN
      res :: BIN
      res = .is_xtal_identical_kind_to(atom) AND .position.equals(atom.position)
   end

   is_xtal_identical_kind_to(atom) result (res) ::: elemental
   ! Return true if self and "atom" are crystallographically
   ! identical based on occupancy and atomic number
      self :: IN
      atom :: ATOM, IN
      res :: BIN

      res =         .atomic_number      ==atom.atomic_number
      res = res AND .site_disorder_group==atom.site_disorder_group
      res = res AND .site_occupancy.equals(atom.site_occupancy )

   end

   is_in_cartesian_system result (res) ::: elemental
   ! Return TRUE if the axis system is cartesian
      self :: IN
      res :: BIN

      res = .pos_axis_system=="cartesian" AND .ADP_axis_system=="cartesian"

   end

!  =====================
!  Basis inquiry methods
!  =====================

   has_basis result (res) ::: elemental
   ! Return TRUE if this is a pseudo atom without integral charge
      self :: IN
      res :: BIN
      res = .basis.created AND .basis.is_resolved
   end

   basis_descriptor result (res) ::: template
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
      self :: IN
      res :: STR

      if (.ARG?.created) then
         res = .ARG?.label
         if (.is_a_ghost_atom) then
            res = trim(res)//" (ghost atom)"
         else if (.is_a_pseudo_atom) then
            res = trim(res)//" (pseudo atom)"
         end
      else if (.is_a_point_charge) then
         res = "n/a (pt. charge)"
      else if (.is_a_dummy_atom) then
         res = "n/a (dummy atom)"
      else
         res = "??"
      end

   end

   basis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, ARG?=>basis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   slaterbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, ARG?=>slaterbasis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   coppensbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, ARG?=>coppensbasis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   library_basis_label(suffix) result (label)
   ! Return a library basis set label by appending "suffix" to the
   ! chemical symbol.
      suffix :: STR

      label :: STR
      symbol :: STR

      symbol = .generic_chemical_symbol

      select case (suffix)

         case ("Coppens","Clementi-Roetti")

            ! Replace bases for high atomic numbers
            ! where bases do not exist
            if (.atomic_number>55) then

               select case (.atomic_number)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:86);  symbol = ATOM:generic_chemical_symbol(.atomic_number-32)
                  case (87);     symbol = "Rb"
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end

               WARN("Atom "//trim(.generic_chemical_symbol)//" basis is now "//trim(symbol))

            end

            label = trim(symbol)//trim(.oxidation_state_str)//":"//trim(suffix)

         case default

            label = trim(symbol)//":"//trim(suffix)

      end

   end

   library_basis_label(Z,suffix) result (label) ::: selfless, leaky
   ! Return a library basis set label for the atom with atomic number
   ! "Z", by appending "suffix" to the chemical symbol.
      Z :: INT, IN
      suffix :: STR

   ENSURE(Z>=1 AND Z<=118,"Z out of range")

      label :: STR
      symbol :: STR

      symbol = element_symbols(Z)
      select case (suffix)
         case ("Coppens","Thakkar","Clementi-Roetti")
            if (Z>55) then
               select case (Z)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:86);  symbol = element_symbols(Z-32)
                  case (87);     symbol = "Rb"
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end
            end
            label = trim(symbol)//":"//trim(suffix)
         case default
            label = trim(symbol)//":"//trim(suffix)
      end

   end


   no_of_shells result (res) ::: pure
   ! Return the no of shells
      self :: IN
      res :: INT

      res = .basis.no_of_shells

   end

   no_of_basis_functions result (res) ::: pure
   ! Evaluate and return the no. of basis functions
      self :: IN
      res :: INT

      res = .basis.no_of_basis_functions

   end

   no_of_sph_basis_functions result (res) ::: pure
   ! Evaluate and return the no. of spherical basis functions
      self :: IN
      res :: INT

      res = .basis.no_of_sph_basis_functions

   end

   n_bf result (res) ::: pure
   ! Return the no. of basis functions
      self :: IN
      res :: INT

      res = .basis.n_bf

   end

   no_of_primitives result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT

      res = .basis.no_of_primitives

   end

   no_of_sph_primitives result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT

      res = .basis.no_of_sph_primitives

   end

   n_prim result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT

      res = .basis.n_prim

   end

!  =============================
!  Chemical-data related inquiry
!  =============================

   generic_chemical_symbol result (res) ::: elemental
   ! Return the generic chemical symbol, which ignores isotopes.
      self :: IN
      res :: STR(len=2)

      Z :: INT

      Z = .atomic_number
      res = ATOM:generic_chemical_symbol(Z)

   end

   generic_chemical_symbol(Z) result (res) ::: elemental, selfless
   ! Return the element symbol for atomic number "Z".
      Z :: INT, IN
      res :: STR(len=2)

      res = "?"
      if (Z==0) then
         res = ATOM_DUMMY_CHARGE_LABEL
      else if (Z.is_in_range([1,118])) then
         res = element_symbols(Z)
      end

   end

   chemical_symbol result (res) ::: elemental, public
   ! Return the chemical symbol for this atom. Accounts for D and T.
      self :: IN
      res :: STR(len=2)

      Z,A :: INT

      Z = .atomic_number
      A = .mass_number
      res = ATOM:chemical_symbol(Z,A)

   end

   chemical_symbol(Z,A) result (res) ::: elemental, selfless
   ! The element symbol for atomic number "Z" mass_number "A".
      Z :: INT, IN
      A :: INT, IN
      res :: STR(len=2)

      res = "?"
      if (Z==0) then
         res = ATOM_DUMMY_CHARGE_LABEL
      else if (Z==1 AND A==2) then
         res = "D"
      else if (Z==1 AND A==3) then
         res = "T"
      else if (Z.is_in_range([1,118])) then
         res = element_symbols(Z)
      end

   end

   mass result (res) ::: private, pure
   ! Return the abundance-weighted mass C12 mass units unless
   ! mass_number is non-zero, in which case give the isotope mass.
      self :: IN
      res :: REAL

      if (.mass_number>0) then
         res = ::mass_of_isotope(.atomic_number,.mass_number)
      else
         res = ::mass_of_atom(.atomic_number)
      end

   end

   mass_of_atom(Z) result (res) ::: elemental, selfless
   ! Return the natural-abundance-weighted atomic mass in C12 mass units.
      Z :: INT, IN
      res :: REAL

      res = 0
      if (Z.is_in_range([1,92])) res = atomic_masses(Z)

   end

   mass_of_isotope(Z,A) result (res) ::: elemental, selfless
   ! Return the atomic mass in C12 mass unoits for the isotope with
   ! atomic number "Z" and atomic mass number "A".
      Z :: INT, IN
      A :: INT, IN
      res :: REAL

      Zf,Zl,Af,Al :: INT
      Zr,Ar :: REAL

      Zr = Z
      Ar = A

      Zf = isotope_data(1,  :  ).index_of_value(Zr)
      Zl = isotope_data(1,  :  ).index_of_value(Zr,last=TRUE)
      Af = isotope_data(2,Zf:Zl).index_of_value(Ar)
      Al = isotope_data(2,Zf:Zl).index_of_value(Ar,last=TRUE)

      res = 0
      if (Af==Al) res = isotope_data(3,Af+Zf-1)

   end

   mean_neutron_number result (res) ::: pure
   ! Return the average (abundance weighted) number of neutrons for this atom,
   ! calculated roughly by subtracting the number of protons from the atomic mass.
      self :: IN
      res :: REAL

      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                                            res = .mass - .atomic_number
      end

   end

   bragg_slater_radius result (res) ::: pure
   ! Return the Bragg-Slater radius for this atom
   ! WARNING: this is in Angstroms!
      self :: IN
      res :: REAL

      if      (.atomic_number<1 ) then; res = ZERO
      else if (.atomic_number>54) then; res = 1.30d0
      else;                             res = bragg_slater_radii(.atomic_number)
      end

   end

   neutron_scattering_length result (res) ::: pure
   ! Return the neutron scattering length for this atom
      self :: IN
      res :: REAL

      if (.atomic_number<1 OR .atomic_number>95) then; res = ZERO
      else;                                            res = neutron_scattering_lengths(.atomic_number)
      end

   end

   n_core_electrons(Z) result (noble) ::: pure
   ! Return the number of core electrons for the atom in the n-shell
   ! one less than the valence shell.  If "Z" is present it is used as
   ! the atomic number.
      self :: IN
      Z :: INT, optional, IN
      noble :: INT

      p :: INT
      atomic_number,tmp,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      noble = 0
      if (atomic_number<1) return

      p = 1
      do
         n = (p+2)/2
         tmp = noble + 2*n**2
         if (atomic_number <= tmp) exit
         noble = tmp   ! add core electrons
         p = p + 1     ! next period
      end

   end

   period_number(Z) result (p) ::: pure
   ! Return the period (i.e. row) on which the atom lies.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN

      p :: INT
      atomic_number,noble,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      p = 0
      if (atomic_number<1) return

      p = 1
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end

   end

   column_number(Z) result (col) ::: pure
   ! Return the periodic table column of the atom.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN
      col :: INT

      atomic_number,p,noble,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      col = 0
      if (atomic_number<1) return

      p = 1
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end

      noble = noble - 2*n**2
      col   = atomic_number - noble

   end

   period_block(Z) result (b) ::: PURE
   ! Return the period block character in which the atom lies.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN
      b :: STR(len=1)

   ENSURE(Z>0,"atomic charge Z not +ve")
   ENSURE(.period_number(Z)<8,"Z is too large")

      p,col :: INT

      p   = .period_number(Z)
      col = .column_number(Z)

      b = "?"

      if (p<4) then
         select case (col)
            case (1:2);   b = "s"
            case (3:8);   b = "p"
         end
      else if (p<6) then
         select case (col)
            case (1:2);   b = "s"
            case (3:12);  b = "d"
            case (13:18); b = "p"
         end
      else if (p<8) then
         select case (col)
            case (1:2);   b = "s"
            case (3:16);  b = "f"
            case (17:26); b = "d"
            case (27:32); b = "p"
         end
      end

   end

   is_a_nonmetal(Z) result(res) ::: elemental
   ! Return whether the atom is a nonmetal.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      atomic_number :: INT

      ! Get atomic number
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      res = FALSE

      select case (atomic_number)
         case( 1: 2); res = TRUE !  H - He
         case( 6:10); res = TRUE !  C - Ne
         case(15:18); res = TRUE !  P - Ar
         case(34:36); res = TRUE ! Se - Kr
         case(53:54); res = TRUE !  I - Xe
         case(86   ); res = TRUE !  Rn
      end

   end

   is_a_metalloid(Z) result(res) ::: elemental
   ! Return whether the atom is a metalloid.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      atomic_number :: INT

      ! Get atomic number
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      res = FALSE

      select case (atomic_number)
         case( 5   ); res = TRUE !  B
         case(14   ); res = TRUE ! Si
         case(32:33); res = TRUE ! Ge - As
         case(51:52); res = TRUE ! Sb - Te
         case(85   ); res = TRUE ! As
      end

   end

   is_a_metal(Z) result(res) ::: elemental
   ! Return whether the atom is a metalloid.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      metalloid,nonmetal :: BIN

      nonmetal  = .is_a_nonmetal(Z)
      metalloid = .is_a_metalloid(Z)

      res = NOT nonmetal AND NOT metalloid

   end

   ground_state_multiplicity(Z) result(mult)
   ! Return the ground state multiplicity for this atom according to Hunds rule
   ! (Note this is not neccesarily the real ground state, esp. for Cu)
   ! If "Z" is present it is used as the atomic number.
      Z :: INT, optional
      mult :: INT

      p,col :: INT

      ! Get period and column
      p   = .period_number(Z)
      col = .column_number(Z)

      mult = 0

      select case (p)

         case (0)

            ! Dummy atom or Electron
            mult = 1

         case (1,2,3)

            ! First three periods
            select case (col)
               case (2,8);   mult = 1
               case (1,3,7); mult = 2
               case (4,6);   mult = 3
               case (5);     mult = 4
            end

         case (4,5)

            ! First two transition metal periods
            select case (col)
               case (2,12,18);      mult = 1
               case (1,3,11,13,17); mult = 2
               case (4,10,14,16);   mult = 3
               case (5,9,15);       mult = 4
               case (6,8);          mult = 5
               case (7);            mult = 6
            end

         case (6,7)

            ! First two actinide metal periods
            select case (col)
               case (2,16,26,32);         mult = 1
               case (1,3,15,17,25,27,31); mult = 2
               case (4,14,18,24,28,30);   mult = 3
               case (5,13,19,23,29);      mult = 4
               case (6,12,20,22);         mult = 5
               case (7,11,21);            mult = 6
               case (8,10);               mult = 7
               case (9);                  mult = 8
            end

         case default

            DIE("cannot assign for period "// trim(p.to_str))

      end

   end

   dispersion_correction(wavelength) result (res)
   ! The dispersion correction which best matches the wavelength.
      self :: IN
      wavelength :: REAL
      res :: CPX

      if (.atomic_number<1 OR .atomic_number>92) then
         res = ZERO
      else
         ! The ranges for deciding these wavelengths are a bit arbirary!
         if      (wavelength < 1.15) then; res = dispersion_correction_Ag(.atomic_number) ! 0.559 A = 1.06 au
         else if (wavelength < 2.1 ) then; res = dispersion_correction_Mo(.atomic_number) ! 0.709 A = 1.34 au
         else if (wavelength < 3.6 ) then; res = dispersion_correction_Cu(.atomic_number) ! 1.541 A = 2.91 au
         else;                             res = dispersion_correction_Cr(.atomic_number) ! 2.29  A = 4.33 au
         end
      end

   end

   oxidation_state_str result (res)
   ! Return the oxidation state string, i.e. if the oxidation state is +3, then
   ! the returned string is "3+"; or if the oxidation state is -1 then the
   ! returned string is "-". This is useful for resolving certain library basis
   ! labels.
      res :: STR
      charge :: INT
      charge = .oxidation_state
      if (charge==0) then
         res = " "
      else
         if (charge>0) then; res = "+"
         else;               res = "-"
         end
         charge = abs(charge)
         if (charge/=1) res = trim(charge.to_str)//trim(res)
      end
   end

   no_of_occupied_NOs(axiskind,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      axiskind :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.occupation_numbers.created,"no occupation numbers")

      res = .occupation_numbers.no_of_occupied(axiskind,tol)

   end

   has_ANO_matrices result (res)
   ! Return TRUE if the ANOs exists for the atom.
      res :: BIN
      res = .natural_orbitals.created AND .occupation_numbers.created
      DIE_IF(res AND NOT .ANOs_made,"natural orbitals created, but ANOs_made is FALSE!")
      DIE_IF(NOT res AND .ANOs_made,"natural orbitals destroyed, but ANOs_made is TRUE!")
   end

   bond_distance_to(b,angstrom) result (res) ::: PURE
   ! Return the bond distance between atoms "a" and "b"
      self :: IN
      b :: ATOM, IN
      angstrom :: BIN, optional, IN
      res :: REAL

      r :: VEC{REAL}(3)
      change :: BIN

      r = b.position - .position
      res = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * STR:conversion_factor("angstrom")

   end

   is_bonded_to(b,range_factor) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      b :: ATOM, IN
      range_factor :: REAL, IN, optional
      res :: BIN

      t,bond,bond_min,bond_max,dx,dy,dz,r2 :: REAL
      Za,Zb,as,bs :: INT

      Za =  .atomic_number
      Zb = b.atomic_number
      as =  .site_disorder_group
      bs = b.site_disorder_group

      if      (Za<1) then;                       res = FALSE
      else if (Zb<1) then;                       res = FALSE
      else if (Za>covalent_radii_ccdc.dim) then; res = FALSE
      else if (Zb>covalent_radii_ccdc.dim) then; res = FALSE
      else if (as*bs>0 AND as/=bs) then;         res = FALSE
      else

         t = atom_bonded_range_factor
         if (present(range_factor)) t = range_factor

         bond = .covalent_radius_ccdc + b.covalent_radius_ccdc
         bond_min = max(bond - t,ZERO)
         bond_max =     bond + t

         ! For HH, nothing closer than 0.9A
         if (self.atomic_number==1 AND b.atomic_number==1) bond_min = 0.7d0*BOHR_PER_ANGSTROM

         dx = abs(.position(1) - b.position(1))
         dy = abs(.position(2) - b.position(2))
         dz = abs(.position(3) - b.position(3))
         if      (dx>bond_max) then; res = FALSE
         else if (dy>bond_max) then; res = FALSE
         else if (dz>bond_max) then; res = FALSE
         else
            r2 = dx*dx + dy*dy + dz*dz
            res = (r2 < bond_max*bond_max) AND (r2 > bond_min*bond_min)
         end

      end

   end

   is_nearby_to(b,dist) result (res)
   ! Return TRUE if atom "self" and atom "b" are nearby, i.e. within length
   ! "dist".
      b :: ATOM
      dist :: REAL
      res :: BIN
      tmp :: VEC{REAL}(3)
      r2 :: REAL
      tmp = .position - b.position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end
   end

   is_vdw_bonded_to(b,range_factor,vdw_range_pc) result (res) ::: pure
   ! Return true if "self" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not vand-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 10%). This uses the CCDC method, as documented in
   ! Brun et al (2011) Struct. Sci 67 p. 333-49.
      self :: IN
      b :: ATOM, IN
      range_factor,vdw_range_pc :: REAL, IN, optional
      res :: BIN

      t,bond,bond_max,dx,dy,dz,r2 :: REAL
      Za,Zb,as,bs :: INT

      Za =  .atomic_number
      Zb = b.atomic_number
      as =  .site_disorder_group
      bs = b.site_disorder_group

      if      (Za<1) then; res = FALSE
      else if (Zb<1) then; res = FALSE
      else if (Za>covalent_radii_ccdc.dim) then; res = FALSE
      else if (Zb>covalent_radii_ccdc.dim) then; res = FALSE
      else if (as*bs>0 AND as/=bs) then; res = FALSE
      else if (.is_bonded_to(b,range_factor)) then; res = FALSE
      else

         t = ONE+0.01*atom_vdw_bonded_range_pc
         if (present(vdw_range_pc)) t = ONE + 0.01*vdw_range_pc

         bond = .vdw_radius_ccdc + b.vdw_radius_ccdc
         bond_max = bond*t

         dx = abs(.position(1) - b.position(1))
         dy = abs(.position(2) - b.position(2))
         dz = abs(.position(3) - b.position(3))
         if      (dx>bond_max) then; res = FALSE
         else if (dy>bond_max) then; res = FALSE
         else if (dz>bond_max) then; res = FALSE
         else
            r2 = dx*dx + dy*dy + dz*dz
            res = (r2 < bond_max*bond_max)
         end

      end

   end

   minimum_basis_exponent result (res)
   ! Return the minimum exponent in the basis.
      res :: REAL
      res = ZERO
      if (.coppensbasis.created)     then; res = .coppensbasis.min_exponent
      else if (.slaterbasis.created) then; res = .slaterbasis.min_exponent
      else if (.basis.created)       then; res = .basis.min_exponent
      else
          DIE("no basis")
      end
   end

   r_max(cutoff) result (res)
   ! Return the distance "r_max" at which the basis function with the lowest
   ! exponent is less than the value "cutoff".
      cutoff :: REAL, IN
      res :: REAL

      if (.basis.destroyed) then; res = ZERO
      else;                       res = .basis.r_max(cutoff)
      end

   end

   r2_max(cutoff) result (res)
   ! Return the squared distance "r2_max" at which the basis function with the
   ! lowest exponent is less than the value "cutoff".
      cutoff :: REAL, IN
      res :: REAL

      if (.basis.destroyed) then; res = ZERO
      else;                       res = .basis.r2_max(cutoff)
      end

   end

   has_dipole result (res)
   ! Return TRUE if the atomic dipole is nonzero.
      res :: BIN
      res = NOT .dipole.is_zero
   end

   has_polarisability result (res)
   ! Return TRUE if the atomic dipole is nonzero.
      res :: BIN
      res =  NOT .charge_polarisability.is_zero &
          OR NOT .dipole_polarisability.is_zero
   end

   has_recognised_label result (res)
   ! Return TRUE if the label corresponds to a recognised chemical element.
      res :: BIN

      label,symbol :: STR
      lensym :: INT
      error :: BIN

      .label = label
      if (label.is_int) then    ! The label must be the atomic number
         res = TRUE
      else                      ! First part of the label is the element symbol
         lensym = label.index_of_nonalphabetical-1
         error = lensym>2 OR lensym==0
         if (error) then
            res = FALSE
            return
         end
         symbol = label(1:lensym)
         symbol(1:1).to_upper_case
         symbol(2:2).to_lower_case
         if (symbol=="D" OR symbol=="T" OR symbol(1:2)=="El") then
            res = TRUE
         else if (any(element_symbols(1:)==symbol(1:2))) then
            res = TRUE
         else
            res = FALSE
         end
      end
   end

   covalent_radius_ccdc result (res) ::: public, elemental
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      res :: REAL
      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = covalent_radii_ccdc(.atomic_number)*BOHR_PER_ANGSTROM
      end
   end

   vdw_radius_ccdc result (res) ::: public, elemental
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = vdw_radii_ccdc(.atomic_number)*BOHR_PER_ANGSTROM
      end

   end

   Spackman86_a_6_dispersion_coeff result (res) ::: public, elemental
   ! Returns Spackman's a-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Spackman86_a_6_disp_coeff(.atomic_number)
      end

   end

   Spackman86_b_repulsion_coeff result (res) ::: public, elemental
   ! Returns Spackman's b-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Spackman86_b_exp_prefactor(.atomic_number)
      end

   end

   Spackman86_c_repulsion_coeff result (res) ::: public, elemental
   ! Returns Spackman's c-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Spackman86_c_exp_exponent(.atomic_number)
      end

   end

   Grimme06_a_6_dispersion_coeff result (res) ::: public, elemental
   ! Return Grimme's a-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Grimme06_a_6_disp_coeff(.atomic_number)
      end

   end

   Grimme06_r_0_dispersion_coeff result (res) ::: public, elemental
   ! Return Grimme's a-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Grimme06_r_0_disp_coeff(.atomic_number)
      end

   end


   Thakkar_atomic_dipole_polarizability result (res) ::: public, elemental
   ! Return Thakkar atomic dipole polarizability for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Thakkar_atomic_polarizability(.atomic_number)
      end

   end

!  ====================
!  ADP inquiry methods
!  ====================

   has_NPD_ADP result (res)
   ! Return TRUE if the ADP is non-zero and non-positive definite.
      self :: IN
      res :: BIN

      evec :: MAT{REAL}(3,3)
      eval :: VEC{REAL}(3)

      res = FALSE

      if (NOT .ADP_tensor.is_zero) then
         .ADP_tensor.solve_symmetric_eigenproblem(eval,evec)
         res = any(eval<ZERO)
      end

   end

   has_flat_ADP(ratio) result (res)
   ! Return TRUE if the ADP is flat i.e. the the max to
   ! the min eigenvalue is greater than "ratio" (or FOUR
   ! if not supplied).
      self :: IN
      ratio :: REAL, IN, optional
      res :: BIN

      evec :: MAT{REAL}(3,3)
      eval :: VEC{REAL}(3)
      rat :: REAL

      rat = FOUR
      if (present(ratio)) rat = ratio

      res = FALSE

      if (NOT .ADP_tensor.is_zero) then
         .ADP_tensor.solve_symmetric_eigenproblem(eval,evec)
         res = abs(maxval(eval)/minval(eval)) > rat
      end

   end

   ADP_principal_axis_ratio result (res)
   ! Return the actual max/min ADP principal axis ratio
   ! (or 1000 if the min eigenvalue is zero).
      self :: IN
      res :: REAL

      evec :: MAT{REAL}(3,3)
      eval :: VEC{REAL}(3)
      mineval,maxeval :: REAL

      res = ZERO

      if (NOT .ADP_tensor.is_zero) then
         .ADP_tensor.solve_symmetric_eigenproblem(eval,evec)
         maxeval = maxval(eval)
         mineval = minval(eval)
         res = 1000.0d0
         if (abs(mineval)>TOL(3)) res = maxeval/mineval
      end

   end

!  ====================
!  pADP inquiry methods
!  ====================

   has_pADPs result (res) ::: pure
   ! Return TRUE if there are pADP's.
      self :: IN
      res :: BIN
      res = .pADP_vector.created
   end

   has_ADP3s result (res) ::: pure
   ! Return TRUE if there are third-order ADP's
      self :: IN
      res :: BIN
      res = .has_pADPs
      if (NOT res) return
      res = res AND .pADP_vector.dim>9
   end

   has_ADP4s result (res) ::: pure
   ! Return TRUE if there are fourth-order ADP's
      self :: IN
      res :: BIN
      res = .has_pADPs
      if (NOT res) return
      res = res AND .pADP_vector.dim>19
   end


   has_pADPs_and_errors result (res) ::: pure
   ! Return TRUE if there are pADP's *and* their errors
   ! Also check if the dimensions are equal.
      self :: IN
      res :: BIN
      res = .pADP_vector.created AND .pADP_errors.created
      if (NOT res) return
      res = .pADP_vector.dim==.pADP_errors.dim
   end

   has_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are third-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim>9
   end

   has_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are fourth-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim>19
   end


   has_only_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are *only* third-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim==19
   end

   has_only_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are *only* fourth-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim==34
   end

   has_anharmonic_ADPs result (res) ::: pure
   ! Return TRUE if there are anharmonic ADP's
      self :: IN
      res :: BIN
      res = .has_only_ADP3s_and_errors OR .has_only_ADP4s_and_errors
   end

   no_of_pADPs result (res) ::: pure
   ! Return the no. of positional/ADP parameters for refinement.
   ! NOTE: positions and second-order ADP's are always refined.
   ! i.e. there are always at least 9 pADPs, even if the pADP
   ! vector is not created.
      self :: IN
      res :: INT

      if (.pADP_vector.created) then; res = .pADP_vector.dim
      else;                           res = 9
      end

   end


   tag_pADP_label(par_index) result (res)
   ! Return the unique tag with the positional-ADP label for parameter
   ! with index "par_index" e.g. "N13 Uxxy".
      par_index :: INT, IN
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")

      if (par_index<=3) then
         res = trim(.tag)//" p"//trim(.pADP_index_label(par_index))
      else
         res = trim(.tag)//" U"//trim(.pADP_index_label(par_index))
      end

   end

   pADP_label(par_index,form) result (res)
   ! Return the ADP label for parameter with index
   ! "par_index". The specific "form" of the ADP's may be given;
   ! the default is "xyz-repeated" e.g. "xxyy. For other forms see
   ! the code below.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      fmt :: STR

      if (FALSE) self = self

      ! Set the symbol
      if (par_index<=3) then

         res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))

      else

         fmt = "xyz-repeated"
         if (present(form)) fmt = form

         res = " "

         select case (fmt)
            case ("underscore-123-repeated"); res = "U_"//trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("underscore-xyz-repeated"); res = "U_"//trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("underscore-xyz-power   "); res = "U_"//trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case ("123-repeated           "); res = "U" //trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("xyz-repeated           "); res = "U" //trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("xyz-power              "); res = "U" //trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case default; UNKNOWN(fmt)
         end

      end

   end

   pADP_index_label(par_index,form) result (res)
   ! Return the ADP index label for parameter with index
   ! "par_index". The specific "form" of the ADP's may be given;
   ! the default is "xyz-repeated" e.g. "xxyy. For other forms see
   ! the code below.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      fmt :: STR

      if (FALSE) self = self

      ! Set the symbol
      if (par_index<=3) then

         res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))

      else

         fmt = "xyz-repeated"
         if (present(form)) fmt = form

         res = " "

         select case (fmt)
            case ("underscore-123-repeated"); res = trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("underscore-xyz-repeated"); res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("underscore-xyz-power   "); res = trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case ("123-repeated           "); res = trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("xyz-repeated           "); res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("xyz-power              "); res = trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case default; UNKNOWN(fmt)
         end

      end

   end

   ADP2_index_label(par_index,form) result (res)
   ! Return the ADP2 index label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,6]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = trim(.pADP_index_label(par_index+3,form))

   end

   ADP3_index_label(par_index,form) result (res)
   ! Return the ADP3 index label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,10]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = trim(.pADP_index_label(par_index+9,form))

   end

   ADP4_index_label(par_index,form) result (res)
   ! Return the ADP4 index label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,15]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = trim(.pADP_index_label(par_index+19,form))

   end

   ADP_label(par_index,form) result (res)
   ! Return the ADP label for parameter with index "par_index".
   ! Higher order indices can be obtained assuming they follow on in
   ! the usual pADP/gaussian lexical order.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,31]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = "U_"//trim(.pADP_index_label(par_index+3,form))

   end

   ADP3_label(par_index,form) result (res)
   ! Return the ADP3 label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,10]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = "U"//trim(.pADP_index_label(par_index+9,form))

   end

   ADP4_label(par_index,form) result (res)
   ! Return the ADP4 label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,15]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = "U"//trim(.pADP_index_label(par_index+19,form))

   end

!  =========
!  Invarioms
!  =========

   allred_rochow_en result (res)
   ! Returns the Allred-Rochow EN for this atom
      res :: REAL
      if      (.atomic_number<0 ) then; res = ZERO
      else if (.atomic_number>82) then; res = 1.0d0
      else;                             res = allred_rochow_electronegs(.atomic_number)*0.01d0
      end
   end

   invariom_covalent_radius result (res)
   ! Returns the covalent radius for this atom
      res :: REAL
      if      (.atomic_number<0  ) then; res = ZERO
      else if (.atomic_number>109) then; res = 1.0d0
      else;                              res = covalent_radii_invariom(.atomic_number)*0.01d0
      end
   end

   get_invariom_rotation(U,actual,reference,L,fail) ::: selfless
   ! Returns the invariom rotation matrix "U" which matches
   ! coordinates "reference" to "actual" in a least squares sense.
   ! Return the mean fitting error "L" or else "fail"  for failure.
      U :: MAT{REAL}, OUT
      actual,reference :: MAT{REAL}, IN
      L :: REAL
      fail :: BIN

   ENSURE(U.is_square,"U must be square")
   ENSURE(U.dim==actual.dim2,"U incompatible with actual")
   ENSURE(reference.dim2==actual.dim2,"reference incompatible with actual")

      U0,X,Rd :: MAT{REAL}*
      d,n,p,q,i,iteration :: INT
      val :: REAL

      ! Set dimension, number of points to fit
      d = U.dim1
      n = reference.dim2

      ! Set minimum L value
      L = ZERO

      ! Start with U being unit matrix
      U.to_unit_matrix

      ! Create antisymmetric matrix X, temporary rotation U
      X.create(d,d)
      U0.create(d,d)
      Rd.create(reference.dim1,reference.dim2)

      ! Repeatedly update U until converged
      iteration = 0
      fail = FALSE
      do

         iteration = iteration + 1

         ! Rotate actual positions
         Rd.to_product_of(U,actual,transpose_A=TRUE)

         ! Get the derivative of L wrt. X_pq
         do p = 1,d
            do q = 1,p
               val = ZERO
               do i = 1,n
                  val = val + Rd(p,i)*reference(q,i) - Rd(q,i)*reference(p,q)
               end
               val = -TWO*val
               X(p,q) =  val
               X(q,p) = -val
            end
            X(p,p) = ZERO
         end

         ! Get maximum gradient
         val = maxval(abs(X))

         ! Exit if gradient converged or too many iteration
         if (val<TOL(4)) exit
         fail = iteration==1000
         if (fail) exit

         ! Otherwise scale X so the maximum value is less than 0.1
         val = TOL(1)/val
         X = X*val

         ! Exponentiate X
         X.exponentiate_to(U0)

         ! Update U
         X.to_product_of(U,U0)
         U = X

      end

      ! Clean up
      Rd.destroy; U0.destroy; X.destroy

      ! If failed, return, otherwise calculate L
      if (fail) return

      Rd.create(reference.dim1,reference.dim2)
      Rd.to_product_of(U,reference)

      L = ZERO
      do i = 1,d
         L = L + dot_product(actual(:,i),actual(:,i)) &
               + dot_product(reference(:,i),reference(:,i)) &
               - TWO*dot_product(actual(:,i),Rd(:,i))
      end
      L = sqrt(L)/d

      Rd.destroy

   end

!  =============================
!  ADP density plotting routines
!  =============================

   make_ADP2_exponent_grid(g,pt) 
   ! Make the effective ADP2 PDF exponents for a series of (Nx3)
   ! points "pt" and put the values into the grid vector "g".
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      u,eval :: VEC{REAL}(3)
      LL :: MAT{REAL}(3,3)
      n_pt,i :: INT
      det,fac,top :: REAL


      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      ! Harmonic part. Note: U2^{-1} is the matrix for the PDF
      ! in cartesian coordinates.
      eval  = ONE/eval
      det   = product(eval)
      fac   = sqrt(det/(TWO*PI)**3)

      n_pt = g.dim
      do i = 1,n_pt
         u     = pt(i,:) - .position
         u     = matmul(u,LL)
         top   = -HALF*sum(u*eval*u)
          g(i) = top
      end

   end

   make_ADP_exponent_grid(g,pt,unit_cell)
   ! Make the effective ADP PDF exponent values for a series of (Nx3)
   ! points "pt" and put the values into the grid vector "g". Supply
   ! "unit_cell" for reciprocal matrix, for the anharmonic constants.
   ! See Coppens, International Tables for Crystlography vol B p. 22
   ! equations (1.2.12.3) and (1.2.12.4)
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      unit_cell :: UNIT_CELL, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      n :: VEC{INT}(3)
      u,eval :: VEC{REAL}(3)
      delta :: MAT{INT}(3,3)
      LL :: MAT{REAL}(3,3)
      U3 :: MAT3{REAL}(3,3,3)
      U4 :: MAT4{REAL}(3,3,3,3)
      n_pt,i,j,k,l,m :: INT
      det,top,fac,H :: REAL
      P0,g3,g4 :: VEC{REAL}*

      ! Harmonic grid
      n_pt = g.dim
      P0.create(n_pt)

      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      ! Harmonic part. Note: U2^{-1} is the matrix for the PDF
      ! in cartesian coordinates.
      eval  = ONE/eval
      det   = product(eval)
      fac   = sqrt(det/(TWO*PI)**3)

      do i = 1,n_pt
         u     = pt(i,:) - .position
         u     = matmul(u,LL)
         top   = -HALF*sum(u*eval*u)
         P0(i) = fac*exp(top)
      end

      g = P0

      if (.has_ADP3s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP3_to(U3)
         U3.change_basis_using(unit_cell.reciprocal_matrix)
         U3.change_basis_using(LL)

         delta.to_unit_matrix

         g3.create(n_pt)
         g3 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g3(i) = g3(i) + U3(j,k,l)*H
            end

         end
         end
         end

         g = g + P0*g3/SIX

         g3.destroy

      end

      if (.has_ADP4s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP4_to(U4)
         U4.change_basis_using(unit_cell.reciprocal_matrix)
         U4.change_basis_using(LL)

         delta.to_unit_matrix

         g4.create(n_pt)
         g4 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3
         do m = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)+delta(:,m)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g4(i) = g4(i) + U4(j,k,l,m)*H
            end

         end
         end
         end
         end

         g = g + P0*g4/(FOUR*SIX)

         g4.destroy

      end

      ! Make g the effecvtive exponent
      g = log(g/fac)

      P0.destroy

   end

   make_AADP_PDF_correction_grid(g,pt)
   ! Make the anharmonic ADP correction to the PDF values (this are
   ! all the purely cubic and quartic terms, not including the unity
   ! factor) for a series of (Nx3) points "pt" and put the values into
   ! the grid vector "g". Supply "unit_cell" for reciprocal matrix.
   ! See Coppens, International Tables for Crystlography vol B p. 22
   ! equations (1.2.12.3) and (1.2.12.4)
   ! NOTE: these numbers are multiplied by 10^9
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   DIE_IF(NOT .has_ADP3s_and_errors,"no third order ADPs")
   DIE_IF(NOT .has_ADP4s_and_errors,"no fourth order ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      n :: VEC{INT}(3)
      u,eval :: VEC{REAL}(3)
      delta :: MAT{INT}(3,3)
      LL :: MAT{REAL}(3,3)
      U3 :: MAT3{REAL}(3,3,3)
      U4 :: MAT4{REAL}(3,3,3,3)
      n_pt,i,j,k,l,m :: INT
      H :: REAL
      g3,g4 :: VEC{REAL}*

      n_pt = g.dim

      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      g = ZERO

      if (.has_ADP3s_and_errors) then

         ! Change to principal axis system
         .put_ADP3_to(U3)
         U3.change_basis_using(LL)

         delta.to_unit_matrix

         g3.create(n_pt)
         g3 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g3(i) = g3(i) + U3(j,k,l)*H
            end

         end
         end
         end

         g = g3/SIX

         g3.destroy

      end

      if (.has_ADP4s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP4_to(U4)
         U4.change_basis_using(LL)

         delta.to_unit_matrix

         g4.create(n_pt)
         g4 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3
         do m = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)+delta(:,m)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g4(i) = g4(i) + U4(j,k,l,m)*H
            end

         end
         end
         end
         end

         g = g + g4/(FOUR*SIX)

         g4.destroy

      end

      g = 1.0d+9*g

   end

!  =========================
!  Density plotting routines
!  =========================

   make_density_grid(density_grid,pt,occ)
   ! Make the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      select case (.basis_kind)

         case ("gaussian")
            if (.use_interpolator AND .interpolator.created) then
               .make_interpolated_density(density_grid,pt,occ)
            else
               ENSURE(.basis.created,"no basis")
               ENSURE(.natural_orbitals.created,"no natural_orbitals")
               if (.natural_orbitals.number_kind=="real") then; .make_density_grid_r(density_grid,pt,occ)
               else;                                            .make_density_grid_c(density_grid,pt,occ)
               end
            end

         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            .slaterbasis.make_density_grid(density_grid,pt,.position,occ)

         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            .coppensbasis.make_density_grid(density_grid,pt,.position,occ)

         case default
            UNKNOWN(.basis_kind)

      end

   end

   add_density_grid(density_grid,pt,occ)
   ! Add the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector.
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      select case (.basis_kind)

         case ("gaussian")
            if (.use_interpolator AND .interpolator.created) then
               .add_interpolated_density(density_grid,pt,occ)
            else
               ENSURE(.basis.created,"no basis")
               ENSURE(.natural_orbitals.created,"no natural orbitals")
               if (.natural_orbitals.number_kind=="real") then; .add_density_grid_r(density_grid,pt,occ)
               else;                                            .add_density_grid_c(density_grid,pt,occ)
               end
            end

         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            .slaterbasis.add_density_grid(density_grid,pt,.position,occ)

         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            .coppensbasis.add_density_grid(density_grid,pt,.position,occ)

         case default
            UNKNOWN(.basis_kind)

      end

   end

   make_density_grid_r(density_grid,pt,occ)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{REAL}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      density_grid = ZERO ! set to zero

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
       density_grid = density_grid + .occupation_numbers.restricted(n)*NO*NO
      end

      if (do_occ) density_grid = occ*density_grid

      NO.destroy

   end

   add_density_grid_r(density_grid,pt,occ)
   ! Add the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{REAL}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      if (do_occ) then
        do n = 1,n_occ
          .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
          density_grid = density_grid + occ*.occupation_numbers.restricted(n)*NO*NO
        end
      else
        do n = 1,n_occ
          .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
          density_grid = density_grid +     .occupation_numbers.restricted(n)*NO*NO
        end
      end

      NO.destroy

   end

   make_density_grid_c(density_grid,pt,occ)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
         do_occ = TRUE
      end
      end

      density_grid = ZERO ! set to zero

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
         .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
         density_grid = density_grid + .occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
      end

      if (do_occ) density_grid = occ*density_grid

      NO.destroy

   end

   add_density_grid_c(density_grid,pt,occ)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
         do_occ = TRUE
      end
      end

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      if (do_occ) then
         do n = 1,n_occ
            .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
            density_grid = density_grid &
                         + occ*.occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
         end
      else
         do n = 1,n_occ
            .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
            density_grid = density_grid &
                         + .occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
         end
      end

      NO.destroy

   end

   make_density_grid(density_grid,pt,D,occ)
   ! Make the "density_grid" for the supplied points "pt" from a
   ! density matrix "D"
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(D.is_square,"D, not square")
   ENSURE(D.dim1==.basis.no_of_basis_functions,"D, wrong size")

      g :: MAT{REAL}*
      W :: VEC{REAL}*
      i :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      W.create(D.dim1)
      g.create(pt.dim1,D.dim1)

      .make_AO_grid(g,pt,.position)

      do i = 1,pt.dim1
         W.to_product_of(D,g(i,:),transpose_a=TRUE)
         density_grid(i) = VEC{REAL}:sum_elements(W*g(i,:))
      end

      if (do_occ) density_grid = occ*density_grid

      W.destroy
      g.destroy

   end

   add_density_grid(density_grid,pt,D,occ)
   ! Add the "density_grid" for the supplied points "pt" from a
   ! density matrix "D"
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(D.is_square,"D, not square")
   ENSURE(D.dim1==.basis.no_of_basis_functions,"D, wrong size")

      g :: MAT{REAL}*
      W :: VEC{REAL}*
      i :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      W.create(D.dim1)
      g.create(pt.dim1,D.dim1)

      .make_AO_grid(g,pt,.position)

      if (do_occ) then

        do i = 1,pt.dim1
           W.to_product_of(D,g(i,:),transpose_a=TRUE)
           density_grid(i) = density_grid(i) + occ*VEC{REAL}:sum_elements(W*g(i,:))
        end

      else

        do i = 1,pt.dim1
           W.to_product_of(D,g(i,:),transpose_a=TRUE)
           density_grid(i) = density_grid(i) + VEC{REAL}:sum_elements(W*g(i,:))
        end

      end

      W.destroy
      g.destroy

   end


!   make_d_density_grid(d0_density,d1_density,d2_density,pt)
!   ! Work out the 1st derivative density "d1_density" and 2nd
!   ! derivative "d2_density" on a set of points "pt" for interpolated
!   ! densities.
!      self :: IN
!      d0_density :: VEC{REAL}, OUT
!      d1_density :: MAT{REAL}, OUT
!      d2_density :: MAT3{REAL}, OUT
!      pt :: MAT{REAL}, IN
!   ENSURE(d0_density.dim==pt.dim1,"inconsistent number of points")
!      select case (.basis_kind)
!         case ("gaussian")
!            DIE("gaussian case, use different routines")
!         case ("slater")
!            ENSURE(.slaterbasis.created,"no slaterbasis")
!            .slaterbasis.make_d_density_grid(d0_density,d1_density,d2_density,pt,.position)
!         case ("coppens")
!            DIE("not implemented yet")
!         case default
!            UNKNOWN(.basis_kind)
!      end
!      if (NOT .site_occupancy.same_as(ONE)) then
!         d0_density = .site_occupancy*d0_density
!         d1_density = .site_occupancy*d1_density
!         d2_density = .site_occupancy*d2_density
!      end
!   end

!  ========================
!  Orbital density routines
!  ========================

   make_AO_grid(g,pt,pos)
   ! Evaluate the AO density grid "g" on a set of grid points "pt" for an atom at position
   ! "pos".
      g :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim1==g.dim1,"pt and g, incompatible")
   ENSURE(.basis.no_of_basis_functions==g.dim2,"pt and g, incompatible")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sh :: SHELL1
      n_shell,f,l,s :: INT

      n_shell = .basis.no_of_shells

      l = 0

      do s = 1,n_shell

         sh.set(.basis.shell(s),pos)

         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph  ! LBXXX
         else
           l = l + sh.n_comp
         end if
         !l = l + sh.n_comp

         sh.make_grid(g(:,f:l),pt)

      end

   end

   make_orbital_grid_r(g,orb,pt,pos,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,n_shell,f,l,s :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      l = 0

      do s = 1,n_shell

         sh.set(.basis.shell(s),pos)

         f = l + 1
         if (sh.is_spherical)then
           l = f + sh.n_sph - 1
           sh_grid.create(n_pt,sh.n_sph)
         else
           l = f + sh.n_comp - 1
           sh_grid.create(n_pt,sh.n_comp)
         end if


         sh.make_grid(sh_grid,pt)
         g.plus_product_of(sh_grid,orb(f:l))

         sh_grid.destroy

      end

      if (sq) g = g*g

   end

   make_orbital_grid_c(g,orb,pt,pos,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      self :: IN
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,n_shell,f,l,s :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      l = 0

      do s = 1,n_shell

         sh.set(.basis.shell(s),pos)

         f = l + 1
         if (sh.is_spherical)then
           l = f + sh.n_sph - 1
           sh_grid.create(n_pt,sh.n_sph)
         else
           l = f + sh.n_comp - 1
           sh_grid.create(n_pt,sh.n_comp)
         end if

         sh.make_grid(sh_grid,pt)
         g.plus_product_of(sh_grid,orb(f:l))

         sh_grid.destroy

      end

      if (sq) g = conjg(g)*g

   end

!  ======================
!  Spherical density at R
!  ======================

   density_at_radius(R) result (res)
   ! Work out the electron at radius "R".
      R :: REAL, IN
      res :: REAL

      density_grid :: VEC{REAL}(1)
      pt :: MAT{REAL}(1,3)

      res = ZERO
      select case (.basis_kind)
         case ("gaussian")
            ENSURE(.basis.created,"no basis")
            pt(1,:) = .position + [R,ZERO,ZERO]
            if (.natural_orbitals.number_kind == "real") then; .make_density_grid_r(density_grid,pt)
            else;                                              .make_density_grid_c(density_grid,pt)
            end
            res = density_grid(1)
         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            ENSURE(.slaterbasis.shell.created,"no slaterbasis shells")
            res = .slaterbasis.density_at_radius(R)
         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            ENSURE(.coppensbasis.orbital.created,"no coppensbasis orbital")
            res = .coppensbasis.density_at_radius(R)
         case default
            UNKNOWN(.basis_kind)
      end

   end

   density_value_at_radius(R) result (res) ::: selfless, public
   ! Return the density values at the radial value "R".
   ! This assumes that the atomic density is spherical!
      R :: REAL, IN
      res :: REAL
      self :: ATOM*
      self => saved_self
      res = .density_at_radius(R)
   end

!   density_at_sqrt_radius2(R2) result (res) ::: selfless, public
!   ! Return the density values at the square root of radial value "R2".
!   ! This assumes that the atomic density is spherical!
!     R2 :: REAL, IN
!     res :: REAL
!     R :: REAL
!     self :: ATOM*
!     self => saved_self
!     R = sqrt(R2)
!     res = .density_at_radius(R)
!   end

!   density_at_sqrt_x1x(x) result (res) ::: selfless, public
!   ! The function r2 = (x/1-x) maps [0,1] -> [0,inf]. An even spacing
!   ! of points in x will lead to a distribution of points in r in the
!   ! range [0,inf] on which the density rho can be calculated. An
!   ! interpolation table of rho vs. x can be made.  The inverse of the
!   ! function is x = (r2/1+r2). These values of x can easily be
!   ! calculated from a given r2. The value of rho can then be
!   ! interpolated. This assumes that the atomic density is spherical!
!     x :: REAL, IN
!     res :: REAL
!
!     R :: REAL
!     self :: ATOM*
!
!
!     if (x>=ONE) then
!        res = ZERO
!     else
!        self => saved_self
!        R = .bragg_slater_radius*BOHR_PER_ANGSTROM*sqrt(x/(ONE-x))
!        res = .density_at_radius(R)
!     end
!
!   end

!  ============
!  Interpolator
!  ============

   make_interpolator(interpolator) ::: leaky
   ! Make the .interpolator for the atom density. If present,
   ! "interpolator" is used as a template to get the settings needed.
   ! NOTE: This is for a gaussian basis set; for slater or coppens
   ! bases use the interpolators stored in those bases.
      interpolator :: INTERPOLATOR*, optional

   ENSURE(.basis_kind=="gaussian","interpolation must be for a gaussian basis")

      ! Create a copy of the template if it exists
      if (present(interpolator)) then
      if (interpolator.created) then
         .interpolator.destroy
         .interpolator.create_copy(interpolator)
      end
      end

      ! If no template, create a default interpolator
      if (.interpolator.destroyed) .interpolator.create

      ! Set domain scale factor. May not be required.
      .interpolator.set_domain_scale_factor(.bragg_slater_radius*BOHR_PER_ANGSTROM)

      ! Set the interpolation table
      .set_saved_self ! Used by ATOM: function below
      .interpolator.set_even_spaced_data(ATOM::density_value_at_radius)

   end

   interpolator_table_length(tol) result (length)
   ! Return the interpolator table "length" for a given tolerance "tol" for the
   ! atom density. The interpolator is a default one.
      tol,length :: REAL

      interpolator :: INTERPOLATOR*

      interpolator.create
      .set_saved_self   ! Used by function below
      length = interpolator.the_table_length(ATOM::density_value_at_radius,tol)
      interpolator.destroy

   end

   make_interpolated_density(density,pt,occ)
   ! Make the spherical atomic "density" for the supplied points "pt"
   ! using a precalculated interpolator.
      self :: IN
      density :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.interpolator.created,"no interpolator defined!")
   ENSURE(.interpolator.domain_mapping(1:4)=="sqrt","must using sqrt-like mapping")

      R2 :: VEC{REAL}*
      n_pt,n :: INT
      x,y,z :: REAL

      ! Space for R2
      n_pt = pt.dim1
      R2.create(n_pt)

      ! Get squared distances R2
      do n = 1,n_pt
        x = pt(n,1) - .position(1)
        y = pt(n,2) - .position(2)
        z = pt(n,3) - .position(3)
        R2(n) = x*x + y*y + z*z
      end

      ! Get the interpolated density values
      .interpolator.values_for(R2,density,occ)

      ! Clean up
      R2.destroy

   end

   add_interpolated_density(density,pt,occ)
   ! Add the spherical atomic "density" for the supplied points "pt"
   ! using a precalculated interpolator.
      self :: IN
      density :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.interpolator.created,"no interpolator defined!")
   ENSURE(.interpolator.domain_mapping(1:4)=="sqrt","must using sqrt-like mapping")

      R2 :: VEC{REAL}*
      n_pt,n :: INT
      x,y,z :: REAL

      ! Space for R2
      n_pt = pt.dim1
      R2.create(n_pt)

      ! Get squared distances R2
      do n = 1,n_pt
        x = pt(n,1) - .position(1)
        y = pt(n,2) - .position(2)
        z = pt(n,3) - .position(3)
        R2(n) = x*x + y*y + z*z
      end

      ! Get the interpolated density values
      .interpolator.add_values_for(R2,density,occ)

      ! Clean up
      R2.destroy

   end

!  ===========================
!  Nabla density grid routines
!  ===========================

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,pts)
      else
         DIE("complex case not yet implemented")
      end

   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid", evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,grid,pts)
      else
         DIE("complex case not yet implemented")
      end

   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,"wrong dimension for points array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong 1st dimension for nabla_grid array")
   ENSURE(nabla_grid.dim2==3,"wrong 2nd dimension for nabla_grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = size(pts,1)
      nabla_grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = size(pts,1)
      nabla_grid = ZERO
      grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
       grid(:) = grid(:) + occ*orb(:)*orb(:)
      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_orbital_grid_r(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{REAL}
      h :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")

      orb_a :: VEC{REAL}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_shell,n_pt,f,l,a :: INT

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      h = ZERO
      l = 0

      do a = 1,n_shell

         sh.set(.basis.shell(a),.position)

         f = l + 1

         if (sh.is_spherical)then
           sh_grid.create(n_pt,sh.n_sph,3)
           sh_grid0.create(n_pt,sh.n_sph)
           l = f + sh.n_sph - 1
         else
           sh_grid.create(n_pt,sh.n_comp,3)
           sh_grid0.create(n_pt,sh.n_comp)
           l = f + sh.n_comp - 1
         end if

         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         orb_a => orb(f:l)

         g(:,1).plus_product_of(sh_grid(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid(:,:,3),orb_a)

         h.plus_product_of(sh_grid0,orb_a)

         sh_grid0.destroy
         sh_grid.destroy

      end

   end

!  ==========================
!  Laplacian density routines
!  ==========================

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind == "real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1

      laplacian_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3)))
      end

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{REAL}
      i :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{REAL}*
      n_pt,f,l,a,n_shell :: INT

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      h = ZERO
      i = ZERO
      l = 0

      do a = 1,n_shell

         sh.set(.basis.shell(a),.position)

         f = l + 1

         if (sh.is_spherical)then
           sh_grid.create(n_pt,sh.n_sph,3)
           sh_grid1.create(n_pt,sh.n_sph,3)
           sh_grid0.create(n_pt,sh.n_sph)
           l = f + sh.n_sph - 1
         else
           sh_grid.create(n_pt,sh.n_comp,3)
           sh_grid1.create(n_pt,sh.n_comp,3)
           sh_grid0.create(n_pt,sh.n_comp)
           l = f + sh.n_comp - 1
         end if

         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)

         orb_a => orb(f:l)

         g(:,1).plus_product_of(sh_grid(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid(:,:,3),orb_a)
         h(:,1).plus_product_of(sh_grid1(:,:,1),orb_a)
         h(:,2).plus_product_of(sh_grid1(:,:,2),orb_a)
         h(:,3).plus_product_of(sh_grid1(:,:,3),orb_a)

         i.plus_product_of(sh_grid0,orb_a)

         sh_grid0.destroy
         sh_grid1.destroy
         sh_grid.destroy

      end

   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind == "real") then
        .make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      laplacian_grid = ZERO

      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * ( &
          NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
       rho = rho + occ*NO*NO
      end

      laplacian_grid = TWO*laplacian_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  =============================
!  Energy density from rho grids
!  =============================

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}

      fac :: REAL
      if (.atomic_number<1) then
         E_grid = ZERO
      else
         .make_density_grid(E_grid,pt)
         fac = .energy/.atomic_number
         E_grid = fac*E_grid
      end

   end

!  ===================================
!  Virial type energy density routines
!  ===================================

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy

   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip
   ! 2G + V = (1/4) L, or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_rG_kinetic_energy_grid(G_grid,pt)
      .make_rL_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy

   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_G_Kirzhnits_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy

   end

   make_V_from_virial_grid(V,pt)
   ! Work out the potential energy density from using the
   ! virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(V.dim)
      .make_G_kinetic_energy_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy

   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the reduced potenbtial energy density from using the
   ! virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(V.dim)
      .make_rG_kinetic_energy_grid(G,pt)
      .make_rL_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy

   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the potential energy density from using the
   ! Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(V.dim)
      .make_G_Kirzhnits_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy

   end

!  ===============================
!  G-type kinetic density routines
!  ===============================

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_G_kinetic_energy_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_G_kinetic_energy_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      G_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       G_grid(:) = G_grid(:) &
                 + .occupation_numbers.restricted(n) &
                 * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end

      G_grid(:) = HALF*G_grid(:)

      P.destroy
      NO.destroy

   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_rG_kinetic_energy_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rG_kinetic_energy_grid_r(G_grid,pt)
   ! Make the reduced G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      G_grid = ZERO

      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
       rho = rho + occ*NO*NO
      end

      G_grid = HALF*G_grid/rho

      P.destroy
      NO.destroy
      rho.destroy

   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_G_Kirzhnits_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
      G,L,nab_rho :: MAT{REAL}*
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1

      rho.create(n_pt);       rho = ZERO
      lap_rho.create(n_pt);   lap_rho = ZERO
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3); nab_rho = ZERO
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)
       occ  = .occupation_numbers.restricted(n)
       occ2 = TWO*occ
       rho  = rho + occ *NO*NO
       nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
       nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,1)
       nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,1)
       lap_rho = lap_rho + occ2*(NO*(L(:,1)+L(:,2)+L(:,3)) + (G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3)))
      end

      L.destroy; G.destroy; NO.destroy

      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy

      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRD)
      G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho

      nab_ro2.destroy; lap_rho.destroy; rho.destroy

   end

!  ===============================
!  K-type kinetic density routines
!  ===============================

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_K_kinetic_energy_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_K_kinetic_energy_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      K_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       K_grid(:) = K_grid(:) &
                 + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3))
      end

      K_grid(:) = -HALF*K_grid(:)

      D.destroy
      P.destroy
      NO.destroy

   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the reduced K-type kinetic energy density (using the nabla^2) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rK_kinetic_energy_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rK_kinetic_energy_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      K_grid = ZERO

      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       K_grid = K_grid + occ * NO * (D(:,1)+D(:,2)+D(:,3))
       rho = rho + occ*NO*NO
      end

      K_grid = -HALF*K_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  =============
!  DFT potential
!  =============

   make_dft_xc_pot_grid(V,pt,exchange,correlation)
   ! Work out the DFT exchange-correlation potential "V" at a series of points
   ! "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*

      rho.create(V.dim)
      .make_density_grid(rho,pt)
      V = ZERO
      dft.new_r_potential(exchange,V,rho)
      dft.new_r_potential(correlation,V,rho)
      rho.destroy

   end

   make_dft_eff_pot_grid(V,pt,exchange,correlation)
   ! Work out the DFT effective potential "V" (i.e. the DFT potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

      rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL

      .make_electric_potential_grid(V,pt)
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.new_r_potential(exchange,V,rho)
      dft.new_r_potential(correlation,V,rho)
      rho.destroy

   end

   make_dft_energy_grid(V,pt,exchange,correlation)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")

      Ve,rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL

      .nuclear_potential(V,pt)
      Ve.create(V.dim)
      .make_electronic_pot_grid_r(Ve,pt,.density_matrix.restricted)
      V = -V - HALF*Ve
      Ve.destroy
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.new_r_energy_density(exchange,V,rho)
      dft.new_r_energy_density(correlation,V,rho)
      V = V*rho
      rho.destroy

   end

   make_H_dft_energy_grid(H_grid,pt,exchange,correlation)
   ! Work out the H DFT energy density "H_grid" on a set ofpoints "pt"
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_dft_energy_grid(H_grid,pt,exchange,correlation)
      H_grid = H_grid + G_grid
      G_grid.destroy

   end

!  ==================
!  Electric potential
!  ==================

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")

      if (.density_matrix.number_kind == "real") then
         .make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         DIE("complex case not yet implemented")
      end

   end

   make_electric_potential_grid_r(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}

      elec_grid :: VEC{REAL}*

      .nuclear_potential(pot_grid,pt)
      elec_grid.create(size(pot_grid))
      .make_electronic_pot_grid_r(elec_grid,pt,dens)
      pot_grid.plus(elec_grid)
      elec_grid.destroy

   end

   make_electronic_pot_grid_r(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}, target

   ENSURE(.basis.created,"no basis set")

      Vab,Dba :: MAT{REAL}*
      sh :: SHELL2
      n_pt,n_shell_pairs,q,fa,fb,la,lb,k :: INT

      n_pt = pt.dim1
      n_shell_pairs = .basis.no_of_shells
      n_shell_pairs = n_shell_pairs.triangle_number

      pot_grid = ZERO

      do q = 1,n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)

         Dba => dens(fa:la,fb:lb)

         if (sh.is_spherical)then
           Vab.create(sh.a.n_sph,sh.b.n_sph)
         else
           Vab.create(sh.a.n_comp,sh.b.n_comp)
         end if

         if (fa/=fb) then

           do k = 1,n_pt
              sh.get_nuc(Vab,ONE,pt(k,:))
              pot_grid(k) = pot_grid(k) - TWO*MAT{REAL}:sum_elements(Vab*Dba)
           end

         else

           do k = 1,n_pt
              sh.get_nuc(Vab,ONE,pt(k,:))
              pot_grid(k) = pot_grid(k) -     MAT{REAL}:sum_elements(Vab*Dba)
           end

         end

         Vab.destroy
         sh.destroy_ptr_part

      end

   end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      i :: INT
      r,x,y,z,xi,yi,zi :: REAL

      values = ZERO
      x = .position(1)
      y = .position(2)
      z = .position(3)

      do i = 1,values.dim
         xi = pts(i,1) - x
         yi = pts(i,2) - y
         zi = pts(i,3) - z
         r  = sqrt(xi*xi + yi*yi + zi*zi)
         if (r>tiny(r)) then; values(i) = values(i) + .atomic_number/r
         else;                values(i) = values(i) + huge(ONE)
         end
      end

   end

!  =================================
!  DFT grids for all basis functions
!  =================================

   make_bf_grid(grid,pt)
   ! Make a "grid" on which all the atom basis functions are
   ! evaluated, for the supplied points "pt".
      self :: IN
      grid :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid.dim1==pt.dim1,"incompatible grid and pt arrays")
   ENSURE(grid.dim2==.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      s,f,l,n_shell :: INT

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell

         sh.set(.basis.shell(s),.position)

         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph
         else
           l = l + sh.n_comp
         end if

         sh.make_grid(grid(:,f:l),pt)

      end

   end

   make_nabla_bf_grid(nabla_grid,pt)
   ! Make a "nabla_grid" on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt".
      self :: IN
      nabla_grid :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(nabla_grid.dim1==pt.dim1,"incompatible nabla_grid and pt arrays")
   ENSURE(nabla_grid.dim2==.no_of_basis_functions,"wrong size, nabla_grid array")
   ENSURE(nabla_grid.dim3==3,"wrong size, nabla_grid array")

      sh :: SHELL1
      s,n_shell :: INT

      n_shell = .basis.no_of_shells

      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         sh.make_nabla_grid(nabla_grid,pt)
      end

   end

   make_nabla_bf_grid(nabla_grid,grid,pt)
   ! Make a "nabla_grid" on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt". Also
   ! return "grid", which tabluates the values of all the atom basis
   ! functions on the grid points.
      self :: IN
      nabla_grid :: MAT3{REAL}, OUT
      grid :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(nabla_grid.dim1==pt.dim1,"incompatible nabla_grid and pt arrays")
   ENSURE(nabla_grid.dim2==.no_of_basis_functions,"wrong size, nabla_grid array")
   ENSURE(nabla_grid.dim3==3,"wrong size, nabla_grid array")
   ENSURE(grid.dim1==pt.dim1,"incompatible grid and pt arrays")
   ENSURE(grid.dim2==.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      s,f,l,n_shell :: INT

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph  ! LBXXX
         else
           l = l + sh.n_comp
         end if
         sh.make_nabla_grid(nabla_grid(:,f:l,1),nabla_grid(:,f:l,2),nabla_grid(:,f:l,3),grid(:,f:l),pt)
      end

   end


   make_bf_grid(grid0,pt,cutoff)
   ! Make a "grid0" on which all the atom basis functions are evaluated, for the
   ! supplied points "pt".
      self :: IN
      grid0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid0.dim1==pt.dim1,"incompatible grid0 and pt arrays")
   ENSURE(grid0.dim2==.no_of_basis_functions,"wrong size, grid0 array")

      x,y,z,r2 :: VEC{REAL}*
      sh :: SHELL1
      n_pt,s,f,l,n_shell :: INT

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph
         else
           l = l + sh.n_comp
         end if
         sh.make_grid(grid0(:,f:l),x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_nabla_bf_grid(grid1,pt,cutoff)
   ! Make a nabla grid, "grid1", on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt".
      self :: IN
      grid1 :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid1.dim1==pt.dim1,"incompatible grid1 and pt arrays")
   ENSURE(grid1.dim2==.no_of_basis_functions,"wrong size, grid1 array")
   ENSURE(grid1.dim3==3,"wrong size, grid1 array")

      x,y,z,r2 :: VEC{REAL}*
      sh :: SHELL1
      n_pt,s,n_shell :: INT

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      n_shell = .basis.no_of_shells

      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         sh.make_nabla_grid(grid1,x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_nabla_bf_grid(grid1,grid0,pt,cutoff)
   ! Make a nabla grid "grid1" on which the gradient of all the atom basis functions
   ! are evaluated, for the supplied points "pt". Also return "grid0", which
   ! tabluates the values of all the atom basis functions on the grid points.
      self :: IN
      grid1 :: MAT3{REAL}, OUT
      grid0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid1.dim1==pt.dim1,"incompatible grid1 and pt arrays")
   ENSURE(grid1.dim2==.no_of_basis_functions,"wrong size, grid1 array")
   ENSURE(grid1.dim3==3,"wrong size, grid1 array")
   ENSURE(grid0.dim1==pt.dim1,"incompatible grid0 and pt arrays")
   ENSURE(grid0.dim2==.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      n_pt,s,f,l,n_shell :: INT
      x,y,z,r2 :: VEC{REAL}*

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph
         else
           l = l + sh.n_comp
         end if
         sh.make_nabla_grid(grid1(:,f:l,1),grid1(:,f:l,2),grid1(:,f:l,3),grid0(:,f:l),x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

!  ================
!  Make point lists
!  ================

   make_logval(logval,r2,n_pt) ::: public
   ! For a list of points with distances "r2" from an atom center,
   ! return the log of the mkaximuk value "logval" which can be used
   ! to implement a cutoff.
      n_pt :: INT, IN
      logval :: VEC{INT}(n_pt), OUT
      r2 :: VEC{REAL}(n_pt), IN

   ENSURE(.basis.created,"no basis set")

      rr,ex :: REAL
      n :: INT

      ex = .basis.min_exponent

      do n = 1,n_pt

         rr = r2(n)
         logval(n) = ceiling(log10(exp(-ex*rr)))

      end

   end


   make_displaced_pts(dx,dy,dz,r2,pt,n_pt) ::: public
   ! For a list of points "pt" of length "n_pt", return displacements
   ! "dx", "dy", "dz", and their square "r2".
      n_pt :: INT, IN
      dx,dy,dz,r2 :: VEC{REAL}(n_pt), OUT
      pt :: MAT{REAL}(n_pt,3), IN

   ENSURE(.basis.created,"no basis set")

      px,py,pz, xx,yy,zz, rr :: REAL
      n :: INT

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      do n = 1,n_pt

         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz

         dx(n)   = xx
         dy(n)   = yy
         dz(n)   = zz
         r2(n)   = rr

      end

   end

   make_displaced_skip_pts(dx,dy,dz,r2,skip,pt,n_pt,cutoff) ::: public
   ! For a list of points "pt" of length "n_pt", return displacements
   ! "dx", "dy", "dz", their square "r2" and "skip" which tells when
   ! the basis function is less than "cutoff".
      n_pt :: INT, IN
      dx,dy,dz,r2 :: VEC{REAL}(n_pt), OUT
      skip :: VEC{BIN}(n_pt), OUT
      pt :: MAT{REAL}(n_pt,3), IN
      cutoff :: REAL, IN

   ENSURE(.basis.created,"no basis set")

      px,py,pz, xx,yy,zz, rr,r2_max :: REAL
      n :: INT

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      r2_max = .r2_max(cutoff)

      do n = 1,n_pt

         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz

         dx(n)   = xx
         dy(n)   = yy
         dz(n)   = zz
         r2(n)   = rr
         skip(n) = rr>r2_max

      end

   end


   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(.basis.created,"no basis set")

      px,py,pz,xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k)
      end

   end

   make_significant_points(x,y,z,r2,d2,skip,pt,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      x,y,z,r2,d2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN
   ENSURE(.basis.created,"no basis set")

      px,py,pz,xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1
      skip.create(n_pt)
      x.create(n_pt); y.create(n_pt); z.create(n_pt)
      r2.create(n_pt); d2.create(n_pt)

      r2_max = .r2_max(cutoff)

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz
         d2(n) = rr
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy; d2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k) ! don't shrink d2 or skip
      end

   end

   make_significant_points(x,y,z,r2,skip,pt,skip2,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE. "skip2" is an array
   ! which skips (in addition) some preselcted points.
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      skip2 :: VEC{BIN}, IN
      cutoff :: REAL, IN
   ENSURE(.basis.created,"no basis set")
      xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)
      k = 0

      do n = 1,n_pt
         xx = pt(n,1) - .position(1)
         yy = pt(n,2) - .position(2)
         zz = pt(n,3) - .position(3)
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = skip2(n) OR rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k) ! don't shrink skip
      end

   end

!  ============================
!  Make basis shell information
!  ============================

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
      self :: INOUT

   ENSURE(.basis.created,"no basis set")

      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .set_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell)

      .make_precomputed_shellpairs

      GAUSSIAN_DATA:set_indices(maxval(.basis.shell.l))

   end

   set_shell_limits(first,last) ::: leaky, PURE
   ! Set the indices of first and last basis functions in a particular shell
   ! "s", first(s) and last(s), respectively.
      self :: IN
      first,last :: VEC{INT}*

      n_shell,f,l,s :: INT

      n_shell = .basis.no_of_shells
      first.create(n_shell)
      last.create(n_shell)

      l = 0
      do s = 1,n_shell
         f = l + 1
         l = f + .basis.shell(s).n_bf - 1
         first(s) = f
         last(s)  = l
      end

   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type
      self :: INOUT

   ENSURE(.basis.created,"no basis set")

      n,a,b :: INT

      n = .basis.no_of_shells

      .precomputed_basis_shellpair.destroy
      .precomputed_basis_shellpair.create(n,n)

      do a = 1,n
      do b = 1,n
         .precomputed_basis_shellpair(a,b).copy_a(.basis.shell(a))
         .precomputed_basis_shellpair(a,b).copy_b(.basis.shell(b))
         .precomputed_basis_shellpair(a,b).make_precalculated_data
      end
      end

   end

   get_precomputed_shell_pair(shell,q,fa,la,fb,lb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "q"
   ! Also return the basis function start indices "fa", "la", etc ...
      self :: IN
      shell :: SHELL2, OUT
      q :: INT, IN
      fa,la,fb,lb :: INT, OUT

   ENSURE(.precomputed_basis_shellpair.created,"no precomputed basis shellpair data")
   ENSURE(.first_basis_fn_for_shell.created,"no first_basis_fn data")
   ENSURE(.last_basis_fn_for_shell.created,"no last_basis_fn data")

      a,b :: INT

      a  = (1+int(sqrt(8.0d0*q-7.0d0)))/2
      b  = q - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      shell.set_and_precompute_from(.precomputed_basis_shellpair(a,b) &
         ,.position,.position,same_center=TRUE,skip=FALSE)

   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("label",.label)
      stdout.dump("tag",.tag)
      stdout.dump("atomic_number",.atomic_number)
      stdout.dump("nuclear_charge",.nuclear_charge)
      stdout.dump("oxidation_state",.oxidation_state)
      stdout.dump("position",.position)
      stdout.dump("position_error",.position_error)
      stdout.dump("group",.group)

      stdout.dump("site_occupancy",.site_occupancy)
      stdout.dump("site_disorder_group",.site_disorder_group)

      stdout.dump("U_iso",.U_iso)
      stdout.dmpp("pADP_vector",.pADP_vector)
      stdout.dmpp("pADP_errors",.pADP_errors)

      stdout.dump("pos_axis_system",.pos_axis_system)
      stdout.dump("ADP_axis_system",.ADP_axis_system)
      stdout.dump("ADPn_axis_system",.ADPn_axis_system)

      stdout.dump("charge",.charge)
      stdout.dump("dipole",.dipole)
      stdout.dump("quadrupole",.quadrupole)
      stdout.dump("spin",.spin)
      stdout.dump("spin_dipole",.spin_dipole)
      stdout.dump("spin_quadrupole",.spin_quadrupole)

      stdout.dump("charge_polarisability",.charge_polarisability)
      stdout.dump("dipole_polarisability",.dipole_polarisability)

      stdout.dump("basis_label",.basis_label)
      stdout.dump("basis_kind",.basis_kind)
      .basis.dmpp("basis")
      stdout.dump("slaterbasis_label",.slaterbasis_label)
      .slaterbasis.dmpp("slaterbasis")
      stdout.dump("coppensbasis_label:STR",.coppensbasis_label)
      .coppensbasis.dmpp("coppensbasis")
      stdout.dump("kind",.kind)
      stdout.dump("is_unique_kind",.is_unique_kind)

      stdout.dump("energy",.energy)
      stdout.dmpp("atomic_orbitals",.atomic_orbitals)
      stdout.dmpp("density_matrix",.density_matrix)
      stdout.dmpp("natural_orbitals",.natural_orbitals)
      stdout.dmpp("occupation_numbers",.occupation_numbers)
      stdout.dump("ANOs_made",.ANOs_made)
      stdout.dump("spherical_atom_data_made",.spherical_atom_data_made)

      stdout.dump("use_interpolator",.use_interpolator)
      .interpolator.dmpp("interpolator")
      stdout.dump("ANO_interpolators_made",.ANO_interpolators_made)
      stdout.dump("interpolators_made",.interpolators_made)

      stdout.dmpp("first_basis_fn_for_shell",.first_basis_fn_for_shell)
      stdout.dmpp("last_basis_fn_for_shell",.last_basis_fn_for_shell)
      .precomputed_basis_shellpair.dmpp("precomputed_basis_shellpair",lower_triangle=TRUE)
      stdout.dump("shell_info_made",.shell_info_made)

      stdout.dump("invariom_label",.invariom_label)
      stdout.dump("protein_strand",.protein_strand)
      stdout.dump("residue_atom_code",.residue_atom_code)
      stdout.dump("residue_code",.residue_code)
      stdout.dump("residue_sequence_number",.residue_sequence_number)

      stdout.dump("mm_forcefield_name",.mm_forcefield_name)
      stdout.dump("mm_atom_type",.mm_atom_type)
      stdout.dump("mm_chargeL",.mm_charge)
      stdout.dump("restraining_position",.restraining_position)
      stdout.dump("restraining_force_constant",.restraining_force_constant)

   end

   dump(object_name,ptr) ::: get_from(OBJECT)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT)
   ! Dump pointer object data as text
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put out the atom information to file "stdout"

      .put_short

      if (.residue_sequence_number/=0) .put_mm_info

      if (.basis.created)              .basis.put
      if (.slaterbasis.created)        .slaterbasis.put
      if (.coppensbasis.created)       .coppensbasis.put

      .put_ANOs

   end

   put_short
   ! Put out the atom information to file "stdout"

      stdout.flush

      stdout.show("Label                  =",trim(.label))
      stdout.show("Unique tag             =",trim(.tag))
      stdout.show("Atomic No.             =",.atomic_number)
      stdout.show("Chemical symbol        =",trim(.chemical_symbol))
      stdout.show("Atom position          =",.position(1),.position(2),.position(3))

      stdout.show("Site disorder group    =",.site_disorder_group)
      stdout.show("Site occupancy         =",.site_occupancy)

   end

   put_ANOs
   ! Put out the ANO information to file "stdout"

      stdout.flush

      if (.atomic_orbitals.created) then
         stdout.flush
         stdout.text("Atomic orbitals:")
         stdout.flush
         stdout.put(.atomic_orbitals)
      end

      if (.density_matrix.created) then
         stdout.flush
         stdout.text("Density matrix:")
         stdout.flush
         stdout.put(.atomic_orbitals)
      end

      if (.natural_orbitals.created) then
         stdout.flush
         stdout.text("Natural occupations and orbitals:")
         stdout.flush
         stdout.put(.occupation_numbers)
         stdout.flush
         stdout.put(.natural_orbitals)
      end

   end

   put_mm_info
   ! Put out the MM/protien part of the atom information to file "stdout"

      stdout.flush
      stdout.show("Residue atom code       =",trim(.residue_atom_code))
      stdout.show("Residue code            =",trim(.residue_code))
      stdout.show("Residue sequence number =",.residue_sequence_number)
      stdout.show("MM forcefield name      =",.mm_forcefield_name)
      stdout.show("MM atom type            =",.mm_atom_type)
      stdout.show("MM charge               =",.mm_charge)
      stdout.show("Restraining position    =",.restraining_position)
      stdout.show("Restraining force       =",.restraining_force_constant)

   end

   put_natural_orbitals
   ! Put out the current associated molecular orbitals to file "out"

   ENSURE(.natural_orbitals.created,"no natural orbitals")
   ENSURE(.occupation_numbers.created,"no natural orbital occupations")

      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers)
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)

   end

   put_interpolator
   ! Put out the atom information to file "stdout"

      select case (.basis_kind)

         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            stdout.flush
            stdout.text("Atom slaterbasis info:")
            .slaterbasis.interpolator.put

         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            stdout.flush
            stdout.text("Atom coppensbasis info:")
            .coppensbasis.interpolator.put

         case default
            DIE("no interpolator for basis "//trim(.basis_kind))

      end

   end

end
