!-------------------------------------------------------------------------------
!
! ATOM: can be a quantum mechanical atom, with a basis set
!       or a molecular mechanical atom with a force field potential
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: atom.foo 4409 2014-06-10 03:32:55Z durhammike $
!-------------------------------------------------------------------------------

module ATOM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!  ===============
!  Data statements
!  ===============

   !  The Periodic Table

   element_symbols :: VEC{STR}(len=2,118), public

   data element_symbols/ &
    "H ",                                                                                "He", &
    "Li","Be",                                                  "B ","C ","N ","O ","F ","Ne", &
    "Na","Mg",                                                  "Al","Si","P ","S ","Cl","Ar", &
    "K ","Ca","Sc","Ti","V ","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr", &
    "Rb","Sr","Y ","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I ","Xe", &
    "Cs","Ba","La",     "Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu", &
                   "Hf","Ta","W ","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn", &
    "Fr","Ra","Ac",     "Th","Pa","U ","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr", &
                   "Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Ut","Fl","Up","Lv","Us","Uo"  /

   element_names :: VEC{STR}(len=13,118)

   data element_names/ &
    "Hydrogen     ","Helium       ", &
    "Lithium      ","Beryllium    ", &
    "Boron        ","Carbon       ","Nitrogen     ","Oxygen       ","Fluorine     ","Neon         ", &
    "Sodium       ","Magnesium    ", &
    "Aluminium    ","Silicon      ","Phosphorous  ","Sulfur       ","Chlorine     ","Argon        ", &
    "Potassium    ","Calcium      ", &
    "Scandium     ","Titanium     ","Vanadium     ","Chromium     ","Manganese    ", &
    "Iron         ","Cobalt       ","Nickel       ","Copper       ","Zinc         ", &
    "Gallium      ","Germanium    ","Arsenic      ","Selinium     ","Bromine      ","Krypton      ", &
    "Rubidium     ","Strontium    ", &
    "Yttrium      ","Zirconium    ","Niobium      ","Molybdenum   ","Technitium   ", &
    "Ruthenium    ","Rhodium      ","Palladium    ","Silver       ","Cadmium      ", &
    "Indium       ","Tin          ","Antimony     ","Tellurium    ","Iodine       ","Xenon        ", &
    "Cesium       ","Barium       ", &
    "Lanthanum    ", &
    "Cerium       ","Praseodymium ","Neodymium    ","Promethium   ","Samarium     ","Europium     ","Gadolinium   ", &
    "Terbium      ","Dysprosium   ","Holmium      ","Erbium       ","Thulium      ","Ytterbium    ","Lutetium     ", &
                    "Haffnium     ","Tantalum     ","Tangsten     ","Rhenium      ", &
    "Osmium       ","Iridium      ","Platinum     ","Gold         ","Mercury      ", &
    "Thallium     ","Lead         ","Bismuth      ","Polonium     ","Astatine     ","Radon        ", &
    "Francium     ","Radium       ", &
    "Actinium     ", &
    "Thorium      ","Protactinium ","Uranium      ","Neptunium    ","Plutonium    ","Americium    ","Curium       ", &
    "Berkellium   ","Californium  ","Einsteinium  ","Fermium      ","Mendelevium  ","Nobelium     ","Lawrencium   ", &
                    "Rutherfordium","Dubnuim      ","Seaborgium   ","Bohrium      ", &
    "Hassium      ","Meitnerium   ","Darmstadtium ","Roentgenium  ","Copernicum   ", &
    "Ununtrium    ","Flerovium    ","Ununpentium  ","Livermorium  ","Ununseptium  ","Ununoctium   "/

   !  Table of elemental anamalous dispersion coefficients.
   !  Set by the user
   xray_dispersion_set :: BIN = FALSE
   element_xray_dispersion :: VEC{CPX}(118) = COMPLEXIFY(ZERO,ZERO)

   !  Bragg-Slater radii taken from Aaron Lee's code
   !  WARNING: this is in Angstroms!

   bragg_slater_radii :: VEC{REAL}(54)

   data bragg_slater_radii/ &
      0.35d0,                                          0.35d0, &
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, &
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, &
      2.20d0,1.80d0, &
                    1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,1.40d0,1.35d0,1.35d0,1.35d0,1.35d0, &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, &
      1.30d0,1.30d0, &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0, &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0  /

   atom_bonded_range_factor :: REAL = ATOM_BONDED_RANGE_FACTOR
   atom_vdw_bonded_range_pc :: REAL = 10.0d0

   ! Covalent radii, where do they come from? in Angstrom x 100

   covalent_radii_invariom :: VEC{INT}(109)

   data covalent_radii_invariom/ &
      37,                                                                                   0, &
      123,  90,                                                    80,  77,  74,  71,  72,   0, &
      154, 136,                                                   118, 111, 106, 102,  99,   0, &
      203, 174, 144, 132, 122, 118, 117, 117, 116, 115, 117, 125, 126, 122, 120, 116, 114,   0, &
      218, 191, 162, 145, 134, 130, 127, 125, 125, 128, 134, 148, 144, 141, 140, 136, 133,   0, &
      235, 198, &
               169, 165, 165, 164, 164, 162, 185, 161, 159, 159, 157, 157, 156, 170, &
               156, 144, 134, 130, 128, 126, 127, 130, 134, 149, 148, 147, 146, 146, 145,   0, &
       0,   0, &
               188, 165, 161, 142, 130, 151, 182,   0,   0,   0,   0,   0,   0,   0, &
                 0,   0,   0,   0,   0,   0,   0 /

   ! Allred-Rochow electronegativities, where do they come from?
   ! Values x 100

   allred_rochow_electronegs :: VEC{INT}(85)

   data allred_rochow_electronegs/ &
      220,                                                                                 550, &
      97, 147,                                                   201, 250, 307, 350, 440, 480, &
      101, 123,                                                   147, 174, 206, 244, 283, 320, &
      91, 104, 120, 132, 145, 156, 160, 164, 170, 175, 175, 166, 182, 202, 220, 248, 274, 290, &
      89,  99, 111, 122, 123, 130, 136, 142, 145, 130, 142, 146, 149, 172, 182, 201, 221, 240, &
      86,  97, &
               108, 108, 107, 107, 107, 107, 110, 111, 110, 110, 110, 111, 111, 106, &
               114, 123, 133, 140, 146, 152, 155, 142, 142, 144, 144, 155, 167, 176, 190 /

   covalent_radii_ccdc :: VEC{REAL}(110)

   data covalent_radii_ccdc/ &
      0.23d0, 1.50d0, 1.28d0, 0.96d0, 0.83d0, 0.68d0, 0.68d0, 0.68d0, 0.64d0, 1.50d0, &
      1.66d0, 1.41d0, 1.21d0, 1.20d0, 1.05d0, 1.02d0, 0.99d0, 1.51d0, 2.03d0, 1.76d0, &
      1.70d0, 1.60d0, 1.53d0, 1.39d0, 1.61d0, 1.52d0, 1.26d0, 1.24d0, 1.32d0, 1.22d0, &
      1.22d0, 1.17d0, 1.21d0, 1.22d0, 1.21d0, 1.50d0, 2.20d0, 1.95d0, 1.90d0, 1.75d0, &
      1.64d0, 1.54d0, 1.47d0, 1.46d0, 1.45d0, 1.39d0, 1.45d0, 1.44d0, 1.42d0, 1.39d0, &
      1.39d0, 1.47d0, 1.40d0, 1.50d0, 2.44d0, 2.15d0, 2.07d0, 2.04d0, 2.03d0, 2.01d0, &
      1.99d0, 1.98d0, 1.98d0, 1.96d0, 1.94d0, 1.92d0, 1.92d0, 1.89d0, 1.90d0, 1.87d0, &
      1.87d0, 1.75d0, 1.70d0, 1.62d0, 1.51d0, 1.44d0, 1.41d0, 1.36d0, 1.50d0, 1.32d0, &
      1.45d0, 1.46d0, 1.48d0, 1.40d0, 1.21d0, 1.50d0, 2.60d0, 2.21d0, 2.15d0, 2.06d0, &
      2.00d0, 1.96d0, 1.90d0, 1.87d0, 1.80d0, 1.69d0, 1.54d0, 1.83d0, 1.50d0, 1.50d0, &
      1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0  /

   ! Van der Waals radii from CCDC, in Angstrom

   vdw_radii_ccdc :: VEC{REAL}(110)

   data vdw_radii_ccdc/ &
      1.09d0, 1.40d0, 1.82d0, 2.00d0, 2.00d0, 1.70d0, 1.55d0, 1.52d0, 1.47d0, 1.54d0, &
      2.27d0, 1.73d0, 2.00d0, 2.10d0, 1.80d0, 1.80d0, 1.75d0, 1.88d0, 2.75d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.63d0, 1.40d0, 1.39d0, &
      1.87d0, 2.00d0, 1.85d0, 1.90d0, 1.85d0, 2.02d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.63d0, 1.72d0, 1.58d0, 1.93d0, 2.17d0, &
      2.00d0, 2.06d0, 1.98d0, 2.16d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.72d0, 1.66d0, 1.55d0, &
      1.96d0, 2.02d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 1.86d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0 /

   ! Abundance weighted atomic masses taken from the WWW to be the
   ! same as Turbomol. This should be updated to a proper source.

   atomic_masses :: VEC{REAL}(92)

   data atomic_masses/ &
       1.007970d0,   4.002600d0, &
       6.939000d0,   9.012200d0,  10.811000d0,  12.011150d0,  14.006700d0,  15.999400d0,  18.998400d0,  20.183000d0, &
      22.989800d0,  24.312000d0,  26.981500d0,  28.086000d0,  30.973800d0,  32.064000d0,  35.453000d0,  39.948000d0, &
      39.102000d0,  40.080000d0, &
                    44.956000d0,  47.900000d0,  50.942000d0,  51.996000d0,  54.938000d0, &
                    55.850000d0,  58.933200d0,  58.710000d0,  63.540000d0,  65.370000d0, &
                                  69.720000d0,  72.590000d0,  74.921600d0,  78.960000d0,  79.909000d0,  83.800000d0, &
      85.470000d0,  87.620000d0,  &
                    88.905000d0,  91.220000d0,  92.906000d0,  95.940000d0,  99.000000d0, &
                   101.070000d0, 102.905000d0, 106.400000d0, 107.870000d0, 112.400000d0, &
                                 114.820000d0, 118.690000d0, 121.750000d0, 127.600000d0, 126.904000d0, 131.300000d0, &
      132.905000d0, 137.330000d0, &
                   138.910000d0, 140.115000d0, 140.908000d0, 144.240000d0, 146.920000d0, 150.360000d0, 151.965000d0, &
                   157.250000d0, 158.925000d0, 162.500000d0, 164.930000d0, 167.260000d0, 168.930000d0, 173.040000d0, &
                   174.970000d0, 178.490000d0, 180.950000d0, 183.850000d0, 186.210000d0, &
                   190.200000d0, 192.220000d0, 195.080000d0, 196.070000d0, 200.590000d0, &
                                 204.380000d0, 207.200000d0, 208.980000d0, 208.980000d0, 209.990000d0, 222.020000d0, &
      223.020000d0, 226.030000d0, &
                   227.030000d0, 232.040000d0, 231.040000d0, 238.030000d0/

   ! Abundance-weighted coherent neutron scattering lengths in fm
   ! taken from: International Tables for Crystallography, Vol. C,
   ! 2004, Table 4.2.6.8 pp 255-257

   neutron_scattering_lengths :: VEC{REAL}(95)

   data neutron_scattering_lengths/ &
      -3.7390d0,  3.2600d0, &
      -1.9000d0,  7.7900d0,  5.3000d0,  6.6460d0,  9.3600d0,  5.8030d0,  5.6540d0,  4.5470d0, &
       3.6300d0,  5.3750d0,  3.4490d0,  4.1490d0,  5.1300d0,  2.8470d0,  9.5770d0,  1.9090d0, &
       3.7100d0,  4.9000d0, &
                 12.2900d0, -3.4380d0,  -.3824,  3.6350d0, -3.7300d0, &
                  9.5400d0,  2.5000d0, 10.3000d0,  7.7180d0,  5.6890d0, &
                             7.2879d0,  8.1929d0,  6.5800d0,  7.9700d0,  6.7950d0,  7.8000d0, &
       7.0800d0,  7.0200d0, &
                  7.7500d0,  7.1600d0,  7.0540d0,  6.9500d0,  6.8000d0, &
                  7.2100d0,  5.8800d0,  5.9100d0,  5.9220d0,  5.1000d0, &
                             4.0650d0,  6.2257d0,  5.5700d0,  5.8000d0,  5.2800d0,  4.8500d0, &
       5.4200d0,  5.0600d0, &
                  8.2400d0,  4.8400d0,  4.4500d0,  7.6900d0, 12.6000d0,  4.2000d0,  6.7300d0, &
                  9.5000d0,  7.3800d0, 16.9000d0,  8.0800d0,  8.0300d0,  7.0700d0, 12.4100d0, &
                  7.2100d0,  7.7700d0,  6.9100d0,  4.7700d0,  9.2000d0, &
                 11.0000d0, 10.6000d0,  9.6000d0,  7.6300d0, 12.6920d0, &
                             8.7760d0,  9.4017d0,  8.5307d0,  0.0000d0,  0.0000d0,  0.0000d0, &
       0.0000d0, 10.0000d0, &
                  0.0000d0, 10.6300d0,  9.1000d0,  8.4170d0, 10.5500d0, 14.1000d0,  8.3000d0/

   ! H SDS scattering factor a_i & b_i expansion coefficients
   ! taken from shelxl (2014) via SFAC.OUT ... nearly the same
   ! as IT B Table 6.1.1.4 first line; Note a_0 is actually c.
   !
   !    f(sin theta/lambda) \sum_0^4 a_i exp(-b_i (sin theta/lambda)^2)
   !
   ! NOTE: sin theta/lambda in in Anstrom^-1

   H_SDS_form_factor_coeff :: MAT{REAL}(2,0:4)

   data H_SDS_form_factor_coeff/ &
      0.003038d0,  0.00000d0, &
      0.493002d0, 10.51091d0, &
      0.322912d0, 26.12573d0, &
      0.140191d0,  3.14236d0, &
      0.040810d0, 57.79977d0  /

   ! Neutral H atom form factor

   H_HF0_form_factor_coeff :: MAT{REAL}(2,0:4)

   data H_HF0_form_factor_coeff/ &
      0.001305d0,  0.00000d0, &
      0.489918d0, 20.65930d0, &
      0.262003d0,  7.74039d0, &
      0.196767d0, 49.55190d0, &
      0.049879d0,  2.20159d0  /

   ! HF neutral (0 charge) atom form factor coefficients
   ! From: International Tables Vol.C (1992), pp.572. Table 6.1.1.4

   HF_n0_form_factor_coeff :: MAT3{REAL}(2,0:4,98)

   data HF_n0_form_factor_coeff/ &
   0.001305d0, 0.000000d0,  0.489918d0, 20.659300d0,  0.262003d0,  7.740390d0,  0.196767d0,  49.551900d0, 0.049879d0,   2.201590d0, & ! H
   0.006400d0, 0.000000d0,  0.873400d0,  9.103700d0,  0.630900d0,  3.356800d0,  0.311200d0,  22.927600d0, 0.178000d0,   0.982100d0, & ! He
   0.037700d0, 0.000000d0,  1.128200d0,  3.954600d0,  0.750800d0,  1.052400d0,  0.617500d0,  85.390500d0, 0.465300d0, 168.261000d0, & ! Li
   0.038500d0, 0.000000d0,  1.591900d0, 43.642700d0,  1.127800d0,  1.862300d0,  0.539100d0, 103.483000d0, 0.702900d0,   0.542000d0, & ! Be
  -0.193200d0, 0.000000d0,  2.054500d0, 23.218500d0,  1.332600d0,  1.021000d0,  1.097900d0,  60.349800d0, 0.706800d0,   0.140300d0, & ! B
   0.215600d0, 0.000000d0,  2.310000d0, 20.843900d0,  1.020000d0, 10.207500d0,  1.588600d0,   0.568700d0, 0.865000d0,  51.651200d0, & ! C
 -11.529000d0, 0.000000d0, 12.212600d0,  0.005700d0,  3.132200d0,  9.893300d0,  2.012500d0,  28.997500d0, 1.166300d0,   0.582600d0, & ! N
   0.250800d0, 0.000000d0,  3.048500d0, 13.277100d0,  2.286800d0,  5.701100d0,  1.546300d0,   0.323900d0, 0.867000d0,  32.908900d0, & ! O
   0.277600d0, 0.000000d0,  3.539200d0, 10.282500d0,  2.641200d0,  4.294400d0,  1.517000d0,   0.261500d0, 1.024300d0,  26.147600d0, & ! F
   0.351500d0, 0.000000d0,  3.955300d0,  8.404200d0,  3.112500d0,  3.426200d0,  1.454600d0,   0.230600d0, 1.125100d0,  21.718400d0, & ! Ne
   0.676000d0, 0.000000d0,  4.762600d0,  3.285000d0,  3.173600d0,  8.842200d0,  1.267400d0,   0.313600d0, 1.112800d0, 129.424000d0, & ! Na
   0.858400d0, 0.000000d0,  5.420400d0,  2.827500d0,  2.173500d0, 79.261100d0,  1.226900d0,   0.380800d0, 2.307300d0,   7.193700d0, & ! Mg
   1.115100d0, 0.000000d0,  6.420200d0,  3.038700d0,  1.900200d0,  0.742600d0,  1.593600d0,  31.547200d0, 1.964600d0,  85.088600d0, & ! Al
   1.140700d0, 0.000000d0,  6.291500d0,  2.438600d0,  3.035300d0, 32.333700d0,  1.989100d0,   0.678500d0, 1.541000d0,  81.693700d0, & ! Si
   1.114900d0, 0.000000d0,  6.434500d0,  1.906700d0,  4.179100d0, 27.157000d0,  1.780000d0,   0.526000d0, 1.490800d0,  68.164500d0, & ! P
   0.866900d0, 0.000000d0,  6.905300d0,  1.467900d0,  5.203400d0, 22.215100d0,  1.437900d0,   0.253600d0, 1.586300d0,  56.172000d0, & ! S
  -9.557400d0, 0.000000d0, 11.460400d0,  0.010400d0,  7.196400d0,  1.166200d0,  6.255600d0,  18.519400d0, 1.645500d0,  47.778400d0, & ! Cl
   1.444500d0, 0.000000d0,  7.484500d0,  0.907200d0,  6.772300d0, 14.840700d0,  0.653900d0,  43.898300d0, 1.644200d0,  33.392900d0, & ! Ar
   1.422800d0, 0.000000d0,  8.218600d0, 12.794900d0,  7.439800d0,  0.774800d0,  1.051900d0, 213.187000d0, 0.865900d0,  41.684100d0, & ! K
   1.375100d0, 0.000000d0,  8.626600d0, 10.442100d0,  7.387300d0,  0.659900d0,  1.589900d0,  85.748400d0, 1.021100d0, 178.437000d0, & ! Ca
   1.332900d0, 0.000000d0,  9.189000d0,  9.021300d0,  7.367900d0,  0.572900d0,  1.640900d0, 136.108000d0, 1.468000d0,  51.353100d0, & ! Sc
   1.280700d0, 0.000000d0,  9.759500d0,  7.850800d0,  7.355800d0,  0.500000d0,  1.699100d0,  35.633800d0, 1.902100d0, 116.105000d0, & ! Ti
   1.219900d0, 0.000000d0, 10.297100d0,  6.865700d0,  7.351100d0,  0.438500d0,  2.070300d0,  26.893800d0, 2.057100d0, 102.478000d0, & ! V
   1.183200d0, 0.000000d0, 10.640600d0,  6.103800d0,  7.353700d0,  0.392000d0,  3.324000d0,  20.262600d0, 1.492200d0,  98.739900d0, & ! Cr
   1.089600d0, 0.000000d0, 11.281900d0,  5.340900d0,  7.357300d0,  0.343200d0,  3.019300d0,  17.867400d0, 2.244100d0,  83.754300d0, & ! Mn
   1.036900d0, 0.000000d0, 11.769500d0,  4.761100d0,  7.357300d0,  0.307200d0,  3.522200d0,  15.353500d0, 2.304500d0,  76.880500d0, & ! Fe
   1.011800d0, 0.000000d0, 12.284100d0,  4.279100d0,  7.340900d0,  0.278400d0,  4.003400d0,  13.535900d0, 2.348800d0,  71.169200d0, & ! Co
   1.034100d0, 0.000000d0, 12.837600d0,  3.878500d0,  7.292000d0,  0.256500d0,  4.443800d0,  12.176300d0, 2.380000d0,  66.342100d0, & ! Ni
   1.191000d0, 0.000000d0, 13.338000d0,  3.582800d0,  7.167600d0,  0.247000d0,  5.615800d0,  11.396600d0, 1.673500d0,  64.812600d0, & ! Cu
   1.304100d0, 0.000000d0, 14.074300d0,  3.265500d0,  7.031800d0,  0.233300d0,  5.165200d0,  10.316300d0, 2.410000d0,  58.709700d0, & ! Zn
   1.718900d0, 0.000000d0, 15.235400d0,  3.066900d0,  6.700600d0,  0.241200d0,  4.359100d0,  10.780500d0, 2.962300d0,  61.413500d0, & ! Ga
   2.131300d0, 0.000000d0, 16.081600d0,  2.850900d0,  6.374700d0,  0.251600d0,  3.706800d0,  11.446800d0, 3.683000d0,  54.762500d0, & ! Ge
   2.531000d0, 0.000000d0, 16.672300d0,  2.634500d0,  6.070100d0,  0.264700d0,  3.431300d0,  12.947900d0, 4.277900d0,  47.797200d0, & ! As
   2.840900d0, 0.000000d0, 17.000600d0,  2.409800d0,  5.819600d0,  0.272600d0,  3.973100d0,  15.237200d0, 4.354300d0,  43.816300d0, & ! Se
   2.955700d0, 0.000000d0, 17.178900d0,  2.172300d0,  5.235800d0, 16.579600d0,  5.637700d0,   0.260900d0, 3.985100d0,  41.432800d0, & ! Br
   2.825000d0, 0.000000d0, 17.355500d0,  1.938400d0,  6.728600d0, 16.562300d0,  5.549300d0,   0.226100d0, 3.537500d0,  39.397200d0, & ! Kr
   3.487300d0, 0.000000d0, 17.178400d0,  1.788800d0,  9.643500d0, 17.315100d0,  5.139900d0,   0.274800d0, 1.529200d0, 164.934000d0, & ! Rb
   2.506400d0, 0.000000d0, 17.566300d0,  1.556400d0,  9.818400d0, 14.098800d0,  5.422000d0,   0.166400d0, 2.669400d0, 132.376000d0, & ! Sr
   1.912130d0, 0.000000d0, 17.776000d0,  1.402900d0, 10.294600d0, 12.800600d0,  5.726290d0,   0.125599d0, 3.265880d0, 104.354000d0, & ! Y
   2.069290d0, 0.000000d0, 17.876500d0,  1.276180d0, 10.948000d0, 11.916000d0,  5.417320d0,   0.117622d0, 3.657210d0,  87.662700d0, & ! Zr
   3.755910d0, 0.000000d0, 17.614200d0,  1.188650d0, 12.014400d0, 11.766000d0,  4.041830d0,   0.204785d0, 3.533460d0,  69.795700d0, & ! Nb
   4.387500d0, 0.000000d0,  3.702500d0,  0.277200d0, 17.235600d0,  1.095800d0, 12.887600d0,  11.004000d0, 3.742900d0,  61.658400d0, & ! Mo
   5.404280d0, 0.000000d0, 19.130100d0,  0.864132d0, 11.094800d0,  8.144870d0,  4.649010d0,  21.570700d0, 2.712630d0,  86.847200d0, & ! Tc
   5.378740d0, 0.000000d0, 19.267400d0,  0.808520d0, 12.918200d0,  8.434670d0,  4.863370d0,  24.799700d0, 1.567560d0,  94.292800d0, & ! Ru
   5.328000d0, 0.000000d0, 19.295700d0,  0.751536d0, 14.350100d0,  8.217580d0,  4.734250d0,  25.874900d0, 1.289180d0,  98.606200d0, & ! Rh
   5.265930d0, 0.000000d0, 19.331900d0,  0.698655d0, 15.501700d0,  7.989290d0,  5.295370d0,  25.205200d0, 0.605844d0,  76.898600d0, & ! Pd
   5.179000d0, 0.000000d0, 19.280800d0,  0.644600d0, 16.688500d0,  7.472600d0,  4.804500d0,  24.660500d0, 1.046300d0,  99.815600d0, & ! Ag
   5.069400d0, 0.000000d0, 19.221400d0,  0.594600d0, 17.644400d0,  6.908900d0,  4.461000d0,  24.700800d0, 1.602900d0,  87.482500d0, & ! Cd
   4.939100d0, 0.000000d0, 19.162400d0,  0.547600d0, 18.559600d0,  6.377600d0,  4.294800d0,  25.849900d0, 2.039600d0,  92.802900d0, & ! In
   4.782100d0, 0.000000d0, 19.188900d0,  5.830300d0, 19.100500d0,  0.503100d0,  4.458500d0,  26.890900d0, 2.466300d0,  83.957100d0, & ! Sn
   4.590900d0, 0.000000d0, 19.641800d0,  5.303400d0, 19.045500d0,  0.460700d0,  5.037100d0,  27.907400d0, 2.682700d0,  75.282500d0, & ! Sb
   4.352000d0, 0.000000d0, 19.964400d0,  4.817420d0, 19.013800d0,  0.420885d0,  6.144870d0,  28.528400d0, 2.523900d0,  70.840300d0, & ! Te
   4.071200d0, 0.000000d0, 20.147200d0,  4.347000d0, 18.994900d0,  0.381400d0,  7.513800d0,  27.766000d0, 2.273500d0,  66.877600d0, & ! I
   3.711800d0, 0.000000d0, 20.293300d0,  3.928200d0, 19.029800d0,  0.344000d0,  8.976700d0,  26.465900d0, 1.990000d0,  64.265800d0, & ! Xe
   3.335200d0, 0.000000d0, 20.389200d0,  3.569000d0, 19.106200d0,  0.310700d0, 10.662000d0,  24.387900d0, 1.495300d0, 213.904000d0, & ! Cs
   2.773100d0, 0.000000d0, 20.336100d0,  3.216000d0, 19.297000d0,  0.275600d0, 10.888000d0,  20.207300d0, 2.695900d0, 167.202000d0, & ! Ba
   2.146780d0, 0.000000d0, 20.578000d0,  2.948170d0, 19.599000d0,  0.244475d0, 11.372700d0,  18.772600d0, 3.287190d0, 133.124000d0, & ! La
   1.862640d0, 0.000000d0, 21.167100d0,  2.812190d0, 19.769500d0,  0.226836d0, 11.851300d0,  17.608300d0, 3.330490d0, 127.113000d0, & ! Ce
   2.058300d0, 0.000000d0, 22.044000d0,  2.773930d0, 19.669700d0,  0.222087d0, 12.385600d0,  16.766900d0, 2.824280d0, 143.644000d0, & ! Pr
   1.984860d0, 0.000000d0, 22.684500d0,  2.662480d0, 19.684700d0,  0.210628d0, 12.774000d0,  15.885000d0, 2.851370d0, 137.903000d0, & ! Nd
   2.028760d0, 0.000000d0, 23.340500d0,  2.562700d0, 19.609500d0,  0.202088d0, 13.123500d0,  15.100900d0, 2.875160d0, 132.721000d0, & ! Pm
   2.209630d0, 0.000000d0, 24.004200d0,  2.472740d0, 19.425800d0,  0.196451d0, 13.439600d0,  14.399600d0, 2.896040d0, 128.007000d0, & ! Sm
   2.574500d0, 0.000000d0, 24.627400d0,  2.387900d0, 19.088600d0,  0.194200d0, 13.760300d0,  13.754600d0, 2.922700d0, 123.174000d0, & ! Eu
   2.419600d0, 0.000000d0, 25.070900d0,  2.253410d0, 19.079800d0,  0.181951d0, 13.851800d0,  12.933100d0, 3.545450d0, 101.398000d0, & ! Gd
   3.583240d0, 0.000000d0, 25.897600d0,  2.242560d0, 18.218500d0,  0.196143d0, 14.316700d0,  12.664800d0, 2.953540d0, 115.362000d0, & ! Tb
   4.297280d0, 0.000000d0, 26.507000d0,  2.180200d0, 17.638300d0,  0.202172d0, 14.559600d0,  12.189900d0, 2.965770d0, 111.874000d0, & ! Dy
   4.567960d0, 0.000000d0, 26.904900d0,  2.070510d0, 17.294000d0,  0.197940d0, 14.558300d0,  11.440700d0, 3.638370d0,  92.656600d0, & ! Ho
   5.920460d0, 0.000000d0, 27.656300d0,  2.073560d0, 16.428500d0,  0.223545d0, 14.977900d0,  11.360400d0, 2.982330d0, 105.703000d0, & ! Er
   6.756210d0, 0.000000d0, 28.181900d0,  2.028590d0, 15.885100d0,  0.238849d0, 15.154200d0,  10.997500d0, 2.987060d0, 102.961000d0, & ! Tm
   7.566720d0, 0.000000d0, 28.664100d0,  1.988900d0, 15.434500d0,  0.257119d0, 15.308700d0,  10.664700d0, 2.989630d0, 100.417000d0, & ! Yb
   7.976280d0, 0.000000d0, 28.947600d0,  1.901820d0, 15.220800d0,  9.985190d0, 15.100000d0,   0.261033d0, 3.716010d0,  84.329800d0, & ! Lu
   8.581540d0, 0.000000d0, 29.144000d0,  1.832620d0, 15.172600d0,  9.599900d0, 14.758600d0,   0.275116d0, 4.300130d0,  72.029000d0, & ! Hf
   9.243540d0, 0.000000d0, 29.202400d0,  1.773330d0, 15.229300d0,  9.370460d0, 14.513500d0,   0.295977d0, 4.764920d0,  63.364400d0, & ! Ta
   9.887500d0, 0.000000d0, 29.081800d0,  1.720290d0, 15.430000d0,  9.225900d0, 14.432700d0,   0.321703d0, 5.119820d0,  57.056000d0, & ! W
  10.472000d0, 0.000000d0, 28.762100d0,  1.671910d0, 15.718900d0,  9.092270d0, 14.556400d0,   0.350500d0, 5.441740d0,  52.086100d0, & ! Re
  11.000500d0, 0.000000d0, 28.189400d0,  1.629030d0, 16.155000d0,  8.979480d0, 14.930500d0,   0.382661d0, 5.675890d0,  48.164700d0, & ! Os
  11.472200d0, 0.000000d0, 27.304900d0,  1.592790d0, 16.729600d0,  8.865530d0, 15.611500d0,   0.417916d0, 5.833770d0,  45.001100d0, & ! Ir
  11.688300d0, 0.000000d0, 27.005900d0,  1.512930d0, 17.763900d0,  8.811740d0, 15.713100d0,   0.424593d0, 5.783700d0,  38.610300d0, & ! Pt
  12.065800d0, 0.000000d0, 16.881900d0,  0.461100d0, 18.591300d0,  8.621600d0, 25.558200d0,   1.482600d0, 5.860000d0,  36.395600d0, & ! Au
  12.608900d0, 0.000000d0, 20.680900d0,  0.545000d0, 19.041700d0,  8.448400d0, 21.657500d0,   1.572900d0, 5.967600d0,  38.324600d0, & ! Hg
  13.174600d0, 0.000000d0, 27.544600d0,  0.655150d0, 19.158400d0,  8.707510d0, 15.538000d0,   1.963470d0, 5.525930d0,  45.814900d0, & ! Tl
  13.411800d0, 0.000000d0, 31.061700d0,  0.690200d0, 13.063700d0,  2.357600d0, 18.442000d0,   8.618000d0, 5.969600d0,  47.257900d0, & ! Pb
  13.578200d0, 0.000000d0, 33.368900d0,  0.704000d0, 12.951000d0,  2.923800d0, 16.587700d0,   8.793700d0, 6.469200d0,  48.009300d0, & ! Bi
  13.677000d0, 0.000000d0, 34.672600d0,  0.700999d0, 15.473300d0,  3.550780d0, 13.113800d0,   9.556420d0, 7.025880d0,  47.004500d0, & ! Po
  13.710800d0, 0.000000d0, 35.316300d0,  0.685870d0, 19.021100d0,  3.974580d0,  9.498870d0,  11.382400d0, 7.425180d0,  45.471500d0, & ! At
  13.690500d0, 0.000000d0, 35.563100d0,  0.663100d0, 21.281600d0,  4.069100d0,  8.003700d0,  14.042200d0, 7.443300d0,  44.247300d0, & ! Rn
  13.724700d0, 0.000000d0, 35.929900d0,  0.646453d0, 23.054700d0,  4.176190d0, 12.143900d0,  23.105200d0, 2.112530d0, 150.645000d0, & ! Fr
  13.621100d0, 0.000000d0, 35.763000d0,  0.616341d0, 22.906400d0,  3.871350d0, 12.473900d0,  19.988700d0, 3.210970d0, 142.325000d0, & ! Ra
  13.526600d0, 0.000000d0, 35.659700d0,  0.589092d0, 23.103200d0,  3.651550d0, 12.597700d0,  18.599000d0, 4.086550d0, 117.020000d0, & ! Ac
  13.431400d0, 0.000000d0, 35.564500d0,  0.563359d0, 23.421900d0,  3.462040d0, 12.747300d0,  17.830900d0, 4.807030d0,  99.172200d0, & ! Th
  13.428700d0, 0.000000d0, 35.884700d0,  0.547751d0, 23.294800d0,  3.415190d0, 14.189100d0,  16.923500d0, 4.172870d0, 105.251000d0, & ! Pa
  13.396600d0, 0.000000d0, 36.022800d0,  0.529300d0, 23.412800d0,  3.325300d0, 14.949100d0,  16.092700d0, 4.188000d0, 100.613000d0, & ! U
  13.357300d0, 0.000000d0, 36.187400d0,  0.511929d0, 23.596400d0,  3.253960d0, 15.640200d0,  15.362200d0, 4.185500d0,  97.490800d0, & ! Np
  13.381200d0, 0.000000d0, 36.525400d0,  0.499384d0, 23.808300d0,  3.263710d0, 16.770700d0,  14.945500d0, 3.479470d0, 105.980000d0, & ! Pu
  13.359200d0, 0.000000d0, 36.670600d0,  0.483629d0, 24.099200d0,  3.206470d0, 17.341500d0,  14.313600d0, 3.493310d0, 102.273000d0, & ! Am
  13.288700d0, 0.000000d0, 36.648800d0,  0.465154d0, 24.409600d0,  3.089970d0, 17.399000d0,  13.434600d0, 4.216650d0,  88.483400d0, & ! Cm
  13.275400d0, 0.000000d0, 36.788100d0,  0.451018d0, 24.773600d0,  3.046190d0, 17.891900d0,  12.894600d0, 4.232840d0,  86.003000d0, & ! Bk
  13.267400d0, 0.000000d0, 36.918500d0,  0.437533d0, 25.199500d0,  3.007750d0, 18.331700d0,  12.404400d0, 4.243910d0,  83.788100d0  / ! Cf

   ! Spackman's a-coefficients for the dispersion part of the
   ! atom-atom potentials (in au).  Unknown values assigned 0.000
   ! Hydrogen a-coefficient is for the xi = 1.24 contraction
   ! (Hydrogen xi = 1.00 has a a-coefficient of 2.549 au ... not reported in table)
   ! See Spackman M. A. (1986) J. Chem. Phys. 85 p. 6579

   Spackman86_a_6_disp_coeff :: VEC{REAL}(110), public

   data Spackman86_a_6_disp_coeff / &
      1.337d0,  0.000d0,  0.000d0,  0.000d0,  9.740d0,  7.029d0,  5.240d0,  4.204d0,  3.233d0,  0.000d0, &
      0.000d0,  0.000d0, 21.491d0, 16.726d0, 13.261d0, 11.633d0,  9.611d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
     22.981d0, 19.744d0, 15.908d0, 14.799d0, 12.920d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0, &
      0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0,  0.000d0 /

   ! Spackman's b- and c-coefficients for fitting exp-6 functional
   ! form to the Gordon-Kim repulsive potentials (in au and au-1
   ! respectively). Unknown values assigned 0.0000.
   ! Hydrogen b-coefficient is for the xi=1.24 contraction
   ! (Hydrogen xi = 1.00 has a b-coefficient of 1.2010 au ... not reported in table)
   ! (Hydrogen xi = 1.00 has a c-coefficient of 0.685 au-1 ... not reported in table)
   ! See Spackman M. A. (1986) J. Chem. Phys. 85 p. 6579

   Spackman86_b_exp_prefactor :: VEC{REAL}(110), public
   Spackman86_c_exp_exponent  :: VEC{REAL}(110), public

   data Spackman86_b_exp_prefactor/ &
      1.6615d0,  0.0000d0,  0.0000d0,  0.0000d0,  3.4281d0,  5.8459d0,  9.2090d0,  9.8367d0, 11.3149d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  3.2590d0,  6.1511d0, 10.6743d0, 14.3528d0, 19.8508d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
     13.3691d0, 15.0062d0, 21.5022d0, 19.7261d0, 25.9946d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0, &
      0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0,  0.0000d0 /

   data Spackman86_c_exp_exponent/ &
      0.871d0, 0.000d0, 0.000d0, 0.000d0, 0.642d0, 0.793d0, 0.939d0, 1.005d0, 1.092d0, 0.000d0, &
      0.000d0, 0.000d0, 0.565d0, 0.653d0, 0.757d0, 0.829d0, 0.916d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.754d0, 0.772d0, 0.836d0, 0.838d0, 0.899d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, &
      0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0, 0.000d0 /

   ! a-coefficients for dispersion term of atom-atom potentials (au)
   ! These are related to Grimme's C6 coefficients, where a = sqrt(C6).
   ! Coefficients for H-Xe defined. Unknown values assigned 0.00.
   ! See Grimme S. (2006) J. Comp. Chem. 27(15) p. 1787
   ! 
   !  0.14,   0.08,  1.61,  1.61,  3.13,  1.75,  1.23,  0.70,  0.75,  0.63, 
   !  5.71,   5.71, 10.79,  9.23,  7.84,  5.57,  5.07,  4.61, 10.80, 10.80, 
   !  10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80, 10.80,
   !  16.99, 17.10, 16.37, 12.64, 12.47, 12.01, 24.67, 24.67, 24.67, 24.67, 
   !  24.67, 24.67, 24.67, 24.67, 24.67, 24.67, 24.67, 24.67, 37.32, 38.71, 
   !  38.44, 31.74, 31.50, 29.99


   Grimme06_a_6_disp_coeff :: VEC{REAL}(110), public

   data Grimme06_a_6_disp_coeff / &
       1.56d0,  1.18d0,  5.28d0,  5.28d0,  7.37d0,  5.51d0,  4.62d0,  3.48d0,  3.61d0,  3.31d0, &
       9.95d0,  9.95d0, 13.68d0, 12.65d0, 11.66d0,  9.83d0,  9.38d0,  8.94d0, 13.69d0, 13.69d0, &
      13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, 13.69d0, &
      17.17d0, 17.22d0, 16.85d0, 14.81d0, 14.71d0, 14.43d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, &
      20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 20.69d0, 25.44d0, 25.91d0, &
      25.82d0, 23.46d0, 23.37d0, 22.81d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, &
       0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0,  0.00d0, 0.00d0,  0.00d0,  0.00d0 /

   ! placeholder value of 2.0 angstrom for those not int the Grimme06 paper
   ! Note that thes are also in bohr/au
   ! These are essentially vdw radii
   Grimme06_r_0_disp_coeff :: VEC{REAL}(110), public

   data Grimme06_r_0_disp_coeff / &
       1.892d0, 1.912d0, 1.559d0, 2.661d0, 2.806d0, 2.744d0, 2.640d0, 2.536d0, 2.432d0, 2.349d0, &
       2.162d0, 2.578d0, 3.097d0, 3.243d0, 3.222d0, 3.180d0, 3.097d0, 3.014d0, 2.806d0, 2.785d0, &
       2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, 2.952d0, &
       3.118d0, 3.264d0, 3.326d0, 3.347d0, 3.305d0, 3.264d0, 3.076d0, 3.035d0, 3.097d0, 3.097d0, &
       3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.097d0, 3.160d0, 3.409d0, &
       3.555d0, 3.575d0, 3.575d0, 3.555d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, &
       3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0, 3.779d0 /

   ! Atomic Polarizabilities (au)
   ! "Atomic Polarizabilities and Hyperpolarizabilities: A Critical Compilation."
   ! A. J. Thakkar and C. Lupinetti, in Atoms, Molecules and Clusters in Electric Fields. 
   ! Theoretical Approaches to the Calculation of Electric Polarizability
   ! pp. 505-529, Edited by G. Maroulis, Imperial College Press, London (2006)
   ! Hydrogen polarizability is for the xi = 1.00 contraction
   ! (Hydrogen xi = 1.24 has a polarizability of 1.90 au ... not reported in table)
   ! Values up to and including Nobelium. Post-Nobelium elements assigned a value of 0.00.

   Thakkar_atomic_polarizability :: VEC{REAL}(110), public

   data Thakkar_atomic_polarizability / &
     4.50d0,   1.38d0, 164.04d0,  37.74d0,  20.43d0,  11.67d0,   7.26d0,   5.24d0,   3.70d0,   2.66d0, &
   162.88d0,  71.22d0,  57.79d0,  37.17d0,  24.93d0,  19.37d0,  14.57d0,  11.09d0, 291.10d0, 157.90d0, &
   142.30d0, 114.30d0,  97.30d0,  94.70d0,  75.50d0,  63.90d0,  57.70d0,  51.10d0,  45.50d0,  38.35d0, &
    52.91d0,  40.80d0,  29.80d0,  26.24d0,  21.13d0,  16.80d0, 316.20d0, 199.00d0, 153.00d0, 121.00d0, &
   106.00d0,  86.00d0,  77.00d0,  65.00d0,  58.00d0,  32.00d0,  52.46d0,  47.55d0,  68.67d0,  57.30d0, &
    42.20d0,  38.10d0,  32.98d0,  27.06d0, 396.00d0, 273.50d0, 210.00d0, 200.00d0, 190.00d0, 212.00d0, &
   203.00d0, 194.00d0, 187.00d0, 159.00d0, 172.00d0, 165.00d0, 159.00d0, 153.00d0, 147.00d0, 145.30d0, &
   148.00d0, 109.00d0,  88.00d0,  75.00d0,  65.00d0,  57.00d0,  51.00d0,  44.00d0,  36.06d0,  34.73d0, &
    71.72d0,  60.05d0,  48.60d0,  43.62d0,  40.73d0,  33.18d0, 315.20d0, 246.20d0, 217.00d0, 217.00d0, &
   171.00d0, 153.00d0, 167.00d0, 165.00d0, 157.00d0, 155.00d0, 153.00d0, 138.00d0, 133.00d0, 161.00d0, &
   123.00d0, 118.00d0,   0.00d0,   0.00d0,   0.00d0,   0.00d0, 0.00d0,   0.00d0,   0.00d0,   0.00d0 /

   ! Atomic polarizibilities for charged species
   ! if not assigned, these should be the same as the uncharged
   ! +/- are in the same table, double charges are implicit e.g. for Ca
   ! + will be SIGNIFICANTLY smaller than neutral, - should be a bit larger than neutral
   ! val for iodine was interpolated
   Charged_atomic_polarizibility :: VEC{REAL}(110), public

   data Charged_atomic_polarizibility / &
     4.50d0,   1.38d0,  0.19d0,   0.052d0,  20.43d0,  11.67d0,   7.26d0,   5.24d0,   7.25d0,   2.66d0, &
   0.986d0,   0.482d0,  57.79d0,  37.17d0,  24.93d0,  19.37d0,  21.20d0,  11.09d0,   5.40d0,   3.20d0, &
   142.30d0, 114.30d0,  97.30d0,  94.70d0,  75.50d0,  63.90d0,  57.70d0,  51.10d0,  45.50d0,  38.35d0, &
    52.91d0,  40.80d0,  29.80d0,  26.24d0,  27.90d0,  16.80d0,   9.10d0,   5.80d0, 153.00d0, 121.00d0, &
   106.00d0,  86.00d0,  77.00d0,  65.00d0,  58.00d0,  32.00d0,  52.46d0,  47.55d0,  68.67d0,  57.30d0, &
    42.20d0,  38.10d0,  39.60d0,  27.06d0,  15.70d0,  10.60d0, 210.00d0, 200.00d0, 190.00d0, 212.00d0, &
   203.00d0, 194.00d0, 187.00d0, 159.00d0, 172.00d0, 165.00d0, 159.00d0, 153.00d0, 147.00d0, 145.30d0, &
   148.00d0, 109.00d0,  88.00d0,  75.00d0,  65.00d0,  57.00d0,  51.00d0,  44.00d0,  36.06d0,  34.73d0, &
    71.72d0,  60.05d0,  48.60d0,  43.62d0,  40.73d0,  33.18d0,  20.40d0,  13.40d0, 217.00d0, 217.00d0, &
   171.00d0, 153.00d0, 167.00d0, 165.00d0, 157.00d0, 155.00d0, 153.00d0, 138.00d0, 133.00d0, 161.00d0, &
   123.00d0, 118.00d0,   0.00d0,   0.00d0,   0.00d0,   0.00d0, 0.00d0,   0.00d0,   0.00d0,   0.00d0 /

   ! Table of isotope masses and abundances taken from NIST
   !
   !    http://www.nist.gov/pml/data/comp.cfm
   !
   ! According to the blurb on the site:
   !
   ! The atomic weights are available for elements 1 through 118 and
   ! isotopic compositions or abundances are given when appropriate.
   ! The atomic weights data were published by M.E. Weiser and M.
   ! Berglund in Atomic Weights of the Elements 2007, and the
   ! isotopic compositions data were published by J.K. Böhlke, J.R.
   ! de Laeter, P. De Bièvre, H. Hidaka, H.S. Peiser, K.J.R.
   ! Rosman, and P.D.P. Taylor in Isotopic Compositions of the
   ! Elements, 2001. The relative atomic masses of the isotopes data
   ! were published by G.  Audi, A.H. Wapstra, and C. Thibault
   ! in The 2003 Atomic Mass Evaluation.  These data have been
   ! compiled from the above sources for the user's convenience and
   ! does not represent a critical evaluation by the NIST Physical
   ! Measurement Laboratory.

   isotope_data :: MAT{REAL}(4,355)

   ! Notes
   ! . Column 1: atomic number
   ! . Column 2: atomic mass number i.e. no of protons and ! neutrons
   ! . Column 3: isotope mass. Negative number means not available.
   ! . Column 4: natural abundance. Negative means most stable form.

   data isotope_data/ &
     0,   1,  1.008664915700d0, -1.00000000d0, & ! neutron mass
     1,   1,  1.007825032070d0,  0.99988500d0, &
     1,   2,  2.014101777800d0,  0.00011500d0, &
     1,   3,  3.016049277700d0,  0.00000000d0, &
     2,   3,  3.016029319100d0,  0.00000134d0, &
     2,   4,  4.002603254150d0,  0.99999866d0, &
     3,   6,  6.015122795000d0,  0.07590000d0, &
     3,   7,  7.016004550000d0,  0.92410000d0, &
     4,   9,  9.012182200000d0,  1.00000000d0, &
     5,  10,  10.01293700000d0,  0.19900000d0, &
     5,  11,  11.00930540000d0,  0.80100000d0, &
     6,  12,  12.00000000000d0,  0.98930000d0, &
     6,  13,  13.00335483780d0,  0.01070000d0, &
     6,  14,  14.00324198900d0,  0.00000000d0, &
     7,  14,  14.00307400480d0,  0.99636000d0, &
     7,  15,  15.00010889820d0,  0.00364000d0, &
     8,  16,  15.99491461956d0,  0.99757000d0, &
     9,  17,  16.99913170000d0,  0.00038000d0, &
     9,  18,  17.99916100000d0,  0.00205000d0, &
     9,  19,  18.99840322000d0,  1.00000000d0, &
    10,  20,  19.99244017540d0,  0.90480000d0, &
    10,  21,  20.99384668000d0,  0.00270000d0, &
    10,  22,  21.99138511400d0,  0.09250000d0, &
    11,  23,  22.98976928090d0,  1.00000000d0, &
    12,  24,  23.98504170000d0,  0.78990000d0, &
    12,  25,  24.98583692000d0,  0.10000000d0, &
    12,  26,  25.98259292900d0,  0.11010000d0, &
    13,  27,  26.98153863000d0,  1.00000000d0, &
    14,  28,  27.97692653250d0,  0.92223000d0, &
    14,  29,  28.97649470000d0,  0.04685000d0, &
    14,  30,  29.97377017000d0,  0.03092000d0, &
    15,  31,  30.97376163000d0,  1.00000000d0, &
    16,  32,  31.97207100000d0,  0.94990000d0, &
    16,  33,  32.97145876000d0,  0.00750000d0, &
    16,  34,  33.96786690000d0,  0.04250000d0, &
    16,  36,  35.96708076000d0,  0.00010000d0, &
    17,  35,  34.96885268000d0,  0.75760000d0, &
    17,  37,  36.96590259000d0,  0.24240000d0, &
    18,  36,  35.96754510600d0,  0.00336500d0, &
    18,  38,  37.96273240000d0,  0.00063200d0, &
    18,  40,  39.96238312250d0,  0.99600300d0, &
    19,  39,  38.96370668000d0,  0.93258100d0, &
    19,  40,  39.96399848000d0,  0.00011700d0, &
    19,  41,  40.96182576000d0,  0.06730200d0, &
    20,  40,  39.96259098000d0,  0.96941000d0, &
    20,  42,  41.95861801000d0,  0.00647000d0, &
    20,  43,  42.95876660000d0,  0.00135000d0, &
    20,  44,  43.95548180000d0,  0.02086000d0, &
    20,  46,  45.95369260000d0,  0.00004000d0, &
    20,  48,  47.95253400000d0,  0.00187000d0, &
    21,  45,  44.95591190000d0,  1.00000000d0, &
    22,  46,  45.95263160000d0,  0.08250000d0, &
    22,  47,  46.95176310000d0,  0.07440000d0, &
    22,  48,  47.94794630000d0,  0.73720000d0, &
    22,  49,  48.94787000000d0,  0.05410000d0, &
    22,  50,  49.94479120000d0,  0.05180000d0, &
    23,  50,  49.94715850000d0,  0.00250000d0, &
    23,  51,  50.94395950000d0,  0.99750000d0, &
    24,  50,  49.94604420000d0,  0.04345000d0, &
    24,  52,  51.94050750000d0,  0.83789000d0, &
    24,  53,  52.94064940000d0,  0.09501000d0, &
    24,  54,  53.93888040000d0,  0.02365000d0, &
    25,  55,  54.93804510000d0,  1.00000000d0, &
    26,  54,  53.93961050000d0,  0.05845000d0, &
    26,  56,  55.93493750000d0,  0.91754000d0, &
    26,  57,  56.93539400000d0,  0.02119000d0, &
    26,  58,  57.93327560000d0,  0.00282000d0, &
    27,  59,  58.93319500000d0,  1.00000000d0, &
    28,  58,  57.93534290000d0,  0.68076900d0, &
    28,  60,  59.93078640000d0,  0.26223100d0, &
    28,  61,  60.93105600000d0,  0.01139900d0, &
    28,  62,  61.92834510000d0,  0.03634500d0, &
    28,  64,  63.92796600000d0,  0.00925600d0, &
    29,  63,  62.92959750000d0,  0.69150000d0, &
    29,  65,  64.92778950000d0,  0.30850000d0, &
    30,  64,  63.92914220000d0,  0.48268000d0, &
    30,  66,  65.92603340000d0,  0.27975000d0, &
    30,  67,  66.92712730000d0,  0.04102000d0, &
    30,  68,  67.92484420000d0,  0.19024000d0, &
    30,  70,  69.92531930000d0,  0.00631000d0, &
    31,  69,  68.92557360000d0,  0.60108000d0, &
    31,  71,  70.92470130000d0,  0.39892000d0, &
    32,  70,  69.92424740000d0,  0.20380000d0, &
    32,  72,  71.92207580000d0,  0.27310000d0, &
    32,  73,  72.92345890000d0,  0.07760000d0, &
    32,  74,  73.92117780000d0,  0.36720000d0, &
    32,  76,  75.92140260000d0,  0.07830000d0, &
    33,  75,  74.92159650000d0,  1.00000000d0, &
    34,  74,  73.92247640000d0,  0.00890000d0, &
    34,  76,  75.91921360000d0,  0.09370000d0, &
    34,  77,  76.91991400000d0,  0.07630000d0, &
    34,  78,  77.91730910000d0,  0.23770000d0, &
    34,  80,  79.91652130000d0,  0.49610000d0, &
    34,  82,  81.91669940000d0,  0.08730000d0, &
    35,  79,  78.91833710000d0,  0.50690000d0, &
    35,  81,  80.91629060000d0,  0.49310000d0, &
    36,  78,  77.92036480000d0,  0.00355000d0, &
    36,  80,  79.91637900000d0,  0.02286000d0, &
    36,  82,  81.91348360000d0,  0.11593000d0, &
    36,  83,  82.91413600000d0,  0.11500000d0, &
    36,  84,  83.91150700000d0,  0.56987000d0, &
    36,  86,  85.91061073000d0,  0.17279000d0, &
    37,  85,  84.91178973800d0,  0.72170000d0, &
    37,  87,  86.90918052700d0,  0.27830000d0, &
    38,  84,  83.91342500000d0,  0.00560000d0, &
    38,  86,  85.90926020000d0,  0.09860000d0, &
    38,  87,  86.90887710000d0,  0.07000000d0, &
    38,  88,  87.90561210000d0,  0.82580000d0, &
    39,  89,  88.90584830000d0,  1.00000000d0, &
    40,  90,  89.90470440000d0,  0.51450000d0, &
    40,  91,  90.90564580000d0,  0.11220000d0, &
    40,  92,  91.90504080000d0,  0.17150000d0, &
    40,  94,  93.90631520000d0,  0.17380000d0, &
    40,  96,  95.90827340000d0,  0.02800000d0, &
    41,  93,  92.90637810000d0,  1.00000000d0, &
    42,  92,  91.90681100000d0,  0.14770000d0, &
    42,  94,  93.90508830000d0,  0.09230000d0, &
    42,  95,  94.90584210000d0,  0.15900000d0, &
    42,  96,  95.90467950000d0,  0.16680000d0, &
    42,  97,  96.90602150000d0,  0.09560000d0, &
    42,  98,  97.90540820000d0,  0.24190000d0, &
    42, 010,  99.90747700000d0,  0.09670000d0, &
    43,  97,  96.90636500000d0,  0.00000000d0, &
    43,  98,  97.90721600000d0,  0.00000000d0, &
    43,  99,  98.90625470000d0, -1.00000000d0, &
    44,  96,  95.90759800000d0,  0.05540000d0, &
    44,  98,  97.90528700000d0,  0.01870000d0, &
    44,  99,  98.90593930000d0,  0.12760000d0, &
    44, 100,  99.90421950000d0,  0.12600000d0, &
    44, 101,  100.9055821000d0,  0.17060000d0, &
    44, 102,  101.9043493000d0,  0.31550000d0, &
    44, 104,  103.9054330000d0,  0.18620000d0, &
    45, 103,  102.9055040000d0,  1.00000000d0, &
    46, 102,  101.9056090000d0,  0.01020000d0, &
    46, 104,  103.9040360000d0,  0.11140000d0, &
    46, 105,  104.9050850000d0,  0.22330000d0, &
    46, 106,  105.9034860000d0,  0.27330000d0, &
    46, 108,  107.9038920000d0,  0.26460000d0, &
    46, 110,  109.9051530000d0,  0.11720000d0, &
    47, 107,  106.9050970000d0,  0.51839000d0, &
    47, 109,  108.9047520000d0,  0.48161000d0, &
    48, 106,  105.9064590000d0,  0.01250000d0, &
    48, 108,  107.9041840000d0,  0.00890000d0, &
    48, 110,  109.9030021000d0,  0.12490000d0, &
    48, 111,  110.9041781000d0,  0.12800000d0, &
    48, 112,  111.9027578000d0,  0.24130000d0, &
    48, 113,  112.9044017000d0,  0.12220000d0, &
    48, 114,  113.9033585000d0,  0.28730000d0, &
    48, 116,  115.9047560000d0,  0.07490000d0, &
    49, 113,  112.9040580000d0,  0.04290000d0, &
    49, 115,  114.9038780000d0,  0.95710000d0, &
    50, 112,  111.9048180000d0,  0.00970000d0, &
    50, 114,  113.9027790000d0,  0.00660000d0, &
    50, 115,  114.9033420000d0,  0.00340000d0, &
    50, 116,  115.9017410000d0,  0.14540000d0, &
    50, 117,  116.9029520000d0,  0.07680000d0, &
    50, 118,  117.9016030000d0,  0.24220000d0, &
    50, 119,  118.9033080000d0,  0.08590000d0, &
    50, 120,  119.9021947000d0,  0.32580000d0, &
    50, 122,  121.9034390000d0,  0.04630000d0, &
    50, 124,  123.9052739000d0,  0.05790000d0, &
    51, 121,  120.9038157000d0,  0.57210000d0, &
    51, 123,  122.9042140000d0,  0.42790000d0, &
    52, 120,  119.9040200000d0,  0.00090000d0, &
    52, 122,  121.9030439000d0,  0.02550000d0, &
    52, 123,  122.9042700000d0,  0.00890000d0, &
    52, 124,  123.9028179000d0,  0.04740000d0, &
    52, 125,  124.9044307000d0,  0.07070000d0, &
    52, 126,  125.9033117000d0,  0.18840000d0, &
    52, 128,  127.9044631000d0,  0.31740000d0, &
    52, 130,  129.9062244000d0,  0.34080000d0, &
    53, 127,  126.9044730000d0,  1.00000000d0, &
    54, 124,  123.9058930000d0,  0.00095200d0, &
    54, 126,  125.9042740000d0,  0.00089000d0, &
    54, 128,  127.9035313000d0,  0.01910200d0, &
    54, 129,  128.9047794000d0,  0.26400600d0, &
    54, 130,  129.9035080000d0,  0.04071000d0, &
    54, 131,  130.9050824000d0,  0.21232400d0, &
    54, 132,  131.9041535000d0,  0.26908600d0, &
    54, 134,  133.9053945000d0,  0.10435700d0, &
    54, 136,  135.9072190000d0,  0.08857300d0, &
    55, 133,  132.9054519330d0,  1.00000000d0, &
    56, 130,  129.9063208000d0,  0.00106000d0, &
    56, 132,  131.9050613000d0,  0.00101000d0, &
    56, 134,  133.9045084000d0,  0.02417000d0, &
    56, 135,  134.9056886000d0,  0.06592000d0, &
    56, 136,  135.9045759000d0,  0.07854000d0, &
    56, 137,  136.9058274000d0,  0.11232000d0, &
    56, 138,  137.9052472000d0,  0.71698000d0, &
    57, 138,  137.9071120000d0,  0.00090000d0, &
    57, 139,  138.9063533000d0,  0.99910000d0, &
    58, 136,  135.9071720000d0,  0.00185000d0, &
    58, 138,  137.9059910000d0,  0.00251000d0, &
    58, 140,  139.9054387000d0,  0.88450000d0, &
    58, 142,  141.9092440000d0,  0.11114000d0, &
    59, 141,  140.9076528000d0,  1.00000000d0, &
    60, 142,  141.9077233000d0,  0.27200000d0, &
    60, 143,  142.9098143000d0,  0.12200000d0, &
    60, 144,  143.9100873000d0,  0.23800000d0, &
    60, 145,  144.9125736000d0,  0.08300000d0, &
    60, 146,  145.9131169000d0,  0.17200000d0, &
    60, 148,  147.9168930000d0,  0.05700000d0, &
    60, 150,  149.9208910000d0,  0.05600000d0, &
    61, 145,  144.9127490000d0, -1.00000000d0, &
    61, 147,  146.9151385000d0,  0.00000000d0, &
    62, 144,  143.9119990000d0,  0.03070000d0, &
    62, 147,  146.9148979000d0,  0.14990000d0, &
    62, 148,  147.9148227000d0,  0.11240000d0, &
    62, 149,  148.9171847000d0,  0.13820000d0, &
    62, 150,  149.9172755000d0,  0.07380000d0, &
    62, 152,  151.9197324000d0,  0.26750000d0, &
    62, 154,  153.9222093000d0,  0.22750000d0, &
    63, 151,  150.9198502000d0,  0.47810000d0, &
    63, 153,  152.9212303000d0,  0.52190000d0, &
    64, 152,  151.9197910000d0,  0.00200000d0, &
    64, 154,  153.9208656000d0,  0.02180000d0, &
    64, 155,  154.9226220000d0,  0.14800000d0, &
    64, 156,  155.9221227000d0,  0.20470000d0, &
    64, 157,  156.9239601000d0,  0.15650000d0, &
    64, 158,  157.9241039000d0,  0.24840000d0, &
    64, 160,  159.9270541000d0,  0.21860000d0, &
    65, 159,  158.9253468000d0,  1.00000000d0, &
    66, 156,  155.9242830000d0,  0.00056000d0, &
    66, 158,  157.9244090000d0,  0.00095000d0, &
    66, 160,  159.9251975000d0,  0.02329000d0, &
    66, 161,  160.9269334000d0,  0.18889000d0, &
    66, 162,  161.9267984000d0,  0.25475000d0, &
    66, 163,  162.9287312000d0,  0.24896000d0, &
    66, 164,  163.9291748000d0,  0.28260000d0, &
    67, 165,  164.9303221000d0,  1.00000000d0, &
    68, 162,  161.9287780000d0,  0.00139000d0, &
    68, 164,  163.9292000000d0,  0.01601000d0, &
    68, 166,  165.9302931000d0,  0.33503000d0, &
    68, 167,  166.9320482000d0,  0.22869000d0, &
    68, 168,  167.9323702000d0,  0.26978000d0, &
    68, 170,  169.9354643000d0,  0.14910000d0, &
    69, 169,  168.9342133000d0,  1.00000000d0, &
    70, 168,  167.9338970000d0,  0.00130000d0, &
    70, 170,  169.9347618000d0,  0.03040000d0, &
    70, 171,  170.9363258000d0,  0.14280000d0, &
    70, 172,  171.9363815000d0,  0.21830000d0, &
    70, 173,  172.9382108000d0,  0.16130000d0, &
    70, 174,  173.9388621000d0,  0.31830000d0, &
    70, 176,  175.9425717000d0,  0.12760000d0, &
    71, 175,  174.9407718000d0,  0.97410000d0, &
    71, 176,  175.9426863000d0,  0.02590000d0, &
    72, 174,  173.9400460000d0,  0.00160000d0, &
    72, 176,  175.9414086000d0,  0.05260000d0, &
    72, 177,  176.9432207000d0,  0.18600000d0, &
    72, 178,  177.9436988000d0,  0.27280000d0, &
    72, 179,  178.9458161000d0,  0.13620000d0, &
    72, 180,  179.9465500000d0,  0.35080000d0, &
    73, 180,  179.9474648000d0,  0.00012000d0, &
    73, 181,  180.9479958000d0,  0.99988000d0, &
    74, 180,  179.9467040000d0,  0.00120000d0, &
    74, 182,  181.9482042000d0,  0.26500000d0, &
    74, 183,  182.9502230000d0,  0.14310000d0, &
    74, 184,  183.9509312000d0,  0.30640000d0, &
    74, 186,  185.9543641000d0,  0.28430000d0, &
    75, 185,  184.9529550000d0,  0.37400000d0, &
    75, 187,  186.9557531000d0,  0.62600000d0, &
    76, 184,  183.9524891000d0,  0.00020000d0, &
    76, 186,  185.9538382000d0,  0.01590000d0, &
    76, 187,  186.9557505000d0,  0.01960000d0, &
    76, 188,  187.9558382000d0,  0.13240000d0, &
    76, 189,  188.9581475000d0,  0.16150000d0, &
    76, 190,  189.9584470000d0,  0.26260000d0, &
    76, 192,  191.9614807000d0,  0.40780000d0, &
    77, 191,  190.9605940000d0,  0.37300000d0, &
    77, 193,  192.9629264000d0,  0.62700000d0, &
    78, 190,  189.9599320000d0,  0.00014000d0, &
    78, 192,  191.9610380000d0,  0.00782000d0, &
    78, 194,  193.9626803000d0,  0.32967000d0, &
    78, 195,  194.9647911000d0,  0.33832000d0, &
    78, 196,  195.9649515000d0,  0.25242000d0, &
    78, 198,  197.9678930000d0,  0.07163000d0, &
    79, 197,  196.9665687000d0,  1.00000000d0, &
    80, 196,  195.9658330000d0,  0.00150000d0, &
    80, 198,  197.9667690000d0,  0.09970000d0, &
    80, 199,  198.9682799000d0,  0.16870000d0, &
    80, 200,  199.9683260000d0,  0.23100000d0, &
    80, 201,  200.9703023000d0,  0.13180000d0, &
    80, 202,  201.9706430000d0,  0.29860000d0, &
    80, 204,  203.9734939000d0,  0.06870000d0, &
    81, 203,  202.9723442000d0,  0.29520000d0, &
    81, 205,  204.9744275000d0,  0.70480000d0, &
    82, 204,  203.9730436000d0,  0.01400000d0, &
    82, 206,  205.9744653000d0,  0.24100000d0, &
    82, 207,  206.9758969000d0,  0.22100000d0, &
    82, 208,  207.9766521000d0,  0.52400000d0, &
    83, 209,  208.9803987000d0,  1.00000000d0, &
    84, 209,  208.9824304000d0,  0.00000000d0, &
    84, 210,  209.9828737000d0, -1.00000000d0, &
    85, 210,  209.9871480000d0, -1.00000000d0, &
    85, 211,  210.9874963000d0,  0.00000000d0, &
    86, 211,  210.9906010000d0,  0.00000000d0, &
    86, 220,  220.0113940000d0,  0.00000000d0, &
    86, 222,  222.0175777000d0,  0.00000000d0, &
    87, 223,  223.0197359000d0,  0.00000000d0, &
    88, 223,  223.0185022000d0,  0.00000000d0, &
    88, 224,  224.0202118000d0,  0.00000000d0, &
    88, 226,  226.0254098000d0, -1.00000000d0, &
    88, 228,  228.0310703000d0,  0.00000000d0, &
    89, 227,  227.0277521000d0, -1.00000000d0, &
    90, 230,  230.0331338000d0,  0.00000000d0, &
    90, 232,  232.0380553000d0,  1.00000000d0, &
    91, 231,  231.0358840000d0,  1.00000000d0, &
    92, 233,  233.0396352000d0,  0.00000000d0, &
    92, 234,  234.0409521000d0,  0.00005400d0, &
    92, 235,  235.0439299000d0,  0.00720400d0, &
    92, 236,  236.0455680000d0,  0.00000000d0, &
    92, 238,  238.0507882000d0,  0.99274200d0, &
    93, 236,  236.0465700000d0,  0.00000000d0, &
    93, 237,  237.0481734000d0, -1.00000000d0, &
    94, 238,  238.0495599000d0,  0.00000000d0, &
    94, 239,  239.0521634000d0,  0.00000000d0, &
    94, 240,  240.0538135000d0,  0.00000000d0, &
    94, 241,  241.0568515000d0,  0.00000000d0, &
    94, 242,  242.0587426000d0,  0.00000000d0, &
    94, 244,  244.0642040000d0, -1.00000000d0, &
    95, 241,  241.0568291000d0,  0.00000000d0, &
    95, 243,  243.0613811000d0, -1.00000000d0, &
    96, 243,  243.0613891000d0,  0.00000000d0, &
    96, 244,  244.0627526000d0,  0.00000000d0, &
    96, 245,  245.0654912000d0,  0.00000000d0, &
    96, 246,  246.0672237000d0,  0.00000000d0, &
    96, 247,  247.0703540000d0, -1.00000000d0, &
    96, 248,  248.0723490000d0,  0.00000000d0, &
    97, 247,  247.0703070000d0, -1.00000000d0, &
    97, 249,  249.0749867000d0,  0.00000000d0, &
    98, 249,  249.0748535000d0,  0.00000000d0, &
    98, 250,  250.0764061000d0,  0.00000000d0, &
    98, 251,  251.0795870000d0, -1.00000000d0, &
    98, 252,  252.0816260000d0,  0.00000000d0, &
    99, 252,  252.0829800000d0, -1.00000000d0, &
   100, 257,  257.0951050000d0, -1.00000000d0, &
   101, 258,  258.0984310000d0, -1.00000000d0, &
   101, 260,  260.1036500000d0,  0.00000000d0, &
   102, 259,  259.1010300000d0, -1.00000000d0, &
   103, 262,  262.1096300000d0, -1.00000000d0, &
   104, 265,  265.1167000000d0, -1.00000000d0, &
   105, 268,  268.1254500000d0, -1.00000000d0, &
   106, 271,  271.1334700000d0, -1.00000000d0, &
   107, 272,  272.1380300000d0, -1.00000000d0, &
   108, 270,  270.1346500000d0, -1.00000000d0, &
   109, 276,  276.1511600000d0, -1.00000000d0, &
   110, 281,  281.1620600000d0, -1.00000000d0, &
   111, 280,  280.1644700000d0, -1.00000000d0, &
   112, 285,  285.1741100000d0, -1.00000000d0, &
   113, 284,  284.1780800000d0, -1.00000000d0, &
   114, 289,  289.1872800000d0, -1.00000000d0, &
   115, 288,  288.1924900000d0, -1.00000000d0, &
   116, 293, -293.0000000000d0, -1.00000000d0, &
   117, 292,  292.2075500000d0, -1.00000000d0, &
   118, 294, -294.0000000000d0, -1.00000000d0  /

   saved_self :: ATOM*, private  DEFAULT_NULL

contains

!  ==================
!  Allocation methods
!  ==================

   create ::: get_from(OBJECT), leaky, PURE
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Destroy an object
   end

   nullify_ptr_part ::: PURE
   ! Nullify the pointer parts of the atom
   ! WARNING: all of these are usually pointer assigned in MOLECULE
   ! when defining the (spherically averaged) atomic natural orbitals.
   ! Therefore, the appropriate MOLECULE destructor should be called
   ! before using this routine.
      self :: INOUT

      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      nullify(.pADP_vector)
      nullify(.pADP_errors)

      nullify(.atomic_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)
      nullify(.NAOs)
      nullify(.NAO_occupations)

      .kind = 0
      .ANOs_made                = FALSE
      .NAOs_made                = FALSE
      .spherical_atom_data_made = FALSE

      nullify(.interpolator)

      .interpolators_made       = FALSE
      .ANO_interpolators_made   = FALSE

      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.precomputed_basis_shellpair)

      .shell_info_made          = FALSE

   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of an atom
   ! WARNING: take care using this, you may need
   ! a unique-atom or all-atom destruction for the
   ! different pointer parts depending on how they
   ! were created.
      self :: INOUT

      ! Never destroy these ... they are always
      ! resolved outside the atom object.
      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      ! WARNING: this may not be correct
      ! The destroy should be done outside of this module
      if (.kind==0 OR .is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy

         .interpolator.destroy

         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

      else

         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)

         nullify(.interpolator)

         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

      end

      ! Destroy NAOs - can always do this
      .destroy_NAOs

      ! Do always destroy these
      .pADP_vector.destroy
      .pADP_errors.destroy

   end

   destroy_NAOs ::: leaky, PURE
   ! Destroy the NAO pointer parts
      self :: INOUT

      if (NOT .NAOs_made) return

      .NAOs.destroy
      .NAO_occupations.destroy

      .NAOs_made = FALSE

   end

   destroy_ANOs ::: leaky, PURE
   ! Destroy the (unique-atom) ANO pointer parts
   ! (and related info)
      self :: INOUT

   ENSURE(.ANOs_made EQV .kind/=0,"The kind has not been set")

      if (NOT .ANOs_made) return

      if (.is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy

      else

         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)

      end

      .ANOs_made = FALSE

   end

   destroy_ANO_interpolators ::: leaky, PURE
   ! Destroy the (unique-atom) ANO interpolators
      self :: INOUT

   ENSURE(.ANO_interpolators_made EQV .kind/=0,"The kind has not been set")

      if (NOT .ANO_interpolators_made) return

      if (.is_unique_kind) then; .interpolator.destroy
      else;                      nullify(.interpolator)
      end

      .ANO_interpolators_made = FALSE

   end

   destroy_spherical_atom_data ::: leaky, PURE
   ! Destroy the (non-unique) ANO pointer parts
      self :: INOUT

      if (NOT .spherical_atom_data_made) return

      .atomic_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy

      .interpolator.destroy

      .spherical_atom_data_made = FALSE

   end

   destroy_interpolators ::: leaky, PURE
   ! Destroy the (non-unique) interpolators
      self :: INOUT

      if (NOT .interpolators_made) return

      .interpolator.destroy

      .interpolators_made = FALSE

   end

   destroy_shell_info ::: leaky, PURE
   ! Destroy the (unique-atom) shell info
      self :: INOUT

   ENSURE(.shell_info_made EQV .kind/=0,"The kind has not been set")

      if (NOT .shell_info_made) return

      if (.is_unique_kind) then

         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

      else

         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

      end

      .shell_info_made = FALSE

   end

!  ====
!  Copy
!  ====

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(atom) ::: leaky
   ! Make self to be a copy of atom.
   ! WARNING: This method only nullifies pointer parts. It is your
   ! responsibility to destroy pointer parts (if you want to) before
   ! calling this method.
      atom :: ATOM, IN

      self = atom

      .nullify_ptr_part

      ! Copy the pADP data
      if (atom.pADP_vector.associated)     .pADP_vector.create_copy(atom.pADP_vector)
      if (atom.pADP_errors.associated)     .pADP_errors.create_copy(atom.pADP_errors)

      ! Re-assign bases
      if (atom.basis.associated)           .basis        => atom.basis
      if (atom.slaterbasis.associated)     .slaterbasis  => atom.slaterbasis
      if (atom.coppensbasis.associated)    .coppensbasis => atom.coppensbasis

      ! Re-assign unique-atom ANO data
      .copy_ANOs(atom)
      .copy_ANO_interpolators(atom)
      .copy_shell_info(atom)

      ! Re-assign unique-atom ANO data
      .copy_spherical_atom_data(atom)
      .copy_interpolators(atom)

      ! Always safely copy NAOs
      .copy_NAOs(atom)

      ! Set kind via VEC{ATOM}:update?
      ! Do it yourself if you want to
    ! .kind = 0

   end

   copy_NAOs(atom) ::: leaky
   ! Copy the NAO pointer parts (and related info)
      atom :: ATOM, IN

      if (NOT atom.NAOs_made) return

      .NAOs.create_copy(atom.NAOs)
      .NAO_occupations.create_copy(atom.NAO_occupations)

      .NAOs_made = TRUE

   end

   copy_ANOs(atom) ::: leaky
   ! Copy the (unique-atom) ANO pointer parts (and related info)
      atom :: ATOM, IN

      if (NOT atom.ANOs_made) return

      if (.kind==0 OR .is_unique_kind) then

         .atomic_orbitals.create_copy(atom.atomic_orbitals)
         .density_matrix.create_copy(atom.density_matrix)
         .natural_orbitals.create_copy(atom.natural_orbitals)
         .occupation_numbers.create_copy(atom.occupation_numbers)

      else

         .atomic_orbitals    => atom.atomic_orbitals
         .density_matrix     => atom.density_matrix
         .natural_orbitals   => atom.natural_orbitals
         .occupation_numbers => atom.occupation_numbers

      end

      ! Kinds may not be sequential
      .ANOs_made = TRUE

   end

   copy_ANO_interpolators(atom) ::: leaky
   ! Copy the (unique-atom) ANO interpolators
      atom :: ATOM, IN

      if (NOT atom.ANO_interpolators_made) return

      if (.kind==0 OR .is_unique_kind) then

         .interpolator.destroy
         .interpolator.create_copy(atom.interpolator)

      else

         nullify(.interpolator)
         .interpolator => atom.interpolator

      end

      ! Kinds may not be sequential
      .ANO_interpolators_made = TRUE

   end

   copy_shell_info(atom) ::: leaky
   ! Destroy the (unique-atom) shell info
      atom :: ATOM, IN

      if (NOT atom.shell_info_made) return

      if (.kind==0 OR .is_unique_kind) then

         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

         .first_basis_fn_for_shell.create_copy(atom.first_basis_fn_for_shell)
         .last_basis_fn_for_shell.create_copy(atom.last_basis_fn_for_shell)
         .precomputed_basis_shellpair.create_copy(atom.precomputed_basis_shellpair)

      else

         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

         .first_basis_fn_for_shell    => atom.first_basis_fn_for_shell
         .last_basis_fn_for_shell     => atom.last_basis_fn_for_shell
         .precomputed_basis_shellpair => atom.precomputed_basis_shellpair

      end

      ! Kinds may not be sequential
      .shell_info_made = TRUE

   end

   copy_spherical_atom_data(atom) ::: leaky
   ! Copy the (non-unique) ANO pointer parts
      atom :: ATOM, IN

      if (NOT atom.spherical_atom_data_made) return

      .atomic_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy

      .atomic_orbitals.create_copy(atom.atomic_orbitals)
      .density_matrix.create_copy(atom.density_matrix)
      .natural_orbitals.create_copy(atom.natural_orbitals)
      .occupation_numbers.create_copy(atom.occupation_numbers)

      .interpolator.destroy
      .interpolator.create_copy(atom.interpolator)

      ! Kinds may not be sequential
      .spherical_atom_data_made = TRUE

   end

   copy_interpolators(atom) ::: leaky
   ! Destroy the (non-unique) interpolators
      atom :: ATOM

      if (NOT atom.interpolators_made) return

      .interpolator.destroy
      .interpolator.create_copy(atom.interpolator)

      ! Kinds may not be sequential
      .interpolators_made = TRUE

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky, PURE
   ! Set a default atom
      self :: INOUT

      .label                    = "?"
      .tag                      = " "
                                
      .atomic_number            = 0
      .nuclear_charge           = ZERO
      .oxidation_state          = 0
                                
      .mass_number              = 0
      .mass                     = ZERO

      ! Leaky
      .set_position([ ZERO,ZERO,ZERO ])
      .set_position_error([ ZERO,ZERO,ZERO ])

      .group                    = 0
                                
      .site_occupancy           = ONE
      .site_disorder_group      = 0
                                
      ! ADP                     
      .U_iso                    = ZERO
      .U_iso_error              = ZERO
      .set_ADP_tensor(ZERO)     
      .pos_axis_system          = "cartesian"
      .ADP_axis_system          = "cartesian"
      .ADPn_axis_system         = "cartesian"
                                
      ! Charges                 
      .charge                   = ZERO
      .dipole                   = ZERO
      .quadrupole               = ZERO
      .spin                     = ZERO
      .spin_dipole              = ZERO
      .spin_quadrupole          = ZERO
      .charge_polarisability    = ZERO
      .dipole_polarisability    = ZERO

      ! Basis
      .basis_label              = " "
      .basis_kind               = " "
      .slaterbasis_label        = " "
      .coppensbasis_label       = " "
      .kind                     = 0
      .is_unique_kind           = FALSE

      ! ANO
      .energy                   = ZERO
      .ANOs_made                = FALSE
      .spherical_atom_data_made = FALSE
      .NAOs_made                = FALSE

      ! Interpolator
      .use_interpolator         = TRUE
      .ANO_interpolators_made   = FALSE
      .interpolators_made       = FALSE

      ! IAM SF's
      .use_IAM_ITC_FFs        = TRUE

      .shell_info_made = FALSE

      ! Protien defaults
      .invariom_label          = " "
      .protein_strand          = 0
      .residue_atom_code       = " "
      .residue_code            = " "
      .residue_sequence_number = 0

      ! MM
      .mm_forcefield_name         = " "
      .mm_atom_type               = " "
      .mm_charge                  = ZERO
      .restraining_position       = [ ZERO,ZERO,ZERO ]
      .restraining_force_constant = ZERO

   end

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self. This version has self a target.
   end

!  ============================
!  Set labels, dummies, charges
!  ============================

   set_atom_data_from_label(label)
   ! Set the atom data such as its label, atomic_number, mass_number,
   ! nuclear_charge and atomic mass.
      self :: INOUT
      label :: STR

      Z :: INT

      if (label.is_int) then

         ! Integer label must be the atomic number
         Z = label.to_int
         .set_atomic_number(Z)

      else if (label(1:2)==ATOM_DUMMY_CHARGE_INPUT_SYMBOL) then

         ! This is a dummy charge, e.g Q:-0.3
         .set_dummy_charge(label)

      else

         .set_label(label)

      end

   end

   set_label(label) ::: private
   ! Set the atom "label" and related variables
      self :: INOUT
      label :: STR

   DIE_IF(NOT label(1:1).is_alphabetical,"unacceptable atom symbol: "// trim(label))

      chemical_symbol :: STR(len=2)

      ! Set the tag - may not be unique
      .tag   = label
      .label = label

      ! Set atomic number and mass from symbol
      chemical_symbol = ATOM:element_symbol_from_label(label)
      .set_mass(chemical_symbol)

   end

   element_symbol_from_label(label) result (symbol) ::: selfless, private
   ! Return a normalised element symbol from an atom "label"
      label :: STR, IN
      symbol :: STR(len=2)

   DIE_IF(NOT label(1:1).is_alphabetical,"unacceptable atom symbol: "// trim(label))

      lensym :: INT

      ! Label ends on nonalphabetical character
      lensym = label.index_of_nonalphabetical - 1

      ! Check label is no more than two character long
      DIE_IF(lensym>2,"unacceptable atom symbol: "// trim(label(1:lensym)))

      ! lensym could be negative -- if no nonalphabetical chars!
      if (lensym<0) lensym = len_trim(label)

      ! Recheck label is no more than two character long
      DIE_IF(lensym>2,"unacceptable atom symbol: "// trim(label(1:lensym)))

      ! Get chemical symbol
      symbol = label(1:lensym)
      symbol(1:1).to_upper_case
      if (lensym>1 AND symbol(2:2).is_upper_case) symbol(2:2).to_lower_case

   end

   set_mass(chemical_symbol) ::: private
   ! Set the atomic mass from the .label and .mass_number
      self :: INOUT
      chemical_symbol :: STR, optional, IN

   ENSURE(.label/="?" AND .label/=" ","label not set")

      symbol :: STR
      Z :: INT

      if (present(chemical_symbol)) then; symbol = chemical_symbol
      else;                               symbol = .label
      end

      ! Assign atomic number from symbol
      select case (symbol(1:2))

      case ("El")
         ! An electron
         .atomic_number  = -1
         .nuclear_charge = -ONE
         ! Mass of electron in C12 mass units
         .mass           = MASS_OF_ELECTRON_SI/AMU_SI

      case("D")
         ! Dueterium
         .atomic_number  = 1
         .mass_number    = 2
         .nuclear_charge = ONE
         .mass           = ::mass_of_isotope(Z=1,A=2)

      case("T")
         ! This is dueterium/tritium
         .atomic_number  = 1
         .mass_number    = 2
         .nuclear_charge = ONE
         .mass           = ::mass_of_isotope(Z=1,A=3)

      case default
         ! Regular element
         Z = element_symbols(1:).index_of(symbol(1:2))
         DIE_IF(Z==0,"unknown element symbol: "//trim(symbol))
         .atomic_number  = Z
         .nuclear_charge = Z*ONE
         .mass           = ATOM::mass(self)

      end

   end

   set_dummy_charge(label)
   ! Set a dummy charge (integer) and related variables
      label :: STR
   DIE_IF(label(1:2)/=ATOM_DUMMY_CHARGE_INPUT_SYMBOL,"invalid q-charge label: "//trim(label(1:2)))
   DIE_IF(NOT label(3:).is_real,"invalid q-charge: "//trim(label(3:)))

      .label          = ATOM_DUMMY_CHARGE_LABEL
      .atomic_number  = 0
      .nuclear_charge = label(3:).to_real ! extract the charge

   end

   set_atomic_number(val)
   ! Set the atomic number (integer) and related variables
      val :: INT

   ENSURE(val>0 OR val<119,"unknown atomic number: "//trim(val.to_str))

      .atomic_number  = val
      .nuclear_charge = val
      .label          = .chemical_symbol

      .set_mass

   end

   set_n_core_electrons(val) ::: PURE
   ! Set the number of core electronbs in the case ECPs are used.
   ! For gaussian only so far.
      self :: INOUT
      val :: INT, IN

   ENSURE(val>0 OR val<119,"val out of range: "//trim(val.to_str))

      .n_core_electrons = val

   end

   set_mass_number(val)
   ! Set the atomic mass number. If the mass number is zero the
   ! atom is assumed to have an abunfance weighted mass, otherwise
   ! its mass is worked out from the isotope table
      self :: INOUT
      val :: INT

   DIE_IF(val<=0 OR val>118,"unknown atomic number: "//trim(val.to_str))
   DIE_IF(.atomic_number==0,"set mass number *after* atomic number")

      .mass_number = val
      .mass        = ATOM::mass(self)

   end

   set_nuclear_charge(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.nuclear_charge)
   ! Generic set
   end

   set_oxidation_state(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.oxidation_state)
   ! Generic set
   end

!  =============
!  Set positions
!  =============

   set_position(val) ::: leaky, PURE
   ! Set positions. Also set the pADP_vector.
   ! NOTE: Do you need to set the axis system too?
      self :: INOUT
      val :: VEC{REAL}(3), IN

      .position = val

      if (.pADP_vector.disassociated) then
         .pADP_vector.create(9)
         .pADP_vector(1:9) = ZERO
      end

      .pADP_vector(1:3) = val

   end

   set_position_error(val) ::: leaky, PURE
   ! Set position error. Also set the pADP_error.
   ! NOTE: Do you need to set the axis system too?
      self :: INOUT
      val :: VEC{REAL}(3), IN

   ENSURE(.pADP_vector.associated,"pADP_vector destroyed")

      .position_error = val

      if (.pADP_errors.disassociated) then
         .pADP_errors.create(9)
         .pADP_errors(1:9) = ZERO
      end

      .pADP_errors(1:3) = val

   end

   check_position_and_pADP
   ! Check if the .position and .pADP vector are consistent
      self :: IN

      if (.pADP_vector.associated) then
         DIE_IF(NOT .pADP_vector(1:3).equals(.position),"pADP_vector /= position")
      end

   end

!  ========
!  Set ADPs
!  ========

   set_U_iso(val) ::: pure
   ! Set U_iso only
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      val :: REAL, IN

      .U_iso = val

   end

   set_U_iso_error(err) ::: pure
   ! Set U_iso error
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      err :: REAL, IN

      .U_iso_error = err

   end

   set_ADP_tensor(val) ::: PURE
   ! Set the ADP tensor.  Also set the pADP_vector
   ! NOTE: pADP_vector is created when position is set.
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      val :: REAL, IN

   ENSURE(.pADP_vector.associated,"pADP_vector destroyed")

      .ADP_tensor = val

      .pADP_vector(4:9) = val
      
      ! Set U_iso
      if (.ADP_axis_system=="cartesian") then
         .set_U_iso(THIRD*val)
      end

   end

   set_ADP_tensor(mx) ::: PURE
   ! Set the ADP tensor.  Also set the pADP_vector.
   ! NOTE: pADP_vector is created when position is set.
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      mx :: MAT{REAL}(3,3), IN

   ENSURE(.pADP_vector.associated,"pADP_vector destroyed")

      tmp :: REAL

      ! Set tensor
      .ADP_tensor = mx

      ! Set pADP
      .pADP_vector(4) = mx(1,1)
      .pADP_vector(5) = mx(2,2)
      .pADP_vector(6) = mx(3,3)
      .pADP_vector(7) = mx(1,2)
      .pADP_vector(8) = mx(1,3)
      .pADP_vector(9) = mx(2,3)
      
      ! Set U_iso
      if (.ADP_axis_system=="cartesian") then
         tmp = THIRD*sum(.pADP_vector(4:6))
         .set_U_iso(tmp)
      end

   end

   set_ADP_tensor(vec) ::: PURE
   ! Set from vector in the order xx, yy, zz, xy, xz, yz.
   ! Also set the pADP_vector if created.
   ! NOTE: pADP_vector is created when position is set.
   ! NOTE: Do you need to set the .ADP_axis_system too?
      self :: INOUT
      vec :: VEC{REAL}, IN

   ENSURE(vec.dim==6,"val: wrong size")

      ADP :: MAT{REAL}(3,3)

      ! Transfer
      ADP(1,1) = vec(1)
      ADP(2,2) = vec(2)
      ADP(3,3) = vec(3)
      ADP(1,2) = vec(4)
      ADP(2,1) = vec(4)
      ADP(1,3) = vec(5)
      ADP(3,1) = vec(5)
      ADP(2,3) = vec(6)
      ADP(3,2) = vec(6)

      ! Set *all* ADP parameters
      .set_ADP_tensor(ADP)

   end

!  ===============
!  Set axis system
!  ===============

   set_axis_system_to(word) ::: PURE
   ! Set the axis system type to "word".
   ! Currently allowed is: "cartesian" or "crystal".
      self :: INOUT
      word :: STR, IN

   ENSURE(word.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      .set_pos_axis_system_to(word)
      .set_ADP_axis_system_to(word)
      .set_ADPn_axis_system_to(word)

   end

   set_pos_axis_system_to(word) ::: PURE
   ! Set the position axis system type to "word".
   ! Currently allowed is: "cartesian" or "crystal".
   ! NOTE: all .ADP_axis_system's are changed too.
      self :: INOUT
      word :: STR, IN

   ENSURE(word.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      .pos_axis_system = word

   end

   set_ADP_axis_system_to(word) ::: PURE
   ! Set **all** the ADP axis systems to "word".
   ! Currently allowed, is: "cartesian" or "crystal".
      self :: INOUT
      word :: STR, IN

   ENSURE(word.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      .ADP_axis_system  = word

   end

   set_ADPn_axis_system_to(word) ::: PURE
   ! Set the ADPn axis systems to "word".
   ! Currently allowed, is: "cartesian" or "crystal".
      self :: INOUT
      word :: STR, IN

   ENSURE(word.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      .ADPn_axis_system = word

   end

!  =======================================
!  Parameter vector (position/ADP) setting
!  =======================================

! Put tensors

   put_ADP2_vector_to(adp2,fac) ::: PURE
   ! Put the ADP2s into the "adp2" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp2 :: MAT{REAL}(3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.associated,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=9,"pADP_vector too small")

      fac2 :: REAL
      v2   :: VEC{REAL}(6)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_2_to_lower_pyramid(.pADP_vector( 4: 9),v2)

      ! Uncompress lower pyramid -> tensor
      adp2.uncompress_from_pyramid(v2)

      if (present(fac)) then

         fac2 = fac*fac
         adp2 = fac2*adp2

      end

   end

   put_ADP3_vector_to(adp3,fac) ::: PURE
   ! Put the ADP3s into the "adp3" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp3 :: MAT3{REAL}(3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.associated,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      fac3 :: REAL
      v3   :: VEC{REAL}(10)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_3_to_lower_pyramid(.pADP_vector(10:19),v3)

      ! Uncompress lower pyramid -> tensor
      adp3.uncompress_from_pyramid(v3)

      ! Change units
      if (present(fac)) then
         fac3 = fac*fac*fac
         adp3 = fac3*adp3
      end

   end

   put_ADP4_vector_to(adp4,fac) ::: PURE
   ! Put the ADP4s into the "adp4" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp4 :: MAT4{REAL}(3,3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.associated,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=34,"pADP_vector too small")

      fac4 :: REAL
      v4   :: VEC{REAL}(15)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_4_to_lower_pyramid(.pADP_vector(20:34),v4)

      ! Uncompress lower pyramid -> tensor
      adp4.uncompress_from_pyramid(v4)

      ! Change units
      if (present(fac)) then
         fac4 = fac*fac*fac*fac
         adp4 = fac4*adp4
      end

   end

   put_ADP2_errors_to(adp2_errors,fac) ::: PURE
   ! Put the ADP2s into the "adp2" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp2_errors :: MAT{REAL}(3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=9,"pADP_errors too small")

      fac2 :: REAL
      v2   :: VEC{REAL}(6)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_2_to_lower_pyramid(.pADP_errors( 4: 9),v2)

      ! Uncompress lower pyramid -> tensor
      adp2_errors.uncompress_from_pyramid(v2)

      if (present(fac)) then

         fac2 = fac*fac
         adp2_errors = fac2*adp2_errors

      end

   end

   put_ADP3_errors_to(adp3_errors,fac) ::: PURE
   ! Put the ADP3 errors into the "adp3" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp3_errors :: MAT3{REAL}(3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=19,"pADP_errors too small")

      fac3 :: REAL
      v3   :: VEC{REAL}(10)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_3_to_lower_pyramid(.pADP_errors(10:19),v3)

      ! Uncompress lower pyramid -> tensor
      adp3_errors.uncompress_from_pyramid(v3)

      ! Change units
      if (present(fac)) then
         fac3 = fac*fac*fac
         adp3_errors = fac3*adp3_errors
      end

   end

   put_ADP4_errors_to(adp4_errors,fac) ::: PURE
   ! Put the ADP4 errors into the "adp4" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp4_errors :: MAT4{REAL}(3,3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=34,"pADP_errors too small")

      fac4 :: REAL
      v4   :: VEC{REAL}(15)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_4_to_lower_pyramid(.pADP_errors(20:34),v4)

      ! Uncompress lower pyramid -> tensor
      adp4_errors.uncompress_from_pyramid(v4)

      ! Change units
      if (present(fac)) then
         fac4 = fac*fac*fac*fac
         adp4_errors = fac4*adp4_errors
      end

   end

! Reset

   reset_pADPs_and_errors(dim) ::: leaky, PURE
   ! Reset the positional-ADP parameters and errors to size "dim".
   ! NOTE: the pADPs and errors are *expanded*.
      self :: INOUT
      dim  :: INT, IN

      X,dX :: VEC{REAL}*
      n :: INT

      ! Create pADPs, and set to existing pADPs
      if (.pADP_vector.disassociated OR .pADP_errors.disassociated) then

         ! Space for X, dX
         n = .no_of_pADPs
          X.create(n)
         dX.create(n)

         ! Get existing pADPs in X
         ! (From e.g. .position)
         .put_pADP_vector_to(X)
         dX = ZERO

         ! Create pADPs (leaky)
         .pADP_errors.destroy
         .pADP_vector.destroy
         .pADP_vector.create(n)
         .pADP_errors.create(n)

         ! Set the pADPs and errors
         .set_pADP_vector_to(X)
         .set_pADP_errors_to(dX,FALSE)

         ! Clean
         dX.destroy
          X.destroy

      end

      ! Expand if necessary.
      ! New (if any) values to zero.
      if (dim>.pADP_vector.dim) then
         .pADP_vector.resize(dim,init=ZERO)
         .pADP_errors.resize(dim,init=ZERO)
      end

   end

! Set vector

   set_pADP_vector_to(X) ::: PURE
   ! Set the pADP vector from vector "X".
   ! NOTE: Also sets positions and ADP_tensor.
   ! NOTE: "X" musts be correct size.
      self :: INOUT
      X :: VEC{REAL}, IN

   ENSURE(X.dim>=9,"X too small")
   ENSURE(.pADP_vector.associated,"no PADP_vector")
   ENSURE(.pADP_vector.dim==X.dim,"wrong size, X")

      val :: REAL

      ! Set positions
      .position(1) = X(1)
      .position(2) = X(2)
      .position(3) = X(3)

      ! Set ADP tensor
      .ADP_tensor(1,1) = X(4)
      .ADP_tensor(2,2) = X(5)
      .ADP_tensor(3,3) = X(6)
      .ADP_tensor(1,2) = X(7)
      .ADP_tensor(2,1) = X(7)
      .ADP_tensor(1,3) = X(8)
      .ADP_tensor(3,1) = X(8)
      .ADP_tensor(2,3) = X(9)
      .ADP_tensor(3,2) = X(9)

      ! Set. Must be correct size
      .pADP_vector = X
      
      ! Set U_iso
      if (.ADP_axis_system=="cartesian") then
         val = THIRD*sum(X(4:6))
         .set_U_iso(val)
      end

   end

   set_ADP2_vector_to(U) ::: PURE
   ! Set the ADP2s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   ENSURE(.pADP_vector.associated,"no pADPs")
   ENSURE(.pADP_vector.dim>=9,"pADP_vector: wrong size")
   ENSURE(U.dim==6,"wrong size, U")

      val :: REAL

      .pADP_vector( 4: 9) = U( 1: 6)
      
      ! Set U_iso
      if (.ADP_axis_system=="cartesian") then
         val = THIRD*sum(.pADP_vector(4:6))
         .set_U_iso(val)
      end

   end

   set_ADP3_vector_to(U) ::: PURE
   ! Set the ADP3s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   ENSURE(.pADP_vector.associated,"no pADPs")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector: wrong size")
   ENSURE(U.dim==10,"wrong size, U")

      .pADP_vector(10:19) = U( 1:10)

   end

   set_ADP4_vector_to(U) ::: PURE
   ! Set the ADP4s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   ENSURE(.pADP_vector.associated,"no pADPs")
   ENSURE(.pADP_vector.dim>=34,"pADP_vector: wrong size")
   ENSURE(U.dim==15,"wrong size, U")

      .pADP_vector(20:34) = U( 1:15)

   end

! Set tensors

   set_ADP3_vector_to(adp3) ::: PURE
   ! Set the ADP3s from the "adp3" tensor into the pADP_vector.
      self :: INOUT
      adp3 :: MAT3{REAL}(3,3,3), OUT

   ENSURE(.pADP_vector.associated,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      v3,w3 :: VEC{REAL}(10)

      ! Compress tensor -> lower pyramid
      adp3.compress_to_pyramid(v3)

      ! Reorder from lower pyramid -> lexical
      GAUSSIAN_DATA:lower_pyramid_to_lexical_3(v3,w3)

      ! Set it
      .set_ADP3_vector_to(w3)

   end

   set_ADP4_vector_to(adp4) ::: PURE
   ! Set the ADP4s into the "adp3" tensor from the pADP_vector.
      self :: INOUT
      adp4 :: MAT4{REAL}(3,3,3,3), OUT

   ENSURE(.pADP_vector.associated,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      v4,w4 :: VEC{REAL}(15)

      ! Compress tensor -> lower pyramid
      adp4.compress_to_pyramid(v4)

      ! Reorder from lower pyramid -> lexical
      GAUSSIAN_DATA:lower_pyramid_to_lexical_4(v4,w4)

      ! Set it
      .set_ADP4_vector_to(w4)

   end

   set_ADP3_errors_to(adp3) ::: PURE
   ! Set the ADP3 errors from the "adp3" tensor into the pADP_errors.
      self :: INOUT
      adp3 :: MAT3{REAL}(3,3,3), OUT

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=19,"pADP_errors too small")

      v3,w3 :: VEC{REAL}(10)

      ! Compress tensor -> lower pyramid
      adp3.compress_to_pyramid(v3)

      ! Reorder from lower pyramid -> lexical
      GAUSSIAN_DATA:lower_pyramid_to_lexical_3(v3,w3)

      ! Set it
      .set_ADP3_errors_to(w3)

   end

   set_ADP4_errors_to(adp4) ::: PURE
   ! Set the ADP4 errorss into the "adp3" tensor from the pADP_errors.
      self :: INOUT
      adp4 :: MAT4{REAL}(3,3,3,3), OUT

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=19,"pADP_errors too small")

      v4,w4 :: VEC{REAL}(15)

      ! Compress tensor -> lower pyramid
      adp4.compress_to_pyramid(v4)

      ! Reorder from lower pyramid -> lexical
      GAUSSIAN_DATA:lower_pyramid_to_lexical_4(v4,w4)

      ! Set it
      .set_ADP4_errors_to(w4)

   end

! Set errors

   zero_pADP_error ::: PURE
   ! Set position error. Also set the pADP_error.
   ! NOTE: Do you need to set the axis system too?
      self :: INOUT

   ENSURE(.pADP_errors.associated,"pADP_errors destroyed")

      dX :: VEC{REAL}(9)

      dX = ZERO

      .set_pADP_errors_to(dX,FALSE)

   end

   set_pADP_errors_to(dX,H_U_iso) ::: PURE
   ! Set the parameter errors (positions and ADPs) to "dX".
   ! NOTE: The pADP's and errors must be already created
   ! NOTE: "dX" must be correct size.
      self :: INOUT
      dX :: VEC{REAL}, IN
      H_U_iso :: BIN, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim==dX.dim,"wrong size, dX")

      val :: REAL

      .position_error = dX(1:3)
      .pADP_errors    = dX
      
      ! Set U_iso error
      val = sum(.pADP_errors(4:6))
      if (.atomic_number==1 AND H_U_iso) then
         .set_U_iso_error(val)
      else
         val = THIRD*val
         .set_U_iso_error(val)
      end

   end

   set_ADP2_errors_to(dU,H_U_iso) ::: PURE
   ! Set the second-order ADP errors from vector "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN
      H_U_iso :: BIN, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=9,"wrong size, pADP_errors")
   ENSURE(dU.dim==6,"wrong size, dU")

      val :: REAL

      .pADP_errors( 4: 9) = dU( 1: 6)
      
      ! Set U_iso error
      val = sum(.pADP_errors(4:6))
      if (.atomic_number==1 AND H_U_iso) then
         .set_U_iso_error(val) ! This is correct believe it or not
      else
         val = THIRD*val
         .set_U_iso_error(val) ! This is what you expect, normally
      end

   end

   set_ADP2_errors_to(dU,H_U_iso) ::: PURE
   ! Set the second-order ADP errors from vector "dU" *matrix*
      self :: INOUT
      dU :: MAT{REAL}(3,3), IN
      H_U_iso :: BIN, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=9,"wrong size, pADP_errors")

      val :: REAL

      .pADP_errors(4) = dU(1,1)
      .pADP_errors(5) = dU(2,2)
      .pADP_errors(6) = dU(3,3)
      .pADP_errors(7) = dU(1,2)
      .pADP_errors(8) = dU(1,3)
      .pADP_errors(9) = dU(2,3)
      
      ! Set U_iso error
      val = sum(.pADP_errors(4:6))
      if (.atomic_number==1 AND H_U_iso) then
         .set_U_iso_error(val)
      else
         val = THIRD*val
         .set_U_iso_error(val)
      end

   end

   set_ADP3_errors_to(dU) ::: PURE
   ! Set the ADP3 errors from vector "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=19,"wrong size, pADP_errors")
   ENSURE(dU.dim==10,"wrong size, dU")

      .pADP_errors(10:19) = dU( 1:10)

   end

   set_ADP4_errors_to(dU) ::: PURE
   ! Set the ADP4 errors from "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=34,"wrong size, pADP_errors")
   ENSURE(dU.dim==15,"wrong size, dU")

      .pADP_errors(20:34) = dU( 1:15)

   end

! Put vector

   put_pos_vector_to(X,fac) ::: PURE
   ! Put the position vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim>=3,"wrong size, X")

      if (NOT present(fac)) then

         ! In atomic units
         X(1) =      .position(1)
         X(2) =      .position(2)
         X(3) =      .position(3)

      else 
      
         ! Change length units
         X(1) = fac *.position(1)
         X(2) = fac *.position(2)
         X(3) = fac *.position(3)

      end

   end

   put_pADP_vector_to(X,fac) ::: PURE
   ! Put the pADP vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim>=.no_of_pADPs,"wrong size, X")
   ENSURE(.pADP_vector.associated,"no pADP_vector")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1) = .position(1)
         X(2) = .position(2)
         X(3) = .position(3)

         ! Set from ADP_tensor
         X(4) = .ADP_tensor(1,1)
         X(5) = .ADP_tensor(2,2)
         X(6) = .ADP_tensor(3,3)
         X(7) = .ADP_tensor(1,2)
         X(8) = .ADP_tensor(1,3)
         X(9) = .ADP_tensor(2,3)

         if (.pADP_vector.dim>=19) then
         X(10:19) = .pADP_vector(10:19)
         end

         if (.pADP_vector.dim>=34) then
         X(20:34) = .pADP_vector(20:34)
         end

      else ! Change length units

         ! Length scales
         fac2 = fac *fac
         fac3 = fac *fac2
         fac4 = fac *fac3

         ! Set from position
         X(1) = fac *.position(1)
         X(2) = fac *.position(2)
         X(3) = fac *.position(3)

         ! Set from ADP_tensor
         X(4) = fac2*.ADP_tensor(1,1)
         X(5) = fac2*.ADP_tensor(2,2)
         X(6) = fac2*.ADP_tensor(3,3)
         X(7) = fac2*.ADP_tensor(1,2)
         X(8) = fac2*.ADP_tensor(1,3)
         X(9) = fac2*.ADP_tensor(2,3)

         if (.pADP_vector.dim>=19) then
         X(10:19) = fac3*.pADP_vector(10:19)
         end

         if (.pADP_vector.dim>=34) then
         X(20:34) = fac4*.pADP_vector(20:34)
         end

      end

   end

   put_pADP2_vector_to(X,fac) ::: PURE
   ! Put the pADP2 vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(X.dim==9,"wrong size, X")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1) = .position(1)
         X(2) = .position(2)
         X(3) = .position(3)

         ! Set from ADP_tensor
         X(4) = .ADP_tensor(1,1)
         X(5) = .ADP_tensor(2,2)
         X(6) = .ADP_tensor(3,3)
         X(7) = .ADP_tensor(1,2)
         X(8) = .ADP_tensor(1,3)
         X(9) = .ADP_tensor(2,3)

      else ! Change length units

         ! Length scales
         fac2 = fac *fac

         ! Set from position
         X(1) = fac *.position(1)
         X(2) = fac *.position(2)
         X(3) = fac *.position(3)

         ! Set from ADP_tensor
         X(4) = fac2*.ADP_tensor(1,1)
         X(5) = fac2*.ADP_tensor(2,2)
         X(6) = fac2*.ADP_tensor(3,3)
         X(7) = fac2*.ADP_tensor(1,2)
         X(8) = fac2*.ADP_tensor(1,3)
         X(9) = fac2*.ADP_tensor(2,3)

      end

   end

   put_ADP2_vector_to(U,fac) ::: PURE
   ! Put the second-order ADPs into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(U.dim==6,"wrong size, U")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from ADP tensor
         U(1) = .ADP_tensor(1,1)
         U(2) = .ADP_tensor(2,2)
         U(3) = .ADP_tensor(3,3)
         U(4) = .ADP_tensor(1,2)
         U(5) = .ADP_tensor(1,3)
         U(6) = .ADP_tensor(2,3)

      else ! Change length units

         ! Length scales
         fac2 = fac*fac

         ! Set from ADP tensor
         U(1) = fac2*.ADP_tensor(1,1)
         U(2) = fac2*.ADP_tensor(2,2)
         U(3) = fac2*.ADP_tensor(3,3)
         U(4) = fac2*.ADP_tensor(1,2)
         U(5) = fac2*.ADP_tensor(1,3)
         U(6) = fac2*.ADP_tensor(2,3)

      end

   end

   put_ADP3_vector_to(U,fac) ::: PURE
   ! Put the ADP3s into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.associated,"no pADPs")
   ENSURE(.pADP_vector.dim>=19,"no pADP3s")
   ENSURE(U.dim==10,"wrong size, U")

      fac2,fac3 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         U( 1:10) = .pADP_vector(10:19)

      else ! Change length units

         ! Length scales
         fac2 = fac*fac
         fac3 = fac*fac2

         U( 1:10) = fac3*.pADP_vector(10:19)

      end

   end

   put_ADP4_vector_to(U,fac) ::: PURE
   ! Put the ADP4s into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.associated,"no pADPs")
   ENSURE(.pADP_vector.dim>=34,"no pADP3s")
   ENSURE(U.dim==15,"wrong size, U")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         U( 1:15) = .pADP_vector(20:34)

      else ! Change length units

         ! Length scales
         fac2 = fac*fac
         fac3 = fac*fac2
         fac4 = fac*fac3

         U( 1:15) = fac4*.pADP_vector(20:34)

      end

   end

! Put errors

   put_pos_errors_to(dX,fac) ::: PURE
   ! Put the position errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(dX.dim==3,"wrong size, dX")

      dX = ZERO

      ! Return if there are no errors
      if (.pADP_errors.disassociated) return

      ! In atomic units
      if (NOT present(fac)) then

         ! Copy all errors
         dX( 1: 3) =      .pADP_errors( 1: 3)

      else ! Change length units

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)

      end

   end

   put_pADP_errors_to(dX,fac) ::: PURE
   ! Put the pADP errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim==dX.dim,"wrong size, dX")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Copy all errors
         dX = .pADP_errors

      else ! Change length units

         ! Length scales
         fac2 = fac*fac
         fac3 = fac*fac2
         fac4 = fac*fac3

         ! Copy all errors
         dX = fac*.pADP_errors

      end

   end

   put_pADP2_errors_to(dX,fac) ::: PURE
   ! Put the pADP2 errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=9,"wrong size, pADP_errors")
   ENSURE(dX.dim==9,"wrong size, dX")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Copy all errors
         dX( 1: 3) = .pADP_errors( 1: 3)
         dX( 4: 9) = .pADP_errors( 4: 9)

      else ! Change length units

         ! Length scales
         fac2 = fac *fac

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)
         dX( 4: 9) = fac2*.pADP_errors( 4: 9)

      end

   end

   put_ADP2_errors_to(dU,fac) ::: PURE
   ! Put the second-order ADP errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=9,"wrong size, pADP_errors")
   ENSURE(dU.dim==6,"wrong size, dU")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1: 6) = .pADP_errors( 4: 9)

      else ! Change length units

         fac2 = fac*fac

         dU( 1: 6) = fac2*.pADP_errors( 4: 9)

      end


   end

   put_ADP3_errors_to(dU,fac) ::: PURE
   ! Put the ADP3 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=19,"wrong size, pADP_errors")
   ENSURE(dU.dim==10,"wrong size, dU")

      fac2,fac3 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1:10) = .pADP_errors(10:19)

      else ! Change length units

         ! Length scales
         fac2 = fac*fac
         fac3 = fac*fac2

         dU( 1:10) = fac3*.pADP_errors(10:19)

      end


   end

   put_ADP4_errors_to(dU,fac) ::: PURE
   ! Put the ADP4 errors into "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_errors.associated,"no pADP_errors")
   ENSURE(.pADP_errors.dim>=34,"wrong size, pADP_errors")
   ENSURE(dU.dim==15,"wrong size, dU")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1:15) = .pADP_errors(20:34)

      else ! Change length units

         ! Length scales
         fac2 = fac*fac
         fac3 = fac*fac2
         fac4 = fac*fac3

         dU( 1:15) = fac4*.pADP_errors(20:34)

      end


   end

! Put labels

   put_pos_labels_to(lab) ::: selfless, PURE
   ! Set the poisition labels for parameter with
   ! index "par_index"
      lab :: VEC{STR}(3), OUT

      i :: INT

      do i = 1,3
         lab(i) = ::pADP_label(i)
      end

   end

   put_pADP_labels_to(lab) ::: selfless, PURE
   ! Set positional-ADP labels for parameter with index "par_index"
      self :: IN
      lab :: VEC{STR}, OUT

      i :: INT

      do i = 1,lab.dim
         lab(i) = "U_"//trim(::pADP_index_label(i))
      end

   end

   put_ADP2_labels_to(lab) ::: selfless, PURE
   ! Set the second order ADP labels for parameter with
   ! index "par_index"
      lab :: VEC{STR}(6), OUT

      i :: INT

      do i = 1,6
         lab(i) = ::ADP_label(i)
      end

   end

   put_ADP3_labels_to(lab) ::: selfless, PURE
   ! Set the ADP3 labels for parameter with index "par_index"
      lab :: VEC{STR}(10), OUT

      i :: INT

      do i = 1,10
         lab(i) = ::ADP3_label(i)
      end

   end

   put_ADP4_labels_to(lab) ::: selfless, PURE
   ! Set the ADP4 labels for parameter with index "par_index"
      lab :: VEC{STR}(15), OUT

      i :: INT

      do i = 1,15
         lab(i) = ::ADP4_label(i)
      end

   end

! Transform

   transform_pADP_vector_with(R) ::: PURE
   ! Transform the pADP vector, using the rotation matrix "R".
   ! e.g. transformed = R . pos
   ! NOTE: this works even if pADP_vector is *not* created,
   ! then it works on the positions and ADPs.
      self :: INOUT
      R :: MAT{REAL}(3,3), IN

      W :: MAT{REAL}*
      X,U :: VEC{REAL}*

      ! Create
      X.create(.no_of_pADPs)

      ! Transform position
      if (.pADP_vector.associated) then
         ENSURE(.pADP_vector(1:3).equals(.position),"pADP_vector /= position")
      end
      X(1:3).to_product_of(R,.position)

      ! Transform ADP's
      W.create(6,6)
      GAUSSIAN_DATA:symmetric_tensor_2_product_mx(W,R)
      U.create(6)
      .put_ADP2_vector_to(U)
      X(4:9).to_product_of(W,U)
      U.destroy
      W.destroy

      ! Transform ADP3's
      if (.pADP_vector.associated) then
      if (.pADP_vector.dim>=19) then
      W.create(10,10)
      GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,R)
      X(10:19).to_product_of(W,.pADP_vector(10:19))
      W.destroy
      end
      end

      ! Transform ADP4's
      if (.pADP_vector.associated) then
      if (.pADP_vector.dim>=34) then
      W.create(15,15)
      GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,R)
      X(20:34).to_product_of(W,.pADP_vector(20:34))
      W.destroy
      end
      end

      ! Set pADPs
      .set_pADP_vector_to(X)

      ! Clean
      X.destroy

   end

!  ===============
!  Set atom groups
!  ===============

   set_isotropic_ADP ::: PURE
   ! Set the ADP to be isotropic.
      self :: INOUT

   ENSURE(.ADP_axis_system=="cartesian","not cartesian axis system")

      val :: REAL
      ADP :: MAT{REAL}(3,3)

      ! The averaged trace
      val = THIRD * (.ADP_tensor(1,1)+.ADP_tensor(2,2)+.ADP_tensor(3,3))

      ! Make it isotropic
      ADP(1,1) = val
      ADP(2,2) = val
      ADP(3,3) = val

      ADP(1,2) = ZERO
      ADP(2,1) = ZERO
      ADP(1,3) = ZERO
      ADP(3,1) = ZERO
      ADP(2,3) = ZERO
      ADP(3,2) = ZERO

      .set_ADP_tensor(ADP(:,:))

      ! Now set the errors
      if (.pADP_errors.associated) then

         ! The averaged trace of errors
         val = THIRD * (.pADP_errors(4)+.pADP_errors(5)+.pADP_errors(6))

      else

         ! Use this as last resort
         val = .U_iso_error

      end

      ! Make isotropic error
      .pADP_errors(4) = val
      .pADP_errors(5) = val
      .pADP_errors(6) = val
      .pADP_errors(7) = ZERO
      .pADP_errors(8) = ZERO
      .pADP_errors(9) = ZERO

   end

   set_group(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.group), pure
   ! Generic set
   end

!  ==================
!  Set site occupancy
!  ==================

   set_site_occupancy(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.site_occupancy), pure
   ! Generic set
   end

   set_site_disorder_group(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.site_disorder_group), pure
   ! Generic set
   end

!  =====================
!  Set atomic properties
!  =====================

   set_charge(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.charge), pure
   ! Generic set
   end

   set_dipole(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.dipole), pure
   ! Generic set
   end

   set_quadrupole(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.quadrupole), pure
   ! Generic set
   end

   set_spin(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.spin), pure
   ! Generic set
   end

   set_spin_dipole(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.spin_dipole), pure
   ! Generic set
   end

   set_spin_quadrupole(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.spin_quadrupole), pure
   ! Generic set
   end

   set_charge_polarisability(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.charge_polarisability), pure
   ! Generic set
   end

   set_dipole_polarisability(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.dipole_polarisability), pure
   ! Generic set
   end

   set_energy(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.energy), pure
   ! Generic set
   end

   set_atom_bonded_range_factor(fac) ::: selfless
   ! Set the range factor to decide when atoms are bonded.
      fac :: REAL

   ENSURE(fac>ZERO,"range factor must be grreater than zero")

      atom_bonded_range_factor = fac

   end

   set_covalent_radii_ccdc ::: selfless
   ! Set the the covalent radii for a given atomic number.
      an :: INT
      new_radius :: REAL

      stdin.read(an)
      ENSURE(an>0 AND an<111,"atomic number out of range")
      stdin.read_quantity(new_radius)

      covalent_radii_ccdc(an) = new_radius*ANGSTROM_PER_BOHR

   end

   set_vdw_radii_ccdc ::: selfless
   ! Set the the VDW radii for a given atomic number.
      an :: INT
      new_radius :: REAL

      stdin.read(an)
      ENSURE(an>0 AND an<111,"atomic number out of range")
      stdin.read_quantity(new_radius)

      vdw_radii_ccdc(an) = new_radius*ANGSTROM_PER_BOHR

   end

!  ==============
!  Set basis info
!  ==============

   set_basis_kind(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.basis_kind), pure
   ! Generic set
   end

   set_basis_label(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.basis_label), pure
   ! Generic set
   end

   set_slaterbasis_label(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.slaterbasis_label), pure
   ! Generic set
   end

   set_coppensbasis_label(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.coppensbasis_label), pure
   ! Generic set
   end

!  ============================
!  Set atom (unique) kind index
!  ============================

   set_kind(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.kind), pure
   ! Generic set
   end

   set_is_unique_kind(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.is_unique_kind), pure
   ! Generic set
   end

!  ================================
!  Set ANO data and shell info made
!  ================================

   set_NAOs_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.NAOs_made), pure
   ! Generic set
   end

   set_ANOs_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.ANOs_made), pure
   ! Generic set
   end

   set_spherical_atom_data_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.spherical_atom_data_made), pure
   ! Generic set
   end

   set_shell_info_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.shell_info_made), pure
   ! Generic set
   end

!  =======================
!  Set interpolators made?
!  =======================

   set_use_interpolator(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_interpolator), pure
   ! Generic set
   end

   set_ANO_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.ANO_interpolators_made), pure
   ! Generic set
   end

   set_interpolators_made(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.interpolators_made), pure
   ! Generic set
   end

!  ============
!  Form factors
!  ============

   set_use_IAM_ITC_FFs(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_IAM_ITC_FFs), pure
   ! Generic set
   end

   set_f_i(val) ::: PURE
   ! Set f'
      self :: INOUT
      val :: REAL, IN

   ENSURE(val< HUNDRED,"f_i is too large: "//trim(val.to_str))
   ENSURE(val>-HUNDRED,"f_i is too small: "//trim(val.to_str))

      .f_i = val

   end

   set_f_r(val) ::: PURE
   ! Set f''
      self :: INOUT
      val :: REAL, IN

   ENSURE(val< HUNDRED,"f_r is too large: "//trim(val.to_str))
   ENSURE(val>-HUNDRED,"f_r is too small: "//trim(val.to_str))

      .f_r = val

   end

!  ============
!  I/O Routines
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                            ")  ! exit case
         case ("adp_axis_system=             "); .read_ADP_axis_system
         case ("adp_tensor=                  "); .read_ADP_tensor
         case ("adp2_tensor=                 "); .read_ADP_tensor
         case ("adp3_tensor=                 "); .read_ADP3_tensor
         case ("adp4_tensor=                 "); .read_ADP4_tensor
         case ("axis_system=                 "); .read_axis_system
         case ("basis_label=                 "); .read_basis_label
         case ("b_eq=                        "); .read_B_iso
         case ("b_iso=                       "); .read_B_iso
         case ("charge=                      "); .read_charge
         case ("coppensbasis_label=          "); .read_coppensbasis_label
         case ("dipole=                      "); .read_dipole
         case ("dispersion_coefficients=     "); ATOM:read_dispersion_coefficients
         case ("f_i=                         "); .read_f_i
         case ("f_r=                         "); .read_f_r
         case ("group=                       "); .read_group
         case ("junk=                        "); .read_junk
         case ("label=                       "); .read_label
         case ("mass_number=                 "); .read_mass_number
         case ("mm_atom_type=                "); .read_mm_atom_type
         case ("mm_charge=                   "); .read_mm_charge
         case ("mm_forcefield_name=          "); .read_mm_forcefield_name
         case ("nuclear_charge=              "); .read_nuclear_charge
         case ("oxidation_state=             "); .read_oxidation_state
         case ("pdb_input_line=              "); .read_pdb_input_line
         case ("pos=                         "); .read_position ! deprecated
         case ("position=                    "); .read_position
         case ("put                          "); .put
         case ("put_interpolator             "); .put_interpolator
         case ("residue_atom_code=           "); .read_residue_atom_code
         case ("residue_code=                "); .read_residue_code
         case ("restraining_position=        "); .read_restraining_position
         case ("restraining_force_constant=  "); .read_restraining_force
         case ("residue_sequence_number=     "); .read_residue_sequence_number
         case ("set_covalent_radii_ccdc      "); ::set_covalent_radii_ccdc
         case ("set_vdw_radii_ccdc           "); ::set_vdw_radii_ccdc
         case ("site_disorder_group=         "); .read_site_disorder_group
         case ("site_occupancy=              "); .read_site_occupancy
         case ("slaterbasis_label=           "); .read_slaterbasis_label
         case ("thermal_axis_system=         "); .read_ADP_axis_system ! deprecated
         case ("thermal_tensor=              "); .read_ADP_tensor ! deprecated
         case ("u_eq=                        "); .read_U_iso
         case ("u_iso=                       "); .read_U_iso
         case ("u_tensor=                    "); .read_ADP_tensor
         case ("u2_tensor=                   "); .read_ADP_tensor
         case ("u3_tensor=                   "); .read_ADP3_tensor
         case ("u4_tensor=                   "); .read_ADP4_tensor
         case ("units=                       "); .read_units
         case  default;                        UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_f_i
   ! Read f'', the imaginary part of the anomalous dispersion
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_f_i(val)

   end

   read_f_r
   ! Read f', the real part of the anomalous dispersion
      self :: INOUT

      val :: REAL

      stdin.read(val)

      .set_f_r(val)

   end

   read_group
   ! Read the index which describes the group the atom belongs to.
      self :: INOUT

      stdin.read(.group)

   end

   read_position ::: leaky
   ! Read in the position. The pADP_vector is set also.
      self :: INOUT

      pos :: VEC{REAL}(3)

      ! Read
      stdin.read_quantity(pos)

      ! Set
      .reset_pADPs_and_errors(9)
      .set_position(pos)

   end

   read_label
   ! Read an ATOM label.
      self :: INOUT
      label :: STR

      stdin.read(label)
      .set_atom_data_from_label(label)

   end

   read_mass_number
   ! Read the neutron mass number
      self :: INOUT
      n :: INT

      stdin.read(n)
      .set_mass_number(n)

   end

   read_charge
   ! Read the charge
      self :: INOUT

      stdin.read(.charge)
   
   end

   read_nuclear_charge
   ! Read the charge
      self :: INOUT

      stdin.read(.nuclear_charge)

   end

   read_dipole
   ! Read the dipole
      self :: INOUT

      stdin.read_quantity(.dipole)

   end

   read_dispersion_coefficients ::: selfless
   ! Read a table of dispersion coefficients as a single string array

      table :: VEC{STR}*

      stdin.read_ptr(table)

      ATOM:set_dispersion_coefficients(table)

      table.destroy

   end

   read_oxidation_state
   ! Read the oxidation state
      self :: INOUT

      stdin.read(.oxidation_state)

   end

   read_residue_atom_code
   ! Read the atom code describing where in the residue this atom
   ! resides (case sensitive).
      self :: INOUT

      stdin.read(.residue_atom_code)

   end

   read_residue_code
   ! Read the residue name that this atom belongs to.
      self :: INOUT

      stdin.read(.residue_code)

   end

   read_pdb_input_line
   ! Read a line in the PDB input style
      self :: INOUT

      word :: STR

      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="atom","PDB line does not begin with 'atom'")

      .read_residue_atom_code
      .read_residue_code
      .read_residue_sequence_number
      .read_position
      .read_junk
      .read_junk
      .read_label

   end

   read_residue_sequence_number
   ! Read the residue sequence number of the atom in the molecule
      self :: INOUT

      stdin.read(.residue_sequence_number)

   end

   read_mm_atom_type
   ! Read the atom type potential, used to define the force field potential
      self :: INOUT

      stdin.read(.mm_atom_type)

   end

   read_mm_charge
   ! Read the MM charge on this atom
      self :: INOUT

      stdin.read(.mm_charge)

   end

   read_mm_forcefield_name
   ! Read the MM forcefield name for this atom
      self :: INOUT

      stdin.read(.mm_forcefield_name)

   end

   read_restraining_position
   ! Read the restraining position
      self :: INOUT

      stdin.read_quantity(.restraining_position)

   end

   read_restraining_force
   ! Read the restrain force constant for this atom
      self :: INOUT

      stdin.read_quantity(.restraining_force_constant)

   end

   read_site_disorder_group
   ! Read the site disorder group, used mainly for crystallographic applications.
      self :: INOUT

      stdin.read(.site_disorder_group)

      DIE_IF(.site_disorder_group<0,"site_disorder_group must be non -ve")

   end

   read_site_occupancy
   ! Read the site occupancy, used mainly for crystallographic applications.
      self :: INOUT

      stdin.read(.site_occupancy)

      DIE_IF(.site_occupancy<=ZERO,"site_occupancy must be +ve")
      DIE_IF(.site_occupancy> ONE ,"site_occupancy must be less than one")

   end

   read_axis_system
   ! Read a string which describes the axis system. Currently allowed is
   ! "cartesian" or "crystal". NOTE: .ADP_axis_system is changed too.
      self :: INOUT

      word :: STR

      stdin.read(word)

      .set_axis_system_to(word)

   end

   read_ADP_axis_system
   ! Read a string which describes the ADP (thermal tensor) axis system.
   ! Currently allowed, is "cartesian" or "crystal".
      self :: INOUT

      word :: STR

      stdin.read(word)

      .set_ADP_axis_system_to(word)

   end

   read_basis_label ::: leaky
   ! Read the basis set label from "stdin" which will be used to match
   ! a basis set to ... the element symbol will be prepended.
      self :: INOUT

      stdin.read(.basis_label)

      ! If no element symbol, prepend it
    ! if (.basis_label.does_not_include(':')) then
    !    .basis_label = trim(.chemical_symbol) // ':' // trim(.basis_label)
    ! end

   end

   read_slaterbasis_label ::: leaky
   ! Read the slater basis set label from "stdin" which will be used
   ! to match a basis set to ... the element symbol may be prepended
      self :: INOUT

      stdin.read(.slaterbasis_label)

      ! If no element symbol, prepend it
      if (.basis_label.does_not_include(':')) then
         .basis_label = trim(.generic_chemical_symbol) // ':' // trim(.basis_label)
      end

   end

   read_coppensbasis_label ::: leaky
   ! Read the Coppens basis set label from "stdin" which will be used to match a
   ! basis set to ... (in fact there is only one coppens basis type)
      self :: INOUT

      stdin.read(.coppensbasis_label)

      ! If no element symbol, prepend it
      if (.basis_label.does_not_include(':')) then
         .basis_label = trim(.generic_chemical_symbol) // ':' // trim(.basis_label)
      end

   end

   read_U_iso
   ! Read the isotropic thermal parameters from "stdin".  NOTE: units are
   ! Bohr^2, not Angstrom^2.
      self :: INOUT

      stdin.read_quantity(.U_iso)

   end

   read_B_iso
   ! Read the isotropic B factor.NOTE: units are Bohr^2, not Angstrom^2.
      self :: INOUT

      B_iso :: REAL

      ! Read
      stdin.read_quantity(B_iso)

      ! Set
      .U_iso = B_iso/(EIGHT*PI*PI)

   end

   read_ADP_tensor ::: leaky
   ! Read the ADP (thermal) from "stdin". These are assumed to be in the
   ! cartesian axis system, and in bohr^2.  The expansion of the thermal
   ! smearing temperature factor term is:
   !              TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where (h) are the miller indices and (a^*) are the reciprocal lattice
   ! constants in angstrom^{-2}.
   ! NOTE: The pADP_vector/pADP_errors are set also.
      self :: INOUT

      ADP :: VEC{REAL}(6)

      ! Read elements in lexical order
      stdin.read_quantity(ADP)

      ! Set the tensor
      .reset_pADPs_and_errors(9)
      .set_ADP_tensor(ADP)

   end

   read_ADP3_tensor ::: leaky
   ! Read the third-order ADP (thermal) tensor, assumed to be in the
   ! cartesian axis system, and in bohr^2. The interpretation of these
   ! coefficients as Gram-Charlier, Edgeworth, cumulants or other is
   ! not specified.
      self :: INOUT

      tensor :: VEC{REAL}(10)

      ! Read elements in lexical order
      stdin.read_quantity(tensor)

      ! Set the tensor
      .reset_pADPs_and_errors(19)
      .set_ADP3_vector_to(tensor)

   end

   read_ADP4_tensor ::: leaky
   ! Read the fourth-order ADP (thermal) tensor, assumed to be in the
   ! cartesian axis system, and in bohr^2. The interpretation of these
   ! coefficients as Gram-Charlier, Edgeworth, cumulants or other is
   ! not specified.
      self :: INOUT

      tensor :: VEC{REAL}(15)

      ! Read elements in lexical order
      stdin.read_quantity(tensor)

      ! Set the tensor
      .reset_pADPs_and_errors(34)
      .set_ADP4_vector_to(tensor)

   end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!  ===================
!  Axis change methods
!  ===================

   change_axis_system_to(axis_system,cell,H_U_iso,change_ESDs) ::: PURE
   ! Change the axis system for the position *and* ADP tensors to "axis_system",
   ! either "crystal" or "cartesian". "cell" holds the unit cell axis system
   ! information. Specify the "form" for the anharmonic ADPs.
   ! NOTE: Errors are *not* transformed since that needs covariances.
   !       The errors must be transformed outside this routine.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
      H_U_iso :: BIN, IN
      change_ESDs :: BIN, optional, IN

      .change_pos_axis_system_to(axis_system,cell,change_ESDs)
      .change_ADP2_tensor_to(axis_system,cell,H_U_iso,change_ESDs)
      .change_ADPn_tensor_to_v2(axis_system,cell,change_ESDs)

   end

   change_pos_axis_system_to(axis_system,cell,change_ESDs) ::: PURE
   ! Change atom positions to a new "axis_system".
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
      change_ESDs :: BIN, optional, IN

   ENSURE(axis_system.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      pos :: VEC{REAL}(3)
      change_err :: BIN

      change_err = TRUE
      if (present(change_ESDs)) change_err = change_ESDs

      select case (axis_system)

      case ("cartesian")

         if (.pos_axis_system=="cartesian") return

         pos.to_product_of(cell.direct_matrix,.position)
         .set_position(pos)
         .pos_axis_system = "cartesian"

      case ("crystal  ")

         if (.pos_axis_system=="crystal") return

         pos.to_product_of(cell.inverse_matrix,.position)
         .set_position(pos)
         .pos_axis_system = "crystal"

      end

   end

   change_ADP_axis_system_to(axis_system,cell,change_ESDs) ::: PURE
   ! Change *all* ADP tensor to the desired "axis_system". The axes
   ! are described by the unit "cell". 
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
      change_ESDs :: BIN, optional, IN

      .change_ADP2_tensor_to(axis_system,cell,change_ESDs)
      .change_ADPn_tensor_to_v2(axis_system,cell,change_ESDs)

   end

   change_ADP2_tensor_to(axis_system,cell,H_U_iso,change_ESDs) ::: private, PURE
   ! Change ADP2/s axis system into the "axis_system" frame.
   ! If "axis_system" is "cartesian" i.e. trasforming from standard
   ! crystal axes, then the errors are transformed too, linearly,
   ! unless forbidden with change_ESDs (this is wrong, but in the
   ! absence of any covariance we do it).
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
      H_U_iso :: BIN, IN
      change_ESDs :: BIN, optional, IN

   ENSURE(axis_system.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      ADP :: MAT{REAL}(3,3)
      change_err,chk :: BIN
      val :: REAL

      change_err = TRUE
      if (present(change_ESDs)) change_err = change_ESDs

      chk = FALSE

      select case (axis_system)

      case ("cartesian")

         ! Convert U_iso to an ADP and use it if necessary
         if (.U_iso>ZERO) then

            ! Change U_iso!
            if (.ADP_tensor.is_zero) then

               ! Note: U_iso/U_eq is always in cartesian system
               ! Change ADP to crystal axis system
               ADP.to_unit_matrix
               ADP = ADP*.U_iso
               ADP.change_basis_using(cell.reciprocal_U_matrix)
               .set_ADP_tensor(ADP)

            else

               ! ADP exists already
               ! Check U_iso later ...
               chk = TRUE

            end

         end

         if (.ADP_axis_system=="cartesian") return

         ! Change to cartesians !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         .ADP_tensor.change_basis_to(ADP,cell.direct_U_matrix)

         ! Set axis system *before* U_iso is set
         .ADP_axis_system = "cartesian"

         ! Now U_iso *is* set as a trace
         .set_ADP_tensor(ADP)

         ! Change errors?
         if (change_err) then
         if (.pADP_errors.associated) then
         if (.pADP_errors.dim>=9) then
         if (NOT .pADP_errors(4:9).is_zero) then
            .put_ADP2_errors_to(ADP)
            ADP.change_basis_using(cell.direct_U_matrix)
            .set_ADP2_errors_to(ADP,H_U_iso)
         end
         end
         end
         end

         ! Set U_iso from trace of tensor.
         ! Could also check if supplied U_iso was correct
         if (chk) then
            val = THIRD*.ADP_tensor.trace
            .set_U_iso(val)
         end

      case ("crystal")

         if (.ADP_axis_system=="crystal") return

         .ADP_tensor.change_basis_to(ADP,cell.reciprocal_U_matrix)

         ! Set axis system *before* U_iso is set
         .ADP_axis_system = "crystal"

         ! Now U_iso is not set as a trace
         .set_ADP_tensor(ADP)

         ! Change errors?
         if (change_err) then
         if (.pADP_errors.associated) then
         if (.pADP_errors.dim>=9) then
         if (NOT .pADP_errors(4:9).is_zero) then
            .put_ADP2_errors_to(ADP)
            ADP.change_basis_using(cell.reciprocal_U_matrix)
            .set_ADP2_errors_to(ADP,H_U_iso)
         end
         end
         end
         end

      end

   end

!   change_ADPn_tensor_to_v1(axis_system,cell,change_ESDs) ::: private, PURE
!   ! Change ADPn vector to the "axis_system" frame.
!   ! - If "axis_system" is "crystal", then dimensionless Gram-Charlier
!   !   *gamma*'s is made. Errors are not transformed, it is assumed
!   !   covariance is there and it is done outside this routine.
!   !   NOTE: XD C's and D's are not gammas!
!   ! - If changing to "cartesian" the errors are transformed
!   !   too in a linear fashion (unless forbidden). This is wrong.
!   ! Checked on SO2, 15/02/16 against v2 code.
!      self :: INOUT
!      axis_system :: STR, IN
!      cell :: UNIT_CELL, IN
!      change_ESDs :: BIN, optional, IN
!
!   ENSURE(axis_system.is_one_of(["cartesian","crystal  "]),"unknown axis system!")
!
!      W :: MAT{REAL}*
!      pADP :: VEC{REAL}*
!      change_err :: BIN
!
!      change_err = TRUE
!      if (present(change_ESDs)) change_err = change_ESDs
!
!      select case (axis_system)
!
!         case ("cartesian")
!
!            if (.ADPn_axis_system=="cartesian") return
!
!            .ADPn_axis_system = "cartesian"
!
!            if (NOT .has_ADP3s) return
!
!            ! Transform ADP3's
!            W.create(10,10)
!            pADP.create(10)
!            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,transpose(cell.direct_matrix))
!            pADP.to_product_of(W,.pADP_vector(10:19))
!            .pADP_vector(10:19) = pADP
!
!            ! Transform errors to cartesian?
!            if (change_ESDs) then
!            if (.pADP_errors.associated) then
!            if (.pADP_errors.dim>=19) then
!            if (NOT .pADP_errors(10:19).is_zero) then
!               pADP.to_product_of(W,.pADP_errors(10:19))
!              .pADP_errors(10:19) = pADP
!            end
!            end
!            end
!            end
!
!            pADP.destroy
!            W.destroy
!
!            if (NOT .has_ADP4s) return
!
!            ! Transform ADP4's
!            W.create(15,15)
!            pADP.create(15)
!            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,transpose(cell.direct_matrix))
!            pADP.to_product_of(W,.pADP_vector(20:34))
!            .pADP_vector(20:34) = pADP
!
!            ! Transform errors to cartesian?
!            if (change_ESDs) then
!            if (.pADP_errors.associated) then
!            if (.pADP_errors.dim>=34) then
!            if (NOT .pADP_errors(20:34).is_zero) then
!               pADP.to_product_of(W,.pADP_errors(20:34))
!              .pADP_errors(20:34) = pADP
!            end
!            end
!            end
!            end
!
!            pADP.destroy
!            W.destroy
!
!         case ("crystal")
!
!            if (.ADPn_axis_system=="crystal") return
!
!            .ADPn_axis_system = "crystal"
!
!            if (NOT .has_ADP3s) return
!
!            ! Transform ADP3's
!            W.create(10,10)
!            pADP.create(10)
!            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,cell.reciprocal_matrix)
!            pADP.to_product_of(W,.pADP_vector(10:19))
!            .pADP_vector(10:19) = pADP
!            pADP.destroy
!            W.destroy
!
!            if (NOT .has_ADP4s) return
!
!            ! Transform ADP4's
!            W.create(15,15)
!            pADP.create(15)
!            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,cell.reciprocal_matrix)
!            pADP.to_product_of(W,.pADP_vector(20:34))
!            .pADP_vector(20:34) = pADP
!            pADP.destroy
!            W.destroy
!
!      end
!
!   end

   change_ADPn_tensor_to_v2(axis_system,cell,change_ESDs) ::: private, PURE
   ! Change ADPn vector to the "axis_system" frame.
   ! NOTE: Unlike the ADP2's, in the "crystal" axis_system these are
   ! reported in dimensionless Gram-Charlier "g" form. For
   ! consistency, we also produce them in dimensioned "u" form
   ! which have reciprocal lengths in them like the IUCr ADPs
   ! in the crystal axis system.  However, internally, and during the
   ! refinement, the axis_system is always "cartesian" and Bohr units.
      self :: INOUT
      axis_system :: STR, IN
      cell :: UNIT_CELL, IN
      change_ESDs :: BIN, optional, IN

   ENSURE(axis_system.is_one_of(["cartesian","crystal  "]),"unknown axis system!")

      adp3,new3 :: MAT3{REAL}(3,3,3)
      adp4,new4 :: MAT4{REAL}(3,3,3,3)
      change_err :: BIN

      change_err = TRUE
      if (present(change_ESDs)) change_err = change_ESDs

      select case (axis_system)

      case ("cartesian") ! Change INTO cartesian FROM crystal

         if (.ADPn_axis_system=="cartesian") return

         .ADPn_axis_system = "cartesian"

         if (NOT .has_ADP3s) return

         .put_ADP3_vector_to(adp3)
         adp3.back_transform_to(new3,cell.direct_matrix)
         .set_ADP3_vector_to(new3)

         ! Transform errors to cartesian?
         if (change_err) then
         if (.pADP_errors.associated) then
         if (.pADP_errors.dim>=19) then
         if (NOT .pADP_errors(10:19).is_zero) then
         .put_ADP3_errors_to(adp3)
         adp3.back_transform_to(new3,cell.direct_matrix)
         .set_ADP3_errors_to(new3)
         end
         end
         end
         end

         if (NOT .has_ADP4s) return

         .put_ADP4_vector_to(adp4)
         adp4.back_transform_to(new4,cell.direct_matrix)
         .set_ADP4_vector_to(new4)

         ! Transform errors to cartesian?
         if (change_err) then
         if (.pADP_errors.associated) then
         if (.pADP_errors.dim>=34) then
         if (NOT .pADP_errors(20:34).is_zero) then
         .put_ADP4_errors_to(adp4)
         adp4.back_transform_to(new4,cell.direct_matrix)
         .set_ADP4_errors_to(new4)
         end
         end
         end
         end

      case ("crystal")  ! Change INTO crystal FROM cartesian

         if (.ADPn_axis_system=="crystal") return

         .ADPn_axis_system = "crystal"

         if (NOT .has_ADP3s) return

         .put_ADP3_vector_to(adp3)
         adp3.change_basis_to(new3,cell.reciprocal_matrix)
         .set_ADP3_vector_to(new3)

         if (NOT .has_ADP4s) return

         .put_ADP4_vector_to(adp4)
         adp4.change_basis_to(new4,cell.reciprocal_matrix)
         .set_ADP4_vector_to(new4)

      end

   end


   change_coordinate_axes(axes)
   ! Change the coordiantes and ADP (thermal) tensors to be expressed
   ! in terms of a new set of orthogonal "axes". We must be n the
   ! cartesian axis system.
      axes :: MAT{REAL}(3,3), IN

   ENSURE(.pos_axis_system=="cartesian","positions must be in cartesian axis system")
   ENSURE(.ADP_axis_system=="cartesian","U's must be in cartesian axis system")
   DIE_IF(.has_ADP3s,"does not work for U3's yet")
   DIE_IF(.has_ADP4s,"does not work for U4's yet")

      pos :: VEC{REAL}(3)
      ADP :: MAT{REAL}(3,3)

      pos.to_product_of(axes,.position)
      .set_position(pos)

      ! WARNING: this may not be correct
      .ADP_tensor.change_basis_to(ADP,axes)
      .set_ADP_tensor(ADP)

   end


!  ========================
!  Basis resolution methods
!  ========================

   resolve_basis(basis,suffix,found) ::: template
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
      basis :: VEC{BASIS?}*
      suffix :: STR, optional
      found :: BIN, optional

   DIE_IF(basis.disassociated,"no basis")

      library_label, symbol :: STR
      fnd :: BIN

      fnd = FALSE

      ! First, try matching the basis from the "suffix"
      ! e.g. like "Mg:STO-3G"
      if (present(suffix)) then
      if (suffix/=" ") then

         ! This makes "Mg:STO-3G"
         library_label = .library_basis_label(suffix)

         ! Pointer assign into "basis"
         TO?.resolve_by_label(library_label,basis,clobber=TRUE,found=fnd)

         ! Set the basis label
         if (fnd) LABEL? = library_label

      end
      end

      ! Next, try matching the basis to an existing label, if there ...
      if (NOT fnd AND LABEL?/=" ") then
         TO?.resolve_by_label(LABEL?,basis,clobber=TRUE,found=fnd)
      end

      ! Last chance: try (minimal) matching using only the chemical symbol ...
      if (NOT fnd) then

         symbol = trim(.generic_chemical_symbol)//":"

         ! Pointer assign into "basis"
         TO?.resolve_by_label(symbol,basis,clobber=TRUE,minmatch=TRUE,found=fnd)

         ! Set the basis label
         if (fnd) LABEL? = TO?.label

      end

      if (present(found)) found = fnd

   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS?=>BASIS, TO?=>.basis, LABEL?=>.basis_label)
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS?=>SLATERBASIS, TO?=>.slaterbasis, LABEL?=>.slaterbasis_label)
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS?=>COPPENSBASIS, TO?=>.coppensbasis, LABEL?=>.coppensbasis_label)
   ! Resolve the BASIS from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

!  =========================
!  Atom-kind inquiry methods
!  =========================

   has_a_dummy_label result (res) ::: elemental
   ! Return TRUE if this has a dummy charge label (charged or not,
   ! with basis set or not)
      self :: IN
      res :: BIN
      res = .label==ATOM_DUMMY_CHARGE_LABEL
   end

   is_a_dummy_atom result (res) ::: elemental
   ! Return TRUE if this is a dummy atom (no charge, no basis)
      self :: IN
      res :: BIN

      res = .has_a_dummy_label AND .nuclear_charge==ZERO AND .basis.disassociated

   end

   is_a_nondummy_atom result (res) ::: elemental
   ! Return TRUE if this is a *not* dummy atom
      self :: IN
      res :: BIN

      res = NOT .has_a_dummy_label OR .nuclear_charge/=ZERO OR .basis.associated

   end

   is_a_ghost_atom result (res) ::: elemental
   ! Return TRUE if this is a ghost atom
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge==ZERO AND .has_basis
   end

   is_a_point_charge result (res) ::: elemental
   ! Return TRUE if this is a point-charge (no basis set)
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge>ZERO AND .basis.disassociated
   end

   is_a_pseudo_atom result (res) ::: elemental
   ! Return TRUE if this is a pseudo atom without integral charge
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND NOT .nuclear_charge.is_int AND .has_basis
   end

   is_same_kind_as(atom) result (res) ::: pure
   ! Return TRUE if self is the same kind of atom as "atom". The
   ! position and label are not compared since the same kind of atom
   ! can have a different position and label.  To check if the basis
   ! set is the same, only the label is used.
      self :: IN
      atom :: ATOM, IN
      res :: BIN

      bases_created,coppens_created,slater_created :: BIN
      bases_destroyed,coppens_destroyed,slater_destroyed :: BIN
      mixed :: BIN

      ! Which kind of bases created?
      bases_created     = .basis.associated        AND atom.basis.associated
      coppens_created   = .coppensbasis.associated AND atom.coppensbasis.associated
      slater_created    = .slaterbasis.associated  AND atom.slaterbasis.associated

      ! Which kind of bases destroyed?
      bases_destroyed   = .basis.disassociated        AND atom.basis.disassociated
      coppens_destroyed = .coppensbasis.disassociated AND atom.coppensbasis.disassociated
      slater_destroyed  = .slaterbasis.disassociated  AND atom.slaterbasis.disassociated

      ! Mixed bases?
      mixed = NOT (bases_created   OR bases_destroyed)   OR &
              NOT (coppens_created OR coppens_destroyed) OR &
              NOT (slater_created  OR slater_destroyed)

      ! Set same kind
      if (mixed) then

         res = FALSE

      else

         ! Set here ...
         res = .atomic_number==atom.atomic_number
         if (bases_created)   res = res AND .basis.label       ==atom.basis.label
         if (coppens_created) res = res AND .coppensbasis.label==atom.coppensbasis.label
         if (slater_created)  res = res AND .slaterbasis.label ==atom.slaterbasis.label

      end

   end

   is_xtal_identical_to(atom) result (res) ::: elemental
   ! Return true if self and "atom" are crystallographically i.e.
   ! identical based on occupancy and atomic number *and* position.
      self :: IN
      atom :: ATOM, IN
      res :: BIN

      res = .is_xtal_identical_kind_to(atom) AND .position.equals(atom.position)

   end

   is_xtal_identical_kind_to(atom) result (res) ::: elemental
   ! Return true if self and "atom" are crystallographically
   ! identical based on occupancy and atomic number
      self :: IN
      atom :: ATOM, IN
      res :: BIN

      res =         .atomic_number      ==atom.atomic_number
      res = res AND .site_disorder_group==atom.site_disorder_group
      res = res AND .site_occupancy.equals(atom.site_occupancy )

   end

   is_in_cartesian_system result (res) ::: elemental
   ! Return TRUE if the axis system is cartesian
      self :: IN
      res :: BIN

      res = .pos_axis_system=="cartesian" AND .ADP_axis_system=="cartesian"

   end

!  =====================
!  Basis inquiry methods
!  =====================

   has_basis result (res) ::: elemental
   ! Return TRUE if this is a pseudo atom without integral charge
      self :: IN
      res :: BIN
      res = .basis.associated AND .basis.is_resolved
   end

   basis_descriptor result (res) ::: template
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
      self :: IN
      res :: STR

      if (.ARG?.associated) then
         res = .ARG?.label
         if (.is_a_ghost_atom) then
            res = trim(res)//" (ghost atom)"
         else if (.is_a_pseudo_atom) then
            res = trim(res)//" (pseudo atom)"
         end
      else if (.is_a_point_charge) then
         res = "n/a (pt. charge)"
      else if (.is_a_dummy_atom) then
         res = "n/a (dummy atom)"
      else
         res = "??"
      end

   end

   basis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, ARG?=>basis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   slaterbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, ARG?=>slaterbasis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   coppensbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, ARG?=>coppensbasis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   library_basis_label(suffix) result (label)
   ! Return a library basis set label by appending "suffix" to the
   ! chemical symbol.
      suffix :: STR

      label :: STR
      symbol :: STR

      symbol = .generic_chemical_symbol

      select case (suffix)

         case ("Coppens","Clementi-Roetti")

            ! Replace bases for high atomic numbers
            ! where bases do not exist
            if (.atomic_number>55) then

               select case (.atomic_number)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:86);  symbol = ATOM:generic_chemical_symbol(.atomic_number-32)
                  case (87);     symbol = "Rb"
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end

               WARN("Atom "//trim(.generic_chemical_symbol)//" basis is now "//trim(symbol))

            end

            label = trim(symbol)//trim(.oxidation_state_str)//":"//trim(suffix)

         case default

            label = trim(symbol)//":"//trim(suffix)

      end

   end

   library_basis_label(Z,suffix) result (label) ::: selfless, leaky
   ! Return a library basis set label for the atom with atomic number
   ! "Z", by appending "suffix" to the chemical symbol.
      Z :: INT, IN
      suffix :: STR

   ENSURE(Z>=1 AND Z<=118,"Z out of range")

      label :: STR
      symbol :: STR

      symbol = element_symbols(Z)
      select case (suffix)
         case ("Coppens","Thakkar","Clementi-Roetti")
            if (Z>55) then
               select case (Z)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:86);  symbol = element_symbols(Z-32)
                  case (87);     symbol = "Rb"
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end
            end
            label = trim(symbol)//":"//trim(suffix)
         case default
            label = trim(symbol)//":"//trim(suffix)
      end

   end


!   no_of_shells result (res) ::: pure
!   ! Return the no of shells
!      self :: IN
!      res :: INT
!
!      res = .basis.no_of_shells
!
!   end

!   no_of_basis_functions result (res) ::: pure
!   ! Evaluate and return the no. of basis functions
!      self :: IN
!      res :: INT
!
!      res = .basis.no_of_basis_functions
!
!   end

!   no_of_sph_basis_functions result (res) ::: pure
!   ! Evaluate and return the no. of spherical basis functions
!      self :: IN
!      res :: INT
!
!      res = .basis.no_of_sph_basis_functions
!
!   end

!   n_bf result (res) ::: pure
!   ! Return the no. of basis functions
!      self :: IN
!      res :: INT
!
!      res = .basis.n_bf
!
!   end

!   no_of_primitives result (res) ::: pure
!   ! Return the no of primitives for this atom
!      self :: IN
!      res :: INT
!
!      res = .basis.no_of_primitives
!
!   end

!   no_of_sph_primitives result (res) ::: pure
!   ! Return the no of primitives for this atom
!      self :: IN
!      res :: INT
!
!      res = .basis.no_of_sph_primitives
!
!   end

!   n_prim result (res) ::: pure
!   ! Return the no of primitives for this atom
!      self :: IN
!      res :: INT
!
!      res = .basis.n_prim
!
!   end

!  =============================
!  Chemical-data related inquiry
!  =============================

   generic_chemical_symbol result (res) ::: elemental
   ! Return the generic chemical symbol, which ignores isotopes.
      self :: IN
      res :: STR(len=2)

      Z :: INT

      Z = .atomic_number
      res = ATOM:generic_chemical_symbol(Z)

   end

   generic_chemical_symbol(Z) result (res) ::: elemental, selfless
   ! Return the element symbol for atomic number "Z".
      Z :: INT, IN
      res :: STR(len=2)

      res = "?"
      if (Z==0) then
         res = ATOM_DUMMY_CHARGE_LABEL
      else if (Z.is_in_range([1,118])) then
         res = element_symbols(Z)
      end

   end

   chemical_symbol result (res) ::: elemental, public
   ! Return the chemical symbol for this atom. Accounts for D and T.
      self :: IN
      res :: STR(len=2)

      Z,A :: INT

      Z = .atomic_number
      A = .mass_number
      res = ATOM:chemical_symbol(Z,A)

   end

   chemical_symbol(Z,A) result (res) ::: elemental, selfless
   ! The element symbol for atomic number "Z" mass_number "A".
      Z :: INT, IN
      A :: INT, IN
      res :: STR(len=2)

      res = "?"
      if (Z==0) then
         res = ATOM_DUMMY_CHARGE_LABEL
      else if (Z==1 AND A==2) then
         res = "D"
      else if (Z==1 AND A==3) then
         res = "T"
      else if (Z.is_in_range([1,118])) then
         res = element_symbols(Z)
      end

   end

   atomic_number_from_label(label) result (Z) ::: selfless
   ! Return the atomic number from an atom label.
      label :: STR, IN
      Z :: INT

      symbol :: STR

      symbol = ATOM:element_symbol_from_label(label)
      Z = element_symbols(1:).index_of(symbol(1:2))

   end

   mass result (res) ::: private, pure
   ! Return the abundance-weighted mass C12 mass units unless
   ! mass_number is non-zero, in which case give the isotope mass.
      self :: IN
      res :: REAL

      if (.mass_number>0) then
         res = ::mass_of_isotope(.atomic_number,.mass_number)
      else
         res = ::mass_of_atom(.atomic_number)
      end

   end

   mass_of_atom(Z) result (res) ::: elemental, selfless
   ! Return the natural-abundance-weighted atomic mass in C12 mass units.
      Z :: INT, IN
      res :: REAL

      res = 0
      if (Z.is_in_range([1,92])) res = atomic_masses(Z)

   end

   mass_of_isotope(Z,A) result (res) ::: elemental, selfless
   ! Return the atomic mass in C12 mass unoits for the isotope with
   ! atomic number "Z" and atomic mass number "A".
      Z :: INT, IN
      A :: INT, IN
      res :: REAL

      Zf,Zl,Af,Al :: INT
      Zr,Ar :: REAL

      Zr = Z
      Ar = A

      Zf = isotope_data(1,  :  ).index_of_value(Zr)
      Zl = isotope_data(1,  :  ).index_of_value(Zr,last=TRUE)
      Af = isotope_data(2,Zf:Zl).index_of_value(Ar)
      Al = isotope_data(2,Zf:Zl).index_of_value(Ar,last=TRUE)

      res = 0
      if (Af==Al) res = isotope_data(3,Af+Zf-1)

   end

   mean_neutron_number result (res) ::: pure
   ! Return the average (abundance weighted) number of neutrons for this atom,
   ! calculated roughly by subtracting the number of protons from the atomic mass.
      self :: IN
      res :: REAL

      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                                            res = .mass - .atomic_number
      end

   end

   bragg_slater_radius result (res) ::: pure
   ! Return the Bragg-Slater radius for this atom
   ! WARNING: this is in Angstroms!
      self :: IN
      res :: REAL

      if      (.atomic_number<1 ) then; res = ZERO
      else if (.atomic_number>54) then; res = 1.30d0
      else;                             res = bragg_slater_radii(.atomic_number)
      end

   end

   neutron_scattering_length result (res) ::: pure
   ! Return the neutron scattering length for this atom
      self :: IN
      res :: REAL

      if (.atomic_number<1 OR .atomic_number>95) then; res = ZERO
      else;                                            res = neutron_scattering_lengths(.atomic_number)
      end

   end

   n_core_electrons(Z) result (noble) ::: pure
   ! Return the number of core electrons for the atom in the n-shell
   ! one less than the valence shell.  If "Z" is present it is used as
   ! the atomic number.
      self :: IN
      Z :: INT, optional, IN
      noble :: INT

      p :: INT
      atomic_number,tmp,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      noble = 0
      if (atomic_number<1) return

      p = 1
      do
         n = (p+2)/2
         tmp = noble + 2*n**2
         if (atomic_number <= tmp) exit
         noble = tmp   ! add core electrons
         p = p + 1     ! next period
      end

   end

   period_number(Z) result (p) ::: pure
   ! Return the period (i.e. row) on which the atom lies.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN

      p :: INT
      atomic_number,noble,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      p = 0
      if (atomic_number<1) return

      p = 1
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end

   end

   column_number(Z) result (col) ::: pure
   ! Return the periodic table column of the atom.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN
      col :: INT

      atomic_number,p,noble,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      col = 0
      if (atomic_number<1) return

      p = 1
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end

      noble = noble - 2*n**2
      col   = atomic_number - noble

   end

   period_block(Z) result (b) ::: PURE
   ! Return the period block character in which the atom lies.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN
      b :: STR(len=1)

   ENSURE(Z>0,"atomic charge Z not +ve")
   ENSURE(.period_number(Z)<8,"Z is too large")

      p,col :: INT

      p   = .period_number(Z)
      col = .column_number(Z)

      b = "?"

      if (p<4) then
         select case (col)
            case (1:2);   b = "s"
            case (3:8);   b = "p"
         end
      else if (p<6) then
         select case (col)
            case (1:2);   b = "s"
            case (3:12);  b = "d"
            case (13:18); b = "p"
         end
      else if (p<8) then
         select case (col)
            case (1:2);   b = "s"
            case (3:16);  b = "f"
            case (17:26); b = "d"
            case (27:32); b = "p"
         end
      end

   end

   is_a_H_atom result(res) ::: elemental
   ! Return whether the atom is a H atom
      self :: IN
      res :: BIN

      res = .atomic_number==1

   end

   is_not_a_H_atom result(res) ::: elemental
   ! Return whether the atom is not a H atom
      self :: IN
      res :: BIN

      res = .atomic_number/=1

   end

   is_a_nonmetal(Z) result(res) ::: elemental
   ! Return whether the atom is a nonmetal.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      atomic_number :: INT

      ! Get atomic number
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      res = FALSE

      select case (atomic_number)
         case( 1: 2); res = TRUE !  H - He
         case( 6:10); res = TRUE !  C - Ne
         case(15:18); res = TRUE !  P - Ar
         case(34:36); res = TRUE ! Se - Kr
         case(53:54); res = TRUE !  I - Xe
         case(86   ); res = TRUE !  Rn
      end

   end

   is_a_metalloid(Z) result(res) ::: elemental
   ! Return whether the atom is a metalloid.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      atomic_number :: INT

      ! Get atomic number
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      res = FALSE

      select case (atomic_number)
         case( 5   ); res = TRUE !  B
         case(14   ); res = TRUE ! Si
         case(32:33); res = TRUE ! Ge - As
         case(51:52); res = TRUE ! Sb - Te
         case(85   ); res = TRUE ! As
      end

   end

   is_a_metal(Z) result(res) ::: elemental
   ! Return whether the atom is a metalloid.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      metalloid,nonmetal :: BIN

      nonmetal  = .is_a_nonmetal(Z)
      metalloid = .is_a_metalloid(Z)

      res = NOT nonmetal AND NOT metalloid

   end

   ground_state_multiplicity(Z) result (mult) ::: PURE
   ! Return the ground state multiplicity for this atom according to Hunds rule
   ! (Note this is not neccesarily the real ground state, esp. for Cu)
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, optional, IN
      mult :: INT

   ENSURE(INT:is_in_range(.period_number(Z),[0,7]), "cannot assign for Z ="// trim(Z.to_str))

      p,col :: INT

      ! Get period and column
      p   = .period_number(Z)
      col = .column_number(Z)

      mult = 0

      select case (p)

      case (0)

         ! Dummy atom or Electron
         mult = 1

      case (1,2,3)

         ! First three periods
         select case (col)
         case (2,8);   mult = 1
         case (1,3,7); mult = 2
         case (4,6);   mult = 3
         case (5);     mult = 4
         end

      case (4,5)

         ! First two transition metal periods
         select case (col)
         case (2,12,18);      mult = 1
         case (1,3,11,13,17); mult = 2
         case (4,10,14,16);   mult = 3
         case (5,9,15);       mult = 4
         case (6,8);          mult = 5
         case (7);            mult = 6
         end

      case (6,7)

         ! First two actinide metal periods
         select case (col)
         case (2,16,26,32);         mult = 1
         case (1,3,15,17,25,27,31); mult = 2
         case (4,14,18,24,28,30);   mult = 3
         case (5,13,19,23,29);      mult = 4
         case (6,12,20,22);         mult = 5
         case (7,11,21);            mult = 6
         case (8,10);               mult = 7
         case (9);                  mult = 8
         end

      end

   end

   oxidation_state_str result (res)
   ! Return the oxidation state string, i.e. if the oxidation state is +3, then
   ! the returned string is "3+"; or if the oxidation state is -1 then the
   ! returned string is "-". This is useful for resolving certain library basis
   ! labels.
      res :: STR
      charge :: INT
      charge = .oxidation_state
      if (charge==0) then
         res = " "
      else
         if (charge>0) then; res = "+"
         else;               res = "-"
         end
         charge = abs(charge)
         if (charge/=1) res = trim(charge.to_str)//trim(res)
      end
   end

!  =========================
!  Form factors & dispersion
!  =========================

   H_SDS_form_factor(k) result (res) ::: selfless, elemental
   ! The H atom SDS form factor where "k" is the scattering vector
   ! in reciprocal Bohr.
      k :: REAL, IN
      res :: REAL

      stl,a,b :: REAL
      i :: INT

      ! Convert k to s.t.l.
      ! See Dunitz p.27-28
      stl = HALF*k*BOHR_PER_ANGSTROM/(2*PI)
      stl = stl*stl

      ! Do it baby
      res = ZERO
      do i = 0,4
         a = H_SDS_form_factor_coeff(1,i)
         b = H_SDS_form_factor_coeff(2,i)
         res = res + a*exp(-b*stl)
      end

   end

   H_HF0_form_factor(k) result (res) ::: selfless, elemental
   ! The H atom *neutral* form factor where "k" is the scattering
   ! vector in reciprocal Bohr.
      k :: REAL, IN
      res :: REAL

      stl,a,b :: REAL
      i :: INT

      ! Convert k to s.t.l.
      ! See Dunitz p.27-28
      stl = HALF*k*BOHR_PER_ANGSTROM/(2*PI)
      stl = stl*stl

      ! Do it baby
      res = ZERO
      do i = 0,4
         a = H_HF0_form_factor_coeff(1,i)
         b = H_HF0_form_factor_coeff(2,i)
         res = res + a*exp(-b*stl)
      end

   end

   HF_n0_form_factor(k) result (res) ::: PURE
   ! The HF *neutral* form factor for atom, where "k" is the
   ! scattering vector in reciprocal Bohr.
      self :: IN
      k :: VEC{REAL}, IN
      res :: VEC{REAL}(k.dim)

   ENSURE(.atomic_number.is_in_range([1,98]),"Z out of range, Z = "//trim(.atomic_number.to_str))

      stl :: VEC{REAL}*
      a,b :: REAL
      i :: INT

      ! Convert k to s.t.l.
      ! See Dunitz p.27-28
      stl.create(k.dim)
      stl = HALF*k*BOHR_PER_ANGSTROM/(2*PI)
      stl = stl*stl

      ! Do it baby
      res = ZERO
      do i = 0,4
         a = HF_n0_form_factor_coeff(1,i,.atomic_number)
         b = HF_n0_form_factor_coeff(2,i,.atomic_number)
         res = res + a*exp(-b*stl)
      end

      stl.destroy

   end

   has_dispersion result (res) ::: elemental
   ! Return TRUE if the atom has non-zero dispersion coefficients
      self :: IN
      res :: BIN

      res = NOT .f_r.is_zero OR &
            NOT .f_i.is_zero

   end

   has_tabular_dispersion result (res) ::: PURE, ELEMENTAL
   ! Return TRUE if this element has a valid dispersion coefficient in
   ! the table.
      self :: IN
      res :: BIN

      res = ATOM:has_tabular_dispersion_for(.atomic_number)

   end

   has_tabular_dispersion_for(Z) result (res) ::: selfless, ELEMENTAL
   ! Return TRUE if the element with atomic number "Z"  has a
   ! valid dispersion coefficient in the table.
      Z :: INT, IN
      res :: BIN

      res = abs(element_xray_dispersion(Z)) >= ZERO

   end

   dispersion_correction result (res) ::: elemental
   ! The dispersion correction at a certain "wavelength".
      self :: IN
      res :: CPX

      res = element_xray_dispersion(.atomic_number)

   end

!   set_dispersion_coefficient(wavelength)
!   ! Set the anomalous dispersion coefficient at a certain "wavelength".
!      self :: INOUT
!      wavelength :: REAL, IN
!
!      sasaki :: SASAKI_FORM_FACTORS*
!
!      if (.has_dispersion) then
!
!         ! Don't override an existing (fr,fi)
!
!      else
!      
!         ! Look up dipersion from table ... UNRELIABLE TABLES
!         if (.atomic_number<1 OR .atomic_number>92) then
!        
!            .f_r = ZERO
!            .f_i = ZERO
!        
!         else
!        
!            ! Get them
!            sasaki.create
!            sasaki.set_wavelength(wavelength)
!            sasaki.set_Z_list([.atomic_number])
!            sasaki.update
!
!            ! Set them
!            .f_r = sasaki.fr(1)
!            .f_i = sasaki.fi(1)
!
!            ! Clean
!            sasaki.destroy
!        
!         end
!
!      end
!
!   end

   xray_dispersion_entered result (res) ::: PURE
   ! Return whether xray_dispersion table was entered.
      self :: IN
      res :: BIN

      res = xray_dispersion_set

   end

   set_dispersion_coefficients(Z,f_r,f_i) ::: selfless
   ! Set the elemental dispersion coefficients from f_r and f_i.
      Z :: INT, IN 
      f_r,f_i :: REAL, IN 

      ! Set them in the table
      element_xray_dispersion(Z) = COMPLEXIFY(f_r,f_i)

      xray_dispersion_set = TRUE

   end

   set_dispersion_coefficients(string) ::: selfless
   ! Set the elemental dispersion coefficients from a "string"
   ! of values comprising sequential element symbols, f' and f''.
      string :: STR, IN 

      table :: VEC{STR}*

      table => string.split

      ATOM:set_dispersion_coefficients(table)

      table.destroy

   end

   set_dispersion_coefficients(table) ::: selfless
   ! Set the elemental dispersion coefficients from a "table"
   ! of values comprising sequential element symbols, f' and f''.
      table :: VEC{STR}, IN 

   DIE_IF((table.dim/3)*3/=table.dim,"the table is not divisible by 3")

      symbol :: STR(len=2)
      val1,val2,val3 :: STR
      i,offset,Z :: INT
      f_r,f_i :: REAL

      offset = 0

      do i = 1,table.dim/3

         val1 = table(offset+1)
         val2 = table(offset+2)
         val3 = table(offset+3)

         ! Get the atomic number Z
         symbol = ATOM:element_symbol_from_label(val1)
         Z = element_symbols(1:).index_of(symbol(1:2))
         DIE_IF(Z==0,"unknown element symbol: "//trim(symbol))

         ! Get f' and f''
         f_r = val2.to_real
         f_i = val3.to_real

         ! Set them in the table
         element_xray_dispersion(Z) = COMPLEXIFY(f_r,f_i)

         ! Next in the table
         offset = offset + 3

      end

      xray_dispersion_set = TRUE

   end

   set_tabular_dispersion ::: PURE
   ! Set the atom's own dispersion coefficients from
   ! the element_xray_dispersion table (if there).
      self :: INOUT

      Z :: INT
      f_r,f_i :: REAL

      Z = .atomic_number

      f_r = RE(element_xray_dispersion(Z))
      f_i = IM(element_xray_dispersion(Z))

      .f_r = f_r
      .f_i = f_i

   end

   add_dispersion(Fc,k_pts,rf) ::: PURE
   ! Add the anamalous dispersion correction into the calculated
   ! structure factor "Fc", for a given set of "k_pts" and with "rf"
   ! the repetition factors.
      self :: IN
      Fc :: VEC{CPX}, INOUT
      k_pts :: MAT{REAL}, IN
      rf :: REAL, IN

   ENSURE(Fc.dim1==k_pts.dim1,"1st dimension of dc and k_pts are not compatible")
   ENSURE(      3==k_pts.dim2,"2nd dimension of k_pts must be 3!")

      II,anom,phase :: CPX
    ! fr :: VEC{REAL}(3)
    ! Uv :: VEC{REAL}(6)
      kv :: VEC{REAL}(3)
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      c2,c3,c4 :: REAL
      k,n_k :: INT
      val :: CPX

      II   = IMAGIFY(ONE)
      anom = .dispersion_correction
      n_k  = k_pts.dim1

    !       if (.atomic_number==16) then
    !          stdout.show("f'          =",RE(anom))
    !          stdout.show("f''         =",IM(anom))
    !          stdout.show("rf          =",rf)
    !          stdout.text("position:")
    !          stdout.put(.position)
    !       end


      ! Temperature part, ADP4's
      if (.has_only_ADP4s_and_errors) then

         ! Get ADP tensors
         .put_ADP2_vector_to(adp2)
         .put_ADP3_vector_to(adp3)
         .put_ADP4_vector_to(adp4)

         do k = 1,n_k

            ! U tensor contracted with k vector
            kv = k_pts(k,:)
            c2 = adp2.contract_with(kv)*HALF
            c3 = adp3.contract_with(kv)*SIXTH
            c4 = adp4.contract_with(kv)*SIXTH*QUARTER

            ! SF contribution (quartic anharmonic!)
            phase = k_pts(k,1)*.position(1) &
                  + k_pts(k,2)*.position(2) &
                  + k_pts(k,3)*.position(3) 
            phase = exp(II*phase)
            Fc(k) = Fc(k) + anom * phase * exp(-c2) * (ONE - II*c3 + c4) / rf

         end

      ! Temperature part, ADP3's
      else if (.has_only_ADP3s_and_errors) then

         ! Get ADP tensors
         .put_ADP2_vector_to(adp2)
         .put_ADP3_vector_to(adp3)

         do k = 1,n_k

            ! U tensor contracted with k vector
            kv = k_pts(k,:)
            c2 = adp2.contract_with(kv)*HALF
            c3 = adp3.contract_with(kv)*SIXTH

            ! SF contribution (cubic anharmonic!)
            phase = k_pts(k,1)*.position(1) &
                  + k_pts(k,2)*.position(2) &
                  + k_pts(k,3)*.position(3) 
            phase = exp(II*phase)
            Fc(k) = Fc(k) + anom * phase * exp(-c2) * (ONE - II*c3) / rf

         end

      ! Harmonic ...
      else 

         ! Get ADP tensor
         .put_ADP2_vector_to(adp2)

         do k = 1,n_k

            ! U tensor contracted with k vector
            kv = k_pts(k,:)
            c2 = adp2.contract_with(kv)*HALF

            ! SF contribution (harmonic!)
            phase = kv(1)*.position(1) + kv(2)*.position(2) + kv(3)*.position(3) 

            phase = exp(II*phase)

            val = anom * phase * exp(-c2) / rf
            Fc(k) = Fc(k) + val

          ! if (.atomic_number==16) then
          !    stdout.show("refl #      = ",k)
          !    stdout.show("Fc contr R  = ",RE(val))
          !    stdout.show("Fc contr I  = ",IM(val))
          !    stdout.show("exp(phase)R =",RE(phase))
          !    stdout.show("exp(phase)I =",IM(phase))
          !    stdout.show("TF          = ",exp(-c2))
          !    stdout.text("k:")
          !    stdout.put(kv)
          ! end

         end
      
      end

   end

   add_derivative_dispn(dFc,base,k_pts,rf) ::: PURE
   ! Add the derivative of the anamalous dispersion correction into
   ! the calculated derivative structure factor "Fc", for a given set
   ! of "k_pts". "base" is the index of where the derivatives for 
   ! this atom start in the full derivative structure factor array.
   ! "rf" is the repetition/site symmetry factor for the atom.
   ! -- This version works for the H U_iso case --
      self :: IN
      dFc :: MAT{CPX}, INOUT
      base :: INT, IN
      k_pts :: MAT{REAL}, IN
      rf :: REAL, IN

   ENSURE(dFc.dim1==k_pts.dim1,"1st dimension of dc and k_pts are not compatible")
   ENSURE(       3==k_pts.dim2,"2nd dimension of k_pts must be 3!")

      II,anom,phase :: CPX
      sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      kv :: VEC{REAL}(3)
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      c2,c3,c4 :: REAL
      k1,k2,k3 :: REAL
      k1_k1,k2_k2,k3_k3 :: REAL
      k1_k2,k1_k3,k2_k3 :: REAL
      k,n_k :: INT
    ! val :: VEC{CPX}(9)

      II   = IMAGIFY(ONE)
      anom = .dispersion_correction

          ! if (.atomic_number==16) then
          !    stdout.show("f'          =",RE(anom))
          !    stdout.show("f''         =",IM(anom))
          !    stdout.text("position:")
          !    stdout.put(.position)
          ! end

      n_k = k_pts.dim1

      ! Temperature part, ADP4's
      if (.has_only_ADP4s_and_errors) then

         ENSURE(.atomic_number/=1,"can't add derivative dispersion corrections when refining H anharmonically with H isotropic")

         ! Get ADP tensors
         .put_ADP2_vector_to(adp2)
         .put_ADP3_vector_to(adp3)
         .put_ADP4_vector_to(adp4)

         do k = 1,n_k

            ! Scattering vector
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            kv = [k1,k2,k3]
           
            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3
           
            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
            c3 = adp3.contract_with(kv)*SIXTH
            c4 = adp4.contract_with(kv)*SIXTH*QUARTER
           
            ! Constant part of the derivative dispersion
            ! correction, harmonic part only.
            ! NOTE: division by repetition factor "rf" in sfh
            phase = k_pts(k,1)*.position(1) &
                  + k_pts(k,2)*.position(2) &
                  + k_pts(k,3)*.position(3) 
            sfh   = anom * exp(II*phase) * exp(-c2)/rf ! <--- 
           
            ! Multiples of *anharmonic* part of anamalous correction
            sf1 = sfh * (ONE - II*c3 + c4)
            sf2 = sf1 * HALF
           
            ! Pos derivatives
            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
           
            ! U2 derivatives
            dFc(k,base+ 4) = dFc(k,base+ 4) - k1_k1*sf2
            dFc(k,base+ 5) = dFc(k,base+ 5) - k2_k2*sf2
            dFc(k,base+ 6) = dFc(k,base+ 6) - k3_k3*sf2
            dFc(k,base+ 7) = dFc(k,base+ 7) - k1_k2*sf1
            dFc(k,base+ 8) = dFc(k,base+ 8) - k1_k3*sf1
            dFc(k,base+ 9) = dFc(k,base+ 9) - k2_k3*sf1
           
            ! Structure factor (harmonic)
            sf1  = sfh
           
            ! Multiples of *harmonic* part of the anomalous correction
            sf2  = sf1 * HALF
            sf4  = sf1 * QUARTER
            sf6  = sf1 * SIXTH
            sf24 = sf1 * SIXTH*QUARTER
           
            ! U3 derivatives
            dFc(k,base+10) = dFc(k,base+10) - II*k1_k1*k1*sf6
            dFc(k,base+11) = dFc(k,base+11) - II*k2_k2*k2*sf6
            dFc(k,base+12) = dFc(k,base+12) - II*k3_k3*k3*sf6
            dFc(k,base+13) = dFc(k,base+13) - II*k1_k1*k2*sf2
            dFc(k,base+14) = dFc(k,base+14) - II*k1_k1*k3*sf2
            dFc(k,base+15) = dFc(k,base+15) - II*k2_k2*k1*sf2
            dFc(k,base+16) = dFc(k,base+16) - II*k2_k2*k3*sf2
            dFc(k,base+17) = dFc(k,base+17) - II*k3_k3*k1*sf2
            dFc(k,base+18) = dFc(k,base+18) - II*k3_k3*k2*sf2
            dFc(k,base+19) = dFc(k,base+19) - II*k1*k2*k3*sf1
           
            ! U4 derivatives
            dFc(k,base+20) = dFc(k,base+20) + k1_k1*k1_k1*sf24
            dFc(k,base+21) = dFc(k,base+21) + k2_k2*k2_k2*sf24
            dFc(k,base+22) = dFc(k,base+22) + k3_k3*k3_k3*sf24
            dFc(k,base+23) = dFc(k,base+23) + k1_k1*k1_k2*sf6
            dFc(k,base+24) = dFc(k,base+24) + k1_k1*k1_k3*sf6
            dFc(k,base+25) = dFc(k,base+25) + k2_k2*k1_k2*sf6
            dFc(k,base+26) = dFc(k,base+26) + k2_k2*k2_k3*sf6
            dFc(k,base+27) = dFc(k,base+27) + k3_k3*k1_k3*sf6
            dFc(k,base+28) = dFc(k,base+28) + k3_k3*k2_k3*sf6
            dFc(k,base+29) = dFc(k,base+29) + k1_k1*k2_k2*sf4
            dFc(k,base+30) = dFc(k,base+30) + k1_k1*k3_k3*sf4
            dFc(k,base+31) = dFc(k,base+31) + k2_k2*k3_k3*sf4
            dFc(k,base+32) = dFc(k,base+32) + k1_k1*k2_k3*sf2
            dFc(k,base+33) = dFc(k,base+33) + k2_k2*k1_k3*sf2
            dFc(k,base+34) = dFc(k,base+34) + k3_k3*k1_k2*sf2

         end

      ! Temperature part, ADP3's
      else if (.has_only_ADP3s_and_errors) then

         ENSURE(.atomic_number/=1,"can't add derivative dispersion corrections when refining H anharmonically with H isotropic")

         ! Get ADP tensors
         .put_ADP2_vector_to(adp2)
         .put_ADP3_vector_to(adp3)

         do k = 1,n_k

            ! Scattering vector
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            kv = [k1,k2,k3]
           
            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3
           
            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
            c3 = adp3.contract_with(kv)*SIXTH
           
            ! Constant part of the derivative dispersion
            ! correction, harmonic part only.
            ! NOTE: division by repetition factor "rf" in sfh
            phase = k_pts(k,1)*.position(1) &
                  + k_pts(k,2)*.position(2) &
                  + k_pts(k,3)*.position(3) 
            sfh   = anom * exp(II*phase) * exp(-c2)/rf ! <---
           
            ! Multiples of *anharmonic* part of anamalous correction
            sf1 = sfh * (ONE - II*c3)
            sf2 = sf1 * HALF
           
            ! Pos derivatives
            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
           
            ! U2 derivatives
            dFc(k,base+ 4) = dFc(k,base+ 4) - k1_k1*sf2
            dFc(k,base+ 5) = dFc(k,base+ 5) - k2_k2*sf2
            dFc(k,base+ 6) = dFc(k,base+ 6) - k3_k3*sf2
            dFc(k,base+ 7) = dFc(k,base+ 7) - k1_k2*sf1
            dFc(k,base+ 8) = dFc(k,base+ 8) - k1_k3*sf1
            dFc(k,base+ 9) = dFc(k,base+ 9) - k2_k3*sf1
           
            ! Structure factor (harmonic)
            sf1  = sfh
           
            ! Multiples of *harmonic* part of the anomalous correction
            sf2  = sf1 * HALF
            sf6  = sf1 * SIXTH
           
            ! U3 derivatives
            dFc(k,base+10) = dFc(k,base+10) - II*k1_k1*k1*sf6
            dFc(k,base+11) = dFc(k,base+11) - II*k2_k2*k2*sf6
            dFc(k,base+12) = dFc(k,base+12) - II*k3_k3*k3*sf6
            dFc(k,base+13) = dFc(k,base+13) - II*k1_k1*k2*sf2
            dFc(k,base+14) = dFc(k,base+14) - II*k1_k1*k3*sf2
            dFc(k,base+15) = dFc(k,base+15) - II*k2_k2*k1*sf2
            dFc(k,base+16) = dFc(k,base+16) - II*k2_k2*k3*sf2
            dFc(k,base+17) = dFc(k,base+17) - II*k3_k3*k1*sf2
            dFc(k,base+18) = dFc(k,base+18) - II*k3_k3*k2*sf2
            dFc(k,base+19) = dFc(k,base+19) - II*k1*k2*k3*sf1
           
         end

      ! Harmonic *and* NOT H atom ...
      else if (.atomic_number>1) then

         ! Get ADP tensors
         .put_ADP2_vector_to(adp2)

         do k = 1,n_k

            ! Scattering vector
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            kv = [k1,k2,k3]
           
            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3
           
            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
           
            ! Constant part of the derivative dispersion
            ! correction, harmonic part only.
            ! NOTE: division by repetition factor "rf" in sfh
            phase = k_pts(k,1)*.position(1) &
                  + k_pts(k,2)*.position(2) &
                  + k_pts(k,3)*.position(3) 
            sfh   = anom * exp(II*phase) * exp(-c2)/rf ! <---
           
            ! Multiples of *anharmonic* part of anamalous correction
            sf1 = sfh 
            sf2 = sf1 * HALF
           
            ! Pos derivatives
            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
           
            ! U2 derivatives
            dFc(k,base+ 4) = dFc(k,base+ 4) - k1_k1*sf2
            dFc(k,base+ 5) = dFc(k,base+ 5) - k2_k2*sf2
            dFc(k,base+ 6) = dFc(k,base+ 6) - k3_k3*sf2
            dFc(k,base+ 7) = dFc(k,base+ 7) - k1_k2*sf1
            dFc(k,base+ 8) = dFc(k,base+ 8) - k1_k3*sf1
            dFc(k,base+ 9) = dFc(k,base+ 9) - k2_k3*sf1

          ! if (.atomic_number==16) then
          !    val(1) = II*k1*sf1
          !    val(2) = II*k2*sf1
          !    val(3) = II*k3*sf1
          !    val(4) = -k1_k1*sf2
          !    val(5) = -k2_k2*sf2
          !    val(6) = -k3_k3*sf2
          !    val(7) = -k1_k2*sf1
          !    val(8) = -k1_k3*sf1
          !    val(9) = -k2_k3*sf1
          !    stdout.show("refl #      = ",k)
          !    stdout.show("base        = ",base)
          !    stdout.text("Fc contr:")
          !    stdout.put(val)
          !    stdout.show("phase       =",phase)
          !    stdout.show("TF          = ",exp(-c2))
          !    stdout.text("k:")
          !    stdout.put([k1,k2,k3])
          ! end

         end

      ! Harmonic and H U_iso case ...
      else 

         ! Get ADP tensors
         .put_ADP2_vector_to(adp2)

         do k = 1,n_k

            ! Scattering vector
            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)
            kv = [k1,k2,k3]
           
            ! Component products
            k1_k1 = k1*k1
            k2_k2 = k2*k2
            k3_k3 = k3*k3
            k1_k2 = k1*k2
            k1_k3 = k1*k3
            k2_k3 = k2*k3
           
            ! U tensor contracted with k vector
            c2 = adp2.contract_with(kv)*HALF
           
            ! Constant part of the derivative dispersion
            ! correction, harmonic part only.
            ! NOTE: division by repetition factor "rf" in sfh
            phase = k_pts(k,1)*.position(1) &
                  + k_pts(k,2)*.position(2) &
                  + k_pts(k,3)*.position(3) 
            sfh   = anom * exp(II*phase) * exp(-c2)/rf ! <---
           
            ! Multiples of *anharmonic* part of anamalous correction
            sf1 = sfh 
            sf2 = HALF * sfh * (k1_k1+k2_k2+k3_k3) ! NOTE
           
            ! Pos derivatives
            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
           
            ! H U_iso derivatives; no off diagonal contribution
            dFc(k,base+ 4) = dFc(k,base+ 4) - sf2
            dFc(k,base+ 5) = dFc(k,base+ 5) - sf2
            dFc(k,base+ 6) = dFc(k,base+ 6) - sf2
           
         end

      end

   end

!   add_derivative_dispn_H_ADP_d(dFc,base,k_pts,rf) ::: PURE
!   ! Add the derivative of the anamalous dispersion correction into
!   ! the calculated derivative structure factor "Fc", for a given set
!   ! of "k_pts". "base" is the index of where the derivatives for 
!   ! this atom start in the full derivative structure factor array.
!   ! "rf" is the repetition/site symmetry factor for the atom.
!      self :: IN
!      dFc :: MAT{CPX}, INOUT
!      base :: INT, IN
!      k_pts :: MAT{REAL}, IN
!      rf :: REAL, IN
!
!   ENSURE(dFc.dim1==k_pts.dim1,"1st dimension of dc and k_pts are not compatible")
!   ENSURE(       3==k_pts.dim2,"2nd dimension of k_pts must be 3!")
!
!      II,anom,phase :: CPX
!      sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
!      kv :: VEC{REAL}(3)
!      adp2 :: MAT{REAL}(3,3)
!      adp3 :: MAT3{REAL}(3,3,3)
!      adp4 :: MAT4{REAL}(3,3,3,3)
!      c2,c3,c4 :: REAL
!      k1,k2,k3 :: REAL
!      k1_k1,k2_k2,k3_k3 :: REAL
!      k1_k2,k1_k3,k2_k3 :: REAL
!      k,n_k :: INT
!    ! val :: VEC{CPX}(9)
!
!      II   = IMAGIFY(ONE)
!      anom = .dispersion_correction
!
!          ! if (.atomic_number==16) then
!          !    stdout.show("f'          =",RE(anom))
!          !    stdout.show("f''         =",IM(anom))
!          !    stdout.text("position:")
!          !    stdout.put(.position)
!          ! end
!
!      n_k = k_pts.dim1
!
!      ! Temperature part, ADP4's
!      if (.has_only_ADP4s_and_errors) then
!
!         ! Get ADP tensors
!         .put_ADP2_vector_to(adp2)
!         .put_ADP3_vector_to(adp3)
!         .put_ADP4_vector_to(adp4)
!
!         do k = 1,n_k
!
!            ! Scattering vector
!            k1 = k_pts(k,1)
!            k2 = k_pts(k,2)
!            k3 = k_pts(k,3)
!            kv = [k1,k2,k3]
!           
!            ! Component products
!            k1_k1 = k1*k1
!            k2_k2 = k2*k2
!            k3_k3 = k3*k3
!            k1_k2 = k1*k2
!            k1_k3 = k1*k3
!            k2_k3 = k2*k3
!           
!            ! U tensor contracted with k vector
!            c2 = adp2.contract_with(kv)*HALF
!            c3 = adp3.contract_with(kv)*SIXTH
!            c4 = adp4.contract_with(kv)*SIXTH*QUARTER
!           
!            ! Constant part of the derivative dispersion
!            ! correction, harmonic part only.
!            ! NOTE: division by "rf" in sfh
!            phase = k_pts(k,1)*.position(1) &
!                  + k_pts(k,2)*.position(2) &
!                  + k_pts(k,3)*.position(3) 
!            sfh   = anom * exp(II*phase) * exp(-c2)/rf
!           
!            ! Multiples of *anharmonic* part of anamalous correction
!            sf1 = sfh * (ONE - II*c3 + c4)
!            sf2 = sf1 * HALF
!           
!            ! Pos derivatives
!            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
!            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
!            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
!           
!            ! U2 derivatives
!            dFc(k,base+ 4) = dFc(k,base+ 4) - k1_k1*sf2
!            dFc(k,base+ 5) = dFc(k,base+ 5) - k2_k2*sf2
!            dFc(k,base+ 6) = dFc(k,base+ 6) - k3_k3*sf2
!            dFc(k,base+ 7) = dFc(k,base+ 7) - k1_k2*sf1
!            dFc(k,base+ 8) = dFc(k,base+ 8) - k1_k3*sf1
!            dFc(k,base+ 9) = dFc(k,base+ 9) - k2_k3*sf1
!           
!            ! Structure factor (harmonic)
!            sf1  = sfh
!           
!            ! Multiples of *harmonic* part of the anomalous correction
!            sf2  = sf1 * HALF
!            sf4  = sf1 * QUARTER
!            sf6  = sf1 * SIXTH
!            sf24 = sf1 * SIXTH*QUARTER
!           
!            ! U3 derivatives
!            dFc(k,base+10) = dFc(k,base+10) - II*k1_k1*k1*sf6
!            dFc(k,base+11) = dFc(k,base+11) - II*k2_k2*k2*sf6
!            dFc(k,base+12) = dFc(k,base+12) - II*k3_k3*k3*sf6
!            dFc(k,base+13) = dFc(k,base+13) - II*k1_k1*k2*sf2
!            dFc(k,base+14) = dFc(k,base+14) - II*k1_k1*k3*sf2
!            dFc(k,base+15) = dFc(k,base+15) - II*k2_k2*k1*sf2
!            dFc(k,base+16) = dFc(k,base+16) - II*k2_k2*k3*sf2
!            dFc(k,base+17) = dFc(k,base+17) - II*k3_k3*k1*sf2
!            dFc(k,base+18) = dFc(k,base+18) - II*k3_k3*k2*sf2
!            dFc(k,base+19) = dFc(k,base+19) - II*k1*k2*k3*sf1
!           
!            ! U4 derivatives
!            dFc(k,base+20) = dFc(k,base+20) + k1_k1*k1_k1*sf24
!            dFc(k,base+21) = dFc(k,base+21) + k2_k2*k2_k2*sf24
!            dFc(k,base+22) = dFc(k,base+22) + k3_k3*k3_k3*sf24
!            dFc(k,base+23) = dFc(k,base+23) + k1_k1*k1_k2*sf6
!            dFc(k,base+24) = dFc(k,base+24) + k1_k1*k1_k3*sf6
!            dFc(k,base+25) = dFc(k,base+25) + k2_k2*k1_k2*sf6
!            dFc(k,base+26) = dFc(k,base+26) + k2_k2*k2_k3*sf6
!            dFc(k,base+27) = dFc(k,base+27) + k3_k3*k1_k3*sf6
!            dFc(k,base+28) = dFc(k,base+28) + k3_k3*k2_k3*sf6
!            dFc(k,base+29) = dFc(k,base+29) + k1_k1*k2_k2*sf4
!            dFc(k,base+30) = dFc(k,base+30) + k1_k1*k3_k3*sf4
!            dFc(k,base+31) = dFc(k,base+31) + k2_k2*k3_k3*sf4
!            dFc(k,base+32) = dFc(k,base+32) + k1_k1*k2_k3*sf2
!            dFc(k,base+33) = dFc(k,base+33) + k2_k2*k1_k3*sf2
!            dFc(k,base+34) = dFc(k,base+34) + k3_k3*k1_k2*sf2
!
!         end
!
!      ! Temperature part, ADP3's
!      else if (.has_only_ADP3s_and_errors) then
!
!         ! Get ADP tensors
!         .put_ADP2_vector_to(adp2)
!         .put_ADP3_vector_to(adp3)
!
!         do k = 1,n_k
!
!            ! Scattering vector
!            k1 = k_pts(k,1)
!            k2 = k_pts(k,2)
!            k3 = k_pts(k,3)
!            kv = [k1,k2,k3]
!           
!            ! Component products
!            k1_k1 = k1*k1
!            k2_k2 = k2*k2
!            k3_k3 = k3*k3
!            k1_k2 = k1*k2
!            k1_k3 = k1*k3
!            k2_k3 = k2*k3
!           
!            ! U tensor contracted with k vector
!            c2 = adp2.contract_with(kv)*HALF
!            c3 = adp3.contract_with(kv)*SIXTH
!           
!            ! Constant part of the derivative dispersion
!            ! correction, harmonic part only.
!            ! NOTE: division by "rf" in sfh
!            phase = k_pts(k,1)*.position(1) &
!                  + k_pts(k,2)*.position(2) &
!                  + k_pts(k,3)*.position(3) 
!            sfh   = anom * exp(II*phase) * exp(-c2)/rf
!           
!            ! Multiples of *anharmonic* part of anamalous correction
!            sf1 = sfh * (ONE - II*c3)
!            sf2 = sf1 * HALF
!           
!            ! Pos derivatives
!            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
!            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
!            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
!           
!            ! U2 derivatives
!            dFc(k,base+ 4) = dFc(k,base+ 4) - k1_k1*sf2
!            dFc(k,base+ 5) = dFc(k,base+ 5) - k2_k2*sf2
!            dFc(k,base+ 6) = dFc(k,base+ 6) - k3_k3*sf2
!            dFc(k,base+ 7) = dFc(k,base+ 7) - k1_k2*sf1
!            dFc(k,base+ 8) = dFc(k,base+ 8) - k1_k3*sf1
!            dFc(k,base+ 9) = dFc(k,base+ 9) - k2_k3*sf1
!           
!            ! Structure factor (harmonic)
!            sf1  = sfh
!           
!            ! Multiples of *harmonic* part of the anomalous correction
!            sf2  = sf1 * HALF
!            sf6  = sf1 * SIXTH
!           
!            ! U3 derivatives
!            dFc(k,base+10) = dFc(k,base+10) - II*k1_k1*k1*sf6
!            dFc(k,base+11) = dFc(k,base+11) - II*k2_k2*k2*sf6
!            dFc(k,base+12) = dFc(k,base+12) - II*k3_k3*k3*sf6
!            dFc(k,base+13) = dFc(k,base+13) - II*k1_k1*k2*sf2
!            dFc(k,base+14) = dFc(k,base+14) - II*k1_k1*k3*sf2
!            dFc(k,base+15) = dFc(k,base+15) - II*k2_k2*k1*sf2
!            dFc(k,base+16) = dFc(k,base+16) - II*k2_k2*k3*sf2
!            dFc(k,base+17) = dFc(k,base+17) - II*k3_k3*k1*sf2
!            dFc(k,base+18) = dFc(k,base+18) - II*k3_k3*k2*sf2
!            dFc(k,base+19) = dFc(k,base+19) - II*k1*k2*k3*sf1
!           
!         end
!
!      ! Harmonic ...
!      else 
!
!         ! Get ADP tensors
!         .put_ADP2_vector_to(adp2)
!
!         do k = 1,n_k
!
!            ! Scattering vector
!            k1 = k_pts(k,1)
!            k2 = k_pts(k,2)
!            k3 = k_pts(k,3)
!            kv = [k1,k2,k3]
!           
!            ! Component products
!            k1_k1 = k1*k1
!            k2_k2 = k2*k2
!            k3_k3 = k3*k3
!            k1_k2 = k1*k2
!            k1_k3 = k1*k3
!            k2_k3 = k2*k3
!           
!            ! U tensor contracted with k vector
!            c2 = adp2.contract_with(kv)*HALF
!           
!            ! Constant part of the derivative dispersion
!            ! correction, harmonic part only.
!            ! NOTE: division by "rf" in sfh
!            phase = k_pts(k,1)*.position(1) &
!                  + k_pts(k,2)*.position(2) &
!                  + k_pts(k,3)*.position(3) 
!            sfh   = anom * exp(II*phase) * exp(-c2)/rf
!           
!            ! Multiples of *anharmonic* part of anamalous correction
!            sf1 = sfh 
!            sf2 = sf1 * HALF
!           
!            ! Pos derivatives
!            dFc(k,base+ 1) = dFc(k,base+ 1) + II*k1*sf1
!            dFc(k,base+ 2) = dFc(k,base+ 2) + II*k2*sf1
!            dFc(k,base+ 3) = dFc(k,base+ 3) + II*k3*sf1
!           
!            ! U2 derivatives
!            dFc(k,base+ 4) = dFc(k,base+ 4) - k1_k1*sf2
!            dFc(k,base+ 5) = dFc(k,base+ 5) - k2_k2*sf2
!            dFc(k,base+ 6) = dFc(k,base+ 6) - k3_k3*sf2
!            dFc(k,base+ 7) = dFc(k,base+ 7) - k1_k2*sf1
!            dFc(k,base+ 8) = dFc(k,base+ 8) - k1_k3*sf1
!            dFc(k,base+ 9) = dFc(k,base+ 9) - k2_k3*sf1
!
!          ! if (.atomic_number==16) then
!          !    val(1) = II*k1*sf1
!          !    val(2) = II*k2*sf1
!          !    val(3) = II*k3*sf1
!          !    val(4) = -k1_k1*sf2
!          !    val(5) = -k2_k2*sf2
!          !    val(6) = -k3_k3*sf2
!          !    val(7) = -k1_k2*sf1
!          !    val(8) = -k1_k3*sf1
!          !    val(9) = -k2_k3*sf1
!          !    stdout.show("refl #      = ",k)
!          !    stdout.show("base        = ",base)
!          !    stdout.text("Fc contr:")
!          !    stdout.put(val)
!          !    stdout.show("phase       =",phase)
!          !    stdout.show("TF          = ",exp(-c2))
!          !    stdout.text("k:")
!          !    stdout.put([k1,k2,k3])
!          ! end
!           
!         end
!
!      end
!
!   end

!  ANOs

   no_of_occupied_NAOs(tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied NAOs. For this purpose,
   ! occupied is greated than 1/14. See ROBY.
      self :: IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.NAO_occupations.associated,"no NAO occupations")

      eps :: REAL

      eps = ROBY_OCCUPIED_ANO_CUTOFF
      if (present(tol)) eps = tol

      res = count(.NAO_occupations>=eps)

   end

   no_of_occupied_NOs(axiskind,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      axiskind :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.occupation_numbers.associated,"no occupation numbers")

      res = .occupation_numbers.no_of_occupied(axiskind,tol)

   end

   has_NAO_matrices result (res) ::: pure
   ! Return TRUE if the NAOs exists for the atom.
      self :: IN
      res :: BIN

      res = .NAOs.associated AND .NAO_occupations.associated

   end

   has_ANO_matrices result (res) ::: pure
   ! Return TRUE if the ANOs exists for the atom.
      self :: IN
      res :: BIN

      res = .natural_orbitals.associated AND .occupation_numbers.associated

   end

!  Bond distances and bonding

   bond_distance_to(b,angstrom) result (res) ::: PURE
   ! Return the bond distance between atoms "a" and "b"
      self :: IN
      b :: ATOM, IN
      angstrom :: BIN, optional, IN
      res :: REAL

      r :: VEC{REAL}(3)
      change :: BIN

      r = b.position - .position
      res = sqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * STR:conversion_factor("angstrom")

   end

   is_bonded_to(b,range_factor) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      b :: ATOM, IN
      range_factor :: REAL, IN, optional
      res :: BIN

      t,bond,bond_min,bond_max,dx,dy,dz,r2 :: REAL
      Za,Zb,as,bs :: INT

      Za =  .atomic_number
      Zb = b.atomic_number
      as =  .site_disorder_group
      bs = b.site_disorder_group

      if      (Za<1) then;                       res = FALSE
      else if (Zb<1) then;                       res = FALSE
      else if (Za>covalent_radii_ccdc.dim) then; res = FALSE
      else if (Zb>covalent_radii_ccdc.dim) then; res = FALSE
      else if (as*bs>0 AND as/=bs) then;         res = FALSE
      else

         t = atom_bonded_range_factor
         if (present(range_factor)) t = range_factor

         bond = .covalent_radius_ccdc + b.covalent_radius_ccdc
         bond_min = max(bond - t,ZERO)
         bond_max =     bond + t

         ! For HH, nothing closer than 0.9A
         if (self.atomic_number==1 AND b.atomic_number==1) bond_min = 0.7d0*BOHR_PER_ANGSTROM

         dx = abs(.position(1) - b.position(1))
         dy = abs(.position(2) - b.position(2))
         dz = abs(.position(3) - b.position(3))
         if      (dx>bond_max) then; res = FALSE
         else if (dy>bond_max) then; res = FALSE
         else if (dz>bond_max) then; res = FALSE
         else
            r2 = dx*dx + dy*dy + dz*dz
            res = (r2 < bond_max*bond_max) AND (r2 > bond_min*bond_min)
         end

      end

   end

   is_nearby_to(b,dist) result (res)
   ! Return TRUE if atom "self" and atom "b" are nearby, i.e. within length
   ! "dist".
      b :: ATOM
      dist :: REAL
      res :: BIN
      tmp :: VEC{REAL}(3)
      r2 :: REAL
      tmp = .position - b.position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end
   end

   is_vdw_bonded_to(b,range_factor,vdw_range_pc) result (res) ::: pure
   ! Return true if "self" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not vand-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 10%). This uses the CCDC method, as documented in
   ! Brun et al (2011) Struct. Sci 67 p. 333-49.
      self :: IN
      b :: ATOM, IN
      range_factor,vdw_range_pc :: REAL, IN, optional
      res :: BIN

      t,bond,bond_max,dx,dy,dz,r2 :: REAL
      Za,Zb,as,bs,ag,bg :: INT

      Za =  .atomic_number
      Zb = b.atomic_number
      as =  .site_disorder_group
      bs = b.site_disorder_group
      ag =  .group
      bg = b.group

      if      (Za<1) then; res = FALSE
      else if (Zb<1) then; res = FALSE
      else if (Za>covalent_radii_ccdc.dim)    then; res = FALSE
      else if (Zb>covalent_radii_ccdc.dim)    then; res = FALSE
      else if (as*bs>0 AND as==bs)            then; res = FALSE
      else if (ag*bg>0 AND ag==bg)            then; res = FALSE
      else if (.is_bonded_to(b,range_factor)) then; res = FALSE
      else

         t = ONE+0.01*atom_vdw_bonded_range_pc
         if (present(vdw_range_pc)) t = ONE + 0.01*vdw_range_pc

         bond = .vdw_radius_ccdc + b.vdw_radius_ccdc
         bond_max = bond*t

         dx = abs(.position(1) - b.position(1))
         dy = abs(.position(2) - b.position(2))
         dz = abs(.position(3) - b.position(3))
         if      (dx>bond_max) then; res = FALSE
         else if (dy>bond_max) then; res = FALSE
         else if (dz>bond_max) then; res = FALSE
         else
            r2 = dx*dx + dy*dy + dz*dz
            res = (r2 < bond_max*bond_max)
         end

      end

   end

   minimum_basis_exponent result (res) ::: pure
   ! Return the minimum exponent in the basis.
      self :: IN
      res :: REAL

      res = ZERO

      if (.coppensbasis.associated)     then; res = .coppensbasis.min_exponent
      else if (.slaterbasis.associated) then; res = .slaterbasis.min_exponent
      else if (.basis.associated)       then; res = .basis.min_exponent
      end

   end

   r_max(cutoff) result (res) ::: pure
   ! Return the distance "r_max" at which the basis function with the lowest
   ! exponent is less than the value "cutoff".
      self :: IN
      cutoff :: REAL, IN
      res :: REAL

      if (.basis.disassociated) then; res = ZERO
      else;                       res = .basis.r_max(cutoff)
      end

   end

   r2_max(cutoff) result (res) ::: pure
   ! Return the squared distance "r2_max" at which the basis function with the
   ! lowest exponent is less than the value "cutoff".
      self :: IN
      cutoff :: REAL, IN
      res :: REAL

      if (.basis.disassociated) then; res = ZERO
      else;                       res = .basis.r2_max(cutoff)
      end

   end

   covalent_radius_ccdc result (res) ::: public, elemental
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      res :: REAL
      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = covalent_radii_ccdc(.atomic_number)*BOHR_PER_ANGSTROM
      end
   end

   vdw_radius_ccdc result (res) ::: public, elemental
   ! Returns the CCDC vdw radius for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = vdw_radii_ccdc(.atomic_number)*BOHR_PER_ANGSTROM
      end

   end

!  Properties

   has_dipole result (res) ::: pure
   ! Return TRUE if the atomic dipole is nonzero.
      self :: IN
      res :: BIN

      res = NOT .dipole.is_zero

   end

   has_polarisability result (res) ::: PURE
   ! Return TRUE if the atomic dipole is nonzero.
      self :: IN
      res :: BIN

      res =  NOT .charge_polarisability.is_zero &
          OR NOT .dipole_polarisability.is_zero

   end

   has_recognised_label result (res) ::: pure
   ! Return TRUE if the label corresponds to a recognised chemical element.
      self :: IN
      res :: BIN

      label,symbol :: STR
      lensym :: INT
      error :: BIN

      label = .label

      if (label.is_int) then    

         ! The label must be the atomic number
         res = TRUE

      else                      

         ! First part of the label is the element symbol
         lensym = label.index_of_nonalphabetical-1
         error = lensym>2 OR lensym==0
         if (error) then
            res = FALSE
            return
         end

         symbol = label(1:lensym)
         symbol(1:1).to_upper_case
         symbol(2:2).to_lower_case

         if (symbol=="D" OR symbol=="T" OR symbol(1:2)=="El") then
            res = TRUE
         else if (any(element_symbols(1:)==symbol(1:2))) then
            res = TRUE
         else
            res = FALSE
         end

      end
   end

!  Dispersion coefficients and polarisabilities

   Spackman86_a_6_dispersion_coeff result (res) ::: public, elemental
   ! Returns Spackman's a-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Spackman86_a_6_disp_coeff(.atomic_number)
      end

   end

   Spackman86_b_repulsion_coeff result (res) ::: public, elemental
   ! Returns Spackman's b-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Spackman86_b_exp_prefactor(.atomic_number)
      end

   end

   Spackman86_c_repulsion_coeff result (res) ::: public, elemental
   ! Returns Spackman's c-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Spackman86_c_exp_exponent(.atomic_number)
      end

   end

   Grimme06_a_6_dispersion_coeff result (res) ::: public, elemental
   ! Return Grimme's a-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Grimme06_a_6_disp_coeff(.atomic_number)
      end

   end

   Grimme06_r_0_dispersion_coeff result (res) ::: public, elemental
   ! Return Grimme's a-coefficient for this atom
      self :: IN
      res :: REAL

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = Grimme06_r_0_disp_coeff(.atomic_number)
      end

   end

   Thakkar_atomic_dipole_polarizability(charged) result (res) ::: public, elemental
   ! Return Thakkar atomic dipole polarizability for this atom
      self :: IN
      res :: REAL
      charged :: BIN, IN, optional
      use_charged :: BIN
      use_charged = FALSE

      if (present(charged)) use_charged = charged

      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else
         if (use_charged) then; res = Charged_atomic_polarizibility(.atomic_number)
         else; res = Thakkar_atomic_polarizability(.atomic_number)
         end
      end

   end

!  ====================
!  ADP inquiry methods
!  ====================

   has_NPD_ADP result (res) ::: PURE
   ! Return TRUE if the ADP is non-zero and non-positive definite.
      self :: IN
      res :: BIN

      evec :: MAT{REAL}(3,3)
      eval :: VEC{REAL}(3)

      res = FALSE

      if (NOT .ADP_tensor.is_zero) then
         .ADP_tensor.diagonalize_by_jacobi(eval,evec)
         res = any(eval<ZERO)
      end

   end

   has_flat_ADP(ratio) result (res) ::: PURE
   ! Return TRUE if the ADP is flat i.e. the the max to
   ! the min eigenvalue is greater than "ratio" (or FOUR
   ! if not supplied).
      self :: IN
      ratio :: REAL, IN, optional
      res :: BIN

      evec :: MAT{REAL}(3,3)
      eval :: VEC{REAL}(3)
      rat :: REAL

      rat = FOUR
      if (present(ratio)) rat = ratio

      res = FALSE

      if (NOT .ADP_tensor.is_zero) then
         .ADP_tensor.diagonalize_by_jacobi(eval,evec)
         res = abs(maxval(eval)/minval(eval)) > rat
      end

   end

   ADP_principal_axis_ratio result (res) ::: PURE
   ! Return the actual max/min ADP principal axis ratio
   ! (or 1000 if the min eigenvalue is zero).
      self :: IN
      res :: REAL

      evec :: MAT{REAL}(3,3)
      eval :: VEC{REAL}(3)
      mineval,maxeval :: REAL

      res = ZERO

      if (NOT .ADP_tensor.is_zero) then
         .ADP_tensor.diagonalize_by_jacobi(eval,evec)
         maxeval = maxval(eval)
         mineval = minval(eval)
         res = 1000.0d0
         if (abs(mineval)>TOL(3)) res = maxeval/mineval
      end

   end

!  ====================
!  pADP inquiry methods
!  ====================

   has_pADPs result (res) ::: pure
   ! Return TRUE if there are pADP's.
      self :: IN
      res :: BIN
      res = .pADP_vector.associated
   end

   has_ADP3s result (res) ::: pure
   ! Return TRUE if there are third-order ADP's
      self :: IN
      res :: BIN
      res = .has_pADPs
      if (NOT res) return
      res = res AND .pADP_vector.dim>9
   end

   has_ADP4s result (res) ::: pure
   ! Return TRUE if there are fourth-order ADP's
      self :: IN
      res :: BIN
      res = .has_pADPs
      if (NOT res) return
      res = res AND .pADP_vector.dim>19
   end


   has_pADPs_and_errors result (res) ::: pure
   ! Return TRUE if there are pADP's *and* their errors
   ! Also check if the dimensions are equal.
      self :: IN
      res :: BIN
      res = .pADP_vector.associated AND .pADP_errors.associated
      if (NOT res) return
      res = .pADP_vector.dim==.pADP_errors.dim
   end

   has_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are third-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim>9
   end

   has_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are fourth-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim>19
   end


   has_only_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are *only* third-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim==19
   end

   has_only_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are *only* fourth-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim==34
   end

   has_anharmonic_ADPs result (res) ::: pure
   ! Return TRUE if there are anharmonic ADP's
      self :: IN
      res :: BIN
      res = .has_only_ADP3s_and_errors OR .has_only_ADP4s_and_errors
   end

   no_of_pADPs result (res) ::: pure
   ! Return the no. of positional/ADP parameters for refinement.
   ! NOTE: positions and second-order ADP's are always refined.
   ! i.e. there are always at least 9 pADPs, even if the pADP
   ! vector is not created.
      self :: IN
      res :: INT

      if (.pADP_vector.associated) then; res = .pADP_vector.dim
      else;                              res = 9
      end

   end


   tag_pADP_label(par_index) result (res) ::: PURE
   ! Return the unique tag with the positional-ADP label for parameter
   ! with index "par_index" e.g. "N13 Uxxy".
      self :: IN
      par_index :: INT, IN
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")

      if (par_index<=3) then
         res = trim(.tag)//" p"//trim(::pADP_index_label(par_index))
      else
         res = trim(.tag)//" U"//trim(::pADP_index_label(par_index))
      end

   end

   pADP_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP label for parameter with index
   ! "par_index". The specific "form" of the ADP's may be given;
   ! the default is "xyz-repeated" e.g. "xxyy. For other forms see
   ! the code below.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")

      fmt :: STR

      ! Set the symbol
      if (par_index<=3) then

         res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))

      else

         fmt = "xyz-repeated"
         if (present(form)) fmt = form

         res = " "

         select case (fmt)
            case ("underscore-123-repeated"); res = "U_"//trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("underscore-xyz-repeated"); res = "U_"//trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("underscore-xyz-power   "); res = "U_"//trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case ("123-repeated           "); res = "U" //trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("xyz-repeated           "); res = "U" //trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("xyz-power              "); res = "U" //trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
         end

      end

   end

   pADP_index_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP index label for parameter with index
   ! "par_index". The specific "form" of the ADP's may be given;
   ! the default is "xyz-repeated" e.g. "xxyy. For other forms see
   ! the code below.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")

      fmt :: STR

      ! Set the symbol
      if (par_index<=3) then

         res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))

      else

         fmt = "xyz-repeated"
         if (present(form)) fmt = form

         res = " "

         select case (fmt)
            case ("underscore-123-repeated"); res = trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("underscore-xyz-repeated"); res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("underscore-xyz-power   "); res = trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case ("123-repeated           "); res = trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("xyz-repeated           "); res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("xyz-power              "); res = trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
         end

      end

   end

   ADP2_index_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP2 index label for parameter with index "par_index"
      self :: IN
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,6]),"par_index out of range")

      res = trim(::pADP_index_label(par_index+3,form))

   end

   ADP3_index_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP3 index label for parameter with index "par_index"
      self :: IN
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,10]),"par_index out of range")

      res = trim(::pADP_index_label(par_index+9,form))

   end

   ADP4_index_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP4 index label for parameter with index "par_index"
      self :: IN
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,15]),"par_index out of range")

      res = trim(::pADP_index_label(par_index+19,form))

   end

   ADP_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP label for parameter with index "par_index".
   ! Higher order indices can be obtained assuming they follow on in
   ! the usual pADP/gaussian lexical order.
      self :: IN
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,31]),"par_index out of range")

      res = "U_"//trim(::pADP_index_label(par_index+3,form))

   end

   ADP3_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP3 label for parameter with index "par_index"
      self :: IN
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,10]),"par_index out of range")

      res = "U"//trim(::pADP_index_label(par_index+9,form))

   end

   ADP4_label(par_index,form) result (res) ::: selfless, PURE
   ! Return the ADP4 label for parameter with index "par_index"
      self :: IN
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,15]),"par_index out of range")

      res = "U"//trim(::pADP_index_label(par_index+19,form))

   end

!  =========
!  Invarioms
!  =========

   allred_rochow_en result (res)
   ! Returns the Allred-Rochow EN for this atom
      res :: REAL
      if      (.atomic_number<0 ) then; res = ZERO
      else if (.atomic_number>82) then; res = 1.0d0
      else;                             res = allred_rochow_electronegs(.atomic_number)*0.01d0
      end
   end

   invariom_covalent_radius result (res)
   ! Returns the covalent radius for this atom
      res :: REAL
      if      (.atomic_number<0  ) then; res = ZERO
      else if (.atomic_number>109) then; res = 1.0d0
      else;                              res = covalent_radii_invariom(.atomic_number)*0.01d0
      end
   end

   get_invariom_rotation(U,actual,reference,L,fail) ::: selfless
   ! Returns the invariom rotation matrix "U" which matches
   ! coordinates "reference" to "actual" in a least squares sense.
   ! Return the mean fitting error "L" or else "fail"  for failure.
      U :: MAT{REAL}, OUT
      actual,reference :: MAT{REAL}, IN
      L :: REAL
      fail :: BIN

   ENSURE(U.is_square,"U must be square")
   ENSURE(U.dim==actual.dim2,"U incompatible with actual")
   ENSURE(reference.dim2==actual.dim2,"reference incompatible with actual")

      U0,X,Rd :: MAT{REAL}*
      d,n,p,q,i,iteration :: INT
      val :: REAL

      ! Set dimension, number of points to fit
      d = U.dim1
      n = reference.dim2

      ! Set minimum L value
      L = ZERO

      ! Start with U being unit matrix
      U.to_unit_matrix

      ! Create antisymmetric matrix X, temporary rotation U
      X.create(d,d)
      U0.create(d,d)
      Rd.create(reference.dim1,reference.dim2)

      ! Repeatedly update U until converged
      iteration = 0
      fail = FALSE
      do

         iteration = iteration + 1

         ! Rotate actual positions
         Rd.to_product_of(U,actual,transpose_A=TRUE)

         ! Get the derivative of L wrt. X_pq
         do p = 1,d
            do q = 1,p
               val = ZERO
               do i = 1,n
                  val = val + Rd(p,i)*reference(q,i) - Rd(q,i)*reference(p,q)
               end
               val = -TWO*val
               X(p,q) =  val
               X(q,p) = -val
            end
            X(p,p) = ZERO
         end

         ! Get maximum gradient
         val = maxval(abs(X))

         ! Exit if gradient converged or too many iteration
         if (val<TOL(4)) exit
         fail = iteration==1000
         if (fail) exit

         ! Otherwise scale X so the maximum value is less than 0.1
         val = TOL(1)/val
         X = X*val

         ! Exponentiate X
         X.exponentiate_to(U0)

         ! Update U
         X.to_product_of(U,U0)
         U = X

      end

      ! Clean up
      Rd.destroy; U0.destroy; X.destroy

      ! If failed, return, otherwise calculate L
      if (fail) return

      Rd.create(reference.dim1,reference.dim2)
      Rd.to_product_of(U,reference)

      L = ZERO
      do i = 1,d
         L = L + dot_product(actual(:,i),actual(:,i)) &
               + dot_product(reference(:,i),reference(:,i)) &
               - TWO*dot_product(actual(:,i),Rd(:,i))
      end
      L = sqrt(L)/d

      Rd.destroy

   end

!  =============================
!  ADP density plotting routines
!  =============================

   make_ADP2_grid(g,pt) 
   ! Make the effective ADP for a series of (Nx3) points "pt" and put
   ! the values into the grid vector "g".
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(NOT .ADP_tensor.is_zero,"no ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      u,eval :: VEC{REAL}(3)
      LL :: MAT{REAL}(3,3)
      n_pt,i :: INT
      det,fac :: REAL


      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      ! Harmonic part. Note: U2^{-1} is the matrix for the PDF
      ! in cartesian coordinates.
      eval  = ONE/eval
      det   = product(eval)
      fac   = sqrt(det/(TWO*PI)**3)

      n_pt = g.dim
      do i = 1,n_pt
         u     = pt(i,:) - .position
         u     = matmul(u,LL)
         g(i)  = fac * exp(-HALF*sum(u*eval*u))
      end


   end

   make_ADP2_exponent_grid(g,pt) 
   ! Make the effective ADP2 PDF exponents for a series of (Nx3)
   ! points "pt" and put the values into the grid vector "g".
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      u,eval :: VEC{REAL}(3)
      LL :: MAT{REAL}(3,3)
      n_pt,i :: INT
      det,fac,top :: REAL


      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      ! Harmonic part. Note: U2^{-1} is the matrix for the PDF
      ! in cartesian coordinates.
      eval  = ONE/eval
      det   = product(eval)
      fac   = sqrt(det/(TWO*PI)**3)

      n_pt = g.dim
      do i = 1,n_pt
         u     = pt(i,:) - .position
         u     = matmul(u,LL)
         top   = -HALF*sum(u*eval*u)
          g(i) = top
      end

   end

   make_ADP_grid(g,pt,unit_cell)
   ! Make the ADP PDF values for a series of (Nx3) points "pt" and put
   ! the values into the grid vector "g". Supply "unit_cell" for
   ! reciprocal matrix, for the anharmonic constants.
   ! See Coppens, International Tables for Crystlography vol B p. 22
   ! equations (1.2.12.3) and (1.2.12.4)
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      unit_cell :: UNIT_CELL, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      n :: VEC{INT}(3)
      u,eval :: VEC{REAL}(3)
      delta :: MAT{INT}(3,3)
      LL :: MAT{REAL}(3,3)
      U3 :: MAT3{REAL}(3,3,3)
      U4 :: MAT4{REAL}(3,3,3,3)
      n_pt,i,j,k,l,m :: INT
      det,top,fac,H :: REAL
      P0,g3,g4 :: VEC{REAL}*

      ! Harmonic grid
      n_pt = g.dim
      P0.create(n_pt)

      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      ! Harmonic part. Note: U2^{-1} is the matrix for the PDF
      ! in cartesian coordinates.
      eval  = ONE/eval
      det   = product(eval)
      fac   = sqrt(det/(TWO*PI)**3)

      do i = 1,n_pt
         u     = pt(i,:) - .position
         u     = matmul(u,LL)
         top   = -HALF*sum(u*eval*u)
         P0(i) = fac * exp(top)
      end

      g = P0

      if (.has_ADP3s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP3_vector_to(U3)
         U3.change_basis_using(unit_cell.reciprocal_matrix)
         U3.change_basis_using(LL)

         delta.to_unit_matrix

         g3.create(n_pt)
         g3 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g3(i) = g3(i) + U3(j,k,l)*H
            end

         end
         end
         end

         g = g + P0*g3/SIX

         g3.destroy

      end

      if (.has_ADP4s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP4_vector_to(U4)
         U4.change_basis_using(unit_cell.reciprocal_matrix)
         U4.change_basis_using(LL)

         delta.to_unit_matrix

         g4.create(n_pt)
         g4 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3
         do m = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)+delta(:,m)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g4(i) = g4(i) + U4(j,k,l,m)*H
            end

         end
         end
         end
         end

         g = g + P0*g4/(FOUR*SIX)

         g4.destroy

      end

      P0.destroy

   end

   make_ADP_exponent_grid(g,pt,unit_cell)
   ! Make the effective ADP PDF exponent values for a series of (Nx3)
   ! points "pt" and put the values into the grid vector "g". Supply
   ! "unit_cell" for reciprocal matrix, for the anharmonic constants.
   ! See Coppens, International Tables for Crystlography vol B p. 22
   ! equations (1.2.12.3) and (1.2.12.4)
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      unit_cell :: UNIT_CELL, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      n :: VEC{INT}(3)
      u,eval :: VEC{REAL}(3)
      delta :: MAT{INT}(3,3)
      LL :: MAT{REAL}(3,3)
      U3 :: MAT3{REAL}(3,3,3)
      U4 :: MAT4{REAL}(3,3,3,3)
      n_pt,i,j,k,l,m :: INT
      det,top,fac,H :: REAL
      P0,g3,g4 :: VEC{REAL}*

      ! Harmonic grid
      n_pt = g.dim
      P0.create(n_pt)

      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      ! Harmonic part. Note: U2^{-1} is the matrix for the PDF
      ! in cartesian coordinates.
      eval  = ONE/eval
      det   = product(eval)
      fac   = sqrt(det/(TWO*PI)**3)

      do i = 1,n_pt
         u     = pt(i,:) - .position
         u     = matmul(u,LL)
         top   = -HALF*sum(u*eval*u)
         P0(i) = fac*exp(top)
      end

      g = P0

      if (.has_ADP3s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP3_vector_to(U3)
         U3.change_basis_using(unit_cell.reciprocal_matrix)
         U3.change_basis_using(LL)

         delta.to_unit_matrix

         g3.create(n_pt)
         g3 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g3(i) = g3(i) + U3(j,k,l)*H
            end

         end
         end
         end

         g = g + P0*g3/SIX

         g3.destroy

      end

      if (.has_ADP4s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP4_vector_to(U4)
         U4.change_basis_using(unit_cell.reciprocal_matrix)
         U4.change_basis_using(LL)

         delta.to_unit_matrix

         g4.create(n_pt)
         g4 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3
         do m = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)+delta(:,m)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g4(i) = g4(i) + U4(j,k,l,m)*H
            end

         end
         end
         end
         end

         g = g + P0*g4/(FOUR*SIX)

         g4.destroy

      end

      ! Make g the effecvtive exponent
      g = log(g/fac)

      P0.destroy

   end

   make_AADP_PDF_correction_grid(g,pt)
   ! Make the anharmonic ADP correction to the PDF values (this are
   ! all the purely cubic and quartic terms, not including the unity
   ! factor) for a series of (Nx3) points "pt" and put the values into
   ! the grid vector "g". Supply "unit_cell" for reciprocal matrix.
   ! See Coppens, International Tables for Crystlography vol B p. 22
   ! equations (1.2.12.3) and (1.2.12.4)
   ! NOTE: these numbers are multiplied by 10^9
      self :: IN
      g :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   DIE_IF(.ADP_tensor.is_zero,"no ADPs")
   DIE_IF(NOT .has_ADP3s_and_errors,"no third order ADPs")
   DIE_IF(NOT .has_ADP4s_and_errors,"no fourth order ADPs")
   ENSURE(pt.dim2==3,"pt, dim2 is not 3")
   ENSURE(pt.dim1==g.dim1,"pt and g, inconsistent")

      n :: VEC{INT}(3)
      u,eval :: VEC{REAL}(3)
      delta :: MAT{INT}(3,3)
      LL :: MAT{REAL}(3,3)
      U3 :: MAT3{REAL}(3,3,3)
      U4 :: MAT4{REAL}(3,3,3,3)
      n_pt,i,j,k,l,m :: INT
      H :: REAL
      g3,g4 :: VEC{REAL}*

      n_pt = g.dim

      ! Get ADP principal axes
      .ADP_tensor.solve_symmetric_eigenproblem(eval,LL)

      g = ZERO

      if (.has_ADP3s_and_errors) then

         ! Change to principal axis system
         .put_ADP3_vector_to(U3)
         U3.change_basis_using(LL)

         delta.to_unit_matrix

         g3.create(n_pt)
         g3 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g3(i) = g3(i) + U3(j,k,l)*H
            end

         end
         end
         end

         g = g3/SIX

         g3.destroy

      end

      if (.has_ADP4s_and_errors) then

         ! Change to Coppens "c" coefficients
         .put_ADP4_vector_to(U4)
         U4.change_basis_using(LL)

         delta.to_unit_matrix

         g4.create(n_pt)
         g4 = 0

         do j = 1,3
         do k = 1,3
         do l = 1,3
         do m = 1,3

            n = delta(:,j)+delta(:,k)+delta(:,l)+delta(:,m)

            do i = 1,n_pt
               u = pt(i,:) - .position
               u = matmul(u,LL)
               H = u.hermite_polynomial_prob(n)
               g4(i) = g4(i) + U4(j,k,l,m)*H
            end

         end
         end
         end
         end

         g = g + g4/(FOUR*SIX)

         g4.destroy

      end

      g = 1.0d+9*g

   end

!  =========================
!  Density plotting routines
!  =========================

   make_density_grid(density_grid,pt,occ) ::: PURE
   ! Make the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.basis_kind.is_one_of(["gaussian","slater  ","coppens "]),"unknwon .basis_kind, "//trim(.basis_kind))

      select case (.basis_kind)

      case ("gaussian")
         if (.use_interpolator AND .interpolator.associated) then
            .make_interpolated_density(density_grid,pt,occ)
         else
            ENSURE(.basis.associated,"no basis")
            ENSURE(.natural_orbitals.associated,"no natural_orbitals")
            if (.natural_orbitals.number_kind=="real") then; .make_density_grid_r(density_grid,pt,occ)
            else;                                            .make_density_grid_c(density_grid,pt,occ)
            end
         end

      case ("slater")
         ENSURE(.slaterbasis.associated,"no slaterbasis")
         .slaterbasis.make_density_grid(density_grid,pt,.position,occ)

      case ("coppens")
         ENSURE(.coppensbasis.associated,"no coppensbasis")
         .coppensbasis.make_density_grid(density_grid,pt,.position,occ)

      end

   end

   add_density_grid(density_grid,pt,occ) ::: PURE
   ! Add the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector.
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.basis_kind.is_one_of(["gaussian","slater  ","coppens "]),"unknwon .basis_kind, "//trim(.basis_kind))

      select case (.basis_kind)

      case ("gaussian")
         if (.use_interpolator AND .interpolator.associated) then
            .add_interpolated_density(density_grid,pt,occ)
         else
            ENSURE(.basis.associated,"no basis")
            ENSURE(.natural_orbitals.associated,"no natural orbitals")
            if (.natural_orbitals.number_kind=="real") then; .add_density_grid_r(density_grid,pt,occ)
            else;                                            .add_density_grid_c(density_grid,pt,occ)
            end
         end

      case ("slater")
         ENSURE(.slaterbasis.associated,"no slaterbasis")
         .slaterbasis.add_density_grid(density_grid,pt,.position,occ)

      case ("coppens")
         ENSURE(.coppensbasis.associated,"no coppensbasis")
         .coppensbasis.add_density_grid(density_grid,pt,.position,occ)

      end

   end

   make_density_grid_r(density_grid,pt,occ) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      NO :: VEC{REAL}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      density_grid = ZERO ! set to zero

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
         .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
         density_grid = density_grid + .occupation_numbers.restricted(n)*NO*NO
      end

      if (do_occ) density_grid = occ*density_grid

      NO.destroy

   end

   add_density_grid_r(density_grid,pt,occ) ::: PURE
   ! Add the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      NO :: VEC{REAL}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      if (do_occ) then
        do n = 1,n_occ
          .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
          density_grid = density_grid + occ*.occupation_numbers.restricted(n)*NO*NO
        end
      else
        do n = 1,n_occ
          .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
          density_grid = density_grid +     .occupation_numbers.restricted(n)*NO*NO
        end
      end

      NO.destroy

   end

   make_density_grid_c(density_grid,pt,occ) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
         do_occ = TRUE
      end
      end

      density_grid = ZERO ! set to zero

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
         .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
         density_grid = density_grid + .occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
      end

      if (do_occ) density_grid = occ*density_grid

      NO.destroy

   end

   add_density_grid_c(density_grid,pt,occ) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
         do_occ = TRUE
      end
      end

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      if (do_occ) then
         do n = 1,n_occ
            .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
            density_grid = density_grid &
                         + occ*.occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
         end
      else
         do n = 1,n_occ
            .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
            density_grid = density_grid &
                         + .occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
         end
      end

      NO.destroy

   end

   make_density_grid(density_grid,pt,D,occ) ::: PURE
   ! Make the "density_grid" for the supplied points "pt" from a
   ! density matrix "D"
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(D.is_square,"D, not square")
   ENSURE(D.dim1==.basis.no_of_basis_functions,"D, wrong size")

      g :: MAT{REAL}*
      W :: VEC{REAL}*
      i :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      W.create(D.dim1)
      g.create(pt.dim1,D.dim1)

      .make_AO_grid(g,pt,.position)

      do i = 1,pt.dim1
         W.to_product_of(D,g(i,:),transpose_a=TRUE)
         density_grid(i) = sum(W*g(i,:))
      end

      if (do_occ) density_grid = occ*density_grid

      W.destroy
      g.destroy

   end

   add_density_grid(density_grid,pt,D,occ) ::: PURE
   ! Add the "density_grid" for the supplied points "pt" from a
   ! density matrix "D"
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(D.is_square,"D, not square")
   ENSURE(D.dim1==.basis.no_of_basis_functions,"D, wrong size")

      g :: MAT{REAL}*
      W :: VEC{REAL}*
      i :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      W.create(D.dim1)
      g.create(pt.dim1,D.dim1)

      .make_AO_grid(g,pt,.position)

      if (do_occ) then

        do i = 1,pt.dim1
           W.to_product_of(D,g(i,:),transpose_a=TRUE)
           density_grid(i) = density_grid(i) + occ*sum(W*g(i,:))
        end

      else

        do i = 1,pt.dim1
           W.to_product_of(D,g(i,:),transpose_a=TRUE)
           density_grid(i) = density_grid(i) + sum(W*g(i,:))
        end

      end

      W.destroy
      g.destroy

   end


!   make_d_density_grid(d0_density,d1_density,d2_density,pt)
!   ! Work out the 1st derivative density "d1_density" and 2nd
!   ! derivative "d2_density" on a set of points "pt" for interpolated
!   ! densities.
!      self :: IN
!      d0_density :: VEC{REAL}, OUT
!      d1_density :: MAT{REAL}, OUT
!      d2_density :: MAT3{REAL}, OUT
!      pt :: MAT{REAL}, IN
!   ENSURE(d0_density.dim==pt.dim1,"inconsistent number of points")
!      select case (.basis_kind)
!         case ("gaussian")
!            DIE("gaussian case, use different routines")
!         case ("slater")
!            ENSURE(.slaterbasis.associated,"no slaterbasis")
!            .slaterbasis.make_d_density_grid(d0_density,d1_density,d2_density,pt,.position)
!         case ("coppens")
!            DIE("not implemented yet")
!         case default
!            UNKNOWN(.basis_kind)
!      end
!      if (NOT .site_occupancy.same_as(ONE)) then
!         d0_density = .site_occupancy*d0_density
!         d1_density = .site_occupancy*d1_density
!         d2_density = .site_occupancy*d2_density
!      end
!   end

!  ========================
!  Orbital density routines
!  ========================

   make_AO_grid(g,pt,pos) ::: PURE
   ! Evaluate the AO density grid "g" on a set of grid points "pt" for
   ! an atom at position "pos".
      self :: IN
      g :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim1==g.dim1,"pt and g, incompatible")
   ENSURE(.basis.no_of_basis_functions==g.dim2,"pt and g, incompatible")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sh :: SHELL1*
      n_shell,f,l,s :: INT

      n_shell = .basis.no_of_shells

      l = 0

      do s = 1,n_shell

         sh.create_copy(.basis.shell(s),pos)

         f = l + 1
         l = f + sh.n_bf - 1

         sh.make_grid(g(:,f:l),pt)

         sh.destroy

      end

   end

   make_orbital_grid_r(g,orb,pt,square) ::: PURE
   ! Evaluate the orbital density grid "g" for *one* AO-basis
   ! coefficient orbital vector "orb" on a set of grid points "pt" for
   ! an atom.  If "square" is present and TRUE, the square of the
   ! orbital density is returned.
      self :: IN
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional, IN

      .make_orbital_grid_r(g,orb,pt,.position,square)

   end

   make_orbital_grid_r(g,orb,pt,pos,square) ::: PURE
   ! Evaluate the orbital density grid "g" for *one* AO-basis
   ! coefficient orbital vector "orb" on a set of grid points "pt" for
   ! an atom at position "pos". If "square" is present and TRUE, the
   ! square of the orbital density is returned.
      self :: IN
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sq :: BIN
      sh :: SHELL1*
      sh_grid :: MAT{REAL}*
      n_pt,n_shell,f,l,s :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      l = 0

      do s = 1,n_shell

         sh.create_copy(.basis.shell(s),pos)

         f = l + 1
         l = f + sh.n_bf - 1
         sh_grid.create(n_pt,sh.n_bf)

         sh.make_grid(sh_grid,pt)
         g.plus_product_of(sh_grid,orb(f:l))

         sh_grid.destroy
         sh.destroy

      end

      if (sq) g = g*g

   end

   make_orbital_grid_c(g,orb,pt,pos,square) ::: PURE
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      self :: IN
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sq :: BIN
      sh :: SHELL1*
      sh_grid :: MAT{REAL}*
      n_pt,n_shell,f,l,s :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      l = 0

      do s = 1,n_shell

         sh.create_copy(.basis.shell(s),pos)

         f = l + 1
         l = f + sh.n_bf - 1
         sh_grid.create(n_pt,sh.n_bf)

         sh.make_grid(sh_grid,pt)
         g.plus_product_of(sh_grid,orb(f:l))

         sh_grid.destroy
         sh.destroy

      end

      if (sq) g = conjg(g)*g

   end

!  =====================
!  Exponential densities
!  =====================

   make_exponential_densities(res,pt,rho0) ::: PURE
   ! Return the exponential density values at "pt"s into "res"
   ! given the density "rho0" at R = 0.
      self :: IN
      res :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      rho0 :: REAL, IN

   ENSURE(pt.dim2==3,"wrong dimension for pt array")

      x,y,z,r2 :: VEC{REAL}*
      n_pt :: INT

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      res = rho0 * exp(-TWO*.atomic_number*sqrt(r2))

   end

   add_exponential_densities(res,pt,rho0) ::: PURE
   ! Add the exponential density values at a series of "pt"s to "res"
   ! given the density "rho0" at R = 0.
      self :: IN
      res :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      rho0 :: REAL, IN

   ENSURE(pt.dim2==3,"wrong dimension for pt array")

      x,y,z,r2 :: VEC{REAL}*
      n_pt :: INT

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      res = res + rho0 * exp(-TWO*.atomic_number*sqrt(r2))

   end

!  ======================
!  Spherical density at R
!  ======================

   density_at_radius(R) result (res) ::: PURE
   ! Work out the electron at radius "R".
      self :: IN
      R :: REAL, IN
      res :: REAL

      density_grid :: VEC{REAL}(1)
      pt :: MAT{REAL}(1,3)

      res = ZERO

      select case (.basis_kind)

      case ("gaussian")
         ENSURE(.basis.associated,"no basis")
         pt(1,:) = .position + [R,ZERO,ZERO]
         if (.natural_orbitals.number_kind == "real") then; .make_density_grid_r(density_grid,pt)
         else;                                              .make_density_grid_c(density_grid,pt)
         end
         res = density_grid(1)

      case ("slater")
         ENSURE(.slaterbasis.associated,"no slaterbasis")
         ENSURE(.slaterbasis.shell.associated,"no slaterbasis shells")
         res = .slaterbasis.density_at_radius(R)

      case ("coppens")
         ENSURE(.coppensbasis.associated,"no coppensbasis")
         ENSURE(.coppensbasis.orbital.associated,"no coppensbasis orbital")
         res = .coppensbasis.density_at_radius(R)

      end

   end

   density_value_at_radius(R) result (res) ::: selfless, public, PURE
   ! Return the density values at the radial value "R".
   ! This assumes that the atomic density is spherical!
      R :: REAL, IN
      res :: REAL

      res = saved_self.density_at_radius(R)

   end

!  ============
!  Interpolator
!  ============

   make_interpolator(interpolator) ::: leaky
   ! Make the .interpolator for the atom density. If present,
   ! "interpolator" is used as a template to get the settings needed.
   ! NOTE: This is for a gaussian basis set; for slater or coppens
   ! bases use the interpolators stored in those bases.
      self :: INOUT
      interpolator :: INTERPOLATOR*, optional

   ENSURE(.basis_kind=="gaussian","interpolation must be for a gaussian basis")

      ! Create a copy of the template if it exists
      if (present(interpolator)) then
      if (interpolator.associated) then
         .interpolator.destroy
         .interpolator.create_copy(interpolator)
      end
      end

      ! If no template, create a default interpolator
      if (.interpolator.disassociated) .interpolator.create

      ! Set domain scale factor. May not be required.
      .interpolator.set_domain_scale_factor(.bragg_slater_radius*BOHR_PER_ANGSTROM)

      ! Set the interpolation table
      .set_saved_self ! Used by ATOM: function below
      .interpolator.set_even_spaced_data(ATOM::density_value_at_radius)

   end

   interpolator_table_length(tol) result (length)
   ! Return the interpolator table "length" for a given tolerance "tol" for the
   ! atom density. The interpolator is a default one.
      self :: IN
      tol :: REAL, IN
      length :: REAL

      interpolator :: INTERPOLATOR*

      interpolator.create
      .set_saved_self   ! Used by function below
      length = interpolator.the_table_length(ATOM::density_value_at_radius,tol)
      interpolator.destroy

   end

   make_interpolated_density(density,pt,occ) ::: PURE
   ! Make the spherical atomic "density" for the supplied points "pt"
   ! using a precalculated interpolator.
      self :: IN
      density :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.interpolator.associated,"no interpolator defined!")
   ENSURE(.interpolator.domain_mapping(1:4)=="sqrt","must using sqrt-like mapping")

      R2 :: VEC{REAL}*
      n_pt,n :: INT
      x,y,z :: REAL

      ! Space for R2
      n_pt = pt.dim1
      R2.create(n_pt)

      ! Get squared distances R2
      do n = 1,n_pt
        x = pt(n,1) - .position(1)
        y = pt(n,2) - .position(2)
        z = pt(n,3) - .position(3)
        R2(n) = x*x + y*y + z*z
      end

      ! Get the interpolated density values
      .interpolator.values_for(R2,density,occ)

      ! Clean up
      R2.destroy

   end

   add_interpolated_density(density,pt,occ) ::: PURE
   ! Add the spherical atomic "density" for the supplied points "pt"
   ! using a precalculated interpolator.
      self :: IN
      density :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, optional, IN

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.interpolator.associated,"no interpolator defined!")
   ENSURE(.interpolator.domain_mapping(1:4)=="sqrt","must using sqrt-like mapping")

      R2 :: VEC{REAL}*
      n_pt,n :: INT
      x,y,z :: REAL

      ! Space for R2
      n_pt = pt.dim1
      R2.create(n_pt)

      ! Get squared distances R2
      do n = 1,n_pt
        x = pt(n,1) - .position(1)
        y = pt(n,2) - .position(2)
        z = pt(n,3) - .position(3)
        R2(n) = x*x + y*y + z*z
      end

      ! Get the interpolated density values
      .interpolator.add_values_for(R2,density,occ)

      ! Clean up
      R2.destroy

   end

!  ===========================
!  Nabla density grid routines
!  ===========================

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,pts)
      else
         DIE("complex case not yet implemented")
      end

   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid", evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,grid,pts)
      else
         DIE("complex case not yet implemented")
      end

   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,"wrong dimension for points array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong 1st dimension for nabla_grid array")
   ENSURE(nabla_grid.dim2==3,"wrong 2nd dimension for nabla_grid array")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = size(pts,1)
      nabla_grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.associated, "no occupation numbers")
   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = size(pts,1)
      nabla_grid = ZERO
      grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
       grid(:) = grid(:) + occ*orb(:)*orb(:)
      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_orbital_grid_r(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{REAL}
      h :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")

      orb_a :: VEC{REAL}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_shell,n_pt,f,l,a :: INT

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      h = ZERO
      l = 0

      do a = 1,n_shell

         sh.set(.basis.shell(a),.position)

         f = l + 1

         if (sh.is_spherical)then
           sh_grid.create(n_pt,sh.n_sph,3)
           sh_grid0.create(n_pt,sh.n_sph)
           l = f + sh.n_sph - 1
         else
           sh_grid.create(n_pt,sh.n_comp,3)
           sh_grid0.create(n_pt,sh.n_comp)
           l = f + sh.n_comp - 1
         end if

         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         orb_a => orb(f:l)

         g(:,1).plus_product_of(sh_grid(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid(:,:,3),orb_a)

         h.plus_product_of(sh_grid0,orb_a)

         sh_grid0.destroy
         sh_grid.destroy

      end

   end

!  ==========================
!  Laplacian density routines
!  ==========================

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind == "real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1

      laplacian_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3)))
      end

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{REAL}
      i :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{REAL}*
      n_pt,f,l,a,n_shell :: INT

      n_pt = pt.dim1
      n_shell = .basis.no_of_shells

      g = ZERO
      h = ZERO
      i = ZERO
      l = 0

      do a = 1,n_shell

         sh.set(.basis.shell(a),.position)

         f = l + 1

         if (sh.is_spherical)then
           sh_grid.create(n_pt,sh.n_sph,3)
           sh_grid1.create(n_pt,sh.n_sph,3)
           sh_grid0.create(n_pt,sh.n_sph)
           l = f + sh.n_sph - 1
         else
           sh_grid.create(n_pt,sh.n_comp,3)
           sh_grid1.create(n_pt,sh.n_comp,3)
           sh_grid0.create(n_pt,sh.n_comp)
           l = f + sh.n_comp - 1
         end if

         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)

         orb_a => orb(f:l)

         g(:,1).plus_product_of(sh_grid(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid(:,:,3),orb_a)
         h(:,1).plus_product_of(sh_grid1(:,:,1),orb_a)
         h(:,2).plus_product_of(sh_grid1(:,:,2),orb_a)
         h(:,3).plus_product_of(sh_grid1(:,:,3),orb_a)

         i.plus_product_of(sh_grid0,orb_a)

         sh_grid0.destroy
         sh_grid1.destroy
         sh_grid.destroy

      end

   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind == "real") then
        .make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      laplacian_grid = ZERO

      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * ( &
          NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
       rho = rho + occ*NO*NO
      end

      laplacian_grid = TWO*laplacian_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  =============================
!  Energy density from rho grids
!  =============================

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}

      fac :: REAL
      if (.atomic_number<1) then
         E_grid = ZERO
      else
         .make_density_grid(E_grid,pt)
         fac = .energy/.atomic_number
         E_grid = fac*E_grid
      end

   end

!  ===================================
!  Virial type energy density routines
!  ===================================

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy

   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip
   ! 2G + V = (1/4) L, or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_rG_kinetic_energy_grid(G_grid,pt)
      .make_rL_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy

   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_G_Kirzhnits_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy

   end

   make_V_from_virial_grid(V,pt)
   ! Work out the potential energy density from using the
   ! virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(V.dim)
      .make_G_kinetic_energy_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy

   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the reduced potenbtial energy density from using the
   ! virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(V.dim)
      .make_rG_kinetic_energy_grid(G,pt)
      .make_rL_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy

   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the potential energy density from using the
   ! Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(V.dim)
      .make_G_Kirzhnits_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy

   end

!  ===============================
!  G-type kinetic density routines
!  ===============================

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_G_kinetic_energy_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_G_kinetic_energy_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      G_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       G_grid(:) = G_grid(:) &
                 + .occupation_numbers.restricted(n) &
                 * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end

      G_grid(:) = HALF*G_grid(:)

      P.destroy
      NO.destroy

   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_rG_kinetic_energy_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rG_kinetic_energy_grid_r(G_grid,pt)
   ! Make the reduced G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      G_grid = ZERO

      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
       rho = rho + occ*NO*NO
      end

      G_grid = HALF*G_grid/rho

      P.destroy
      NO.destroy
      rho.destroy

   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_G_Kirzhnits_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
      G,L,nab_rho :: MAT{REAL}*
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1

      rho.create(n_pt);       rho = ZERO
      lap_rho.create(n_pt);   lap_rho = ZERO
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3); nab_rho = ZERO
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)
       occ  = .occupation_numbers.restricted(n)
       occ2 = TWO*occ
       rho  = rho + occ *NO*NO
       nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
       nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,1)
       nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,1)
       lap_rho = lap_rho + occ2*(NO*(L(:,1)+L(:,2)+L(:,3)) + (G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3)))
      end

      L.destroy; G.destroy; NO.destroy

      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy

      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRD)
      G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho

      nab_ro2.destroy; lap_rho.destroy; rho.destroy

   end

!  ===============================
!  K-type kinetic density routines
!  ===============================

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
        .make_K_kinetic_energy_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_K_kinetic_energy_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      K_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       K_grid(:) = K_grid(:) &
                 + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3))
      end

      K_grid(:) = -HALF*K_grid(:)

      D.destroy
      P.destroy
      NO.destroy

   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the reduced K-type kinetic energy density (using the nabla^2) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.associated, "no natural orbitals")
   ENSURE(.natural_orbitals.has_any_genre, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rK_kinetic_energy_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rK_kinetic_energy_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.is_associated_with_genre("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.associated, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      K_grid = ZERO

      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       K_grid = K_grid + occ * NO * (D(:,1)+D(:,2)+D(:,3))
       rho = rho + occ*NO*NO
      end

      K_grid = -HALF*K_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  =============
!  DFT potential
!  =============

   make_dft_xc_pot_grid(V,pt,exchange,correlation)
   ! Work out the DFT exchange-correlation potential "V" at a series of points
   ! "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*

      rho.create(V.dim)
      .make_density_grid(rho,pt)
      V = ZERO
      dft.new_r_potential(exchange,V,rho)
      dft.new_r_potential(correlation,V,rho)
      rho.destroy

   end

   make_dft_eff_pot_grid(V,pt,exchange,correlation)
   ! Work out the DFT effective potential "V" (i.e. the DFT potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

      rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL

      .make_electric_potential_grid(V,pt)
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.new_r_potential(exchange,V,rho)
      dft.new_r_potential(correlation,V,rho)
      rho.destroy

   end

   make_dft_energy_grid(V,pt,exchange,correlation)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.restricted.associated, "no restricted density matrix")

      Ve,rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL

      .nuclear_potential(V,pt)
      Ve.create(V.dim)
      .make_electronic_pot_grid_r(Ve,pt,.density_matrix.restricted)
      V = -V - HALF*Ve
      Ve.destroy
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.new_r_energy_density(exchange,V,rho)
      dft.new_r_energy_density(correlation,V,rho)
      V = V*rho
      rho.destroy

   end

   make_H_dft_energy_grid(H_grid,pt,exchange,correlation)
   ! Work out the H DFT energy density "H_grid" on a set ofpoints "pt"
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR

      G_grid :: VEC{REAL}*

      G_grid.create(H_grid.dim)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_dft_energy_grid(H_grid,pt,exchange,correlation)
      H_grid = H_grid + G_grid
      G_grid.destroy

   end

!  ==================
!  Electric potential
!  ==================

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      self :: IN
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.restricted.associated, "no restricted density matrix")

      if (.density_matrix.number_kind == "real") then
         .make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         DIE("complex case not yet implemented")
      end

   end

   make_electric_potential_grid_r(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      self :: IN
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, IN

      elec_grid :: VEC{REAL}*

      .nuclear_potential(pot_grid,pt)
      elec_grid.create(size(pot_grid))
      .make_electronic_pot_grid_r(elec_grid,pt,dens)
      pot_grid.plus(elec_grid)
      elec_grid.destroy

   end

   make_electronic_pot_grid_r(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      self :: IN
      pot_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      dens :: MAT{REAL}, target, IN

   ENSURE(.basis.associated,"no basis set")

      Vab,Dba :: MAT{REAL}*
      sh :: SHELL2
      n_pt,n_shell_pairs,q,fa,fb,la,lb,k :: INT

      n_pt = pt.dim1
      n_shell_pairs = .basis.no_of_shells
      n_shell_pairs = n_shell_pairs.triangle_number

      pot_grid = ZERO

      do q = 1,n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)

         Dba => dens(fa:la,fb:lb)

         if (sh.is_spherical)then
           Vab.create(sh.a.n_sph,sh.b.n_sph)
         else
           Vab.create(sh.a.n_comp,sh.b.n_comp)
         end if

         if (fa/=fb) then

           do k = 1,n_pt
              sh.get_nuc(Vab,ONE,pt(k,:))
              pot_grid(k) = pot_grid(k) - TWO*MAT{REAL}:sum_elements(Vab*Dba)
           end

         else

           do k = 1,n_pt
              sh.get_nuc(Vab,ONE,pt(k,:))
              pot_grid(k) = pot_grid(k) -     MAT{REAL}:sum_elements(Vab*Dba)
           end

         end

         Vab.destroy
         sh.destroy_ptr_part

      end

   end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      i :: INT
      r,x,y,z,xi,yi,zi :: REAL

      values = ZERO
      x = .position(1)
      y = .position(2)
      z = .position(3)

      do i = 1,values.dim
         xi = pts(i,1) - x
         yi = pts(i,2) - y
         zi = pts(i,3) - z
         r  = sqrt(xi*xi + yi*yi + zi*zi)
         if (r>tiny(r)) then; values(i) = values(i) + .atomic_number/r
         else;                values(i) = values(i) + huge(ONE)
         end
      end

   end

!  =================================
!  DFT grids for all basis functions
!  =================================

   make_bf_grid(grid,pt)
   ! Make a "grid" on which all the atom basis functions are
   ! evaluated, for the supplied points "pt".
      self :: IN
      grid :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid.dim1==pt.dim1,"incompatible grid and pt arrays")
   ENSURE(grid.dim2==.basis.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      s,f,l,n_shell :: INT

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell

         sh.set(.basis.shell(s),.position)

         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph
         else
           l = l + sh.n_comp
         end if

         sh.make_grid(grid(:,f:l),pt)

      end

   end

   make_nabla_bf_grid(nabla_grid,pt)
   ! Make a "nabla_grid" on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt".
      self :: IN
      nabla_grid :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(nabla_grid.dim1==pt.dim1,"incompatible nabla_grid and pt arrays")
   ENSURE(nabla_grid.dim2==.basis.no_of_basis_functions,"wrong size, nabla_grid array")
   ENSURE(nabla_grid.dim3==3,"wrong size, nabla_grid array")

      sh :: SHELL1
      s,n_shell :: INT

      n_shell = .basis.no_of_shells

      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         sh.make_nabla_grid(nabla_grid,pt)
      end

   end

   make_nabla_bf_grid(nabla_grid,grid,pt)
   ! Make a "nabla_grid" on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt". Also
   ! return "grid", which tabluates the values of all the atom basis
   ! functions on the grid points.
      self :: IN
      nabla_grid :: MAT3{REAL}, OUT
      grid :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(nabla_grid.dim1==pt.dim1,"incompatible nabla_grid and pt arrays")
   ENSURE(nabla_grid.dim2==.basis.no_of_basis_functions,"wrong size, nabla_grid array")
   ENSURE(nabla_grid.dim3==3,"wrong size, nabla_grid array")
   ENSURE(grid.dim1==pt.dim1,"incompatible grid and pt arrays")
   ENSURE(grid.dim2==.basis.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      s,f,l,n_shell :: INT

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph  ! LBXXX
         else
           l = l + sh.n_comp
         end if
         sh.make_nabla_grid(nabla_grid(:,f:l,1),nabla_grid(:,f:l,2),nabla_grid(:,f:l,3),grid(:,f:l),pt)
      end

   end


   make_bf_grid(grid0,pt,cutoff)
   ! Make a "grid0" on which all the atom basis functions are evaluated, for the
   ! supplied points "pt".
      self :: IN
      grid0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid0.dim1==pt.dim1,"incompatible grid0 and pt arrays")
   ENSURE(grid0.dim2==.basis.no_of_basis_functions,"wrong size, grid0 array")

      x,y,z,r2 :: VEC{REAL}*
      sh :: SHELL1
      n_pt,s,f,l,n_shell :: INT

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph
         else
           l = l + sh.n_comp
         end if
         sh.make_grid(grid0(:,f:l),x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_nabla_bf_grid(grid1,pt,cutoff)
   ! Make a nabla grid, "grid1", on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt".
      self :: IN
      grid1 :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid1.dim1==pt.dim1,"incompatible grid1 and pt arrays")
   ENSURE(grid1.dim2==.basis.no_of_basis_functions,"wrong size, grid1 array")
   ENSURE(grid1.dim3==3,"wrong size, grid1 array")

      x,y,z,r2 :: VEC{REAL}*
      sh :: SHELL1
      n_pt,s,n_shell :: INT

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      n_shell = .basis.no_of_shells

      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         sh.make_nabla_grid(grid1,x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_nabla_bf_grid(grid1,grid0,pt,cutoff)
   ! Make a nabla grid "grid1" on which the gradient of all the atom basis functions
   ! are evaluated, for the supplied points "pt". Also return "grid0", which
   ! tabluates the values of all the atom basis functions on the grid points.
      self :: IN
      grid1 :: MAT3{REAL}, OUT
      grid0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.associated,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid1.dim1==pt.dim1,"incompatible grid1 and pt arrays")
   ENSURE(grid1.dim2==.basis.no_of_basis_functions,"wrong size, grid1 array")
   ENSURE(grid1.dim3==3,"wrong size, grid1 array")
   ENSURE(grid0.dim1==pt.dim1,"incompatible grid0 and pt arrays")
   ENSURE(grid0.dim2==.basis.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      n_pt,s,f,l,n_shell :: INT
      x,y,z,r2 :: VEC{REAL}*

      n_pt = pt.dim1

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      n_shell = .basis.no_of_shells

      l = 0
      do s = 1,n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         if (sh.is_spherical)then
           l = l + sh.n_sph
         else
           l = l + sh.n_comp
         end if
         sh.make_nabla_grid(grid1(:,f:l,1),grid1(:,f:l,2),grid1(:,f:l,3),grid0(:,f:l),x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

!  ================
!  Make point lists
!  ================

   make_logval(logval,r2,n_pt) ::: PURE
   ! For a list of points with distances "r2" from an atom center,
   ! return the log of the mkaximuk value "logval" which can be used
   ! to implement a cutoff.
      self :: IN
      n_pt :: INT, IN
      logval :: VEC{INT}(n_pt), OUT
      r2 :: VEC{REAL}(n_pt), IN

   ENSURE(.basis.associated,"no basis set")

      rr,ex :: REAL
      n :: INT

      ex = .basis.min_exponent

      do n = 1,n_pt

         rr = r2(n)
         logval(n) = ceiling(log10(exp(-ex*rr)))

      end

   end


   make_displaced_pts(dx,dy,dz,r2,pt,n_pt) ::: PURE
   ! For a list of points "pt" of length "n_pt", return displacements
   ! "dx", "dy", "dz", from the atom center, and their square "r2".
      self :: IN
      dx,dy,dz,r2 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      n_pt :: INT, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(dx.dim ==n_pt,"wrong size, dx")
   ENSURE(dy.dim ==n_pt,"wrong size, dy")
   ENSURE(dz.dim ==n_pt,"wrong size, dy")
   ENSURE(pt.dim1==n_pt,"wrong dim1, pt")
   ENSURE(pt.dim2==3,   "wrong dim1, pt")

      px,py,pz, xx,yy,zz, rr :: REAL
      n :: INT

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      do n = 1,n_pt

         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz

         dx(n)   = xx
         dy(n)   = yy
         dz(n)   = zz
         r2(n)   = rr

      end

   end

   make_displaced_skip_pts(dx,dy,dz,r2,skip,pt,n_pt,cutoff) ::: PURE
   ! For a list of points "pt" of length "n_pt", return displacements
   ! "dx", "dy", "dz", their square "r2" and "skip" which tells when
   ! the basis function is less than "cutoff".
      self :: IN
      dx,dy,dz,r2 :: VEC{REAL}, OUT
      skip :: VEC{BIN}, OUT
      pt :: MAT{REAL}, IN
      n_pt :: INT, IN
      cutoff :: REAL, IN

   ENSURE(.basis.associated,"no basis set")
   ENSURE(dx.dim >=n_pt,"wrong size, dx")
   ENSURE(dy.dim >=n_pt,"wrong size, dy")
   ENSURE(dz.dim >=n_pt,"wrong size, dy")
   ENSURE(pt.dim1==n_pt,"wrong dim1, pt")
   ENSURE(pt.dim2==3,   "wrong dim1, pt")

      px,py,pz, xx,yy,zz, rr,r2_max :: REAL
      n :: INT

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      r2_max = .r2_max(cutoff)

      do n = 1,n_pt

         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz

         dx(n)   = xx
         dy(n)   = yy
         dz(n)   = zz
         r2(n)   = rr
         skip(n) = rr>r2_max

      end

   end


   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky, PURE
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      self :: IN
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(.basis.associated,"no basis set")

      px,py,pz,xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k)
      end

   end

   make_significant_points(x,y,z,r2,d2,skip,pt,cutoff) ::: leaky, PURE
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      self :: IN
      x,y,z,r2,d2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(.basis.associated,"no basis set")

      px,py,pz,xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1
      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)
      d2.create(n_pt)

      r2_max = .r2_max(cutoff)

      px = .position(1)
      py = .position(2)
      pz = .position(3)

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px
         yy = pt(n,2) - py
         zz = pt(n,3) - pz
         rr = xx*xx + yy*yy + zz*zz
         d2(n) = rr
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy
         y.destroy
         z.destroy
         r2.destroy
         d2.destroy
      else
         x.shrink(k)
         y.shrink(k)
         z.shrink(k)
         r2.shrink(k) ! don't shrink d2 or skip
      end

   end

   make_significant_points(x,y,z,r2,skip,pt,skip2,cutoff) ::: leaky, PURE
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE. "skip2" is an array
   ! which skips (in addition) some preselcted points.
      self :: IN
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      skip2 :: VEC{BIN}, IN
      cutoff :: REAL, IN

   ENSURE(.basis.associated,"no basis set")

      xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)
      k = 0

      do n = 1,n_pt
         xx = pt(n,1) - .position(1)
         yy = pt(n,2) - .position(2)
         zz = pt(n,3) - .position(3)
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = skip2(n) OR rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy
         y.destroy
         z.destroy
         r2.destroy
      else
         x.shrink(k)
         y.shrink(k)
         z.shrink(k)
         r2.shrink(k) ! don't shrink skip
      end

   end

!  ============================
!  Make basis shell information
!  ============================

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
      self :: INOUT

   ENSURE(.basis.associated,"no basis set")

      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .set_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell)

      .make_precomputed_shellpairs

      GAUSSIAN_DATA:set_indices(maxval(.basis.shell.l))

   end

   set_shell_limits(first,last) ::: leaky, PURE
   ! Set the indices of first and last basis functions in a particular shell
   ! "s", first(s) and last(s), respectively.
      self :: IN
      first,last :: VEC{INT}*

      n_shell,f,l,s :: INT

      n_shell = .basis.no_of_shells
      first.create(n_shell)
      last.create(n_shell)

      l = 0
      do s = 1,n_shell
         f = l + 1
         l = f + .basis.shell(s).n_bf - 1
         first(s) = f
         last(s)  = l
      end

   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type
      self :: INOUT

   ENSURE(.basis.associated,"no basis set")

      n,a,b :: INT

      n = .basis.no_of_shells

      .precomputed_basis_shellpair.destroy
      .precomputed_basis_shellpair.create(n,n)

      do a = 1,n
      do b = 1,n
         .precomputed_basis_shellpair(a,b).copy_a(.basis.shell(a))
         .precomputed_basis_shellpair(a,b).copy_b(.basis.shell(b))
         .precomputed_basis_shellpair(a,b).make_precalculated_data
      end
      end

   end

   get_precomputed_shell_pair(shell,q,fa,la,fb,lb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "q"
   ! Also return the basis function start indices "fa", "la", etc ...
      self :: IN
      shell :: SHELL2, OUT
      q :: INT, IN
      fa,la,fb,lb :: INT, OUT

   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed basis shellpair data")
   ENSURE(.first_basis_fn_for_shell.associated,"no first_basis_fn data")
   ENSURE(.last_basis_fn_for_shell.associated,"no last_basis_fn data")

      a,b :: INT

      a  = (1+int(sqrt(8.0d0*q-7.0d0)))/2
      b  = q - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(a,b) &
         ,.position,.position,same_center=TRUE,skip=FALSE)

   end

   get_precomputed_shell_pair0(shell,q,fa,la,fb,lb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "q"
   ! Also return the basis function start indices "fa", "la", etc ...
   ! HOWEVER, place both functions at the origin not at .position.
      self :: IN
      shell :: SHELL2, OUT
      q :: INT, IN
      fa,la,fb,lb :: INT, OUT

   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed basis shellpair data")
   ENSURE(.first_basis_fn_for_shell.associated,"no first_basis_fn data")
   ENSURE(.last_basis_fn_for_shell.associated,"no last_basis_fn data")

      a,b :: INT
      zv  :: VEC{REAL}(3)

      zv = ZERO

      a  = (1+int(sqrt(8.0d0*q-7.0d0)))/2
      b  = q - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(a,b) &
         ,zv,zv,same_center=TRUE,skip=FALSE)

   end

!  ==========================
!  Structure factor integrals
!  ==========================

   make_FT(res,k_pts)
   ! Fourier transform of the density described by ".density_matrix"
   ! evaluated at a reciprocal space points [k_pts(i,:), i = 1,dim ]
      self :: IN
      res :: VEC{CPX}, OUT
      k_pts :: MAT{REAL}, IN

      if (.use_IAM_ITC_FFs) then; .make_FT_spherical(res,k_pts)
      else;                       .make_FT_aspherical(res,k_pts)
      end

   end

   make_FT_spherical(res,k_pts)
   ! Analytical representation of the spherical IAM form factor
   ! evaluated at a reciprocal space points [k_pts(i,:), i = 1,dim ]
      self :: IN
      res :: VEC{CPX}, OUT
      k_pts :: MAT{REAL}, IN

   ENSURE(.use_IAM_ITC_FFs,"use_IAM_ITC_FFs is FALSE!")

      k_z :: VEC{REAL}*
      k_max :: INT
      II :: CPX
      phv :: VEC{CPX}*

      k_max = k_pts.dim1
         II = IMAGIFY(ONE)

      if (.atomic_number==1) then

         ! H atom uses Stewart-Davidson-Simpson (SDS) AIM
         k_z.create(k_max)
         k_pts.get_row_norms(k_z)
         res = ATOM::H_SDS_form_factor(k_z) &
             * exp(II*(.position(1)*k_pts(:,1) &
                      +.position(2)*k_pts(:,2) &
                      +.position(3)*k_pts(:,3)))
         k_z.destroy

      else

         ! Other atoms use fitted *neutral* HF form factors
         phv.create(k_max)
         k_z.create(k_max)
         k_pts.get_row_norms(k_z)
         res = .HF_n0_form_factor(k_z)
         phv = exp(II*(.position(1)*k_pts(:,1) &
                      +.position(2)*k_pts(:,2) &
                      +.position(3)*k_pts(:,3)))
         res = res * phv

         k_z.destroy
         phv.destroy

      end

   end

   make_FT_aspherical(res,k_pts)
   ! Fourier transform of the density described by ".density_matrix"
   ! evaluated at a reciprocal space points [k_pts(i,:), i = 1,dim ]
      self :: IN
      res :: VEC{CPX}, OUT
      k_pts :: MAT{REAL}, IN

   ENSURE(.density_matrix.associated, "no .density_matrix")
   ENSURE(.density_matrix.restricted.associated, "only works for restricted .density_matrix")
   ENSURE(.precomputed_basis_shellpair.associated, "no precomputed_basis_shellpair info")

      n_shell_pairs,q,fa,fb,la,lb, k_max,k :: INT
      FT :: MAT3{CPX}*
      D :: MAT{REAL}@
      sh :: SHELL2

      n_shell_pairs = .basis.no_of_shells
      n_shell_pairs = n_shell_pairs.triangle_number

      k_max = k_pts.dim1

      ! Use whatever atomic .density_matrix is there
      res = ZERO
   
      do q = 1,n_shell_pairs
   
         ! Get shell
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
   
         ! Make the FT 
         FT.create(k_max,sh.a.n_comp,sh.b.n_comp)
         sh.make_ft_c(FT,k_pts)
   
         ! Trace with density matrix
         ! Count off-diagonals twice
         D = .density_matrix.restricted(fa:la,fb:lb)
         if (fa/=fb) then 
            do k = 1,k_max
               res(k) = res(k) + sum(FT(k,:,:)*D) * TWO
            end
         else
            do k = 1,k_max
               res(k) = res(k) + sum(FT(k,:,:)*D)
            end
         end
   
         ! Clean
         FT.destroy
         sh.destroy_ptr_part
   
      end
   
   end


   make_FT_along_z(res,k_z)
   ! Fourier transform of the density described by ".density_matrix"
   ! evaluated at a reciprocal space points [0,0,k_z(i), i = 1,dim].
   ! NOTE: evaluated at the ORIGIN!
      self :: IN
      res :: VEC{CPX}, OUT
      k_z :: VEC{REAL}, IN

   ENSURE(.density_matrix.associated, "no .density_matrix")
   ENSURE(.density_matrix.restricted.associated, "only works for restricted .density_matrix")
   ENSURE(.precomputed_basis_shellpair.associated,"no precomputed basis shellpair data")

      n_shell_pairs,q,fa,fb,la,lb, k_max,k :: INT
      k_x,k_y :: VEC{REAL}*
    ! partition :: MAT{REAL}*
      FT :: MAT3{CPX}*
      D :: MAT{REAL}@
      sh :: SHELL2

      k_max = k_z.dim1

      if (.atomic_number==1 AND .use_IAM_ITC_FFs) then

         ! H atom uses Stewart-Davidson-Simpson (SDS) AIM
         res = COMPLEXIFY(ATOM::H_SDS_form_factor(k_z),ZERO)

      else if (.use_IAM_ITC_FFs) then

         ! Uses neutral atom form factors
         res = COMPLEXIFY(.HF_n0_form_factor(k_z),ZERO)

      else

         ! Use whatever atomic .density_matrix is there
         n_shell_pairs = .basis.no_of_shells
         n_shell_pairs = n_shell_pairs.triangle_number
        
         ! Other components
         k_x.create(k_max); k_x = 0
         k_y.create(k_max); k_y = 0
        
         res = ZERO
        
         do q = 1,n_shell_pairs
        
            ! Get shell pair *AT ORIGIN*
            .get_precomputed_shell_pair0(sh,q,fa,la,fb,lb)
        
            ! Make the FT 
            FT.create(k_max,sh.a.n_comp,sh.b.n_comp)
            sh.make_ft_c(FT,k_x,k_y,k_z)
        
          ! partition.create(sh.a.n_comp,sh.b.n_comp)
          ! partition = ONE
          ! sh.make_FT_parted_c(FT,k_x,k_y,k_z,partition)
        
            ! Trace with density matrix
            ! Count off-diagonals twice
            D = .density_matrix.restricted(fa:la,fb:lb)
            if (fa/=fb) then 
               do k = 1,k_max
                  res(k) = res(k) + sum(FT(k,:,:)*D) * TWO
               end
            else
               do k = 1,k_max
                  res(k) = res(k) + sum(FT(k,:,:)*D)
               end
            end
        
            ! Clean
          ! partition.destroy
            FT.destroy
            sh.destroy_ptr_part
        
         end
        
         ! Clean
         k_y.destroy
         k_x.destroy

      end

   end

   FT_along_z_r(res,k_z) ::: selfless
   ! Real part of fourier transform of the density described by
   ! ".density_matrix" evaluated at a reciprocal space points
   ! [0,0,k_z(i), i = 1,dim]
      res :: VEC{REAL}, OUT
      k_z :: VEC{REAL}, IN

      tmp :: VEC{CPX}*

      tmp.create(res.dim)
      saved_self.make_FT_along_z(tmp,k_z)

      res = RE(tmp)

      tmp.destroy

   end

   FT_along_z_i(res,k_z) ::: selfless
   ! Imaginary part of fourier transform of the density described by
   ! ".density_matrix" evaluated at a reciprocal space points
   ! [0,0,k_z(i), i = 1,dim]
      res :: VEC{REAL}, OUT
      k_z :: VEC{REAL}, IN

      tmp :: VEC{CPX}*

      tmp.create(res.dim)
      saved_self.make_FT_along_z(tmp,k_z)

      res = IM(tmp)

      tmp.destroy

   end

   put_FT_along_z_r(length,spacing) ::: leaky
   ! Put the real part of the spherical atomic form factors (along z
   ! direction) NOTE: X axis is converted to Angstrom^-1
      self :: IN
      length,spacing :: REAL, IN

      interpolator :: INTERPOLATOR*
    ! points :: VEC{REAL}*
     
      ! Used below to make interpolator
      .set_saved_self 

      ! Set the interpolation table
      interpolator.create
      interpolator.set_data(length,spacing,ATOM::FT_along_z_r)

      ! Set H SDS points from the IT C table
    ! points.create(23)
    ! points = [ &
    !    0.0000, &
    !    0.0215, &
    !    0.0429, &
    !    0.0644, &
    !    0.0859, &
    !    0.1073, &
    !    0.1288, &
    !    0.1503, &
    !    0.1718, &
    !    0.1932, &
    !    0.2147, &
    !    0.2576, &
    !    0.3006, &
    !    0.3435, &
    !    0.3864, &
    !    0.4294, &
    !    0.4723, &
    !    0.5153, &
    !    0.5582, &
    !    0.6011, &
    !    0.6441, &
    !    0.6870, &
    !    0.7300  ]
    ! points = FOUR*PI * ANGSTROM_PER_BOHR * points ! in Bohr^-1
    ! interpolator.create
    ! interpolator.set_data_points(points)
    ! interpolator.set_data(length,spacing,ATOM::FT_along_z_r)

      ! Neutral H atom form factors points
    ! points.create(46)
    ! points = [ &
    !    0.00,   &
    !    0.01,   &
    !    0.02,   &
    !    0.03,   &
    !    0.04,   &
    !    0.05,   &
    !    0.06,   &
    !    0.07,   &
    !    0.08,   &
    !    0.09,   &
    !    0.10,   &
    !    0.11,   &
    !    0.12,   &
    !    0.13,   &
    !    0.14,   &
    !    0.15,   &
    !    0.16,   &
    !    0.17,   &
    !    0.18,   &
    !    0.19,   &
    !    0.20,   &
    !    0.22,   &
    !    0.24,   &
    !    0.25,   &
    !    0.26,   &
    !    0.28,   &
    !    0.30,   &
    !    0.32,   &
    !    0.34,   &
    !    0.35,   &
    !    0.36,   &
    !    0.38,   &
    !    0.40,   &
    !    0.42,   &
    !    0.44,   &
    !    0.45,   &
    !    0.46,   &
    !    0.48,   &
    !    0.50,   &
    !    0.55,   &
    !    0.60,   &
    !    0.65,   &
    !    0.70,   &
    !    0.80,   &
    !    0.90,   &
    !    1.00    ]
    ! points = FOUR*PI * ANGSTROM_PER_BOHR * points ! in Bohr^-1
    ! interpolator.create
    ! interpolator.set_data_points(points)
    ! interpolator.set_data(length,spacing,ATOM::FT_along_z_r)

      ! Put
      interpolator.put(fac=BOHR_PER_ANGSTROM/(FOUR*PI))

      ! Clean
      interpolator.destroy

   end

   put_FT_along_z_i(length,spacing) ::: leaky
   ! Put the imaginary part of the spherical atomic form factors
   ! (along z direction) NOTE: X axis is converted to Angstrom^-1
      self :: IN
      length,spacing :: REAL, IN

      interpolator :: INTERPOLATOR*
     
      ! Set the interpolation table
      .set_saved_self ! Used below
      interpolator.create
      interpolator.set_data(length,spacing,ATOM::FT_along_z_i)

      ! Clean
      interpolator.put(fac=BOHR_PER_ANGSTROM/(FOUR*PI))

      ! Clean
      interpolator.destroy

   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("label",.label)
      stdout.dump("tag",.tag)
      stdout.dump("atomic_number",.atomic_number)
      stdout.dump("nuclear_charge",.nuclear_charge)
      stdout.dump("oxidation_state",.oxidation_state)
      stdout.dump("position",.position)
      stdout.dump("position_error",.position_error)
      stdout.dump("group",.group)

      stdout.dump("site_occupancy",.site_occupancy)
      stdout.dump("site_disorder_group",.site_disorder_group)

      stdout.dump("U_iso",.U_iso)
      stdout.dmpp("pADP_vector",.pADP_vector)
      stdout.dmpp("pADP_errors",.pADP_errors)

      stdout.dump("pos_axis_system",.pos_axis_system)
      stdout.dump("ADP_axis_system",.ADP_axis_system)
      stdout.dump("ADPn_axis_system",.ADPn_axis_system)

      stdout.dump("charge",.charge)
      stdout.dump("dipole",.dipole)
      stdout.dump("quadrupole",.quadrupole)
      stdout.dump("spin",.spin)
      stdout.dump("spin_dipole",.spin_dipole)
      stdout.dump("spin_quadrupole",.spin_quadrupole)

      stdout.dump("charge_polarisability",.charge_polarisability)
      stdout.dump("dipole_polarisability",.dipole_polarisability)

      stdout.dump("basis_label",.basis_label)
      stdout.dump("basis_kind",.basis_kind)
      .basis.dmpp("basis")
      stdout.dump("slaterbasis_label",.slaterbasis_label)
      .slaterbasis.dmpp("slaterbasis")
      stdout.dump("coppensbasis_label:STR",.coppensbasis_label)
      .coppensbasis.dmpp("coppensbasis")
      stdout.dump("kind",.kind)
      stdout.dump("is_unique_kind",.is_unique_kind)

      stdout.dump("energy",.energy)
      stdout.dmpp("atomic_orbitals",.atomic_orbitals)
      stdout.dmpp("density_matrix",.density_matrix)
      stdout.dmpp("natural_orbitals",.natural_orbitals)
      stdout.dmpp("occupation_numbers",.occupation_numbers)
      stdout.dump("ANOs_made",.ANOs_made)
      stdout.dump("spherical_atom_data_made",.spherical_atom_data_made)
      stdout.dump("NAOs_made",.NAOs_made)

      stdout.dump("use_interpolator",.use_interpolator)
      .interpolator.dmpp("interpolator")
      stdout.dump("ANO_interpolators_made",.ANO_interpolators_made)
      stdout.dump("interpolators_made",.interpolators_made)

      stdout.dmpp("first_basis_fn_for_shell",.first_basis_fn_for_shell)
      stdout.dmpp("last_basis_fn_for_shell",.last_basis_fn_for_shell)
      .precomputed_basis_shellpair.dmpp("precomputed_basis_shellpair",lower_triangle=TRUE)
      stdout.dump("shell_info_made",.shell_info_made)

      stdout.dump("invariom_label",.invariom_label)
      stdout.dump("protein_strand",.protein_strand)
      stdout.dump("residue_atom_code",.residue_atom_code)
      stdout.dump("residue_code",.residue_code)
      stdout.dump("residue_sequence_number",.residue_sequence_number)

      stdout.dump("mm_forcefield_name",.mm_forcefield_name)
      stdout.dump("mm_atom_type",.mm_atom_type)
      stdout.dump("mm_chargeL",.mm_charge)
      stdout.dump("restraining_position",.restraining_position)
      stdout.dump("restraining_force_constant",.restraining_force_constant)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE?=>ATOM)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE?=>ATOM)
   ! Dump pointer object data as text
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put out the atom information to file "stdout"
      self :: IN

      .put_short

      if (.residue_sequence_number/=0) .put_mm_info

      if (.basis.associated)              .basis.put
      if (.slaterbasis.associated)        .slaterbasis.put
      if (.coppensbasis.associated)       .coppensbasis.put

      .put_ANOs

   end

   put_short
   ! Put out the atom information to file "stdout"
      self :: IN

      stdout.flush

      stdout.show("Label                  =",trim(.label))
      stdout.show("Unique tag             =",trim(.tag))
      stdout.show("Atomic No.             =",.atomic_number)
      stdout.show("Chemical symbol        =",trim(.chemical_symbol))
      stdout.show("Atom position          =",.position(1),.position(2),.position(3))

      stdout.show("Site disorder group    =",.site_disorder_group)
      stdout.show("Site occupancy         =",.site_occupancy)

   end

   put_ANOs
   ! Put out the ANO information to file "stdout"
      self :: IN

      stdout.flush

      if (.atomic_orbitals.associated) then
         stdout.flush
         stdout.text("Atomic orbitals:")
         stdout.flush
         stdout.put(.atomic_orbitals)
      end

      if (.density_matrix.associated) then
         stdout.flush
         stdout.text("Density matrix:")
         stdout.flush
         stdout.put(.atomic_orbitals)
      end

      if (.natural_orbitals.associated) then
         stdout.flush
         stdout.text("Natural occupations and orbitals:")
         stdout.flush
         stdout.put(.occupation_numbers)
         stdout.flush
         stdout.put(.natural_orbitals)
      end

   end

   put_mm_info
   ! Put out the MM/protien part of the atom information to file "stdout"
      self :: IN

      stdout.flush
      stdout.show("Residue atom code       =",trim(.residue_atom_code))
      stdout.show("Residue code            =",trim(.residue_code))
      stdout.show("Residue sequence number =",.residue_sequence_number)
      stdout.show("MM forcefield name      =",.mm_forcefield_name)
      stdout.show("MM atom type            =",.mm_atom_type)
      stdout.show("MM charge               =",.mm_charge)
      stdout.show("Restraining position    =",.restraining_position)
      stdout.show("Restraining force       =",.restraining_force_constant)

   end

   put_natural_orbitals
   ! Put out the current associated molecular orbitals to file "out"
      self :: IN

   ENSURE(.natural_orbitals.associated,"no natural orbitals")
   ENSURE(.occupation_numbers.associated,"no natural orbital occupations")

      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers)

      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)

   end

   put_interpolator
   ! Put out the atom information to file "stdout"

      select case (.basis_kind)

         case ("slater")
            ENSURE(.slaterbasis.associated,"no slaterbasis")
            stdout.flush
            stdout.text("Atom slaterbasis info:")
            .slaterbasis.interpolator.put

         case ("coppens")
            ENSURE(.coppensbasis.associated,"no coppensbasis")
            stdout.flush
            stdout.text("Atom coppensbasis info:")
            .coppensbasis.interpolator.put

         case default
            DIE("no interpolator for basis "//trim(.basis_kind))

      end

   end

end
