!==============================================================================-
!
! MOLECULE: An object repxresentation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!==============================================================================-


module MOLECULE.MAIN

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

!  ================
!  Main controllers
!  ================

   run ::: leaky
   ! Main molecule run-loop; assumes stdin and stdout have been defined.
      self :: PTR

      ! Start timer
      std_time.start_timing

      ! Create (leaky)
      .BASE:create

      ! Gaussian indices (leaky)
      GAUSSIAN_DATA:set_indices(GAUSSIAN_DATA_L_MAX)

      ! Banner
      ::put_banner

      ! Read & process keywords
      .:read_keywords

      ! Release memory
      .:pauli_block_geminals.destroy
      .atoms_bonded_to_atom.destroy

      ! Finish timing
      std_time.stop_timing

      stdout.flush
      stdout.text(std_time.elapsed_time_message("job "//'"'// trim(.name) //'"'))
      stdout.text(std_time.elapsed_cpu_time_message("job "//'"'// trim(.name) //'"'))

      ! Warnings
      if (tonto.warnings_issued) then
      stdout.flush
      stdout.text("WARNINGS were issued in this job.")
      stdout.text("Look above, or in the stderr file.")
      end

   end

   put_banner ::: selfless
   ! Put to stdout the current TONTO banner

      stdout.text("_______________________________________________________________")
      stdout.text("                                                               ")
      stdout.text(" T   O   N   T   O                                             ")
      stdout.text("                                                               ")
      stdout.text(" A free object-based system for computational chemistry        ")
      stdout.text("                                                               ")
      stdout.text(" Version: "//TONTO_VERSION//" v. "//GIT_VERSION)
      stdout.text(" Platform: "//TONTO_PLATFORM)
      stdout.text(" Build-date: "//TONTO_BUILD_DATE)
      stdout.text("                                                               ")
      stdout.text(" For conditions of use, on-line documentation, and contributor ")
      stdout.text(" and developer information see :-                              ")
      stdout.text("                                                               ")
      stdout.text(" www."//"theochem."//"uwa."//"edu."//"au/tonto/                ")
      stdout.text(" or")
      stdout.text(" https://"//"github."//"com/"//"dylan-jayatilaka/tonto         ")
      stdout.text("                                                               ")
      stdout.text(" Dylan Jayatilaka                                              ")
      stdout.text(" Daniel Grimwood                                               ")
      stdout.text(" Peter Spackman                                                ")
      stdout.text("_______________________________________________________________")

      stdout.flush
      stdout.flush
      stdout.text(std_time.start_time_message)
      stdout.flush

   end

   cleanup ::: leaky
   ! Clean up all undeleted memory in all modules.

      self :: PTR
      atom :: ATOM
      basis :: BASIS
      coppensbasis :: COPPENSBASIS
      coppensorbital :: COPPENSORBITAL
    ! geminal :: GEMINAL_MF_SPECTRUM
      reflection :: REFLECTION
      shell :: SHELL
      slaterbasis :: SLATERBASIS
      slatershell :: SLATERSHELL

      ! Clean self
      .BASE:destroy

      ! Gaussian indices
      GAUSSIAN_DATA:destroy_data

      ! Clear all keys
      atom.clear_keys
      basis.clear_keys
      coppensbasis.clear_keys
      coppensorbital.clear_keys
    ! geminal.clear_keys
      reflection.clear_keys
      shell.clear_keys
      slaterbasis.clear_keys
      slatershell.clear_keys

   end

   reset_molecule ::: leaky
   ! Resets the mol data type and reruns the read routine
      self :: PTR
      word :: STR

      .BASE:destroy
      .BASE:create

      ! First keyword must be "name"
      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="name=","first keyword must be name")

      stdin.read(.name)

   end

!  =============
!  Read routines
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: recursive, leaky
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
   ! NOTE : this routine reuires a MOLECULE pointer self variable
      self :: PTR
      keyword :: STR, IN

      select case (keyword(1:30))

        case ("}                             "); ! exit case

        case ("assign_mos_to_nos             "); .BASE:assign_MOs_to_NOs
        case ("assign_nos_to_mos             "); .BASE:assign_NOs_to_MOs
        case ("atoms=                        "); .:read_atoms
        case ("atom_groups=                  "); .:read_atom_groups

        case ("b_field=                      "); .:read_B_field
        case ("basis_sets=                   "); .:read_basis_sets
        case ("basis_directory=              "); .:read_basis_directory
        case ("basis_library=                "); .:read_basis_directory
        case ("basis_name=                   "); .:read_basis_name
        case ("basis_set=                    "); .:read_basis_name
        case ("batch_surfaces                "); .:batch_hs
        case ("generate_wavefunctions        "); .:generate_all_wavefunctions
        case ("becke_grid=                   "); .:read_becke_grid

        case ("canonicalize_mos              "); .SCF:canonicalize_MOs
        case ("change_axis_system_to         "); .BASE:change_axis_system_to
        case ("change_to_principal_axes      "); .BASE:change_to_principal_axes
        case ("change_to_principal_top_axes  "); .BASE:change_to_principal_top_axes
        case ("charge=                       "); .:read_charge
        case ("cif=                          "); .XTAL:read_CIF
        case ("cleanup_scf                   "); .SCF:cleanup_scf
        case ("cluster=                      "); .:read_cluster
        case ("coppensbasis_name=            "); .:read_coppensbasis_name
        case ("create_cluster                "); .XTAL:create_cluster
        case ("create_cluster_mol            "); .XTAL:create_cluster_mol
        case ("create_hs_cluster             "); .XTAL:create_HS_cluster
        case ("crystal=                      "); .:read_crystal

        case ("debug_on                      "); .BASE:read_debug_on
        case ("debug_off                     "); .BASE:read_debug_off
        case ("delete_plot_grid              "); .GRID:delete_plot_grid
        case ("delete_scf_archives           "); .BASE:delete_scf_archives
        case ("delete_scf_integrals          "); .BASE:destroy_scf_integrals
        case ("destroy_atom_groups           "); .BASE:destroy_atom_group
        case ("destroy_cluster               "); .XTAL:destroy_cluster
      ! case ("dvpt_scf                      "); .MISC.DVPT_scf

        case ("e_field=                      "); .:read_E_field

        case ("fit_hirshfeld_atoms           "); .TAD:fit_Hirshfeld_atoms
        case ("fit_hirshfeld_atom_kappas     "); .MISC:fit_Hirshfeld_atom_kappas
        case ("force_constants=              "); .PROP:read_force_constants

        case ("gauge_origin=                 "); .:read_gauge_origin
        case ("get_dedr_iotc                 "); .REL:get_dEdR_IOTC
        case ("get_g_overlap_nuc             "); .REL:get_g_overlap_nuc
        case ("get_gchf_jz                   "); .PROP:get_gchf_jz
        case ("get_gchf_kramers              "); .PROP:get_gchf_kramers
        case ("get_gchf_kramers_2            "); .PROP:get_gchf_kramers_2
        case ("get_gchf_na_nb                "); .PROP:get_gchf_na_nb
        case ("get_gchf_sx_sy_sz             "); .PROP:get_gchf_sx_sy_sz
        case ("get_gchf_s2                   "); .PROP:get_gchf_s2
        case ("get_gchf_s2_orig              "); .PROP:get_gchf_s2_orig
        case ("get_gchf_s2_contributions     "); .PROP:get_gchf_s2_contributions
        case ("get_uhf_kramers               "); .PROP:get_uhf_kramers
        case ("get_uhf_kramers_2             "); .PROP:get_uhf_kramers_2
        case ("get_uhf_sx_sy_sz              "); .PROP:get_uhf_sx_sy_sz
        case ("get_uhf_s2                    "); .PROP:get_uhf_s2
        case ("get_uhf_s2_orig               "); .PROP:get_uhf_s2_orig
        case ("get_x_negative_laplacian_grid "); .GRID:get_x_negative_laplacian_grid
        case ("get_x_laplacian_grid          "); .GRID:get_x_laplacian_grid
        case ("get_x_structure_factors_pce   "); .XTAL:get_x_structure_factors_pce
        case ("get_x_structure_factors_test  "); .XTAL:get_x_structure_factors_test
        case ("geminal_mf_scheme_data=       "); .GEM:read_geminal_mf_scheme
        case ("geminal_mf_scheme             "); .GEM:do_geminal_mf_scheme
        case ("geminal_mf_scheme_restart     "); .GEM:restart_geminal_mf_scheme
        case ("generalized_seniority_conf=   "); .:make_conf

        case ("har_refinement                "); .TAD:HAR_refinement

        case ("iam_refinement                "); .TAD:IAM_refinement
        case ("integrate_density_numerically "); .MISC:integrate_density_numerically
        case ("integrate_ku_spin_numerically "); .MISC:integrate_ku_spin_numerically
        case ("integrate_nc_spin_numerically "); .MISC:integrate_nc_spin_numerically
        case ("integrate_spin_numerically    "); .MISC:integrate_spin_numerically
        case ("interpolator=                 "); .MAIN:read_interpolator
        case ("isosurface=                   "); .MAIN:read_isosurface
        case ("isosurface_plot               "); .PLOT:isosurface_plot

        case ("keyword_echo_on               "); .MAIN:set_keyword_echo_on
        case ("km_refinement                 "); .TAD:KM_refinement

        case ("localise_mos=                 "); .SCF:localize_MOs
        case ("localize_mos=                 "); .SCF:localize_MOs
        case ("low_verbosity_on              "); .MAIN:set_low_verbosity_on

        case ("make_ano_data                 "); .SCF:make_ANO_data
        case ("make_ao_density_matrix        "); .BASE:make_ao_density_matrix
        case ("make_ao_sz_density_matrix     "); .BASE:make_ao_sz_density_matrix
      ! case ("make_core_structure_factors   "); .MISC:make_core_structure_factors
        case ("make_dkh_density_norm         "); .REL:make_DKH_density_norm
        case ("make_fermi_contact_terms      "); .MISC:make_fermi_contact_terms
        case ("make_file_delta_density_grid  "); .MISC:make_file_delta_density_grid
        case ("make_file_delta_spin_grid     "); .MISC:make_file_delta_spin_grid
        case ("make_fock_guess               "); .SCF:make_fock_guess
        case ("make_fock_matrix              "); .SCF:make_fock_matrix
        case ("make_hirshfeld_inputs         "); .SCF:make_Hirshfeld_inputs(skip_NOs=TRUE)
        case ("make_iterative_has            "); .TAD:make_iterative_HAs
        case ("make_monomer_mos              "); .SCF:make_monomer_MOs
      ! case ("make_n_structure_factors      "); .XTAL:make_H_Sz_structure_factors
        case ("make_natural_orbitals         "); .BASE:make_natural_orbitals
        case ("make_overlap_matrix           "); .INTS:make_overlap_matrix
        case ("make_progroup_density_matrix  "); .SCF:make_progroup_density_matrix
        case ("make_promolecule_density      "); .SCF:make_promolecule_density
        case ("make_promol_density_matrix    "); .SCF:make_promolecule_density
        case ("make_group_density_matrix     "); .SCF:make_group_density_matrix
        case ("make_promol_mos               "); .SCF:make_promol_MOs
        case ("make_scf_density_matrix       "); .BASE:make_scf_density_matrix(damp=FALSE)
        case ("make_spherically_averaged_bdas"); .TAD:make_averaged_BDAs
        case ("make_spherically_averaged_has "); .TAD:make_spherically_averaged_HAs
        case ("make_symortho_density_matrix  "); .SCF:make_group_density_matrix
        case ("make_weak_force_energy_shift  "); .MISC:make_weak_force_energy_shift
        case ("move_origin                   "); .BASE:move_origin
        case ("move_origin_to_center_of_atoms"); .BASE:move_origin_to_center_of_atoms
        case ("move_origin_to_center_of_mass "); .BASE:move_origin_to_center_of_mass
        case ("mp2                           "); .MISC:mp2
        case ("rmp2                          "); .MISC:make_chem_mp2
        case ("multiplicity=                 "); .MAIN:read_spin_multiplicity ! deprecated

        case ("name=                         "); .:read_name
        case ("normal_mode_analysis          "); .PROP:normal_mode_analysis
        case ("nucleus_model=                "); .:read_nucleus_model

      ! case ("optimise_geometry             "); .:optimise_geometry
        case ("optimise_orbitals             "); .MISC:optimize_orbitals
        case ("optimize_orbitals             "); .MISC:optimize_orbitals
        case ("output_style_options=         "); .MAIN:read_output_style_options
        case ("pauli_block_geminals=         "); .GEM:read_pauli_block_geminals
        case ("pbg_energy                    "); .GEM:do_PBG_energy
        case ("pbg_optimization              "); .GEM:do_PBG_optimization

        case ("phi_step_size                 "); .MAIN:read_phi_step_size
        case ("plot                          "); .PLOT:plot
        case ("plots                         "); .PLOT:plots
        case ("plot_grid=                    "); .:read_plot_grid
        case ("plot_ku_density               "); .PLOT:plot_ku_density
        case ("plot_on_isosurface            "); .PLOT:plot_on_isosurface
        case ("pointgroup=                   "); .:read_pointgroup
        case ("put                           "); .BASE:put
        case ("put_1e_properties             "); .PROP:put_1e_properties
        case ("put_1e_properties_for_groups  "); .PROP:put_1e_properties_for_groups
        case ("put_adps                      "); .BASE:put_ADPs
        case ("put_anos                      "); .BASE:put_ANOs
        case ("put_ao_energy_partition       "); .PROP:put_AO_energy_partition
        case ("put_atom_groups               "); .BASE:put_atom_groups
        case ("put_atomic_form_factors       "); .BASE:put_atomic_form_factors
        case ("put_bda_charges               "); .TAD:put_BDA_charges
        case ("put_becke_grid_atom_info      "); .:becke_grid.put_atom_info
        case ("put_bond_length_with_error    "); .BASE:put_bond_length_with_error
        case ("put_bond_angle_with_error     "); .BASE:put_bond_angle_with_error
        case ("put_torsion_angle_with_error  "); .BASE:put_torsion_angle_with_error
        case ("put_cif                       "); .BASE:put_CIFs
        case ("put_cif_with_esds             "); .BASE:put_CIFs(with_esds=FALSE)
        case ("put_coppens_interpolators     "); .MISC:put_coppens_interpolators
        case ("put_coulomb_energy            "); .PROP:put_coulomb_energy
        case ("put_crystal                   "); .BASE:put_crystal
        case ("put_debug_list                "); .BASE:put_debug_list
        case ("put_density_matrix            "); .BASE:put_density_matrix
        case ("put_diff_coppens_slater_ints  "); .MISC:put_diff_coppens_slater_ints
        case ("put_diff_slater_interpolators "); .MISC:put_diff_slater_interpolators
        case ("put_dnc_displaced_geometries  "); .PROP:put_dnc_displaced_geometries
      ! case ("put_excel_crystal             "); .BASE:put_excel_crystal
        case ("put_fitting_plots             "); .:crystal.put_fitting_plots ! <--
        case ("put_fock_matrix               "); .BASE:put_fock_matrix
        case ("put_g_tensor_information      "); .MISC:put_g_tensor_information
        case ("put_geminal_mf_scheme         "); .:geminal_mf_scheme.put
        case ("put_generalized_seniority_conf"); .:generalized_seniority_conf.put
        case ("put_group_12_energies         "); .PROP:put_group_12_energies
        case ("put_group_12_spackman1986_ener"); .PROP:put_group_12_Spackman1986_energies
        case ("put_group_12_grimme2006_energy"); .PROP:put_group_12_grimme2006_energy
        case ("put_group_12_polarization_ener"); .PROP:put_group_12_polarization_energy
        case ("put_hirshfeld_atom_info       "); .PROP:put_Hirshfeld_atom_info
        case ("put_hirshfeld_g_and_k_energy  "); .MISC:put_Hirshfeld_G_and_K_energy
        case ("put_hirshfeld_polarisabilities"); .CP:put_H_polarisabilities
        case ("put_hirshfeld_polarizabilities"); .CP:put_H_polarisabilities
        case ("put_interpolator_list         "); .MISC:put_interpolator_list
        case ("put_minmax_residual_density   "); .SCF:put_minmax_residual_density
        case ("put_molecular_orbitals        "); .BASE:put_molecular_orbitals
        case ("put_mos_and_energies          "); .BASE:put_MOs_and_energies
        case ("put_mo_energies               "); .BASE:put_MO_energies
        case ("put_mo_energy_partition       "); .PROP:put_MO_energy_partition
        case ("put_mulliken_populations      "); .PROP:put_mulliken_populations
        case ("put_mulliken_ku_populations   "); .PROP:put_mulliken_ku_populations
        case ("put_mulliken_sf_populations   "); .PROP:put_mulliken_sf_populations
        case ("put_natural_orbitals          "); .BASE:put_natural_orbitals
      ! case ("put_nka_cartesian             "); .BASE:put_NKA_cartesian
      ! case ("put_nka_crystal               "); .BASE:put_NKA_crystal
        case ("put_normal_modes              "); .PROP:put_normal_modes
        case ("put_oscillator_overlaps       "); .MISC:put_oscillator_overlaps
        case ("put_overlap_eigenvalues       "); .MISC:put_overlap_eigenvalues
        case ("put_overlap_matrix            "); .MISC:put_overlap_matrix
        case ("put_overlapping_atoms         "); .BASE:put_overlapping_atoms
        case ("put_pauli_block_geminals      "); .:pauli_block_geminals.put
        case ("put_pdb                       "); .MISC:put_pdb
        case ("put_plot_grid                 "); .BASE:put_plot_grid
        case ("put_pnd_sf                    "); .XTAL:put_PND_sf
        case ("put_pointgroup                "); .BASE:put_pointgroup
        case ("put_principal_axes            "); .BASE:put_principal_axes
        case ("put_reflection_data           "); .crystal.put_reflection_data
        case ("put_roby_mmo_energy_partition "); .PROP:put_roby_mmo_energy_partition
        case ("put_roby_smo_energy_partition "); .PROP:put_roby_smo_energy_partition
        case ("put_sao_energy_partition      "); .PROP:put_SAO_energy_partition
        case ("put_scf_energy_in_mo_pairs    "); .PROP:put_scf_energy_in_mo_pairs
        case ("put_scf_energy_as_mo_parts    "); .PROP:put_scf_energy_as_mo_parts
        case ("put_scf_atomic_polarisabilitie"); .CP:put_scf_atomic_polarisability
        case ("put_scf_atomic_polarizabilitie"); .CP:put_scf_atomic_polarisability
        case ("put_scf_dipole_hyperpolarisabi"); .CP:put_scf_dipole_hyperpolarisa
        case ("put_scf_dipole_hyperpolarizabi"); .CP:put_scf_dipole_hyperpolarisa
        case ("put_scf_dipole_polarisability "); .CP:put_scf_dipole_polarisability
        case ("put_scf_dipole_polarizability "); .CP:put_scf_dipole_polarisability
        case ("put_shelx_fcf                 "); .BASE:put_shelx_fcf
        case ("put_shelx_hkl3                "); .BASE:put_shelx_hkl3
        case ("put_shelx_hkl4                "); .BASE:put_shelx_hkl4
        case ("put_slater_interpolators      "); .MISC:put_slater_interpolators
        case ("put_sos_dipole_polarisability "); .CP:put_sos_dipole_polarisability
        case ("put_sylvain_csizmadia_tensors "); .CP:put_sylvain_csizmadia_tensors
        case ("put_structure_factor_stats    "); .PROP:put_X_SF_statistics
        case ("put_structure_factors         "); .PROP:put_X_structure_factors
        case ("put_sz_structure_factors      "); .PROP:put_N_structure_factors
        case ("put_uc_dipole_polarisability  "); .CP:put_uc_dipole_polarisability
        case ("put_uc_dipole_polarizability  "); .CP:put_uc_dipole_polarisability
        case ("put_uc_dipole_hyperpolarisabil"); .CP:put_uc_dipole_hyperpolar
        case ("put_uc_dipole_hyperpolarizabil"); .CP:put_uc_dipole_hyperpolar
        case ("put_uc_chi2_old               "); .CP:put_uc_chi2
        case ("put_uc_refractive_index       "); .CP:put_uc_refractive_index
        case ("put_vrml                      "); .BASE:put_vrml

        case ("read_archive                  "); .BASE:read_archive
        case ("read_ascii_archive            "); .BASE:read_ascii_archive
        case ("read_pcc_density_matrix       "); .MISC:read_pcc_density_matrix
        case ("read_g03_fchk_file            "); .BASE:read_g03_FChk_file
        case ("read_g09_fchk_file            "); .BASE:read_g09_FChk_file
        case ("read_g94_fchk_file            "); .BASE:read_g94_FChk_file
        case ("read_g98_fchk_file            "); .BASE:read_g94_FChk_file
        case ("read_molden_file              "); .BASE:read_molden_MOs
        case ("read_molden_mos               "); .BASE:read_molden_MOs
        case ("read_molden_nos               "); .BASE:read_molden_NOs
        case ("read_tonto_fchk_file          "); .BASE:read_tonto_FChk_file
        case ("redirect                      "); .BASE:redirect
        case ("redirect_stdout               "); .BASE:redirect_stdout
        case ("refine_hirshfeld_atoms        "); .TAD:HAR_refinement
        case ("refine_independent_atoms      "); .TAD:IAM_refinement
        case ("refine_km_atoms               "); .TAD:KM_refinement
        case ("reset_molecule                "); .:reset_molecule
        case ("revert                        "); .BASE:revert
        case ("revert_stdout                 "); .BASE:revert_stdout
        case ("roby_analysis                 "); .PROP:roby_analysis
        case ("robydata=                     "); .:read_robydata
        case ("rotate                        "); .MAIN:read_rotate
        case ("rotate_group                  "); .MAIN:read_rotate_group
        case ("rotate_with_matrix            "); .MAIN:read_rotate_matrix

        case ("saved_basis_name=             "); .:read_saved_basis_name
        case ("saved_coppensbasis_name=      "); .:read_saved_coppensbasis_name
        case ("saved_slaterbasis_name=       "); .:read_saved_slaterbasis_name
        case ("saved_isosurface_plot         "); .PLOT:saved_isosurface_plot
        case ("saved_plot_on_isosurface      "); .PLOT:saved_plot_on_isosurface
        case ("set_isotropic_h_adps          "); .atom.set_isotropic_H_ADP
        case ("scf                           "); .SCF:scf
        case ("scfdata=                      "); .:read_scfdata
        case ("simulate_new_f_exp            "); .:crystal.simulate_new_F_exp
        case ("slaterbasis_name=             "); .:read_slaterbasis_name
        case ("spin_contamination            "); .PROP:spin_contamination
        case ("spin_multiplicity=            "); .:read_spin_multiplicity
        case ("serialize=                    "); .:read_serialize_filename
        case ("deserialize=                    "); .:read_deserialize_filename

        case ("unsave                        "); .BASE:unsave
        case ("use_interpolators=            "); .MAIN:read_use_interpolators
        case ("use_spherical_basis=          "); .MAIN:read_use_spherical_basis

        case ("write_aim2000_wfn_file        "); .BASE:write_aim2000_wfn_file
        case ("write_archive                 "); .BASE:write_archive
        case ("write_ascii_archive           "); .BASE:write_ascii_archive
        case ("write_tonto_fchk_mo           "); .BASE:write_tonto_FChk_MO
        case ("write_tonto_fchk_dm           "); .BASE:write_tonto_FChk_DM
        case ("write_morphy98_wfn_file       "); .BASE:write_morphy98_wfn_file

        case ("dispersion_coefficients=      "); ATOM:read_dispersion_coefficients

        case ("zero_off_atom_density         "); .MISC:zero_off_atom_density
        case ("zero_overlap_density          "); .MISC:zero_overlap_density

        ! Crystal Explorer commands ...

        case ("cx_file_name=                 "); .CE:read_CX_file_name
        case ("cx_isosurface=                "); .CE:read_CX_isosurface
        case ("cx_surface=                   "); .CE:read_CX_isosurface
        case ("cx_uses_angstrom=             "); .CE:read_CX_uses_angstrom

        case ("process_cif                   "); .CE:process_CIF
        case ("process_cif_cell_and_symmetry "); .CE:process_CIF_cell_and_symmetry
        case ("process_cif_for_cx            "); .CE:process_CIF_for_CX
        case ("put_cx_data                   "); .CE:put_CX_data
        case ("serialize_isosurface          "); .CE:serialize_isosurface_sbf

        ! Invarioms commands ...

        case ("put_next_neighbour_handedness "); .TAD:put_next_neighbour_handedness
        case ("put_invariom_label            "); .TAD:put_invariom_label
        case ("put_invariom_labels           "); .TAD:put_invariom_labels
        case ("put_smiles_invariom_labels    "); .TAD:put_smiles_invariom_labels

        ! Test commands ...

        case ("spherically_averaged_sf       "); .MISC:spherically_averaged_sf
        case ("test_dump_file                "); MOLECULE.MAIN:test_dump_file

        case  default ;               UNKNOWN(keyword)

      end

   end

!  A

   read_atoms ::: leaky
   ! Read in the atom list information
      DIE_IF(.cluster.created,"cluster already defined! swap cluster= and atoms= ?")
      WARN_IF(.atom.created,"atom list already defined!")

      ! Force update
      .atom_info_made = FALSE

      ! Read list keywords
      .atom.read_list_keywords

      ! Finalize
      .BASE:set_atom_info
      .BASE:finalize_atom_groups
      .BASE:resolve_basis_info

      ! Finalize crystal
      if (associated(.crystal)) then
         .BASE:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

      ! Make Hirshfeld info
      if (.scfdata.created) then
      if (.basis_info_made) then
      if (.crystal.created) then
      if (.crystal.data.created) then
      if (.crystal.data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

      ! Destroy stored atoms here
      .isosurface.destroy

   end

   read_atom_groups ::: leaky
   ! Read in the .atom_group information

      ! Read the atom groups
      .atom_group.read_list_keywords

      ! Make the atom groups
      ! Don't do this until the ANOs are made ...
      .BASE:finalize_atom_groups

   end

!  B

   read_B_field
   ! Read in the applied magnetic B field
      stdin.read_quantity(.B_field)
   end

   read_basis_sets ::: leaky
   ! Read in a list of atomic basis sets for the molecule
      WARN_IF(.basis.created,"basis sets already defined!")

      ! Copy bases
      if (.atom.created)  .atom.nullify_basis_part

      ! Basis sets are read in normalized, but internally
      ! are used unnormalized.
      if (.basis.created) .basis.renormalise
      .basis.read_list_keywords
      if (.basis.created) .basis.unnormalise

      ! Finalize
      .BASE:resolve_basis_info

      ! Make Hirshfeld info
      if (.scfdata.created) then
      if (.atom.created) then
      if (.crystal.created) then
      if (.crystal.data.created) then
      if (.crystal.data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

   end

   read_basis_directory
   ! Read in the basis directory (for all kinds of bases)

      directory :: STR

      stdin.read(directory)
      .BASE:set_basis_directory(directory)

   end

   read_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.

      name :: STR

      stdin.read(name)

      .BASE:set_basis_name(name)

   end

   read_becke_grid ::: leaky
   ! Read in the Becke integration grid data

   ENSURE(.atom.created,"input atom information before becke_grid information")

      if (.becke_grid.destroyed) .becke_grid.create

      ! Leaky
      .becke_grid.set_atom_info(.atom)
      .becke_grid.read_keywords
      .becke_grid.set_grid_data

   end

!  C

   read_charge
   ! Read in the total molecular charge

      stdin.read(.charge)

      ! Set the no. of electons
      if (.atom.created) .n_e = .BASE:no_of_electrons

   end

   read_cluster ::: leaky
   ! Read in the crystal cluster data. NOTE: the .atom list must correspond to
   ! the (unpruned or pruned) asymmetric unit cell geometry of the .crystal.
      self :: INOUT

   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")

      .crystal.make_fragment_data(.atom,assign_atom=TRUE)

   DIE_IF(.crystal.asymmetric_unit_atom.destroyed,"atom list missing asym atoms")

      .cluster.destroy
      .cluster.create(.crystal)

      .cluster.read_keywords

   end

   read_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms.
      this :: STR
      stdin.read(this)
      .BASE:set_coppensbasis_name(this)
   end

   read_crystal ::: leaky
   ! Read in the crystal data. If the ".atom" list data is available,
   ! its coordinates will be resolved into cartesians at this point.
   ! IMPORTANT NOTE: normally the crystal information will be inputted
   ! from a CIF file.  However, if the crystal information is inputted
   ! explicitly, and the asymmetric unit is not specified, then the
   ! symmetry unique atoms in the ".atom" list are used to define the
   ! crystal asymmetric unit. Once defined, the asymmetric unit in the
   ! crystal is never destroyed. Thus, in this case, you must ensure
   ! that your atom list has enough atoms to generate the entire
   ! crystal; for co-crystals this may be a problem. Use the CIF file
   ! method for input in this case, or be careful.

      WARN_IF(.crystal.created,"crystal data already defined!")

      ! Destroy
      if (.crystal.destroyed) .crystal.create

      ! Read
      .crystal.read_keywords

      ! Finalize crystal
      if (.crystal.finalize) then
         .crystal.update
         if (.atom.created) then
            .BASE:resolve_axis_system
            .crystal.make_fragment_data(.atom,assign_atom=TRUE)
         end
      end

      ! Set dispersion coefficients?
    ! if (.atom.created) then
    ! if (.crystal.xray_data.created) then
    ! if (.crystal.xray_data.have_set_wavelength) then
    !    .atom.set_dispersion_coefficients(.crystal.xray_data.wavelength)
    ! end
    ! end
    ! end

      ! Make Hirshfeld info
      if (.scfdata.created) then
      if (.basis_info_made) then
      if (.atom.created) then
      if (.crystal.xray_data.created) then
      if (.crystal.xray_data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

      ! Reset to finalize next time
      .crystal.finalize = TRUE

   end

!  E

   read_E_field
   ! Read in the applied electric E field
      stdin.read_quantity(.E_field)
   end

!  G

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      stdin.read_quantity(.gauge_origin)
   end

!  I

   read_interpolator ::: leaky
   ! Read template interpolators
      .interpolator.destroy
      .interpolator.create
      .interpolator.read_keywords
      .BASE:destroy_interpolators
   end

   read_isosurface ::: leaky
   ! Read in the isosurface data. NOTE: the isosurface has its own
   ! plotgrid, different from that used in normal density plots.

      ! Destroy
      if (.isosurface.destroyed) .isosurface.create(.atom)

      ! Read
      .isosurface.read_keywords

   end

!  K

   set_keyword_echo_on
   ! Echo keywords into the stdout file

   DIE_IF(tonto.destroyed,"tonto not created")

      ! Get rid of unused self error
      tonto.keyword_echo = transfer(self,tonto.keyword_echo)

      tonto.keyword_echo = TRUE

   end

!  L

   set_low_verbosity_on
   ! Set low output verbosity

   DIE_IF(tonto.destroyed,"tonto not created")

      ! Get rid of self error
      tonto.low_verbosity = transfer(self,tonto.low_verbosity)

      tonto.low_verbosity = TRUE

   end

!  M

!  N

   read_name
   ! Read in the name of the molecule. This must always be
   ! the first keyword inputted.
      self :: INOUT

      val :: STR

      stdin.read(val)

      .BASE:set_name(val)

   end

   read_nucleus_model ::: leaky
   ! Read whether what nucleus model to use
      stdin.read(.nucleus_model)
   end

!  O

   read_output_style_options ::: private
   ! Read new output style options, for example change the
   ! width and number of field, or precision of output.
      if (FALSE) self = self
      stdout.read_keywords(TEXTFILE::stdin)
   end

!  P

   read_phi_step_size ::: leaky
   ! Read in the dimensionless normal coordinate step size.

      stdin.read(.phi_step_size)

      WARN_IF(.phi_step_size<TOL(2),"phi_step_size may be too small")

   end

   read_plot_grid ::: leaky
   ! Read in the plot grid data

      ! Set up a defualt grid
      if (.plot_grid.destroyed) .plot_grid.create(.atom)

      ! Read options
      .plot_grid.read_keywords

      ! Check
      DIE_IF(.plot_grid.plot_format==" ","plot_format not specified (try all)")

   end

   read_pointgroup ::: leaky
   ! Read in the pointgroup data
      if (.pointgroup.destroyed) .pointgroup.create
      .pointgroup.read_keywords
   end

!  R

   read_rotate
   ! Rotate the whole molecule using matrix defined by its rotation "axis" and
   ! the "angle" of rotation around that axis, which are both inputted.
   ! Checked, 7/2/06; it needed the archives to be deleted to work
      R :: MAT{REAL}(3,3)
      axis :: VEC{REAL}(3)
      angle :: REAL

      ! Read axis
      stdin.read(axis)
      stdin.read(angle)
      ENSURE(NOT axis.is_zero,"axis must not be zero")

      ! Delete archives
      .BASE:delete_scf_archives

      ! Get the rotation matrix from the axis
      R.to_3x3_rotation_matrix(axis,angle)

      ! Rotate
      .BASE:rotate_by(R)

      ! Remake the Becke grid (leaky)
      if (.becke_grid.created) .becke_grid.set_grid_data(.atom)

   end

   read_rotate_group ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
   ENSURE(.atom_group.created,"no atom group information")

      axis :: VEC{REAL}(3)
      angle :: REAL
      g :: INT

      stdin.read(g)               ! read group
      stdin.read(axis)            ! read axis
      stdin.read_quantity(angle)  ! read angle

      ENSURE(g>0,"group number must be positive")
      ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
      ENSURE(NOT axis.is_zero,"axis must not be zero")

      .BASE:rotate_group(g,axis,angle)

   end

   read_rotate_matrix ::: leaky
   ! Same as read_rotate except reads the rotation matrix from the stdin
      R :: MAT{REAL}(3,3)

      ! Read matrix
      stdin.read(R)

      ! Delete archives
      .BASE:delete_scf_archives

      ! Rotate
      .BASE:rotate_by(R)

      ! Remake the Becke grid (leaky)
      if (.becke_grid.created) .becke_grid.set_grid_data(.atom)

   end

!  S

   read_spin_multiplicity
   ! Read in the spin multiplicity
      self :: INOUT

      val :: INT

      stdin.read(val)

      .BASE:set_spin_multiplicity(val)

   end

!  U

   read_use_interpolators
   ! Read whether to use interpolators
      stdin.read(.use_interpolators)
      if (.atom.created) .atom.set_use_interpolators(.use_interpolators)
   end

   read_use_spherical_basis ::: leaky
   ! Read whether to use a spherical basis
      stdin.read(.use_spherical_basis)
      .BASE:resolve_gaussianbases
   end

!  =============
!  Read routines
!  =============

   read_scfdata ::: leaky
   ! Read in the scf data

      if (.scfdata.destroyed) .scfdata.create

      ! Read options
      .scfdata.read_keywords

      ! Internal post-process options
      .scfdata.finalize

      ! Make Hirshfeld info
      if (.crystal.created) then
      if (.crystal.data.created) then
      if (.crystal.data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end

   end

   read_robydata ::: leaky
   ! Read in the Roby data. NOTE: this keyword must appear after a basis set
   ! has been defined
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")

      if (.roby.created) .roby.destroy

      .INTS:make_overlap_matrix
      .roby.create(self)

      .roby.read_keywords

      .roby.finalize

   end

   read_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms.
      self :: INOUT

      name :: STR

      stdin.read(name)
      .BASE:set_slaterbasis_name(name)

      ! Finalize crystal - remake basis kinds !
    ! if (associated(.crystal)) then
    !    .crystal.destroy_asymmetric_unit
    !    .crystal.make_fragment_data(.atom,assign_atom=TRUE)
    ! end

   end

   read_saved_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms in the
   ! *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      this :: STR
      stdin.read(this)
      .saved.BASE:set_basis_name(this)
   end

   read_saved_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms in the
   ! *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      this :: STR
      stdin.read(this)
      .saved.BASE:set_slaterbasis_name(this)
   end

   read_saved_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms in the
   ! *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      this :: STR
      stdin.read(this)
      .saved.BASE:set_coppensbasis_name(this)
   end

   read_slaterbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.slaterbasis.created,"slaterbasis sets already defined!")

      if (.atom.created)  .atom.nullify_slaterbasis_part

      if (.slaterbasis.created) .slaterbasis.renormalise
      .slaterbasis.read_list_keywords
      if (.slaterbasis.created) .slaterbasis.unnormalise

      .BASE:resolve_basis_info

   end

   read_coppensbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.coppensbasis.created,"coppensbasis sets already defined!")

      if (.atom.created)  .atom.nullify_coppensbasis_part

      if (.coppensbasis.created) .coppensbasis.renormalise
      .coppensbasis.read_list_keywords
      if (.coppensbasis.created) .coppensbasis.unnormalise

      .BASE:resolve_basis_info

   end

   read_serialize_filename ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      name :: STR
      stdin.read(name)
      .BASE:serialize(name)
   end

   read_deserialize_filename ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      self :: PTR
      name :: STR
      stdin.read(name)
      .BASE:deserialize(name)
   end

   test_dump_file ::: selfless
   ! Always put a comment ...
      d :: DATAFILE
      i :: INT
      i_in, i_out :: VEC{INT}@
      err :: INT
      i_in = [(i*i, i=1,100)]

      d.open("test.sbf")
      call d%sbf%add_dataset(sbf_Dataset("integer_dataset", i_in))
      stdout.show("integer_dataset write", i_in)
      call d%sbf%serialize
      d.close

      d.open("test.sbf")
      call d%sbf%deserialize
      call d%sbf%get("integer_dataset", i_out, err)
      stdout.show("integer_dataset read ", i_out)
      if (NOT err == 1) print *, "Error: ", sbf_strerr(err)
      d.close

   end

   batch_hs ::: leaky
      self :: PTR
      i :: INT
      formula, name, filename :: STR
      i = 1
      .cluster.create(.crystal) 
      .cluster.set_generation_method("fragment")
      .cluster.radius = ZERO
      .cluster.defragment = TRUE
      .cluster.make_info
      if(.cluster.n_molecules == 1) then
         formula = .atom.chemical_formula(FALSE)
         stdout.show("formula ", formula)
         name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
      ! Create the wavefunction
         .BASE:set_name(trim(name))
         call make_wavefunction(self)
         stdout.text("Wavefunction done.")
         filename = trim(name)//"-wfn.sbf"
         .BASE:serialize(filename)
         stdout.show("Creating Hirshfeld surface m =", i)
         call make_hirshfeld_surface(self, 0.2d0)
         stdout.text("Hirshfeld surface done.")
         filename = trim(name)//"-hs.sbf"
         .CE:serialize_isosurface_sbf(filename, .cif)
         return
      end

      do i= 1, .cluster.n_molecules
         .MAIN:make_hs_with_esp(i)
      end do
   end

   make_hs_with_esp(i) ::: private, leaky
      self :: PTR
      i :: INT
      mol :: MOLECULE*
      res :: REAL
      formula, name, filename :: STR

      res = 0.2

      mol.BASE:create
      .XTAL:create_cluster_mol(i, mol)
      formula = mol.atom.chemical_formula(FALSE)
      stdout.show("formula ", formula)
      name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
      ! Create the wavefunction
      mol.BASE:set_name(trim(name))
      mol.scfdata.copy(.scfdata)
      mol.basis_name = .basis_name
      mol.BASE:resolve_basis_info
      stdout.show("Generating wavefunction m =", i)
      call make_wavefunction(mol)
      stdout.text("Wavefunction done.")
      filename = trim(name)//"-wfn.sbf"
      mol.BASE:serialize(filename)
      stdout.show("Creating Hirshfeld surface m =", i)
      call make_hirshfeld_surface(mol, res)
      stdout.text("Hirshfeld surface done.")
      filename = trim(name)//"-hs.sbf"
      mol.CE:serialize_isosurface_sbf(filename, mol.cif)
   end

   make_hirshfeld_surface(m, res) ::: selfless, private, leaky
      m :: MOLECULE*
      res :: REAL, IN
      m.cluster.create(m.crystal)
      m.cluster.set_generation_method("for_hirshfeld_surface")
      m.cluster.atom_density_cutoff = 1.0e-8
      m.cluster.defragment = FALSE
      m.cluster.make_info
      m.XTAL:create_cluster

      m.atom.set_basis_kind("slater")
      !interpolators
      m.interpolator.create
      m.interpolator.set_interpolation_method("linear")
      m.interpolator.set_domain_mapping("sqrt")
      m.interpolator.set_table_eps(1.0d-10)
      m.interpolator.set_table_spacing(1.0d-1)
      m.BASE:destroy_interpolators

      ! Create CX_isosurface
      m.isosurface.create(m.atom)
      m.isosurface.property = "stockholder_weight"
      m.isosurface.triangulation_method = "recursive_marching_cube"
      m.isosurface.iso_value = 0.5
      m.isosurface.minimum_scan_division = 1
      m.isosurface.voxel_proximity_factor = 5
      m.isosurface.CX_output_distance_properties = TRUE
      m.isosurface.CX_output_shape_properties = TRUE
      ! Initialize CX_isosurface.plot_grid
      m.isosurface.plot_grid.use_bcube_with_shape_axes
      m.isosurface.plot_grid.set_cube_scale_factor(1.0d0)
      ! Desired separation is essentially the resolution of the calculated surface
      m.isosurface.plot_grid.desired_separation = res
      ! Make isosurface
      m.PLOT:isosurface_plot

      m.isosurface.surface_property = "electric_potential"
      m.atom.set_basis_kind("gaussian")
      m.PLOT:saved_plot_on_isosurface
   end

   generate_all_wavefunctions ::: leaky
      self :: PTR
      mol :: MOLECULE*
      i :: INT
      formula :: STR
      filename, name :: STR
      .cluster.create(.crystal) 
      .cluster.set_generation_method("fragment")
      .cluster.radius = ZERO
      .cluster.defragment = TRUE
      .cluster.make_info
      i = 1
      if(.cluster.n_molecules == 1) then
         formula = .atom.chemical_formula(FALSE)
         call make_wavefunction(self)
         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)//".sbf"
         .BASE:serialize(filename)
         return
      end

      do i= 1, .cluster.n_molecules
         mol.BASE:create
         .XTAL:create_cluster_mol(i, mol)
         formula = mol.atom.chemical_formula(FALSE)
         name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
         mol.BASE:set_name(trim(name))
         mol.basis_name = .basis_name
         mol.scfdata.copy(.scfdata)
         call make_wavefunction(mol)
         filename = trim(name)//".sbf"
         mol.BASE:serialize(filename)
      end do
   end

   make_wavefunction(m) ::: selfless, private, leaky
      m :: MOLECULE*
      m.SCF:make_ANO_data
      stdout.text("Beginning SCF")
      m.SCF:scf
   end

   make_conf ::: leaky
   ! 
      i,j :: INT
      r :: VEC{REAL}(3)
      h :: MAT{REAL}*
      d :: REAL

     h.create(60,60)
     h=ZERO
     do i=1, .n_atom
       do j=i+1, .n_atom
         r=.atom(i).position - .atom(j).position
         d=sqrt(r(1)*r(1)+r(2)*r(2)+r(3)*r(3))
         if (d < 3.0d0) then
           h(i,j) =-ONE
           h(j,i) =-ONE
         end
     !    write(*,*) i,j,h(i,j)
       end
     end
     .generalized_seniority_conf.create
     .generalized_seniority_conf.read_keywords
     .generalized_seniority_conf.make_orbitals(h)
   end

end
