!==============================================================================-
!
! MOLECULE: An object repxresentation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!==============================================================================-


module MOLECULE.MAIN

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

!  ================
!  Main controllers
!  ================

   run(basis_library_dir) ::: leaky
   ! Main molecule run-loop; assumes stdin and stdout have been defined.
      self :: PTR
      basis_library_dir :: STR, optional, IN

      ! Set up molecule
      .:setup(basis_library_dir)

      ! Banner
      MOLECULE.MAIN:put_banner

      ! Read & process keywords
      .:read_keywords

      ! Finish timing
      std_time.stop_timing

      stdout.flush
      stdout.text(std_time.elapsed_time_message("job "//'"'// trim(.name) //'"'))
      stdout.text(std_time.elapsed_cpu_time_message("job "//'"'// trim(.name) //'"'))

      ! Warnings
      if (tonto.warnings_issued) then
      stdout.flush
      stdout.text("WARNINGS were issued in this job.")
      stdout.text("Look above, or in the stderr file.")
      end

   end

   setup(basis_library_dir) ::: leaky
   ! Set up a molecule ready to do something.
      self :: PTR
      basis_library_dir :: STR, optional, IN

      ! Start timer
      std_time.start_timing

      ! Create (leaky)
      .BASE:create
      if (present(basis_library_dir)) then
      if (basis_library_dir /= " ") then
         .BASE:set_basis_directory(basis_library_dir)
      end
      end

      ! Gaussian indices (leaky)
      GAUSSIAN_DATA:set_indices(GAUSSIAN_DATA_L_MAX)

   end

   put_banner ::: selfless
   ! Put to stdout the current TONTO banner

      stdout.text("_______________________________________________________________")
      stdout.text("                                                               ")
      stdout.text(" T   O   N   T   O                                             ")
      stdout.text("                                                               ")
      stdout.text(" A free object-based system for computational chemistry        ")
      stdout.text("                                                               ")
      stdout.text(" Version: "//TONTO_VERSION//" v. "//GIT_VERSION)
      stdout.text(" Platform: "//TONTO_PLATFORM)
      stdout.text(" Build-date: "//TONTO_BUILD_DATE)
      stdout.text("                                                               ")
      stdout.text(" For conditions of use, on-line documentation, and contributor ")
      stdout.text(" and developer information see :-                              ")
      stdout.text("                                                               ")
      stdout.text(" https://"//"github."//"com/"//"dylan-jayatilaka/tonto         ")
      stdout.text("                                                               ")
      stdout.text(" Dylan Jayatilaka                                              ")
      stdout.text(" Daniel Grimwood                                               ")
      stdout.text(" Peter Spackman                                                ")
      stdout.text("_______________________________________________________________")

      stdout.flush
      stdout.flush
      stdout.text(std_time.start_time_message)
      stdout.flush

   end

   cleanup ::: leaky
   ! Clean up all undeleted memory in all modules.
      self :: PTR

      atom :: ATOM
      basis :: BASIS
      coppensbasis :: COPPENSBASIS
      coppensorbital :: COPPENSORBITAL
      reflection :: REFLECTION
      shell :: SHELL
      slaterbasis :: SLATERBASIS
      slatershell :: SLATERSHELL

      ! Clean self
      .BASE:destroy

      ! Gaussian indices
      GAUSSIAN_DATA:destroy_data

      ! Clear all keys
      atom.clear_keys
      basis.clear_keys
      coppensbasis.clear_keys
      coppensorbital.clear_keys
      reflection.clear_keys
      shell.clear_keys
      slaterbasis.clear_keys
      slatershell.clear_keys

   end

   reset_molecule ::: leaky
   ! Resets the mol data type and reruns the read routine
      self :: PTR
      word :: STR

      .BASE:destroy
      .BASE:create

      ! First keyword must be "name"
      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="name=","first keyword must be name")

      stdin.read(.name)

   end

!  =================
!  Read/Set routines
!  =================

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: recursive, leaky
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
   ! NOTE : this routine reuires a MOLECULE pointer self variable
      self :: PTR
      keyword :: STR, IN

      select case (keyword(1:30))

      case ("}                             "); ! exit case

      case ("assign_mos_to_nos             "); .BASE:assign_MOs_to_NOs
      case ("assign_nos_to_mos             "); .BASE:assign_NOs_to_MOs
      case ("atoms=                        "); .:read_atoms
      case ("atom_groups=                  "); .:read_atom_groups
      case ("atom_group_charges=           "); stdin.read_ptr(.atom_group_charges)

      case ("b_field=                      "); .:read_B_field
      case ("basis_sets=                   "); .:read_basis_sets
      case ("basis_directory=              "); .:read_basis_directory
      case ("basis_library=                "); .:read_basis_directory
      case ("basis_name=                   "); .:read_basis_name
      case ("basis_set=                    "); .:read_basis_name
      case ("batch_surfaces                "); .:batch_hs
      case ("generate_wavefunctions        "); .:generate_all_wavefunctions
      case ("becke_grid=                   "); .:read_becke_grid

      case ("canonicalize_mos              "); .SCF:canonicalize_MOs
      case ("change_axis_system_to         "); .BASE:change_axis_system_to
      case ("change_to_principal_axes      "); .BASE:change_to_principal_axes
      case ("change_to_principal_top_axes  "); .BASE:change_to_principal_top_axes
      case ("charge=                       "); .:read_charge
      case ("cif=                          "); .XTAL:read_CIF
      case ("cleanup_scf                   "); .SCF:cleanup_scf
      case ("cluster=                      "); .:read_cluster
      case ("coppensbasis_name=            "); .:read_coppensbasis_name
      case ("create_cluster                "); .XTAL:create_cluster
      case ("create_cluster_mol            "); .XTAL:create_cluster_mol
      case ("create_g09_wfn_from_crystal   "); .:generate_g09_input
      case ("create_hs_cluster             "); .XTAL:create_HS_cluster
      case ("crystal=                      "); .:read_crystal

      case ("debug_on                      "); .BASE:read_debug_on
      case ("debug_off                     "); .BASE:read_debug_off
      case ("defragment                    "); .CE:defragment
      case ("delete_plot_grid              "); .GRID:delete_plot_grid
      case ("delete_scf_archives           "); .BASE:delete_scf_archives
      case ("delete_scf_integrals          "); .BASE:destroy_scf_integrals
      case ("deserialize=                  "); .:read_deserialize_filename
      case ("destroy_atom_groups           "); .BASE:destroy_atom_group
      case ("destroy_cluster               "); .XTAL:destroy_cluster
      case ("dispersion_coefficients=      "); .:read_dispersion_coefficients
      case ("dump_xyz_files                "); .:dump_xyz_files
    ! case ("dvpt_scf                      "); .MISC.DVPT_scf

      case ("e_field=                      "); .:read_E_field

      case ("find_d_norm_contacts          "); .MAIN:find_d_norm_contacts
      case ("fit_hirshfeld_atoms           "); .TAD:LS_fit_Hirshfeld_atoms
      case ("fit_hirshfeld_atom_kappas     "); .MISC:fit_Hirshfeld_atom_kappas
      case ("force_constants=              "); .PROP:read_force_constants
      case ("fraghar                       "); .TAD:fragHAR_refinement
      case ("fraghar_refinement            "); .TAD:fragHAR_refinement

      case ("gauge_origin=                 "); .:read_gauge_origin
      case ("get_bader_regions             "); .PROP:get_Bader_regions
      case ("get_dedr_iotc                 "); .REL:get_dEdR_IOTC
      case ("get_g_overlap_nuc             "); .REL:get_g_overlap_nuc
      case ("get_gchf_jz                   "); .PROP:get_gchf_jz
      case ("get_gchf_kramers              "); .PROP:get_gchf_kramers
      case ("get_gchf_kramers_2            "); .PROP:get_gchf_kramers_2
      case ("get_gchf_na_nb                "); .PROP:get_gchf_na_nb
      case ("get_gchf_sx_sy_sz             "); .PROP:get_gchf_sx_sy_sz
      case ("get_gchf_s2                   "); .PROP:get_gchf_s2
      case ("get_gchf_s2_orig              "); .PROP:get_gchf_s2_orig
      case ("get_gchf_s2_contributions     "); .PROP:get_gchf_s2_contributions
      case ("get_uhf_kramers               "); .PROP:get_uhf_kramers
      case ("get_uhf_kramers_2             "); .PROP:get_uhf_kramers_2
      case ("get_uhf_sx_sy_sz              "); .PROP:get_uhf_sx_sy_sz
      case ("get_uhf_s2                    "); .PROP:get_uhf_s2
      case ("get_uhf_s2_orig               "); .PROP:get_uhf_s2_orig
      case ("get_x_negative_laplacian_grid "); .GRID:get_x_negative_laplacian_grid
      case ("get_x_laplacian_grid          "); .GRID:get_x_laplacian_grid
      case ("get_x_structure_factors_pce   "); .XTAL:get_x_structure_factors_pce
      case ("get_x_structure_factors_test  "); .XTAL:get_x_structure_factors_test

      case ("har_refinement                "); .TAD:HAR_refinement

      case ("iam_refinement                "); .TAD:IAM_refinement
      case ("integrate_density_numerically "); .MISC:integrate_density_numerically
      case ("integrate_ku_spin_numerically "); .MISC:integrate_ku_spin_numerically
      case ("integrate_nc_spin_numerically "); .MISC:integrate_nc_spin_numerically
      case ("integrate_spin_numerically    "); .MISC:integrate_spin_numerically
      case ("interpolator=                 "); .MAIN:read_interpolator
      case ("isosurface=                   "); .MAIN:read_isosurface
      case ("isosurface_plot               "); .PLOT:isosurface_plot

      case ("keyword_echo_on               "); .MAIN:set_keyword_echo_on

      case ("lattice_energy                "); .:lattice_energy
      case ("lattice_energy_convergence=   "); MOLECULE.MAIN:read_e_lat_convergence
      case ("localise_mos=                 "); .SCF:localize_MOs
      case ("localize_mos=                 "); .SCF:localize_MOs
      case ("low_verbosity_on              "); .MAIN:set_low_verbosity_on

      case ("make_ano_data                 "); .SCF:make_ANO_data
      case ("make_ao_density_matrix        "); .BASE:make_ao_density_matrix
      case ("make_ao_sz_density_matrix     "); .BASE:make_ao_sz_density_matrix
    ! case ("make_core_structure_factors   "); .MISC:make_core_structure_factors
      case ("make_cluster_charges          "); .SCF:make_cluster_charges
      case ("make_dkh_density_norm         "); .REL:make_DKH_density_norm
      case ("make_fermi_contact_terms      "); .MISC:make_fermi_contact_terms
      case ("make_file_delta_density_grid  "); .MISC:make_file_delta_density_grid
      case ("make_file_delta_spin_grid     "); .MISC:make_file_delta_spin_grid
      case ("make_fock_guess               "); .SCF:make_fock_guess
      case ("make_fock_matrix              "); .SCF:make_fock_matrix
      case ("make_hirshfeld_inputs         "); .SCF:make_Hirshfeld_inputs(skip_NOs=TRUE)
      case ("make_iterative_has            "); .TAD:make_iterative_HAs
      case ("make_monomer_mos              "); .SCF:make_monomer_MOs
      case ("make_n_structure_factors      "); .SCF:make_N_SFs
      case ("make_natural_orbitals         "); .BASE:make_natural_orbitals
      case ("make_overlap_matrix           "); .INTS:make_overlap_matrix
      case ("make_progroup_density_matrix  "); .SCF:make_progroup_density_matrix
      case ("make_promolecule_density      "); .SCF:make_promolecule_density
      case ("make_promol_density_matrix    "); .SCF:make_promolecule_density
      case ("make_group_density_matrix     "); .SCF:make_group_density_matrix
      case ("make_promol_mos               "); .SCF:make_promol_MOs
      case ("make_scf_density_matrix       "); .BASE:make_scf_density_matrix(damp=FALSE)
      case ("make_spherically_averaged_bdas"); .TAD:make_averaged_BDAs
      case ("make_spherically_averaged_has "); .TAD:make_spherically_averaged_HAs
      case ("make_structure_factors        "); .SCF:make_X_SFs
      case ("make_symortho_density_matrix  "); .SCF:make_group_density_matrix
      case ("make_weak_force_energy_shift  "); .MISC:make_weak_force_energy_shift
      case ("make_x_structure_factors      "); .SCF:make_X_SFs
      case ("mfcc_har                      "); .TAD:fragHAR_refinement
      case ("move_origin                   "); .BASE:move_origin
      case ("move_origin_to_center_of_atoms"); .BASE:move_origin_to_center_of_atoms
      case ("move_origin_to_center_of_mass "); .BASE:move_origin_to_center_of_mass
      case ("mp2                           "); .MISC:mp2
      case ("multiplicity=                 "); .MAIN:read_spin_multiplicity ! deprecated

      case ("name=                         "); .:read_name
      case ("no_scf                        "); .NOMO:no_scf
      case ("normal_mode_analysis          "); .PROP:normal_mode_analysis
      case ("nucleus_model=                "); .:read_nucleus_model

    ! case ("optimise_geometry             "); .:optimise_geometry
      case ("optimise_orbitals             "); .MISC:optimize_orbitals
      case ("optimize_orbitals             "); .MISC:optimize_orbitals
      case ("output_style_options=         "); .MAIN:read_output_style_options

      case ("pair_energy_model=            "); MOLECULE.MAIN:read_pair_energy_model

      case ("phi_step_size                 "); .MAIN:read_phi_step_size
      case ("plot                          "); .PLOT:plot
      case ("plots                         "); .PLOT:plots
      case ("plot_grid=                    "); .:read_plot_grid
      case ("plot_ku_density               "); .PLOT:plot_ku_density
      case ("plot_on_isosurface            "); .PLOT:plot_on_isosurface
      case ("plot_uc_density               "); .:plot_uc_density
      case ("pointgroup=                   "); .:read_pointgroup
      case ("put                           "); .BASE:put
      case ("put_1e_properties             "); .PROP:put_1e_properties
      case ("put_1e_properties_for_groups  "); .PROP:put_1e_properties_for_groups
      case ("put_km_1e_properties          "); .PROP:put_1e_properties_with_KM
      case ("put_adps                      "); .BASE:put_ADPs
      case ("put_anos                      "); .BASE:put_ANOs
      case ("put_ao_energy_partition       "); .PROP:put_AO_energy_partition
      case ("put_atom_groups               "); .BASE:put_atom_groups
      case ("put_atomic_form_factors       "); .BASE:put_atomic_form_factors
      case ("put_bda_charges               "); .TAD:put_BDA_charges
      case ("put_becke_grid_atom_info      "); .:becke_grid.put_atom_info
      case ("put_bond_length_with_error    "); .BASE:put_bond_length_with_error
      case ("put_bond_angle_with_error     "); .BASE:put_bond_angle_with_error
      case ("put_torsion_angle_with_error  "); .BASE:put_torsion_angle_with_error
      case ("put_cif                       "); .BASE:put_CIFs
      case ("put_grown_cif                 "); .BASE:put_grown_CIF
      case ("put_cif_with_esds             "); .BASE:put_CIFs(with_esds=FALSE)
      case ("put_coppens_interpolators     "); .MISC:put_coppens_interpolators
      case ("put_coulomb_energy            "); .PROP:put_coulomb_energy
      case ("put_crystal                   "); .BASE:put_crystal
      case ("put_debug_list                "); .BASE:put_debug_list
      case ("put_density_matrix            "); .BASE:put_density_matrix
      case ("put_diff_coppens_slater_ints  "); .MISC:put_diff_coppens_slater_ints
      case ("put_diff_slater_interpolators "); .MISC:put_diff_slater_interpolators
      case ("put_dnc_displaced_geometries  "); .PROP:put_dnc_displaced_geometries
    ! case ("put_excel_crystal             "); .BASE:put_excel_crystal
      case ("put_fitting_plots             "); .:crystal.put_fitting_plots ! <--
      case ("put_fock_matrix               "); .BASE:put_fock_matrix
      case ("put_g_tensor_information      "); .MISC:put_g_tensor_information
      case ("put_group_12_energies         "); .PROP:put_group_12_energies
      case ("put_group_12_multipole_energy "); .PROP:put_group_12_multipole_energies
      case ("put_group_12_spackman1986_ener"); .PROP:put_group_12_Spackman1986_energies
      case ("put_group_12_grimme2006_energy"); .PROP:put_group_12_grimme2006_energy
      case ("put_group_12_polarization_ener"); .PROP:put_group_12_polarization_energy
      case ("put_hirshfeld_atom_info       "); .PROP:put_Hirshfeld_atom_info
      case ("put_hirshfeld_g_and_k_energy  "); .MISC:put_Hirshfeld_G_and_K_energy
      case ("put_hirshfeld_polarisabilities"); .CP:put_H_polarisabilities
      case ("put_hirshfeld_polarizabilities"); .CP:put_H_polarisabilities
      case ("put_interpolator_list         "); .MISC:put_interpolator_list
      case ("put_minmax_residual_density   "); .SCF:get_minmax_residual_density(output=TRUE)
      case ("put_molecular_orbitals        "); .BASE:put_molecular_orbitals
      case ("put_mos_and_energies          "); .BASE:put_MOs_and_energies
      case ("put_mo_energies               "); .BASE:put_MO_energies
      case ("put_mo_energy_partition       "); .PROP:put_MO_energy_partition
      case ("put_mulliken_populations      "); .PROP:put_mulliken_populations
      case ("put_mulliken_ku_populations   "); .PROP:put_mulliken_ku_populations
      case ("put_mulliken_sf_populations   "); .PROP:put_mulliken_sf_populations
      case ("put_natural_orbitals          "); .BASE:put_natural_orbitals
    ! case ("put_nka_cartesian             "); .BASE:put_NKA_cartesian
    ! case ("put_nka_crystal               "); .BASE:put_NKA_crystal
      case ("put_n_structure_factors       "); .PROP:put_N_SFs
      case ("put_normal_modes              "); .PROP:put_normal_modes
      case ("put_oscillator_overlaps       "); .MISC:put_oscillator_overlaps
      case ("put_overlap_eigenvalues       "); .MISC:put_overlap_eigenvalues
      case ("put_overlap_matrix            "); .MISC:put_overlap_matrix
      case ("put_overlapping_atoms         "); .BASE:put_overlapping_atoms
    ! case ("put_pdb                       "); .MISC:put_pdb
      case ("put_plot_grid                 "); .BASE:put_plot_grid
      case ("put_pnd_sf                    "); .XTAL:put_PND_sf
      case ("put_pointgroup                "); .BASE:put_pointgroup
      case ("put_principal_axes            "); .BASE:put_principal_axes
      case ("put_reflection_data           "); .crystal.put_reflection_data
      case ("put_roby_mmo_energy_partition "); .PROP:put_roby_mmo_energy_partition
      case ("put_roby_smo_energy_partition "); .PROP:put_roby_smo_energy_partition
      case ("put_sao_energy_partition      "); .PROP:put_SAO_energy_partition
      case ("put_scf_energy_in_mo_pairs    "); .PROP:put_scf_energy_in_mo_pairs
      case ("put_scf_energy_as_mo_parts    "); .PROP:put_scf_energy_as_mo_parts
      case ("put_scf_atomic_polarisabilitie"); .CP:put_scf_atomic_polarisability
      case ("put_scf_atomic_polarizabilitie"); .CP:put_scf_atomic_polarisability
      case ("put_scf_dipole_hyperpolarisabi"); .CP:put_scf_dipole_hyperpolarisa
      case ("put_scf_dipole_hyperpolarizabi"); .CP:put_scf_dipole_hyperpolarisa
      case ("put_scf_dipole_polarisability "); .CP:put_scf_dipole_polarisability
      case ("put_scf_dipole_polarizability "); .CP:put_scf_dipole_polarisability
      case ("put_shelx_fcf5                "); .BASE:put_shelx_fcf5
      case ("put_shelx_fcf6                "); .BASE:put_shelx_fcf6
      case ("put_shelx_hkl3                "); .BASE:put_shelx_hkl3
      case ("put_shelx_hkl4                "); .BASE:put_shelx_hkl4
      case ("put_slater_interpolators      "); .MISC:put_slater_interpolators
      case ("put_sos_dipole_polarisability "); .CP:put_sos_dipole_polarisability
      case ("put_sylvain_csizmadia_tensors "); .CP:put_sylvain_csizmadia_tensors
      case ("put_structure_factor_stats    "); .PROP:put_X_SF_statistics
      case ("put_structure_factors         "); .PROP:put_X_SFs
      case ("put_uc_dipole_polarisability  "); .CP:put_uc_dipole_polarisability
      case ("put_uc_dipole_polarizability  "); .CP:put_uc_dipole_polarisability
      case ("put_uc_dipole_hyperpolarisabil"); .CP:put_uc_dipole_hyperpolar
      case ("put_uc_dipole_hyperpolarizabil"); .CP:put_uc_dipole_hyperpolar
      case ("put_uc_chi2_old               "); .CP:put_uc_chi2
      case ("put_uc_refractive_index       "); .CP:put_uc_refractive_index
      case ("put_vrml                      "); .BASE:put_vrml
      case ("put_xyz_file                  "); .atom.put_xyz_file

      case ("read_archive                  "); .BASE:read_archive
      case ("read_ascii_archive            "); .BASE:read_ascii_archive
      case ("read_pcc_density_matrix       "); .MISC:read_pcc_density_matrix
      case ("read_g09_fchk_file            "); .BASE:read_g09_FChk_file
      case ("read_gaussian_fchk_file       "); .BASE:read_g09_FChk_file
      case ("read_molden_file              "); .BASE:read_molden_MOs
      case ("read_molden_mos               "); .BASE:read_molden_MOs
      case ("read_molden_nos               "); .BASE:read_molden_NOs
      case ("read_tonto_fchk_file          "); .BASE:read_tonto_FChk_file
      case ("redirect                      "); .BASE:redirect
      case ("redirect_stdout               "); .BASE:redirect_stdout
      case ("refine_hirshfeld_atoms        "); .TAD:HAR_refinement
      case ("reset_molecule                "); .:reset_molecule
      case ("revert                        "); .BASE:revert
      case ("revert_stdout                 "); .BASE:revert_stdout
      case ("rmp2                          "); .MISC:make_chem_mp2
      case ("roby_analysis                 "); .PROP:roby_analysis
      case ("robydata=                     "); .:read_robydata
      case ("rotate                        "); .MAIN:read_rotate
      case ("rotate_group                  "); .MAIN:read_rotate_group
      case ("rotate_with_matrix            "); .MAIN:read_rotate_matrix

      case ("saved_basis_name=             "); .:read_saved_basis_name
      case ("saved_coppensbasis_name=      "); .:read_saved_coppensbasis_name
      case ("saved_slaterbasis_name=       "); .:read_saved_slaterbasis_name
      case ("saved_isosurface_plot         "); .PLOT:saved_isosurface_plot
      case ("saved_plot_on_isosurface      "); .PLOT:saved_plot_on_isosurface
      case ("set_isotropic_adps            "); .:set_isotropic_ADPs
      case ("set_isotropic_h_adps          "); .:set_isotropic_H_ADPs
      case ("scf                           "); .SCF:scf
      case ("scfdata=                      "); .:read_scfdata
      case ("shorten_vdw_bond              "); .atom.shorten_shortest_vdw_bond
    ! case ("simulate_new_f_exp            "); .:crystal.simulate_new_F_exp ! use F_sigma_noise
      case ("slaterbasis_name=             "); .:read_slaterbasis_name
      case ("spin_contamination            "); .PROP:spin_contamination
      case ("spin_multiplicity=            "); .:read_spin_multiplicity
      case ("serialize=                    "); .:read_serialize_filename

      case ("table_column=                 "); MOLECULE.MAIN:read_table_column

      case ("unsave                        "); .BASE:unsave
      case ("use_interpolators=            "); .MAIN:read_use_interpolators
      case ("use_spherical_basis=          "); .MAIN:read_use_spherical_basis

      case ("write_aim2000_wfn_file        "); .BASE:write_aim2000_wfn_file
      case ("write_florian_wfn_file        "); .BASE:write_florian_wfn_file
      case ("write_archive                 "); .BASE:write_archive
      case ("write_ascii_archive           "); .BASE:write_ascii_archive
      case ("write_tonto_fchk_mo           "); .BASE:write_tonto_FChk_MO
      case ("write_tonto_fchk_dm           "); .BASE:write_tonto_FChk_DM
      case ("write_morphy98_wfn_file       "); .BASE:write_morphy98_wfn_file
      case ("write_xyz_file                "); .BASE:write_xyz_file

      case ("zero_off_atom_density         "); .MISC:zero_off_atom_density
      case ("zero_overlap_density          "); .MISC:zero_overlap_density

      ! Crystal Explorer commands ...

      case ("cx_file_name=                 "); .CE:read_CX_file_name
      case ("cx_isosurface=                "); .CE:read_CX_isosurface
      case ("cx_surface=                   "); .CE:read_CX_isosurface
      case ("cx_uses_angstrom=             "); .CE:read_CX_uses_angstrom

      case ("process_cif                   "); .CE:process_CIF
      case ("process_cif_cell_and_symmetry "); .CE:process_CIF_cell_and_symmetry
      case ("process_cif_for_cx            "); .CE:process_CIF_for_CX
      case ("put_cx_data                   "); .CE:put_CX_data
      case ("serialize_isosurface          "); .CE:serialize_isosurface_sbf

      ! Invarioms commands ...

      case ("put_next_neighbour_handedness "); .TAD:put_next_neighbour_handedness
      case ("put_invariom_label            "); .TAD:put_invariom_label
      case ("put_invariom_labels           "); .TAD:put_invariom_labels
      case ("put_smiles_invariom_labels    "); .TAD:put_smiles_invariom_labels

      ! Test commands ...

      case ("spherically_averaged_sf       "); .MISC:spherically_averaged_sf
      case ("test_dump_file                "); MOLECULE.MAIN:test_dump_file

      case  default ;               UNKNOWN(keyword)

      end

   end

!  A

   read_atoms ::: leaky
   ! Read in the atom list information
      self :: INOUT

   DIE_IF(.cluster.associated,"cluster already defined! swap cluster= and atoms= ?")
   WARN_IF(.atom.associated,"atom list already defined!")

      ! Destroy atom_groups & reset group indices
      .atom_group.destroy

      ! Force update
      .atom_info_made = FALSE

      ! Read list keywords
      .atom.read_list_keywords

      ! Finalize
      .BASE:finalize_atoms

      ! Make Hirshfeld info
      if (.scfdata.associated) then
      if (.basis_info_made) then
      if (.crystal.associated) then
      if (.crystal.xray_data.associated) then
      if (.crystal.xray_data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

   end

   read_atom_groups ::: leaky
   ! Read in the .atom_group information
      self :: INOUT

   WARN_IF(.atom.associated,"normally, atoms= must be defined before atom_groups=")

      ! Read the atom groups
      .atom_group.read_list_keywords

      ! Make the atom groups
      ! Don't do this until the ANOs are made ...
      .BASE:finalize_atom_groups

   end

!  B

   read_B_field
   ! Read in the applied magnetic B field
      self :: INOUT

      stdin.read_quantity(.B_field)

   end

   read_basis_sets ::: leaky
   ! Read in a list of atomic basis sets for the molecule
      self :: INOUT

      WARN_IF(.basis.associated,"basis sets already defined!")

      ! Copy bases
      if (.atom.associated)  .atom.nullify_basis_part

      ! Basis sets are read in normalized, but internally
      ! are used unnormalized.
      if (.basis.associated) .basis.renormalise
      .basis.read_list_keywords
      if (.basis.associated) .basis.unnormalise

      ! Finalize
      .BASE:finalize_atoms

      ! Make Hirshfeld info
      if (.scfdata.associated) then
      if (.atom.associated) then
      if (.crystal.associated) then
      if (.crystal.data.associated) then
      if (.crystal.data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

   end

   read_basis_directory
   ! Read in the basis directory (for all kinds of bases)
      self :: INOUT

      directory :: STR

      stdin.read(directory)
      .BASE:set_basis_directory(directory)

   end

   read_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      self :: INOUT

      name :: STR

      stdin.read(name)

      .BASE:set_basis_name(name)

   end

   read_becke_grid ::: leaky
   ! Read in the Becke integration grid data
      self :: INOUT

   ENSURE(.atom.associated,"input atom information before becke_grid information")

      if (.becke_grid.deallocated) .becke_grid.create

      ! Includes
      .becke_grid.read_keywords
      
      ! Finalize
      .becke_grid.set_atom_info(.atom)
      .becke_grid.set_grid_data

   end

!  C

   read_charge
   ! Read in the total molecular charge
      self :: INOUT

      stdin.read(.charge)

      ! Set the no. of electons
      if (.atom.associated) .n_e = .BASE:no_of_electrons

   end

   read_cluster ::: leaky
   ! Read in the crystal cluster data. NOTE: the .atom list must correspond to
   ! the (unpruned or pruned) asymmetric unit cell geometry of the .crystal.
      self :: INOUT

   ENSURE(.atom.associated,"no atom data")
   ENSURE(.crystal.associated,"no crystal data")

      .crystal.make_fragment_data(.atom,assign_atom=TRUE)

   DIE_IF(.crystal.asymmetric_unit_atom.disassociated,"atom list missing asym atoms")

      .cluster.destroy
      .cluster.create(.crystal)

      .cluster.read_keywords

   end

   read_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms.
      self :: INOUT

      this :: STR

      stdin.read(this)
      .BASE:set_coppensbasis_name(this)

   end

   read_crystal ::: leaky
   ! Read in the crystal data. If the ".atom" list data is available,
   ! its coordinates will be resolved into cartesians at this point.
   ! IMPORTANT NOTE: normally the crystal information will be inputted
   ! from a CIF file.  However, if the crystal information is inputted
   ! explicitly, and the asymmetric unit is not specified, then the
   ! symmetry unique atoms in the ".atom" list are used to define the
   ! crystal asymmetric unit. Once defined, the asymmetric unit in the
   ! crystal is never destroyed. Thus, in this case, you must ensure
   ! that your atom list has enough atoms to generate the entire
   ! crystal; for co-crystals this may be a problem. Use the CIF file
   ! method for input in this case, or be careful.
      self :: INOUT

      tags :: VEC{STR}*

      WARN_IF(.crystal.associated,"crystal data already defined!")

      ! Destroy
      if (.crystal.disassociated) .crystal.create

      ! Read
      .crystal.read_keywords

      ! Finalize crystal
      if (.crystal.finalize) then

         if (.atom.associated) then

            ! Finalize.
            ! May be needed for fragment capping
            .BASE:finalize_atoms

            ! Set H U iso
            if (.crystal.data.associated) then
            if (.crystal.data.refine_H_U_iso) then
               .atom.set_isotropic_H_ADP
            end
            end

            ! Set U iso's
            if (.crystal.data.associated) then
            if (.crystal.data.refine_U_iso_for_atom.associated) then
               tags => .crystal.data.refine_U_iso_for_atom
               .atom.set_isotropic_ADPs(tags)
            end
            end

            ! Cartesian axes
            .BASE:resolve_axis_system
            .crystal.make_fragment_data(.atom,assign_atom=TRUE)

            ! Set H U iso & really do it this time
            if (.crystal.data.associated) then
            if (.crystal.data.refine_H_U_iso) then
               .crystal.fragment_atom.set_isotropic_H_ADP
               .crystal.asymmetric_unit_atom.set_isotropic_H_ADP
               .crystal.unit_cell_atom.set_isotropic_H_ADP
            end
            end

            ! Set U iso & really do it this time
            if (.crystal.data.associated) then
            if (.crystal.data.refine_U_iso_for_atom.associated) then
               tags => .crystal.data.refine_U_iso_for_atom
               .crystal.fragment_atom.set_isotropic_ADPs(tags)
               .crystal.asymmetric_unit_atom.set_isotropic_ADPs(tags)
               .crystal.unit_cell_atom.set_isotropic_ADPs(tags)
            end
            end

         end

         .crystal.update

      end

      ! Set dispersion coefficients?
    ! if (.atom.associated) then
    ! if (.crystal.xray_data.associated) then
    ! if (.crystal.xray_data.have_set_wavelength) then
    !    .atom.set_dispersion_coefficients(.crystal.xray_data.wavelength)
    ! end
    ! end
    ! end

      ! Make Hirshfeld info
      if (.scfdata.associated) then
      if (.basis_info_made) then
      if (.atom.associated) then
      if (.crystal.xray_data.associated) then
      if (.crystal.xray_data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end
      end
      end

      ! Reset to finalize next time
      .crystal.finalize = TRUE

   end

!  D

   read_dispersion_coefficients ::: leaky
   ! Read the anaomalous dispersion coefficients f' and f''
   ! and set the atom list
      self :: INOUT

   DIE_IF(.atom.disassociated,"please enter dispersion after atom list")

      ATOM:read_dispersion_coefficients

      .atom.set_tabular_dispersion

   end

!  E

   read_E_field
   ! Read in the applied electric E field
      self :: INOUT

      stdin.read_quantity(.E_field)

   end

!  G

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      self :: INOUT

      stdin.read_quantity(.gauge_origin)

   end

!  I

   read_interpolator ::: leaky
   ! Read template interpolators
      self :: INOUT

      .interpolator.destroy
      .interpolator.create
      .interpolator.read_keywords
      .BASE:destroy_interpolators

   end

   read_isosurface ::: leaky
   ! Read in the isosurface data. NOTE: the isosurface has its own
   ! plotgrid, different from that used in normal density plots.
      self :: INOUT

      ! Destroy
      if (.isosurface.disassociated) .isosurface.create(.atom)

      ! Read
      .isosurface.read_keywords

   end

   set_isotropic_ADPs
   ! As it says
      self :: INOUT

      ! Make isotropic
      if (.crystal.associated) then
      if (.crystal.xray_data.associated) then
      if (.crystal.xray_data.refine_U_iso_for_atom.associated) then

         .atom.set_isotropic_ADPs(.crystal.xray_data.refine_U_iso_for_atom)

         .BASE:resolve_axis_system
         .crystal.destroy_asymmetric_unit
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)

      end
      end
      end

   end

   set_isotropic_H_ADPs
   ! As it says
      self :: INOUT

      ! Make isotropic
      .atom.set_isotropic_H_ADP

      ! Finalize crystal
      if (associated(.crystal)) then
         .BASE:resolve_axis_system
         .crystal.destroy_asymmetric_unit
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

!  K

   set_keyword_echo_on
   ! Echo keywords into the stdout file
      self :: INOUT

   DIE_IF(tonto.disassociated,"tonto not created")

      ! Get rid of unused self error
      tonto.keyword_echo = transfer(self,tonto.keyword_echo)

      tonto.keyword_echo = TRUE

   end

!  L

   set_low_verbosity_on
   ! Set low output verbosity
      self :: IN

   DIE_IF(tonto.disassociated,"tonto not created")

      ! Get rid of self error
      tonto.low_verbosity = transfer(self,tonto.low_verbosity)

      tonto.low_verbosity = TRUE

   end

!  M

!  N 

   read_name
   ! Read in the name of the molecule. This must always be
   ! the first keyword inputted.
      self :: INOUT

      val :: STR

      stdin.read(val)

      .BASE:set_name(val)

   end

   read_nucleus_model ::: leaky
   ! Read whether what nucleus model to use
      self :: INOUT

      stdin.read(.nucleus_model)

   end

!  O

   read_output_style_options ::: private
   ! Read new output style options, for example change the
   ! width and number of field, or precision of output.
      self :: INOUT

      if (FALSE) self = self

      stdout.read_keywords(TEXTFILE::stdin)

   end

!  P

   read_pair_energy_model ::: leaky, selfless
   ! Set pair-energy model
      self :: INOUT

      energy_model :: STR

      stdin.read(energy_model)
      VEC{PAIR_ENERGY}:set_energy_model(trim(energy_model))

   end

   read_phi_step_size ::: leaky
   ! Read in the dimensionless normal coordinate step size.
      self :: INOUT

      stdin.read(.phi_step_size)

      WARN_IF(.phi_step_size<TOL(2),"phi_step_size may be too small")

   end

   read_e_lat_convergence ::: leaky, selfless
   ! Set pair-energy convergence threshhold
      self :: INOUT

      threshold :: REAL

      stdin.read(threshold)
      VEC{PAIR_ENERGY}:set_convergence_threshold(threshold)

   end

   read_plot_grid ::: leaky
   ! Read in the plot grid data
      self :: INOUT

      ! Set up a defualt grid
      if (.plot_grid.disassociated) .plot_grid.create(.atom)

      ! Read options
      .plot_grid.read_keywords

      ! Check
      DIE_IF(.plot_grid.plot_format==" ","plot_format not specified (try all)")

   end

   read_pointgroup ::: leaky
   ! Read in the pointgroup data
      self :: INOUT

      if (.pointgroup.disassociated) .pointgroup.create
      .pointgroup.read_keywords

   end

!  R

   read_rotate
   ! Rotate the whole molecule using matrix defined by its rotation "axis" and
   ! the "angle" of rotation around that axis, which are both inputted.
   ! Checked, 7/2/06; it needed the archives to be deleted to work
      self :: INOUT

      R :: MAT{REAL}(3,3)
      axis :: VEC{REAL}(3)
      angle :: REAL

      ! Read axis
      stdin.read(axis)
      stdin.read(angle)
      ENSURE(NOT axis.is_zero,"axis must not be zero")

      ! Delete archives
      .BASE:delete_scf_archives

      ! Get the rotation matrix from the axis
      R.to_3x3_rotation_matrix(axis,angle)

      ! Rotate
      .BASE:rotate_by(R)

      ! Remake the Becke grid (leaky)
      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom)
         .becke_grid.set_grid_data
      end

   end

   read_rotate_group ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
      self :: INOUT

   ENSURE(.atom_group.associated,"no atom group information")

      axis :: VEC{REAL}(3)
      angle :: REAL
      g :: INT

      stdin.read(g)               ! read group
      stdin.read(axis)            ! read axis
      stdin.read_quantity(angle)  ! read angle

      ENSURE(g>0,"group number must be positive")
      ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
      ENSURE(NOT axis.is_zero,"axis must not be zero")

      .BASE:rotate_group(g,axis,angle)

   end

   read_rotate_matrix ::: leaky
   ! Same as read_rotate except reads the rotation matrix from the stdin
      self :: INOUT

      R :: MAT{REAL}(3,3)

      ! Read matrix
      stdin.read(R)

      ! Delete archives
      .BASE:delete_scf_archives

      ! Rotate
      .BASE:rotate_by(R)

      ! Remake the Becke grid (leaky)
      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom)
         .becke_grid.set_grid_data
      end

   end

!  S

   read_spin_multiplicity
   ! Read in the spin multiplicity
      self :: INOUT

      val :: INT

      stdin.read(val)

      .BASE:set_spin_multiplicity(val)

   end

!  T

   read_table_column ::: selfless, leaky
   ! Read in default settings for table_column output

      TABLE_COLUMN:create_std_table_column

      std_table_column.read_keywords

   end

!  U

   read_use_interpolators
   ! Read whether to use interpolators
      self :: INOUT

      stdin.read(.use_interpolators)
      if (.atom.associated) .atom.set_use_interpolators(.use_interpolators)

   end

   read_use_spherical_basis ::: leaky
   ! Read whether to use a spherical basis
      self :: INOUT

      stdin.read(.use_spherical_basis)
      .BASE:resolve_gaussianbases

   end

!  =============
!  Read routines
!  =============

   read_scfdata ::: leaky
   ! Read in the scf data
      self :: INOUT

      if (.scfdata.disassociated) .scfdata.create

      ! Read options
      .scfdata.read_keywords

      ! Internal post-process options
      .scfdata.finalize

      ! Make Hirshfeld info
      if (.crystal.associated) then
      if (.crystal.data.associated) then
      if (.crystal.data.thermal_smearing_model=="hirshfeld") then
         .SCF:make_Hirshfeld_inputs
      end
      end
      end

   end

   read_robydata ::: leaky
   ! Read in the Roby data. NOTE: this keyword must appear after a basis set
   ! has been defined
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,"no atom list")

      ! Make the Becke grid
      if (.becke_grid.deallocated) .becke_grid.create
      .becke_grid.set_atom_info(.atom)
      .becke_grid.set_grid_data

      .INTS:make_overlap_matrix
      .SCF:make_core_matrix
    ! if (.scfdata.associated) then
    !    .SCF:make_fock_matrix
    ! end

      if (.roby.associated) .roby.destroy
      .roby.create(self)

      .roby.read_keywords

      .roby.finalize

   end

   read_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms.
      self :: INOUT

      name :: STR

      stdin.read(name)
      .BASE:set_slaterbasis_name(name)

      ! Finalize crystal - remake basis kinds !
    ! if (associated(.crystal)) then
    !    .crystal.destroy_asymmetric_unit
    !    .crystal.make_fragment_data(.atom,assign_atom=TRUE)
    ! end

   end

   read_saved_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms in the
   ! *saved* molecule.
      self :: INOUT

   ENSURE(.saved.associated,"there is no saved molecule")

      this :: STR

      stdin.read(this)
      .saved.BASE:set_basis_name(this)

   end

   read_saved_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms in the
   ! *saved* molecule.
      self :: INOUT

   ENSURE(.saved.associated,"there is no saved molecule")

      this :: STR

      stdin.read(this)
      .saved.BASE:set_slaterbasis_name(this)

   end

   read_saved_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms in the
   ! *saved* molecule.
      self :: INOUT

   ENSURE(.saved.associated,"there is no saved molecule")

      this :: STR

      stdin.read(this)
      .saved.BASE:set_coppensbasis_name(this)

   end

   read_slaterbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      self :: INOUT

   WARN_IF(.slaterbasis.associated,"slaterbasis sets already defined!")

      if (.atom.associated)  .atom.nullify_slaterbasis_part

      if (.slaterbasis.associated) .slaterbasis.renormalise
      .slaterbasis.read_list_keywords
      if (.slaterbasis.associated) .slaterbasis.unnormalise

      .BASE:resolve_basis_info

   end

   read_coppensbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.coppensbasis.associated,"coppensbasis sets already defined!")

      if (.atom.associated)  .atom.nullify_coppensbasis_part

      if (.coppensbasis.associated) .coppensbasis.renormalise
      .coppensbasis.read_list_keywords
      if (.coppensbasis.associated) .coppensbasis.unnormalise

      .BASE:resolve_basis_info

   end

   read_serialize_filename ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      name :: STR
      stdin.read(name)
      .BASE:serialize(name)
   end

   read_deserialize_filename ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      self :: PTR
      name :: STR
      stdin.read(name)
      .BASE:deserialize(name)
   end

   test_dump_file ::: selfless
   ! Always put a comment ...
      self :: IN

      d :: DATAFILE
      i :: INT
      i_in, i_out :: VEC{INT}@
      err :: INT

      i_in = [(i*i, i=1,100)]

      d.open("test.sbf")
      call d%sbf%add_dataset(sbf_Dataset("integer_dataset", i_in))
      stdout.show("integer_dataset write", i_in)
      call d%sbf%serialize
      d.close

      d.open("test.sbf")
      call d%sbf%deserialize
      call d%sbf%get("integer_dataset", i_out, err)
      stdout.show("integer_dataset read ", i_out)
      if (NOT err == 1) print *, "Error: ", sbf_strerr(err)
      d.close

   end

!  ======================
!  Batch HS & ESP methods
!  ======================

! K's red spot code

   find_d_norm_contacts ::: leaky
   ! Find the close d_norm values and store the list of indices for
   ! the corresponding closest atoms inside and outside the HS.
      self :: PTR

   ENSURE(.cif.associated,"no CIF file")
   ENSURE(.isosurface.associated,"no isosurface")

      i :: INT
      ub :: REAL
      formula, name :: STR
      CX_file :: TEXTFILE*

      ! Defragment any molecules in the CIF
      .cluster.create(.crystal) 
      .cluster.set_generation_method("fragment")
      .cluster.radius = ZERO
      .cluster.defragment = TRUE
      .cluster.make_info

      ub = .isosurface.surface_property_ub

      if (.cluster.n_molecules == 1) then

         i = 1

         ! Set up name
         formula = .atom.chemical_formula(FALSE)
         stdout.show("formula ", formula)
         name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)

         ! Make the HS
         stdout.flush
         stdout.show("Creating Hirshfeld surface m =", i)
         call make_HS(self,ub)
         stdout.flush
         stdout.text("Hirshfeld surface done.")

         ! Print out cxs file
         CX_file.create(trim(name)//".cxs")
         CX_file.open_for("write")
         .CE:put_CX_data(CX_file,.cif)       
         CX_file.close
         CX_file.destroy

         return

      end

      ! Make all HSs for i-th cluster mol
      do i = 1, .cluster.n_molecules
         .MAIN:make_HS_for_cluster_mol(i,ub)
      end

   end

   make_HS_for_cluster_mol(i,ub) ::: private, leaky
   ! Make the HS for cluster molecule i.
      self :: PTR
      i :: INT, IN
      ub :: REAL, IN

      mol :: MOLECULE*
      res :: REAL
      formula, name :: STR
      CX_file :: TEXTFILE*

      res = 0.2d0

      ! Make the i-th cluster molecule "mol"
      mol.BASE:create
      .XTAL:create_cluster_mol(i, mol)

      ! Set molecule name
      formula = mol.atom.chemical_formula(FALSE)
      stdout.show("formula ", formula)
      name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
      mol.BASE:set_name(trim(name))

      ! Set basis set
      mol.basis_name = .basis_name
      .BASE:finalize_atoms

      ! Make the HS
      stdout.flush
      stdout.show("Creating Hirshfeld surface m =", i)
      call make_HS(mol,ub)
      stdout.flush
      stdout.text("Hirshfeld surface done.")

      ! Deposit cxs file
      CX_file.create(trim(name)//".cxs")
      CX_file.open_for("write")
      mol.CE:put_CX_data(CX_file,.cif)       
      CX_file.close
      CX_file.destroy

      ! Clean
      mol.BASE:destroy

   end

   make_HS(m,ub) ::: selfless, private, leaky
   ! Make the HS for molecule "m" with desired resolution "res".
      m :: MOLECULE*
      ub :: REAL, IN

      res :: REAL

      res = 0.2d0

      ! Create HS cluster for molecule "m"
      m.cluster.create(m.crystal)
      m.cluster.set_generation_method("for_hirshfeld_surface")
      m.cluster.atom_density_cutoff = 1.0e-8
      m.cluster.defragment = FALSE
      m.cluster.make_info

      !!!!!!!!!!!!!!!!!!!!!
      m.XTAL:create_cluster
      !!!!!!!!!!!!!!!!!!!!!

      ! Use Slater-type HS
      m.atom.set_basis_kind("slater")

      ! Set up interpolator type
      m.interpolator.create
      m.interpolator.set_interpolation_method("linear")
      m.interpolator.set_domain_mapping("sqrt")
      m.interpolator.set_table_eps(1.0d-10)
      m.interpolator.set_table_spacing(1.0d-1)
      m.BASE:destroy_interpolators

      ! Set up CX_isosurface
      m.isosurface.destroy
      m.isosurface.create(m.atom)
      m.isosurface.property = "stockholder_weight"
      m.isosurface.triangulation_method = "recursive_marching_cube"
      m.isosurface.iso_value = 0.5
      m.isosurface.minimum_scan_division = 1
      m.isosurface.voxel_proximity_factor = 5
      m.isosurface.CX_output_distance_properties = TRUE
      m.isosurface.CX_output_shape_properties = TRUE

      ! Initialize CX_isosurface.plot_grid
      m.isosurface.plot_grid.use_bcube_with_shape_axes
      m.isosurface.plot_grid.set_cube_scale_factor(1.0d0)
      ! Desired separation is essentially the resolution of the calculated surface
      m.isosurface.plot_grid.set_desired_separation(res)

      ! Make HS isosurface
      m.PLOT:isosurface_plot

      ! Do the d_norm close contact table
      if (m.isosurface.associated) then
      if (m.isosurface.atom.associated) then 
      if (m.saved.associated) then
      if (m.saved.cluster.associated) then

         m.isosurface.set_surface_property_ub(ub)
         m.isosurface.put_d_norm_info(m.saved.cluster.fragment_atom_indices    &
                                     ,m.saved.cluster.nonfragment_atom_indices &
                                     ,m.atom)

      end
      end
      end
      end

   end

! Peter's batch code

   batch_hs ::: leaky
   ! Make a HS for every symmetry-unique molecule in a CIF file
      self :: PTR
      i, n_molecules :: INT
      name :: STR

      .cluster.create(.crystal) 
      .cluster.set_generation_method("fragment")
      .cluster.radius = ZERO
      .cluster.defragment = TRUE
      .cluster.make_info
      n_molecules = self.cluster.n_molecules
      name = .name

      do i = 1, n_molecules
         .MAIN:make_hs_for_group(i)
         .BASE:set_from_saved_self
         .cluster.create(.crystal) 
         .cluster.set_generation_method("fragment")
         .cluster.radius = ZERO
         .cluster.defragment = TRUE
         .cluster.make_info
         .name = name

      end do

   end

   make_hs_for_group(i) ::: private, leaky
   ! Make the wavefunction, then HS, then the ESP mapped on it
   ! for the i-th molecule in the cluster.
      self :: PTR

      i :: INT
      mol :: MOLECULE*
      res :: REAL
      formula, name, filename :: STR

      res = 0.2d0

      mol.BASE:create
      .XTAL:create_cluster_mol(i, mol)
      formula = mol.atom.chemical_formula(FALSE)
      name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
      stdout.show("Name ", name)
      stdout.show("Molecular formula ", formula)
      mol.atom.put_xyz_file(trim(name))
      stdout.show("Creating Hirshfeld surface m =", i)
      call make_hirshfeld_surface(mol, 0.5d0)
      stdout.text("Hirshfeld surface done.")
      filename = trim(name)//"-hs.sbf"
      mol.CE:serialize_isosurface_sbf(filename, .cif)
   end

   make_hirshfeld_surface(m, res) ::: selfless, private, leaky
   ! Make the HS for molecule "m" with desired resolution "res".
   ! Also do the ESP on the HS of "m" afterwards.
      m :: MOLECULE*
      res :: REAL, IN

      ! Create HS cluster for molecule "m"
      m.cluster.create(m.crystal)
      m.cluster.set_generation_method("for_hirshfeld_surface")
      m.cluster.atom_density_cutoff = 1.0e-8
      m.cluster.defragment = FALSE
      m.cluster.make_info
      m.XTAL:create_cluster

      ! Use Slater-type HS
      m.atom.set_basis_kind("slater")

      ! Set up interpolator type
      m.interpolator.create
      m.interpolator.set_interpolation_method("linear")
      m.interpolator.set_domain_mapping("sqrt")
      m.interpolator.set_table_eps(1.0d-10)
      m.interpolator.set_table_spacing(1.0d-1)
      m.BASE:destroy_interpolators

      ! Set up CX_isosurface
      m.isosurface.create(m.atom)
      m.isosurface.property = "stockholder_weight"
      m.isosurface.triangulation_method = "recursive_marching_cube"
      m.isosurface.iso_value = 0.5
      m.isosurface.minimum_scan_division = 1
      m.isosurface.voxel_proximity_factor = 5
      m.isosurface.CX_output_distance_properties = TRUE
      m.isosurface.CX_output_shape_properties = TRUE

      ! Initialize CX_isosurface.plot_grid
      m.isosurface.plot_grid.use_bcube_with_shape_axes
      m.isosurface.plot_grid.set_cube_scale_factor(1.0d0)

      ! Desired separation is essentially the resolution of the calculated surface
      m.isosurface.plot_grid.set_desired_separation(res)

      ! Make isosurface
      m.PLOT:isosurface_plot

      ! Do the ESP on surface
      if(FALSE) then
         m.isosurface.plot_grid.electric_potential_method = "mixed"
         m.isosurface.surface_property = "electric_potential"
         m.atom.set_basis_kind("gaussian")
         m.PLOT:saved_plot_on_isosurface
      end
      m.cluster.destroy
   end

   make_promolecule_surface(m, res, have_esp) ::: selfless, private, leaky
   ! Make the HS for molecule "m" with desired resolution "res".
   ! Also do the ESP on the HS of "m" afterwards.
      m :: MOLECULE*
      res :: REAL, IN
      have_esp :: BIN, optional, IN
      with_esp :: BIN
      with_esp = FALSE
      if(present(have_esp)) with_esp = have_esp


      ! Create HS cluster for molecule "m"
      m.cluster.create(m.crystal)
      m.cluster.set_generation_method("within_radius")
      m.cluster.radius = 6.0d0
      m.cluster.defragment = FALSE
      m.cluster.make_info
      m.XTAL:create_cluster

      ! Use Slater-type HS
      m.atom.set_basis_kind("slater")

      ! Set up interpolator type
      m.interpolator.create
      m.interpolator.set_interpolation_method("linear")
      m.interpolator.set_domain_mapping("sqrt")
      m.interpolator.set_table_eps(1.0d-10)
      m.interpolator.set_table_spacing(1.0d-1)
      m.BASE:destroy_interpolators

      ! Set up CX_isosurface
      m.isosurface.create(m.atom)
      m.isosurface.property = "promolecule_density"
      m.isosurface.triangulation_method = "recursive_marching_cube"
      m.isosurface.iso_value = 0.002
      m.isosurface.minimum_scan_division = 1
      m.isosurface.voxel_proximity_factor = 5
      m.isosurface.CX_output_distance_properties = TRUE
      m.isosurface.CX_output_shape_properties = TRUE

      ! Initialize CX_isosurface.plot_grid
      m.isosurface.plot_grid.use_bcube_with_shape_axes
      m.isosurface.plot_grid.set_cube_scale_factor(1.0d0)

      ! Desired separation is essentially the resolution of the calculated surface
      m.isosurface.plot_grid.set_desired_separation(res)

      ! Make isosurface
      m.PLOT:saved_isosurface_plot

      ! Do the ESP on surface
      if(with_esp) then
         m.isosurface.plot_grid.electric_potential_method = "mixed"
         m.isosurface.surface_property = "electric_potential"
         m.atom.set_basis_kind("gaussian")
         m.PLOT:saved_plot_on_isosurface
      end
      m.cluster.destroy
   end


   generate_all_wavefunctions ::: leaky
   ! Generate all wavefunctions from the cluster
   ! NOTE: Broken, need to create scfdata etc.
      self :: PTR

      mol :: MOLECULE*
      i :: INT
      formula :: STR
      filename, name :: STR

      ! Defragment the cluster
      .cluster.create(.crystal) 
      .cluster.set_generation_method("fragment")
      .cluster.radius = ZERO
      .cluster.defragment = TRUE
      .cluster.make_info


      ! Make a single wavefunction
      if (.cluster.n_molecules == 1) then

         formula = .atom.chemical_formula(FALSE)
         call make_wavefunction(self)

         i = 1
         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)//".sbf"
         .BASE:serialize(filename)

         return

      end

      ! Make several wavefunctions
      do i = 1, .cluster.n_molecules

         ! Make the i-th molecule
         mol.BASE:create
         .XTAL:create_cluster_mol(i, mol)

         ! Set up the name of the molecule
         formula = mol.atom.chemical_formula(FALSE)
         name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
         mol.BASE:set_name(trim(name))
         mol.basis_name = .basis_name
         mol.scfdata.copy(.scfdata)

         ! Make the wavefunction
         call make_wavefunction(mol)

         ! Dump data
         filename = trim(name)//".sbf"
         mol.BASE:serialize(filename)

      end

   end

   make_wavefunction(m) ::: selfless, private, leaky
   ! Make the wavefunction for molecule "m"
      self :: IN
      m :: MOLECULE*

      ! Set up ANO data
      m.SCF:make_ANO_data

      ! Do the SCF
      stdout.text("Beginning SCF")
      m.SCF:scf

   end

   dump_xyz_files ::: leaky
   ! Generate all wavefunctions from the cluster
   ! NOTE: Broken, need to create scfdata etc.
      self :: PTR

      mol :: MOLECULE*
      i :: INT
      formula :: STR
      filename :: STR

      ! Defragment the cluster
      .cluster.create(.crystal) 
      .cluster.set_generation_method("fragment")
      .cluster.radius = ZERO
      .cluster.defragment = TRUE
      .cluster.make_info


      ! One molecule
      i = 1
      if (.cluster.n_molecules == 1) then
         formula = .atom.chemical_formula(FALSE)
         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
         stdout.show("Writing xyz file", trim(filename))
         .atom.put_xyz_file(trim(filename))
         return
      end

      ! several mols
      do i = 1, .cluster.n_molecules
         ! Make the i-th molecule
         mol.BASE:create
         .XTAL:create_cluster_mol(i, mol)
         stdout.show("Writing xyz file", trim(filename))
         formula = mol.atom.chemical_formula(FALSE)
         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
         mol.atom.put_xyz_file(trim(filename))
      end

   end

   lattice_energy
   ! Calculate lattice energy?
      self :: PTR

      g09_file :: STR

      stdin.read(g09_file)
      .CE:total_lattice_energy(g09_file)

   end

   generate_g09_input
   ! Write g09 input file for what kinmd of job?
     self :: PTR

     atoms :: VEC{ATOM}*

     .cluster.create(.crystal) 
     .cluster.set_generation_method("fragment")
     .cluster.defragment = TRUE
     .cluster.make_info
     .cluster.create_mol_atom_list(atoms, 1)

     atoms.put_g09_input(trim(.name))

   end

! Test plot UC density code

   plot_uc_density   
   ! Plot the unit cell density
     self :: INOUT

   ENSURE(.atom.associated,"no atom info")
   ENSURE(.crystal.associated,"no crystal info")
   ENSURE(NOT .crystal.cluster_info_made,"cluster info already made!")

     .SCF:make_ANO_data

     .crystal.destroy_fragment_data
     .crystal.make_fragment_data(.atom,assign_atom=TRUE)

     .crystal.set_generation_method("for_unit_cell_density") 
     .crystal.set_atom_density_cutoff(1.0d-3) 
     .crystal.make_cluster_info
     .crystal.put_cluster_info

   end


end
