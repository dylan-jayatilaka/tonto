!==================================================================
!
! MOLECULE: An object repxresentation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!==================================================================


module MOLECULE.MAIN

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

!  ================
!  Main controllers
!  ================

   run(basis_library_dir) ::: leaky
   ! Main molecule run-loop; assumes stdin and stdout have been defined.
      self :: allocatable, INOUT
      basis_library_dir :: STR, optional, IN

      ! Create & set up molecule
      .:setup(basis_library_dir)

      ! Banner
      MOLECULE.MAIN:put_banner

      ! Read & process keywords
      .:read_keywords

      ! Finish timing
      std_time.stop_timing

      stdout.flush
      stdout.text(std_time.elapsed_time_message("job "//'"'// trim(.name) //'"'))
      stdout.text(std_time.elapsed_cpu_time_message("job "//'"'// trim(.name) //'"'))

      ! Warnings
      if (tonto.warnings_issued) then
      stdout.flush
      stdout.text("WARNINGS were issued in this job.")
      stdout.text("Look above, or in the stderr file.")
      end

   end

   setup(basis_library_dir) ::: leaky
   ! Set up a molecule ready to do something.
      self :: allocatable, INOUT
      basis_library_dir :: STR, optional, IN

      ! Start timer
      std_time.start_timing

      ! Create (leaky)
      .SET:create
      if (present(basis_library_dir)) then
      if (basis_library_dir /= " ") then
         .SET:set_basis_directory(basis_library_dir)
      end
      end

      ! Gaussian indices (leaky)
      GAUSSIAN_DATA:set_indices(GAUSSIAN_DATA_L_MAX)

      ! Put errors under value
      TABLE_COLUMN:create_std_table_column
    ! std_table_column.set_e_under_r(TRUE)

   end

   put_banner ::: selfless
   ! Put to stdout the current TONTO banner

      stdout.text("_______________________________________________________________")
      stdout.text("                                                               ")
      stdout.text(" T   O   N   T   O                                             ")
      stdout.text("                                                               ")
      stdout.text(" A free object-based system for computational chemistry        ")
      stdout.text("                                                               ")
      stdout.text(" Version: "//TONTO_VERSION//" v. "//GIT_VERSION)
      stdout.text(" Platform: "//TONTO_PLATFORM)
      stdout.text(" Build-date: "//TONTO_BUILD_DATE)
      stdout.text("                                                               ")
      stdout.text(" For conditions of use, on-line documentation, and contributor ")
      stdout.text(" and developer information see :-                              ")
      stdout.text("                                                               ")
      stdout.text(" https://"//"github."//"com/"//"dylan-jayatilaka/tonto         ")
      stdout.text("                                                               ")
      stdout.text(" Dylan Jayatilaka                                              ")
      stdout.text(" Daniel Grimwood                                               ")
      stdout.text(" Peter Spackman                                                ")
      stdout.text("_______________________________________________________________")

      stdout.flush
      stdout.flush
      stdout.text(std_time.start_time_message)
      stdout.flush

   end

   cleanup ::: leaky
   ! Clean up all undeleted memory in all modules.
      self :: allocatable, INOUT

      atom  :: ATOM
      basis :: BASIS
      shell :: SHELL
      coppensbasis   :: COPPENSBASIS
      coppensorbital :: COPPENSORBITAL
      slaterbasis :: SLATERBASIS
      slatershell :: SLATERSHELL
      reflection  :: REFLECTION

      ! Clean self
      ! Causes problems on gfortran.
      ! Leave the compiler to do it
    ! .SET:destroy

      ! Gaussian indices
      GAUSSIAN_DATA:destroy_data

      ! Clear all keys
       atom.clear_keys
      basis.clear_keys
      shell.clear_keys
        coppensbasis.clear_keys
      coppensorbital.clear_keys
      slaterbasis.clear_keys
      slatershell.clear_keys
      reflection.clear_keys

   end

   reset_molecule ::: leaky
   ! Resets the mol data type and reruns the read routine
      self :: allocatable, INOUT

      word :: STR

      .SET:destroy
      .SET:create

      ! First keyword must be "name"
      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="name=","first keyword must be name")

      stdin.read(.name)

   end

!  =============
!  Read routines
!  =============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   ! Allocatable version.
   end

   process_keyword(keyword) ::: recursive, leaky
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
   ! NOTE : this routine reuires a MOLECULE pointer self variable
      self :: allocatable, INOUT
      keyword :: STR, IN

      select case (keyword(1:30))

      case ("}                             "); ! exit case

      case ("assign_mos_to_nos             "); .BASE:assign_MOs_to_NOs
      case ("assign_nos_to_mos             "); .BASE:assign_NOs_to_MOs
      case ("atoms=                        "); .:read_atoms
      case ("atom_groups=                  "); .:read_atom_groups
      case ("atom_group_charges=           "); stdin.read_all(.atom_group_charges)

      case ("b_field=                      "); .:read_B_field
      case ("basis_directory=              "); .:read_basis_directory
      case ("basis_library=                "); .:read_basis_directory
      case ("basis_name=                   "); .:read_basis_name
      case ("basis_set=                    "); .:read_basis_name
      case ("basis_sets=                   "); .:read_basis_sets
    ! case ("batch_surfaces                "); .:batch_HS
    ! case ("generate_wavefunctions        "); .:generate_all_wavefunctions
      case ("becke_grid=                   "); .:read_becke_grid

      case ("canonicalize_mos              "); .SCF:canonicalize_MOs
      case ("change_axis_system_to         "); .SET:change_axis_system_to
      case ("change_to_principal_axes      "); .atom.change_to_principal_axes
      case ("change_to_principal_top_axes  "); .atom.change_to_principal_top_axes
      case ("charge=                       "); .:read_charge
      case ("cif=                          "); .XTAL:read_CIF
      case ("cleanup_scf                   "); .SCF:cleanup_scf
      case ("cluster=                      "); .:read_cluster
      case ("coppensbasis_name=            "); .:read_coppensbasis_name
      case ("create_cluster                "); .BASE:create_cluster
    ! case ("create_cluster_mol            "); .XTAL:create_cluster_mol
    ! case ("create_g09_wfn_from_crystal   "); .:generate_g09_input
    ! case ("create_hs_cluster             "); .XTAL:create_HS_cluster
      case ("crystal=                      "); .:read_crystal

      case ("defragment                    "); .CE:defragment
      case ("delete_plot_grid              "); .SET:delete_plot_grid
      case ("delete_scf_archives           "); .SET:delete_SCF_archives
      case ("delete_scf_integrals          "); .SET:destroy_SCF_integrals
      case ("delta_lambda_plot             "); .MAIN:delta_lambda_plot
      case ("deserialize=                  "); .:read_deserialize_filename
      case ("destroy_atom_groups           "); .SET:destroy_atom_group
      case ("destroy_cluster               "); .BASE:destroy_cluster
      case ("dispersion_coefficients=      "); .:read_dispersion_coefficients
    ! case ("dump_xyz_files                "); .:dump_xyz_files
    ! case ("dvpt_scf                      "); .MISC.DVPT_scf

      case ("e_field=                      "); .:read_E_field

    ! case ("find_d_norm_contacts          "); .MAIN:find_d_norm_contacts
      case ("fit_hirshfeld_atoms           "); .HAR:LS_fit_Hirshfeld_atoms
    ! case ("fit_hirshfeld_atom_kappas     "); .MISC:fit_Hirshfeld_atom_kappas
      case ("force_constants=              "); .PROP:read_force_constants
      case ("fraghar                       "); .HAR:fragHAR_refinement
      case ("fraghar_refinement            "); .HAR:fragHAR_refinement
      case ("fragment_plot                 "); .PLOT:plot_fragments

      case ("gauge_origin=                 "); .:read_gauge_origin
      case ("get_bader_regions             "); .PROP:get_Bader_regions
    ! case ("get_dedr_iotc                 "); .REL:get_dEdR_IOTC
    ! case ("get_g_overlap_nuc             "); .REL:get_g_overlap_nuc
    ! case ("get_gchf_jz                   "); .PROP:get_gchf_jz
    ! case ("get_gchf_kramers              "); .PROP:get_gchf_kramers
    ! case ("get_gchf_kramers_2            "); .PROP:get_gchf_kramers_2
    ! case ("get_gchf_na_nb                "); .PROP:get_gchf_na_nb
    ! case ("get_gchf_sx_sy_sz             "); .PROP:get_gchf_sx_sy_sz
    ! case ("get_gchf_s2                   "); .PROP:get_gchf_s2
    ! case ("get_gchf_s2_orig              "); .PROP:get_gchf_s2_orig
    ! case ("get_gchf_s2_contributions     "); .PROP:get_gchf_s2_contributions
    ! case ("get_uhf_kramers               "); .PROP:get_uhf_kramers
    ! case ("get_uhf_kramers_2             "); .PROP:get_uhf_kramers_2
    ! case ("get_uhf_sx_sy_sz              "); .PROP:get_uhf_sx_sy_sz
    ! case ("get_uhf_s2                    "); .PROP:get_uhf_s2
    ! case ("get_uhf_s2_orig               "); .PROP:get_uhf_s2_orig
    ! case ("get_x_negative_laplacian_grid "); .GRID:get_X_negative_laplacian_grid
    ! case ("get_x_laplacian_grid          "); .GRID:get_X_laplacian_grid
    ! case ("put_pce_x_structure_factors   "); .XTAL:put_PCE_X_structure_factors
    ! case ("get_x_structure_factors_test  "); .XTAL:get_X_structure_factors_test

      case ("har_refinement                "); .HAR:HAR_refinement

      case ("iam_refinement                "); .HAR:IAM_refinement
    ! case ("integrate_density_numerically "); .MISC:integrate_density_numerically
    ! case ("integrate_ku_spin_numerically "); .MISC:integrate_ku_spin_numerically
    ! case ("integrate_nc_spin_numerically "); .MISC:integrate_nc_spin_numerically
    ! case ("integrate_spin_numerically    "); .MISC:integrate_spin_numerically
      case ("interpolator=                 "); .MAIN:read_interpolator
      case ("isosurface=                   "); .MAIN:read_isosurface
      case ("isosurface_plot               "); .PLOT:isosurface_plot

      case ("keyword_echo_on               "); MOLECULE.MAIN:set_keyword_echo_on

    ! case ("lattice_energy                "); .:lattice_energy
      case ("lattice_energy_convergence=   "); MOLECULE.MAIN:read_e_lat_convergence
      case ("localise_mos=                 "); .SCF:localize_MOs
      case ("localize_mos=                 "); .SCF:localize_MOs
      case ("low_verbosity_on              "); MOLECULE.MAIN:set_low_verbosity_on

      case ("make_ano_data                 "); .SCF:make_ANO_data
      case ("make_ao_density_matrix        "); .BASE:make_r_density_mx
      case ("make_ao_density_mx            "); .BASE:make_r_density_mx
      case ("make_atom_group_density_mx    "); .SCF:make_atom_group_density_mx
      case ("make_r_density_mx             "); .BASE:make_r_density_mx
      case ("make_ao_sz_density_matrix     "); .BASE:make_r_Sz_density_mx
      case ("make_r_sz_density_mx          "); .BASE:make_r_Sz_density_mx
    ! case ("make_core_structure_factors   "); .MISC:make_core_structure_factors
      case ("make_cluster_charges          "); .SCF:make_cluster_charges
    ! case ("make_dkh_density_norm         "); .REL:make_DKH_density_norm
      case ("make_f_predicted              "); .SCF:make_F_predicted
    ! case ("make_fermi_contact_terms      "); .MISC:make_fermi_contact_terms
    ! case ("make_file_delta_density_grid  "); .MISC:make_file_delta_density_grid
    ! case ("make_file_delta_spin_grid     "); .MISC:make_file_delta_spin_grid
      case ("make_fock_guess               "); .SCF:make_Fock_mx_guess_MOs
      case ("make_fock_matrix              "); .SCF:make_Fock_mx
      case ("make_fock_mx                  "); .SCF:make_Fock_mx
      case ("make_hirshfeld_inputs         "); .SCF:make_HA_inputs(skip_NOs=TRUE)
      case ("make_iterative_has            "); .HAR:make_iterative_HAs
      case ("make_monomer_mos              "); .SCF:make_monomer_MOs
    ! case ("make_n_structure_factors      "); .SCF:make_N_SFs
      case ("make_natural_orbitals         "); .BASE:make_NOs
      case ("make_nos                      "); .BASE:make_NOs
      case ("make_overlap_matrix           "); .INTS:make_overlap_mx
      case ("make_overlap_mx               "); .INTS:make_overlap_mx
      case ("make_progroup_density_matrix  "); .SCF:make_progroup_density_mx
      case ("make_progroup_density_mx      "); .SCF:make_progroup_density_mx
      case ("make_promolecule_density      "); .SCF:make_promolecule_density_mx
      case ("make_promol_density_matrix    "); .SCF:make_promolecule_density_mx
      case ("make_promol_density_mx        "); .SCF:make_promolecule_density_mx
      case ("make_promol_mos               "); .SCF:make_promol_MOs
      case ("make_scf_density_matrix       "); .BASE:make_SCF_density_mx(damp=FALSE)
      case ("make_scf_density_mx           "); .BASE:make_SCF_density_mx(damp=FALSE)
      case ("make_spherically_averaged_bdas"); .HAR:make_averaged_BDAs
      case ("make_spherically_averaged_has "); .HAR:make_spherically_averaged_HAs
      case ("make_structure_factors        "); .SCF:make_X_SFs(output=TRUE)
    ! case ("make_weak_force_energy_shift  "); .MISC:make_weak_force_energy_shift
    ! case ("make_symortho_density_matrix  "); .SCF:make_group_density_matrix
      case ("make_vanfleteren_atoms        "); .MAIN:make_Vanfleteren_atoms
      case ("make_x_structure_factors      "); .SCF:make_X_SFs(output=TRUE)
      case ("move_origin                   "); .BASE:move_origin
      case ("move_origin_to_center_of_atoms"); .BASE:move_origin_to_center_of_atoms
      case ("move_origin_to_center_of_mass "); .BASE:move_origin_to_center_of_mass
      case ("mp2                           "); .MISC:mp2
      case ("multiplicity=                 "); .MAIN:read_spin_multiplicity ! deprecated

      case ("name=                         "); .:read_name
    ! case ("no_scf                        "); .NOMO:no_scf
      case ("normal_mode_analysis          "); .PROP:normal_mode_analysis
      case ("nucleus_model=                "); .:read_nucleus_model

    ! case ("optimise_geometry             "); .:optimise_geometry
    ! case ("optimise_orbitals             "); .MISC:optimize_orbitals
    ! case ("optimize_orbitals             "); .MISC:optimize_orbitals
      case ("output_style_options=         "); MOLECULE.MAIN:read_output_style_options

      case ("pair_energy_model=            "); MOLECULE.MAIN:read_pair_energy_model

      case ("phi_step_size                 "); .MAIN:read_phi_step_size
      case ("plot                          "); .PLOT:plot
      case ("plot_fragments                "); .PLOT:plot_fragments
      case ("plots                         "); .PLOT:plots
      case ("plot_grid=                    "); .:read_plot_grid
      case ("plot_ku_density               "); .PLOT:plot_ku_density
      case ("plot_on_isosurface            "); .PLOT:plot_on_isosurface
      case ("plot_uc_density               "); .:plot_uc_density
      case ("pointgroup=                   "); .:read_pointgroup
      case ("put                           "); .PUT:put
      case ("put_1e_properties             "); .PROP:put_1e_properties
      case ("put_1e_properties_for_groups  "); .PROP:put_1e_properties_for_groups
      case ("put_km_1e_properties          "); .PROP:put_1e_properties_with_KM
      case ("put_adps                      "); .PUT:put_ADPs
      case ("put_anos                      "); .PUT:put_ANOs
      case ("put_ao_energy_partition       "); .PROP:put_AO_energy_partition
      case ("put_atom_groups               "); .PUT:put_atom_groups
      case ("put_atomic_form_factors       "); .PUT:put_atomic_form_factors
      case ("put_bda_charges               "); .HAR:put_BDA_charges
      case ("put_becke_grid_atom_info      "); .:becke_grid.put_atom_info
      case ("put_bond_length_with_error    "); .PUT:put_bond_length_with_error
      case ("put_bond_angle_with_error     "); .PUT:put_bond_angle_with_error
      case ("put_torsion_angle_with_error  "); .PUT:put_torsion_angle_with_error
      case ("put_cif                       "); .PUT:put_CIFs
      case ("put_grown_cif                 "); .PUT:put_grown_CIF
      case ("put_cif_with_esds             "); .PUT:put_CIFs(with_esds=FALSE)
    ! case ("put_coppens_interpolators     "); .MISC:put_coppens_interpolators
      case ("put_coulomb_energy            "); .PROP:put_coulomb_energy
      case ("put_crystal                   "); .PUT:put_crystal
      case ("put_density_matrix            "); .PUT:put_density_mx
      case ("put_density_mx                "); .PUT:put_density_mx
    ! case ("put_diff_coppens_slater_ints  "); .MISC:put_diff_coppens_slater_ints
    ! case ("put_diff_slater_interpolators "); .MISC:put_diff_slater_interpolators
      case ("put_dnc_displaced_geometries  "); .PROP:put_dnc_displaced_geometries
    ! case ("put_excel_crystal             "); .PUT:put_excel_crystal
      case ("put_fitting_plots             "); .:crystal.put_fitting_plots ! <--
      case ("put_fock_matrix               "); .PUT:put_Fock_mx
      case ("put_fock_mx                   "); .PUT:put_Fock_mx
    ! case ("put_g_tensor_information      "); .MISC:put_g_tensor_information
      case ("put_group_12_energies         "); .PROP:put_group_12_energies
      case ("put_group_12_multipole_energy "); .PROP:put_group_12_multipole_energies
      case ("put_group_12_spackman1986_ener"); .PROP:put_group_12_Spackman1986_energies
      case ("put_group_12_grimme2006_energy"); .PROP:put_group_12_grimme2006_energy
      case ("put_group_12_polarization_ener"); .PROP:put_group_12_polarization_energy
      case ("put_ha_atom_info              "); .PROP:put_HA_info
      case ("put_hirshfeld_atom_info       "); .PROP:put_HA_info
    ! case ("put_hirshfeld_g_and_k_energy  "); .MISC:put_Hirshfeld_G_and_K_energy
    ! case ("put_hirshfeld_polarisabilities"); .CP:put_H_polarisabilities
    ! case ("put_hirshfeld_polarizabilities"); .CP:put_H_polarisabilities
      case ("put_hirshfeld_test            "); .MAIN:put_Hirshfeld_test
    ! case ("put_interpolator_list         "); .MISC:put_interpolator_list
      case ("put_minmax_residual_density   "); .SCF:get_minmax_residual_density(output=TRUE)
      case ("put_molecular_orbitals        "); .PUT:put_MOs
      case ("put_mo_energies               "); .PUT:put_MO_energies
      case ("put_mo_energy_partition       "); .PROP:put_MO_energy_partition
      case ("put_mos                       "); .PUT:put_MOs
      case ("put_mos_and_energies          "); .PUT:put_MOs_and_energies
      case ("put_mulliken_populations      "); .PROP:put_mulliken_populations
    ! case ("put_mulliken_ku_populations   "); .PROP:put_mulliken_ku_populations
    ! case ("put_mulliken_sf_populations   "); .PROP:put_mulliken_sf_populations
      case ("put_natural_orbitals          "); .PUT:put_NOs
      case ("put_nbo_file_47               "); .PUT:put_NBO_file_47
    ! case ("put_nka_cartesian             "); .PUT:put_NKA_cartesian
    ! case ("put_nka_crystal               "); .PUT:put_NKA_crystal
    ! case ("put_n_structure_factors       "); .PROP:put_N_SFs
      case ("put_normal_modes              "); .PROP:put_normal_modes
      case ("put_nos                       "); .PUT:put_NOs
    ! case ("put_oscillator_overlaps       "); .MISC:put_oscillator_overlaps
    ! case ("put_overlap_eigenvalues       "); .MISC:put_overlap_eigenvalues
    ! case ("put_overlap_matrix            "); .MISC:put_overlap_mx
    ! case ("put_overlap_mx                "); .MISC:put_overlap_mx
      case ("put_overlapping_atoms         "); .PUT:put_overlapping_atoms
    ! case ("put_pdb                       "); .MISC:put_pdb
      case ("put_plot_grid                 "); .PUT:put_plot_grid
    ! case ("put_pnd_sf                    "); .XTAL:put_PND_sf
      case ("put_pointgroup                "); .PUT:put_pointgroup
      case ("put_principal_axes            "); .PUT:put_principal_axes
      case ("put_reflection_data           "); .crystal.put_reflection_data
      case ("put_roby_mmo_energy_partition "); .PROP:put_roby_mmo_energy_partition
      case ("put_roby_smo_energy_partition "); .PROP:put_roby_smo_energy_partition
      case ("put_sao_energy_partition      "); .PROP:put_SAO_energy_partition
      case ("put_scf_energy_in_mo_pairs    "); .PROP:put_SCF_energy_in_mo_pairs
      case ("put_scf_energy_as_mo_parts    "); .PROP:put_SCF_energy_as_mo_parts
      case ("put_scf_atomic_polarisabilitie"); .CP:put_SCF_atomic_polarisability
      case ("put_scf_atomic_polarizabilitie"); .CP:put_SCF_atomic_polarisability
      case ("put_scf_dipole_hyperpolarisabi"); .CP:put_SCF_dipole_hyperpolarisa
      case ("put_scf_dipole_hyperpolarizabi"); .CP:put_SCF_dipole_hyperpolarisa
      case ("put_scf_dipole_polarisability "); .CP:put_SCF_dipole_polarisability
      case ("put_scf_dipole_polarizability "); .CP:put_SCF_dipole_polarisability
      case ("put_shelx_fcf5                "); .PUT:put_shelx_fcf5
      case ("put_shelx_fcf6                "); .PUT:put_shelx_fcf6
      case ("put_shelx_hkl3                "); .PUT:put_shelx_hkl3
      case ("put_shelx_hkl4                "); .PUT:put_shelx_hkl4
    ! case ("put_slater_interpolators      "); .MISC:put_slater_interpolators
      case ("put_sos_dipole_polarisability "); .CP:put_SOS_dipole_polarisability
      case ("put_sylvain_csizmadia_tensors "); .CP:put_Sylvain_Csizmadia_tensors
      case ("put_structure_factor_stats    "); .PROP:put_X_SF_statistics
      case ("put_structure_factors         "); .PROP:put_X_SFs
      case ("put_uc_dipole_polarisability  "); .CP:put_uc_dipole_polarisability
      case ("put_uc_dipole_polarizability  "); .CP:put_uc_dipole_polarisability
      case ("put_uc_dipole_hyperpolarisabil"); .CP:put_uc_dipole_hyperpolar
      case ("put_uc_dipole_hyperpolarizabil"); .CP:put_uc_dipole_hyperpolar
      case ("put_uc_chi2_old               "); .CP:put_uc_chi2
      case ("put_uc_refractive_index       "); .CP:put_uc_refractive_index
      case ("put_vrml                      "); .PUT:put_vrml
      case ("put_xyz_file                  "); .atom.put_xyz_file

      case ("read_archive                  "); .READ:read_archive
      case ("read_ascii_archive            "); .READ:read_ascii_archive
    ! case ("read_pcc_density_matrix       "); .MISC:read_pcc_density_mx
    ! case ("read_pcc_density_mx           "); .MISC:read_pcc_density_mx
      case ("read_g09_fchk_file            "); .READ:read_g09_FChk_file
      case ("read_gaussian_fchk_file       "); .READ:read_g09_FChk_file
      case ("read_molden_file              "); .READ:read_molden_MOs
      case ("read_molden_mos               "); .READ:read_molden_MOs
    ! case ("read_molden_nos               "); .READ:read_molden_NOs
      case ("read_tonto_fchk_file          "); .READ:read_tonto_FChk_file
      case ("redirect                      "); .READ:redirect
      case ("redirect_stdout               "); .READ:redirect_stdout
      case ("refine_hirshfeld_atoms        "); .HAR:HAR_refinement
    ! case ("refine_tanaka_atoms           "); .HAR:TAR_refinement
      case ("reset_molecule                "); .:reset_molecule
      case ("revert                        "); .READ:revert
      case ("revert_stdout                 "); .READ:revert_stdout
      case ("rmp2                          "); .MISC:make_chem_mp2
      case ("roby_analysis                 "); .PROP:roby_analysis
      case ("robydata=                     "); .:read_robydata
      case ("rotate                        "); .MAIN:read_rotate
      case ("rotate_group                  "); .MAIN:read_rotate_group
      case ("rotate_with_matrix            "); .MAIN:read_rotate_mx
      case ("rotate_with_mx                "); .MAIN:read_rotate_mx

      case ("saved_basis_name=             "); .:read_saved_basis_name
      case ("saved_coppensbasis_name=      "); .:read_saved_coppensbasis_name
      case ("saved_isosurface_plot         "); .PLOT:saved_isosurface_plot
      case ("saved_slaterbasis_name=       "); .:read_saved_slaterbasis_name
      case ("saved_plot_on_isosurface      "); .PLOT:saved_plot_on_isosurface
      case ("scf                           "); .SCF:scf
      case ("scfdata=                      "); .:read_scfdata
      case ("serialize=                    "); .:read_serialize_filename
      case ("set_isotropic_adps            "); .:set_isotropic_ADPs
      case ("set_isotropic_h_adps          "); .:set_isotropic_H_ADPs
      case ("shorten_vdw_bond              "); .atom.shorten_shortest_vdw_bond
    ! case ("simulate_new_f_exp            "); .:crystal.simulate_new_F_exp ! use F_sigma_noise
      case ("slaterbasis_name=             "); .:read_slaterbasis_name
      case ("spin_contamination            "); .PROP:spin_contamination
      case ("spin_multiplicity=            "); .:read_spin_multiplicity

      case ("table_column=                 "); MOLECULE.MAIN:read_table_column

      case ("unsave                        "); .SET:unsave
      case ("use_interpolators=            "); .MAIN:read_use_interpolators
      case ("use_spherical_basis=          "); .MAIN:read_use_spherical_basis

      case ("write_aim2000_wfn_file        "); .BASE:put_aim2000_wfn_file
      case ("write_florian_wfn_file        "); .BASE:put_florian_wfn_file
      case ("write_archive                 "); .PUT:put_archive
      case ("write_ascii_archive           "); .PUT:put_ascii_archive
      case ("write_tonto_fchk_mo           "); .PUT:put_tonto_FChk_MO
      case ("write_tonto_fchk_dm           "); .PUT:put_tonto_FChk_DM
      case ("write_morphy98_wfn_file       "); .BASE:put_morphy98_wfn_file
      case ("write_xyz_file                "); .PUT:put_xyz_file

    ! case ("zero_off_atom_density         "); .MISC:zero_off_atom_density
    ! case ("zero_overlap_density          "); .MISC:zero_overlap_density

      ! Crystal Explorer commands ...

      case ("cx_file_name=                 "); .CE:read_CX_file_name
      case ("cx_isosurface=                "); .CE:read_CX_isosurface
      case ("cx_surface=                   "); .CE:read_CX_isosurface
      case ("cx_uses_angstrom=             "); .CE:read_CX_uses_angstrom

      case ("process_cif                   "); .CE:process_CIF
      case ("process_cif_cell_and_symmetry "); .CE:process_CIF_cell_and_symmetry
      case ("process_cif_for_cx            "); .CE:process_CIF_for_CX
      case ("put_cx_data                   "); .CE:put_CX_data
      case ("serialize_isosurface          "); .CE:serialize_isosurface_sbf

      ! Invarioms commands ...

      case ("put_next_neighbour_handedness "); .HAR:put_next_neighbour_handedness
      case ("put_invariom_label            "); .HAR:put_invariom_label
      case ("put_invariom_labels           "); .HAR:put_invariom_labels
      case ("put_smiles_invariom_labels    "); .HAR:put_smiles_invariom_labels

      ! Test commands ...

    ! case ("spherically_averaged_sf       "); .MISC:spherically_averaged_sf
    ! case ("test_dump_file                "); MOLECULE.MAIN:test_dump_file
    ! case ("test_plot_info                "); .:test_plot_info

      case  default ;               UNKNOWN(keyword)

      end

   end

!  A

   read_atoms ::: leaky
   ! Read in the atom list information
      self :: INOUT

   DIE_IF(.cluster.allocated,"cluster already defined! swap cluster= and atoms= ?")
   WARN_IF(.atom.allocated,"atom list already defined!")

      ! Destroy atom_groups & reset group indices
      .atom_group.destroy

      ! Force update
      .atom_info_made = FALSE

      ! Read list keywords
      .atom.read_list_keywords

      ! Finalize
      .BASE:update_atom_basis_group_info


      ! Make Hirshfeld info
      if (.scfdata.allocated) then
      if (.basis_info_made) then
      if (.crystal.allocated) then

         .MAIN:update_crystal_atom_info

         if (.crystal.xray_data.allocated) then
         if (.crystal.uses_numerical_FFs) then
            .SCF:make_HA_inputs
         end
         end

      end
      end
      end

   end

   read_atom_groups ::: leaky
   ! Read in the .atom_group information
      self :: INOUT

 ! WARN_IF(.atom.deallocated,"normally, atoms= must be defined before atom_groups=")

      done :: BIN

      ! Read the atom groups
      .atom_group.read_list_keywords

      ! CE hack to bypass Tonto group finery
      done = FALSE
      if (.atom.deallocated) then
      if (.atom_group.has_wfn_files) then
            ! Make the atoms from FChk files?
            .MAIN:read_groups_from_wfn_files
            done = TRUE
      end
      end

      if (NOT done) then
          .BASE:update_atom_basis_group_info
      end

   end

   read_groups_from_wfn_files ::: leaky, privatej
   ! Make the atom groups by read in Gaussian Fchk files in they are
   ! defined for the groups.
   ! NOTE: this creates a default scfdata since the gaussian FChk more
   ! than likely has some MOs and a density mx inside it.
      self :: INOUT

   DIE_IF(.atom.allocated,"atoms already exists!")
   DIE_IF(.atom_group.deallocated,"no atom groups")
   DIE_IF(NOT .atom_group.has_wfn_files,"no wfn files")

      name :: STR
      g :: INT

      if (.scfdata.deallocated) then
         .scfdata.create
         .scfdata.set_defaults
         .scfdata.set_SCF_kind("rhf") 
      end

      allocate(.mol(.atom_group.dim))

      do g = 1,.atom_group.dim

         ! Set name
         if (.atom_group(g).name /= " ") then
            .mol(g).SET:set_name(.atom_group(g).name)
         end

         ! Define mol from FChk or sbf file
         name = .atom_group(g).wfn_file
         if (name /= " ") .mol(g).READ:read_wfn_file(name)

         ! Set kind of SCF of joined groups!
         if (.mol(g).scfdata.is_unrestricted) then
            .scfdata.set_SCF_kind("uhf") ! <== HERE
         end

         ! Rotate and translate it
         .mol(g).BASE:rotate_by(.atom_group(g).rotation_mx)
         .mol(g).atom.translate_by(.atom_group(g).shift)
         .mol(g).atom.set_group_to(g)

      end

      ! Define .atom list
      .BASE:join_atom_groups

      ! See NOTE in comments
      if (.scfdata.deallocated) then
         .SET:set_SCF_defaults ! NOT PURE
         .scfdata.set_output(FALSE)
      end

      ! Update group info from self
      .SET:update_group_crystal_and_ANOs

   end

!  B

   read_B_field
   ! Read in the applied magnetic B field
      self :: INOUT
      stdin.read_quantity(.B_field)
   end

   read_basis_directory
   ! Read in the basis directory (for all kinds of bases)
      self :: INOUT

      directory :: STR

      stdin.read(directory)
      .SET:set_basis_directory(directory)

   end

   read_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      self :: INOUT

      name :: STR

      stdin.read(name)
      .SET:set_basis_name(name)

      if (.atom.allocated) then
         .BASE:update_atom_basis_group_info
      end

   end

   read_basis_sets ::: leaky
   ! Read in a list of atomic basis sets for the molecule
      self :: INOUT

   WARN_IF(.basis.allocated,"basis sets already defined!")

      ! Copy bases
      if (.atom.allocated)  .atom.destroy_basis_part

      ! Basis sets are read in normalized, but internally
      ! are used unnormalized.
      if (.basis.allocated) .basis.renormalize
      .basis.read_list_keywords
      if (.basis.allocated) .basis.unnormalize

      ! Finalize
      .BASE:update_atom_basis_group_info

      ! Make Hirshfeld info
      if (.scfdata.allocated) then
      if (.atom.allocated) then
      if (.crystal.allocated) then
      if (.crystal.xray_data.allocated) then
      if (.crystal.uses_numerical_FFs) then
         .SCF:make_HA_inputs(skip_NOs=TRUE)
      end
      end
      end
      end
      end

   end

!  Below should be in some other module?

!   batch_HS ::: leaky
!   ! Make a HS for every symmetry-unique molecule in a CIF file
!      self :: INOUT
!
!      i, n_molecules :: INT
!      name :: STR
!
!      .cluster.create(.crystal) 
!      .cluster.set_generation_method("fragment")
!      .cluster.set_radius(ZERO)
!      .cluster.set_defragment(TRUE)
!      .cluster.update_info
!      n_molecules = self.cluster.n_molecules
!
!      name = .name
!
!      do i = 1, n_molecules
!         .MAIN:make_HS_for_group(i)
!         .SET:set_from_saved_self
!         .cluster.create(.crystal) 
!         .cluster.set_generation_method("fragment")
!         .cluster.set_radius(ZERO)
!         .cluster.set_defragment(TRUE)
!         .cluster.update_info
!         .name = name
!      end
!
!   end

!   make_HS_for_group(i) ::: private, leaky
!   ! Make the wavefunction, then HS, then the ESP mapped on it
!   ! for the i-th molecule in the cluster.
!      self :: allocatable, OUT
!
!      i :: INT
!      mol :: MOLECULE@
!      formula, name, filename :: STR
!
!      mol.SET:create
!      .XTAL:create_cluster_mol(i, mol)
!
!      formula = mol.atom.chemical_formula(FALSE)
!      name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
!      stdout.show("Name ", name)
!      stdout.show("Molecular formula ", formula)
!      mol.atom.put_xyz_file(trim(name))
!      stdout.show("Creating Hirshfeld surface m =", i)
!      call make_hirshfeld_surface(mol, 0.5d0) ! Where is this routine?
!      stdout.text("Hirshfeld surface done.")
!      filename = trim(name)//"-hs.sbf"
!      mol.CE:serialize_isosurface_sbf(filename, .cif)
!
!   end

!   make_hirshfeld_surface(m, res) ::: selfless, private, leaky
!   ! Make the HS for molecule "m" with desired resolution "res".
!   ! Also do the ESP on the HS of "m" afterwards.
!      m :: MOLECULE*
!      res :: REAL, IN
!
!      ! Create HS cluster for molecule "m"
!      m.cluster.create(m.crystal)
!      m.cluster.set_generation_method("for_hirshfeld_surface")
!      m.cluster.set_atom_density_cutoff(TOL(8))
!      m.cluster.set_defragment(FALSE)
!      m.cluster.update_info
!      m.BASE:create_cluster
!
!      ! Use Slater-type HS
!      m.atom.set_basis_kind("slater")
!
!      ! Set up interpolator type
!      m.interpolator.create
!      m.interpolator.set_interpolation_method("linear")
!      m.interpolator.set_domain_mapping("sqrt")
!      m.interpolator.set_table_eps(1.0d-10)
!      m.interpolator.set_table_spacing(1.0d-1)
!      m.SET:destroy_interpolators
!
!      ! Set up CX_isosurface
!      m.isosurface.create(m.atom)
!      m.isosurface.property = "stockholder_weight"
!      m.isosurface.triangulation_method = "recursive_marching_cube"
!      m.isosurface.iso_value = 0.5
!      m.isosurface.minimum_scan_division = 1
!      m.isosurface.voxel_proximity_factor = 5
!      m.isosurface.CX_output_distance_properties = TRUE
!      m.isosurface.CX_output_shape_properties = TRUE
!
!      ! Initialize CX_isosurface.plot_grid
!      m.isosurface.plot_grid.use_bcube_with_shape_axes
!      m.isosurface.plot_grid.set_cube_scale_factor(1.0d0)
!
!      ! Desired separation is essentially the resolution of the calculated surface
!      m.isosurface.plot_grid.set_desired_separation(res)
!
!      ! Make isosurface
!      m.PLOT:isosurface_plot
!
!      ! Do the ESP on surface
!      if(FALSE) then
!         m.isosurface.plot_grid.electric_potential_method = "mixed"
!         m.isosurface.surface_property = "electric_potential"
!         m.atom.set_basis_kind("gaussian")
!         m.PLOT:saved_plot_on_isosurface
!      end
!      m.cluster.destroy
!   end

   read_becke_grid ::: leaky
   ! Read in the Becke integration grid data
      self :: INOUT

   ENSURE(.atom.allocated,"input atom information before becke_grid information")

      if (.becke_grid.deallocated) .becke_grid.create

      ! Includes
      .becke_grid.read_keywords
      
      ! Finalize
      .becke_grid.set_atom_info(.atom)
      .becke_grid.set_grid_data

   end

!  C

   read_charge
   ! Read in the total molecular charge
      self :: INOUT

      stdin.read(.charge)

      ! Set the no. of electons
      if (.atom.allocated) .n_e = .INQ:no_of_electrons

   end

   read_cluster ::: leaky
   ! Read in the crystal cluster data. NOTE: the .atom list must correspond to
   ! the (unpruned or pruned) asymmetric unit cell geometry of the .crystal.
      self :: INOUT

   ENSURE(.atom.allocated,"no atom data")
   ENSURE(.crystal.allocated,"no crystal data")

      .crystal.update_fragment_info(.atom)

   DIE_IF(.crystal.asymmetric_unit_atom.deallocated,"atom list missing asym atoms")

      .cluster.destroy
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.read_keywords

   end

   read_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms.
      self :: INOUT

      this :: STR

      stdin.read(this)
      .SET:set_coppensbasis_name(this)

   end

   read_coppensbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      self :: INOUT

   WARN_IF(.coppensbasis.allocated,"coppensbasis sets already defined!")

      if (.atom.allocated)  .atom.destroy_coppensbasis_part

      if (.coppensbasis.allocated) .coppensbasis.renormalize
      .coppensbasis.read_list_keywords
      if (.coppensbasis.allocated) .coppensbasis.unnormalize

      .BASE:update_atom_basis_group_info

   end

   create_g09_wfn_from_crystal
   ! Write g09 input file for what kinmd of job?
      self :: INOUT
     
      atoms :: VEC{ATOM}@
     
      .cluster.create
      .cluster.set_defaults(.crystal)
      .cluster.set_generation_method("fragment")
      .cluster.set_defragment(TRUE)
      .cluster.update_info
      .cluster.create_mol_atom_list(atoms, 1)
     
      atoms.put_g09_input(trim(.name))

   end

   read_crystal ::: leaky
   ! Read in the crystal data. If the ".atom" list data is available,
   ! its coordinates will be resolved into cartesians at this point.
   ! IMPORTANT NOTE: normally the crystal information will be inputted
   ! from a CIF file.  However, if the crystal information is inputted
   ! explicitly, and the asymmetric unit is not specified, then the
   ! symmetry unique atoms in the ".atom" list are used to define the
   ! crystal asymmetric unit. Once defined, the asymmetric unit in the
   ! crystal is never destroyed. Thus, in this case, you must ensure
   ! that your atom list has enough atoms to generate the entire
   ! crystal; for co-crystals this may be a problem. Use the CIF file
   ! method for input in this case, or be careful.
      self :: INOUT

   WARN_IF(.crystal.allocated,"crystal data already defined!")

      ! Destroy
      if (.crystal.deallocated) .crystal.create

      ! Read
      .crystal.read_keywords

      ! Finalize crystal
      if (.crystal.finalize) then

         if (.atom.allocated) then

            ! Finalize.
            ! May be needed for fragment capping
            .BASE:update_atom_basis_group_info

            .MAIN:update_crystal_atom_info

         end


         .crystal.update_diffraction_data

      end

      ! Set dispersion coefficients?
    ! if (.atom.allocated) then
    ! if (.crystal.xray_data.allocated) then
    ! if (.crystal.xray_data.have_set_wavelength) then
    !    .atom.set_dispersion_coefficients(.crystal.xray_data.wavelength)
    ! end
    ! end
    ! end

      ! Make Hirshfeld info
      if (.scfdata.allocated) then
      if (.basis_info_made) then
      if (.atom.allocated) then

         if (.crystal.xray_data.allocated) then
         if (.crystal.uses_numerical_FFs) then
            .SCF:make_HA_inputs(skip_NOs=TRUE)
         end
         end

      end
      end
      end

      ! Reset to finalize next time
      .crystal.finalize = TRUE

   end

   update_crystal_atom_info ::: private, leaky
   ! Update the crystal info if new atom info has been read in.
      self :: INOUT

      tags :: VEC{STR}@

      ! Finalize crystal
      .crystal.finalize = TRUE

      ! Set H U iso
      if (.crystal.xray_data.allocated) then
      if (.crystal.xray_data.refine_H_U_iso) then
         .atom.set_isotropic_H_ADP
      end
      end

      ! Set U iso's
      if (.crystal.xray_data.allocated) then
      if (.crystal.xray_data.refine_U_iso_for_atom.allocated) then
         tags = .crystal.xray_data.refine_U_iso_for_atom
         .atom.set_isotropic_ADPs(tags)
      end
      end

      ! Cartesian axes
      .SET:resolve_axis_system
      .crystal.update_fragment_info(.atom)

      ! Set H U iso & really do it this time
      if (.crystal.xray_data.allocated) then
      if (.crystal.xray_data.refine_H_U_iso) then
         .crystal.fragment_atom.set_isotropic_H_ADP
         .crystal.asymmetric_unit_atom.set_isotropic_H_ADP
         .crystal.unit_cell_atom.set_isotropic_H_ADP
      end
      end

      ! Set U iso & really do it this time
      if (.crystal.xray_data.allocated) then
      if (.crystal.xray_data.refine_U_iso_for_atom.allocated) then
         tags = .crystal.xray_data.refine_U_iso_for_atom
         .crystal.fragment_atom.set_isotropic_ADPs(tags)
         .crystal.asymmetric_unit_atom.set_isotropic_ADPs(tags)
         .crystal.unit_cell_atom.set_isotropic_ADPs(tags)
      end
      end

      ! Set dispersion coefficients?
    ! if (.atom.allocated) then
    ! if (.crystal.xray_data.allocated) then
    ! if (.crystal.xray_data.have_set_wavelength) then
    !    .atom.set_dispersion_coefficients(.crystal.xray_data.wavelength)
    ! end
    ! end
    ! end

      ! Make Hirshfeld info
      if (.scfdata.allocated) then
      if (.basis_info_made) then
      if (.atom.allocated) then
      if (.crystal.xray_data.allocated) then
      if (.crystal.uses_numerical_FFs) then
         .SCF:make_HA_inputs(skip_NOs=TRUE)
      end
      end
      end
      end
      end

   end

!  D

   read_deserialize_filename ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      self :: INOUT

      name :: STR

      stdin.read(name)
      .READ:deserialize(name)

   end

   read_dispersion_coefficients ::: leaky
   ! Read the anaomalous dispersion coefficients f' and f''
   ! and set the atom list
      self :: INOUT

   DIE_IF(.atom.deallocated,"please enter dispersion after atom list")

      ATOM:read_dispersion_coefficients

      .atom.set_tabular_dispersion

   end

!   dump_xyz_files ::: leaky
!   ! Generate all wavefunctions from the cluster
!   ! NOTE: Broken, need to create scfdata etc.
!   ! Very bad name! Fix! -- dylan
!      self :: INOUT
!
!      mol :: MOLECULE@
!      formula :: STR
!      filename :: STR
!      i :: INT
!
!      ! Defragment the cluster
!      .cluster.create(.crystal) 
!      .cluster.set_generation_method("fragment")
!      .cluster.set_radius(ZERO)
!      .cluster.set_defragment(TRUE)
!      .cluster.update_info
!
!      ! One molecule
!      i = 1
!      if (.cluster.n_molecules==1) then
!         formula  = .atom.chemical_formula(FALSE)
!         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
!         stdout.show("Writing xyz file", trim(filename))
!         .atom.put_xyz_file(trim(filename))
!         return
!      end
!
!      ! Several mols?
!      do i = 1,.cluster.n_molecules
!         ! Make the i-th molecule
!         mol.SET:create
!         .XTAL:create_cluster_mol(i, mol)
!         stdout.show("Writing xyz file", trim(filename))
!         formula = mol.atom.chemical_formula(FALSE)
!         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
!         mol.atom.put_xyz_file(trim(filename))
!      end
!
!   end

!  E

   read_E_field
   ! Read in the applied electric E field
      self :: INOUT
      stdin.read_quantity(.E_field)
   end

!  F

!   find_d_norm_contacts ::: leaky
!   ! Find the close d_norm values and store the list of indices for
!   ! the corresponding closest atoms inside and outside the HS.
!      self :: PTR
!
!   ENSURE(.cif.allocated,"no CIF file")
!   ENSURE(.isosurface.allocated,"no isosurface")
!
!      i :: INT
!      ub :: REAL
!      formula, name :: STR
!      CX_file :: TEXTFILE*
!
!      ! Defragment any molecules in the CIF
!      .cluster.create(.crystal) 
!      .cluster.set_generation_method("fragment")
!      .cluster.set_radius(ZERO)
!      .cluster.set_defragment(TRUE)
!      .cluster.update_info
!
!      ub = .isosurface.surface_property_ub
!
!      if (.cluster.n_molecules == 1) then
!
!         i = 1
!
!         ! Set up name
!         formula = .atom.chemical_formula(FALSE)
!         stdout.show("formula ", formula)
!         name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
!
!         ! Make the HS
!         stdout.flush
!         stdout.show("Creating Hirshfeld surface m =", i)
!         call make_HS(self,ub)
!         stdout.flush
!         stdout.text("Hirshfeld surface done.")
!
!         ! Print out cxs file
!         CX_file.create(trim(name)//".cxs")
!         CX_file.open_for("write")
!         .CE:put_CX_data(CX_file,.cif)       
!         CX_file.close
!         CX_file.destroy
!
!         return
!
!      end
!
!      ! Make all HSs for i-th cluster mol
!      do i = 1, .cluster.n_molecules
!         .MAIN:make_HS_for_cluster_mol(i,ub)
!      end
!
!   end

!   make_HS(m,ub) ::: selfless, private, leaky
!   ! Make the HS for molecule "m" with desired resolution "res".
!      m  :: MOLECULE, INOUT
!      ub :: REAL, IN
!
!      res :: REAL
!
!      res = 0.2d0
!
!      ! Create HS cluster for molecule "m"
!      m.cluster.create(m.crystal)
!      m.cluster.set_generation_method("for_hirshfeld_surface")
!      m.cluster.set_atom_density_cutoff(TOL(8))
!      m.cluster.set_defragment(FALSE)
!      m.cluster.update_info
!
!      !!!!!!!!!!!!!!!!!!!!!
!      m.BASE:create_cluster
!      !!!!!!!!!!!!!!!!!!!!!
!
!      ! Use Slater-type HS
!      m.atom.set_basis_kind("slater")
!
!      ! Set up interpolator type
!      m.interpolator.create
!      m.interpolator.set_interpolation_method("linear")
!      m.interpolator.set_domain_mapping("sqrt")
!      m.interpolator.set_table_eps(1.0d-10)
!      m.interpolator.set_table_spacing(1.0d-1)
!      m.SET:destroy_interpolators
!
!      ! Set up CX_isosurface
!      m.isosurface.destroy
!      m.isosurface.create(m.atom)
!      m.isosurface.property = "stockholder_weight"
!      m.isosurface.triangulation_method = "recursive_marching_cube"
!      m.isosurface.iso_value = 0.5
!      m.isosurface.minimum_scan_division = 1
!      m.isosurface.voxel_proximity_factor = 5
!      m.isosurface.CX_output_distance_properties = TRUE
!      m.isosurface.CX_output_shape_properties = TRUE
!
!      ! Initialize CX_isosurface.plot_grid
!      m.isosurface.plot_grid.use_bcube_with_shape_axes
!      m.isosurface.plot_grid.set_cube_scale_factor(1.0d0)
!
!      ! Desired separation is essentially the resolution of the calculated surface
!      m.isosurface.plot_grid.set_desired_separation(res)
!
!      ! Make HS isosurface
!      m.PLOT:isosurface_plot
!
!      ! Do the d_norm close contact table
!      if (m.isosurface.allocated) then
!      if (m.isosurface.atom.allocated) then 
!      if (m.saved.allocated) then
!      if (m.saved.cluster.allocated) then
!         m.isosurface.set_surface_property_ub(ub)
!         m.isosurface.put_d_norm_info(m.saved.cluster.fragment_atom_indices    &
!                                     ,m.saved.cluster.nonfragment_atom_indices &
!                                     ,m.atom)
!      end
!      end
!      end
!      end
!
!   end

!   make_HS_for_cluster_mol(i,ub) ::: private, leaky
!   ! Make the HS for cluster molecule i.
!      self :: INOUT
!      i :: INT, IN
!      ub :: REAL, IN
!
!      mol :: MOLECULE@
!      formula, name :: STR
!      CX_file :: TEXTFILE*
!
!      ! Make the i-th cluster molecule "mol"
!      mol.SET:create
!      .XTAL:create_cluster_mol(i, mol)
!
!      ! Set molecule name
!      formula = mol.atom.chemical_formula(FALSE)
!      stdout.show("formula ", formula)
!      name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
!      mol.SET:set_name(trim(name))
!
!      ! Set basis set
!      mol.basis_name = .basis_name
!      .BASE:update_atom_basis_group_info
!
!      ! Make the HS
!      stdout.flush
!      stdout.show("Creating Hirshfeld surface m =", i)
!      call make_HS(mol,ub)
!      stdout.flush
!      stdout.text("Hirshfeld surface done.")
!
!      ! Deposit cxs file
!      CX_file.create(trim(name)//".cxs")
!      CX_file.open_for("write")
!      mol.CE:put_CX_data(CX_file,.cif)       
!      CX_file.close
!      CX_file.destroy
!
!      ! Clean
!      mol.SET:destroy
!
!   end

!  G

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external 
   ! magnetic field
      self :: INOUT
      stdin.read_quantity(.gauge_origin)
   end

!   generate_all_wavefunctions ::: leaky
!   ! Generate all wavefunctions from the cluster
!   ! NOTE: Broken, need to create scfdata etc.
!      self :: INOUT
!
!      mol :: MOLECULE@
!      i :: INT
!      formula :: STR
!      filename, name :: STR
!
!      ! Defragment the cluster
!      .cluster.create(.crystal) 
!      .cluster.set_generation_method("fragment")
!      .cluster.set_radius(ZERO)
!      .cluster.set_defragment(TRUE)
!      .cluster.update_info
!
!
!      ! Make a single wavefunction
!      if (.cluster.n_molecules == 1) then
!
!         formula = .atom.chemical_formula(FALSE)
!         .SCF:make_ANO_data
!         .SCF:scf
!
!         i = 1
!         filename = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)//".sbf"
!         .PUT:serialize(filename)
!
!         return
!
!      end
!
!      ! Make several wavefunctions
!      do i = 1, .cluster.n_molecules
!
!         ! Make the i-th molecule
!         mol.SET:create
!         .XTAL:create_cluster_mol(i, mol) ! THIS IS STRANGE - FIX
!
!         ! Set up the name of the molecule
!         formula = mol.atom.chemical_formula(FALSE)
!         name = trim(.name)//"-"//trim(formula)//"_"//trim(i.to_str)
!         mol.SET:set_name(trim(name))
!         mol.basis_name = .basis_name
!         mol.scfdata.copy(.scfdata)
!
!         ! Make the wavefunction
!         mol.SCF:make_ANO_data
!         mol.SCF:scf
!
!         ! Dump data
!         filename = trim(name)//".sbf"
!         mol.PUT:serialize(filename)
!
!      end
!
!   end

!  I

   read_interpolator ::: leaky
   ! Read template interpolators
      self :: INOUT

      .interpolator.destroy
      .interpolator.create
      .interpolator.read_keywords
      .SET:destroy_interpolators

   end

   read_isosurface ::: leaky
   ! Read in the isosurface data. 
   ! NOTE: the isosurface has its own plotgrid, different from that
   ! used in normal density plots, but .plot_grid is assigned to it.
   ! This will be a nightmare for memory leaks!
      self :: INOUT

      ! Destroy
      if (.isosurface.deallocated) .isosurface.create(.atom)

      ! Read
      .isosurface.read_keywords

   end

   set_isotropic_ADPs
   ! As it says
      self :: INOUT

      ! Make isotropic
      if (.crystal.allocated) then
      if (.crystal.xray_data.allocated) then
      if (.crystal.xray_data.refine_U_iso_for_atom.allocated) then

         .atom.set_isotropic_ADPs(.crystal.xray_data.refine_U_iso_for_atom)

         .SET:resolve_axis_system
         .crystal.destroy_asymmetric_unit
         .crystal.update_fragment_info(.atom)

      end
      end
      end

   end

   set_isotropic_H_ADPs
   ! As it says
      self :: INOUT

      ! Make isotropic
      .atom.set_isotropic_H_ADP

      ! Finalize crystal
      if (.crystal.allocated) then
         .SET:resolve_axis_system
         .crystal.destroy_asymmetric_unit
         .crystal.update_fragment_info(.atom)
      end

   end

!  K

   set_keyword_echo_on ::: selfless
   ! Echo keywords into the stdout file
      tonto.set_keyword_echo(TRUE)
   end

!  L

!   lattice_energy
!   ! Calculate lattice energy?
!      self :: INOUT
!
!      g09_file :: STR
!
!      stdin.read(g09_file)
!      .CE:total_lattice_energy(g09_file)
!
!   end

   set_low_verbosity_on ::: selfless, private
   ! Set low output verbosity
      self :: IN
      tonto.set_low_verbosity(TRUE)
   end

!  M

!  N 

   read_name
   ! Read in the name of the molecule. This must always be
   ! the first keyword inputted.
      self :: INOUT

      val :: STR

      stdin.read(val)
      .SET:set_name(val)

   end

   read_nucleus_model ::: leaky
   ! Read whether what nucleus model to use
      self :: INOUT
      stdin.read(.nucleus_model)
   end

!  O

   read_output_style_options ::: selfless, private
   ! Read new output style options, for example change the
   ! width and number of field, or precision of output.
      self :: INOUT
      stdout.read_keywords(TEXTFILE::stdin)
   end

!  P

   put_Hirshfeld_test
   ! Set pair-energy model
      self :: IN

   DIE_IF(.atom.deallocated,"there are no atoms!")

      .atom.put_Hirshfeld_test

   end

   read_pair_energy_model ::: leaky, selfless
   ! Set pair-energy model
      self :: INOUT

      energy_model :: STR

      stdin.read(energy_model)
      VEC{PAIR_ENERGY}:set_energy_model(trim(energy_model))

   end

   read_phi_step_size ::: leaky
   ! Read in the dimensionless normal coordinate step size.
      self :: INOUT

      stdin.read(.phi_step_size)

   WARN_IF(.phi_step_size<TOL(2),"phi_step_size may be too small")

   end

   read_e_lat_convergence ::: leaky, selfless
   ! Set pair-energy convergence threshhold
      self :: INOUT

      threshold :: REAL

      stdin.read(threshold)
      VEC{PAIR_ENERGY}:set_convergence_threshold(threshold)

   end

   read_plot_grid ::: leaky
   ! Read in the plot grid data
      self :: INOUT

      ! Set up a defualt grid
      if (.plot_grid.deallocated) .plot_grid.create(.atom)

      ! Read options
      .plot_grid.read_keywords
      
      if (.plot_grid.use_unit_cell_as_bbox) then
         DIE_IF(.crystal.deallocated,"unit_cell_as_bbox set, but no crystal= info given! Fair go!")
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell,recenter=FALSE)
      end

   DIE_IF(.plot_grid.plot_format==" ","plot_format not specified (try all)")

   end

   plot_uc_density   
   ! Plot the unit cell density
     self :: INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.crystal.allocated,"no crystal info")
   ENSURE(NOT .crystal.cluster_info_made,"cluster info already made!")

     .SCF:make_ANO_data

     .crystal.destroy_fragment_data
     .crystal.update_fragment_info(.atom)

     .crystal.set_generation_method("for_unit_cell_density") 
     .crystal.set_atom_density_cutoff(1.0d-3) 
     .crystal.make_cluster_info
     .crystal.put_cluster_info

   end

   read_pointgroup ::: leaky
   ! Read in the pointgroup data
      self :: INOUT

      if (.pointgroup.deallocated) .pointgroup.create
      .pointgroup.read_keywords

   end

!  R

   read_robydata ::: leaky
   ! Read in the Roby data. NOTE: this keyword must appear after a basis set
   ! has been defined
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")

      ! Make the Becke grid
      if (.becke_grid.deallocated) .becke_grid.create
      .becke_grid.set_atom_info(.atom)
      .becke_grid.set_grid_data

      .INTS:make_overlap_mx
      .SCF:make_core_mx
    ! if (.scfdata.allocated) then
    !    .SCF:make_Fock_mx
    ! end

      if (.roby.allocated) .roby.destroy
      .roby.create(self)

      .roby.read_keywords

      .roby.update

   end

   read_rotate
   ! Rotate the whole molecule using matrix defined by its rotation
   ! "axis" and the "angle" of rotation around that axis, which are
   ! both inputted.  Checked, 7/2/06; it needed the archives to be
   ! deleted to work
      self :: INOUT

      R :: MAT{REAL}(3,3)
      axis :: VEC{REAL}(3)
      angle :: REAL

      ! Read axis
      stdin.read(axis)
      stdin.read(angle)
      ENSURE(NOT axis.is_zero,"axis must not be zero")

      ! Delete archives
      .SET:delete_SCF_archives

      ! Get the rotation matrix from the axis
      R.to_3x3_rotation_mx(axis,angle)

      ! Rotate
      .BASE:rotate_by(R)

      ! Remake the Becke grid (leaky)
      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom)
         .becke_grid.set_grid_data
      end

   end

   read_rotate_group ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix
   ! defined by its rotation "axis" and the "angle" of rotation around
   ! that axis, which are all inputted on the command line. The
   ! rotation is performed on the coordinates and the group-block
   ! diagonal of the density matrix. NOTE: this can be a problem for
   ! group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual
   ! rotation
      self :: INOUT

   ENSURE(.atom_group.allocated,"no atom group information")

      axis :: VEC{REAL}(3)
      angle :: REAL
      g :: INT

      stdin.read(g)               ! read group
      stdin.read(axis)            ! read axis
      stdin.read_quantity(angle)  ! read angle

      ENSURE(g>0,"group number must be positive")
      ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
      ENSURE(NOT axis.is_zero,"axis must not be zero")

      .BASE:rotate_group(g,axis,angle)

   end

   read_rotate_mx ::: leaky
   ! Same as read_rotate except reads the rotation matrix from 
   ! the stdin file
      self :: INOUT

      R :: MAT{REAL}(3,3)

      ! Read matrix
      stdin.read(R)

      ! Delete archives
      .SET:delete_SCF_archives

      ! Rotate
      .BASE:rotate_by(R)

      ! Remake the Becke grid (leaky)
      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom)
         .becke_grid.set_grid_data
      end

   end

!  S

   read_saved_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms in the
   ! *saved* molecule.
      self :: INOUT

   ENSURE(.saved.allocated,"there is no saved molecule")

      this :: STR

      stdin.read(this)
      .saved.SET:set_basis_name(this)

   end

   read_saved_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms in the
   ! *saved* molecule.
      self :: INOUT

   ENSURE(.saved.allocated,"there is no saved molecule")

      this :: STR

      stdin.read(this)
      .saved.SET:set_coppensbasis_name(this)

   end

   read_saved_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms in the
   ! *saved* molecule.
      self :: INOUT

   ENSURE(.saved.allocated,"there is no saved molecule")

      this :: STR

      stdin.read(this)
      .saved.SET:set_slaterbasis_name(this)

   end

   read_scfdata ::: leaky
   ! Read in the scf data
      self :: INOUT

      if (.scfdata.deallocated) .scfdata.create

      ! Read options
      .scfdata.read_keywords

      ! Internal post-process options
      .scfdata.update

      ! Make Hirshfeld info
      if (.crystal.allocated) then
      if (.crystal.xray_data.allocated) then
      if (.crystal.uses_numerical_FFs) then
         .SCF:make_HA_inputs(skip_NOs=TRUE)
      end
      end
      end

      ! Each atom_group has up-to-date scfdata options
      ! Do the whole kaboodle again.
      if (.atom_group.allocated) then
         .BASE:update_atom_basis_group_info
      end

   end

   read_serialize_filename ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      self :: IN

      name :: STR

      stdin.read(name)
      .PUT:serialize(name)

   end

   read_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms.
      self :: INOUT

      name :: STR

      stdin.read(name)
      .SET:set_slaterbasis_name(name)

      ! Finalize crystal - remake basis kinds !
    ! if (.crystal.allocated) then
    !    .crystal.destroy_asymmetric_unit
    !    .crystal.update_fragment_info(.atom)
    ! end

   end

   read_slaterbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      self :: INOUT

   WARN_IF(.slaterbasis.allocated,"slaterbasis sets already defined!")

      if (.atom.allocated) .atom.destroy_slaterbasis_part

      if (.slaterbasis.allocated) .slaterbasis.renormalize
      .slaterbasis.read_list_keywords
      if (.slaterbasis.allocated) .slaterbasis.unnormalize

      .BASE:update_atom_basis_group_info

   end

   read_spin_multiplicity
   ! Read in the spin multiplicity
      self :: INOUT

      val :: INT

      stdin.read(val)
      .SET:set_spin_multiplicity(val)

   end

   delta_lambda_plot ::: leaky
   ! Do a plot of the difference between a property
   ! ".plot_grid.plot_kind" using molecular orbitals or density
   ! matrices for .scfdata.lambda_max and .scfdata.initial_lambda, 
   ! and write out the file.
      self :: INOUT

   ENSURE(.plot_grid.allocated, "no plot_grid!")
   ENSURE(.scfdata.allocated, "no scfdata!")

      gr1,gr2 :: VEC{REAL}@
      nm1,nm2 :: STR
      kind :: STR

      ! Get lambda values
      nm1 = "MOs,lambda=" // trim(.scfdata.lambda_max.to_str("f9.6"))
      nm2 = "MOs,lambda=" // trim(.scfdata.initial_lambda.to_str("f9.6"))
      kind = .scfdata.spinorbital_genre

      ! Property values.
      gr1.create(.plot_grid.n_pt)
      gr2.create(.plot_grid.n_pt)

      ! Read the lambda_max
      .READ:read_archive(nm1,kind)
      .BASE:assign_NOs_to_MOs
      .BASE:make_SCF_density_mx

      ! Plot max
      .PLOT:do_plot(gr1)

      ! Read the initial_lambd
      .READ:read_archive(nm2,kind)
      .BASE:assign_NOs_to_MOs
      .BASE:make_SCF_density_mx

      ! Plot initial_lamba
      .PLOT:do_plot(gr2)

      ! Subtract
      gr1 = gr1 - gr2

      ! Print out
      .PUT:dump_plot_grid(gr1,"subtracted_plot")

      ! Clean
      gr2.destroy
      gr1.destroy

   end

!  T

   read_table_column ::: selfless, leaky
   ! Read in default settings for table_column output

      TABLE_COLUMN:create_std_table_column
      std_table_column.read_keywords

   end

!  U

   read_use_interpolators
   ! Read whether to use interpolators
      self :: INOUT

      stdin.read(.use_interpolators)
      if (.atom.allocated) .atom.set_use_interpolators(.use_interpolators)

   end

   read_use_spherical_basis ::: leaky
   ! Read whether to use a spherical basis
      self :: INOUT

      stdin.read(.use_spherical_basis)
    ! .SET:resolve_gaussianbases

      if (.atom.allocated) then
         .BASE:update_atom_basis_group_info
      end

   end

!  =============
!  Test routines
!  =============

!   test_dump_file ::: selfless
!   ! Always put a comment ...
!      self :: IN
!
!      d :: DATAFILE
!      i :: INT
!      i_in, i_out :: VEC{INT}@
!      err :: INT
!
!      i_in = [(i*i, i=1,100)]
!
!      d.open("test.sbf")
!      call d%sbf%add_dataset(sbf_Dataset("integer_dataset", i_in))
!      stdout.show("integer_dataset write", i_in)
!      call d%sbf%serialize
!      d.close
!
!      d.open("test.sbf")
!      call d%sbf%deserialize
!      call d%sbf%get("integer_dataset", i_out, err)
!      stdout.show("integer_dataset read ", i_out)
!      if (NOT err == 1) print *, "Error: ", sbf_strerr(err)
!      d.close
!
!   end

!   generate_g09_input
!   ! Write g09 input file for what kinmd of job?
!     self :: PTR
!
!     atoms :: VEC{ATOM}*
!
!     .cluster.create(.crystal) 
!     .cluster.set_generation_method("fragment")
!     .cluster.set_defragment(TRUE)
!     .cluster.update_info
!     .cluster.create_mol_atom_list(atoms, 1)
!
!     atoms.put_g09_input(trim(.name))
!
!   end

! Test plot UC density code

   test_plot_info
   ! Test tlot the unit cell density
     self :: INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.crystal.allocated,"no crystal info")
   ENSURE(NOT .crystal.cluster_info_made,"cluster info already made!")

      pt :: MAT{REAL}@
      shift :: MAT{INT}@
      parent, symop :: VEC{INT}@
      i,p,g :: INT

   ! .crystal.destroy_fragment_data
   ! .crystal.update_fragment_info(.atom)

   ! .crystal.set_generation_method("for_unit_cell_density") 

     pt.create(.plot_grid.n_pt,3)
     .plot_grid.make_points(pt)

     .plot_grid.put

     .crystal.set_atom_density_cutoff(1.0d-3) 
     .crystal.make_plot_info(pt,parent,symop,shift)

     if (parent.allocated) then

        do i = 1, parent.dim
            p = parent(i)
            g = .atom_group.group_for_atom(p)
            stdout.text("The group for atom "//trim(p.to_str)//" is "//trim(g.to_str))
            stdout.show("parent     =",p)
            stdout.show("symop      =",symop(i))
            stdout.show("With shift =",shift(:,i))
        end

     end

   ! .crystal.put_cluster_info

   end

   make_Vanfleteren_atoms 
   ! Do it.
      self :: INOUT

   ENSURE(.MOs.allocated,"No MOs")
   ENSURE(.MOs.r.allocated,"No restricted MOs")

      S,Sc,rho,rmh :: MAT{REAL}@
      rho_this,   rho_next   :: MAT{REAL}@
      rho_this_A, rho_next_A :: MAT3{REAL}@
      wgt_this_A             :: MAT3{REAL}@
      iter, n, a,na, f,l     :: INT
      diff :: REAL

      ! No. of basis fn's
      n = .n_bf

      ! VA iterative array matrices
      rho_next_A.create(n,n,.n_atom)
      rho_this_A.create(n,n,.n_atom)
      wgt_this_A.create(n,n,.n_atom)

      ! Total densities
      rho_this.create(n,n)
      rho_next.create(n,n)

      ! And zero em ...
      rho_this_A = ZERO

      ! Overlap matrices & powers
        S.create(n,n)
    ! Sph.create(n,n)
    ! Smh.create(n,n)
      rmh.create(n,n)

      ! And define em ...
      S = .overlap_mx
    ! Sph.to_sqrt_of(S)         ! S^+1/2
    ! Smh.to_inverse_sqrt_of(S) ! S^-1/2

      ! S . MOs
      Sc = matmul(S,.MOs.r)

      ! Check
    ! W = S
    ! W.change_basis_using(Smh)
    ! stdout.text("Check Smh . S . Smh :")
    ! stdout.put(W)

      ! Check
    ! W = matmul(Sph,Smh)
    ! stdout.text("Check Sph . Smh :")
    ! stdout.put(W)

      ! Get rho in symmetrically orthonormal basis 
      rho = .density_mx.r
      rho.change_basis_using(Sc)

      stdout.text("rho in MO basis:")
      stdout.put(rho)

      ! Set initial rho^(i)_AA
      rho_this_A = ZERO
      l = 0
      do a = 1,.atom.dim
         f = l + 1
         l = l +  .atom(a).basis.n_bf
         rho_this_A(f:l,f:l,a) = .atom(a).density_mx.r
      end

      stdout.text("Transferred rho^(i)_AA in AO basis:")
      stdout.put(rho_this_A)

      ! Get rho^(i)_AA in the MO basis
      rho_this = ZERO
      l = 0
      do a = 1,.atom.dim
         ! Basis fn limits
         na = .atom(a).basis.n_bf
         f  = l + 1
         l  = l + .atom(a).basis.n_bf
         ! Initial rho^(i)_AA
         rho_this_A(:,:,a).change_basis_using(Sc)
         ! rho^(i) = Sum_A rho^(i)_AA ... eqn 6(a)
         rho_this = rho_this + rho_this_A(:,:,a)
      end

      stdout.text("rho^(i)_AA in the MO basis:")
      stdout.put(rho_this_A)

      stdout.text("rho^(i) in the MO basis:")
      stdout.put(rho_this)

      ! Start iterations
      iter = 0

      do 

         iter = iter + 1
       
         ! Overwrite new [rho^(i)]^-1/2
         rmh.to_sqrt_of(rho_this) 
       
         ! Make the w_A_i ... 6b
         wgt_this_A = ZERO
         do a = 1,.n_atom
            rho_this_A(:,:,a).change_basis_to(wgt_this_A(:,:,a),rmh)
         end
       
         ! Update the atomic rho_A's
         rho_next_A = ZERO
         do a = 1,.n_atom
            rho.change_basis_to(rho_next_A(:,:,a),wgt_this_A(:,:,a))
         end
       
         ! Difference
         diff = maxval(abs(rho_next_A-rho_this_A))
         stdout.show("Diff. between rho i+1 and rho i =",diff)

         ! Converged?
         if (diff<TOL(2) OR iter>10) exit

         rho_this_A = rho_next_A

      end

   end

end
