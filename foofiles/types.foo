!===============================================================================
!
! TYPES : used to deposit all derived types used in TONTO.
!
! A separate module is required so that two modules can see each others types
! even if they can't use each others routines by with a "use" statement.
!
! Please follow the indenting style here to allow the foo version of
! ctags to do its work properly
!
! (c) dylan jayatilaka, university of western australia, 1998
!
!===============================================================================

module TYPES

   ! External modules
   use sbf

#ifdef MPI
!  Note the capital USE, below which prevents the 
!  preprocessor from making the module a dependent
   USE mpi, only: MPI_STATUS_SIZE
#endif


   implicit none


!  ========================
!  Encapsulated Array types
!  ========================

   type EVEC{BIN}

     element :: VEC{BIN}@
     ! Encapsulated type

   end

   type EVEC{INT}

     element :: VEC{INT}@
     ! Encapsulated type

   end

   type EVEC{STR}

     element :: VEC{STR}@
     ! Encapsulated type

   end

   type EVEC{REAL}

     element :: VEC{REAL}@
     ! Encapsulated vec type

   end


   array type VEC{EVEC{BIN}}

     ! A 1-D array of EVEC{BIN} objects

   end

   array type VEC{EVEC{INT}}

     ! A 1-D array of EVEC{INT} objects

   end

   array type VEC{EVEC{STR}}

     ! A 1-D array of EVEC{INT} objects

   end

   array type VEC{EVEC{REAL}}

     ! A 1-D array of EVEC{REAL} objects

   end

   array type MAT{EVEC{INT}}

     ! A matrix of EVEC{INT} objects

   end

   array type MAT{EVEC{REAL}}

     ! A matrix of EVEC{REAL} objects

   end

   array type MAT3{EVEC{INT}}

     ! A 3D matrix of EVEC{INT} objects

   end


   type EVEC{EVEC{INT}}

     element :: VEC{EVEC{INT}}@
     ! Encapsulated encapsulated vector

   end

   type EVEC{EVEC{REAL}}

     element :: VEC{EVEC{REAL}}@
     ! Encapsulated encapsulated vector

   end


   array type VEC{EVEC{EVEC{INT}}}

     ! A 1-D array of EVEC{EVEC{INT}} objects

   end

   array type VEC{EVEC{EVEC{REAL}}}

     ! A 1-D array of EVEC{EVEC{REAL}} objects

   end



   type EMAT{BIN}

     element :: MAT{BIN}@ 
     ! Encapsulated mat type

   end

   type EMAT{INT}

     element :: MAT{INT}@ 
     ! Encapsulated mat type

   end

   type EMAT{REAL}

     element :: MAT{REAL}@
     ! Encapsulated mat type

   end


   array type VEC{EMAT{BIN}}

     ! A 1-D array of EMAT{BIN} objects

   end

   array type VEC{EMAT{INT}}

     ! A 1-D array of EMAT{INT} objects

   end

   array type VEC{EMAT{REAL}}

     ! A 1-D array of EMAT{REAL} objects

   end

   array type MAT{EMAT{REAL}}

     ! A matrix of EMAT{REAL} objects

   end



   type EMAT3{REAL}

     element :: MAT3{REAL}@
     ! Encapsulated mat3 type

   end

   array type VEC{EMAT3{REAL}}

     ! A 1-D array of EMAT3{REAL} objects

   end



   type EMAT4{REAL}

     element :: MAT4{REAL}@
     ! Encapsulated mat4 type

   end

   array type VEC{EMAT4{REAL}}

     ! A 1-D array of EMAT4{REAL} objects

   end


!  ===============
!  Operators types
!  ===============

   type OPVECTOR

     n_bf :: INT
     ! No of spatial basis functions (i.e. AO's)

     restricted :: VEC{REAL}@
     ! Restricted spinorbital representation

     alpha :: VEC{REAL}@
     ! Alpha part of a DODS representation

     beta :: VEC{REAL}@
     ! Beta  part of a DODS representation

     general :: VEC{REAL}@
     ! General mixed alpha-beta matrix representation

   end

   type OPMATRIX

     n_bf :: INT
     ! No of real spatial basis functions (i.e. AO's)

     n_mo :: INT, readonly  DEFAULT(0)
     ! No. of molecular orbitals - used for ELMO/ALO.

     restricted :: MAT{REAL}@
     ! Restricted spinorbital representation

     alpha :: MAT{REAL}@
     ! Alpha part of a DODS representation

     beta :: MAT{REAL}@
     ! Beta  part of a DODS representation

     general :: MAT{REAL}@
     ! General mixed alpha-beta matrix representation

     restricted_complex :: MAT{CPX}@
     ! Complex restricted representation

     alpha_complex :: MAT{CPX}@
     ! Complex alpha part of a DODS representation

     beta_complex :: MAT{CPX}@
     ! Complex beta  part of a DODS representation

     general_complex :: MAT{CPX}@
     ! Complex general mixed alpha-beta matrix representation

     triangle :: VEC{REAL}@
     ! Space saving for symmetric matrices: lower triangle only

     square :: VEC{REAL}@
     ! Space saving for hermitian matrices: lower triangle is real part, upper is imaginary

   end


!  =======================
!  Maps/associative arrays
!  =======================

   type MAP{INT,INT}

     n_keys :: INT  DEFAULT(0)
     ! The number of keys

     n_size :: INT  DEFAULT(0)
     ! The size of the keys and values arrays.

     reverse_search :: BIN  DEFAULT(FALSE)
     ! If TRUE, the search for values is performed from the largest
     ! key to the smallest.

     keys :: VEC{INT}@
     ! The array of keys.

     values :: VEC{INT}@
     ! The array of values.

   end

   type MAP{INT,STR}

     n_keys :: INT  DEFAULT(0)
     ! The number of keys

     n_size :: INT  DEFAULT(0)
     ! The size of the keys and values arrays.

     reverse_search :: BIN  DEFAULT(FALSE)
     ! If TRUE, the search for values is performed from the largest
     ! key to the smallest.

     keys :: VEC{INT}@
     ! The array of keys.

     values :: VEC{STR}@
     ! The array of values.

   end

   type MAP{STR,INT}

     n_keys :: INT  DEFAULT(0)
     ! The number of keys

     n_size :: INT  DEFAULT(0)
     ! The size of the keys and values arrays.

     reverse_search :: BIN  DEFAULT(FALSE)
     ! If TRUE, the search for values is performed from the largest
     ! key to the smallest.

     keys :: VEC{STR}@
     ! The array of keys.

     values :: VEC{INT}@
     ! The array of values.

   end

   type MAP{VEC{INT},VEC{INT}}

     n_keys :: INT  DEFAULT(0)
     ! The number of keys

     n_size :: INT  DEFAULT(0)
     ! The size of the keys and values arrays.

     reverse_search :: BIN  DEFAULT(FALSE)
     ! If TRUE, the search for values is performed from the largest
     ! key to the smallest.

     keys :: MAT{INT}@
     ! The array of keys, stored contigously by columns.

     values :: MAT{INT}@
     ! The array of values.

   end


!  =====================
!  System-function types
!  =====================

   type TIME

     start_time5 :: VEC{INT}(5)  DEFAULT(0)
     ! Contains real start time, in Julian day,h,m,s,ms

     stop_time5 :: VEC{INT}(5)  DEFAULT(0)
     ! Contains real stop time, in Julian day,h,m,s,ms

     cpu_start_time :: REAL  DEFAULT(ZERO)
     ! Contains CPU start time, in seconds

     cpu_stop_time :: REAL  DEFAULT(ZERO)
     ! Contains CPU stop time, in seconds

   end

   type PARALLEL

     is_parallel :: BIN  DEFAULT(FALSE)
     ! Whether we are doing a parallel job, or not.

     do_parallel_lock :: STR  DEFAULT(" ")
     ! This is set to the name of the routine which calls the parallel
     ! do loop.  Only the routine with the same name may unlock the
     ! parallel loop. This implementation assumes that all routines
     ! with parallel do loops have distinct names (append with the
     ! module name, if not; or use a unique ID).  Further, recursive
     ! routines cannot have parallel do loops.

     master_rank :: INT  DEFAULT(0)
     ! The rank of the master processor. It can be useful to change
     ! this, since only the master processor is allowed to so IO.

     processor_rank :: INT  DEFAULT(0)
     ! The rank number of the this current processor

     n_processors :: INT  DEFAULT(1)
     ! The number of processors

     p_loop_lbound :: INT  DEFAULT(1)
     ! The minimum of the (shared) parallel loop index.

     p_loop_ubound :: INT  DEFAULT(0)
     ! The maximum of the (shared) parallel loop index.

     p_loop_index :: INT  DEFAULT(0)
     ! The actual index of the (shared) parallel loop.

     p_loop_list :: VEC{INT}@  
     ! A list of sorted indices so that parallel work can be
     ! distributed in an user-determined order.

#ifdef MPI
     mpi_comm :: INT  DEFAULT(0)
     ! Communicator for all MPI routines.

     mpi_error :: INT  DEFAULT(0)
     ! MPI error return code

     mpi_status :: VEC{INT}(MPI_STATUS_SIZE)
     ! Status array for MPI routines.

     mpi_request :: INT  DEFAULT(0)
     ! MPI request parameter for asynchornous routines.

     max_n_skip_proc :: INT DEFAULT(0)
     ! maximum number of processors that can be skipped when assigning a
     ! processor grid.

     blacs_2d_context :: VEC{INT}(50)
     ! BLACS internal descriptor.

     proc_grid_nrow :: INT DEFAULT(0)
     ! Number of processors in a row of the processor grid
     ! nprows * npcols <= n_processors

     proc_grid_ncol :: INT DEFAULT(0)
     ! Number of processors in a column of the processor grid

     proc_grid_myrow :: INT DEFAULT(0)
     ! This processor's row of the processor grid

     proc_grid_mycol :: INT DEFAULT(0)
     ! This processor's column of the processor grid
#endif

   end

   type TEST_PARALLEL

   end

   type SYSTEM

     ! ===================
     ! Errors and warnings
     ! ===================

     error_status :: INT  DEFAULT(0)
     ! Set non-zero on error.

     warnings_issued :: BIN  DEFAULT(FALSE)
     ! Set TRUE if warings were issued through the system

     stderr_unit :: INT  DEFAULT(TEXTFILE_STDERR_UNIT)
     ! The file unit number for error messages.

     stdout_unit :: INT  DEFAULT(TEXTFILE_STDOUT_UNIT)
     ! The main output file unit number.

     ! ==============
     ! Output control
     ! ==============

     low_verbosity :: BIN  DEFAULT(FALSE)
     ! Whether low output verbosity is desired

     keyword_echo :: BIN  DEFAULT(SYSTEM_KEYWORD_ECHO)
     ! Whether to echo use-input keywords

     io_file :: TEXTFILE*
     ! Last I/O file used

     known_keywords :: VEC{STR}@
     ! List of known keywords in the current case statement, if
     ! applicable This allows a nice error message to be returned
     ! saying what the allowed options in the case statement were.

     ! ==========================================================
     ! Parallel processor system options, inherited from PARALLEL
     ! ==========================================================

     is_parallel :: BIN  DEFAULT(FALSE)
     ! Whether we are doing a parallel job, or not.

     parallel_IO_allowed :: BIN  DEFAULT(FALSE)
     ! Determines whether IO is allowed for all processors, or only
     ! the master. Default false.
     
     do_parallel_lock :: STR  DEFAULT(" ")
     ! This is set to the name of the routine which calls the parallel
     ! do loop.  Only the routine with the same name may unlock the
     ! parallel loop. This implementation assumes that all routines
     ! with parallel do loops have distinct names (append with the
     ! module name, if not; or use a unique ID).  Further, recursive
     ! routines cannot have parallel do loops.

     master_rank :: INT  DEFAULT(0)
     ! The rank of the master processor. It can be useful to change
     ! this, since

     processor_rank :: INT  DEFAULT(0)
     ! The rank number of the current processor

     n_processors :: INT  DEFAULT(1)
     ! The number of processors

     p_loop_lbound :: INT  DEFAULT(1)
     ! The minimum of the (shared) parallel loop index.

     p_loop_ubound :: INT  DEFAULT(0)
     ! The maximum of the (shared) parallel loop index.

     p_loop_index :: INT  DEFAULT(0)
     ! The actual index of the (shared) parallel loop.

     p_loop_list :: VEC{INT}@  
     ! A list of sorted indices so that work can be distributed in an
     ! asecending or descending manner.

#ifdef MPI
     mpi_comm :: INT  DEFAULT(0)
     ! Communicator for all MPI routines.

     mpi_error :: INT  DEFAULT(0)
     ! MPI error return code

     mpi_status :: VEC{INT}(MPI_STATUS_SIZE)
     ! Status field used for all MPI routines.
     
     mpi_request :: INT  DEFAULT(0)
     ! MPI request parameter for asynchornous routines.

#endif

   end

   type SYSTEM_COMMAND

     command :: STR  DEFAULT(" ")
     ! The command line to be executed

     wait :: BIN, readonly  DEFAULT(TRUE)
     ! Whether to execute synchronously or not.

     exit_status :: INT, readonly  DEFAULT(0)
     ! The system-dependent exit status of the executed command

     status :: INT, readonly  DEFAULT(0)
     ! On exit, assigned:
     !  0  if no errors,
     ! -1  if command can't be executed
     ! -2  if synchronous (wait=TRUE) command not possible

     message :: STR, readonly  DEFAULT(" ")
     ! ANy explanatory message

   end

   type COMMAND_LINE

     n_items :: INT, readonly  DEFAULT(0)
     ! Number of items on the command line.
     ! WARNING: do not confuse this with arguments.

     command :: STR  DEFAULT(" ")
     ! The command name i.e. program name

     command_arguments :: STR  DEFAULT(" ")
     ! The command arguments as a single string

     command_optarg :: VEC{STR}@ 
     ! The array of command options followed by command arguments

     item :: VEC{STR}@, readonly
     ! The complete list of command line items

     n_options :: INT, readonly  DEFAULT(0)
     ! Number of optional arguments

     option :: VEC{STR}@, readonly
     ! List of options e.g. "o" for "-o name"

     option_value :: VEC{STR}@, readonly
     ! List of option values e.g. "name" for "-o name"

     n_args :: INT, readonly  DEFAULT(0)
     ! Number of non-optional arguments.

     arg :: VEC{STR}@, readonly
     ! List of non-optional arguments.

   end


!  =====
!  Files
!  =====

   type FILE

     name :: STR  DEFAULT("unknown")
     ! The name of the file

     unit :: INT  DEFAULT(0)
     ! The unit number

     record :: INT  DEFAULT(1)
     ! The current record of the output

     io_status :: INT  DEFAULT(0)
     ! Set non-zero if there is an error condition

     action :: STR  DEFAULT("unknown")
     ! The type of action performed on this file

     file_status :: STR  DEFAULT("unknown")
     ! File status

   end

   type BUFFER

     item_start :: INT
     ! The position of the first character of the last item processed in
     ! the buffer string

     item_end :: INT
     ! The position of the last character of the last item processed in
     ! the buffer string

     item_index :: INT
     ! The item number of the last item processed in the buffer string

     n_items :: INT
     ! The total number of items in the string

     analyzed :: BIN  DEFAULT(FALSE)
     ! True, if the buffer string has been analyzed

     comment_chars :: STR  DEFAULT(BUFFER_COMMENT_CHARS)
     ! The comment character symbols (concatenated) to be used in the
     ! buffer string

     quote_chars :: STR  DEFAULT(BUFFER_QUOTE_CHARS)
     ! The quote character symbols (concatenated) to be used in the
     ! buffer string

     ignore_unmatched_quotes :: BIN  DEFAULT(FALSE)
     ! If TRUE then unmatched quote character on a sigle line are deemed an error.

     eliminate_specials :: BIN  DEFAULT(TRUE)
     ! If TRUE then non-ascii characters are set to blank

     replacement_list :: MAT{STR}@
     ! A list of replacement strings to apply to the buffer string, before
     ! analysis.

     string :: STR(len=BSTR_SIZE)  DEFAULT(" ")
     ! This is the actual buffer string

   end

   type TEXTFILE

     name :: STR  DEFAULT("unknown")
     ! The name of the file

     action :: STR  DEFAULT("unknown")
     ! The action status of the file, "read" or "write"

     unit :: INT  DEFAULT(0)
     ! The unit number

     record :: INT  DEFAULT(0)
     ! The current record of the output

     io_status :: INT  DEFAULT(0)
     ! Set non-zero if there is an error condition

     ignore_end_of_file :: BIN  DEFAULT(FALSE)
     ! Set to TRUE if the end of file is not to be regarded as an
     ! error.

     no_of_lines :: INT DEFAULT(-1)
     ! The number of lines in the file. This is only set if the
     ! end-of-file is encountered.

     using_fields :: BIN  DEFAULT(TEXTFILE_USE_FIELDS)
     ! If set TRUE, then items are output in set fields with certain
     ! field widths.  e.g. integers have withd int_width. If not TRUE
     ! then the minimum field width is used.

     n_fields_per_line :: INT  DEFAULT(TEXTFILE_N_FIELDS_PER_LINE)
     ! No. of fields per line (i.e. no of columns) to use for output

     spacing :: INT  DEFAULT(TEXTFILE_SPACING)
     ! Spacing between fields

     int_width :: INT  DEFAULT(TEXTFILE_INT_WIDTH)
     ! Width of an integer field

     real_width :: INT  DEFAULT(TEXTFILE_REAL_WIDTH)
     ! Width of a real field

     real_precision :: INT  DEFAULT(TEXTFILE_REAL_PRECISION)
     ! No. of decimal places to use for outputing a real variable

     real_style :: STR(len=2)  DEFAULT(TEXTFILE_REAL_STYLE)
     ! Fortran style character for a real variable

     margin_width :: INT  DEFAULT(TEXTFILE_MARGIN_WIDTH)
     ! Margin width

     using_array_labels :: BIN  DEFAULT(TEXTFILE_USE_ARRAY_LABELS)
     ! Whether to use column and row labels on vectors and matrices

     default_units :: STR  DEFAULT(" ")
     ! Each REAL number is assumed to have "default_units", and are converted
     ! into generic (internal) units, usually A.U.

     comment_chars :: STR  DEFAULT(TEXTFILE_COMMENT_CHARS)
     ! The comment character symbols (concatenated) to be used in the textfile

     quote_chars :: STR  DEFAULT(TEXTFILE_QUOTE_CHARS)
     ! The quote character symbols (concatenated) to be used in the textfile

     list_delimiter :: STR  DEFAULT(TEXTFILE_LIST_DELIMITER)
     ! The two list delimiters used to open and close variable length
     ! lists or arrays.

     ignore_unmatched_quotes :: BIN  DEFAULT(FALSE)
     ! If TRUE then unmatched quote character on a sigle line are deemed an error.

     eliminate_specials :: BIN  DEFAULT(TRUE)
     ! If TRUE then non-ascii characters are set to blank

     replacement_list :: MAT{STR}@
     ! A list of strings and their replacements, to be applied when every line is
     ! inputted, if required.

     buffer :: BUFFER
     ! The output buffer which holds one line of output to be flushed
     ! i.e. written to the output file

     internal :: VEC{STR}@
     ! Used to keep a record of of the entire file, internally

     saved :: TEXTFILE* DEFAULT_NULL
     ! Used to keep a record of a previous file, say for input redirect

   end

   type DATAFILE
      type(sbf_File) sbf
   end type

   type ARCHIVE

     root_name :: STR  DEFAULT("unknown")
     ! Archive root name (usually, the name of the job)

     name :: STR  DEFAULT("unknown")
     ! Archive name (usually, the name of the entity in the archive)

     genre :: STR  DEFAULT(" ")
     ! Archive basis genre for opmatrix objects, or a qualifier for name

     format :: STR   DEFAULT(" ")
     ! Archive format (blank for binary)

     use_all_commas :: BIN   DEFAULT(FALSE)
     ! Whether to use all commas in the archive name

     Afile :: TEXTFILE*  DEFAULT_NULL
     ! ASCII (text) file part

     Bfile :: FILE@
     ! Binary file part

   end

   type CIF

     file_name :: STR  DEFAULT(" ")
     ! The name of the CIF file to open

     is_mmCIF :: BIN  DEFAULT(FALSE)
     ! Set whether to use mmCIF input conventions

     use_CIF2 :: BIN  DEFAULT(FALSE)
     ! Set whether to use CIF2 output conventions.
     ! In Tonto, CIF2 means cartesian.

     use_fragments :: BIN  DEFAULT(FALSE)
     ! Set whether to make fragments to split protein up.

     file :: TEXTFILE* DEFAULT_NULL
     ! The actual CIF file to be processed

     data_block_name :: STR  DEFAULT(" ")
     ! The name of the data block

     start_of_data :: INT  DEFAULT(1)
     ! The starting line of the data block

     end_of_data :: INT  DEFAULT(0)
     ! The end line of the data block

     data_block_found :: BIN  DEFAULT(FALSE)
     ! Set TRUE if a data block has been sucessfully found

     BH_bond_length :: REAL  DEFAULT(-CIF_BH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any BH bonds in the CIF file are set to this

     CH_bond_length :: REAL  DEFAULT(-CIF_CH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any CH bonds in the CIF file are set to this

     NH_bond_length :: REAL  DEFAULT(-CIF_NH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any NH bonds in the CIF file are set to this

     OH_bond_length :: REAL  DEFAULT(-CIF_OH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any OH bonds in the CIF file are set to this

     U_iso_is_B_iso :: BIN  DEFAULT(FALSE)
     ! If TRUE, then any U_iso values in the CIF file are interpreted as B_iso
     ! values. This is a hack that should not be used except when the CIF file is
     ! hand made using B_iso values.

     U_is_B :: BIN  DEFAULT(FALSE)
     ! If TRUE, then any U values (i.e. ADP's) in the CIF file are interpreted as B
     ! values. This is a hack that should not be used except when the CIF file is
     ! hand made using B_iso values.

     U_is_beta :: BIN  DEFAULT(FALSE)
     ! If TRUE, then any U values (i.e. ADP's) in the CIF file are interpreted as
     ! beta values. This is a hack that should not be used except when the CIF
     ! file is hand made using B_iso values.

     GC_format :: STR  DEFAULT(CIF_GC_FORMAT)
     ! This may be "g" for the dimensionless Gram-Charlier anharmonic
     ! constants, OR "u"  i.e. the constants are dimensioned in
     ! Angstrom^n, where n=3,4 is the order of the constants. This is
     ! like the second order cartesian ADPs, but is non-standard,
     ! see Trueblood (1996) Acta Cryst A 52 p. 770-81 (34)-(37), but
     ! in that paper "h" is our k/2\pi.

     GC3_scale_factor :: REAL  DEFAULT(-ONE)
     ! The Gram-Charlier 3rd order constants are scaled by this factor.

     GC3_label :: STR  DEFAULT(CIF_GC3_LABEL)
     ! Label used for the 3rd order anharmonic Gram-Charlier constants

     GC4_scale_factor :: REAL  DEFAULT(-ONE)
     ! The Gram-Charlier 4th order constants are scaled by this factor.

     GC4_label :: STR  DEFAULT(CIF_GC4_LABEL)
     ! Label used for the 3rd order anharmonic Gram-Charlier constants

   end


!  ============
!  Table output
!  ============

   type TABLE_COLUMN

     heading :: STR  DEFAULT(" ")
     ! Column heading

     subheading :: STR  DEFAULT(" ")
     ! Column subheading

     sb3heading :: STR  DEFAULT(" ")
     ! Column sub3 heading

     width :: INT  DEFAULT(TABLE_COLUMN_WIDTH)
     ! Column width

     auto_width :: BIN  DEFAULT(TRUE)
     ! Set table width automatically from maximum column element,
     ! including any headings or subheadings.

     width_set :: BIN  DEFAULT(FALSE)
     ! Was the width set?

     item_width :: INT  DEFAULT(TABLE_COLUMN_WIDTH)
     ! Either max real item width, or list item width

     item_width_set :: BIN  DEFAULT(FALSE)
     ! Was the item width set?

     real_precision :: INT  DEFAULT(TABLE_COLUMN_REAL_PRECISION)
     ! Real precision

     max_cp :: INT  DEFAULT(TABLE_COLUMN_REAL_PRECISION)
     ! Maximum closing brace position when outputting real numbers
     ! with errors as in 123.456(7) <-- posiion of last parens ")".
     ! Used by default, when e_under_r is FALSE.

     e_under_r :: BIN  DEFAULT(FALSE)
     ! If set TRUE, the error is printed underneath the real number.
     ! Normally the error is placed in parens at the end, IUCr style.

     two_digit_error :: BIN  DEFAULT(FALSE)
     ! Whether to always use two digit errors for extra accuracy on
     ! errors - useful for testing and checking.

     column_spacing :: INT  DEFAULT(TABLE_COLUMN_SPACING)
     ! Column spacing

     list_item_spacing :: INT  DEFAULT(TABLE_COLUMN_SPACING)
     ! Column spacing between *list* items

     spacer :: STR  DEFAULT(TABLE_COLUMN_SPACER)
     ! Column spacer, applied *before* the column; blanks means
     ! to use no spacer.

     center :: BIN  DEFAULT(TABLE_COLUMN_CENTER)
     ! Column centering

     left_justify :: BIN  DEFAULT(TABLE_COLUMN_LEFT_JUSTIFY)
     ! Column left-justify

     list_as_column :: BIN  DEFAULT(TABLE_COLUMN_LIST_AS_COLUMN)
     ! Put a list as columns, one-per-line
     ! NOTE: this can only be set when the list is the last column.

     values_created :: BIN  DEFAULT(FALSE)
     ! Set true if the column was created

     b_values :: VEC{BIN}@
     ! Binary column values

     i_values :: VEC{INT}@
     ! Integer column values

     r_values :: VEC{REAL}@
     ! Real column values

     e_values :: VEC{REAL}@
     ! Real column *error* values

     s_values :: VEC{STR}@
     ! String column values

     iv_values :: VEC{EVEC{INT}}@
     ! Integer list column values

     sv_values :: VEC{EVEC{STR}}@
     ! String list column values

   end

   array type VEC{TABLE_COLUMN}

     ! A 1-D array of TABLE_COLUMN objects

   end


!  ==================================
!  Polynomials and surface expansions
!  ==================================

   type TERM_1D

     descriptor :: STR, readonly   DEFAULT(" ")
     ! The character code for the term e.g. q(3)^2 or tpt(5)[-2.0,0.3].
     ! "q" or "tpt" is the "variable type", "3" and "5" is the "degree
     ! of freedom" or index of this variable, and "2" and "-2,0,0.3"
     ! are parameters associated with this monomial (the "2" is of
     ! course the power).

     d1_codes :: MAP{STR,INT}@
     ! Stores the 1D variable types and their associated integer
     ! "varcode". Always pointer assigned.

     analyzed :: BIN, readonly   DEFAULT(FALSE)
     ! Set TRUE when the monomial is analyzed

     ! =================================
     ! Below are produced after analysis
     ! =================================

     variable :: STR, readonly   DEFAULT(" ")
     ! The variable type associated with the monomial

     variable_code :: INT, readonly   DEFAULT(0)
     ! The variable code associated with the monomial: it is derived
     ! from d1_codes

     dof :: INT, readonly   DEFAULT(0)
     ! The degree of freedom associated with the variable

     parameters :: VEC{REAL}@, readonly  
     ! The values of any parameters associated with the variable.
     ! You have to know the convention of what each parameter means.

   end

   array type VEC{TERM_1D}

     ! A 1-D array of TERM_1D objects

   end

   type TERM

     coefficient :: REAL, readonly   DEFAULT(ZERO)
     ! The coeficient associated with the term

     descriptor :: STR, readonly   DEFAULT(" ")
     ! The character code associated with this term e.g.
     ! q(3)^2.q(1)^4. This is the way a term is inputted.

     d1_codes :: MAP{STR,INT}@
     ! Stores the 1D variable types to be recognized and their
     ! associated "varcode" indices in a map table. Pointer assigned.

     analyzed :: BIN, readonly   DEFAULT(FALSE)
     ! Set TRUE when the term is analyzed

     ! =================================
     ! Below are produced after analysis
     ! =================================

     n_monomials :: INT   DEFAULT(0)
     ! The number of 1D monomials in the term

     monomial :: VEC{TERM_1D}@
     ! The array of 1D monomials into which the descriptor is decoded

     has_any_var :: VEC{BIN}@
     ! Set TRUE if the variable with the given "varcode" is present as
     ! a 1D term, at any part position

     has_any_dof :: VEC{BIN}@
     ! Set TRUE if the dof with the given "dof" index is present as
     ! a 1D term, at any part position

   end

   array type VEC{TERM}

     ! A 1-D array of TERM objects

   end

   type POLYNOMIAL

     name :: STR, readonly   DEFAULT(" ")
     ! The name of this entity

     d1_codes :: MAP{STR,INT}@
     ! Stores the recognised 1D variable types and their associated
     ! indices in a map table.

     series_expansion :: VEC{TERM}@, readonly
     ! The polynomial provided as input by the user

   end


!  =============
!  Interpolation
!  =============

   type INTERPOLATOR

     interpolation_method :: STR, readonly  DEFAULT(INTERPOLATOR_INTERPOLATION_METHOD)
     ! The interpolation method used, usually "linear". Also allowed
     ! is "cubic_spline".

     interpolation_is_spline :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if it is a spline interpolation

     range_mapping :: STR, readonly  DEFAULT(INTERPOLATOR_RANGE_MAPPING)
     ! How the function values are treated before being stored as
     ! interpolation table data_values, i.e. "none" or "logarithmic"

     range_is_logarithmic :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if range has ben logged

     domain_mapping :: STR, readonly  DEFAULT(INTERPOLATOR_DOMAIN_MAPPING)
     ! How the data_points are treated before evaluation by the
     ! interpolation function, e.g. "none", "sqrt", "sqrt(x/(1-x))*scale".
     ! NOTE: when obtaining the tabulated values it is the users
     ! responsibility to use the inverse domain mapping function to
     ! obtain the actual table value x.

     domain_scale_factor :: REAL, readonly  DEFAULT(ZERO)
     ! A factor which is used to rescale the domain mapping function

     domain_is_sqrt :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if domain has been sqrted

     domain_is_sqrt_x1x :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if domain maps to sqrt(x/(1-x))

     table_origin :: REAL  DEFAULT(INTERPOLATOR_TABLE_ORIGIN)
     ! The origin of the table use i.e. where the table starts. Used for setting
     ! up even spaced data.

     table_length :: REAL  DEFAULT(INTERPOLATOR_TABLE_LENGTH)
     ! The length of the table use; it starts from the origin. Used for setting up
     ! even spaced data.

     table_spacing :: REAL  DEFAULT(INTERPOLATOR_TABLE_SPACING)
     ! The spacing between data points, if using an even spaced grid.
     ! (this is the case if spacing in non-zero)

     table_eps :: REAL  DEFAULT(INTERPOLATOR_TABLE_EPS)
     ! If there are values smaller than this in the interpolation table, they are
     ! set to zero. The interpolation table may be reduced in size.

     n_data :: INT  DEFAULT(0)
     ! The number of "data_points" and "values" in the table.

     data_point :: VEC{REAL}@
     ! The list of data points, from smallest to largest.

     data_value :: VEC{REAL}@
     ! The list of values corresponding to each data value.

     finalized :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the object is ready for use

     y2 :: VEC{REAL}@
     ! The tabulated values of the second derivatives at the data_point's. This is
     ! used only for cubic spline interpolation.

     y1_initial :: REAL  DEFAULT(INTERPOLATOR_Y1_INITIAL)
     ! The first derivative at the initial data_point to use, when doing cubic
     ! spline interpolation.

     y1_final :: REAL  DEFAULT(INTERPOLATOR_Y1_FINAL)
     ! The first derivative at the final data_point to use, when doing cubic
     ! spline interpolation.

   end

   array type VEC{INTERPOLATOR}

     ! A 1-D array of INTERPOLATOR objects

   end


!  ==========
!  Quadrature
!  ==========

   type RYS

     n_roots :: INT
     ! No. of rys roots

     weight :: VEC{REAL}@
     ! The Rys weights

     root :: VEC{REAL}@
     ! The Rys roots

   end

   type ADAPTIVE_QUADRATURE

     algorithm :: STR  DEFAULT(" ")
     ! Identifier for the kind of quadrature algorithm

     accuracy :: REAL  DEFAULT(QUADRATURE_ACCURACY)
     ! The accuracy required for adapative quadratures

     n_points :: INT  DEFAULT(0)
     ! No. of quadrature points. For adaptive quadrature it is set to thye number
     ! of function eveluations.

     lower_limit :: REAL  DEFAULT(-ONE)
     ! Lower integration limit (if appropriate)

     upper_limit :: REAL  DEFAULT(ONE)
     ! Upper integration limit (if appropriate)

     point :: MAT{REAL}@
     ! The 3D quadrature points

     weight :: VEC{REAL}@
     ! The quadrature weight

     embedded_weight :: VEC{REAL}@
     ! The embedded set of quadrature weights==for embedded cubature.

   end

   type QUADRATURE

     kind :: STR  DEFAULT(" ")
     ! Identifier for the kind of quadrature

     n_points :: INT  DEFAULT(0)
     ! No of quadrature points, or the order of the quadrature

     fold_weight_function_in :: BIN  DEFAULT(TRUE)
     ! The quadrature of I = Int f(x) dx is I = Sum_i f(x_i) w_i, i.e. no weight
     ! function appears in the integrand; it has been folded into w_i.  If this
     ! switch is set FALSE then f(x) = F(x) W(x) and the quadrature is defined as
     ! I = Int F(x) W(x) dx = Sum_i F(x_i) W_i i.e. the function F(x) to be
     ! quadrated does *not* have the weight W(x) folded in, as does f(x). The
     ! weights are related by w_i = W(x_i) W_i. Normally the program calculated
     ! W_i but it delivers w_i.

     lower_limit :: REAL  DEFAULT(-ONE)
     ! Lower integration limit (if appropriate)

     upper_limit :: REAL  DEFAULT(ONE)
     ! Upper integration limit (if appropriate)

     gauss_laguerre_alpha :: REAL  DEFAULT(ONE)
     ! Gauss-Laguerre alpha parameters

     gauss_jacobi_alpha :: REAL  DEFAULT(ONE)
     ! Gauss-Jacobi alpha parameter

     gauss_jacobi_beta :: REAL  DEFAULT(ONE)
     ! Gauss-Jacobi alpha parameter

     eps :: REAL  DEFAULT(QUADRATURE_EPS)
     ! The relative accuracy of the roots when they are polished

     maxit :: INT  DEFAULT(QUADRATURE_MAXIT)
     ! The maximum iterations to work solve for the roots.

     point :: VEC{REAL}@
     ! The quadrature point i.e. root of the appropriate orthogonal polynomial

     weight :: VEC{REAL}@
     ! The quadrature weight

     finalized :: BIN  DEFAULT(FALSE)
     ! Set TRUE when all initialisations are completed.

   end

   array type VEC{QUADRATURE}

     ! A 1-D array of QUADRATURE objects

   end

   type LEBEDEV

     n_points :: INT  DEFAULT(0)
     ! No of quadrature points

     l :: INT  DEFAULT(0)
     ! The angular momentum that this quadrature will integrate up to.

     point :: MAT{REAL}@
     ! Coordinates of the quadrature points

     weight :: VEC{REAL}@
     ! The quadrature weights (normalized to unity)

     n_points_per_shell :: VEC{INT}@
     ! No of ppoints per shell. This is used to save work when calculating the
     ! atomic grids on each shell.

     n :: INT, private DEFAULT(0)
     ! Private counter to keep track of how many points have been added into the
     ! quadrature grid.

     s :: INT, private DEFAULT(0)
     ! Private counter to keep track of how many shells there are in the
     ! quadrature grid.

   end


!  ====================
!  DIIS & extrapolation
!  ====================

   type AITKEN

     iteration :: INT  DEFAULT(0)
     ! The iteration count for the AITKEN extrapolation.

     param :: VEC{EVEC{REAL}}@
     ! List of stored parameter vectors

     error_length :: REAL  DEFAULT(1000d0)
     ! The length of the DIIS error vector

   end

   type DIIS

     iteration :: INT  DEFAULT(0)
     ! The iteration count for the DIIS procedure. When it equals 0,
     ! the "initial guess" parameters param(0)[:] are specified.

     use_errors :: BIN  DEFAULT(TRUE)
     ! Set TRUE if the extrapolation procedure supplies its own error
     ! vectors. If a corresponding error vector is supplied, the first
     ! nontrivial DIIS extrapolation occurs at iteration 2.  If no
     ! error vector is supplied, the error at iteration (i) is defined
     ! as error(i)[:] = param(i+1)[:] - param(i)[:] and the dimension
     ! of the DIIS problem is one less than the number of parameter
     ! vectors stored, so extrapolation occurs at actual iteration 3.

     start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
     ! The iteration of the *parent iterative cycle* when DIIS is
     ! supposed to start e.g. 4 if it is supposed to start on the 4th
     ! iteration of the SCF cycle (or, whatever iterative method you
     ! are trying to extrapolate).

     save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
     ! The iteration of the *parent iterative cycle* when the DIIS
     ! is supposed to start saving vectors though not necessarily
     ! start extrapolating. This must be less than or equal to the
     ! .start_iteration. The "actual iterations" begin at this number.

     keep :: INT  DEFAULT(DIIS_KEEP)
     ! No. of DIIS vectors to keep for use in extrapolation

     kept :: INT  DEFAULT(0)
     ! The actual number of DIIS vectors actually kept.

     oldest :: VEC{INT}@
     ! A list of the indices of the oldest vectors stored in the param
     ! vector. The index of oldest vector is stored as the *last*
     ! entry in this list, .oldest(.kept) i.e. this is a first-in
     ! first-out (FIFO) list.

     iter_4 :: VEC{INT}@
     ! A list of the actual *parent iteration indices* corresponding
     ! to the saved .param list. Note that in SCF, the DIIS operates
     ! before the SCF iteration is cycled, i.e. the DIIS iteration
     ! index may be one larger that the SCF iteration index.

     itor_4 :: VEC{INT}@
     ! The previous iteration's iter_4, required due to index lag.

     new :: INT  DEFAULT(0)
     ! The index of the new (current) parameter vector in the list of
     ! saved vectors. It is equal to .iteration only if
     ! .iteration<=.keep; otherwise it is in the range [1,.keep] and
     ! it corresponds to either the parameter vector with the "worst"
     ! error or the "oldest" vector.

     error_length :: REAL  DEFAULT(1000d0)
     ! The length of the DIIS error vector

     convergence_tolerance :: REAL  DEFAULT(DIIS_CONVERGENCE_TOLERANCE)
     ! This tolerance specifies when the length of the error vector is
     ! such that the DIIS procedure is regarded as converged.

     start_tolerance :: REAL  DEFAULT(DIIS_START_TOLERANCE)
     ! This tolerance is specifies the length of the error vector
     ! below which the DIIS procedure is supposed to start. It should
     ! override the .start_iteration.

     replacement_method :: STR  DEFAULT(DIIS_REPLACEMENT_METHOD)
     ! Specifies the method to be used when replacing the DIIS
     ! vectors, in the case when the DIIS space becomes saturated. The
     ! choices are "worst" item, or "oldest" item.

     param :: VEC{EVEC{REAL}}@
     ! List of stored parameter vectors

     error :: VEC{EVEC{REAL}}@
     ! List of stored error vectors

     lhs :: MAT{REAL}@
     ! The LHS of the DIIS equations

     rhs :: VEC{REAL}@
     ! The RHS of the DIIS equations

     coeff :: VEC{REAL}@
     ! The DIIS coefficicents.

   end

   array type VEC{DIIS}

     ! A 1-D array of DIIS objects

   end

!   type FOCK_DIIS
!
!     genre :: STR  DEFAULT(DIIS_GENRE)
!     ! The kind of DIIS procedure to use
!
!     iteration :: INT  DEFAULT(0)
!     ! The iteration count for the DIIS procedure. It gets incremented every time
!     ! one of the extrapolators/interpolators are called.
!
!     start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
!     ! The iteration when the DIIS procedure is supposed to start accelerating the
!     ! requested object. The DIIS acceleration procedure works on the saved vectors,
!     ! and the procedure can start saving vectors before starting the acceleration
!     ! procedure.
!
!     save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
!     ! The iteration when the DIIS object starts saving vectors. It must be equal
!     ! or smaller than the start_iteration. The previously saved vectors are used
!     ! in the acceleration procedure.
!
!     keep :: INT  DEFAULT(DIIS_KEEP)
!     ! No. of DIIS vectors to keep for use in extrapolation
!
!     kept :: INT  DEFAULT(0)
!     ! The actual number of DIIS vectors kept.
!
!     oldest :: VEC{INT}*  DEFAULT_NULL
!     ! A list of the indices of the oldest vectors.
!
!     new :: INT  DEFAULT(0)
!     ! The integer identifier for the new (current) parameter vector, usually the
!     ! Fock matrix.  This is equal to .iteration only if .iteration<=.keep;
!     ! otherwise it is an integer in the range [1,.keep] which corresponds to the
!     ! parameter vector with the worst error (DIIS) or the oldest vector (EDIIS).
!     ! In this way, the worst/oldest parameter and error vectors are pruned.
!
!     error_length :: REAL  DEFAULT(ZERO)
!     ! The length of the DIIS error vector
!
!     convergence_tolerance :: REAL  DEFAULT(DIIS_CONVERGENCE_TOLERANCE)
!     ! This tolerance specifies when the DIIS/EDIIS procedure is regarded to be
!     ! converged.
!
!     start_tolerance :: REAL  DEFAULT(DIIS_START_TOLERANCE)
!     ! In the case when the method is "ediis+diis", this tolerance specifies when
!     ! the EDIIS procedure finishes and when the DIIS procedure begins.
!
!     encore_iterations :: INT  DEFAULT(DIIS_ENCORE_ITERATIONS)
!     ! In the case when the method is "ediis+diis", this tolerance specifies how
!     ! many EDIIS iterations are to be performed again, assuming that EDIIS was
!     ! already performed before, and DIIS has started to diverge.
!
!     stage :: INT   DEFAULT(0)
!     ! The stage of the "ediis+diis" calculation. If 0, we have not yet started
!     ! the first DIIS. If 1, we have finished EDIIS and started DIIS. If 2, we
!     ! have reached stage 1, but we need encore EDIIS iterations.
!
!     encore :: INT   DEFAULT(0)
!     ! The iteration counter for encore iterations.
!
!     replacement_method :: STR  DEFAULT(DIIS_REPLACEMENT_METHOD)
!     ! This specifies the method to be used when replacing the DIIS vectors, in
!     ! the case when the DIIS space becomes saturated. The choices are "worst"
!     ! item, or "oldest" item.
!
!     archive :: ARCHIVE
!     ! Archive used to store the DIIS parameter and error vectors
!
!     par_tag :: STR  DEFAULT("fock_matrix")
!     ! A string tag used to identify the parameter vectors stored on disk, which
!     ! are used to construct the next DIIS approximation.
!
!     err_tag :: STR  DEFAULT("pulay_error")
!     ! A string tag used to identify the error vectors stored on disk, which
!     ! are used to construct the next DIIS approximation.
!
!     lhs_tag :: STR  DEFAULT("diis_lhs")
!     ! A string tag used to identify the DIIS LHS matrix stored on disk.
!
!     lhs_tol :: REAL  DEFAULT(TOL(10))
!     ! Tolernace for solving the non-linear DDIIS  equations iteratively.
!
!     S :: MAT{REAL}*  DEFAULT_NULL
!     ! The overlap matrix. Used to calculate commutators.
!
!     F :: OPMATRIX@
!     ! The current fock matrix. It gets stored on disk, and then extrapolated or
!     ! interpolated by the DIIS routines.
!
!     F_tag :: STR  DEFAULT("fock_matrix")
!     ! A string tag used to identify the Fock matrices stored on disk, which
!     ! are used to construct the next DIIS approximation.
!
!     D :: OPMATRIX@
!     ! The density matrix corresponding to the current fock matrix. It gets stored
!     ! on disk and is used to calculate the commutators.
!
!     D_tag :: STR  DEFAULT("density_matrix")
!     ! A string tag used to identify the Density matrices stored on disk, which
!     ! are used to construct the next DIIS approximation.
!
!     J :: OPMATRIX@
!     ! The coulomb matrix corresponding to the current fock matrix. It gets stored
!     ! on disk and is used to calculate commutators in the UHF case only.
!
!     J_tag :: STR  DEFAULT("coulomb_matrix")
!     ! A string tag used to identify the Coulomb J matrices stored on disk, which
!     ! are used to construct the next DIIS approximation in the UHF case.
!
!     energy :: VEC{REAL}*   DEFAULT_NULL
!     ! The current SCF electronic energy (or energies, in the UHF case), used in
!     ! energy DIIS.
!
!     e_tag :: STR  DEFAULT("energy")
!     ! A string tag used to identify the energy stored on disk, which
!     ! are used to construct the next DIIS approximation.
!
!     force_convexity :: BIN  DEFAULT(DIIS_FORCE_CONVEXITY)
!     ! If TRUE the diis coefficients are forced to be positive to ensure that any
!     ! extrapolated density matrix is a convex linear combination. This is TRUE by
!     ! default for the EDIIS method.
!
!     micro_iteration_method :: STR   DEFAULT(DIIS_MICRO_ITERATION_METHOD)
!     ! The name of the method used to solve the DDIIS equations iteratively.
!     ! These are called DDIIS micro iterations.
!
!     micro_starting_guess :: STR   DEFAULT(DIIS_MICRO_STARTING_GUESS)
!     ! The starting guess to use for the solving the DDIIS equations iteratively.
!     ! They can be started with the "last" density or "diis" coefficients.
!
!     micro_convergence_tol :: REAL  DEFAULT(DIIS_MICRO_CONVERGENCE_TOL)
!     ! The tolerace for solving the non-linear DDIIS  equations iteratively.
!
!     micro_max_iterations :: INT  DEFAULT(DIIS_MICRO_MAX_ITERATIONS)
!     ! This is the maximum number of micro iterations allowed when solving the
!     ! non-linear DDIIS equations by simple relaxation.
!
!     micro_damp_factor :: REAL  DEFAULT(DIIS_MICRO_DAMP_FACTOR)
!     ! The damp factor to use when solving the non-linear DDIIS equations by
!     ! simple relaxation.
!
!   end

   type L_BFGS

     iteration :: INT  DEFAULT(0)
     ! The iteration count for the DIIS procedure. When it equals 0,
     ! the "initial guess" parameters param(0)[:] are specified.

     start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
     ! The iteration of the *parent iterative cycle* when DIIS is
     ! supposed to start e.g. 4 if it is supposed to start on the 4th
     ! iteration of the SCF cycle (or, whatever iterative method you
     ! are trying to extrapolate).

     save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
     ! The iteration of the *parent iterative cycle* when the DIIS
     ! is supposed to start saving vectors though not necessarily
     ! start extrapolating. This must be less than or equal to the
     ! .start_iteration. The "actual iterations" begin at this number.

     keep :: INT  DEFAULT(DIIS_KEEP)
     ! No. of parameters/gradient to keep for use in extrapolation

     grd_norm :: REAL  DEFAULT(1000d0)
     ! The length of the latest gradient vector

     grd_norm_a :: REAL  DEFAULT(1000d0)
     ! The length of the latest alpha gradient vector

     grd_norm_b :: REAL  DEFAULT(1000d0)
     ! The length of the latest beta gradient vector

     convergence_tolerance :: REAL  DEFAULT(DIIS_CONVERGENCE_TOLERANCE)
     ! This tolerance specifies when the length of the error vector is
     ! such that the DIIS procedure is regarded as converged.

     start_tolerance :: REAL  DEFAULT(DIIS_START_TOLERANCE)
     ! This tolerance is specifies the length of the error vector
     ! below which the DIIS procedure is supposed to start. It should
     ! override the .start_iteration.

     par :: VEC{EVEC{REAL}}@
     ! List of stored parameter vectors

     par_a :: VEC{EVEC{REAL}}@
     ! List of stored alpha parameter vectors

     par_b :: VEC{EVEC{REAL}}@
     ! List of stored beta parameter vectors

     grd :: VEC{EVEC{REAL}}@
     ! List of stored gradient vectors

     grd_a :: VEC{EVEC{REAL}}@
     ! List of stored alpha gradient vectors

     grd_b :: VEC{EVEC{REAL}}@
     ! List of stored beta gradient vectors

   end


!  =========
!  Gaussians
!  =========

   type GAUSSIAN

     l :: INT, readonly  DEFAULT(0)
     ! l quantum number for the gaussian

     exponent :: REAL  DEFAULT(ZERO)
     ! Exponent for the gaussian

     position :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Position of the gaussian

     n_comp :: INT, readonly  DEFAULT(0)
     ! No. of cartesian components for the gaussian

     n_sph :: INT, readonly  DEFAULT(0)
     ! No. of spherical components for the gaussian shell

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian. For lookups.

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian. For lookups.

   end

   type GAUSSIAN2

     a :: GAUSSIAN
     ! Shell "a" of the pair

     b :: GAUSSIAN
     ! Shell "b" of the pair

   end

   type GAUSSIAN4

     a :: GAUSSIAN
     ! Shell "a" of the quartet

     b :: GAUSSIAN
     ! Shell "b" of the quartet

     c :: GAUSSIAN
     ! Shell "c" of the quartet

     d :: GAUSSIAN
     ! Shell "d" of the quartet

   end

   type RMS_INDICES

     xyz0 :: VEC{INT}@
     ! list of the indices where nx and ny and nz are zero

     yz0 :: VEC{INT}@
     ! list of the indices where ny and nz are zero (not including any above)

     xz0 :: VEC{INT}@
     ! list of the indices where nx and nz are zero (not including any above)

     xy0 :: VEC{INT}@
     ! list of the indices where nx and ny are zero (not including any above)

     z0 :: VEC{INT}@
     ! list of the indices where nz is zero (not including any above)

     y0 :: VEC{INT}@
     ! list of the indices where ny is zero (not including any above)

     x0 :: VEC{INT}@
     ! list of the indices where nx is zero (not including any above)

     n0 :: VEC{INT}@
     ! list of the indices where none of nx, ny, nz is zero (not including any above)

     a0 :: VEC{INT}@
     ! list of the indices where any  of nx, ny, nz is zero i.e. complement of n0

!    xy_rms :: VEC{EVEC{INT}}@
!    ! list of the repeated nx and ny indices for use in the reduced
!    ! multiplication scheme for indices which are non-zero

     xy_rms_n :: VEC{EVEC{INT}}@
     ! list of the repeated nx and ny indices for use in the reduced
     ! multiplication scheme for indices which are non-zero

!    xy_unique_n :: VEC{INT}@
!    ! list of the unique nx and ny indices for use in the reduced
!    ! multiplication scheme for indices which are non-zero

     xy_rms_a :: VEC{EVEC{INT}}@
     ! list of the repeated nx and ny indices for use in the reduced
     ! multiplication scheme where at least one index is zero

!    xy_unique_a :: VEC{INT}@
!    ! list of the unique nx and ny indices for use in the reduced
!    ! multiplication scheme where at least one index is zero

     yz0px :: VEC{INT}@
     ! px powers for the yz0 indices

     xz0py :: VEC{INT}@
     ! py powers for the xz0 indices

     xy0pz :: VEC{INT}@
     ! pz powers for the xz0 indices

     z0px :: VEC{INT}@
     ! px and py powers for the z0 indices

     z0py :: VEC{INT}@
     ! px and py powers for the z0 indices

     y0px :: VEC{INT}@
     ! px and pz powers for the y0 indices

     y0pz :: VEC{INT}@
     ! px and pz powers for the y0 indices

     x0py :: VEC{INT}@
     ! py and pz powers for the x0 indices

     x0pz :: VEC{INT}@
     ! py and pz powers for the x0 indices

     n1 :: VEC{INT}@
     ! Indices and non-zero powers for non-rms terms

     n1px :: VEC{INT}@
     ! Indices and non-zero powers for non-rms terms

     n1py :: VEC{INT}@
     ! Indices and non-zero powers for non-rms terms

     n1pz :: VEC{INT}@
     ! Indices and non-zero powers for non-rms terms

     n2 :: VEC{EVEC{INT}}@
     ! Indices and non-zero powers for rms terms

     n2px :: VEC{EVEC{INT}}@
     ! Indices and non-zero powers for rms terms

     n2py :: VEC{EVEC{INT}}@
     ! Indices and non-zero powers for rms terms

     n2pz :: VEC{EVEC{INT}}@
     ! Indices and non-zero powers for rms terms

   end

   array type MAT{RMS_INDICES}

     ! A 2-D array of RMS_INDICES objects

   end

   type RMS2_INDICES

   ! e :: VEC{INT}@
   ! ! list of the "e" indices for forming the esfs(e,f) integrals
   !
   ! f :: VEC{INT}@
   ! ! list of the "f" indices for forming the esfs(e,f) integrals
   !
   ! ex :: VEC{INT}@
   ! ! x power of the cartesian gaussian on the e side
   !
   ! ey :: VEC{INT}@
   ! ! y power of the cartesian gaussian on the e side
   !
   ! ez :: VEC{INT}@
   ! ! z power of the cartesian gaussian on the e side
   !
   ! fx :: VEC{INT}@
   ! ! x power of the cartesian gaussian on the f side
   !
   ! fy :: VEC{INT}@
   ! ! y power of the cartesian gaussian on the f side
   !
   ! fz :: VEC{INT}@
   ! ! z power of the cartesian gaussian on the f side
   !
   ! Ixy_is_1 :: VEC{INT}@
   ! ! No. of rms elements where Ix*Iy = 1
   !
   ! Ixy_is_x :: VEC{INT}@
   ! ! No. of rms elements where Ix*Iy = Ix
   !
   ! Ixy_is_y :: VEC{INT}@
   ! ! No. of rms elements where Ix*Iy = Iy
   !
   ! Ixy_is_p :: VEC{INT}@
   ! ! No. of rms elements for Ix*Iy

     ef :: VEC{INT}@
     ! List of linearised "e,f" indices for accessing the esfs(e,f) integrals

     efx :: VEC{INT}@
     ! List of linearised "ex,fx" indices for accessing the Ix(ex,fx) integrals

     efy :: VEC{INT}@
     ! List of linearised "ey,fy" indices for accessing the Iy(ey,fy) integrals

     efz :: VEC{INT}@
     ! List of linearised "ez,fz" indices for accessing the Iz(ez,fz) integrals

     no_Ixy_is_1 :: INT
     ! Number of terms where Ix*Iy is 1.

     no_Ixy_is_x :: INT
     ! Offset for terms where Ix*Iy = Ix .

     no_Ixy_is_y :: INT
     ! Offset for terms where Ix*Iy = Iy.

     do_Ixy_is_x :: VEC{BIN}@
     ! If TRUE, then we should set Ix*Iy = Ix

     do_Ixy_is_y :: VEC{BIN}@
     ! If TRUE, then we should set Ix*Iy = Iy

     do_Ixy :: VEC{BIN}@
     ! If TRUE, then we should set Ix*Iy

   end

   array type MAT{RMS2_INDICES}

     ! A 2-D array of RMS2_INDICES objects

   end

   array type MAT4{RMS2_INDICES}

     ! A 2-D array of RMS2_INDICES objects

   end

   type GAUSSIAN_DATA

     l_max :: INT
     ! The maximum l value for which the data is defined.

   end


!  =========================
!  Segmented gaussian shells
!  =========================

   type SHELL

     l :: INT, readonly  DEFAULT(0)
     ! (Maximum) l quantum number for the gaussian shell

     l_chr :: STR, readonly  DEFAULT(" ")
     ! The character symbol for the shell e.g. "s", "p", "L", "d" ...

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the components are spherical harmonics, else cartesian

     n_comp :: INT, readonly  DEFAULT(0)
     ! No. of cartesian components for the gaussian shell

     n_sph :: INT, readonly  DEFAULT(0)
     ! No. of spherical components for the gaussian shell

     n_bf :: INT, readonly  DEFAULT(0)
     ! No. of basis functions in the shell

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian in the shell. For lookups.

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian in the shell. For lookups.

     n_cc :: INT  DEFAULT(0)
     ! No. of contractions for the gaussian shell

     exponent :: VEC{REAL}* DEFAULT_NULL
     ! Exponent vector

     contraction :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector

     contraction_s :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for s functions in an L shell

     contraction_p :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for p functions in an L shell

   end

   array type VEC{SHELL}

     ! A 1-D array of SHELL objects

   end

   type SHELL1

     l :: INT, readonly  DEFAULT(0)
     ! (Maximum) l quantum number of the shell

     l_chr :: STR, readonly  DEFAULT(" ")
     ! The character symbol for the shell e.g. "s", "p", "l", "d" ...

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the components are spherical harmonics, else cartesian

     n_comp :: INT, readonly  DEFAULT(0)
     ! No. of components for the shell

     n_sph :: INT, readonly  DEFAULT(0)
     ! No. of spherical components for the gaussian shell

     n_bf :: INT, readonly  DEFAULT(0)
     ! No. of basis functions in the shell

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian in the shell. For lookups.

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian in the shell. For lookups.

     n_cc :: INT  DEFAULT(0)
     ! No. of contraction coefficients for the shell

     position :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Position of the shell

     exponent :: VEC{REAL}* DEFAULT_NULL
     ! Exponent vector

     contraction :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector

     contraction_s :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for s functions in an L shell

     contraction_p :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for p functions in an L shell

   end

   type SHELL2

     a :: SHELL1
     ! Shell "a" of the pair

     b :: SHELL1
     ! Shell "b" of the pair

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the components are spherical harmonics, else cartesian

     n_gaussian_pairs :: INT, readonly  DEFAULT(0)
     ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

     l_max :: INT, readonly  DEFAULT(0)
     ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

     l_min :: INT, readonly  DEFAULT(0)
     ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

     l_sum :: INT, readonly  DEFAULT(0)
     ! Sum of the angular momenta on each shell, .a.l+.b.l

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian in the shell with momentum .l_max

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian in the shell with momentum .l_sum

     n_gaussian :: INT, readonly  DEFAULT(0)
     ! The number of gaussians in the source integral list.

     ! kappa_max :: REAL
     ! Maximum of .a.cc * .b.cc * kappa_ab for the two electron integrals.

     destroy_all :: BIN, readonly 
     ! Set TRUE or if all the pointer parts are to be destroyed. Sometimes you
     ! want this FALSE when pointers are assigned to save computation.

     exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "a"
     ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

     exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of the sum of the gaussian pair exponents, as a flattened
     ! array, 1/(.a.ex(:)+.b.ex(:))

     contraction_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "a" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     contraction_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     contraction_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     same_center :: BIN  
     ! If TRUE, then the centers of a and b are the same.

     pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .a and .b.

     av_pair_center :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The contractionweighted average of the pair_center's.

     center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between pair_center and the position of the gaussian of
     ! higher angular momentum out of .a and .b.

   end

   type SHELL1PAIR

     a :: SHELL1
     ! Shell "a" of the pair

     b :: SHELL1
     ! Shell "b" of the pair

     n_gaussian_pairs :: INT, readonly
     ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

     n_comp_pairs :: INT, readonly
     ! The number of cartesian gaussian component pairs in the shell
     ! pair, i.e.  .a.n_comp*.b.n_comp

     n_sph_pairs :: INT, readonly
     ! The number of spherical gaussian component pairs in the shell
     ! pair, i.e.  .a.n_sph*.b.n_sph

     n_bf_pairs :: INT, readonly
     ! The number of basis function component pairs in the shell pair,

     l_max :: INT, readonly
     ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

     l_min :: INT, readonly
     ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

     l_sum :: INT, readonly
     ! Sum of the angular momenta on each shell

     first_gaussian :: INT, readonly
     ! Lexical index of the first gaussian in the shell with momentum .l_max

     last_gaussian :: INT, readonly
     ! Lexical index of the last gaussian in the shell with momentum .l_sum

     n_gaussian :: INT, readonly
     ! The number of gaussians in the source integral list.

     exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "a"
     ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

     exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of the sum of the gaussian pair exponents, as a flattened
     ! array, 1/(.a.ex(:)+.b.ex(:))

     contraction_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "a" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     contraction_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     contraction_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .a and .b.

   end

   array type MAT{SHELL1PAIR}

     ! A 1-D array of SHELL1PAIR objects

   end

   type SHELL4

     a :: SHELL1
     ! Shell "a" of the quartet

     b :: SHELL1
     ! Shell "b" of the quartet

     c :: SHELL1
     ! Shell "c" of the quartet

     d :: SHELL1
     ! Shell "d" of the quartet

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the integrals from this shell should be converted
     ! to spherical harmonics

   end

   type SHELL1QUARTET

     a :: SHELL1
     ! Shell "a" of the quartet

     b :: SHELL1
     ! Shell "b" of the quartet

     c :: SHELL1
     ! Shell "c" of the quartet

     d :: SHELL1
     ! Shell "d" of the quartet

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the integrals from this shell should be converted
     ! to spherical harmonics

     ab_nullify :: BIN
     ! Whether to nullify the precalculated .ab vectors or destroy them, i.e.
     ! whether they were pointer assigned or created/calculated.

     cd_nullify :: BIN
     ! Whether to nullify the precalculated .cd vectors or destroy them, i.e.
     ! whether they were pointer assigned or created/calculated.

     ab_n_gaussian_pairs :: INT
     ! The number of (ab| gaussian pair products in the shell pair

     ab_n_comp_pairs :: INT
     ! The number of (ab| cartesian basis function pairs in the shell pair

     ab_n_sph_pairs :: INT
     ! The number of (ab| spherical basis function pairs in the shell pair

     ab_n_bf_pairs :: INT
     ! The number of (ab| basis function pairs in the shell pair

     ab_l_max :: INT
     ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

     ab_l_min :: INT
     ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

     ab_l_tri :: INT
     ! Triangular index for the ab angular momentum pair

     ab_l_sum :: INT
     ! Sum of the angular momenta on each shell, .a.l+.b.l

     ab_first_gaussian :: INT
     ! Index of first gaussian in pair ab

     ab_last_gaussian :: INT
     ! Index of last gaussian in pair ab

     n_ab :: INT
     ! The number of ab gaussian functions required for the source integrals.

     ab_exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "a"
     ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

     ab_exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of ab_exponent_sum.

     ab_contraction_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "a" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     ab_contraction_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     ab_contraction_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     ab_same_center :: BIN
     ! Whether centers of a and b are the same.

     ab_pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .a and .b.

     ab_center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between ab_pair_center and the position of the gaussian of
     ! higher angular momentum out of .a and .b.

     cd_n_gaussian_pairs :: INT
     ! The number of |cd) gaussian pair products in the shell pair

     cd_n_comp_pairs :: INT
     ! The number of |cd) cartesian basis function pairs in the shell pair

     cd_n_sph_pairs :: INT
     ! The number of |cd) spherical basis function pairs in the shell pair

     cd_n_bf_pairs :: INT
     ! The number of |cd) basis function component pairs in the shell pair

     cd_l_max :: INT
     ! Maximum of the angular momenta on each shell, max(.c.l,.d.l)

     cd_l_min :: INT
     ! Minimum of the angular momenta on each shell, min(.c.l,.d.l)

     cd_l_tri :: INT
     ! Triangular index for the cd angular momentum pair

     cd_l_sum :: INT
     ! Sum of the angular momenta on each shell, .c.l+.d.l

     cd_first_gaussian :: INT
     ! Index of first gaussian in pair cd

     cd_last_gaussian :: INT
     ! Index of last gaussian in pair cd

     n_cd :: INT
     ! The number of cd gaussian functions required for the source integrals.

     cd_exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "c"
     ! exponents incrementing most rapidly, .c.ex(:)+.d.ex(:)

     cd_exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of ab_exponent_sum.

     cd_contraction_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "c" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     cd_contraction_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     cd_contraction_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     cd_same_center :: BIN
     ! Whether centers of c and c are the same.

     cd_pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .c and .d.

     cd_center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between cd_pair_center and the position of the gaussian of
     ! higher angular momentum out of .c and .d.

     ab_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.

     ab_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.

     ab_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.

     ab_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.  This version is for the
     ! reduced multiplication scheme, where the y and z arrays have been collapsed
     ! into one product array.

     cd_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.

     cd_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.

     cd_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.

     cd_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.  This version is for the
     ! reduced multiplication scheme, where the y and z arrays have been collapsed
     ! into one product array.

     r2ab :: REAL
     ! The distance between shells .a and .b.

     r2cd :: REAL
     ! The distance between shells .c and .d.

   end


!  =====
!  Bases
!  =====

   type BASIS

     label :: STR
     ! Unique label for the basis set

     is_spherical :: BIN   DEFAULT(FALSE)
     ! Set TRUE if using spherical harmonic basis

     n_shell :: INT
     ! No. of shells in the basis, equal to size(shell)

     n_bf :: INT
     ! No. of basis functions

     n_prim :: INT
     ! No. of primitives 

     shell :: VEC{SHELL}* DEFAULT_NULL
     ! The list of gaussian shells in the basis set

   end

   array type VEC{BASIS}

     ! A 1-D array of BASIS objects

   end

   type SLATERSHELL

     l :: INT, readonly  DEFAULT(0)
     ! l quantum number

     l_chr :: STR, readonly  DEFAULT(" ")
     ! The character symbol for the shell e.g. "s", "p", "l", "d" ...

     n_comp :: INT, readonly  DEFAULT(0)
     ! The number of l-components, normally 2*l+1 for spherical type slater
     ! functions.

     n_orb :: INT, readonly DEFAULT(0)
     ! The number of generally contracted orbitals.

     n_prim :: INT, readonly  DEFAULT(0)
     ! No. of exponents/contractions (i.e. the number of primitives for one
     ! *single* angular momentum shell component, e.g. p_x).

     n :: VEC{INT}* DEFAULT_NULL
     ! The n quantum numbers.

     z :: VEC{REAL}* DEFAULT_NULL
     ! The exponent zeta for each slater function

     c :: MAT{REAL}* DEFAULT_NULL
     ! The contraction coefficient matrix == this is a generally contracted slater
     ! shell. The size of .dim1 is "n_cc". The size of .dim2 is "n_orb".

     orb_kind :: VEC{STR}* DEFAULT_NULL
     ! The orbital kinds (1s, 2s, 2p, etc.), if available.
     ! It's length is "n_orb".

     occupancy :: VEC{INT}* DEFAULT_NULL
     ! The occupany number of each contracted orbital, if available.
     ! It's length is "n_orb".

   end

   array type VEC{SLATERSHELL}

     ! A 1-D array of SLATERSHELL objects

   end

   type SLATERBASIS

     label :: STR
     ! Unique label for the basis set

     configuration :: STR
     ! A STR representation of the configuration.

     n_shell :: INT
     ! No. of shells in the basis, equal to size(shell)

     n_bf :: INT
     ! No. of basis functions for the shell

     n_prim :: INT
     ! No. of primitives for the shell

     shell :: VEC{SLATERSHELL}*  DEFAULT_NULL
     ! The list of gaussian shells in the basis set

     use_interpolator :: BIN  DEFAULT(TRUE)
     ! Whether to use interpolators

     interpolator :: INTERPOLATOR@
     ! An interpolator object, used for calculating the atomic density at a
     ! certain radius, from the slater "shell" of orbitals

     d1_interpolator :: INTERPOLATOR@
     ! The same as above, but for the 1st derivative of the density.

     d2_interpolator :: INTERPOLATOR@ 
     ! The same as above, but for the 2nd derivative of the density.

   end

   array type VEC{SLATERBASIS}

     ! A 1-D array of SLATERBASIS objects

   end

   type COPPENSORBITAL

     orb_kind :: STR, readonly
     ! The kind of the orbital (1s, 2s, 2p, etc.)

     occupancy :: INT, readonly
     ! The number of electrons in the orbital.

     n_fun :: INT, readonly
     ! The number of contracted fitting functions

     n :: VEC{INT}* DEFAULT_NULL
     ! The n quantum numbers

     c :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient

     z :: VEC{REAL}* DEFAULT_NULL
     ! The exponent zeta for each slater function

   end

   array type VEC{COPPENSORBITAL}

     ! A 1-D array of COPPENSORBITAL objects

   end

   type COPPENSBASIS

     label :: STR
     ! The basis label

     n_orb :: INT
     ! The number of orbitals in the basis

     n_prim :: INT
     ! The number of primitive functions in the basis

     orbital :: VEC{COPPENSORBITAL}*  DEFAULT_NULL
     ! The list of fitted Slater atomic orbitals, Coppens style.

     use_interpolator :: BIN  DEFAULT(TRUE)
     ! Whether to use interpolators

     interpolator :: INTERPOLATOR@
     ! An interpolator object, used for calculating the atomic density at a
     ! certain radius, from e.g. the coppensbasis

   end

   array type VEC{COPPENSBASIS}

     ! A 1-D array of COPPENSBASIS objects

   end

   type T_TENSOR
   
      scalar :: REAL DEFAULT(ZERO)
      alpha :: VEC{REAL}(3) DEFAULT(ZERO)
      alpha_beta :: MAT{REAL}(3,3) DEFAULT(ZERO)
      alpha_beta_gamma :: MAT3{REAL}(3,3,3) DEFAULT(ZERO)
      alpha_beta_gamma_delta :: MAT4{REAL}(3,3,3,3) DEFAULT(ZERO)
      x,y,z :: REAL
      xx,yy,zz,xy,xz,yz :: REAL
      xxx,yyy,zzz,xxy,xxz,yyx,yyz,zzx,zzy,xyz :: REAL
      ! Empty type

   end



!  =====
!  Atoms
!  =====

   type ATOM

     label :: STR  DEFAULT("?"), readonly
     ! The label for the atom (not necessarily unique)

     tag :: STR  DEFAULT(" "), readonly
     ! The label may have tag information, which is extracted into here.
     ! It may be reset in the VEC{ATOM} module

     atomic_number :: INT  DEFAULT(0), readonly
     ! The atomic number

     nuclear_charge :: REAL  DEFAULT(ZERO), readonly
     ! The nuclear charge, used for dummy atom charges

     oxidation_state :: INT   DEFAULT(0), readonly
     ! The atomic oxidation state

     n_core_electrons :: INT  DEFAULT(0), readonly
     ! The number of core elctrons eliminated by e.g. the
     ! use of effective core potentials.

     ! ====
     ! Mass
     ! ====

     mass_number :: INT  DEFAULT(0), readonly
     ! The atomic mass number i.e. no. of protons and neutrons

     mass :: REAL  DEFAULT(ZERO), readonly
     ! The abundamce-weighted mass of the atom (if mass_number=0) or
     ! the isotope mass in C12 mass units.

     ! ========
     ! Position
     ! ========

     position :: VEC{REAL}(3)  DEFAULT(ZERO), readonly
     ! Atom position

     position_error :: VEC{REAL}(3)  DEFAULT(ZERO), readonly
     ! Error in atom position error (for refinements only)

     ! =================
     ! Group & site data
     ! =================

     group :: INT  DEFAULT(0)
     ! An integer which describes the group to which the atom belongs

     site_occupancy :: REAL  DEFAULT(ONE), readonly
     ! The crystallographic site occupancy.

     site_disorder_group :: INT  DEFAULT(0), readonly
     ! The crystallographic site disorder group.

     ! =====
     ! ADP's
     ! =====

     U_iso :: REAL  DEFAULT(ZERO), readonly
     ! The isotropic ADP value for the atom

     U_iso_error :: REAL  DEFAULT(ZERO), readonly
     ! The isotropic ADP error for the atom

     M_ani :: REAL  DEFAULT(ZERO), readonly
     ! The *square root* of the anisotropy of the ADP tensor as
     ! defined in e.g. Stone (2013) Theory of Intermolecular Forces,
     ! p. 27 eqn. (2.3.16).

     M_ani_error :: REAL  DEFAULT(ZERO), readonly
     ! The error in M_ani

     covariance_mx :: MAT{REAL}@ 
     ! Covariance matrix between this atom's parameters.
     
     ADP_tensor :: MAT{REAL}(3,3)  DEFAULT(ZERO), readonly
     ! The ADP (thermal) tensor for the atom

     pADP_vector :: VEC{REAL}*  DEFAULT_NULL, readonly
     ! The position-ADP vector for the atom. Used in refinements only.
     ! The order is x, y, z, Uxx, Uyy, Uzz, Uxy, Uxz, Uyz, Uxxx, Uyyy,
     ! and thereafter exactly for gaussian basis functions. See the
     ! GAUSSIAN_DATA module.

     pADP_errors :: VEC{REAL}*  DEFAULT_NULL, readonly
     ! The errors in the parameters (positions and ADP's). Used in
     ! refinements only. See above.

     ! ===========
     ! Axis system
     ! ===========

     pos_axis_system :: STR  DEFAULT("cartesian"), readonly
     ! Specifies the position coordinate system

     ADP_axis_system :: STR  DEFAULT("cartesian"), readonly
     ! Specifies the ADP (thermal tensor) coordinate system

     ADPn_axis_system :: STR  DEFAULT("cartesian"), readonly
     ! Specifies the ADP3 coordinate system

     ADPn_form :: STR  DEFAULT(ATOM_ADPN_FORM)
     ! This may be "g" for the dimensionless Gram-Charlier anharmonic
     ! constants, OR "u"  i.e. the constants are dimensioned in
     ! Angstrom^n, where n=3,4 is the order of the constants. This is
     ! like the second order cartesian ADPs, but is non-standard,
     ! see Trueblood (1996) Acta Cryst A 52 p. 770-81 (34)-(37), but
     ! in that paper "h" is our k/2\pi.

     ! =======
     ! Charges
     ! =======

     charge :: REAL  DEFAULT(ZERO), readonly
     ! The charge on the atom

     dipole :: VEC{REAL}(3)  DEFAULT(ZERO), readonly
     ! The dipole on the atom

     quadrupole :: MAT{REAL}(3,3)  DEFAULT(ZERO), readonly
     ! The quadrupole on the atom

     spin :: REAL  DEFAULT(ZERO), readonly
     ! The value of unpaired spin on this atom

     spin_dipole :: VEC{REAL}(3)  DEFAULT(ZERO), readonly
     ! The Sz spin dipole on the atom

     spin_quadrupole :: MAT{REAL}(3,3)  DEFAULT(ZERO), readonly
     ! The Sz spin quadrupole on the atom

     charge_polarisability :: VEC{REAL}(3)  DEFAULT(ZERO), readonly
     ! The charge polarisability on the atom

     dipole_polarisability :: MAT{REAL}(3,3)  DEFAULT(ZERO), readonly
     ! The dipole polarisability on the atom; field is 2nd component.

     ! ========
     ! QM bases
     ! ========

     basis_label :: STR  DEFAULT(" "), readonly
     ! The label of the basis set to match to. e.g. when looking in
     ! the library

     basis_kind :: STR  DEFAULT(" "), readonly
     ! The kind of basis set ("gaussian", "slater" etc.) to use in
     ! calculations. Note that there may be more than one type of
     ! basis present for an atom.

     basis :: BASIS* DEFAULT_NULL
     ! The basis for the atom

     slaterbasis_label :: STR  DEFAULT(" "), readonly
     ! The label of the slater basis set to match to.

     slaterbasis :: SLATERBASIS* DEFAULT_NULL
     ! The Slater function basis set for the atom. This includes
     ! occupancies and can be used for Hirshfeld surface plots and
     ! sum-of-spherical atoms densities.

     coppensbasis_label :: STR  DEFAULT(" "), readonly
     ! The label of the coppens basis set to match to.

     coppensbasis :: COPPENSBASIS* DEFAULT_NULL
     ! The Coppens-style fitted relativistic orbital basis for the
     ! atom. This is used for Hirshfeld surface plots and
     ! sum-of-spherical atoms densities.

     kind :: INT  DEFAULT(0), readonly
     ! The atom kind index ... atoms have the same kind if they have
     ! the same atomic number and the same basis sets.
     ! NOTE: this is used to test for finalization.

     is_unique_kind :: BIN  DEFAULT(FALSE), readonly
     ! Set true if this atom and its basis are unique.
     ! This is used for setting ANO data and bases.

     ! =======================
     ! ANO/spherical atom info
     ! =======================

     energy :: REAL, readonly
     ! The energy of the isolated atom

     atomic_orbitals :: OPMATRIX@
     ! The atomic orbitals for the atom

     density_matrix :: OPMATRIX@
     ! The density matrix for the atom

     natural_orbitals :: OPMATRIX@
     ! The natural orbitals for the atom

     occupation_numbers :: OPVECTOR@
     ! The occupation numbers for the atom

     atom_data_made :: BIN  DEFAULT(FALSE), readonly
     ! Set TRUE if the ANO info has been made.  Used to destroy the
     ! unique atom info.

     NAOs :: MAT{REAL}* DEFAULT_NULL
     ! The natural atomic orbitals for the atom

     NAO_occupations :: VEC{REAL}* DEFAULT_NULL
     ! The NAO occupation numbers for the atom

     ! =============
     ! Interpolators
     ! =============

     use_interpolator :: BIN  DEFAULT(TRUE), readonly
     ! Whether to use interpolators for spherical densities

     interpolator :: INTERPOLATOR@
     ! An interpolator object, used for calculating the atomic
     ! density at a certain radius. This is for gaussian bases only.

     ! =====================
     ! IAM structure factors
     ! =====================

     use_IAM_ITC_FFs :: BIN  DEFAULT(TRUE)
     ! For IAM refinements only.
     ! If TRUE, use Stewart-Davidson-Simpson (SDS) H form factors.  
     ! If FALSE, use neutral atom form factors (including for H).

     f_r :: REAL  DEFAULT(ZERO)
     ! Real part of the anomalous scattering factor, f'

     f_i :: REAL  DEFAULT(ZERO)
     ! Imaginary part of the anomalous scattering factor, f''

     ! ==========
     ! Shell data
     ! ==========

     first_basis_fn_for_shell :: VEC{INT}@
     ! First basis function for a given shell

     last_basis_fn_for_shell :: VEC{INT}@
     ! Last basis function for a given shell

     angular_moment_for_shell :: VEC{INT}@
     ! Angular moment for a given shell

     precomputed_basis_shellpair :: MAT{SHELL1PAIR}* DEFAULT_NULL
     ! Precomputed stuff for shellpairs of the basis set, to speed up
     ! later calculations of gaussian integrals.

     ! =========
     ! Invarioms
     ! =========

     invariom_label :: STR  DEFAULT(" "), readonly
     ! The label for the invariom

     ! ========
     ! Proteins
     ! ========

     ! The following names are very similar to the IUCr dictionary
     ! Blame them for silly names.

     atom_sequence_id :: INT  DEFAULT(0)
     ! Atom sequence number in the protein. The dictionary says it is
     ! not necessary to be an integer but we make it so here.

     compound_id :: STR   DEFAULT(" ")
     ! Compound i.e. residue code that atom belongs to.

     compound_sequence_id :: INT   DEFAULT(0)
     ! Sequential number for the compound i.e. residue that the atom belongs to.

     asym_id :: STR   DEFAULT(" ")
     ! Protein strand label that this atom belongs to.

     entity_id :: STR   DEFAULT(" ")
     ! Code for the entity that the atom & residue belong to

     is_cap_atom :: BIN  DEFAULT(FALSE)
     ! Set true if this is a cap atom to terminate a fragment, so that
     ! structure factors are not calculated. NOTE: some cap atoms are
     ! in the backbond and overlap with other fragments.

     ! ==
     ! MM
     ! ==

     mm_forcefield_name :: STR  DEFAULT(" ")
     ! The name of the forcefield (e.g. amber, sybyl,...)

     mm_atom_type :: STR  DEFAULT(" ")
     ! The atom type, used to define the force field potential

     mm_charge :: REAL  DEFAULT(ZERO)
     ! The atomic charge (relative to the force field!)

     restraining_position :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! A position used for restrained geometry optimization

     restraining_force_constant :: REAL  DEFAULT(ZERO)
     ! A force constant used for restrained geometry optimisations

   end

   array type VEC{ATOM}

     ! A 1-D array of ATOM's

   end

   type ATOM_GROUP

     name :: STR  DEFAULT(" "), readonly
     ! The name given to the group

     n_atoms :: INT   DEFAULT(0)
     ! The number of atoms in the group

     atom_index :: VEC{INT}@
     ! The list of atom indices in the group
     ! Non-zero value indicates user set this value.

     charge :: INT, readonly  DEFAULT(0)
     ! The list of charges on each group

     spin_multiplicity :: INT  DEFAULT(1)
     ! Spin multiplicity of the atom group.

     spin_multiplicity_set :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the user entered a spin_multiplicity.
     ! Used to override the default.

     MO_file_name :: STR DEFAULT(" "), readonly
     ! Name of the MO file for the group

     wavefunction_file_name :: STR DEFAULT(" "), readonly
     ! Name of the wavefunction file used to store molecule data

     transform_group :: BIN  DEFAULT(FALSE), readonly
     ! Whether to symmetry-transform (rotate, translate) the group.
     ! fchk file groups are always rotated.

     rotation_matrix :: MAT{REAL}(3,3) DEFAULT(ZERO)
     ! Rotation matrix

     shift :: VEC{REAL}(3) DEFAULT(ZERO)
     ! Shift vector

     n_MOs :: INT, readonly  DEFAULT(0)
     ! The number of MO's to use when constructing the density matrix
     ! for the group. Only the lowest MO's up to this number are used.

     atom :: VEC{ATOM}*, readonly  DEFAULT_NULL
     ! The list of atoms from which groups are defined, where
     ! atom_index(:) points to. *Pointer assigned*.

     mol :: MOLECULE*  DEFAULT_NULL
     ! The current submolecule

   end

   array type VEC{ATOM_GROUP}

     ! A 1-D array of ATOM_GROUP's

   end

!  Atomic data

   type SASAKI_FORM_FACTORS

     Z_list :: VEC{INT}@
     ! The list of atomic numbers for which form factors are required

     wavelength :: REAL, readonly  DEFAULT(-ONE)
     ! The wavelength for the data, in Angstrom

     fr :: VEC{REAL}@
     ! The real part of the anomalous form factor, f'

     fi :: VEC{REAL}@
     ! The imahinary part of the anomalous form factor, f''

     mu_on_rho :: VEC{REAL}@
     ! Mass photoelectric attenuation coefficient, units unknown

     sigma_on_rho :: VEC{REAL}@
     ! Total photon scatterin cross section, units unknown

     finalized :: BIN  DEFAULT(FALSE)
     ! Whetherthe object is finalised


   end


!  ===================
!  DFT and Becke grids
!  ===================

   type DFT_FUNCTIONAL

     name :: STR  DEFAULT(" ")
     ! The name of the functional to use

     Xalpha :: REAL  DEFAULT(DFT_FUNCTIONAL_XALPHA)
     ! The valueof the alpha parameter in the Xalpha functional

     rho_cutoff :: REAL   DEFAULT(DFT_FUNCTIONAL_RHO_CUTOFF)
     ! The value of the density below which the functional and the potential are
     ! set to zero.

   end

   type BECKE_GRID

     kind :: STR  DEFAULT(BECKE_GRID_KIND)
     ! The exact type of Becke grid to use

     atom :: VEC{ATOM}*  DEFAULT_NULL
     ! List of atoms for which DFT integration grids are to be made.
     ! If associated, used to generate the atom basis function (and
     ! nabla) grids for gaussian DFT calculations. *Pointer copied*.

     atom_zeta :: VEC{REAL}@
     ! List of scaling factors used in the transformation to the radial
     ! integration interval.

     atom_min_distance :: VEC{REAL}@, private
     ! For every atom, the minimum distance to the nearest atom.

     n_unique_atoms :: INT, private
     ! No. of atoms of unique kind. An atom is the same as another if it has the
     ! same nuclear charge.

     unique_atom :: VEC{INT}@, private 
     ! unique_atom(k) is the index of the "k"-th unique atom.

     unique_atom_for :: VEC{INT}@, private 
     ! unique_atom_for(a) is the index of the unique atom equivalent to "a".

     basis_function_cutoff :: REAL  DEFAULT(BECKE_GRID_BASIS_FUNCTION_CUTOFF)
     ! Below this cutoff, *atomic* grid points whose corresponding basis function values
     ! (which are to be integrated) are assumed to be zero. In combination with
     ! the .atom_lowest_exponents this cutoff is used to prune *atomic* grids of
     ! unnecessary points.

     basis_function_pair_cutoff :: REAL  DEFAULT(BECKE_GRID_RHO_CUTOFF)
     ! *Atom pair* grid points where the *product* of the two basis function
     ! values is smaller than this cutoff are assumed to be zero. In combination
     ! with the .atom_lowest_exponents this cutoff is used to prune *atom pair*
     ! grids of unnecessary points.

     partition_cutoff :: REAL  DEFAULT(BECKE_GRID_PARTITION_CUTOFF)
     ! Below this cutoff, basis function values which are to be integrated are
     ! assumed to be zero. In combination with the .atom_lowest_exponents

     rho_cutoff :: REAL   DEFAULT(BECKE_GRID_RHO_CUTOFF)
     ! The value of the density below which the functional and the potential are
     ! set to zero on this grid. This variable is passed to the DFT_FUNCTIONAL
     ! object. It is also used to eliminate density evaluation at grid points, and
     ! it determines the overlapping_atoms array.

     n_radial_points ::  INT DEFAULT(0)
     ! No. of radial points desired for the Hydrogen atom. The number of points
     ! used for other atoms is normally 5 more for every extra shell, according
     ! to Becke's original rule of thumb.

     n_extra_points_per_shell :: INT DEFAULT(BECKE_GRID_EXTRA_POINTS_PER_SHELL)
     ! The number of extra points to use per n-shell over and above the default
     ! number .n_radial_points for the Hydrogen atom.

     accuracy :: STR  DEFAULT(BECKE_GRID_ACCURACY)
     ! A keyword describing the desired accuracy of the integration grid.

     l_angular_grid :: INT DEFAULT(0)
     ! Angular momentum which is to be integrated exactly by the angular grid.

     l_H_angular_grid :: INT DEFAULT(0)
     ! Angular momentum which is to be integrated exactly by the angular grid
     ! for the Hydrogen/Helium atoms only. For other atoms .l_angular_grid is used.

     pruning_scheme :: STR  DEFAULT(BECKE_GRID_PRUNING_SCHEME)
     ! This describes the method to reduce angluar grids near the atomic nuclei.
     ! It can be "none", "treutler_ahlrichs", or "sg-1". This variable sets the
     ! .reduce_core_angular_grid and .reduce_H_angular_grid switches.

    ! reduce_core_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_CORE_ANGULAR_GRID)
    ! ! If set TRUE the order of the angular grid near the core of the atom is
    ! ! reduced to make smaller meshes. So far the scheme of Treutler and Ahlrichs
    ! ! is used.

     reduce_H_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_H_ANGULAR_GRID)
     ! If set TRUE the order of the angular grid for Hydrogen and Helium are
     ! reduced to .l_H_angular_grid.

     scale_atomic_grids :: BIN  DEFAULT(BECKE_GRID_SCALE_ATOMIC_GRIDS)
     ! If set TRUE, the atomic grids are scaled according to the authors
     ! recommended scaling factors. This does *not* mean that the partition
     ! function is also scaled to account for varying atomic sizes.

     partition_power :: INT  DEFAULT(BECKE_GRID_PARTITION_POWER)
     ! Used in smoothing the partition boundary

     stratmann_scuseria_A :: REAL  DEFAULT(BECKE_GRID_STRATMANN_SCUSERIA_A)
     ! The Stratmann-Scuseria "a" parameter, used in defining their piecewise
     ! partition function. See CPL 257 p. 213 (1996).

     atom_n1_SS :: VEC{INT}@, private 
     ! The number of unit-weight SS grid weights, for every atom

     partition_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCHEME)
     ! This describes the method to partition the electron density into atomic
     ! contributions which are then integrated separately. Currently there are
     ! "becke" and "delley". The former is based on smoothed-out Voronoi
     ! polyhedra. The latter are based on Hirshfeld-like partitioning using
     ! exponential functions.

     partition_scaling_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCALING_SCHEME)
     ! This chooses the precise method to scale the sizes of the "atoms" generated
     ! by the atomic partition function. For "becke" partitioning the default is
     ! by "truetler_ahlrichs", but you can choose "none" or "becke". For "delley"
     ! partitioning the only option is "none" i.e. no atomic rescaling.  Usually
     ! the scaling is based on the Bragg-Slater radii (except for H, where twice
     ! the radii is used). Treutler and Ahlrichs recommended using the square root
     ! of the ratio of Bragg Slater radii.

     finalized :: BIN  DEFAULT(FALSE)
     ! Set to true if the grid has been "set" using set_grid_data

     n_points_for_row :: VEC{INT}@, private 
     ! The number of points for a given row of the periodic table, for the
     ! current grid settings.

     radial_grid :: VEC{QUADRATURE}@
     ! The radial quadrature points, one for every row of the periodic table.

     lebedev_grid :: LEBEDEV@ 
     ! The angular quadrature points. We use a Lebedev grid.

     lebedev_H_grid :: LEBEDEV@
     ! The angular quadrature points for the Hydrogen atom.

     lebedev_L3_grid :: LEBEDEV@
     ! Angular quadrature points for L=3, used close to the atom.

     lebedev_L5_grid :: LEBEDEV@
     ! Angular quadrature points for L=5, used close to the atom.

     lebedev_L7_grid :: LEBEDEV@
     ! Angular quadrature points for L=7, used close to the atom.

     lebedev_L9_grid :: LEBEDEV@
     ! Angular quadrature points for L=9, used close to the atom.

     lebedev_L11_grid :: LEBEDEV@
     ! Angular quadrature points for L=11, used close to the atom.

     n_unscaled_points :: INT DEFAULT(0)
     ! No. of quadrature points in the reference atom.

     unscaled_point :: MAT{REAL}@, private
     ! The unscaled spherical quadrature grid points centered at the
     ! origin, for a reference atom.

     unscaled_weight :: VEC{REAL}@, private
     ! The unscaled spherical quadrature grid weights for a reference
     ! atom.

     n_points :: INT DEFAULT(0)
     ! No. of points in quadrature grid for the whole molecule.

     atom_points :: VEC{EMAT{REAL}}@
     ! The complete list of grid points for the unique atoms
     ! assuming the atom is centered at the origin

     atom_weights :: VEC{EVEC{REAL}}@
     ! The complete list of grid weights for the unique atoms in
     ! .atom_Z.

     atom_grid0 :: VEC{EMAT{REAL}}@
     ! List of atomic density grids for the unique atoms

     atom_grid1 :: VEC{EMAT3{REAL}}@
     ! List of atomic gradient density grids for the unique atoms

     weight_is_0 :: VEC{BIN}@
     ! Set to TRUE if the weight for a particular point is zero. Used
     ! to eliminate grid points from product grids.

   end


!  ========
!  Symmetry
!  ========

   type IRREP

     label :: STR(len=4)
     ! Irrep label

     dimension :: INT
     ! Irrep dimension

     character :: VEC{REAL}* DEFAULT_NULL
     ! Characters for the irrep

     mat :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for the irrep

   end

   array type VEC{IRREP}

     ! A 1-D array of IRREP objects

   end

   type POINTGROUP

     symbol :: STR(len=4)
     ! symmetry symbol

     ID_symbol :: STR(len=4)
     ! group id symbol

     ID_number :: INT
     ! group id number

     axis_order :: INT
     ! principal axis order

     order :: INT
     ! order of the group

     n_irrep :: INT
     ! no of irreducible representations

     n_gen :: INT
     ! No. of generators

     has_complex_irreps :: BIN
     ! true if the group has complex irreps

     table :: MAT{INT}* DEFAULT_NULL
     ! group multiplication table

     mat :: MAT3{REAL}* DEFAULT_NULL
     ! 3x3 representation matrices

     use_spherical_basis :: BIN   DEFAULT(FALSE)
     ! Set true if you want to use spherical harmonic basis set
     ! Necessary for the correct rep matrices

     ptr :: MAT3{REAL}* DEFAULT_NULL
     ! 3x3 representation matrices for p functions, same as mat

     dtr :: MAT3{REAL}* DEFAULT_NULL
     ! 6x6 representation matrices for d functions

     ftr :: MAT3{REAL}* DEFAULT_NULL
     ! 10x10 representation matrices for f functions

     gtr :: MAT3{REAL}* DEFAULT_NULL
     ! 15x15 representation matrices for g functions

     inverse :: VEC{INT}* DEFAULT_NULL
     ! Indices of inverse group elements

     irrep :: VEC{IRREP}* DEFAULT_NULL
     ! List of irrrducible representations

   end

   type SPACEGROUP

     ! ==========
     ! Input data
     ! ==========

     IT_symbol :: STR   DEFAULT("?")
     ! International Table (Hermann-Maguin) symmetry symbol

     IT_group_number :: INT   DEFAULT(0)
     ! International tables group number

     Hall_symbol :: STR   DEFAULT("?")
     ! Hall notation symbol

     HM_symbol :: STR   DEFAULT("?")
     ! Hermann-Mauguin notation symbol

     Schoenflies_symbol :: STR   DEFAULT("?")
     ! Hermann-Mauguin notation symbol

     ! ============
     ! Parsed input
     ! ============

     lattice_symbol :: STR(len=1)   DEFAULT("?")
     ! Hall lattice symmetry symbol

     lattice_symbol_index :: INT   DEFAULT(0)
     ! Hall lattice symbol index number

     lattice_type :: STR   DEFAULT("?")
     ! Lattice type e.g. "cubic"

     centrosymmetric :: BIN   DEFAULT(FALSE)
     ! True if center of symmetry present

     axis_order :: VEC{INT}(4)   DEFAULT(0)
     ! Order of each symop generator

     axis_direction_symbol :: VEC{STR}(len=1,4)   DEFAULT(" ")
     ! Superscript rotation axis direction symbol for each generator

     axis_direction_index :: VEC{INT}(4)   DEFAULT(0)
     ! Indicates the numberical index corresponding to the rotation
     ! axis symbol for each generator

     has_axis_bar :: VEC{BIN}(4)   DEFAULT(FALSE)
     ! True if bar for this generator

     translation_symbol :: MAT{STR}(len=1,3,4)   DEFAULT(" ")
     ! Subscript translation symbols for each generator

     origin_shift :: VEC{INT}(3)   DEFAULT(0)
     ! Subscript translation symbols for each axis

     ! =============
     ! Analyzed data
     ! =============

     nL :: INT   DEFAULT(0)
     ! No. of translational lattice generators

     nR :: INT   DEFAULT(0)
     ! No. of rotation generators

     nG :: INT   DEFAULT(0)
     ! No. of generators

     n_seitz :: INT   DEFAULT(0)
     ! No. of Seitz matrices

     seitz :: MAT3{REAL}* DEFAULT_NULL
     ! The spacegroup Seitz matrices in the fractional crystal system.

     product_of_symops :: MAT{INT}* DEFAULT_NULL
     ! The spacegroup multiplication table; product_of_symop(a,b)
     ! corresponds to matmul(seitz(:,:,a),seitz(:,:,b))

     inverse_of_symops :: VEC{INT}* DEFAULT_NULL
     ! The inverse of spacegroup symops

     n_inverted_symops :: INT   DEFAULT(0)
     ! Number of symmetry operations related by inversion

     inverted_symop :: VEC{INT}* DEFAULT_NULL
     ! inverted_symop(i) is the index of a symop strictly less than i,
     ! which is related to symop i by an inversion.  Used to save work
     ! in SF calculations.

     translated_symop :: VEC{INT}* DEFAULT_NULL
     ! translated_symop(i) is the index of a symop, less than or
     ! equal to i, which is related to symop i by translation but
     ! *not* inversion.  This array is used to save work in SF calculations.

     n_unique_SF_symops :: INT
     ! Number of unique symmetry operations not related by translation or
     ! inversion, T&I. This is used to save work in structure factor (SF)
     ! calculations.

     unique_SF_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the unique symops not related by inversion or translation.
     ! This is used to save work in structure factor (SF) calculations.

     analyzed :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the spacegroup symbol has been succesfully analyzed

   end


!  ===========
!  Diffraction
!  ===========

   type REFLECTION

     h :: INT  DEFAULT(0)
     ! Miller h index for the reflection

     k :: INT  DEFAULT(0)
     ! Miller k index for the reflection

     l :: INT  DEFAULT(0)
     ! Miller l index for the reflection

     d :: REAL  DEFAULT(ZERO)
     ! The interplanar spacing (in Bohr)

     stl :: REAL  DEFAULT(ZERO)
     ! Sin (theta)/lambda (in Bohr)

     theta :: REAL  DEFAULT(ZERO)
     ! The Bragg angle theta

     equivalence_factor :: INT  DEFAULT(1)
     ! The number of distinct reflections
     !which are symmetry equivalent

     F_exp :: REAL  DEFAULT(ZERO)
     ! Experimental structure factor

     F_corr :: REAL  DEFAULT(ZERO)
     ! Experimental structure factor corrected for anomalous
     ! dispersion. *These are used in the LSQ*, not F_exp.
     ! (Although, without removal of dispersion from F_exp
     ! it will be the same as F_exp).

     F_sigma :: REAL  DEFAULT(ZERO)
     ! Experimental error in the structure factor

     F_calc :: CPX  DEFAULT(ZERO)
     ! Calculated complex structure factor on the absolute scale
     ! without extinction or scale factor *with* dispersion *if used*

     F_disp :: CPX  DEFAULT(ZERO)
     ! The anomalous dispersion correction, if stored.

     F_pred :: REAL  DEFAULT(ZERO)
     ! Calculated structure factor including scale and extinction corrections

     I_exp :: REAL  DEFAULT(ZERO)
     ! Experimental intensity

     I_sigma :: REAL  DEFAULT(ZERO)
     ! Experimental error in the intensity

     I_calc :: REAL  DEFAULT(ZERO)
     ! Calculated intensity (F_pred==2) without scale and extinction corrections

     I_pred :: REAL  DEFAULT(ZERO)
     ! Calculated intensity (F_pred==2) including scale and extinction corrections

     group :: INT DEFAULT(0)
     ! Specifies the group that this reflection belongs to. Reflections in
     ! different groups may get treated differently e.g. be optimised with
     ! different scale factors.

   end

   array type VEC{REFLECTION}

     ! A 1-D array of REFLECTION objects

   end

   type DIFFRACTION_DATA

     data_kind :: STR  DEFAULT(DIFFRACTION_DATA_DATA_KIND)
     ! Tells whether this is X-ray, neutron, or whatever data

     reflection0 :: VEC{REFLECTION}* DEFAULT_NULL
     ! The original input structure factors before pruning.

     reflections :: VEC{REFLECTION}* DEFAULT_NULL
     ! The structure factor information. NOTE: this can stand for either X-ray or
     ! PND reflections depending on the case.

     hkl_range :: VEC{EVEC{INT}}@
     ! The range of the Miller indices (h k l)

     ! =================
     ! Experimental data
     ! =================

     wavelength :: REAL  DEFAULT(-ONE)
     ! Experimental wavelength

     temperature :: REAL   DEFAULT(DIFFRACTION_DATA_TEMPERATURE)
     ! Experimental temperature, for NKA

     NKA_T_sequence_no :: INT   DEFAULT(0)
     ! Sequence no. for NKA output file

     ! ======================
     ! Data treatment options
     ! ======================

     F_sigma_noise :: REAL  DEFAULT(ZERO)
     ! The value of the "alpha" noise to apply to the F_exp and
     ! F_sigma in units of F_sigma. Noise is normally distributed.

     F_sigma_cutoff :: REAL  DEFAULT(DIFFRACTION_DATA_F_SIGMA_CUTOFF)
     ! Cutoff for F_exp/F_sigma, for prune_weak_reflections

     I_sigma_cutoff :: REAL  DEFAULT(DIFFRACTION_DATA_I_SIGMA_CUTOFF)
     ! Cutoff for I_exp/I_sigma, for prune_weak_reflection data

     F_z_cutoff :: REAL  DEFAULT(-ONE)
     ! Cutoff for F_z, for prune_bad_F_reflections

     I_z_cutoff :: REAL  DEFAULT(-ONE)
     ! Cutoff for I_z, for prune_bad_I_reflections

     F_calc_cutoff :: REAL  DEFAULT(DIFFRACTION_DATA_F_CALC_CUTOFF)
     ! Cutoff for F_calc, for prune_zero_F_calcs

     F_pred_cutoff :: REAL  DEFAULT(-ONE)
     ! Cutoff for F_pred, for prune_zero_F_preds

     I_pred_cutoff :: REAL  DEFAULT(-ONE)
     ! Cutoff for I_pred, for prune_zero_I_preds

     stl_high_cutoff :: REAL  DEFAULT(-ONE)
     ! Cutoff for sin_theta_on_lamba, for prune_high_angle_reflections

     stl_low_cutoff :: REAL  DEFAULT(-ONE)
     ! Cutoff for sin_theta_on_lamba, for prune_low_angle_reflections

     stl_limit :: REAL  DEFAULT(-ONE)
     ! Sin-theta on lambda limit for generating (h k l) reflections

     max_prune_iterations :: INT  DEFAULT(-1)
     ! If the refinement iteration does not exceed this maximum,
     ! reflection pruning will occur i.e. the last ref. iteration
     ! that pruning will occur.

     show_rejects :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to see rejected reflections when pruning

     synthesize_sigma_I :: BIN  DEFAULT(DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I)
     ! True if artificial sigma(I) errors are to be generated from poisson
     ! statistics and used in calculating agreement statistics

     SF_mixing_parameter :: REAL  DEFAULT(ZERO)
     ! The SF mixing parameter which sets the proportion of the
     ! experimental structure factors added into the predicted
     ! structure factors. This may help convergence in constrained HF
     ! problems. Dangerous and not recommended.

     ! =======================================
     ! Structure factor calculation parameters
     ! =======================================

     partition_model :: STR  DEFAULT(DIFFRACTION_DATA_PARTITION_MODEL)
     ! Model for partitioning the fragment into unique bits

     thermal_smearing_model :: STR  DEFAULT(DIFFRACTION_DATA_THERMAL_SMEARING_MODEL)
     ! Thermal smearing model for the Fourier transform

     use_Voronoi_atoms :: BIN  DEFAULT(FALSE)
     ! Set TRUE if fuzzy Voronoi atoms (in the Stratmann-Scuseria
     ! scheme) are to be used for calculating the atomic form factors,
     ! instead of Hirshfeld atoms

     use_KM_atoms :: BIN  DEFAULT(FALSE)
     ! Set TRUE if Koritsanszky-Michael atoms are to be used in the
     ! density in the refinement.

     use_disk_SFs :: BIN  DEFAULT(FALSE)
     ! Set TRUE if writing the asphrical atomic form factors to disk
     ! to save memory.

     use_text_SFs :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the aspherical atomic on disk are in ASCII format.
     ! Setting this will set use_disk_SFs TRUE also.

     ! =====================
     ! IAM structure factors
     ! =====================

     use_IAM_density :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the promolecule (i.e IAM) is to be used in the
     ! density for the HAR refinement; see also next option.

     use_IAM_ITC_FFs :: BIN  DEFAULT(TRUE)
     ! Set TRUE if using International Tables Vol. C IAM exponential
     ! fit to the atomic form factors. This only makes sense for IAM
     ! refinement. NOTE: for H, we use Stewart-Davidson-Simpson (SDS).

     use_zero_overlap :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to have zero overlap density in the
     ! Koritsanszky-Michael density in the refinement.

     ! ====================
     ! Dittrich's invarioms
     ! ====================

     invariom_database_directory :: STR  DEFAULT(" ")
     ! Location of the invariom database

     invariom_refinement :: BIN DEFAULT(FALSE)
     ! Logical to switch on invariom refinement

     ! ========================
     ! Experimental corrections
     ! ========================

     optimize_scale :: BIN  DEFAULT(DIFFRACTION_DATA_OPTIMIZE_SCALE)
     ! True if an overall scaler factor is to be optimised, for use in
     ! calculating F_pred

     scale_factor :: REAL  DEFAULT(DIFFRACTION_DATA_SCALE_FACTOR)
     ! Scale factor to apply to the predicted structure factors  - to
     ! predicted???? this is the one being used to put Fexp on
     ! absolute scale!!! (this is Lorraine here!)

     scale_factors :: VEC{REAL}* DEFAULT_NULL
     ! A set of scale factors to apply to structure factors from
     ! different groups.

     exp_scale_factor :: REAL  DEFAULT(DIFFRACTION_DATA_EXP_SCALE_FACTOR)
     ! Fixed scale factor to apply to the experimental structure factors

     optimize_extinction :: BIN  DEFAULT(DIFFRACTION_DATA_OPTIMIZE_EXTINCTION)
     ! True if extinction is to be optimised.

     extinction_factor :: REAL  DEFAULT(DIFFRACTION_DATA_EXTINCTION_FACTOR)
     ! Secondary extinction factor

     add_dispersion_to_F_calc :: BIN  DEFAULT(FALSE)
     ! True if dispersion is to be corrected, by adding the anomalous
     ! contribution into the complex F_calc.

     remove_dispersion_from_F_exp :: BIN  DEFAULT(FALSE)
     ! True if dispersion is to be removed from F_exp during
     ! refinement. This method is used by XD, Shelx, ...

     stop_after_dispersion :: BIN  DEFAULT(FALSE)
     ! Stop the program immediately after dispersion corrections
     ! arre applied to the SF's in the zeroth iteration of a
     ! refinement and printo out the results. For testing only.

     ! ====================
     ! Agreement statistics
     ! ====================

     n_param :: INT  DEFAULT(0)
     ! No. of fitting parameters used.

     n_param_manually_set :: BIN  DEFAULT(FALSE)
     ! Whether n_param was manually set e.g. by reading a Cif file,
     ! or set after a refinement and not to be changed

     n_obs :: INT  DEFAULT(0)
     ! No. of observations *including* any pseudo observations
     ! associated with restraints like those for H U_iso.

     chi2 :: REAL  DEFAULT(0)
     ! The current iteration's value of chi2

     ! =======================
     ! Refinement/fit switches
     ! =======================

     fit_structure :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if a structure is being fitted

     refine_structure :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if a structure is being refined (implies fitting)

     refine_fragments :: BIN, readonly  DEFAULT(FALSE)

     use_Ryde_capping :: BIN  DEFAULT(FALSE)
     ! Use Ulf Ryde's capping method to split and cap polypeptides
     ! into fragment to make wavefunction and atomic structure factor
     ! and HAR calculations for proteins quicker.
     ! Internal variable to know if we are doing a fragHAR

     refine_F :: BIN, readonly  DEFAULT(TRUE)
     ! Set TRUE if you want to refine F's *not* F2's

     refine_positions_only :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to refine *only* the coordinates

     refine_ADPs_only :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to refine *only* the ADP's

     refine_H_positions :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to refine *only* the hydrogen positions

     refine_H_ADPs :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to refine *all* hydrogen ADP's
     ! NOTE: this includes the H_U_iso case i.e. it includes
     ! just the isotropic displacement parameter.

     refine_H_U_iso :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to refine U_iso for *all* H atoms

     refine_U_iso_for_atom :: VEC{STR}*  DEFAULT_NULL
     ! List of unique atom tags for which U_iso is refined

     refine_nothing_for_atom :: VEC{STR}*  DEFAULT_NULL
     ! List of unique atom tags for which *nothing* (niether positions
     ! nor ADPs) is refined

     refine_anharmonicity :: BIN  DEFAULT(FALSE)
     ! Set TRUE if at least some anharmonic parameters are refined

     refine_3rd_order_for_atom :: VEC{STR}*  DEFAULT_NULL
     ! List of unique atom tags for which third-order anharmonicity
     ! parameters are to be refined.

     refine_4th_order_for_atom :: VEC{STR}*  DEFAULT_NULL
     ! List of unique atom tags for which fourth-order anharmonicity
     ! parameters are to be refined.

     refine_4th_order_only :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to refine only 4th order

     refine_atom_parameters :: MAT{INT}*  DEFAULT_NULL
     ! NOT IMPLEMENTED YET ...
     ! The list of atom parameters which should be refined. This is an
     ! N x 9 list. The first nine columns hold 0's and 1's indicating
     ! whether certain parameters should be refined. The first three
     ! are for the coordinates of the atom and the last six are for
     ! the ADP's in the order xx, yy, zz, xy, xz, yz.

     restart_HAR_with_promolecule :: BIN  DEFAULT(FALSE)
     ! If set TRUE this will restart the SCF procedure with
     ! promolecule guess, followed by the orginal choice of guess.
     ! This may stop convergence problems.

     XCW :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if doing an XCW

     ! ====================================
     ! Refinement/fit iteration termination
     ! ====================================

     min_iterations :: INT, readonly  DEFAULT(DIFFRACTION_DATA_MIN_ITER)
     ! The minimum number of iterations for the normal equations

     max_iterations :: INT, readonly  DEFAULT(DIFFRACTION_DATA_MAX_ITER)
     ! The maximum number of iterations for the normal equations

     max_allowed_param_shift :: REAL  DEFAULT(DIFFRACTION_DATA_MAX_ALLOWED_SHIFT)
     ! The maximum allowed shift when solving the normal equations:
     ! If any one of the parameters shifts obtained from solving the
     ! normal equations is greater than this value, they are all
     ! rescaled so that the largest is this value.

     ! =====================
     ! Least squares options
     ! =====================

     tol_for_shift_on_esd :: REAL DEFAULT(DIFFRACTION_DATA_TOL_FOR_SHIFT_ON_ESD)
     ! The convergence tolerance for the shift in a parameter
     ! divided by its esd

     tol_near_0 :: REAL  DEFAULT(DIFFRACTION_DATA_TOL_NEAR_0)
     ! The tolerance used to detect near zero eigenvalues in the
     ! normal equations

     ! =============================
     ! Refinement/fit output control
     ! =============================

     show_refinement_output :: BIN  DEFAULT(TRUE)
     ! Show refinement output.

     show_refinement_results :: BIN  DEFAULT(TRUE)
     ! Show refinement result statistics, but no parameter values.

     show_fit_output :: BIN  DEFAULT(FALSE)
     ! Display fit output in a refinement

     show_fit_results :: BIN  DEFAULT(FALSE)
     ! Display fit result statistics, but no parameter values

     do_residual_cube :: BIN  DEFAULT(TRUE)
     ! Do residual density as a gaussian.cube after a fit/refinement.

     do_standard_plots :: BIN  DEFAULT(FALSE)
     ! Do standard plots after a fit/refinement

     display_near_0_eigenvectors :: BIN  DEFAULT(FALSE)
     ! Whether to display the near zero eigenvectors

     display_correlation_matrix :: BIN  DEFAULT(FALSE)
     ! Whether to display the correlation matrix or not

     min_correlation :: REAL  DEFAULT(DIFFRACTION_DATA_MIN_CORRELATION)
     ! The minimum value for correlation matrix elements before they
     ! are printed out in the output.

     n_worst_reflections :: INT  DEFAULT(-1)
     ! The number of the worst reflections to show; set to be +ve

     ! =================
     ! Fit output tables
     ! =================

     fit_table :: VEC{TABLE_COLUMN}@
     ! The current fit table

     ref_table :: VEC{TABLE_COLUMN}@
     ! The current refinement table

     ! ==================
     ! Fit iteration data
     ! ==================

     fit_iteration :: INT  DEFAULT(0)
     ! The iteration counter for a rigid-atom structure fit

     chi2_fit :: REAL  DEFAULT(0)
     ! The fit-iteration's value of chi2

     chi2_fit0 :: REAL  DEFAULT(0)
     ! The previous fit-iteration's value of chi2

     max_shift :: REAL  DEFAULT(ZERO)
     ! The shift for the parameter which had the maximum shift on ESD
     ! during a HAR least-squares cycle.

     max_esd :: REAL  DEFAULT(ZERO)
     ! The ESD for the parameter which had the maximum shift on ESD.
     ! during a HAR least-squares cycle.

     max_shift_on_esd :: REAL DEFAULT(ZERO)
     ! The maximum shift in a parameter divided by its esd, during
     ! the current refinement step.

     max_shift_on_esd_ind :: INT DEFAULT(0)
     ! The index of the maximum parameter shift on esd, during the
     ! current refinement step.

     max_shift_on_esd_par :: STR DEFAULT(" ")
     ! The parameter label for the index of the maximum parameter
     ! shift on esd, during the current refinement step.

     fit_converged :: BIN  DEFAULT(FALSE)
     ! TRUE if the fit has converged

     chi2_increased :: BIN  DEFAULT(FALSE)
     ! TRUE if chi2 increased

     too_many_fit_iterations :: BIN  DEFAULT(FALSE)
     ! TRUE if the maximum fit iterations was exceeded

     ! =========================
     ! Refinement iteration data
     ! =========================

     ref_iteration :: INT  DEFAULT(0)
     ! The iteration counter for a non-rigid atom structure refinement
     ! (includes multiple SCF/fit cycles)

     chi2_ref :: REAL  DEFAULT(0)
     ! For a given refine step, fhe final fit-iteration's value of chi2

     chi2_ref0 :: REAL  DEFAULT(0)
     ! For a given refine step, the initial fit-iteration's value of chi2

     max_refshift :: REAL  DEFAULT(ZERO)
     ! The shift in the parameter which had the maximum shift on ESD.
     ! during a HAR refinement cycle.

     max_refesd :: REAL  DEFAULT(ZERO)
     ! The ESD for the parameter which had the maximum shift on ESD
     ! during a HAR refinement cycle.

     max_refshift_on_esd :: REAL DEFAULT(ZERO)
     ! The maximum shift in a parameter divided by its esd, during
     ! the current refinement step.

     ave_refshift_on_esd :: REAL DEFAULT(ZERO)
     ! The *mean* *absolute* shift in a parameter divided by its esd,
     ! during the current refinement step.

     max_refshift_on_esd_ind :: INT DEFAULT(0)
     ! The index of the maximum parameter shift on esd, during the
     ! current refinement step.

     max_refshift_on_esd_par :: STR DEFAULT(" ")
     ! The parameter label for the index of the maximum parameter
     ! shift on esd, during the current refinement step.

     refinement_converged :: BIN  DEFAULT(FALSE)
     ! TRUE if the refinement has converged

     too_many_ref_iterations :: BIN  DEFAULT(FALSE)
     ! TRUE if the maximum ref iterations was exceeded

     max_residual :: REAL  DEFAULT(ZERO)
     ! Maximum residual in the unit cell

     min_residual :: REAL  DEFAULT(ZERO)
     ! Minimum residual in the unit cell

     rms_residual :: REAL  DEFAULT(ZERO)
     ! RMS residual in the unit cell

     max_atom_residual :: REAL  DEFAULT(ZERO)
     ! Maximum residual on at atom

     max_atom_residual_tag :: STR  DEFAULT(" ")
     ! Maximum residual on at atom

     min_atom_residual :: REAL  DEFAULT(ZERO)
     ! Minimum residual on at atom

     min_atom_residual_tag :: STR  DEFAULT(" ")
     ! Minimum residual on at atom

     rms_atom_residual :: REAL  DEFAULT(ZERO)
     ! RMS residual on at atom


     ! ===========================
     ! Parameter values and shifts
     ! ===========================

     dX :: VEC{REAL}*   DEFAULT_NULL
     ! These are are the parameter shifts

     X_fit :: VEC{REAL}*   DEFAULT_NULL
     ! These are are the refinement parameter values

     X_fit0 :: VEC{REAL}*   DEFAULT_NULL
     ! These are are the previous fit-iteration's parameter values

     X_ref :: VEC{REAL}*   DEFAULT_NULL
     ! These are are the refinement parameter values

     X_ref0 :: VEC{REAL}*   DEFAULT_NULL
     ! These are are the previous refine-iteration's parameter values

     ! ==========================================
     ! Near zero eigenvalues in the least-squares
     ! ==========================================

     n_0 :: INT  DEFAULT(0)
     ! The number of zero eigenvalues detected when solving the
     ! normal equations

     n_near_0 :: INT  DEFAULT(0)
     ! The number near zero eigenvalues detected when solving the
     ! normal equations

     near_0_eigenvalues :: VEC{REAL}@
     ! The near zero eigenvalues obtained when solving the normal
     ! equations. Useful to see parameter correlations.

     near_0_eigenvectors :: MAT{REAL}@
     ! The columns of eigenvectors with near zero eigenvalue obtained
     ! when solving the normal equations. Useful to see parameter
     ! correlations.

     ! ==========================================
     ! Errors and covariances in parameter values
     ! ==========================================

     esd :: VEC{REAL}@
     !  Uncertainties in the parameters; alias for esd_fit or esd_ref

     covariance_matrix :: MAT{REAL}@
     ! The covariance matrix for the asymmetric-unit parameters i.e.
     ! the inverse of the LHS of the least squares matrix.

     correlation_matrix :: MAT{REAL}@
     ! The correlation coefficient matrix for the parameters

     fragment_covariance_matrix :: MAT{REAL}@
     ! The covariance matrix for the parameters in the full fragment

   end


!  ===================
!  Crystals & clusters
!  ===================

   type UNIT_CELL

     angle :: VEC{REAL}(3)  DEFAULT(HALF_PI)
     ! The cell angles  (in radians)

     angle_error :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The cell angle errors (in radians)

     length :: VEC{REAL}(3)  DEFAULT(ONE)
     ! The cell lengths (in bohr)

     length_error :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The cell length errors (in bohr)

     volume :: REAL  DEFAULT(-ONE)
     ! The cell volumes (bohr^3)

     volume_error :: REAL  DEFAULT(ZERO)
     ! The cell volume error (bohr^3)

     direct_matrix :: MAT{REAL}(3,3)  DEFAULT(ZERO)
     ! Direct lattice cell matrix (bohr). The columns are vectors 
     ! of the three cell axes a, b, c, in the cartesian system.

     inverse_matrix :: MAT{REAL}(3,3) DEFAULT(ZERO)
     ! Inverse direct lattice cell matrix (bohr^{-1}). The columns
     ! are the coordinates of a*, b*, c* in the cartesian system.

     reciprocal_matrix :: MAT{REAL}(3,3) DEFAULT(ZERO)
     ! Reciprocal lattice cell matrix (bohr^{-1}).

     direct_U_matrix :: MAT{REAL}(3,3) DEFAULT(ZERO)
     ! Converts ADPs from crystal to cartesian systems.

     reciprocal_U_matrix :: MAT{REAL}(3,3) DEFAULT(ZERO)
     ! Converts ADPs from cartesian to crystal systems.

     info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if all the above information is consistent.

   end

   array type VEC{UNIT_CELL}

      ! A 1-D array of UNIT_CELL objects

   end

   type CRYSTAL

     CIF_chemical_formula :: STR  DEFAULT("?")
     ! The chemical formula, as found in a CIF file.

     spacegroup :: SPACEGROUP
     ! The crystal spacegroup

     unit_cell :: UNIT_CELL
     ! The crystal unit cell

     ! ===========
     ! QM fragment
     ! ===========

     n_fragment_atoms :: INT  DEFAULT(0)
     ! No. of atoms in the inputted cell fragment, used to calculate
     ! structure factors, or do wavefunction fitting.

     fragment_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of fragment atoms. NOTE: this is normally pointer
     ! copied, except when a cluster object makes a new list.
     ! See below.

     destroy_fragment_atom :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the fragment_atoms need to be destroyed

     fragment_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The geometry for a molecular fragment in the crystal (in
     ! fractional coordinates) used to calculate structure factors or
     ! do wavefunction fitting. NOTE: this should not to be confused
     ! with the "asymmetric_unit_geometry"; it may include symmetry
     ! non-unique atoms.

     fragment_offset :: VEC{INT}(3)
     ! The center point of the fragment_geometry, to the nearest unit cell

     ! =====================
     ! Asymmetric unit atoms
     ! =====================

     asymmetric_unit_source :: STR  DEFAULT("?")
     ! Where did the asymmetric unit come from?

     n_asymmetric_unit_atoms :: INT  DEFAULT(0)
     ! No. of atoms in the asymmetric unit of the unit cell.

     asymmetric_unit_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of asymmetric unit atoms.

     asymmetric_unit_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The asymmetric unit geometry. Usually inputted from a CIF file.
     ! This may or may not be the same as fragment_geometry. It is NOT
     ! used for structure factor calculations, but for cluster
     ! generation.

     prune_asymmetric_unit :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to prune the asymmetric unit. Sometimes
     ! the asymmetric unit may not be asymmetric i.e. it may have
     ! symmetry-equivalent atoms repeated. This could be because of an
     ! input or CIF file error, or it could be genuinely correct
     ! because the repeated atom corresponds to a disordered position.

     ! ===============
     ! Unit cell atoms
     ! ===============

     n_unit_cell_atoms :: INT  DEFAULT(0)
     ! Total no. of unit cell atoms.

     unit_cell_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of unit cell atoms. Needed for dispersion correction.

     unit_cell_geometry :: MAT{REAL}*  DEFAULT_NULL
     ! The full unit cell geometry, in the crystal coordinate system,
     ! generated from the asymmetric_unit_geometry.

     unique_unit_cell_atom :: VEC{INT}*  DEFAULT_NULL
     ! The list of unique (asymmetric unit) atoms in the
     ! unit_cell_geometry above

     unique_uc_atom_offset :: VEC{EVEC{INT}}@
     ! The list of (h1 h2 h3) offsets which need to be applied to the
     ! ".asymmetric_unit_geometry" to get the corresponding unit cell
     ! atom in the ".unit_cell_geometry".

     is_asym_unit_cell_atom :: VEC{BIN}*  DEFAULT_NULL
     ! Is TRUE if the the atom index corresponds to an asymmetric unit
     ! atom in unit_cell_geometry

     ! ========================================================
     ! Arrays relating fragment, unit cell, and asymmetric cell
     ! ========================================================

     same_atom_tol :: REAL  DEFAULT(CRYSTAL_SAME_ATOM_TOL)
     ! Tolerance to compare if two atom coordinates are the same
     ! in fractional coordinates

     unit_cell_tol :: REAL  DEFAULT(CRYSTAL_UNIT_CELL_TOL)
     ! Tolerance to compare if fractional position is close enough to
     ! integer to be made into an integer.

     fragment_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the fragment related information has been made

     asym_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! ".asym_atom_for_unit_cell_atom(u)" is the index of the unique
     ! unit cell atom (in ".asymmetric_unit_geometry") which generates
     ! ".unit_cell_geometry(:,u)".

     asym_symop_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! "asym_symop_for_unit_cell_atom(u)" is the index of any
     ! spacegroup symmetry operation that generates atom position
     ! "unit_cell_geometry(:,u)" from the atom with index
     ! ".asym_atom_for_unit_cell_atom(u)" (and with position in
     ! ".asymmetric_unit_geometry").

     asym_shift_for_unit_cell_atom :: MAT{INT}* DEFAULT_NULL
     ! "asym_shift_for_unit_cell_atom(u)" is the shift that was
     ! applied to get position "unit_cell_geometry(:,u)" after it was
     ! got from position of atom ".asym_atom_for_unit_cell_atom(u)"
     ! with the symop ".asym_symop_for_unit_cell_atom(u)" to get it
     ! into the unit cell.

     frag_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! ".frag_atom_for_unit_cell_atom(u)" is the index of the
     ! fragment atom (in ".fragment_geometry") which is equivalent to
     ! ".unit_cell_geometry(:,u)" *by cell translation*.  The index may
     ! be zero i.e. there is no fragment atom for unit cell atom u.

     frag_parent_for_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! ".frag_parent_for_unit_cell_atom(u)" is the index of the
     ! fragment atom in ".fragment_geometry" which is equivalent to
     ! .unit_cell_geometry(:,u) *by any crystal symop*. It may have 
     ! zero elements if the fragment does not enhcompass the whole
     ! unit cell. Compare with ".frag_atom_for_unit_cell_atom".

     unit_cell_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".unit_cell_atom_for_frag_atom(f)" is the index of the unit
     ! cell atom in ".unit_cell_geometry" which is equivalent to
     ! ".fragment_geometry(:,f)".  *by cell translation*. It is the
     ! =inverse= of the array above.

     unit_cell_shft_for_frag_atom :: MAT{INT}* DEFAULT_NULL
     ! ".unit_cell_shft_for_frag_atom(f)" is the shift for position
     ! ".fragment_geometry(:,f)" needed to make it the same as unit
     ! cell atom in ".unit_cell_atom_for_frag_atom(f)" above.

     frag_atom_for_asym_atom :: VEC{INT}* DEFAULT_NULL
     ! ".frag_atom_for_asym_atom(a)" is the index of the earliest
     ! fragment atom (in ".fragment_geometry") which is generated from
     ! the asymmetric unit atom position ".asymmeric_unit_geometry(:,a)"
     ! *by any crystal symop*.  This index may be zero meaning that
     ! there is no fragment atom for asymmetric atom "a".

     asym_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".asym_atom_for_frag_atom(f)" is the index of the asymmetric
     ! atom (in ".asymmetric_unit_geometry") which is equivalent to
     ! ".fragment_geometry(:,f)" *by any crystal symop*.  This array
     ! is used to extract the atom list of the asymmetric unit from a
     ! given fragment for cluster generation. This is the =inverse=
     ! of the array above.

     n_unique_frag_atoms :: INT  DEFAULT(0)
     ! No. of unique fragment atoms.

     unique_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! The list of unique fragment atoms, determined as the first
     ! atom in the fragment which is generated by a particular
     ! asymmetric unit atom.

     unique_index_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! The unique fragment atom index for a given frag atom.
     ! It is zero if the atom is not unqie.

     unique_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".unique_atom_for_frag_atom(f)" is the index of the
     ! symmetry-unique atom position in ".fragment_geometry" which
     ! generates ".fragment_geometry(:,f)" by the symop with index
     ! .unique_symop_for_frag_atom(u) *except for a possible
     ! translational shift*.  The unique atom is determined as the
     ! first atom in the ".fragment_geometry" which is generated by a
     ! particular asymmetric unit atom.

     unique_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".unique_symop_for_frag_atom(f)" is the index of the symop
     ! which generates ".fragment_geometry(:,f)" from
     ! ".unique_atom_for_frag_atom(f)" *except for a possible
     ! translational shift*.  The symop corresponds to the first atom
     ! in the ".fragment_geometry" which is generated by a particular
     ! asymmetric unit atom. WARNING: UNTESTED.

     asym_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".asym_symop_for_frag_atom(f)" is the index of the symop which
     ! maps an asymmetric_unit_atom into the unit cell atom which is
     ! equivalent to fragment atom "f" *by translation*. See below.

     asym_shift_for_frag_atom :: MAT{REAL}* DEFAULT_NULL
     ! "asym_shift_for_frag_atom(f)" is the shift required to map an
     ! asymmetric_unit_atom into the fragment atom after applying the
     ! 3x3 seitz operator with index ".asym_symop_for_frag_atom(f)".

     asym_symops_for_frag_atom :: VEC{EVEC{INT}}@ 
     ! ".asym_symop_for_frag_atom(f)" are the index of all symops which
     ! map an asymmetric_unit_atom into the unit cell atom "u" which is
     ! equivalent to fragment atom "f" *up to translation*. 

   ! asym_pair_for_frag_atom_pair :: VEC{INT}@
   ! ! The triangle number for the asymmetric unit atom pair that is
   ! ! symmetry-equivalent  to the frag atom pair in the fragment
   ! ! atom list.

   ! frag_pair_for_asym_atom_pair :: VEC{EVEC{INT}}@
   ! ! The triangle number for the fragment atom *pairs* that are
   ! ! symmetry-equivalent to the asymmetric atom pair in the fragment
   ! ! atom list. There may be more than one set of pairs!

     ! ==================
     ! Repetition factors
     ! ==================

     Z :: REAL  DEFAULT(ZERO)
     ! The Z factor for the molecular cell fragment in the unit cell

     use_manual_repetition_factors :: BIN  DEFAULT(FALSE)
     ! If this is set TRUE, then the user should manually enter the
     ! desired repetition factors. For experts only!

     repetition_factor :: VEC{REAL}* DEFAULT_NULL
     ! The number of times *any* fragment atom is mapped into itself 
     ! by the spacegroup. Used in structure factor calcs from a
     ! fragment geometry or a portion of it; in the latter case it can
     ! be reset manually.

     n_stabilizer_max :: INT  DEFAULT(0)
     ! The maximum number of stabilizer operations for an atom

     frag_atom_sym_factor :: VEC{INT}* DEFAULT_NULL
     ! The number of times an asymmetric unit atom is mapped into
     ! itself by the spacegroup i.e. the "site symmetry factor"
     ! however this array is for the atoms in the QM fragment.
     ! For structure factor calcs based on the asymmetric unit.

     frag_atom_stabilizer :: VEC{EVEC{INT}}@
     ! The list of indices of seitz symop's which stabilize
     ! a given atoms position. See above.

     asym_atom_sym_factor :: VEC{INT}* DEFAULT_NULL
     ! The number of times an asymmetric unit atom is mapped into
     ! itself by the spacegroup i.e. the "site symmetry factor". 
     ! For structure factor calcs based on the asymmetric unit.

     asym_atom_stabilizer :: VEC{EVEC{INT}}@
     ! The list of indices of seitz symop's which stabilize
     ! a given atoms position. See above.

     ! ==========================
     ! Unit cell connection table
     ! ==========================

     unit_cell_connection :: VEC{EVEC{EVEC{INT}}}@
     ! List of which unit cell atoms are connected to which other unit
     ! cell atoms, and in what cell e.g. "connection(i).element(k)"
     ! represents the "k"-th atom connected to atom "i" in the
     ! ".crystal.unit_cell_geometry", and it is comprised of a
     ! 4-vector, the first three elements being the cell of the "k"-th
     ! connected atom, and the last element being the index of the
     ! actual unit cell atom connected to unit cell atom "i".

     uc_vdw_connection :: VEC{EVEC{EVEC{INT}}}@
     ! As above, for vdw connections.

     unit_cell_mol_for_atom :: VEC{INT}*  DEFAULT_NULL
     ! "unit_cell_mol_for_atom(i)" is the index of the molecule to
     ! which a particular unit cell atom "i" belongs. See comments for
     ! "unit_cell_mol".

     n_unit_cell_mols :: INT   DEFAULT(0)
     ! The number of molecules in the unit cell. Fragments of
     ! molecules are counted as separate molecules.

     ! ===============
     ! Stablizer group
     ! ===============

     n_stabilizer_symops :: INT  DEFAULT(0)
     ! No. of symops needed to make the unit_cell_geometry from
     ! fragment_geometry

     stabilizer_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the symops in the spacegroup seitz list which map
     ! .fragment_geometry into itself.

     str :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for s-type gaussian functions of the
     ! stabilizer symops.

     ptr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for p-type gaussian functions of the
     ! stabilizer symops.

     dtr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for d-type gaussian functions of the
     ! stabilizer symops.

     ftr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for f-type gaussian functions of the
     ! stabilizer symops.

     gtr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for g-type gaussian functions of the
     ! stabilizer symops.

     ! ================
     ! Diffraction data
     ! ================

     data_kind :: STR  DEFAULT("?")
     ! Kind of diffraction experiment used.

     data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The structure factor and fitting data. NOTE: this can stand for
     ! either X-ray or PND data depending on the case.

     xray_data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The X-ray structure factor and fitting data

     pnd_data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The PND scalar structure factor and fitting data

     r_free_percentage :: INT  DEFAULT(0)
     ! A percentage which tells how much of the data is to be reserved
     ! and not fitted in the model

     xray_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL
     ! This is the excluded X-ray data used to calculate R free

     pnd_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL
     ! This is the excluded PND data used to calculate R free

     finalize :: BIN  DEFAULT(TRUE)
     ! Finalize/update non-cluster crystal data

     ! ===============
     ! Cluster-related
     ! ===============

     radius :: REAL, readonly  DEFAULT(CLUSTER_RADIUS)
     ! The radius of the cluster. This number determines the maximum
     ! acceptable distance between an atom in fragment_geometry and
     ! any atom in the crystal lattice. It defines the size of the
     ! cluster in the case that "generation_method" component (see
     ! below) takes the value "within_radius".

     atom_density_cutoff :: REAL  DEFAULT(CLUSTER_ATOM_DENSITY_CUTOFF)
     ! This number is used to define a cluster radius (see above). The
     ! radius is defined from it, as the *largest* distance from any
     ! atom in the asymmetric_cell_atom list where the atomic electron
     ! density becomes smaller than this number. It requires that
     ! slater or coppens bases are defined in asymmetric_unit_atom's, 
     ! and it requires that the generation method be set to
     ! "for_hirshfeld_surface". It is primarily used for clusters
     ! generated from a fragment which will correctly produce the
     ! Hirshfeld surface.

     generation_method :: STR  DEFAULT(CLUSTER_GENERATION_METHOD)
     ! This option tell how to make the cluster: whether to add atoms
     ! within a certain distance (radius) of the starting fragment,
     ! whether to make a cluster specifically for generating a
     ! hirshfeld surface, whether to just make the unit cell, or the
     ! unit cell and the starting fragment.

     defragment :: BIN  DEFAULT(CLUSTER_DEFRAGMENT)
     ! If TRUE, the cluster ends are defragmented, i.e. any atoms
     ! which are "bonded" at the ends of the cluster are included into
     ! the cluster. This oisn't a good idea for network covalent
     ! solids or zeolites: the defragmentation will end when all
     ! bonded entites with the 3x3 cube of units cells near the origin
     ! have been constructed.

     n_atoms :: INT
     ! The number of atoms in the cluster

     geometry :: MAT{REAL}* DEFAULT_NULL
     ! The (3 x .n_atoms) sized array of cluster atom positions, in
     ! fractional coordiantes

     unit_cell_offset :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Unit cell offset to use when generating an offset unit cell.

     h_min :: VEC{INT}(3), private
     ! The minimum values of the cells to search over in a within_radius cluster

     h_max :: VEC{INT}(3), private
     ! The maximum values of the cells to search over in a within_radius cluster

     n_shift :: INT  DEFAULT(0)
     ! The number of distinct translational shifts used to generate the atoms in
     ! the cluster.

     shift :: MAT{INT}* DEFAULT_NULL
     ! The (3 x .n_shift) sized list of translational shifts used to generate the
     ! cluster from the crystal unit cell atoms. See ".shift_for_atom".
     ! NOT CURRENTLY USED

     shift_for_atom :: VEC{INT}* DEFAULT_NULL
     ! ".shift_for_atom(a)" is the index of the translational shift in array
     ! ".shift", that shift being added to the position of the crystal unit cell
     ! atom whose index is given by ".occupation_list(a)/1000" in order to
     ! generate the cluster atom "a" whose position is given by ".geometry(a)".
     ! NOT CURRENTLY USED

     is_fragment_atom :: VEC{BIN}* DEFAULT_NULL
     ! is_fragment_atom(a) is TRUE if .geometry(:,a) is the position of a fragment
     ! atom, i.e. if "a" is the index of a fragm,ent atom.

     occupation_list :: VEC{INT}*  DEFAULT_NULL
     ! The list of atoms in the cluster which are occupied. This is a coded
     ! integer representing the triple of integers (h1,h2,h3), the cell where the
     ! atom resides, as well as the integer index i for the unit cell atom. The
     ! cell integers are limited to be in the range [-4,4] and at most 10^6 atoms
     ! in the cluster.

     n_molecules :: INT   DEFAULT(0)
     ! The number of molecules in the cluster

     molecule_for_atom :: VEC{INT}@
     ! An integer which tells which molecule the cluster atoms belongs to.

     molecule :: VEC{EVEC{INT}}@
     ! The list of atom indices corresponding to each molecule

     molecule_centroid :: MAT{REAL}*  DEFAULT_NULL
     ! The list of molecule centroids in fractionals
     ! NOT CURRENTLY USED

     n_unique_molecules :: INT  DEFAULT(0)
     ! The number of unique molecules in a defragmented cluster

     unique_molecule_for :: VEC{INT}*  DEFAULT_NULL
     ! The unique molecules; unique_molecule_for(mi) is the molecule
     ! earlier in the list which is symmetry equivalent by the symop
     ! given in unique_symcode_for.
     ! NOT CURRENTLY USED

     unique_symcode_for :: VEC{INT}*  DEFAULT_NULL
     ! The list of symops which maps unique_molecule_for(mi) to the
     ! non-unique molecule mi. See above.
     ! NOT CURRENTLY USED

     atom_connection :: VEC{EVEC{INT}}@
     ! atom_connection(i)[:] are those atoms which are connected to atom "i".

     unit_cell_atoms_to_suppress :: VEC{INT}* DEFAULT_NULL
     ! A list of indices into unit cell geometry. Used
     ! to suppress those atoms in cluster generation.

     cluster_info_made :: BIN  DEFAULT(FALSE)
     ! Set to true if the routine make_info has been called

   end

   type CLUSTER

     radius :: REAL  DEFAULT(CLUSTER_RADIUS)
     ! The radius of the cluster. This number determines the maximum acceptable
     ! distance between an atom in fragment_geometry and any atom in the crystal
     ! lattice. It defines the size of the cluster in the case that
     ! "generation_method" component (see below) takes the value "within_radius".

     atom_density_cutoff :: REAL  DEFAULT(CLUSTER_ATOM_DENSITY_CUTOFF)
     ! This number is used to define a cluster radius (see above). The radius is
     ! defined from it, as the *largest* distance from any atom in the
     ! asymmetric_cell_atom list where the atomic electron density becomes smaller
     ! than this number. It requires that slater or coppens bases are defined for
     ! the asymmetric_cell_atom's, and it requires that the generation method be
     ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
     ! from a fragment which will correctly produce the Hirshfeld surface.

     generation_method :: STR  DEFAULT(CLUSTER_GENERATION_METHOD)
     ! This option tell how to make the cluster: whether to add atoms within a
     ! certain distance (radius) of the starting fragment, whether to make a
     ! cluster specifically for generating a hirshfeld surface, whether to just
     ! make the unit cell, or the unit cell and the starting fragment.

     defragment :: BIN  DEFAULT(CLUSTER_DEFRAGMENT)
     ! If TRUE, the cluster ends are defragmented, i.e. any atoms which are
     ! "bonded" at the ends of the cluster are included into the cluster. This
     ! oisn't a good idea for network covalent solids or zeolites: the
     ! defragmentation will end when all bonded entites with the 3x3 cube of
     ! units cells near the origin have been constructed.

     n_atoms :: INT
     ! The number of atoms in the cluster

     geometry :: MAT{REAL}* DEFAULT_NULL
     ! The (3 x .n_atoms) sized array of cluster atom positions, in crystal
     ! coordiantes

     crystal :: CRYSTAL* DEFAULT_NULL
     ! The crystal information used to generate the cluster. The most important
     ! part used is the asymmetric unit cell geometry.

     asymmetric_unit_atom :: VEC{ATOM}* DEFAULT_NULL
     ! The atom list data associated with the *asymmetric* unit cell_geometry (see
     ! below) used to generate the cluster atom positions. It must be consistent
     ! with the crystal asymmetric unit.

     n_fragment_atoms :: INT
     ! The number of fragment atoms used to build the cluster

     fragment_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The (3 x .n_fragment_atoms) sized array of fragment atom positions used to
     ! generate the cluster: the cluster will usually be arranged as the set of
     ! atoms within a certain radius of this fragment geometry. It is in the
     ! crystal coordinate system. Note that the fragment geometry might not
     ! include an asymmetric cell unit.

     fragment_width :: VEC{REAL}(3)
     ! The width of the crystal fragment, to the nearest unit cell

     fragment_offset :: VEC{INT}(3)
     ! The center point of the fragment_geometry, to the nearest unit cell

     unit_cell_offset :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Unit cell offset to use when generating an offset unit cell.

     h_min :: VEC{INT}(3), private
     ! The minimum values of the cells to search over in a within_radius cluster

     h_max :: VEC{INT}(3), private
     ! The maximum values of the cells to search over in a within_radius cluster

     n_shift :: INT  DEFAULT(0)
     ! The number of distinct translational shifts used to generate the atoms in
     ! the cluster.

     shift :: MAT{INT}* DEFAULT_NULL
     ! The (3 x .n_shift) sized list of translational shifts used to generate the
     ! cluster from the crystal unit cell atoms. See ".shift_for_atom".
     ! NOT CURRENTLY USED

     shift_for_atom :: VEC{INT}* DEFAULT_NULL
     ! ".shift_for_atom(a)" is the index of the translational shift in array
     ! ".shift", that shift being added to the position of the crystal unit cell
     ! atom whose index is given by ".occupation_list(a)/1000" in order to
     ! generate the cluster atom "a" whose position is given by ".geometry(a)".
     ! NOT CURRENTLY USED

     is_fragment_atom :: VEC{BIN}* DEFAULT_NULL
     ! is_fragment_atom(a) is TRUE if .geometry(:,a) is the position of a fragment
     ! atom, i.e. if "a" is the index of a fragm,ent atom.

     occupation_list :: VEC{INT}*  DEFAULT_NULL
     ! The list of atoms in the cluster which are occupied. This is a coded
     ! integer representing the triple of integers (h1,h2,h3), the cell where the
     ! atom resides, as well as the integer index i for the unit cell atom. The
     ! cell integers are limited to be in the range [-4,4] and at most 10^6 atoms
     ! in the cluster.

     n_molecules :: INT   DEFAULT(0)
     ! The number of molecules in the cluster

     molecule_for_atom :: VEC{INT}@
     ! An integer which tells which molecule the cluster atoms belongs to.

     molecule :: VEC{EVEC{INT}}@
     ! The list of atom indices corresponding to each molecule

     molecule_centroid :: MAT{REAL}*  DEFAULT_NULL
     ! The list of molecule centroids in fractionals
     ! NOT CURRENTLY USED

     n_unique_molecules :: INT  DEFAULT(0)
     ! The number of unique molecules in a defragmented cluster

     unique_molecule_for :: VEC{INT}*  DEFAULT_NULL
     ! The unique molecules; unique_molecule_for(mi) is the molecule
     ! earlier in the list which is symmetry equivalent by the symop
     ! given in unique_symcode_for.
     ! NOT CURRENTLY USED

     unique_symcode_for :: VEC{INT}*  DEFAULT_NULL
     ! The list of symops which maps unique_molecule_for(mi) to the
     ! non-unique molecule mi. See above.
     ! NOT CURRENTLY USED

     atom_connection :: VEC{EVEC{INT}}@
     ! atom_connection(i)[:] are those atoms which are connected to atom "i".

     info_made :: BIN  DEFAULT(FALSE)
     ! Set to true if the routine make_info has been called

     unit_cell_atoms_to_suppress :: VEC{INT}* DEFAULT_NULL
     ! A list of indices into unit cell geometry. Used
     ! to suppress those atoms in cluster generation.

   end

   type MULTI_T_ADP

     ! ===================
     ! Calculation options
     ! ===================

     fit_method :: STR   DEFAULT("unknown")
     ! The method used to refine the ADP's

     cif_file_name :: VEC{STR}@
     ! A list of the CIF files names that contain the multi
     ! temperature ADP data. Normally ordered from lowest
     ! to highest temperature.

     V_expansion_order :: INT  DEFAULT(2)
     ! Order to expand the volumes as a polynomial series

     use_V_linear_term :: BIN  DEFAULT(TRUE)
     ! Whether to use the linear term in the expansion of the volume

     use_translations :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to refine translational modes

     use_librations :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to refine librational modes

     use_fixed_H_modes :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to use fixed high frequency local H modes
     ! aka Buergi and coworkers "epsilon" tensors.

     use_fixed_non_H_modes :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to use fixed high frequency local non-H
     ! modes aka Buergi and coworkers "epsilon" tensors.

     n_internal :: INT  DEFAULT(0)
     ! No. of internal modes to refine

     project_onto_initial_modes :: BIN  DEFAULT(FALSE)
     ! Project the mode shifts onto the starting modes.
     ! Normally used for translations and rotations.

     n_project :: INT  DEFAULT(-1)
     ! No. of initial modes (starting from the first) to use in
     ! projection

     equality_constraints :: VEC{EVEC{INT}}@
     ! A list of parameter indices which are to be made equal
     ! Indices should be ordered least to greatest. These are
     ! normally applied to mode indices and Grueneisen's.

     decoupled_parameters :: VEC{EVEC{INT}}@
     ! A list of parameters indices which are decoupled
     ! from the others

     max_iterations :: INT  DEFAULT(MULTI_T_ADP_MAX_ITER)
     ! The maximum number of iterations for the normal equations

     min_iterations :: INT  DEFAULT(MULTI_T_ADP_MIN_ITER)
     ! The minumum number of iterations for the normal equations

     tol_shift_convergence :: REAL DEFAULT(MULTI_T_ADP_TOL_SHIFT_CONV)
     ! Tolerance for convergence of the parameter shifts divided by
     ! the esd's, used when solving the normal equations

     max_allowed_shift :: REAL  DEFAULT(MULTI_T_ADP_MAX_SHIFT)
     ! The maximum allowed shift when solving the normal equations:
     ! If any one of the parameters shifts obtained from solving the
     ! normal equations is greater than this value, they are all
     ! rescaled so that the largest is this value.

     show_correlations :: BIN  DEFAULT(FALSE)
     ! Whether to display the correlation matrix or not

     min_correlation :: REAL  DEFAULT(MULTI_T_ADP_MIN_CORRELATION)
     ! The minimum value for correlation matrix elements before they
     ! are printed out in the output.

     show_near_0_eigenvectors :: BIN  DEFAULT(FALSE)
     ! Whether to display the near zero eigenvectors

     tol_near_0 :: REAL  DEFAULT(MULTI_T_ADP_TOL_NEAR_0)
     ! The tolerance used to detect near zero eigenvalues in the
     ! normal equations

     ! ================
     ! Private switches
     ! ================

     cif_files_read :: BIN   DEFAULT(FALSE)
     ! Set TRUE if the cif files have been read

     initialized :: BIN   DEFAULT(FALSE)
     ! Set up starting info

     ! =================
     ! Experimental data
     ! =================

     n_T :: INT  DEFAULT(0)
     ! The number of temperatures

     n_atom :: INT   DEFAULT(0)
     ! The number of atoms in the file

     n3N :: INT   DEFAULT(0)
     ! Three times the number of atoms

     n6N :: INT   DEFAULT(0)
     ! 6 times the number of atoms

     n9N :: INT   DEFAULT(0)
     ! 9 times the number of atoms

     atom :: VEC{ATOM}*
     ! List of atoms for the first CIF file used to construct
     ! the starting rigid modes L^rigid. *Pointer copied*.

     temperature :: VEC{REAL}@
     ! The different experimental temperatures

     temperature_sigma :: VEC{REAL}@
     ! The uncertainty in the experimental temperatures

     unit_cell :: VEC{UNIT_CELL}@
     ! The list of unit cells at the different temperatures

     unit_cell_sigma :: VEC{UNIT_CELL}@
     ! The list of unit cell errors at the different temperatures

     ADP :: VEC{EMAT{REAL}}@
     ! A list of the X-ray ADP's at the different temperatures
     ! n_T x 6 in size

     ADP_cov :: VEC{EMAT{REAL}}@
     ! For every temperature, the covariance matrix between
     ! the ADP's. Must be extracted from full covariance matrix.

     ADP_wt :: VEC{EMAT{REAL}}@
     ! For every temperature, the weights to use in the least squares.
     ! Normally the inverse of the covariance matrix between ADP's.

     ! ==========
     ! Model info
     ! ==========

     V_coeff :: VEC{REAL}@
     ! List of polynomial coefficients to expand the volume

     Delta_V_on_V :: VEC{REAL}@
     ! The relative changes in unit cell volumes

     parameter_description :: VEC{STR}@
     ! A string description of each parameter

     n_modes :: INT   DEFAULT(0)
     ! The number of modes in the model

     L :: MAT{REAL}@
     ! The list of normal modes

     lambda :: VEC{REAL}@
     ! Lagrange multipliers for mode orthogonality

     omega :: VEC{REAL}@
     ! The list of harmonic frequencies

     amplitude :: MAT{REAL}@, private
     ! The list of amplitudes for each mode omega bar each temperature

     gamma_G :: VEC{REAL}@
     ! The list of Grueneisen constants

     ! ===============================
     ! Structure refinement parameters
     ! ===============================

     iteration :: INT
     ! The iterations coiunter for structure refinement

     chi2 :: REAL
     ! The current iteration's value of chi2

     chi2_old :: REAL
     ! The previous iteration's value of chi2

     max_shift_on_esd :: REAL
     ! The maximum shift in the parameter vector divided by the esd
     ! of that parameter during a refinement step.

     max_shift :: REAL
     ! The maximum shift in the parameter vector

     n_ind_params :: INT
     ! No of independent parameters taking into account zero
     ! eigenvalues

     n_0 :: INT
     ! The number of zero eigenvalues detected when solving the
     ! normal equations

     n_near_0 :: INT
     ! The number near zero eigenvalues detected when solving the
     ! normal equations

     near_0_eigenvalues :: VEC{REAL}@
     ! The near zero eigenvalues obtained when solving the normal
     ! equations. Useful to see parameter correlations.

     near_0_eigenvectors :: MAT{REAL}@
     ! The columns of eigenvectors with near zero eigenvalue obtained
     ! when solving the normal equations. Useful to see parameter
     ! correlations.

     delta_p :: VEC{REAL}@
     ! Uncertainties in the parameters

     covariance_matrix :: MAT{REAL}@
     ! The covariance matrix for the parameters i.e.
     ! the inverse of the LHS of the least squares matrix.

     correlation_matrix :: MAT{REAL}@
     ! The correlation coefficient matrix for the parameters

   end


!  =========
!  Spherical
!  =========

   type SPHERICAL

    ! this module is essentially just methods
     n_points :: INT  DEFAULT(0)
     nfact :: INT DEFAULT(1)
     factorials :: VEC{REAL}* DEFAULT_NULL
     recur :: BIN

   end


!  ======
!  BIGINT
!  ======
 
!    type BIGINT
!        n :: INT DEFAULT(0)
!        dig :: VEC{INT}* DEFAULT_NULL
!        base :: INT DEFAULT(10)
!    end

!  ====
!  JSON
!  ====

   type JSON

      out :: TEXTFILE*, public DEFAULT_NULL
      ! Output texctfile

      name :: STR, private DEFAULT("unknown")
      ! ?

      margin :: INT, private DEFAULT(0)
      ! Margin size for the JSON file

   end


!  ======
!  Colour
!  ======

   type COLOUR

     name :: STR   DEFAULT(" ")
     ! The standard colour name for this colour.

     RGB255 :: VEC{INT}(3)   DEFAULT(0)
     ! The RGB triple for this colour as a triple of integers between 0 and 255.

   end

   type COLOUR_FUNCTION

     n_data :: INT
     ! The number of data values (and their associated colours) used to make
     ! the colour function

     data :: VEC{REAL}* DEFAULT_NULL
     ! The list of data values, from smallest to largest

     RGB :: MAT{REAL}* DEFAULT_NULL
     ! The RGB values corresponding to each data value. Their norm should be
     ! between zero and 3.

     finalized :: BIN
     ! Set TRUE if the object is ready for use

   end


!  =====================
!  Plots and isosurfaces
!  =====================

   type PLOT_GRID

     plot_kind :: STR  DEFAULT(" ")
     ! The type of plot calculation wanted

     plot_kinds :: VEC{STR}@
     ! The type of plot kinds (multiple) wanted

     plot_label :: STR  DEFAULT(" ")
     ! An optional label to describe the plot, used on archives.

     projection_direction :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! For vector fields, the vectors at each point in the grid are
     ! projected onto the (normalized) direction of this vector.

     interpolator :: INTERPOLATOR@
     ! This is used for setting defaults for isosurfaces which make
     ! use of spherical atomic densities.

     n_x :: INT  DEFAULT(PLOT_GRID_NX)
     ! The number of points on the x-axis

     n_y :: INT  DEFAULT(PLOT_GRID_NY)
     ! The number of points on the y-axis

     n_z :: INT  DEFAULT(PLOT_GRID_NZ)
     ! The number of points on the z-axis

     n_pt :: INT  DEFAULT(0)
     ! The total no. of points in the plot

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! List of atoms used to define grid axes and positions.
     ! *Pointer copied*.

     center_atom :: INT  DEFAULT(0)
     ! Use this atom as the center of the plot

     center_atoms :: VEC{INT}@ 
     ! List of center atoms

     x_atom_1, x_atom_2 :: INT
     ! These atoms define the x-axis of the plot

     y_atom_1, y_atom_2 :: INT
     ! These atoms define the y-axis of the plot (made orthogonal to
     ! the x-axis)

     z_atom_1, z_atom_2 :: INT
     ! These atoms define the z-axis of the plot.

     del_x :: REAL  DEFAULT(ONE)
     ! The distance between axis points in the plot

     del_y :: REAL  DEFAULT(ONE)
     ! The distance between axis points in the plot

     del_z :: REAL  DEFAULT(ONE)
     ! The distance between axis points in the plot

     desired_separation :: REAL  DEFAULT(ZERO)
     ! The desired separation between grid points.

     grid_points :: VEC{INT}(3) 
     ! number of grid points as requested by the user

     center :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Center of the plot

     origin :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Bottom left front point of the plot

     x_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_X_AXIS)
     ! x-axis of the plot

     y_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_Y_AXIS)
     ! y-axis of the plot

     z_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_Z_AXIS)
     ! z-axis of the plot

     width :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_WIDTH)
     ! The widths (in a.u.) of each axis of the plot

     offset :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The center of the plot is offset by this amount

     origin_atom :: BIN DEFAULT(FALSE)
     ! The bounding box will start at the center atom / center vector

     x_width_set :: BIN  DEFAULT(TRUE)
     ! If False the x_width, i.e. width(1), is to be calculated from
     ! the size of the inputted x_axis vector; or if a width has *not*
     ! been inputted.

     y_width_set :: BIN  DEFAULT(TRUE)
     ! If False the y_width, i.e. width(2), is to be calculated from
     ! the size of the inputted y_axis vector; or if a width has *not*
     ! been inputted.

     z_width_set :: BIN  DEFAULT(TRUE)
     ! If False the z_width, i.e. width(3), is to be calculated from
     ! the size of the inputted z_axis vector; or if a width has *not*
     ! been inputted.

     x_axis_defined :: BIN  DEFAULT(FALSE)
     ! Flag set true if the user has defined the x_axis in the input

     y_axis_defined :: BIN  DEFAULT(FALSE)
     ! Flag set true if the user has defined the y_axis in the input

     z_axis_defined :: BIN  DEFAULT(FALSE)
     ! Flag set true if the user has defined the z_axis in the input

     ! =================
     ! Bounding box data
     ! =================

     use_bounding_box :: BIN   DEFAULT(FALSE)
     ! IF set TRUE the bounding box has been set.

     box_center :: VEC{REAL}(3)
     ! The center of the bounding box, defined as the center of an optional
     ! inputted atom list.

     box_widths :: VEC{REAL}(3)
     ! The bounding box widths for the molecule, defined from an
     ! optional atom list.

     box_scale_factor :: REAL
     ! Scale factor for the bounding box.  Usually leave it at 1.

     box_axes :: MAT{REAL}(3,3)
     ! The axes of the bounding box, defined as the principal axes of
     ! the shape tensor (essentially the unit weighted moment of
     ! inertia tensor). Defined from an optionally inputted atom list.

     use_unit_cell_as_bbox :: BIN   DEFAULT(FALSE)
     ! IF set TRUE the bounding box is supposed to bethe unit cell.

     ! =============================
     ! Plot units, format and limits
     ! =============================

     plot_units :: STR  DEFAULT(" ")
     ! Default units for the plot: the value is used to convert the grid values

     plot_kinds_units :: VEC{STR}@
     ! Different units for each of the plot_kinds.

     plot_format :: STR  DEFAULT(" ")
     ! Default format for the plot: if blank, all known formats are produced.

     points_filename :: STR  DEFAULT("no_made-up_points")
     ! filename for file containing a made-up grid of 3D points to read in

     use_plot_max :: BIN   DEFAULT(FALSE)
     ! Whether to reset the plot maximum

     use_plot_min :: BIN   DEFAULT(FALSE)
     ! Whether to reset the plot minimum

     plot_max :: REAL   DEFAULT(ZERO)
     ! Whether to reset the plot maximum

     plot_min :: REAL   DEFAULT(ZERO)
     ! Whether to reset the plot minimum

     ! =======================
     ! Plot-kind specific data
     ! =======================

     orbital :: INT  DEFAULT(0)
     ! The orbital to plot (if any)

     HOMO_orbital :: INT  DEFAULT(0)
     ! The HOMO orbital to plot. A value "n" indicates the HOMO+"n".

     LUMO_orbital :: INT  DEFAULT(0)
     ! The LUMO orbital to plot. A value "n" indicates the LUMO+"n".

     bond_density_atom :: VEC{INT}@
     ! Pair of atoms indices whose bond density should be plotted.
     ! Triple indicates an atom within a bond.

     electric_potential_method :: STR DEFAULT("exact")
     ! Method to suse when calculating electric potential on the isosurface

     group :: INT  DEFAULT(0)
     ! Molecular group to use as central element in fragment_plot

     ! ============
     ! Contour data
     ! ============

     contour_scale :: STR   DEFAULT("log")
     ! Whether to use linear, log, positive- or negative-log on the
     ! range scale.

     contour_min_value :: REAL  DEFAULT(ZERO)
     ! Minimum value for contour

     contour_max_value :: REAL  DEFAULT(ZERO)
     ! Maximum value for contour

     contour_increment :: REAL  DEFAULT(ZERO)
     ! Value to increment contors by

     contour_min_color :: COLOUR
     ! Color for minimum-value contour

     contour_mid_color :: COLOUR
     ! Color for mid-range-contour (or the zero contour)

     contour_max_color :: COLOUR
     ! Color for maximum-value contour

     contour_color_scale :: STR  DEFAULT(" ")
     ! Explicit color scale to use (gnuplot format)

     contour_line_width :: REAL  DEFAULT(1.25)
     ! Width for cotour lines.

     contour_fade_factor :: REAL  DEFAULT(0.8)
     ! Factor to fade the contour-colors by, for the palette

     contour_tic_dps :: INT  DEFAULT(2)
     ! No of decimal places on the colorbox tics

     contour_font_size :: INT  DEFAULT(9)
     ! Font size for contour scale

     use_ruler_scale :: BIN  DEFAULT(TRUE)
     ! Whether to use a ruler scale on contour plot

     use_colorbox_scale :: BIN  DEFAULT(TRUE)
     ! Whether to plot a colorbox scale onb contour plot

   end

   type CAPPING_SQUARE

     case :: INT   DEFAULT(-1)
     ! A coded bit string to describe the particular case for capping
     ! triangles. These are essentially the same as for marching squares.

     face_number :: INT   DEFAULT(0)
     ! Integer representing which face the of the cube the capping
     ! square belongs to.  i.e. it's orientation. if face_number=1
     ! then it's the z=0 face.

     iso_value :: REAL   DEFAULT(ONE)
     ! The isovalue to be used for the isosurface

     skip_bit_string :: INT   DEFAULT(0)
     ! A bit string which tells whether to skip processing certain
     ! edges. Can be used when certain edge vertex points are already
     ! done.

     vertex_positions :: MAT{REAL}(3,0:3)   DEFAULT(ZERO)
     ! A (3 x 0:3) dimensioned list of the actual coordinates of each
     ! square vertex.  The second index is the standard capping square
     ! vertex number.

     edge_positions :: MAT{REAL}(3,0:3)   DEFAULT(ZERO)
     ! A (3 x 0:3) dimensioned list of the interpolated coordinates of
     ! the edge vertices that are shared between the marching cube and
     ! the capping square.  The second index is the standard capping
     ! square vertex number.

     value_at_vertex :: VEC{REAL}(0:3)   DEFAULT(ZERO)
     ! A (0:3) dimensioned list of the values of the function at each
     ! square vertex.

     edge_vertex_index :: VEC{INT}(0:7)   DEFAULT(0)
     ! A (0:7) dimensioned list of the  triangle vertex *indices* for
     ! each "edge" of the capping square.  Because the vertices of the
     ! square are involved in triangulation that are encoded as edges:
     ! v0 -> e4, v1 -> e5, v2 -> e6, v4 -> e7.
     ! Not all these edge are new since they include the edge vertices
     ! taken from the marching cube

     edge_vertex_positions :: MAT{REAL}(3,0:7)   DEFAULT(ZERO)
     ! A (3 x 0:7) dimensioned list of the interpolated triangle vertex
     ! coordinates on each edge of the cube (if that edge is needed).

     cap_vertex_flag :: VEC{BIN}(0:3)   DEFAULT(FALSE)
     ! Used to flag vertices of capping square which belong to caps
     ! and therefore need to be triangulated.

     n_triangle :: INT   DEFAULT(0)
     ! The number of triangles formed on this capping square.

     n_pt :: INT   DEFAULT(0)
     ! The number of points up until this square was analyzed. Used to
     ! keep a list of unique indices to define triangle vertices and
     ! points.

     no_new_vertex :: INT   DEFAULT(0)
     ! A capping square contains previously determined edge vertices
     ! (from marching cube) and new edge vertices. This contains the
     ! number of new edge vertices.

     triangle_edge_index :: MAT{INT}(3,4)   DEFAULT(0)
     ! The (3 x .n_triangle) dimensioned list of 3-edges on the
     ! capping square used to form triangles. This is just the
     ! appropriate row from the triangle_table. The maximum number of
     ! triangles is 4.

     triangle_vertex_index :: MAT{INT}(3,4)   DEFAULT(0)
     ! The (3,.n_triangle) dimensioned list of groups of 3 *unique*
     ! triangle vertex *indices*. These indices point to a unique list
     ! of points. The maximum number of triangles is 4.

     new_vertex_index :: VEC{INT}(6)   DEFAULT(0)
     ! A list of the edge indices for each new triangle vertex index.
     ! Only the vertices of the square become new edge vertices hence
     ! only can have four new vertex indices.

     edge_vertex_gradient :: MAT{REAL}(3,0:7)   DEFAULT(ZERO)
     ! A (3 x 0:7) dimensioned list of the triangle vertex normals on
     ! each edge of the capping square (if that edge is needed).

     edge_mean_curvature :: VEC{REAL}(0:7)   DEFAULT(ZERO)
     ! A (0:7) dimensioned list of the mean curvatures on each edge of
     ! the capping square that crosses the isosurface (if that edge is
     ! needed).

     edge_gaussian_curvature :: VEC{REAL}(0:7)   DEFAULT(ZERO)
     ! A (0:7) dimensioned list of the gaussian curvatures on each
     ! edge of the capping square that crosses the isosurface (if that
     ! edge is needed).

   end

   type MARCHINGCUBE

     vertex_positions :: MAT{REAL}(3,0:7)  DEFAULT(ZERO)
     ! A (3 x 0:7) dimensioned list of the actual coordinates of each
     ! cube vertex. Second index is the marching cubes vertex number.

     value_at_vertex :: VEC{REAL}(0:7)  DEFAULT(ZERO)
     ! A (0:7) dimensioned list of the values of the function at each
     ! cube vertex.

     vertex_gradient :: MAT{REAL}(3,0:7)  DEFAULT(ZERO)
     ! A (3 x 0:7) dimensioned list of the vertex gradients at each
     ! cube vertex.  Second index is the marching cubes vertex number.

     vertex_hessian :: MAT3{REAL}(3,3,0:7)  DEFAULT(ZERO)
     ! A (3 x 3 x 0:7) dimensioned list of the hessian at each cube
     ! vertex. Third index is the marching cubes vertex number.

     x_side_length :: REAL  DEFAULT(ZERO)
     ! The length of the x side of the cube

     y_side_length :: REAL  DEFAULT(ZERO)
     ! The length of the y side of the cube

     z_side_length :: REAL  DEFAULT(ZERO)
     ! The length of the z side of the cube

     axes :: MAT{REAL}(3,3)   DEFAULT(ZERO)
     ! The axes of the marching cube, if not usual x,y,z

     inverse_axes :: MAT{REAL}(3,3)   DEFAULT(ZERO)
     ! The inverse (transpose) of the axes of the marching cube

     iso_value :: REAL   DEFAULT(ZERO)
     ! The isovalue to be used for the isosurface

     accuracy :: REAL   DEFAULT(TOL(6))
     ! The function accuracy to which each isosurface point is
     ! determined

     case :: INT   DEFAULT(-1)
     ! The case number of this marching cube, for lookup in edge_table
     ! and triangle_table

     interior_case :: INT   DEFAULT(-1)
     ! The case number corresponding to a cube being wholly within a
     ! surface.  Normally this is when the interior of the surface has
     ! larger values than the exterior, and in this case the default is 0.

     exterior_case :: INT   DEFAULT(-1)
     ! The case number corresponding to a cube being wholly outside a
     ! surface.  Normally this is when the interior of the surface has
     ! smaller values than the exterior, and in this case the default
     ! is 255.

     edge_bit_string :: INT   DEFAULT(0)
     ! The edge bit string for the marching cube. This is just the
     ! appropriate element of the edge_table i.e. if the bit is set,
     ! then that edge crosses the isosurface and must be interpolated.

     skip_bit_string :: INT   DEFAULT(0)
     ! A bit string which tells whether to skip processing certain cube
     ! edges.  Can be used when certain edge vertex points are already
     ! done.

     cube_bit_string :: INT   DEFAULT(0)
     ! The grad bit string for the marching cube. This tells which
     ! *vertices* of the cube cross the isosurface and must be
     ! interpolated.

     n_edge :: INT   DEFAULT(0)
     ! The number of marching cube edges that need to be considered on
     ! this marching cube

     n_active_edge :: INT   DEFAULT(0)
     ! The number of active marching cube edges that need to be
     ! considered on this marching cube, taking into account the
     ! skip_bit_string

     n_triangle :: INT   DEFAULT(0)
     ! The number of triangles formed on this marching cube

     n_pt :: INT   DEFAULT(0)
     ! The number of points up until this cube was analyzed. Used to
     ! keep a list of unique indices to define triangle vertices and
     ! points.

     triangle_edge_index :: MAT{INT}(3,5)   DEFAULT(0)
     ! The (3 x .n_triangle) dimensioned list of 3-edges on the
     ! marching cube used to form triangles. This is just the
     ! appropriate row
     ! from the triangle_table. The maximum number of triangles is 5.

     triangle_vertex_index :: MAT{INT}(3,5)   DEFAULT(0)
     ! The (3,.n_triangle) dimensioned list of groups of 3 *unique*
     ! triangle vertex *indices*. These indices point to a unique list
     ! of points. The maximum number of triangles is 5.

     edge_vertex_positions :: MAT{REAL}(3,0:11)   DEFAULT(ZERO)
     ! A (3 x 0:11) dimensioned list of the interpolated triangle vertex
     ! coordinates on each edge of the cube (if that edge is needed).

     edge_vertex_value :: VEC{REAL}(0:11)   DEFAULT(ZERO)
     ! A (0:11) dimensioned list of the interpolated vertex values
     ! normals on each edge of the cube (if that edge is needed).

     edge_vertex_gradient :: MAT{REAL}(3,0:11)   DEFAULT(ZERO)
     ! A (3 x 0:11) dimensioned list of the interpolated triangle vertex
     ! normals on each edge of the cube (if that edge is needed).

     edge_vertex_hessian :: MAT3{REAL}(3,3,0:11)   DEFAULT(ZERO)
     ! A (3 x 3 x 0:11) dimensioned list of the interpolated triangle
     ! vertex hessians on each edge of the cube (if that edge is
     ! needed).

     edge_mean_curvature :: VEC{REAL}(0:11)   DEFAULT(ZERO)
     ! A (0:11) dimensioned list of the (interpolated) mean curvatures
     ! on each edge of the cube that crosses the isosurface (if that
     ! edge is needed).

     edge_gaussian_curvature :: VEC{REAL}(0:11)   DEFAULT(ZERO)
     ! A (0:11) dimensioned list of the (interpolated) gaussian
     ! curvatures on each edge of the cube that crosses the isosurface
     ! (if that edge is needed).

     edge_vertex_index :: VEC{INT}(0:12)   DEFAULT(0)
     ! A (0:11) dimensioned list of the *unique* triangle vertex
     ! *indices* for each edge of the marching cube (if that edge is
     ! needed). The 12-th component is used for re-use counting.

     vertex_edge_index :: VEC{INT}(12)   DEFAULT(0)
     ! A list of the edge indices for each unique triangle vertex index.
     ! Essentially, this is the reverse mapping of edge_vertex_index.

   end

   array type VEC{MARCHINGCUBE}

     ! A 1-D array of MARCHINGCUBE objects

   end

   type ISOSURFACE

     property :: STR  DEFAULT(" ")
     ! The kind of isosurface plot, if known. This helps in deciding which way the
     ! normals of the isosurface should point.

     triangulation_method :: STR  DEFAULT(" ")
     ! The method used to triangulate the isosurface.

     iso_value :: REAL  DEFAULT(ZERO)
     ! The isovalue to be used for the isosurface

     iso_values :: VEC{REAL}*  DEFAULT_NULL
     ! List of *multiple* isovalues to be used for the isosurfaces

     plot_grid :: PLOT_GRID
     ! The isosurface plotgrid

     n_pt :: INT  DEFAULT(0)
     ! The number of isosurface points

     point :: MAT{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of points on the isosurface

     n_face :: INT  DEFAULT(0)
     ! The number of triangulated faces on the isosurface

     face :: MAT{INT}*  DEFAULT_NULL
     ! A (3 x n_face) list of the triangular faces of the surface. Each face is
     ! represented by three integers which move in an anticlockwise direction when
     ! viewed from the outside.

     neighbour :: VEC{EVEC{INT}}@
     ! The linked list of neighbour vertices for each vertex.

     n_cap :: INT  DEFAULT(0)
     ! The number of triangulated faces making up the caps

     cap :: MAT{INT}*  DEFAULT_NULL
     ! A (3 x n_cap) list of the triangular faces of the capping region. Each face is
     ! represented by three integers which move in an anticlockwise direction when
     ! viewed from the outside.

     point_gradient :: MAT{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of the function gradient vectors for every point on the
     ! isosurface

     point_mean_curvature :: VEC{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of the mean surface curvatures for every point on the
     ! isosurface

     point_gaussian_curvature :: VEC{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of the gaussian surface curvatures for every point on the
     ! isosurface

     area :: REAL  DEFAULT(ZERO)
     ! The area of the isosurface, calculated from the triangulate isosurface

     volume :: REAL  DEFAULT(ZERO)
     ! The volume of the isosurface, calculated from the triangulate isosurface.

     an_volume :: REAL  DEFAULT(ZERO)
     ! The volume of the isosurface, calculated from the triangulate isosurface by
     ! using the average face normal for each triangle face. The average face
     ! normal is calculated from the average of the norms of the point_gradient's
     ! at each surface point.

     volume_min :: REAL  DEFAULT(ZERO)
     ! A lower bound to the interior volume of the isosurface, calculated by
     ! counting the number of cubes inside the surface.

     volume_max :: REAL  DEFAULT(ZERO)
     ! An upper bound to the interior volume of the isosurface, calculated by
     ! counting the number of cubes inside and on the surface.

     n_skip :: INT  DEFAULT(0)
     ! The number of function evaluations skipped (recursive method only)
     ! This is in fact worked out by counting the total number of evaluations.

     level :: INT  DEFAULT(0)
     ! The current level to which the initial box has been divided, in the
     ! recursive marching cube algorithm.

     final_level :: INT  DEFAULT(0)
     ! The final level to which the initial box must be divided, in the
     ! recursive marching cube algorithm.

     scan_level :: INT  DEFAULT(0)
     ! The level to which the initial box must be divided, in the recursive
     ! marching cube algorithm, to achieve resolution of all important features.
     ! It is determined by the .minimum_scan_division setting; or if this is
     ! smaller than the .minimum_scan_level, that value is used instead.

     minimum_scan_level :: INT  DEFAULT(ISOSURFACE_MINIMUM_SCAN_LEVEL)
     ! The smallest acceptable scan level used in the recursive marching cubes
     ! algorithm.

     minimum_scan_division :: REAL  DEFAULT(ZERO)
     ! The minimum acceptable voxel side length to which the initial box must be
     ! divided, in the recursive marching cube algorithm, to achieve resolution of
     ! all important features. The minimum_scan_level (above) may override this
     ! setting.

     voxel_proximity_factor :: REAL  DEFAULT(ISOSURFACE_VOXEL_PROXIMITY_FACTOR)
     ! Setting this value determines when a voxel is deemed to be "close" to the
     ! isosurface, and hence should be subdivided. It works by seeing if the
     ! .iso_value is within this factor times the difference between the maximum
     ! and minimum values on the voxel vertices. If it is, then the voxel is
     ! "close" to the surface.

     cube :: MARCHINGCUBE
     ! The marching cube used to generate the isosurface

     cap_square :: CAPPING_SQUARE
     ! The cap square used to generate the caps on the boundary of the plot grid

     del_x :: REAL   DEFAULT(ONE)
     ! The current box x side length in the recursive marching cubes algorithm.

     del_y :: REAL   DEFAULT(ONE)
     ! The current box y side length in the recursive marching cubes algorithm.

     del_z :: REAL   DEFAULT(ONE)
     ! The current box z side length in the recursive marching cubes algorithm.

     x :: INT  DEFAULT(0)
     ! The (partial) x-coordinate of the box in the recursive marching cubes
     ! algorithm.  This is a binary number, with each bit from the right
     ! representing a segment double the size to which the current box belongs.

     y :: INT  DEFAULT(0)
     ! The (partial) y-coordinate of the box in the recursive marching cubes
     ! algorithm.  This is a binary number, with each bit from the right
     ! representing a box double the size to which the current box belongs.

     z :: INT  DEFAULT(0)
     ! The (partial) z-coordinate of the box in the recursive marching cubes
     ! algorithm.  This is a binary number, with each bit from the right
     ! representing a box double the size to which the current box belongs.

     map :: MAP{VEC{INT},VEC{INT}}@
     ! A map table storing marching cube edge_vertex_index information as a
     ! function of the cube coordinates, [.x,.y,.z]

     small_map :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to prune dead elements from the map table

     big_interior :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the interior of the isosurface is bigger than the exterior,
     ! i.e. if the point_normals are to be reversed on output. This switch could
     ! probably be determined automatically, assuming the botton left had corner
     ! of the plot (the first point) was "outside".

     cap_ends :: INT  DEFAULT(0)
     ! Set non-zero if you want the ends of the isosurface on the
     ! bounding cube to be capped. Set less than one if you want values
     ! less than the isosurface capped, or greater than one if you want
     ! values greater than the iso value capped.

     suppress_caps :: BIN DEFAULT(FALSE)
     ! If TRUE caps are not outputed in put_faces even if they have been generated.

     surface_property :: STR  DEFAULT(" ")
     ! The name of a surface property to plot or calculate on the isosurface
     ! surface.

     surface_property_values :: VEC{REAL}* DEFAULT_NULL
     ! The values of .surface_property, evaluated on the isosurface surface.

     surface_iso_values :: VEC{REAL}*  DEFAULT_NULL
     ! The values of the iso_value on the surface, in the case when multiple
     ! isosurfaces have been calculated and merged together into a single surface.

     surface_point :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! A special point which lies on or near the isosurface, used for calculations
     ! of connected area, for example.

     chop_surface_property :: BIN  DEFAULT(FALSE)
     ! When plotting a surface, whether to chop the surface property accorsding to
     ! the lower and upper bounds specified below, rather than scaling the
     ! smallest value to zero and the largest to one.

     surface_property_lb :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB)
     ! A lower bound to the property value, for calculating surface areas, and for
     ! chopping the range of surface property values.

     surface_property_ub :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB)
     ! A upper bound to the property value, for calculating surface areas, and for
     ! chopping the range of surface property values.

     surface_prop_lb_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB_ABS)
     ! A lower bound to the absolute value of the property, for calculating the
     ! log of the surface property values.

     surface_prop_ub_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB_ABS)
     ! A upper bound to the absolute value of the property, for calculating the
     ! log of the surface property values.

     colour :: COLOUR_FUNCTION*  DEFAULT_NULL
     ! A colourfunction used for colouring the isourface

     atom :: VEC{ATOM}*  DEFAULT_NULL
     ! A list of atoms associated with the isosurface.
     ! *Pointer copied*.

     interpolator :: INTERPOLATOR@
     ! This is used for setting defaults for isosurfaces which make
     ! use of spherical atomiuc densities.

     CX_output_fingerprint :: BIN DEFAULT(FALSE)
     ! Set TRUE to output the fingerprint data during a put_CX call.

     CX_fingerprint_grid :: INT DEFAULT(2)
     ! Sets the resolution of the fingerprint binning grid

     CX_output_distance_properties :: BIN DEFAULT(FALSE)
     ! Set TRUE to output di, de and dnorm properties during put_CX call.

     CX_output_shape_properties :: BIN DEFAULT(FALSE)
     ! Set TRUE to output shape index and curvedness properties during put_CX call.

     hirshfeld_power_factor :: INT DEFAULT(1)
     ! Raise densities to this power for generation of
     ! Hirshfeld surfaces

   end


!  =================================
!  Wavefunction methods & treatments
!  =================================

   type SCFDATA

     ! ========
     ! SCF kind
     ! ========

     scf_kind :: STR  DEFAULT(" ")
     ! The kind of SCF calculation to perform

     ! ====
     ! ELMO
     ! ====

     use_NOMO :: BIN, readonly  DEFAULT(FALSE)
     ! Whether to use non-orthogonal MO's of any type

     use_ELMO :: BIN, readonly  DEFAULT(FALSE)
     ! Whether to use extremely localised MO's of any type

     use_ELMO_01 :: BIN, readonly  DEFAULT(FALSE)
     ! Whether to use ELMO(0,1) as defined by Davidson & Jayatilaka

     use_ELMO_11 :: BIN, readonly  DEFAULT(FALSE)
     ! Whether to use ELMO(1,1) as defined by Davidson & Jayatilaka

     elmo_b :: INT, readonly  DEFAULT(0)
     ! Degree of connectivity for ELMO basis functions

     elmo_p :: INT, readonly  DEFAULT(1)
     ! Degree of connectivity for ELMO particle interactions

     ! ======================
     ! DFT functional options
     ! ======================

     dft_exchange_functional :: STR, readonly  DEFAULT(SCFDATA_DFT_EXCHANGE_FUNCTIONAL)
     ! The DFT exchange functional to be used

     dft_correlation_functional :: STR, readonly  DEFAULT(SCFDATA_DFT_CORRELATION_FUNCTIONAL)
     ! The DFT correlation functional to be used

     using_GGA_exchange :: BIN, readonly  DEFAULT(SCFDATA_USING_GGA_EXCHANGE)
     ! TRUE if the exchange functional uses the generalized gradient
     ! approximation, otherwise false.

     using_hybrid_exchange :: BIN, readonly  DEFAULT(SCFDATA_USING_HYBRID_EXCHANGE)
     ! TRUE if the exchange functional uses a mixture of exact exchange
     ! and exchange functionals

     hybrid_exchange_factor :: REAL DEFAULT(0.2)
     ! quantity of hybrid exchange to use for hybrid DFT functionals


     using_GGA_correlation :: BIN, readonly  DEFAULT(SCFDATA_USING_GGA_CORRELATION)
     ! TRUE if the correlation functional uses the generalized gradient
     ! approximation, otherwise false.

     ! ==================
     ! Iteration counters
     ! ==================

     iteration :: INT  DEFAULT(0)
     ! The interation count for the SCF procedure

     total_iterations :: INT  DEFAULT(0)
     ! The total interation count for the SCF procedure, which does not get reset
     ! after each lambda increment, in the case of a constrained SCF procedure.

     lambda_iteration :: INT, readonly  DEFAULT(0)
     ! Lambda iteration count for the constrained SCF procedure

     min_iterations :: INT, readonly  DEFAULT(SCFDATA_MIN_ITERATIONS)
     ! The minimum number of SCF iterations to perform

     max_iterations :: INT, readonly  DEFAULT(SCFDATA_MAX_ITERATIONS)
     ! The maximum number of SCF iterations to perform

     ! ===============
     ! Stored energies
     ! ===============

     nuclear_repulsion_energy :: REAL  DEFAULT(ZERO)
     ! Nuclear repulsion energy for the associated molecule

     nuclear_attraction_energy :: REAL  DEFAULT(ZERO)
     ! Electron nuclear attraction energy for the associated molecule

     charge_attraction_energy :: REAL  DEFAULT(ZERO)
     ! point-charge attraction energy for the associated molecule

     electron_repulsion_energy :: REAL  DEFAULT(ZERO)
     ! Electron-electron repulsion energy for the associated molecule

     kinetic_energy :: REAL  DEFAULT(ZERO)
     ! Electron kinetic energy for the associated molecule

     dft_energy_correction :: REAL  DEFAULT(ZERO)
     ! The DFT energy correction to the SCF energy for the associated molecule

     dft_alpha_energy_correction :: REAL  DEFAULT(ZERO)
     ! The DFT alpha energy correction to the SCF energy for the associated molecule

     dft_beta_energy_correction :: REAL  DEFAULT(ZERO)
     ! The DFT beta energy correction to the SCF energy for the associated molecule

     E_initial :: REAL  DEFAULT(ZERO)
     ! The initial-guess SCF energy

     ! Current energies

     energy :: REAL  DEFAULT(ZERO)
     ! The SCF energy for the associated molecule

     old_energy :: REAL  DEFAULT(ZERO)
     ! The SCF energy from the previous SCF cycle

     delta :: REAL  DEFAULT(ZERO)
     ! The change in the main SCF variable (usually the energy) between cycles

     ! ====================
     ! Constrained SCF data
     ! ====================

     lambda :: REAL, readonly  DEFAULT(ZERO)
     ! The initial lambda value to use in a constrained SCF procedure

     initial_lambda :: REAL, readonly  DEFAULT(ZERO)
     ! The starting lambda value in a constrained SCF procedure

     lambda_max :: REAL, readonly  DEFAULT(ZERO)
     ! The maximum lambda value to use in a constrained SCF procedure

     lambda_step :: REAL, readonly  DEFAULT(ONE)
     ! The value to step the lambda value between lambda cycles in a
     ! constrained SCF calc.

     fit_value :: REAL, readonly  DEFAULT(ZERO)
     ! The value of E + lambda * penalty in a constrained SCF calc.
     ! Penalty can be the Chi2, or a combination of Chi2's if more than one
     ! type of diffraction data is to be fitted.

     old_fit_value :: REAL, readonly  DEFAULT(ZERO)
     ! The value of E + lambda * penalty of the previous iteration in a
     ! constrained  SCF calc.

     penalty :: REAL  DEFAULT(ZERO)
     ! Penalty statistic for a constrained SCF calc

     old_penalty :: REAL  DEFAULT(ZERO)
     ! Penalty statistic for a constrained SCF calc of the previous iteration

     zero_oo_constraint_block :: BIN, readonly   DEFAULT(FALSE)
     ! Zero the occ-occ block of the constraint matrix. This should
     ! not affect the answer but only the canonicalisation


     crystal :: CRYSTAL*  DEFAULT_NULL
     ! The crystal information for the diffraction experiment

     ! =====================
     ! Initial guess options
     ! =====================

     initial_density :: STR, readonly  DEFAULT("core")
     ! The kind of density matrix to start the SCF calc

     initial_MOs :: STR, readonly  DEFAULT(" ")
     ! The kind of initial MO's to start the SCF calc

     restart_SCF :: BIN, readonly  DEFAULT(FALSE)
     ! This is set TRUE if restarting from density *or* MOs

     initial_Us :: STR, readonly  DEFAULT(" ")
     ! The kind of initial U matrices to start the CPHF from

     use_default_guess_options :: BIN, readonly  DEFAULT(TRUE)
     ! Use the default SCF options for promolecule or group SCF
     ! initial guess (except that output is FALSE); otherwise use
     ! current scfdata options for promolecule/group SCF guess.

     initial_atomic_states :: MAT{INT}*  DEFAULT_NULL
     ! A (nx2) matrix which holds the charges and multiplicities of
     ! the n unique atoms in the molecule (as presented by the atom
     ! order), used for nondefault ANO & promolecule initial guess.

     ! ===============
     ! SCF convergence
     ! ===============

     convergence :: REAL, readonly  DEFAULT(SCFDATA_CONVERGENCE)
     ! A number which measures the convergence of the SCF

     damp_finish :: INT, readonly  DEFAULT(DIIS_START_ITERATION)
     ! Iteration when density matrix damping is turned off

     damp_factor :: REAL, readonly  DEFAULT(SCFDATA_DAMP_FACTOR)
     ! The damping factor to use

     level_shift_finish :: INT, readonly  DEFAULT(DIIS_START_ITERATION)
     ! Iteration when level shifting is turned off

     level_shift :: REAL, readonly  DEFAULT(SCFDATA_LEVEL_SHIFT)
     ! Value to level shift the virtual orbitals

     ! =================
     ! Linear dependence
     ! =================

     linear_dependence_tol :: REAL, readonly   DEFAULT(SCFDATA_LINEAR_DEPENDENCE_TOL)
     ! Eigenvalues of the overlap matrix smaller than this value are level shifted.

     linear_dependence_shift :: REAL, readonly   DEFAULT(SCFDATA_LINEAR_DEPENDENCE_SHIFT)
     ! A level shift to apply to eigenvalues of the overlap matrix which are
     ! smaller than the above tolerance. If tolerance is zero, no shifting is done.

     min_overlap_mx_eigenvalue :: REAL, readonly  DEFAULT(ZERO)
     ! Minimum overlap matrix eigenvalue

     n_small_S_eigenvalues :: INT,   readonly  DEFAULT(0)
     ! Number of small overlap matrix eigenvalues

     n_neg_S_eigenvalues :: INT,   readonly  DEFAULT(0)
     ! Number of negative overlapm matrix eigenvalues

     ! ========
     ! Accuracy
     ! ========

     MO_gradient_stepsize :: REAL, readonly  DEFAULT(0.01d0)
     ! The stepisize to use for updating the orbitals

     max_update_stepsize :: REAL, readonly  DEFAULT(0.01d0)
     ! The maximum update stepsize to use for updating any SCF object, e.g. the orbitals

     eri_disk_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_DISK_CUTOFF)
     ! Cutoff for the two electron integrals, on disk

     eri_schwarz_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_SCHWARZ_CUTOFF)
     ! Cutoff for the two electron integrals

     eri_J_density_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_J_DENSITY_CUTOFF)
     ! Cutoff for the J density matrix elements in Schwarz test

     eri_K_density_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ERI_K_DENSITY_CUTOFF)
     ! Cutoff for the K density matrix elements in Schwarz test

     eri_bf_overlap_cutoff :: REAL, readonly DEFAULT(SCFDATA_ERI_BF_OVERLAP_CUTOFF)
     ! The cutoff for the ERI Schwarz test.

     eri_primitive_pair_cutoff :: REAL, readonly DEFAULT(SCFDATA_ERI_PAIR_CUTOFF)
     ! The cutoff for the exponential prefactor for the product of two
     ! gaussian primitives, below which that primitive pair is ignored in the
     ! calculation of the ERI's.

     atom_overlap_cutoff :: REAL, readonly  DEFAULT(SCFDATA_ATOM_OVERLAP_CUTOFF)
     ! The value of the maximum overlap between basis functions on two different
     ! atoms, below which the atoms are considered *not* overlapping. This is used
     ! to defined the .overlapping_atoms array used in linear scaling DFT matrix
     ! element evaluation.

     XC_atom_separation_cutoff :: REAL, readonly  DEFAULT(SCFDATA_XC_ATOM_SEPARATION_CUTOFF)
     ! The exchange correlation matrix in DFT calculations is *not* calculated
     ! for basis functions on atoms separated by *more* than this distance.
     ! This allows linear scaling of the exchange correlation terms (except for a
     ! negligible N^2 contribution due to the atom-distance test).

     ! ================================
     ! DIIS convergence related options
     ! ================================

     ee_adiabatic_constant :: REAL, readonly  DEFAULT(ONE)
     ! Constant to multiply the V_ee interactions, for adiabatic
     ! coupling calculations.

     use_Fermi_Amaldi :: BIN, readonly  DEFAULT(FALSE)
     ! Whether to use Fermi-Amaldi in the SCF procedure
     ! (ignores exchange)

     ! ================================
     ! DIIS convergence related options
     ! ================================

     diis :: DIIS
     ! For diis extrapolation (usually Fock matrix DIIS extrapolation)
     ! SHould we make this allocatable?

     CP_diis :: VEC{DIIS}@
     ! For coupled-perturbed DIIS extrapolation

     diis_error :: REAL, readonly  DEFAULT(ZERO)
     ! The DIIS error

     old_diis_error :: REAL, readonly  DEFAULT(ZERO)
     ! The DIIS error of the previous iteration

     diis_error_temp_cutoff :: REAL, readonly  DEFAULT(DIIS_ERROR_TEMP_CUTOFF)
     ! The DIIS error at which pFON fractional occupation numbers are
     ! turned off and the temperature is set to zero.

     ! ======
     ! L BFGS
     ! ======

     bfgs :: L_BFGS
     ! For low memory BFGS extrapolation/minimization

     ! ==========================
     ! General Complex HF options
     ! ==========================

     sl_1e_factor :: REAL, readonly  DEFAULT(ONE)
     ! Factor to apply to the 1-electron S.L terms

     sl_2e_factor :: REAL, readonly  DEFAULT(ONE)
     ! Factor to apply to the 2-electron S.L terms

     quantization_axis :: VEC{REAL}(3), readonly  DEFAULT(([ZERO,ZERO,ONE]))
     ! Quantization axis for GCHF, if using initial MO's as a guess

     ! ======================
     ! Finite temperature SCF
     ! ======================

     temperature :: REAL, readonly  DEFAULT(ZERO)
     ! The electronic temperature

     E_Fermi :: REAL, readonly  DEFAULT(ZERO)
     ! The Fermi energy

     Ea_Fermi :: REAL, readonly  DEFAULT(ZERO)
     ! The alpha-electron Fermi energy

     Eb_Fermi :: REAL, readonly  DEFAULT(ZERO)
     ! The beta-electron Fermi energy

     ! ================
     ! Logical switches
     ! ================

     do_outputs :: BIN, readonly  DEFAULT(FALSE)
     ! True if output is wanted for each iteration cycle of the XCW.
     ! this will messup the stdout, but will output cifs, fcf, fco and
     ! residual cube for every lambda step.

     output :: BIN, readonly  DEFAULT(TRUE)
     ! True if output is wanted; sometimes we supress output e.g. when we do
     ! atomic SCF calculations to get a good initial guess, or if we are just not
     ! interested in the SCF output.

     output_results :: BIN, readonly  DEFAULT(TRUE)
     ! True if SCF results output is wanted; for unit tests.
     ! If *only* SCF results are wanted, set .output FALSE.

     guess_output :: BIN, readonly  DEFAULT(FALSE)
     ! TRUE if the output for the initial guess is to be printed.

     is_guess :: BIN, readonly  DEFAULT(FALSE)
     ! TRUE if this SCF is an initial guess.

     test :: BIN, readonly  DEFAULT(FALSE)
     ! Test flag. Set True if some test procedure is to be executed

     stabilize_density :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if the density is to be averaged over the stabilizer
     ! group in xray constrained calculations (rhf only so far).

     ! ==================
     ! Relativity options
     ! ==================

     relativity_kind :: STR, readonly  DEFAULT("none")
     ! What kind of relativity are you using?

     using_iotc :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the 1 electron IOTC terms

!    using_SO_coupling :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron DKH terms

     DK1_PCE :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the DK1_PCE terms

     DK2_PCE :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the DK2_PCE terms

     DK1 :: BIN, readonly  DEFAULT(TRUE)
     ! Switch on/off the DK1 terms

     DK2 :: BIN, readonly  DEFAULT(TRUE)
     ! Switch on/off the DK2 terms

     DK3 :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the DK3 terms

     using_ppzpp :: BIN, readonly DEFAULT(FALSE)
     ! switch on/off the PCE correction

     PCE_CORR :: BIN, readonly DEFAULT(FALSE)
     ! switch on/off the PCE correction

     using_SO_FDFF :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the SO corrections to SO scalar terms
     ! which are missed in the works of Hess

     using_1e_zora_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the 1 electron ZORA terms

     using_pauli_terms :: BIN, readonly  DEFAULT(FALSE)
     ! Use the Pauli terms

     using_1e_sl_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the 1 electron S.L term

     using_1e_srxa_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the 1 electron diamagnetic term

     using_2e_sl_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the 2 electron S.L terms

     using_aa_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the A.A diamagnetic term

     using_bl_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the B.L term (complex SCF reqd.)

     using_bs_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the B.S term

     using_bs_t_term :: BIN, readonly  DEFAULT(FALSE)
     ! Switch on/off the (B.S) T_e term

     ! =========================
     ! Convergence/Build options
     ! =========================

     using_damping :: BIN, readonly  DEFAULT(SCFDATA_USING_DAMPING)
     ! True if using damping

     using_pFON :: BIN, readonly  DEFAULT(FALSE)
     ! True if using pFON

     using_FON :: BIN, readonly  DEFAULT(FALSE)
     ! True if using finite temperatures

     using_delta_build :: BIN, readonly  DEFAULT(TRUE)
     ! True if using an incremental (delta) fock build as advocated by Almlof.

     using_direct_scf :: BIN, readonly  DEFAULT(TRUE)
     ! True if using direct SCF

     using_diis :: BIN, readonly  DEFAULT(TRUE)
     ! True if using DIIS extrapolation for fock matrices

     use_BFGS :: BIN, readonly  DEFAULT(TRUE)
     ! True if using L BFGS for minimization; currently only for NOMO

     use_LSQ :: BIN, readonly  DEFAULT(FALSE)
     ! True if using least squares; currently only for ELMO

     using_level_shift :: BIN, readonly  DEFAULT(SCFDATA_USING_LEVEL_SHIFT)
     ! True if using level shifting

     using_orbital_locking :: BIN, readonly  DEFAULT(FALSE)
     ! True if using orbital locking

     using_exponential_update :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if using an antisymmetric exponential update

     using_MO_gradient_update :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if using the gradient of the orbital coefficients to
     ! update the coefficients

     using_NDDO :: BIN, readonly  DEFAULT(FALSE)
     ! Neglect of diatomic differential overlap

     using_NUDO :: BIN, readonly  DEFAULT(FALSE)
     ! Neglect of unconnected differential overlap

     using_PIE :: BIN, readonly  DEFAULT(FALSE)
     ! Projective integral expansion method (PIE) developed by Mayer.
     ! See Mayer, CPL 332, 381 (2000).

     ! =================
     ! Coupled-perturbed
     ! =================

     n_pert :: INT, readonly  DEFAULT(0)
     ! No. of perturbations in CP equations

     using_CP_diis :: BIN, readonly  DEFAULT(TRUE)
     ! True if using coupled-perturbed DIIS extrapolation

     ! ===================
     ! Cluster/crystal SCF
     ! ===================

     restart_skip_asfs :: BIN   DEFAULT(FALSE)
     ! If set true then not only MOs and/or density matrices are
     ! assumed present, but atomic structure factors (ASFs) are
     ! assumed to be on disk. Use for efficient restart.

     kappa :: REAL DEFAULT(ZERO)
     ! The kappa value used to multiply the orthogonality projector, uses in an
     ! embedded SCF procedure

     using_cluster_charges :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if you want to surround the molecule with charges.

     using_SC_cluster_charges :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if you want to surround the molecule with *self consistent* charges.
     ! These charges are reculculated every SCF iteration.

     using_qq_cluster_charges :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if you want to surround the molecule with *self consistent*
     ! quadrupole charges. You still need to set use_sc_cluster_charges

     cluster_radius :: REAL, readonly  DEFAULT(SCFDATA_CLUSTER_RADIUS)
     ! Radius of the cluster to use to generate cluster

     cluster :: CLUSTER*  DEFAULT_NULL
     ! A cluster used to get the cluster charges

     defragment :: BIN, readonly  DEFAULT(TRUE)
     ! The defragment option in case of network compounds should be
     ! false Lorraine

     save_cluster_charges :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if you want to save the cluster charges

     cluster_charges :: VEC{REAL}*   DEFAULT_NULL
     ! List of saved cluster charges

     cluster_charge_positions :: MAT{REAL}*   DEFAULT_NULL
     ! List of saved cluster positions for the charges

     using_SC_Lorentz_fields :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if you want to use local Lorentz fields from atomic
     ! point charges and point dipoles, summed to infinity using
     ! the Lorentz tensor.

     delete_scf_archives :: BIN  DEFAULT(TRUE)
     ! Delete all disk archives but the MO's and density matrix after
     ! an SCF calculation. Keeping archives can save work later.

     delete_all_archives :: BIN  DEFAULT(FALSE)
     ! Delete all archives, even the molecular orbitals.
     ! They will only exist in core. Saves disk writes.

     ! ===================
     ! SCF iteration table
     ! ===================

     table_info :: VEC{EVEC{STR}}@
     ! A list of list of informational margin notes

     table :: VEC{TABLE_COLUMN}@
     ! The SCF iteration table

     ! ================================
     ! finite gaussian nucleus tunnings
     ! ================================

     nhf :: INT DEFAULT(0)
     ! change of the radius of nucleus for obtaining the
     ! numerical derivative of energy

   end

   type ROBY

     roby_kind :: STR
     ! The kind of Roby calculation to perform

     ! =====
     ! Atoms
     ! =====

     atom_list :: VEC{INT}@ 
     ! The indices of a list of roby atoms to be used in some way
     ! for population analysis

     atom_group :: VEC{EVEC{INT}}@
     ! The indices of the roby atoms defining different spaces

     atom_a :: VEC{INT}@
     ! The indices of the atoms defining space V_A

     atom_b :: VEC{INT}@
     ! The indices of the atoms defining space V_B

     atom_ab :: VEC{INT}@
     ! The indices of the roby atoms defining spaces V_A and V_B

     ! =======
     ! Options
     ! =======

     is_hyper_analysis :: BIN, readonly  DEFAULT(FALSE)
     ! Whether the analysis is a hypervalent one which treats bonding
     ! from space .atom(A) to everything not in any .atom(:)

     show_calcs :: BIN  DEFAULT(FALSE)
     ! If TRUE show NAO at theta calculations

     use_NAOs :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to use NAO atomic projectors instead of
     ! ANO's as defined in the original Gould et al 2008 TCA paper.

     use_spherical_averaging :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to use spherically averaged NAOs. 

     use_projected_NAOs :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to use projected NAO atomic projectors
     ! instead of NAOs.

     analyze_all_atom_pairs :: BIN  DEFAULT(ROBY_ANALYZE_ALL_ATOM_PAIRS)
     ! If set TRUE, the bond index information is printed out ONLY for every
     ! atom pair which is considered "bonded". Otherwise all pairs of atoms are
     ! analyzed. This is onlyeffective when an atom_list is defined.

     analyze_vdw_atom_pairs :: BIN  DEFAULT(FALSE)
     ! ANalyze vdw bonded pairs only

     bond_range_factor :: REAL  DEFAULT(ROBY_BOND_RANGE_FACTOR)
     ! Used to extend the range of the CCDC bonded test.

     zero_angle_cutoff :: REAL  DEFAULT(ROBY_ZERO_ANGLE_CUTOFF*RADIAN_PER_DEGREE)
     ! Angles (in radians) *less* than this are regareded as zero

     occupied_ANO_cutoff :: REAL  DEFAULT(ROBY_OCCUPIED_ANO_CUTOFF)
     ! Atomic natural orbitals with occupations less than this number
     ! are regarded as unoccupied. This number is used to define the Roby
     ! atomic projector

     output_theta_info :: BIN  DEFAULT(ROBY_OUTPUT_THETA_INFO)
     ! If set TRUE, the bond index information is printed out for every
     ! space V_theta. See the paper for details.

     output_ci_latex_labels :: BIN  DEFAULT(FALSE)
     ! If set TRUE then this will output c and i bond indices
     ! above and below the bond when making RGBI pictures.
     ! Default is to output the total bond index and % covalency.

     ! =====
     ! Bonds
     ! =====

     n1 :: VEC{REAL}@
     ! Roby population for each atom-group

     n2 :: MAT{REAL}@
     ! Roby pair population for each atom-group pair
     ! NOTE: these are *not* shared populations
     ! The not atom-group populations

     n_all :: REAL  DEFAULT(ZERO)
     ! Population of all the atoms

     n_shared :: REAL  DEFAULT(ZERO)
     ! Roby multiple shared population for a specified atom-group

     cov_index :: MAT{REAL}@
     ! Gould covalent bond indices for each pair of atoms

     ion_index :: MAT{REAL}@
     ! Gould ionic bond indices for each pair of atoms

     bond_index :: MAT{REAL}@
     ! Gould Bond indices for each pair of atoms

     percent_covalency_P :: MAT{REAL}@
     ! The % covalency of the given bond pair using the Pythagorean
     ! formula

     percent_covalency_A :: MAT{REAL}@
     ! The % covalency of the given bond pair using the Araki angle
     ! formula

     ! =======
     ! Charges
     ! =======

     gould_charge :: VEC{REAL}@
     ! Roby-Gould charges

     cruickshank_charge :: VEC{REAL}@
     ! Cruikshank-Avramedes charges

     summed_n2 :: VEC{REAL}@
     ! Summed atom-group pair populations

     summed_n3 :: VEC{REAL}@
     ! Summed atom-group triple populations

     subgroup_pop :: VEC{REAL}@
     ! The subgroup population contributions when calculating multiple shared
     ! populations.

     proportion_a :: MAT{REAL}@
     ! The proportion to partition for atom A, between two atoms (A,B)
     ! using Gould's probabilistic scheme

     charge :: INT
     ! The total charge on the molecule

     ! ===================
     ! Theta subspace info
     ! ===================

     theta_C :: MAT{REAL}@
     ! The matrix of the covalent theta orbitals

     eigen_C :: VEC{REAL}@
     ! The array of the covalent theta eigenvalues

     theta_angle :: VEC{REAL}@
     ! The array of covalent theta angles

     pair :: VEC{INT}@
     ! An array which pairs the positive eigenvalues in eval_C with the
     ! negative eigenvalues, thus definining each theta subspace

     theta_I :: MAT{REAL}@
     ! The matrix of the ionic theta orbitals

     eigen_I :: VEC{REAL}@
     ! The matrix of the ionic theta eigenvalues

     ! =====================
     ! Theta population info
     ! =====================

     theta_pop_C :: VEC{REAL}@
     ! Covalent theta orbital populations

     theta_pop_C_A :: VEC{REAL}@
     ! Atom "A" theta covalent orbital popualtions

     theta_pop_C_B :: VEC{REAL}@
     ! Atom "B" theta covalent orbital populations

     theta_pop_I :: VEC{REAL}@
     ! Ionic theta orbital populations

     theta_pop_I_A :: VEC{REAL}@
     ! Atom "A" theta ionic orbital popualtions

     theta_pop_I_B :: VEC{REAL}@
     ! Atom "B" theta ionic orbital populations

     theta_cov_index :: VEC{REAL}@
     ! The vector of each covalent theta bond index

     theta_ion_index :: VEC{REAL}@
     ! The vector of each ionic theta bond index

     ! ========
     ! Energies
     ! ========

     E1 :: VEC{REAL}@ 
     ! Roby energy for each atom-group

     E2 :: MAT{REAL}@
     ! Roby pair energy for each atom-group pair
     ! NOTE: these are *not* shared populations

     E_shared :: REAL
     ! Roby multiple shared energy for a specified atom-group

     E1_cov :: MAT{REAL}@
     ! Covalent bond energy for the atom-group pair

     E1_ion :: MAT{REAL}@
     ! Ionic bond energy for the atom-group pair

     E1_bond :: MAT{REAL}@
     ! Total bond energy for the atom-group pair

     ! =================
     ! Theta energy info
     ! =================

     theta_E_C :: VEC{REAL}@
     ! Covalent theta orbital energies

     theta_E_C_A :: VEC{REAL}@
     ! Atom "A" part of the covalent theta energies

     theta_E_C_B :: VEC{REAL}@
     ! Atom "B" part of the covalent theta energies

     theta_E_I :: VEC{REAL}@
     ! Ionic theta orbital energies

     theta_E_I_A :: VEC{REAL}@
     ! Atom "A" part of the ionic theta energies

     theta_E_I_B :: VEC{REAL}@
     ! Atom "B" part of the ionic theta energies

   ! theta_E_cov :: VEC{REAL}@ 
   ! ! The vector of each covalent theta energy index

   ! theta_E_ion :: VEC{REAL}@
   ! ! The vector of each covalent theta energy index

     ! =============
     ! Molecule info
     ! =============

     spin_multiplicity :: INT DEFAULT(1)
     ! The spin multiplicity of the molecule

     density_matrix :: OPMATRIX@
     ! The density matrix of the molecule

     overlap_matrix :: MAT{REAL}@
     ! The full molecular overlap matrix for Roby analysis

     core_matrix :: OPMATRIX@
     ! The core hamiltonian matrix of the molecule

     fock_matrix :: OPMATRIX@
     ! The Fock matrix of the molecule

     E_matrix :: OPMATRIX@
     ! The Krogel et al energy density matrix of the molecule
     ! See Krogel et al (2014) PRB 90 p035125.

     E_scf :: REAL DEFAULT(ZERO)
     ! The SCF energy

     E_atomic :: REAL DEFAULT(ZERO)
     ! The atomic part of the SCF electronic energy, the expectation
     ! value of P_{AB...C} with the SCF density matrix.

     E_non_atomic :: REAL DEFAULT(ZERO)
     ! The complement of E_atomic in E_scf.

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! The list of atoms to be used in the Roby calculations
     ! *Pointer copied*.

   end

   type MO_LOCALISER

     algorithm :: STR  DEFAULT(MO_LOCALISER_ALGORITHM)
     ! Identifier for the kind of localising algorithm

     n_orb :: INT  DEFAULT (0)
     ! The number of molecular orbitals to be localized. It must not exceed the
     ! first dimension of the dipole integrals.

     accuracy :: REAL  DEFAULT(MO_LOCALISER_ACCURACY)
     ! Used to decide when the iterative localising algorithm should terminate

     iteration :: INT  DEFAULT(0)
     ! The iteration counter, for the number of iterative steps used to refine
     ! the localized orbitals.

     max_iterations :: INT  DEFAULT(MO_LOCALISER_MAXIT)
     ! The maximum number of iterations allowed

     MO :: MAT{REAL}@
     ! The original molecular orbitals to be localized.

     TM :: MAT{REAL}@
     ! The orthogonal transformation matrix from the old to the new MO's.

     dipole :: MAT3{REAL}@
     ! The dipole moment integrals in the (current) MO basis, used for the Boys
     ! scheme and for analysing the spread of the localized orbitals. The first
     ! two indices are for the orbitals, the last for the component x, y, or z.

     quadrupole :: MAT3{REAL}@
     ! The quadrupole moment integrals in the (current) MO, used to analyze the
     ! localized orbitals. The first two indices are for the orbitals, the last
     ! for the component xx, yy, zz, xy, xz, yz.

   end


!  ========
!  Molecule
!  ========

   type MOLECULE

     name :: STR  DEFAULT("unknown")
     ! Name of molecule

     charge :: INT  DEFAULT(0)
     ! Electric charge of the molecule

     spin_multiplicity :: INT  DEFAULT(1)
     ! Spin multiplicity of the molecule

     n_e :: INT  DEFAULT(0)
     ! No of electrons

     n_e_on_atom :: VEC{INT}* DEFAULT_NULL
     ! No of electrons on the atom -- used in ELMO methods

     n_a :: INT  DEFAULT(0)
     ! No of alpha electrons

     n_b :: INT  DEFAULT(0)
     ! No of beta electrons

     E_field :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Applied electric field in atomic units

     B_field :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Applied magnetic field in atomic units

     gauge_origin :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Global gauge origin for magnetic field

     ! =========
     ! Atom info
     ! =========

     n_atom :: INT  DEFAULT(0)
     ! No of atoms

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! List of atoms in molecule

     atoms_bonded_to_atom :: VEC{EVEC{INT}}@
     ! List of atom connections

     atom_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the atom info has been made.

     n_atom_kind :: INT  DEFAULT(0)
     ! No of atoms of a different kind

     atom_group :: VEC{ATOM_GROUP}@
     ! A list of atom groups in the molecule, for group property decomposition

     atom_group_charges :: VEC{INT}*  DEFAULT_NULL
     ! The charges on the auto-detected atom groups

     ! ===================
     ! Gaussian basis info
     ! ===================

     basis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the gaussian basis set class
     ! to be used for each atom

     n_basis :: INT  DEFAULT(0)
     ! No of basis sets

     basis_l_max :: INT  DEFAULT(-1)
     ! The maximum l value for the basis set

     basis :: VEC{BASIS}* DEFAULT_NULL
     ! List of basis sets used

     use_spherical_basis :: BIN   DEFAULT(FALSE)
     ! Set true if you want to use spherical harmonic basis set

     n_bf :: INT  DEFAULT(0)
     ! Total number of basis functions in the molecular basis set

     n_prim :: INT  DEFAULT(0)
     ! Total number of primitives in the molecular basis set

     ! =================
     ! Slater basis info
     ! =================

     slaterbasis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the Slater basis set class
     ! to be used for each atom

     slaterbasis :: VEC{SLATERBASIS}* DEFAULT_NULL
     ! List of Slater basis sets used

     coppensbasis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the Coppens basis set class
     ! to be used for each atom

     coppensbasis :: VEC{COPPENSBASIS}* DEFAULT_NULL
     ! List of coppens basis sets used

     basis_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the gaussian basis set info has been made.

     ! ===========================
     ! Becke grid and related info
     ! ===========================

     becke_grid :: BECKE_GRID@
     ! Becke DFT integration grid data

     overlapping_atoms :: VEC{BIN}* DEFAULT_NULL
     ! List of atom-pairs (in lower triangular form) which have significant
     ! overlap. Used in linear scaling DFT calculations.

     overlapping_atoms_for_atom :: VEC{EVEC{INT}}@
     ! List of atoms which have significant overlap with another

     ! ==================================
     ! Plot, interpolator and isosurfaces
     ! ==================================

     plot_grid :: PLOT_GRID* DEFAULT_NULL
     ! Rectangular grid data, for plots

     use_interpolators :: BIN  DEFAULT(TRUE)
     ! Set to use interpolators

     interpolator :: INTERPOLATOR@
     ! Template interpolator object used for setting options

     isosurface :: ISOSURFACE* DEFAULT_NULL
     ! An object used for creating triangluated meshes for isosurface plots.

     ! ==================================
     ! Crystal, cluster and symmetry info
     ! ==================================

     crystal :: CRYSTAL* DEFAULT_NULL
     ! Crystal data for the enclosing crystal

     cluster :: CLUSTER* DEFAULT_NULL
     ! Crystal cluster data

     cif :: CIF* DEFAULT_NULL
     ! Crystallographic Information file (CIF) object

     pointgroup :: POINTGROUP* DEFAULT_NULL
     ! Pointgroup symmetry of the molecule

     saved :: MOLECULE* DEFAULT_NULL
     ! For saving self and temporarily using an alternative in its place

     ! ==========
     ! Shell info
     ! ==========

     n_shell :: INT  DEFAULT(0)
     ! Total number of shells in the molecular basis set

     n_shell_pairs :: INT  DEFAULT(0)
     ! Total number of shell pairs in the molecular basis set

     n_unique_shells :: INT  DEFAULT(0)
     ! Number of unique shells in the basis set.

     atom_for_shell :: VEC{INT}@
     ! Atom index for molecular shell index array

     atom_shell_for_shell :: VEC{INT}@
     ! Atom shell index for molecular shell index array

     first_shell_for_atom :: VEC{INT}@
     ! First molecule shell index for an atom

     last_shell_for_atom :: VEC{INT}@ 
     ! Last molecule shell index for an atom

     basis_shell_for_shell :: VEC{INT}@
     ! Map a shell of the molecule to a shell of the basis set

     first_basis_fn_for_shell :: VEC{INT}@
     ! First basis function for a given shell

     last_basis_fn_for_shell :: VEC{INT}@
     ! Last basis function for a given shell

     angular_moment_for_shell :: VEC{INT}@
     ! Angular moment for a given shell

     first_basis_fn_for_atom :: VEC{INT}@
     ! For the atom basis function limits

     last_basis_fn_for_atom :: VEC{INT}@
     ! For the atom basis function limits

     precomputed_basis_shellpair :: MAT{SHELL1PAIR}* DEFAULT_NULL
     ! Precomputed stuff for shellpairs of the basis set, to speed up
     ! later calculations of gaussian integrals.

     max_I :: VEC{REAL}*, private  DEFAULT_NULL
     ! Maximum of the (ab|ab) integrals, used for SChwarz inequality test to
     ! eliminate two electron integrals.

     ! ========
     ! SCF info
     ! ========

     scfdata :: SCFDATA* DEFAULT_NULL
     ! SCF data object

     orbital_energies :: OPVECTOR@
     ! The orbital energies

     molecular_orbitals :: OPMATRIX@
     ! The molecular orbitals

     density_matrix :: OPMATRIX@
     ! The density matrix

     old_density_matrix :: OPMATRIX@
     ! The old density matrix used for damping

     delta_density_matrix :: OPMATRIX@
     ! The delta density matrix used for incremental Fock matrix
     ! builds in the direct SCF method

     natural_orbitals :: OPMATRIX@
     ! The natural orbitals

     occupation_numbers :: OPVECTOR@
     ! The natural orbital occupation numbers

     localiser :: MO_LOCALISER@
     ! An MO localiser object

     E_density_matrix :: OPMATRIX@
     ! The E density matrix in the AO basis.
     ! See Krogel et al (2014) Phys. Rev B 90 p. 035125

     E_natural_orbitals :: OPMATRIX@
     ! The energy natural orbitals

     E_eigenvalues :: OPVECTOR@
     ! Eigenvalues of the energy density maytrix 

     ! =================
     ! Integral matrices
     ! =================

     overlap_matrix :: MAT{REAL}* DEFAULT_NULL
     ! The basis function overlap matrix

     overlap_eigenvectors :: MAT{REAL}* DEFAULT_NULL
     ! The overlap matrix eigenvectors

     overlap_eigenvalues :: VEC{REAL}* DEFAULT_NULL
     ! The overlap matrix eigenvalues

     max_S :: VEC{REAL}* DEFAULT_NULL
     ! The maximum value of the basis function overlap matrix
     ! over pairs of shells ... for skip testing ...

     kinetic_energy_matrix :: OPMATRIX@
     ! The kinetic energy integral matrix

     nuclear_attraction_matrix :: OPMATRIX@
     ! The nuclear attraction energy integral matrix

     core_matrix :: OPMATRIX@
     ! The basis function core matrix

     fock_matrix :: OPMATRIX@
     ! The fock matrix

     fock_2e_matrix :: OPMATRIX@
     ! The 2e part of the fock matrix

     constraint_matrix :: OPMATRIX@
     ! The constraint matrix, used for X-ray or PND constrained SCF calculations

     nomo_gradient :: MAT{REAL}*  DEFAULT_NULL
     ! This is the NOMO/ELMO energy derivative wrt to the occupied
     ! coefficients only. It is not a square matrix.

     ! =============
     ! Bond analysis
     ! =============

     roby :: ROBY* DEFAULT_NULL
     ! A Roby data object

     ! ===============
     ! CrystalExplorer
     ! ===============

     CX_file_name :: STR  DEFAULT(" ")
     ! The name of the Crystal Explorer (CX) output file

     CX_uses_angstrom :: BIN  DEFAULT(TRUE)
     ! Set TRUE if output for CX should be in Angstrom, not Bohr.

     ! ================
     ! Polarizabilities
     ! ================

     U_electric_dipole :: MAT3{REAL}*
     ! The derivative U matrices for electric dipole perturbations

     dipole_polarisability :: MAT{REAL}*  DEFAULT_NULL
     ! The dipole polarisability of the molecule.

     dipole_hyperpolarisability :: MAT3{REAL}*  DEFAULT_NULL
     ! The dipole hyperpolarisability of the molecule.

     Hirshfeld_atom_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the Hirshfeld atomic properties are made

     uHirshfeld_atom_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the unrestricted Hirshfeld atomic properties are made

     atomic_polarisabilities_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the atomic polarisabilities are made

     U2_electric_dipole :: MAT3{REAL}*  DEFAULT_NULL
     ! The second order U matrices for electric dipole perturbations

     ! ===========
     ! Derivatives
     ! ===========

     force_constants :: MAT{REAL}@
     ! The second order force constants

     normal_mode_eigenvectors :: MAT{REAL}@
     ! The normal mode eigenvectors

     normal_mode_eigenvalues :: VEC{REAL}@
     ! The normal mode eigenvalues

     phi_step_size :: REAL  DEFAULT(MOLECULE_PHI_STEP_SIZE)
     ! Default dimensionless normal coordinate step size for evaluating
     ! anharmionic constants

     phi3_force_constants :: MAT3{REAL}@
     ! The third order force constants in cm^-1

     phi4_force_constants :: MAT4{REAL}@
     ! The fourth order force constants in cm^-1

     ! ====================
     ! Finite/point nucleus
     ! ====================

     nucleus_model :: STR  DEFAULT("point")
     ! What kind of nucleus to use

     ! ====================
     ! Connection table variable
     ! ====================

     elmo_connection_table :: MAT{INT}* DEFAULT_NULL

     ! ====================
     ! Atomic multipoles
     ! ====================

     charges :: VEC{REAL}@

     dipoles :: MAT{REAL}@

     quadrupoles :: MAT{REAL}@

     octupoles :: MAT{REAL}@

   end

   array type VEC{MOLECULE}

     ! A 1-D array of MOLECULE objects

   end

!  ====
!  XTAL
!  ====

   type XTAL

     name :: STR  DEFAULT("unknown")
     ! Name of the crystal, used for generating file names.

     CIF_chemical_formula :: STR  DEFAULT("?")
     ! The chemical formula, as found in a CIF file.

     cif :: CIF* DEFAULT_NULL
     ! Crystallographic Information file (CIF) object

     pointgroup :: POINTGROUP* DEFAULT_NULL
     ! Pointgroup symmetry of the molecule

     spacegroup :: SPACEGROUP
     ! The crystal spacegroup

     unit_cell :: UNIT_CELL
     ! The crystal unit cell

     ! =========
     ! Atom info
     ! =========

     n_atom :: INT  DEFAULT(0)
     ! No of atoms

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! List of atoms in molecule

     atoms_bonded_to_atom :: VEC{EVEC{INT}}@
     ! List of atom connections

     atom_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the atom info has been made.

     n_atom_kind :: INT  DEFAULT(0)
     ! No of atoms of a different kind

     atom_group :: VEC{ATOM_GROUP}* DEFAULT_NULL
     ! A list of atom groups in the molecule, for group property decomposition

     ! ===================
     ! Gaussian basis info
     ! ===================

     basis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the gaussian basis set class
     ! to be used for each atom

     n_basis :: INT  DEFAULT(0)
     ! No of basis sets

     basis_l_max :: INT  DEFAULT(-1)
     ! The maximum l value for the basis set

     basis :: VEC{BASIS}* DEFAULT_NULL
     ! List of basis sets used

     use_spherical_basis :: BIN   DEFAULT(FALSE)
     ! Set true if you want to use spherical harmonic basis set
     ! NOTE: not done properly yet

     n_bf :: INT  DEFAULT(0)
     ! Total number of basis functions in the molecular basis set

     n_prim :: INT  DEFAULT(0)
     ! Total number of primitives in the molecular basis set

     ! =================
     ! Slater basis info
     ! =================

     slaterbasis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the Slater basis set class
     ! to be used for each atom

     slaterbasis :: VEC{SLATERBASIS}* DEFAULT_NULL
     ! List of Slater basis sets used

     coppensbasis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the Coppens basis set class
     ! to be used for each atom

     coppensbasis :: VEC{COPPENSBASIS}* DEFAULT_NULL
     ! List of coppens basis sets used

     basis_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the gaussian basis set info has been made.

     ! ===========================
     ! Becke grid and related info
     ! ===========================

     becke_grid :: BECKE_GRID@
     ! Becke DFT integration grid data

     overlapping_atoms :: VEC{BIN}* DEFAULT_NULL
     ! List of atom-pairs (in lower triangular form) which have significant
     ! overlap. Used in linear scaling DFT calculations.

     overlapping_atoms_for_atom :: VEC{EVEC{INT}}@
     ! List of atoms which have significant overlap with another

     ! ==================================
     ! Plot, interpolator and isosurfaces
     ! ==================================

     plot_grid :: PLOT_GRID* DEFAULT_NULL
     ! Rectangular grid data, for plots

     use_interpolators :: BIN  DEFAULT(TRUE)
     ! Set to use interpolators

     interpolator :: INTERPOLATOR@
     ! Template interpolator object used for setting options

     isosurface :: ISOSURFACE* DEFAULT_NULL
     ! An object used for creating triangluated meshes for isosurface plots.

     ! ===========
     ! QM fragment
     ! ===========

     n_fragment_atoms :: INT  DEFAULT(0)
     ! No. of atoms in the inputted cell fragment, used to calculate
     ! structure factors, or do wavefunction fitting.

     fragment_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of fragment atoms. NOTE: this is normally pointer
     ! copied, except when a cluster object makes a new list.
     ! See below.

     destroy_fragment_atom :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the fragment_atoms need to be destroyed

     fragment_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The geometry for a molecular fragment in the crystal (in
     ! fractional coordinates) used to calculate structure factors or
     ! do wavefunction fitting. NOTE: this should not to be confused
     ! with the "asymmetric_unit_geometry"; it may include symmetry
     ! non-unique atoms.

     fragment_offset :: VEC{INT}(3)
     ! The center point of the fragment_geometry, to the nearest unit cell

     ! =====================
     ! Asymmetric unit atoms
     ! =====================

     asymmetric_unit_source :: STR  DEFAULT("?")
     ! Where did the asymmetric unit come from?

     n_asymmetric_unit_atoms :: INT  DEFAULT(0)
     ! No. of atoms in the asymmetric unit of the unit cell.

     asymmetric_unit_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of asymmetric unit atoms.

     asymmetric_unit_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The asymmetric unit geometry. Usually inputted from a CIF file.
     ! This may or may not be the same as fragment_geometry. It is NOT
     ! used for structure factor calculations, but for cluster
     ! generation.

     prune_asymmetric_unit :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to prune the asymmetric unit. Sometimes
     ! the asymmetric unit may not be asymmetric i.e. it may have
     ! symmetry-equivalent atoms repeated. This could be because of an
     ! input or CIF file error, or it could be genuinely correct
     ! because the repeated atom corresponds to a disordered position.

     ! ===============
     ! Unit cell atoms
     ! ===============

     n_unit_cell_atoms :: INT  DEFAULT(0)
     ! Total no. of unit cell atoms.

     unit_cell_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of unit cell atoms. Needed for dispersion correction.

     unit_cell_geometry :: MAT{REAL}*  DEFAULT_NULL
     ! The full unit cell geometry, in the crystal coordinate system,
     ! generated from the asymmetric_unit_geometry.

     unique_unit_cell_atom :: VEC{INT}*  DEFAULT_NULL
     ! The list of unique (asymmetric unit) atoms in the
     ! unit_cell_geometry above

     unique_uc_atom_offset :: VEC{EVEC{INT}}@
     ! The list of (h1 h2 h3) offsets which need to be applied to the
     ! ".asymmetric_unit_geometry" to get the corresponding unit cell
     ! atom in the ".unit_cell_geometry".

     is_asym_unit_cell_atom :: VEC{BIN}*  DEFAULT_NULL
     ! Is TRUE if the the atom index corresponds to an asymmetric unit
     ! atom in unit_cell_geometry

     ! ========================================================
     ! Arrays relating fragment, unit cell, and asymmetric cell
     ! ========================================================

     same_atom_tol :: REAL  DEFAULT(CRYSTAL_SAME_ATOM_TOL)
     ! Tolerance to compare if two atom coordinates are the same
     ! in fractional coordinates

     unit_cell_tol :: REAL  DEFAULT(CRYSTAL_UNIT_CELL_TOL)
     ! Tolerance to compare if fractional position is close enough to
     ! integer to be made into an integer.

     fragment_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the fragment related information has been made

     asym_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! ".asym_atom_for_unit_cell_atom(u)" is the index of the unique
     ! unit cell atom (in ".asymmetric_unit_geometry") which generates
     ! ".unit_cell_geometry(:,u)".

     asym_symop_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! "asym_symop_for_unit_cell_atom(u)" is the index of any
     ! spacegroup symmetry operation that generates atom position
     ! "unit_cell_geometry(:,u)" from the atom with index
     ! ".asym_atom_for_unit_cell_atom(u)" (and with position in
     ! ".asymmetric_unit_geometry").

     asym_shift_for_unit_cell_atom :: MAT{INT}* DEFAULT_NULL
     ! "asym_shift_for_unit_cell_atom(u)" is the shift that was
     ! applied to get position "unit_cell_geometry(:,u)" after it was
     ! got from position of atom ".asym_atom_for_unit_cell_atom(u)"
     ! with the symop ".asym_symop_for_unit_cell_atom(u)" to get it
     ! into the unit cell.

     frag_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! ".frag_atom_for_unit_cell_atom(u)" is the index of the
     ! fragment atom (in ".fragment_geometry") which is equivalent to
     ! ".unit_cell_geometry(:,u)" *by cell translation*.  The index may
     ! be zero i.e. there is no fragment atom for unit cell atom u.

     frag_parent_for_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! ".frag_parent_for_unit_cell_atom(u)" is the index of the
     ! fragment atom in ".fragment_geometry" which is equivalent to
     ! .unit_cell_geometry(:,u) *by any crystal symop*. It may have 
     ! zero elements if the fragment does not enhcompass the whole
     ! unit cell. Compare with ".frag_atom_for_unit_cell_atom".

     unit_cell_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".unit_cell_atom_for_frag_atom(f)" is the index of the unit
     ! cell atom in ".unit_cell_geometry" which is equivalent to
     ! ".fragment_geometry(:,f)".  *by cell translation*. It is the
     ! =inverse= of the array above.

     unit_cell_shft_for_frag_atom :: MAT{INT}* DEFAULT_NULL
     ! ".unit_cell_shft_for_frag_atom(f)" is the shift for position
     ! ".fragment_geometry(:,f)" needed to make it the same as unit
     ! cell atom in ".unit_cell_atom_for_frag_atom(f)" above.

     frag_atom_for_asym_atom :: VEC{INT}* DEFAULT_NULL
     ! ".frag_atom_for_asym_atom(a)" is the index of the fragment
     ! atom (in ".fragment_geometry") which is generated from the
     ! asymmetric unit atom position ".asymmeric_unit_geometry(:,a)"
     ! *by any crystal symop*.  This index may be zero meaning that
     ! there is no fragment atom for asymmetric atom "a".

     asym_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".asym_atom_for_frag_atom(f)" is the index of the asymmetric
     ! atom (in ".asymmetric_unit_geometry") which is equivalent to
     ! ".fragment_geometry(:,f)" *by any crystal symop*.  This array
     ! is used to extract the atom list of the asymmetric unit from a
     ! given fragment for cluster generation. This is the =inverse=
     ! of the array above.

     n_unique_frag_atoms :: INT  DEFAULT(0)
     ! No. of unique fragment atoms.

     unique_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! The list of unique fragment atoms, determined as the first
     ! atom in the fragment which is generated by a particular
     ! asymmetric unit atom.

     unique_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".unique_atom_for_frag_atom(f)" is the index of the
     ! symmetry-unique atom position in ".fragment_geometry" which
     ! generates ".fragment_geometry(:,f)" by the symop with index
     ! .unique_symop_for_frag_atom(u) *except for a possible
     ! translational shift*.  The unique atom is determined as the
     ! first atom in the ".fragment_geometry" which is generated by a
     ! particular asymmetric unit atom.

     unique_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".unique_symop_for_frag_atom(f)" is the index of the symop
     ! which generates ".fragment_geometry(:,f)" from
     ! ".unique_atom_for_frag_atom(f)" *except for a possible
     ! translational shift*.  The symop corresponds to the first atom
     ! in the ".fragment_geometry" which is generated by a particular
     ! asymmetric unit atom. WARNING: UNTESTED.

     asym_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! ".asym_symop_for_frag_atom(f)" is the index of the symop which
     ! maps an asymmetric_unit_atom into the unit cell atom which is
     ! equivalent to fragment atom "f" *by translation*. See below.

     asym_shift_for_frag_atom :: MAT{REAL}* DEFAULT_NULL
     ! "asym_shift_for_frag_atom(f)" is the shift required to map an
     ! asymmetric_unit_atom into the fragment atom after applying the
     ! 3x3 seitz operator with index ".asym_symop_for_frag_atom(f)".

     ! ==================
     ! Repetition factors
     ! ==================

     Z :: REAL  DEFAULT(ZERO)
     ! The Z factor for the molecular cell fragment in the unit cell

     use_manual_repetition_factors :: BIN  DEFAULT(FALSE)
     ! If this is set TRUE, then the user should manually enter the
     ! desired repetition factors. For experts only!

     repetition_factor :: VEC{REAL}* DEFAULT_NULL
     ! For each atom, the number of times a *whole QM fragment* is
     ! mapped into itself by the spacegroup. Used in non-HAR structure
     ! factor calcs. These can be reset manually.

     asym_atom_sym_factor :: VEC{REAL}* DEFAULT_NULL
     ! The number of times an asymmetric unit atom is mapped into
     ! itself by the spacegroup i.e. the site symmetry factor. For
     ! HAR-based structure factor calcs.

     asym_atom_stabilizer :: VEC{EVEC{INT}}@
     ! The partition factors for asymmetric_unit_geometry. For
     ! structure factor calcs based on the asymmetric unit.

     ! ==========================
     ! Unit cell connection table
     ! ==========================

     unit_cell_connection :: VEC{EVEC{EVEC{INT}}}@
     ! List of which unit cell atoms are connected to which other unit
     ! cell atoms, and in what cell e.g. "connection(i).element(k)"
     ! represents the "k"-th atom connected to atom "i" in the
     ! ".crystal.unit_cell_geometry", and it is comprised of a
     ! 4-vector, the first three elements being the cell of the "k"-th
     ! connected atom, and the last element being the index of the
     ! actual unit cell atom connected to unit cell atom "i".

     uc_vdw_connection :: VEC{EVEC{EVEC{INT}}}@
     ! As above, for vdw connections.

     unit_cell_mol_for_atom :: VEC{INT}*  DEFAULT_NULL
     ! "unit_cell_mol_for_atom(i)" is the index of the molecule to
     ! which a particular unit cell atom "i" belongs. See comments for
     ! "unit_cell_mol".

     n_unit_cell_mols :: INT   DEFAULT(0)
     ! The number of molecules in the unit cell. Fragments of
     ! molecules are counted as separate molecules.

     ! ===============
     ! Stablizer group
     ! ===============

     n_stabilizer_symops :: INT  DEFAULT(0)
     ! No. of symops needed to make the unit_cell_geometry from
     ! fragment_geometry

     stabilizer_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the symops in the spacegroup seitz list which map
     ! .fragment_geometry into itself.

     str :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for s-type gaussian functions of the
     ! stabilizer symops.

     ptr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for p-type gaussian functions of the
     ! stabilizer symops.

     dtr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for d-type gaussian functions of the
     ! stabilizer symops.

     ftr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for f-type gaussian functions of the
     ! stabilizer symops.

     gtr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for g-type gaussian functions of the
     ! stabilizer symops.

     ! ================
     ! Diffraction data
     ! ================

     data_kind :: STR  DEFAULT("?")
     ! Kind of diffraction experiment used.

     data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The structure factor and fitting data. NOTE: this can stand for
     ! either X-ray or PND data depending on the case.

     xray_data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The X-ray structure factor and fitting data

     pnd_data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The PND scalar structure factor and fitting data

     r_free_percentage :: INT  DEFAULT(0)
     ! A percentage which tells how much of the data is to be reserved
     ! and not fitted in the model

     xray_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL
     ! This is the excluded X-ray data used to calculate R free

     pnd_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL
     ! This is the excluded PND data used to calculate R free

     finalize :: BIN  DEFAULT(TRUE)
     ! Finalize/update non-cluster crystal data

     ! ===============
     ! Cluster-related
     ! ===============

     radius :: REAL, readonly  DEFAULT(CLUSTER_RADIUS)
     ! The radius of the cluster. This number determines the maximum
     ! acceptable distance between an atom in fragment_geometry and
     ! any atom in the crystal lattice. It defines the size of the
     ! cluster in the case that "generation_method" component (see
     ! below) takes the value "within_radius".

     atom_density_cutoff :: REAL  DEFAULT(CLUSTER_ATOM_DENSITY_CUTOFF)
     ! This number is used to define a cluster radius (see above). The
     ! radius is defined from it, as the *largest* distance from any
     ! atom in the asymmetric_cell_atom list where the atomic electron
     ! density becomes smaller than this number. It requires that
     ! slater or coppens bases are defined in asymmetric_unit_atom's, 
     ! and it requires that the generation method be set to
     ! "for_hirshfeld_surface". It is primarily used for clusters
     ! generated from a fragment which will correctly produce the
     ! Hirshfeld surface.

     generation_method :: STR  DEFAULT(CLUSTER_GENERATION_METHOD)
     ! This option tell how to make the cluster: whether to add atoms
     ! within a certain distance (radius) of the starting fragment,
     ! whether to make a cluster specifically for generating a
     ! hirshfeld surface, whether to just make the unit cell, or the
     ! unit cell and the starting fragment.

     defragment :: BIN  DEFAULT(CLUSTER_DEFRAGMENT)
     ! If TRUE, the cluster ends are defragmented, i.e. any atoms
     ! which are "bonded" at the ends of the cluster are included into
     ! the cluster. This oisn't a good idea for network covalent
     ! solids or zeolites: the defragmentation will end when all
     ! bonded entites with the 3x3 cube of units cells near the origin
     ! have been constructed.

     n_atoms :: INT
     ! The number of atoms in the cluster

     geometry :: MAT{REAL}* DEFAULT_NULL
     ! The (3 x .n_atoms) sized array of cluster atom positions, in
     ! fractional coordiantes

     unit_cell_offset :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Unit cell offset to use when generating an offset unit cell.

     h_min :: VEC{INT}(3), private
     ! The minimum values of the cells to search over in a within_radius cluster

     h_max :: VEC{INT}(3), private
     ! The maximum values of the cells to search over in a within_radius cluster

     n_shift :: INT  DEFAULT(0)
     ! The number of distinct translational shifts used to generate the atoms in
     ! the cluster.

     shift :: MAT{INT}* DEFAULT_NULL
     ! The (3 x .n_shift) sized list of translational shifts used to generate the
     ! cluster from the crystal unit cell atoms. See ".shift_for_atom".
     ! NOT CURRENTLY USED

     shift_for_atom :: VEC{INT}* DEFAULT_NULL
     ! ".shift_for_atom(a)" is the index of the translational shift in array
     ! ".shift", that shift being added to the position of the crystal unit cell
     ! atom whose index is given by ".occupation_list(a)/1000" in order to
     ! generate the cluster atom "a" whose position is given by ".geometry(a)".
     ! NOT CURRENTLY USED

     is_fragment_atom :: VEC{BIN}* DEFAULT_NULL
     ! is_fragment_atom(a) is TRUE if .geometry(:,a) is the position of a fragment
     ! atom, i.e. if "a" is the index of a fragm,ent atom.

     occupation_list :: VEC{INT}*  DEFAULT_NULL
     ! The list of atoms in the cluster which are occupied. This is a coded
     ! integer representing the triple of integers (h1,h2,h3), the cell where the
     ! atom resides, as well as the integer index i for the unit cell atom. The
     ! cell integers are limited to be in the range [-4,4] and at most 10^6 atoms
     ! in the cluster.

     ! =========
     ! Molecules
     ! =========

     mol :: VEC{MOLECULE}*  DEFAULT_NULL
     ! A list of molecules associated with the QM fragment.
     ! This only get's made after defragmenting.

     n_molecules :: INT   DEFAULT(0)
     ! The number of molecules in the cluster

     molecule_for_atom :: VEC{INT}@
     ! An integer which tells which molecule the cluster atoms belongs to.

     molecule :: VEC{EVEC{INT}}@
     ! The list of atom indices corresponding to each molecule

     molecule_centroid :: MAT{REAL}*  DEFAULT_NULL
     ! The list of molecule centroids in fractionals
     ! NOT CURRENTLY USED

     n_unique_molecules :: INT  DEFAULT(0)
     ! The number of unique molecules in a defragmented cluster

     unique_molecule_for :: VEC{INT}*  DEFAULT_NULL
     ! The unique molecules; unique_molecule_for(mi) is the molecule
     ! earlier in the list which is symmetry equivalent by the symop
     ! given in unique_symcode_for.
     ! NOT CURRENTLY USED

     unique_symcode_for :: VEC{INT}*  DEFAULT_NULL
     ! The list of symops which maps unique_molecule_for(mi) to the
     ! non-unique molecule mi. See above.
     ! NOT CURRENTLY USED

     atom_connection :: VEC{EVEC{INT}}@
     ! atom_connection(i)[:] are those atoms which are connected to atom "i".

     unit_cell_atoms_to_suppress :: VEC{INT}@
     ! A list of indices into unit cell geometry. Used
     ! to suppress those atoms in cluster generation.

     info_made :: BIN  DEFAULT(FALSE)
     ! Set to true if the routine make_info has been called

   end

   type PAIR_ENERGY

     symop_id :: INT DEFAULT(0) 
     ! The unique symop id for this pair 

     energy_calculated :: BIN DEFAULT(FALSE)
     ! whether or not this energy has been calculated

     n_equivalent :: INT  DEFAULT(1)
     ! The number of equivalent pairs in the crystal

     unit_cell :: VEC{INT}(3) DEFAULT(0)
     ! the unit cell for molecule b

     symop_str :: STR DEFAULT("?")
     ! the symop string for this pair

     center_separation :: REAL DEFAULT(ZERO)
     ! The center->center distance for this pair 

     closest_distance :: REAL DEFAULT(ZERO)
     ! The closest distance between this pair 

     components :: VEC{REAL}(4) DEFAULT(ZERO)
     ! The energy components for this pair energy
     ! Order is E_ele, E_rep, E_pol, E_dis, E_rep

     pos_a :: VEC{REAL}(3) DEFAULT(ZERO)
     ! Location of the center of mol a

     pos_b :: MAT{REAL}@
     ! Location of the center of mol b

     mol :: INT DEFAULT(1)
     ! Identity of mol a

     rot :: MAT{REAL}(3,3) DEFAULT(ZERO)
     ! rotation part of the transform to get mol b

     trans :: VEC{REAL}(3) DEFAULT(ZERO)
     ! translation part of the transform to get mol b

   end
 
   array type VEC{PAIR_ENERGY}

      ! An array of PAIR_ENERGY objects

   end


end
