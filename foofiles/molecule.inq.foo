!===============================================================================
!
! MOLECULE.INQ
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below.
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further.
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! Updated 2014-12-01
! 
! Hierarchic order:
!    INQ
!    SET   ...  INQ 20  SET 83
!    PUT   ...  INQ  3  SET  0  PUT 46
!    BASE  ...  INQ  3  SET 18 [PUT  1] BASE 62
!    REL   ... 
!    INTS  ...  INQ  4  SET  16 PUT  0  BASE 32  [REL  3] INTS 14
!    XTAL  ...  INQ  1  SET  20 PUT  0 [BASE  7] [REL 29] INTS  0  XTAL 40
!    GRID  ...  INQ 35  SET  74 PUT 34  BASE  7  [REL 97] INTS  0  XTAL  0  GRID 367
!    FOCK  ...  INQ  0  SET 101 PUT  0  BASE  0  [REL  0] INTS  5  XTAL  0  GRID   4
!    SCF   ...  INQ 21  SET  28 PUT 21  BASE 49  [REL  5] INTS 40  XTAL  7  GRID  10 FOCK  6  SCF 25
!    PROP  ...  INQ 11  SET  11 PUT  2  BASE 43  [REL  0] INTS 40  XTAL  7  GRID  10 FOCK 17  SCF 30
!    CP    ...  INQ  0  SET   0 PUT  0  BASE  3  [REL  0] INTS  8  XTAL  0  GRID   5 FOCK  4  SCF  1 PROP  0PLOT  0
!    PLOT  ...  INQ  0  SET   7 PUT  2  BASE  9  [REL  0] INTS  3 [XTAL  1] GRID  13 FOCK  0  SCF  5 PROP  0  CP  0
!    TAD   ...  INQ  0  SET  11 PUT 12  BASE  2  [REL  0] INTS  0 [XTAL  1] GRID   8 FOCK  0  SCF 36 PROP  0  CP  0 PLOT  0
!    MISC  ...  INQ  2  SET  11 PUT  5  BASE 14  [REL  0] INTS 21 [XTAL  1] GRID   8 FOCK 15  SCF 13 PROP  0  CP  0 PLOT  1 TAD  2
!    MAIN  ...  INQ  0  SET   1 PUT 50  BASE 22  [REL  3] INTS  3  XTAL 14  GRID   2 FOCK  0  SCF 35 PROP 44  CP 16 PLOT 14 TAD 15 MISC 31
!
! .BASE
!     3 .REL
!    16---24 .GRID
!    14---12---- 1 .XTAL
!     2--- |---- |---- 4 .CE =
!     7--- |---- 1---- |-- | .INTS
!    14--- |---- 5---- |-- |---- 2 .FOCK
!    30--- 5---- 4---- 5-- |----10---- 5 .SCF
!     2--- |---- |---- |-- |---- 1---- 5--- 1 .GEM =     =     =
!    11--- |---- |---- 1-- |----15---- 5---13--- | .PROP =     =
!     4--- |---- 6---- |-- |---- 3---- |--- 2--- |---- | .PLOT =
!     4--- |---- 5---- |-- |---- 4---- 2--- 1--- |---- |---- | .CP
!    12--- |---- 7---- |-- |---- |---- |--- 1--- |---- |---- 1-- | .TAD
!    15--- |---- 5---- 1-- |---- 5---- 6--- 5--- |---- |---- |-- |--- 2 .MISC
!    76--- 3---- 3----13-- 7---- 1---- |---13--- 3----19---- 6-- 9---11----24 .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===============================================================================

module MOLECULE.INQ

   implicit none

contains

!  ===============
!  Inquiry methods
!  ===============

   has_all_NAO_matrices result (res) ::: PURE
   ! Return TRUE if the NAOs are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated
      if (res) res = .atom.has_all_NAO_matrices

   end

   has_all_ANO_matrices result (res) ::: PURE
   ! Return TRUE if the ANO data is made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_ANO_matrices

   end

   has_all_interpolators result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_interpolators

   end

   has_all_atom_data result (res) ::: PURE
   ! Return TRUE if all the atom ANOs and interpolators are made for
   ! every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_atom_data

   end

   has_all_shell_info result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_shell_info

   end


   no_of_electrons result (res) ::: PURE
   ! Work out and return the number of electrons in the molecule.
   ! NOTE: removed the core electrons, if any.
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,  "no atom list")

      res = .atom.no_of_electrons &
          - .charge &
          - sum(.atom(:).n_core_electrons)

   end

   no_of_alpha_electrons result (res) ::: PURE
   ! Work out and return the number of alpha electrons in the molecule.
      self :: IN
      res :: INT

      res = .INQ:no_of_electrons - .INQ:no_of_beta_electrons

   end

   no_of_beta_electrons result (res) ::: PURE
   ! Work out and return the number of beta electrons in the molecule.
   ! Normally the number of beta electrons is smaller than alpha, but
   ! if the atom list is a single explicit (alpha) "El" electron it is
   ! assumed that there is one beta electron surrounding it. This is
   ! to ensure a good initial guess for promolecule SCF guess.
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,  "no atom list")

      tmp :: INT

      if (.atom.dim==1 AND .atom(1)%tag(1:2)=="El") then

         res = 1 ! Assume one beta electron surrounds the "El"

      else

         tmp = .INQ:no_of_electrons - .INQ:no_of_unpaired_electrons
         res = tmp/2
         ENSURE(tmp.is_even,"Inconsistent multiplicity, non integer # of beta electrons")

      end

   end

   has_valid_no_of_beta_electrons result (res) ::: PURE
   ! Return TRUE if the number of beta electrons is valid based on the
   ! assigned charge and multiplicity i.e. it must come out integral
   ! *except* in the case when the atom list is a single explicit
   ! (alpha) "El" electron - in which case there must be one beta
   ! electron. See above.
      self :: IN
      res :: BIN

   ENSURE(.atom.allocated,  "no atom list")

      tmp :: INT

      if (.atom.dim==1 AND .atom(1).tag(1:2)=="El") then

         tmp = .INQ:no_of_electrons
         res = tmp==1 ! must have one beta electron

      else

         tmp = .INQ:no_of_electrons - .INQ:no_of_unpaired_electrons
         res = tmp.is_even

      end

   end

   no_of_unpaired_electrons result (res) ::: PURE
   ! Work out and return the number of unpaired electrons in the molecule
      self :: IN
      res :: INT

      res = .spin_multiplicity - 1

      ENSURE(res<=.INQ:no_of_electrons,"Wrong multiplicity, not enough electrons")

   end


   no_of_atom_pairs result (res) ::: PURE
   ! Return the number of atom pairs in the molecule
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,"no atom list")

      res = .n_atom*(.n_atom+1)/2

   end


   no_of_occupied_NOs(genre,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      genre :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.NO_occ_nos.allocated,"no occupation numbers")

      res = .NO_occ_nos.no_of_occupied(genre,tol)

   end


   DFT_grid_info_made result (res) ::: PURE
   ! Return TRUE if the DFT grid information is made
      self :: IN
      res :: BIN

      res = .becke_grid.allocated  &
          AND .overlapping_atoms.allocated &
          AND .overlapping_atoms_for_atom.allocated

   end

   has_Hirshfeld_inputs result (res) ::: PURE
   ! Return TRUE if the inputs for a Hirshfeld calc are there
      self :: IN
      res :: BIN

      res =  .INQ:DFT_grid_info_made &
         AND .INQ:has_all_ANO_matrices &
         AND (.INQ:has_all_interpolators OR .INQ:has_all_atom_data )

   end


   guess_SCF_method result (res) ::: PURE
   ! Guess the scf method in use.
      self :: IN
      res :: STR
      res = "?"
      if      (.scfdata.allocated) then;            res = .scfdata.SCF_kind
      else if (.MOs.allocated) then; res = .MOs.guess_SCF_kind
    ! else;                                       DIE("no way to  guess!")
      end
   end

!  =================
!  Overlapping atoms
!  =================

   is_overlapping_atom(a,b) result (res) ::: PURE
   ! Return TRUE if atoms "a" and "b" overlap.
      self :: IN
      a,b :: INT, IN
      res :: BIN

   ENSURE(.overlapping_atoms.allocated,"no .overlapping_atoms")

      aa,bb,ab :: INT

      if (a==b) then
         res = TRUE
      else
         aa = max(a,b)
         bb = min(a,b)
         ab = int(HALF*aa*(aa-1)) + bb
         res = .overlapping_atoms(ab)
      end

   end

   is_overlapping_atom(a,list) result (res) ::: PURE
   ! Return TRUE if atom "a" overlaps with *any* atoms in the "list".
      self :: IN
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: BIN

   ENSURE(.overlapping_atoms.allocated,"no .overlapping_atoms")

      i,b,aa,bb,ab :: INT

      res = FALSE

      do i = 1,list.dim

         b = list(i)

         if (a==b) then
            res = TRUE
            exit
         else
            aa = max(a,b)
            bb = min(a,b)
            ab = int(HALF*aa*(aa-1)) + bb
            if (.overlapping_atoms(ab)) then
               res = TRUE
               exit
            end
         end

      end

   end

   overlapping_atoms_for(list) result (res) ::: leaky, PURE
   ! Return the list of atoms which overlaps with those in "list".
      self :: IN
      list :: VEC{INT}, IN
      res :: VEC{INT}@

      a,k :: INT

      res.create(.n_atom)

      k = 0
      do a = 1,.n_atom
         if (NOT .INQ:is_overlapping_atom(a,list)) cycle
         k = k + 1
         res(k) = a
      end

      res.shrink(k)

   end

!  =================
!  VEC{ATOM} methods
!  =================

   default_spin_multiplicity result (res) ::: PURE
   ! Return the default multiplicity for a molecule.
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,"no atom info")

      n_e :: INT

      n_e = .INQ:no_of_electrons
      if (.atom.dim==1) then
         ! One atom
         if (.atom(1).atomic_number==-1) then
            res = 2 ! This is an El electron
         else
            res = .atom(1).ground_state_multiplicity(n_e)
         end
      else
         ! Singlet or doublet
         res = mod(n_e,2) + 1
      end

   end

   nuclear_repulsion_energy result (res) ::: PURE
   ! Return the nuclear repulsion energy
      self :: IN
      res :: REAL

   ENSURE(.atom.allocated,"atom list required")

      i :: INT
      scf_kind :: STR

      scf_kind = "unknown"
      if (.scfdata.allocated) scf_kind = .scfdata.SCF_kind

      i = 0
      res = ZERO
      select case (scf_kind)
      case ("embedded_rhf"); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
      case ("crystal_rhf "); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
      case default;          res = .atom.nuclear_repulsion_energy
      end

   end

!  ============================
!  Nuclear & electric potential
!  ============================

   nuclear_potential(values,pts) ::: pure
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is useful for numerical integration of nuclear attraction
   ! integrals. Dummay atom charges are included.
      self :: IN
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      n_pts,n,i :: INT
      Z_n,r :: REAL
      pos :: VEC{REAL}(3)

      n_pts  = pts.dim1

      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n).nuclear_charge
         pos = .atom(n).position
         do i = 1,n_pts
            r = pos.distance_to(pts(i,:))
            if (r>tiny(r)) then
               values(i) = values(i) + Z_n / r
            else
               values(i) = values(i) + huge(ONE)
            end
         end
      end

   end

   electric_potential(values,grid,charges,positions) ::: selfless, PURE
   ! Calculate the electric potential "values" at a set of "grid" points, coming
   ! from a given set "charges" located at "positions".  This is useful for
   ! numerical integration of the potential.
      values :: VEC{REAL}, OUT
      charges   :: VEC{REAL}, IN
      grid      :: MAT{REAL}, IN
      positions :: MAT{REAL}, IN

   ENSURE(charges.dim==positions.dim1,"inconsistent charges and positions arrays")
   ENSURE(positions.dim2==3,"wrong 2nd dimension, positions array")
   ENSURE(values.dim==grid.dim1,"inconsistent values and grid array")

      n,i :: INT
      q,r :: REAL
      pos :: VEC{REAL}(3)

      values = ZERO
      do n = 1,charges.dim
         q = charges(n)
         pos = positions(n,:)
         do i = 1,grid.dim1
            r = pos.distance_to(grid(i,:))
            if (r>tiny(r)) then
               values(i) = values(i) + q / r
            else
               values(i) = values(i) + TEN**6 ! something very large
            end
         end
      end

   end

!  ================
!  Atom connections
!  ================

   connected(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are connected
      self :: IN
      a,b :: INT, IN
      res :: BIN
      
      if (a <= .atoms_bonded_to_atom.dim1) then
         res = any(b==.atoms_bonded_to_atom(a).element(:))
      else
         res = FALSE
      end if

   end
  
   connected_or_identical(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are connected
   ! or if they are the same atom
      self :: IN
      a,b :: INT, IN
      res :: BIN
     
      if (a == b) then 
         res = TRUE
      else if (a <= .atoms_bonded_to_atom.dim1) then
         res = any(b==.atoms_bonded_to_atom(a).element(:))
      else
         res = FALSE
      end if

   end

!  ===========
!  Atom groups
!  ===========

   n_bonds_between_atom_groups(g1,g2) result (res) ::: pure
   ! Return the number of connections between ".atom_group(g1)" and
   ! ".atom_group(g2)". 
      self :: IN
      g1,g2 :: INT, IN
      res :: INT

      i,j,a,b :: INT
      bonded :: BIN

      res = 0
      residue1: do i = 1,.atom_group(g1).atom_index.dim
         a = .atom_group(g1).atom_index(i)
         residue2: do j = 1,.atom_group(g2).atom_index.dim
            b = .atom_group(g2).atom_index(j)
            bonded = VEC{ATOM}:has_a_connection(a,b)
            if (bonded) then
               res = res + 1
            end
         end do residue2
      end do residue1

   end

   bonded_atoms_between_groups(g1,g2) result (res) ::: pure
   ! Return the number of connections between ".atom_group(g1)" and
   ! ".atom_group(g2)" in a table "res(1:2,n_bonds)". 
      self :: IN
      g1,g2 :: INT, IN
      res :: MAT{INT}(2,n_bonds_between_atom_groups(self,g1,g2))

      n :: INT
      i,j :: INT
      a,b :: INT
      bonded :: BIN

      n = 0
      residue1: do i = 1,.atom_group(g1).atom_index.dim
         a = .atom_group(g1).atom_index(i)
         residue2: do j = 1,.atom_group(g2).atom_index.dim
            b = .atom_group(g2).atom_index(j)
            ! Are a & b bonded?
            bonded = VEC{ATOM}:has_a_connection(a,b)
            ! Store pair of bonded atoms
            if (bonded) then
               n = n + 1
               res(1,n) = a
               res(2,n) = b
            end
         end do residue2
      end do residue1

   end

   n_bf_up_to_mol(g) result (res) ::: PURE
   ! Return the no. of basis functions up to the "g"-th
   ! molecule .mol(g) assuming they are concatenated.
      self :: IN
      g    :: INT, IN
      res  :: INT
 
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(g>0 AND g<=.mol.dim,"group out of range")
 
      i :: INT
 
      res = 0
      do i = 1,g-1
         res = res + .mol(i).n_bf
      end
 
   end

!  ===============
!  ARCHIVE related
!  ===============

   archive_exists(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      self :: IN
      archive_name :: STR, IN
      genre :: STR, IN
      res :: BIN

      archive :: ARCHIVE

      archive.set(.name,archive_name,genre)
      res = archive.exists

   end

   archive_doesnt_exist(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      self :: IN
      archive_name :: STR, IN
      genre :: STR, IN
      res :: BIN

      archive :: ARCHIVE

      archive.set(.name,archive_name,genre)
      res = NOT archive.exists

   end

!  ===========
!  CIF related
!  ===========

   wavefunction_descriptor result (psi) ::: PURE
   ! Get the wavefunction details. Only call this if an SCF
   ! calculation was completed!
      self :: IN
      psi :: VEC{STR}(19)

   ENSURE(.scfdata.allocated,"no SCF data!")

      field :: STR
      radius :: REAL
      L :: INT

      psi = "?"

      if (.scfdata.deallocated) return

      ! QM method
      psi(1) = "Hartree-Fock"
      if (.scfdata.is_DFT_calculation) then
         psi(1) = "Kohn-Sham/"// &
                  trim(.scfdata.DFT_exchange_functional)// &
                  trim(.scfdata.DFT_correlation_functional)
      end

      if (.scfdata.using_cluster_charges) then

         ! Add crystal field
         field = "CF"
         if (.scfdata.using_SC_cluster_charges) field = "SCCF"

         ! Add L
         if (.scfdata.using_qq_cluster_charges) then
            field = trim(field)//" L=2"
         else
            field = trim(field)//" L=1"
         end

         ! Radius
         radius = .scfdata.cluster_radius*ANGSTROM_PER_BOHR

         ! All bits
         psi(1) = trim(psi(1))//"/"//   &
                  trim(field) //" R="// &
                  trim(radius.to_str("f3.1"))//" A"
      end

      ! AO kind
      psi(2) = .scfdata.spinorbital_genre

      ! Basis
      psi(3) = "custom?"
      if (.basis_name/=" ") psi(3) = trim(.basis_name)

      ! Basis kind
      psi(4) = "cartesian"
      if (.use_spherical_basis) psi(4) = "spherical-harmonic"

      ! Basis max L
      L = .basis.maximum_basis_set_l_value
      psi(5) = trim(L.to_str)

      ! Becke grid
      if (.scfdata.is_DFT_calculation) then
      if (.becke_grid.allocated) then
      psi( 6) = trim(.becke_grid.kind)
      psi( 7) = trim(.becke_grid.accuracy)
      psi( 8) = trim(.becke_grid.pruning_scheme)
      psi( 9) = trim(.becke_grid.basis_function_cutoff.to_str(fmt="e6.1"))
      psi(10) = trim(.becke_grid.rho_cutoff.to_str(fmt="e6.1"))
      psi(11) = trim(.becke_grid.scale_atomic_grids.to_str)
      psi(12) = trim(INT:to_str(.becke_grid.no_of_points_for_row(1)))
      psi(13) = trim(INT:to_str(.becke_grid.no_of_points_for_row(2)))
      psi(14) = trim(INT:to_str(.becke_grid.no_of_points_for_row(3)))
      psi(15) = trim(.becke_grid.n_radial_points.to_str)
      psi(16) = trim(.becke_grid.n_extra_points_per_shell.to_str)
      psi(17) = trim(.becke_grid.l_angular_grid.to_str)
      psi(18) = trim(.becke_grid.l_H_angular_grid.to_str)
      psi(19) = trim(.becke_grid.reduce_H_angular_grid.to_str)
      end
      end

   end

end
