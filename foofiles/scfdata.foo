!==================================================================
!
! SCFDATA: Store SCF data and deal with iteration control ......
!
! Copyright (C) Daniel Grimwood, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!==================================================================

module SCFDATA

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of self
      self :: INOUT

      .SCF_DIIS.destroy_ptr_part
      .CP_DIIS.destroy

      .crystal.destroy
      .cluster.destroy
      .cluster_charges.destroy
      .cluster_charge_positions.destroy
      .table_info.destroy
      .table.destroy

   end

!  ===============================================
!  Set defaults, reset, update and realted methods
!  ===============================================

   set_defaults ::: leaky, PURE
   ! Set default SCF data values
      self :: INOUT

      ! The SCF_kind is purposely set blank so DIIS comes later
      .SCF_kind                    = " "

      ! DFT functional options
      .DFT_exchange_functional     = SCFDATA_DFT_EXCHANGE_FUNCTIONAL
      .DFT_correlation_functional  = SCFDATA_DFT_CORRELATION_FUNCTIONAL
      .using_GGA_exchange          = SCFDATA_USING_GGA_EXCHANGE
      .using_GGA_correlation       = SCFDATA_USING_GGA_CORRELATION
      .using_hybrid_exchange       = SCFDATA_USING_HYBRID_EXCHANGE

      ! Iteration counters
      .iteration                   = 0
      .total_iterations            = 0
      .lambda_iteration            = 0
      .min_iterations              = SCFDATA_MIN_ITERATIONS
      .max_iterations              = SCFDATA_MAX_ITERATIONS

      ! Stored energies
      .nuclear_repulsion_energy    = ZERO
      .nuclear_attraction_energy   = ZERO
      .kinetic_energy              = ZERO
      .energy                      = ZERO
      .old_energy                  = ZERO
      .DFT_energy_correction       = ZERO
      .DFT_alpha_energy_correction = ZERO
      .DFT_beta_energy_correction  = ZERO
      .delta                       = ZERO

      ! Constrained SCF/Crystal SCF data
      .lambda                      = ZERO
      .initial_lambda              = ZERO
      .lambda_max                  = ZERO
      .lambda_step                 = ONE
      .fit_value                   = ZERO
      .old_fit_value               = ZERO
      .penalty                     = ZERO
      .old_penalty                 = ZERO
      .kappa                       = ZERO
      .zero_oo_constraint_block    = FALSE

      ! Initial guess options
      .initial_density             = "core" ! This shouldn't be changed; else atom SCF goes forever
      .initial_MOs                 = "--using density--"
      .initial_Us                  = " "
      .use_default_guess_options   = TRUE

      ! SCF convergence
      .convergence                 = SCFDATA_CONVERGENCE             ! TOL(4)
      .damp_finish                 = SCFDATA_DAMP_FINISH
      .damp_factor                 = SCFDATA_DAMP_FACTOR
      .level_shift                 = SCFDATA_LEVEL_SHIFT
      .level_shift_finish          = SCFDATA_LEVEL_SHIFT_FINISH

      ! Linear dependence
      .linear_dependence_tol       = SCFDATA_LINEAR_DEPENDENCE_TOL
      .linear_dependence_shift     = SCFDATA_LINEAR_DEPENDENCE_SHIFT
      .min_overlap_mx_eigenvalue   = ZERO
      .n_small_S_eigenvalues       = 0
      .n_neg_S_eigenvalues         = 0

      ! Accuracy
      .MO_gradient_stepsize        = 0.01d0
      .max_update_stepsize         = 0.01d0
      .ERI_disk_cutoff             = SCFDATA_ERI_DISK_CUTOFF
      .ERI_Schwarz_cutoff          = SCFDATA_ERI_SCHWARZ_CUTOFF
      .ERI_J_density_cutoff        = SCFDATA_ERI_J_DENSITY_CUTOFF
      .ERI_K_density_cutoff        = SCFDATA_ERI_K_DENSITY_CUTOFF
      .ERI_bf_overlap_cutoff       = SCFDATA_ERI_BF_OVERLAP_CUTOFF
      .ERI_primitive_pair_cutoff   = SCFDATA_ERI_PAIR_CUTOFF

      ! For eliminating exchange correlation integrals
      .atom_overlap_cutoff         = SCFDATA_ATOM_OVERLAP_CUTOFF
      .XC_atom_separation_cutoff   = SCFDATA_XC_ATOM_SEPARATION_CUTOFF

      ! DIIS convergence related data
      .SCF_DIIS.set_defaults           ! <<< leaky here ...
      .DIIS_error                  = ZERO
      .old_DIIS_error              = ZERO
      .DIIS_error_temp_cutoff      = DIIS_ERROR_TEMP_CUTOFF

      ! General Complex HF options
      .sl_1e_factor                = ONE
      .sl_2e_factor                = ONE
      .quantization_axis           = [ZERO, ZERO, ONE]

      ! Logical switches in alphabetical order
      .do_outputs                  = FALSE
      .output                      = TRUE
      .output_results              = TRUE 
      .guess_output                = FALSE
      .is_guess                    = FALSE
      .test                        = FALSE
      .stabilize_density           = FALSE
                                   
      ! Relativity                 
      .relativity_kind             = "none"
                                   
      .DK1                         = TRUE
      .DK2                         = TRUE
      .using_SO_FDFF               = FALSE
      .using_ppzpp                 = FALSE
      .DK3                         = FALSE
      .PCE_CORR                    = FALSE
      .DK1_PCE                     = FALSE
      .DK2_PCE                     = FALSE
                                   
      ! Pauli switches             
      .set_pauli_terms_off         
                                   
      .using_damping               = SCFDATA_USING_DAMPING ! TRUE
      .using_pFON                  = FALSE
      .using_delta_build           = TRUE
      .using_direct_SCF            = TRUE
      .using_DIIS                  = TRUE
      .using_level_shift           = SCFDATA_USING_LEVEL_SHIFT ! TRUE
      .using_orbital_locking       = FALSE
      .using_exponential_update    = FALSE
      .using_MO_gradient_update    = FALSE
      .using_NDDO                  = FALSE
      .using_NUDO                  = FALSE
      .using_PIE                   = FALSE

      ! Coupled=perturbed
      .n_pert                      = 0
      .using_CP_DIIS               = TRUE

      ! Cluster switches
      .using_cluster_charges       = FALSE
      .using_SC_cluster_charges    = FALSE
      .using_qq_cluster_charges    = FALSE
      .cluster_radius              = SCFDATA_CLUSTER_RADIUS
      .defragment                  = TRUE 
      !testing, turn off defragment in case of network compounds, Lorraine. 
      .save_cluster_charges        = FALSE
      .using_SC_Lorentz_fields     = FALSE

      ! how to change the finite gaussian nucleus radius
      .nhf = 0

      .delete_SCF_archives         = TRUE
      .delete_all_archives         = FALSE

   end

   set_pauli_terms_on ::: PURE
   ! Turn on all the Pauli terms
      self :: INOUT

      .using_1e_sl_term   = TRUE
      .using_1e_srxa_term = TRUE
      .using_2e_sl_term   = TRUE
      .using_aa_term      = TRUE
      .using_bl_term      = TRUE
      .using_bs_term      = TRUE
      .using_bs_t_term    = TRUE

   end

   set_pauli_terms_off ::: PURE
   ! Turn on all the Pauli terms
      self :: INOUT

      .using_1e_sl_term   = FALSE
      .using_1e_srxa_term = FALSE
      .using_2e_sl_term   = FALSE
      .using_aa_term      = FALSE
      .using_bl_term      = FALSE
      .using_bs_term      = FALSE
      .using_bs_t_term    = FALSE

   end

   set_crystal(crystal) ::: PURE
   ! Set the crystal
      self :: INOUT
      crystal :: CRYSTAL@, IN

      ! Set crystal and penalty
      if (.iteration==0) then
      if (crystal.allocated) then
         .crystal = crystal
      end
      end

   end

   set_penalty ::: PURE
   ! Set the penalties for the diffraction data present
      self :: INOUT

   ENSURE(.crystal.allocated,"No Crystal Data Present")

      .old_penalty = .penalty

      select case (.SCF_kind)

      case ("xray_rhf","xray_uhf","xray_gchf")
         ENSURE(.crystal.xray_data.allocated,"No diffraction data")
         .penalty = .crystal.xray_data.chi2

      case ("xray_rks","xray_uks")
         ENSURE(.crystal.xray_data.allocated,"No diffraction data")
         .penalty = .crystal.xray_data.chi2

    ! case ("pnd_uhf","pnd_uks")
    !    ENSURE(.crystal.pnd_data.allocated,"No diffraction data")
    !    .penalty = .crystal.pnd_data.chi2

    ! case ("xray_pnd_uhf","xray_pnd_uks")
    !    ENSURE(.crystal.pnd_data.allocated,"No PND diffraction data")
    !    ENSURE(.crystal.xray_data.allocated,"No X-ray diffraction data")
    !    .penalty = log(.crystal.xray_data.F_chi2*.crystal.pnd_data.F_chi2)

    ! case default
    !    DIE("this is not a constrained scf")

      end

   end

   set_table ::: leaky, PURE
   ! Set up the SCF table
      self :: INOUT

      ! Initialize save margin note data
      .table_info.destroy
      .table_info.create(1,20)
      .set_margin_info

      ! Set table headings
      if (NOT .fitting) then

         .table.create(5)
         .table(1).set_heading("Iter")
         .table(2).set_heading("Energy")
         .table(2).set_subhead("  E/au")
         .table(3).set_heading("Delta")
         .table(3).set_subhead("E")
         .table(4).set_heading("  DIIS  ")
         .table(4).set_subhead("Gradient")
         .table(5).set_width(0)

         ! Table widths
         .table(1).set_width_from(.max_iterations)
         .table(2).set_width_from(.energy)
         .table(3).set_width_from(.energy)
         .table(4).set_width_from(.energy)
         .table(5).force_width(0)
         .table(5).set_left(TRUE)
         .table(5).set_list_as_column(TRUE)

      else

         .table.create(8)
         .table(1).set_heading("Iter")
         .table(2).set_heading("Lambda")
         .table(2).set_subhead("   L  ")
         .table(3).set_heading("chi2")
         .table(4).set_heading("Energy")
         .table(4).set_subhead(" E/au ")
         .table(5).set_heading("Penalty")
         .table(5).set_subhead("E+L*chi2")
         .table(6).set_heading("Delta")
         .table(6).set_subhead("penalty")
         .table(7).set_heading("  DIIS  ")
         .table(7).set_subhead("Gradient")

         ! Table widths
         .table(1).set_width_from(.max_iterations)
         .table(2).set_width_from(.lambda)
         .table(3).set_width_from(TEN**3*.penalty)
         .table(4).set_width_from(.energy)
         .table(5).set_width_from(.fit_value)
         .table(6).set_width_from(.fit_value)
         .table(7).set_width_from(.energy)
         .table(8).force_width(0)
         .table(8).set_left(TRUE)
         .table(8).set_list_as_column(TRUE)

      end

   end

   set_CP_table ::: leaky, PURE
   ! Set up the CP table
      self :: INOUT

      ! Initialize save margin note data
      .table_info.destroy
      .table_info.create(1,20)
      .set_margin_info

      ! Set table headings
      .table.create(4)
      .table(1).set_heading("Iter")
      .table(2).set_heading("      max")
      .table(2).set_subhead("|Delta U|")
      .table(3).set_heading("max DIIS")
      .table(3).set_subhead("   error")
      .table(4).set_width(0)

      ! Table widths
      .table(1).set_width_from(.max_iterations)
      .table(2).set_width_from(1.0d4)
      .table(3).set_width_from(1.0d4)
      .table(4).force_width(0)
      .table(4).set_left(TRUE)
      .table(4).set_list_as_column(TRUE)

   end

   set_margin_info(n_notes) ::: PURE
   ! Set the margin information "info" for the SCF iterations
   ! This usesd SAVE vafiables, so is not PURE.
      self :: INOUT
      n_notes :: INT, optional, OUT

      n,i,s :: INT

      ! Initialize saved switches
      if (.iteration <= 0) then
         .delta_E_converged = FALSE
         .damping_on        = FALSE
         .damping_off       = FALSE
         .level_shift_on    = FALSE
         .level_shift_off   = FALSE
         .DIIS_converged    = FALSE
         .DIIS_saving       = FALSE
         .DIIS_started      = FALSE
         .DIIS_used_up      = FALSE
      end

      ! Initialize info
      n = 0
      .table_info(1)[:] = " "

      ! No notes ...
      if (.scf_done) return

      ! Set margin info ...
      if (NOT .delta_E_converged AND .delta_converged AND .iteration>0) then
         n = n + 1
         .table_info(1)[n] = " *Difference has converged"
         .delta_E_converged = TRUE
      end

      if (NOT .DIIS_converged AND .SCF_DIIS.is_converged) then
         n = n + 1
         .table_info(1)[n] = " *Gradient has converged"
         .DIIS_converged = TRUE
      end

      if (.apply_damping AND NOT .damping_on) then
         n = n + 1
         .table_info(1)[n] = " *Damping on"
         .damping_on = TRUE
      else if (NOT .apply_damping AND NOT .damping_off) then
         n = n + 1
         .table_info(1)[n] = " *Damping was off"
         .damping_off = TRUE
      end

      if (.apply_level_shifting AND NOT .level_shift_on) then
         n = n + 1
         .table_info(1)[n] = " *Levelshift on"
         .level_shift_on = TRUE
      else if (NOT .apply_level_shifting AND NOT .level_shift_off) then
         n = n + 1
         .table_info(1)[n] = " *Levelshift was off"
         .level_shift_off = TRUE
      end

      if (.using_DIIS) then

         if (.SCF_DIIS.saved_iteration==0 AND NOT .DIIS_saving) then
            n = n + 1
            .table_info(1)[n] = " *DIIS starts saving now"
            .DIIS_saving = TRUE
         end

         if (.SCF_DIIS.actual_iteration==0 AND NOT .DIIS_started) then
            n = n + 1
            .table_info(1)[n] = " *DIIS extrapolates now"
            .DIIS_started = TRUE
         end

         if (.SCF_DIIS.subspace_saturated AND .DIIS_used_up) then
            n = n + 1
            i = .SCF_DIIS.replaced_iteration
            s = .SCF_DIIS.new
            .table_info(1)[n] = " *DIIS replaced saved #"//trim(s.to_str)//" iter #"//trim(i.to_str)
         end

         if (.SCF_DIIS.kept<=2 AND .DIIS_used_up) then
            n = n + 1
            i = .SCF_DIIS.iter_4(1) - 1
            s = .SCF_DIIS.new
            if (.SCF_DIIS.kept==1) then
            .table_info(1)[n] = " *DIIS stuck, total reset"
            else
            .table_info(1)[n] = " *DIIS stuck, kept saved #"//trim(s.to_str)//" iter #"//trim(i.to_str)
            end
            .DIIS_used_up = FALSE
         end

         ! This must come last
         if (.SCF_DIIS.subspace_saturated AND NOT .DIIS_used_up) then
            n = n + 1
            .table_info(1)[n] = " *DIIS subspace is saturated"
            .DIIS_used_up = TRUE
         end

      end

      if (present(n_notes)) n_notes = n

   end

   reset ::: PURE
   ! Reset SCF energy and iteration data , but don't change
   ! nuclear_repulsion_energy, convergence, direct, or max_it options
      self :: INOUT

      ! Stored total energy/Lagrangian
      .energy        = ZERO
      .fit_value     = ZERO
      .old_fit_value = ZERO

      ! Stored part-energies
      .nuclear_attraction_energy = ZERO ! Electron-nuclear attraction energy
      .charge_attraction_energy  = ZERO ! Point-charge attraction energy
      .electron_repulsion_energy = ZERO ! Electron-electron repulsion energy
      .kinetic_energy            = ZERO ! Electron kinetic energy
      .old_energy                = ZERO

      ! Iteration count
      .iteration        = 0
      .total_iterations = 0
      .lambda_iteration = 0
      .penalty          = ZERO

      ! DIIS (leaky)
      .SCF_DIIS.reset_iteration_defaults

      ! BFGS
      .bfgs.set_defaults

   end

   reset_for_next_lambda ::: leaky, PURE
   ! Reset a few things for the next constrained-scf lambda iteration:
      self :: INOUT

      ! Reset iteration & margin info
      .iteration = -1
      .set_margin_info

      ! DIIS (leaky)
      .SCF_DIIS.reset_iteration_defaults

   end

   reset_CP(n_pert) ::: PURE
   ! Reset the "n_pert" CPHF DIIS extrapolators
      self :: INOUT
      n_pert :: INT, IN

      ! Reset iterations
      .reset

      ! Set defaults
      .set_n_pert(n_pert)
      .set_using_damping(FALSE)
      .set_using_level_shift(FALSE)
      .set_min_iterations(max(2,.min_iterations))

      ! Set DIIS defaults
      .SCF_DIIS.set_convergence_tolerance(TOL(4))
      .SCF_DIIS.set_keep(4)

      ! CPHF DIIS (leaky)
      .CP_DIIS.destroy
      .CP_DIIS.create(n_pert)
      .CP_DIIS.set_defaults(.SCF_DIIS)
      .CP_DIIS.set_use_errors(TRUE)

   end

   update_lambda ::: pure
   ! Increments lambda by lambda_step
      self :: INOUT

      .lambda           = .lambda + .lambda_step
      .lambda_iteration = .lambda_iteration + 1
      .old_fit_value    = .old_energy + .lambda * .old_penalty
      .fit_value        = .energy + .lambda * .penalty

   end

   update_iteration ::: pure
   ! Update the SCF iteration
      self :: INOUT

      .iteration        = .iteration + 1
      .total_iterations = .total_iterations + 1

   end

   update_energy(energy) ::: PURE
   ! Update the energy and penalty needed in constrained fits.
      self :: INOUT
      energy :: REAL, IN

      ! Keep old values
      .old_energy    = .energy
      .old_fit_value = .fit_value

      ! Set new values
      .energy = energy
      if (.fitting) then
         .set_penalty
         .fit_value = energy + .lambda * .penalty
      end

      ! Set initiual energy
      if (.iteration==0) then 
         .E_initial = .energy
      end

      ! Set energy differences
      .delta = .energy - .old_energy

   end

   update_DIIS_from_CP_DIIS ::: PURE
   ! Update the CP vector difference
      self :: INOUT
      .SCF_DIIS = .CP_DIIS(1)
   end

   update_CP_difference(delta) ::: pure
   ! Update the CP vector difference
      self :: INOUT
      delta :: REAL, IN
      .delta = delta 
   end

!  ============
!  Set routines
!  ============

   set_use_NOMO(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_NOMO), pure
   ! Generic set
   end

   set_use_ELMO(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: BIN, IN
      .use_ELMO = val
   end

   set_ELMO_B(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: INT, IN
      .elmo_b = val
   end

   set_ELMO_P(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: INT, IN
      .elmo_p = val
   end


   set_use_ELMO_01(val) ::: public, pure
   ! Generic set
      self :: INOUT
      val :: BIN, IN
      .use_ELMO_01 = val
   end

   set_use_ELMO_11(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: BIN, IN
      .use_ELMO_11 = val
   end

   set_use_BFGS(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_BFGS), pure
   ! Generic set
   end

   set_use_LSQ(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_LSQ), pure
   ! Generic set
   end

   set_1e_sl_factor(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.sl_1e_factor), pure
   ! Generic set
   end

   set_2e_sl_factor(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.sl_2e_factor), pure
   ! Generic set
   end

   set_atom_overlap_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.atom_overlap_cutoff), pure
   ! Generic set
   end

   set_delete_SCF_archives(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.delete_SCF_archives), pure
   ! Generic set
   end

   set_delete_all_archives(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.delete_all_archives), pure
   ! Generic set
   end

   set_cluster_radius(val) ::: PURE
   ! Set the cluster radius
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>0,"cluster_radius must be positive")

      .cluster_radius = val

   end

   set_convergence(val) ::: PURE
   ! Set SCF energy convergence criteria
      self :: INOUT
      val :: REAL, IN

 ! ENSURE(.convergence>TOL(12),"convergence may be too small")

      .convergence = val

   end

   set_damp_factor(val) ::: PURE
   ! Set the SCF density matrix damping factor
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"damp_factor must be positive")
   ENSURE(val<=ONE,"damp_factor must not exceed 1 ")

      .damp_factor = val

   end

   set_damp_finish(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.damp_finish), pure
   ! Generic set
   end

   ! Testing, turn off defragment in case of network compounds 
   ! Lorraine. 

   set_defragment(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.defragment), PURE
   ! Generic set
   end

   set_correlation_functional(val)  ::: PURE
   ! Set the DFT correlation functional
      self :: INOUT
      val :: STR, IN

      .DFT_correlation_functional = val
      .DFT_correlation_functional.to_lower_case

      select case (.DFT_correlation_functional)
      case("       "); .using_GGA_correlation = FALSE
      case("none   "); .using_GGA_correlation = FALSE
      case("vwn5   "); .using_GGA_correlation = FALSE
      case("vwn3   "); .using_GGA_correlation = FALSE
      case("lyp    "); .using_GGA_correlation = TRUE
      case("b3lypc "); .using_GGA_correlation = TRUE
      case("b3lypgc"); .using_GGA_correlation = TRUE
    ! case default;        UNKNOWN(.DFT_correlation_functional)
      end

   end

   set_exchange_functional(val) ::: PURE
   ! Set the DFT exchange functional
      self :: INOUT
      val :: STR, IN

      .DFT_exchange_functional = val
      .DFT_exchange_functional.to_lower_case

      .using_hybrid_exchange = FALSE

      select case (.DFT_exchange_functional)
      case("       "); .using_GGA_exchange = FALSE
      case("none   "); .using_GGA_exchange = FALSE
      case("slater "); .using_GGA_exchange = FALSE
      case("xalpha "); .using_GGA_exchange = FALSE
      case("becke88"); .using_GGA_exchange = TRUE
      case("b3lypx "); .using_GGA_exchange = TRUE
      case("b3lypgx"); .using_GGA_exchange = TRUE
                       .using_hybrid_exchange = TRUE
      case("gill96 "); .using_GGA_exchange = TRUE
    ! case default;    UNKNOWN(.DFT_exchange_functional)
      end

   end

   set_DIIS_error(val) ::: pure
   ! Set the DIIS error and the starting iteration for automatic DIIS start
      self :: INOUT
      val :: REAL, IN

      .old_DIIS_error = .DIIS_error
      .DIIS_error     = val

   end

   set_DIIS_error_temp_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.DIIS_error_temp_cutoff), pure
   ! Generic set
   end

   set_ERI_bf_overlap_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.ERI_bf_overlap_cutoff), pure
   ! Generic set
   end

   set_ee_adiabatic_constant(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.ee_adiabatic_constant), pure
   ! Generic set
   end

   set_Fermi_Amaldi(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_Fermi_Amaldi), pure
   ! Generic set
   end

   set_ERI_disk_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.ERI_disk_cutoff), pure
   ! Generic set
   end

   set_ERI_J_density_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.ERI_J_density_cutoff), pure
   ! Generic set
   end

   set_ERI_K_density_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.ERI_K_density_cutoff), pure
   ! Generic set
   end

   set_ERI_primitive_pair_cutoff(val)
   ! Set the ERI primitive pair cutoff
      self :: INOUT
      val :: REAL

      sh4 :: SHELL1QUARTET

      if (FALSE) self = self
      sh4.set_pair_cutoff(val)

   end

   set_ERI_Schwarz_cutoff(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.ERI_Schwarz_cutoff), pure
   ! Generic set
   end

   set_guess_output(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.guess_output), pure
   ! Generic set
   end

   set_initial_density(val) ::: PURE
   ! Set the initial density type to use for SCF guess
      self :: INOUT
      val :: STR, IN

      .initial_density = val
      .initial_density.to_lower_case

      select case (.initial_density)
      case("--using mo's--      "); .restart_SCF = TRUE
      case("core                ")  ! No reading
      case("fock                ")  ! No reading
      case("promolecule         ")  ! No reading
      case("progroup            "); .restart_SCF = TRUE ! ??? Reading or calculated
      case("r                   "); .restart_SCF = TRUE
      case("restricted          "); .restart_SCF = TRUE
      case("u                   "); .restart_SCF = TRUE
      case("unrestricted        "); .restart_SCF = TRUE
      case("g                   "); .restart_SCF = TRUE
      case("general_complex     "); .restart_SCF = TRUE
    ! case default;  UNKNOWN(.initial_density)
      end

      ! Need to reset set this
      .initial_MOs = "--using density--"

   end

   set_initial_MOs(val) ::: PURE
   ! Read the initial MOs to use as SCF guess
      self :: INOUT
      val :: STR, IN

      .initial_MOs = val
      .initial_MOs.to_lower_case

      select case (.initial_MOs)
      case("--using density--   ")
      case("r                   "); .restart_SCF = TRUE
      case("restricted          "); .restart_SCF = TRUE
      case("u                   "); .restart_SCF = TRUE
      case("unrestricted        "); .restart_SCF = TRUE
      case("g                   "); .restart_SCF = TRUE
      case("general_complex     "); .restart_SCF = TRUE
    ! case default;   UNKNOWN(.initial_MOs)
      end

      ! Need to reset set this
      .initial_density = "--using MO's--"

   end

   set_initial_lambda(val) ::: pure
   ! Set the initial lambda value for constrained SCF
      self :: INOUT
      val :: REAL, IN

      .initial_lambda = val
      .lambda         = val

   end

   set_initial_Us(val) ::: PURE
   ! Set initial U's to use as CPHF guess
      self :: INOUT
      val :: STR, IN

      .initial_Us = val
      .initial_Us.to_lower_case

      select case (.initial_Us)
      case("                    ")
      case("restricted          ")
    ! case default;   UNKNOWN(.initial_Us)
      end

   end

   set_is_guess(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.is_guess), pure
   ! Generic set
   end

   set_SCF_kind(val) ::: PURE
   ! Read the SCF type
      self :: INOUT
      val :: STR, IN

      .SCF_kind = val
      .SCF_kind.to_lower_case

      select case (.SCF_kind)
      case("gchf        ") ! General complex Hartree-Fock
      case("ghf         ") ! General Hartree-Fock
      case("group       ") ! General Hartree-Fock
      case("no_ghf      ") ! Nono-orthogonal GHF
      case("rchf        ") ! Restricted complex Hartree-Fock
      case("rhf         ") ! Restricted Hartree-Fock
      case("rks         ") ! Restricted Kohn-Sham
      case("rohf        ") ! Restricted open shell Hartree-Fock
      case("uchf        ") ! Unrestricted complex Hartree-Fock
      case("uhf         ") ! Unrestricted Hartree-Fock
      case("uks         ") ! Unrestricted Kohn-Sham
      case("unrestricted"); .SCF_kind = "uhf"
      case("restricted  "); .SCF_kind = "rhf"
      case("general     "); .SCF_kind = "ghf"
      case("xray_rhf    ") ! X-ray-constrained restricted Hartree-Fock
      case("xray_uhf    ") ! X-ray-constrained unrestricted Hartree-Fock
      case("xray_gchf   ") ! X-ray-constrained unrestricted Hartree-Fock
      case("xray_rks    ") ! X-ray-constrained restricted Kohn-Sham
      case("xray_uks    ") ! X-ray-constrained unrestricted Kohn-Sham
    ! case("pnd_uhf     ") ! polarised neutron diffraction uhf
    ! case("pnd_uks     ") ! polarised neutron diffraction uks
    ! case("xray_pnd_uhf") ! joint xray, pnd uhf
    ! case("xray_pnd_uks") ! joint xray, pnd uks
      case("fragment-rhf ") ! 
      case("fragment-rks ") ! 
    ! case default;    UNKNOWN(.SCF_kind)
      end

   end

   set_lambda_max(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.lambda_max), pure
   ! Generic set
   end

   set_lambda_step(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.lambda_step), pure
   ! Generic set
   end

   set_level_shift(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.level_shift), pure
   ! Generic set
   end

   set_level_shift_finish(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.level_shift_finish), pure
   ! Generic set
   end

   set_linear_dependence_shift(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.linear_dependence_shift), pure
   ! Generic set
   end

   set_linear_dependence_tol(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.linear_dependence_tol), pure
   ! Generic set
   end

   set_min_overlap_mx_eigenvalue(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.min_overlap_mx_eigenvalue), pure
   ! Generic set
   end

   set_n_small_S_eigenvalues(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.n_small_S_eigenvalues), pure
   ! Generic set
   end

   set_n_neg_S_eigenvalues(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.n_neg_S_eigenvalues), pure
   ! Generic set
   end

   set_min_iterations(val) ::: PURE
   ! Set the minimum no. of SCF interations
      self :: INOUT
      val :: INT, IN

   ENSURE(val>=0,"min_iteration must be non-negative")
   ENSURE(.max_iterations>=val,"must not exceed max_iterations!")

      .min_iterations = val

   end

   set_max_iterations(val) ::: PURE
   ! Set the maximum no. of SCF interations
      self :: INOUT
      val :: INT, IN

   ENSURE(val>=0,"must be non-negative")
   ENSURE(val>=.min_iterations,"must be at least as large as min_iterations!")

      .max_iterations = val

   end

   set_max_update_stepsize(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.max_update_stepsize), pure
   ! Generic set
   end

   set_nhf(val) ::: PURE
   ! Set what ... ?
      self :: INOUT
      val :: INT, IN

      .nhf = val

   end

   set_MO_gradient_stepsize(val) ::: get_from(OBJECT:set, VAL?=>REAL, ARG?=>.MO_gradient_stepsize), pure
   ! Generic set
   end

   set_output(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: BIN, IN

      .output         = val
      .output_results = val

   end

   set_output_results(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.output_results), pure
   ! Generic set
   end

   set_quantization_axis(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.quantization_axis), pure
   ! Generic set
   end

   set_relativity_kind(val) ::: PURE
   ! Read whether to use Douglas-Kroll-Hess
      self :: INOUT
      val :: STR, IN

      .relativity_kind = val
      .relativity_kind.to_lower_case

      select case (.relativity_kind)
      case ("iotc");
      case ("douglas-kroll-hess");
      case ("dkh");
      case ("douglas-kroll-hess-2");
      case ("dkh-2");
      case ("none");
      case ("pauli");
      case ("zora");
    ! case default;   UNKNOWN(.relativity_kind)
      end

      .set_pauli_terms_off
      if (.relativity_kind=="pauli") .set_pauli_terms_on

   end

   set_restart_skip_asfs(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: BIN, IN

      .restart_skip_asfs = val

   end

   set_save_cluster_charges(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.save_cluster_charges), pure
   ! Generic set
   end

   set_stabilize_density(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.stabilize_density), pure
   ! Generic set
   end

   set_test(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.test), pure
   ! Generic set
   end

   set_temperature(val)
   ! Set the electronic temperature
      self :: INOUT
      val  :: REAL, IN

   ENSURE(val>=ZERO, "must set non-negative temperature in Hartree")

      if (val==ZERO) then
         .temperature = ZERO
         .using_FON   = FALSE
      else
         .temperature = val
         .using_FON   = TRUE
      end

   end

   set_using_1e_sl_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_1e_sl_term), pure
   ! Generic set
   end

   set_using_1e_srxa_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_1e_srxa_term), pure
   ! Generic set
   end

   set_using_1e_zora_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_1e_zora_term), pure
   ! Generic set
   end

   set_using_2e_sl_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_2e_sl_term), pure
   ! Generic set
   end

   set_using_aa_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_aa_term), pure
   ! Generic set
   end

   set_using_bl_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_bl_term), pure
   ! Generic set
   end

   set_using_bs_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_bs_term), pure
   ! Generic set
   end

   set_using_bs_t_term(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_bs_t_term), pure
   ! Generic set
   end

   set_n_pert(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.n_pert), pure
   ! Generic set
   end

   set_using_CP_DIIS(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_CP_DIIS), pure
   ! Generic set
   end

   set_using_cluster_charges(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_cluster_charges), pure
   ! Generic set
   end

   set_using_damping(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_damping), pure
   ! Generic set
   end

   set_use_default_guess_options(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.use_default_guess_options), pure
   ! Generic set
   end

   set_using_delta_build(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_delta_build), pure
   ! Generic set
   end

   set_using_direct_SCF(val) ::: pure
   ! Set whether to use direct SCF or not
      self :: INOUT
      val :: BIN, IN

      .using_direct_SCF = val
      if (.using_direct_SCF) .using_delta_build = TRUE

   end

   set_using_DK1(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.DK1), pure
   ! Generic set
   end

   set_using_DK2(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.DK2), pure
   ! Generic set
   end

   set_using_DK3(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.DK3), pure
   ! Generic set
   end

   set_using_DK1_PCE(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.DK1_PCE), pure
   ! Generic set
   end

   set_using_DK2_PCE(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.DK2_PCE), pure
   ! Generic set
   end

   set_using_exponential_update(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_exponential_update), pure
   ! Generic set
   end

   set_using_DIIS(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_DIIS), pure
   ! Generic set
   end

   set_using_level_shift(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_level_shift), pure
   ! Generic set
   end

   set_using_MO_gradient_update(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_MO_gradient_update), pure
   ! Generic set
   end

   set_using_NDDO(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_NDDO), pure
   ! Generic set
   end

   set_using_NUDO(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_NUDO), pure
   ! Generic set
   end

   set_using_orbital_locking(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_orbital_locking), pure
   ! Generic set
   end

   set_using_PCE_correction(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.PCE_CORR), pure
   ! Generic set
   end

   set_using_PIE(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_PIE), pure
   ! Generic set
   end

   set_using_ppzpp_method(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_ppzpp), pure
   ! Generic set
   end

   set_using_pFON_damping(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_pFON), pure
   ! Generic set
   end

   set_using_qq_cluster_charges(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_qq_cluster_charges), pure
   ! Generic set
   end

   set_using_SC_cluster_charges(val) ::: pure
   ! Set whether to use SC cluster charges
      self :: INOUT
      val :: BIN, IN

      .using_SC_cluster_charges = val
      if (val) .using_cluster_charges = val

   end

   set_using_SC_Lorentz_fields(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_SC_Lorentz_fields), pure
   ! Generic set
   end

   set_using_SO_FDFF_method(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.using_SO_FDFF), pure
   ! Generic set
   end

   set_XC_atom_separation_cutoff(val) ::: PURE
   ! Set the XC atom separation cutoff
      self :: INOUT
      val :: REAL, IN

   ENSURE(val>ZERO,"cutoff must be positive")

      .XC_atom_separation_cutoff = val

   end

   set_zero_oo_constraint_block(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.zero_oo_constraint_block), pure
   ! Generic set
   end

   set_initial_atomic_states(qmult) ::: leaky, private, PURE
   ! Set the elemental dispersion coefficients from a "table"
   ! of values comprising sequential element symbols, f' and f''.
      self  :: INOUT
      qmult :: VEC{INT}, IN 

   ENSURE((qmult.dim/2)*2==qmult.dim,"the must be an even number of charges/multiplicities")

      n,i,q,mult,offset :: INT

      ! Size of array
      n = qmult.dim/2

      ! Create
      .initial_atomic_states.destroy
      .initial_atomic_states.create(n,2)

      offset = 0

      do i = 1,n

         ! Get charge & multiplicity
         q    = qmult(offset+1)
         mult = qmult(offset+2)

         ! Set the table
         .initial_atomic_states(i,1) = q
         .initial_atomic_states(i,2) = mult

         offset = offset + 2

      end

   end

!  =============
!  Input methods
!  =============

   ! NOTE : this must be finalized after the call.

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process a command "keyword". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
      self :: INOUT
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("1e_sl_factor=                "); .read_1e_sl_factor
      case ("2e_sl_factor=                "); .read_2e_sl_factor
      case ("}                            ")  ! exit case
      case ("atom_overlap_cutoff=         "); .read_atom_overlap_cutoff
      case ("cluster_radius=              "); .read_cluster_radius
      case ("convergence=                 "); .read_convergence
      case ("converge=                    "); .read_convergence
      case ("damp_factor=                 "); .read_damp_factor
      case ("damp_finish=                 "); .read_damp_finish
      case ("defragment=                  "); .read_defragment ! testing, turn off defragment in case of network compounds, Lorraine. 
      case ("delete_all_archives=         "); .read_delete_all_archives
      case ("delete_scf_archives=         "); .read_delete_SCF_archives
      case ("dft_correlation_functional=  "); .read_correlation_functional
      case ("dft_exchange_functional=     "); .read_exchange_functional
      case ("diis=                        "); .read_DIIS
      case ("diis_error_temp_cutoff=      "); .read_DIIS_error_temp_cutoff
      case ("direct=                      "); .read_using_direct_SCF ! deprecated
      case ("do_outputs=                  "); .read_do_outputs
      case ("ee_adiabatic_constant=       "); .read_ee_adiabatic_constant
      case ("elmo_b=                      "); .read_ELMO_B
      case ("elmo_p=                      "); .read_ELMO_P
      case ("eri_bf_overlap_cutoff=       "); .read_ERI_bf_overlap_cutoff
      case ("eri_disk_cutoff=             "); .read_ERI_disk_cutoff
      case ("eri_j_density_cutoff=        "); .read_ERI_J_density_cutoff
      case ("eri_k_density_cutoff=        "); .read_ERI_K_density_cutoff
      case ("eri_primitive_pair_cutoff=   "); .read_ERI_primitive_pair_cutoff
      case ("eri_schwarz_cutoff=          "); .read_ERI_Schwarz_cutoff
      case ("guess_output=                "); .read_guess_output
      case ("initial_atomic_states=       "); .read_initial_atomic_states
      case ("initial_density=             "); .read_initial_density
      case ("initial_lambda=              "); .read_initial_lambda
      case ("initial_mos=                 "); .read_initial_MOs
      case ("initial_us=                  "); .read_initial_Us
      case ("kind=                        "); .read_SCF_kind !  deprecated
      case ("lambda_max=                  "); .read_lambda_max
      case ("lambda_step=                 "); .read_lambda_step
      case ("level_shift=                 "); .read_level_shift
      case ("level_shift_finish=          "); .read_level_shift_finish
      case ("linear_dependence_shift=     "); .read_linear_dependence_shift
      case ("linear_dependence_tol=       "); .read_linear_dependence_tol
      case ("min_iterations=              "); .read_min_iterations
      case ("max_iterations=              "); .read_max_iterations
      case ("max_update_stepsize=         "); .read_max_update_stepsize
      case ("mo_gradient_stepsize=        "); .read_MO_gradient_stepsize
      case ("nhf=                         "); .read_nhf
      case ("output=                      "); .read_output
      case ("output_results=              "); .read_output_results
      case ("put_cluster                  "); .put_cluster
      case ("put_cluster_charges          "); .put_cluster_charges("cluster_charges")
      case ("quantization_axis=           "); .read_quantization_axis
      case ("relativity_kind=             "); .read_relativity_kind
      case ("restart_skip_asfs=           "); .read_restart_skip_ASFs
      case ("save_cluster_charges=        "); .read_save_cluster_charges
      case ("scf_kind=                    "); .read_SCF_kind
      case ("scf_type=                    "); .read_SCF_kind !  deprecated
      case ("stabilize_density=           "); .read_stabilize_density
      case ("temperature=                 "); .read_temperature
      case ("test=                        "); .read_test
      case ("use_1e_sl_term=              "); .read_using_1e_sl_term
      case ("use_1e_s(rxa)_term=          "); .read_using_1e_srxa_term
      case ("use_1e_zora_term=            "); .read_using_1e_zora_term
      case ("use_2e_sl_term=              "); .read_using_2e_sl_term
      case ("use_aa_term=                 "); .read_using_aa_term
      case ("use_bfgs=                    "); .read_use_BFGS
      case ("use_bl_term=                 "); .read_using_bl_term
      case ("use_bs_term=                 "); .read_using_bs_term
      case ("use_bs_t_term=               "); .read_using_bs_t_term
      case ("use_cp_DIIS=                 "); .read_using_CP_DIIS
      case ("use_cluster_charges=         "); .read_using_cluster_charges
      case ("use_damping=                 "); .read_using_damping
      case ("use_default_guess_options=   "); .read_use_default_guess_options
      case ("use_delta_build=             "); .read_using_delta_build
      case ("use_direct_scf=              "); .read_using_direct_SCF
      case ("use_diis=                    "); .read_using_DIIS
      case ("use_dk1=                     "); .read_using_DK1
      case ("use_dk2=                     "); .read_using_DK2
      case ("use_dk3=                     "); .read_using_DK3
      case ("use_dk1_pce=                 "); .read_using_DK1_PCE
      case ("use_dk2_pce=                 "); .read_using_DK2_PCE
      case ("use_elmo=                    "); .read_use_ELMO
      case ("use_elmos=                   "); .read_use_ELMO
      case ("use_elmo_01=                 "); .read_use_ELMO_01
      case ("use_elmo_11=                 "); .read_use_ELMO_11
      case ("use_exponential_update=      "); .read_using_exponential_update
      case ("use_fermi_amaldi=            "); .read_using_Fermi_Amaldi
      case ("use_level_shifting=          "); .read_using_level_shift
      case ("use_level_shift=             "); .read_using_level_shift
      case ("use_lsq=                     "); .read_use_LSQ
      case ("use_mo_gradient_update=      "); .read_using_MO_gradient_update
      case ("use_nddo=                    "); .read_using_NDDO
      case ("use_nomo=                    "); .read_use_NOMO
      case ("use_nudo=                    "); .read_using_NUDO
      case ("use_orbital_locking=         "); .read_using_orbital_locking
      case ("use_pce_corr=                "); .read_using_PCE_correction
      case ("use_pie=                     "); .read_using_PIE
      case ("use_ppzpp=                   "); .read_using_ppzpp_method
      case ("use_pfon_damping=            "); .read_using_pFON_damping
      case ("use_qq_cluster_charges=      "); .read_using_qq_cluster_charges
      case ("use_sc_cluster_charges=      "); .read_using_SC_cluster_charges
      case ("use_sc_lorentz_fields=       "); .read_using_SC_Lorentz_fields
      case ("use_so_fdff=                 "); .read_using_SO_FDFF_method
      case ("xc_atom_separation_cutoff=   "); .read_XC_atom_separation_cutoff
      case ("zero_oo_constraint_block=    "); .read_zero_oo_constraint_block
      case default;           UNKNOWN(word)
      
      end

   end

   update ::: PURE
   ! Make sure the input satisfies sanity checks and generate
   ! any other missing data
      self :: INOUT

   ENSURE(.SCF_kind/=" ","no scf kind specified")
   ENSURE(.max_iterations>=.min_iterations,"max_it must be greater than min_it!")
   ENSURE(.SCF_DIIS.keep           >0,"DIIS.keep must be > 0")
   ENSURE(.SCF_DIIS.start_iteration>0,"DIIS.start_iteration must be > 0")
   ENSURE(.SCF_DIIS.save_iteration >0,"DIIS.save_iteration must be > 0")

      val :: BIN

      if (.using_1e_zora_term)   .using_1e_sl_term = FALSE
      if (.using_1e_sl_term)     .using_1e_zora_term = FALSE

      if (.using_SC_cluster_charges OR .using_cluster_charges) then

         val = .is_constrained_wavefunction AND NOT .using_SC_cluster_charges
         ENSURE(NOT val,"must use SC_cluster_charges!")

         val = .initial_density=="core" OR .initial_density=="promolecule"
         ENSURE(NOT val,"must use previous densityor MOs for initial guess")

         if (.using_SC_cluster_charges) then
            .using_cluster_charges = TRUE
         end

      end

   end

!  ====
!  Read
!  ====

   read_1e_sl_factor ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_1e_sl_factor), private
   ! Generic read and set a quantity with units
   end

   read_2e_sl_factor ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_2e_sl_factor), private
   ! Generic read and set a quantity with units
   end

   read_atom_overlap_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_atom_overlap_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_cluster_radius ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_cluster_radius), private
   ! Generic read and set a quantity with units
   end

   read_convergence ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_convergence), private
   ! Generic read and set a quantity with units
   end

   read_damp_factor ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_damp_factor), private
   ! Generic read and set a quantity with units
   end

   read_damp_finish ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_damp_finish), private
   ! Generic read and set a quantity with units
   end

   read_defragment
   ! Read whether to defragment the cluster at the boundaries. If set TRUE, the
   ! cluster ends are defragmented, i.e. any atoms which are bonded at the ends
   ! of the cluster are included into the cluster. LORRAINE!
      self :: INOUT

      stdin.read(.defragment)

   end

   read_delete_all_archives ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_delete_all_archives), private
   ! Generic read and set
   end

   read_delete_SCF_archives ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_delete_SCF_archives), private
   ! Generic read and set
   end

   read_correlation_functional ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_correlation_functional), private
   ! Generic read and set
   end

   read_exchange_functional ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_exchange_functional), private
   ! Generic read and set
   end

   read_DIIS ::: private
   ! Read the DIIS options
      .SCF_DIIS.read_keywords
   end

   read_DIIS_error_temp_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_DIIS_error_temp_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_ERI_bf_overlap_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ERI_bf_overlap_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_ee_adiabatic_constant ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ee_adiabatic_constant), private
   ! Generic read and set a quantity with units
   end

   read_ELMO_B ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_ELMO_B), private
   ! Generic read and set
   end

   read_ELMO_P ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_ELMO_P), private
   ! Generic read and set
   end


   read_use_NOMO ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_NOMO), private
   ! Generic read and set
   end

   read_use_ELMO ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_ELMO), private
   ! Generic read and set
   end

   read_use_ELMO_01 ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_ELMO_01), private
   ! Generic read and set
   end

   read_use_ELMO_11 ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_ELMO_11), private
   ! Generic read and set
   end

   read_use_BFGS ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_BFGS), private
   ! Generic read and set
   end

   read_use_LSQ ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_LSQ), private
   ! Generic read and set
   end


   read_using_Fermi_Amaldi ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_Fermi_Amaldi), private
   ! Generic read and set
   end

   read_ERI_disk_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ERI_disk_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_ERI_J_density_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ERI_J_density_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_ERI_K_density_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ERI_K_density_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_ERI_primitive_pair_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ERI_primitive_pair_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_ERI_Schwarz_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_ERI_Schwarz_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_guess_output ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_guess_output), private
   ! Generic read and set
   end

   read_initial_density ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_initial_density), private
   ! Generic read and set
   end

   read_initial_atomic_states ::: private, leaky
   ! Read the initial charges and multiplicities as a flat list for
   ! the unique atoms.
      self :: INOUT

      qmult :: VEC{INT}@

      stdin.read_all(qmult)
      .set_initial_atomic_states(qmult)
      qmult.destroy

   end

   read_initial_lambda ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_initial_lambda), private
   ! Generic read and set a quantity with units
   end

   read_initial_MOs ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_initial_MOs), private
   ! Generic read and set
   end

   read_initial_Us ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_initial_Us), private
   ! Generic read and set
   end

   read_lambda_max ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_lambda_max), private
   ! Generic read and set a quantity with units
   end

   read_lambda_step ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_lambda_step), private
   ! Generic read and set a quantity with units
   end

   read_level_shift ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_level_shift), private
   ! Generic read and set a quantity with units
   end

   read_level_shift_finish ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_level_shift_finish), private
   ! Generic read and set
   end

   read_linear_dependence_shift ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_linear_dependence_shift), private
   ! Generic read and set a quantity with units
   end

   read_linear_dependence_tol ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_linear_dependence_tol), private
   ! Generic read and set a quantity with units
   end

   read_min_iterations ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_min_iterations), private
   ! Generic read and set
   end

   read_max_iterations ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_max_iterations), private
   ! Generic read and set
   end

   read_max_update_stepsize ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_max_update_stepsize), private
   ! Generic read and set a quantity with units
   end

   read_nhf ::: get_from(OBJECT:read_and_set, VAL?=>INT, SET?=>.set_nhf), private
   ! Generic read and set
   end

   read_MO_gradient_stepsize ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_MO_gradient_stepsize), private
   ! Generic read and set a quantity with units
   end

   read_output ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_output), private
   ! Generic read and set
   end

   read_do_outputs
   ! Read whether to output result files for every lambda step in the
   ! XCW. This will mess up the stdout text!
      self :: INOUT

      stdin.read(.do_outputs)

   end

   read_output_results ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_output_results), private
   ! Generic read and set
   end

   read_quantization_axis ::: get_from(OBJECT:read_and_set, VAL?=>VEC{REAL}(3), SET?=>.set_quantization_axis), private
   ! Generic read and set
   end

   read_relativity_kind ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_relativity_kind), private
   ! Generic read and set
   end

   read_restart_skip_ASFs ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_restart_skip_asfs), private
   ! Generic read and set
   end

   read_save_cluster_charges ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_save_cluster_charges), private
   ! Generic read and set
   end

   read_SCF_kind ::: get_from(OBJECT:read_and_set, VAL?=>STR, SET?=>.set_SCF_kind), private
   ! Generic read and set
   end

   read_stabilize_density ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_stabilize_density), private
   ! Generic read and set
   end

   read_temperature
   ! Generic read and set
      self :: INOUT
      val :: REAL

      stdin.read(val)

      .set_temperature(val)

   end

   read_test ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_test), private
   ! Generic read and set
   end

   read_using_1e_sl_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_1e_sl_term), private
   ! Generic read and set
   end

   read_using_1e_srxa_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_1e_srxa_term), private
   ! Generic read and set
   end

   read_using_1e_zora_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_1e_zora_term), private
   ! Generic read and set
   end

   read_using_2e_sl_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_2e_sl_term), private
   ! Generic read and set
   end

   read_using_aa_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_aa_term), private
   ! Generic read and set
   end

   read_using_bl_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_bl_term), private
   ! Generic read and set
   end

   read_using_bs_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_bs_term), private
   ! Generic read and set
   end

   read_using_bs_t_term ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_bs_t_term), private
   ! Generic read and set
   end

   read_using_CP_DIIS ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_CP_DIIS), private
   ! Generic read and set
   end

   read_using_cluster_charges ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_cluster_charges), private
   ! Generic read and set
   end

   read_using_damping ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_damping), private
   ! Generic read and set
   end

   read_use_default_guess_options ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_use_default_guess_options), private
   ! Generic read and set
   end

   read_using_delta_build ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_delta_build), private
   ! Generic read and set
   end

   read_using_direct_SCF ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_direct_SCF), private
   ! Generic read and set
   end

   read_using_DK1 ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_DK1), private
   ! Generic read and set
   end

   read_using_DK2 ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_DK2), private
   ! Generic read and set
   end

   read_using_DK3 ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_DK3), private
   ! Generic read and set
   end

   read_using_DK1_PCE ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_DK1_PCE), private
   ! Generic read and set
   end

   read_using_DK2_PCE ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_DK2_PCE), private
   ! Generic read and set
   end

   read_using_exponential_update ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_exponential_update), private
   ! Generic read and set
   end

   read_using_DIIS ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_DIIS), private
   ! Generic read and set
   end

   read_using_level_shift ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_level_shift), private
   ! Generic read and set
   end

   read_using_MO_gradient_update ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_MO_gradient_update), private
   ! Generic read and set
   end

   read_using_NDDO ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_NDDO), private
   ! Generic read and set
   end

   read_using_NUDO ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_NUDO), private
   ! Generic read and set
   end

   read_using_orbital_locking ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_orbital_locking), private
   ! Generic read and set
   end

   read_using_PCE_correction ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_PCE_correction), private
   ! Generic read and set
   end

   read_using_PIE ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_PIE), private
   ! Generic read and set
   end

   read_using_ppzpp_method ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_ppzpp_method), private
   ! Generic read and set
   end

   read_using_pFON_damping ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_pFON_damping), private
   ! Generic read and set
   end

   read_using_qq_cluster_charges ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_qq_cluster_charges), private
   ! Generic read and set
   end

   read_using_SC_cluster_charges ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_SC_cluster_charges), private
   ! Generic read and set
   end

   read_using_SC_Lorentz_fields ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_SC_Lorentz_fields), private
   ! Generic read and set
   end

   read_using_SO_FDFF_method ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_using_SO_FDFF_method), private
   ! Generic read and set
   end

   read_XC_atom_separation_cutoff ::: get_from(OBJECT:read_and_set, VAL?=>REAL, SET?=>.set_XC_atom_separation_cutoff), private
   ! Generic read and set a quantity with units
   end

   read_zero_oo_constraint_block ::: get_from(OBJECT:read_and_set, VAL?=>BIN, SET?=>.set_zero_oo_constraint_block), private
   ! Generic read and set
   end


!  ================================================
!  Query the type of orbitals and their number kind
!  ===============================================

   spinorbital_kind(SCF_kind) result (res) ::: pure
   ! Return the kind of spinorbitals used for the fock_mx and
   ! density_mx (but *not* neccesarily the MO's -- see below)
   ! in doing a particular "SCF_kind" of SCF calculation.
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: STR

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      select case (s_kind)
      case("group        "); res = "restricted" ! for now
      case("rhf          "); res = "restricted"
      case("rks          "); res = "restricted"
      case("rohf         "); res = "unrestricted"
      case("uhf          "); res = "unrestricted"
      case("uks          "); res = "unrestricted"
      case("gchf         "); res = "general_complex"
    ! case("pnd_uhf      "); res = "unrestricted"
    ! case("pnd_uks      "); res = "unrestricted"
      case("xray_rhf     "); res = "restricted"
      case("xray_rks     "); res = "restricted"
      case("xray_uhf     "); res = "unrestricted"
      case("xray_uks     "); res = "unrestricted"
      case("xray_gchf    "); res = "general_complex"
    ! case("xray_pnd_uhf "); res = "unrestricted"
    ! case("xray_pnd_uks "); res = "unrestricted"
      case("rdvpt        "); res = "restricted"
      case("fragment-rhf "); res = "restricted" 
      case("fragment-rks "); res = "restricted" 
    ! case default; DIE("unknown scf kind: "//trim(s_kind))
      end

   end

   spinorbital_genre(SCF_kind) result (res) ::: pure
   ! Return the kind of spinorbitals used for the fock_mx and
   ! density_mx (but *not* neccesarily the MO's -- see below)
   ! in doing a particular "SCF_kind" of SCF calculation.
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: STR

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      select case (s_kind)
      case("group        "); res = "r" ! for now
      case("rhf          "); res = "r"
      case("rks          "); res = "r"
      case("rohf         "); res = "u"
      case("uhf          "); res = "u"
      case("uks          "); res = "u"
      case("gchf         "); res = "gc"
    ! case("pnd_uhf      "); res = "u"
    ! case("pnd_uks      "); res = "u"
      case("xray_rhf     "); res = "r"
      case("xray_rks     "); res = "r"
      case("xray_uhf     "); res = "u"
      case("xray_uks     "); res = "u"
      case("xray_gchf    "); res = "gc"
    ! case("xray_pnd_uhf "); res = "u"
    ! case("xray_pnd_uks "); res = "u"
      case("rdvpt        "); res = "r"
      case("fragment-rhf "); res = "r" 
      case("fragment-rks "); res = "r" 
    ! case default; DIE("unknown scf kind: "//trim(s_kind))
      end

   end

   initial_density_genre result (res) ::: pure
   ! Return the kind of spinorbitals used for the initial density
   ! when it is to be *read in* not calculated.
      self :: IN
      res :: STR

      select case (.initial_density)
      case("core           "); res = "r"
      case("fock           "); res = "r"
      case("g              "); res = "gc"
      case("general_complex"); res = "gc"
      case("promolecule    "); res = "r"
      case("r              "); res = "r"
      case("restricted     "); res = "r"
      case("u              "); res = "u"
      case("unrestricted   "); res = "u"
      end

   end

   is_restricted result (res) ::: pure
   ! Return TRUE if a restricted calculation
      self :: IN
      res :: BIN
      res = .spinorbital_kind=="restricted"
   end

   is_unrestricted result (res) ::: pure
   ! Return TRUE if a restricted calculation
      self :: IN
      res :: BIN
      res = .spinorbital_kind=="unrestricted"
   end

   is_general result (res) ::: pure
   ! Return TRUE if a general calculation
      self :: IN
      res :: BIN
      res = .spinorbital_kind=="general"
   end

   is_general_complex result (res) ::: pure
   ! Return TRUE if a general_complex calculation
      self :: IN
      res :: BIN
      res = .spinorbital_kind=="general_complex"
   end

   MOs_kind(SCF_kind) result (res) ::: PURE
   ! Return the kind of spinorbitals used for the molecular orbitals
   ! in a particular "SCF_kind". In only differs from the
   ! .spinorbital_kind for the ROHF kind of SCF calculation.
   ! This is also the kind of the core_mx needed for the SCF.
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: STR

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      select case (s_kind)
      case("rhf","rks");    res = "restricted"
      case("rohf");         res = "restricted"
      case("uhf","uks");    res = "unrestricted"
      case("ghf");          res = "general"
      case("no_ghf");       res = "general"
      case("rchf");         res = "restricted_complex"
      case("uchf");         res = "unrestricted_complex"
      case("gchf");         res = "general_complex"
    ! case("pnd_uhf");      res = "unrestricted"
    ! case("pnd_uks");      res = "unrestricted"
      case("xray_rhf");     res = "restricted"
      case("xray_rks");     res = "restricted"
      case("xray_uhf");     res = "unrestricted"
      case("xray_uks");     res = "unrestricted"
      case("xray_gchf");    res = "general_complex"
    ! case("xray_pnd_uhf"); res = "unrestricted"
    ! case("xray_pnd_uks"); res = "unrestricted"
      case("rdvpt");        res = "restricted"
      case("farghar-rhf "); res = "restricted" ! <<< This is a hack!
      case("farghar-rks "); res = "restricted" ! <<< This is a hack!
    ! case default; DIE("unknown scf kind")
      end

   end

   MOs_genre(SCF_kind) result (res) ::: PURE
   ! Return the genre of spinorbitals used for the MOs in a particular
   ! "SCF_kind". In only differs from the .spinorbital_kind for the
   ! ROHF kind of SCF calculation.  This is also the kind of the
   ! core_mx needed for the SCF.
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: STR

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      select case (s_kind)
      case("rhf         "); res = "r"
      case("rks         "); res = "r"
      case("rohf        "); res = "r"
      case("uhf         "); res = "u"
      case("uks         "); res = "u"
      case("gchf        "); res = "gc"
    ! case("pnd_uhf     "); res = "u"
    ! case("pnd_uks     "); res = "u"
      case("xray_rhf    "); res = "r"
      case("xray_rks    "); res = "r"
      case("xray_uhf    "); res = "u"
      case("xray_uks    "); res = "u"
      case("xray_gchf   "); res = "gc"
    ! case("xray_pnd_uhf"); res = "u"
    ! case("xray_pnd_uks"); res = "u"
      case("rdvpt       "); res = "r"
      case("farghar-rhf "); res = "r" ! <<< This is a hack!
      case("farghar-rks "); res = "r" ! <<< This is a hack!
    ! case default; DIE("unknown scf kind")
      end

   end

   MO_energies_kind(SCF_kind) result (res) ::: PURE
   ! Return the kind of vectors used for the orbital energies in a
   ! particular "SCF_kind"
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: STR

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      select case (s_kind)
      case("rhf","rks");    res = "restricted"
      case("rohf");         res = "restricted"
      case("uhf","uks");    res = "unrestricted"
      case("ghf");          res = "general"
      case("no_ghf");       res = "general"
      case("rchf");         res = "restricted"
      case("uchf");         res = "unrestricted"
      case("gchf");         res = "general"
    ! case("pnd_uhf");      res = "unrestricted"
    ! case("pnd_uks");      res = "unrestricted"
      case("xray_rhf");     res = "restricted"
      case("xray_uhf");     res = "unrestricted"
      case("xray_gchf");    res = "general"
    ! case("xray_pnd_uhf"); res = "unrestricted"
    ! case("xray_pnd_uks"); res = "unrestricted"
      case("xray_rks");     res = "restricted"
      case("xray_uks");     res = "unrestricted"
      case("rdvpt");        res = "restricted"
      case("fragment-rhf "); res = "restricted" 
      case("fragment-rks "); res = "restricted" 
    ! case default; DIE("unknown scf kind")
      end

   end

   MO_energies_genre(SCF_kind) result (res) ::: PURE
   ! Return the kind of vectors used for the orbital energies in a
   ! particular "SCF_kind"
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: STR

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      select case (s_kind)
      case("rhf         "); res = "r"
      case("rks         "); res = "r"
      case("rohf        "); res = "r"
      case("uhf         "); res = "u"
      case("uks         "); res = "u"
      case("gchf        "); res = "g"
    ! case("pnd_uhf     "); res = "u"
    ! case("pnd_uks     "); res = "u"
      case("xray_rhf    "); res = "r"
      case("xray_rks    "); res = "r"
      case("xray_uhf    "); res = "u"
      case("xray_uks    "); res = "u"
      case("xray_gchf   "); res = "g"
    ! case("xray_pnd_uhf"); res = "u"
    ! case("xray_pnd_uks"); res = "u"
      case("rdvpt       "); res = "r"
      case("farghar-rhf "); res = "r" ! <<< This is a hack!
      case("farghar-rks "); res = "r" ! <<< This is a hack!
    ! case default; DIE("unknown scf kind")
      end

   end

   MOs_number_kind result (res) ::: PURE
   ! Return the kind of numbers used for a particular "kind" of 
   ! SCF calculation
      self :: IN
      res :: STR

      select case (.SCF_kind)
      case("rhf","rks","rohf","uhf","uks", "ghf", "no_ghf"); res = "real"
      case("rchf","uchf","gchf","xray_gchf");                res = "complex"
      case("xray_rhf","xray_rks","xray_uks");                res = "real"
      case("xray_uhf","pnd_uhf","xray_pnd_uhf");             res = "real"
      case("pnd_uks","xray_pnd_uks");                        res = "real"
      case("rdvpt","restricted_dvpt");                       res = "real"
    ! case default; DIE("unknown scf kind")
      end

   end

   is_DFT_calculation(SCF_kind) result (res) ::: PURE
   ! Return TRUE if the scf kind is a DFT calculation
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: BIN

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      res = FALSE
      select case (s_kind)
      case("rhf");          res = FALSE
      case("rks");          res = TRUE
      case("rohf");         res = FALSE
      case("uhf");          res = FALSE
      case("uks");          res = TRUE
      case("ghf");          res = FALSE
      case("no_ghf");       res = FALSE
      case("rchf");         res = FALSE
      case("uchf");         res = FALSE
      case("gchf");         res = FALSE
      case("xray_rhf");     res = FALSE
      case("xray_rks");     res = TRUE
      case("xray_uhf");     res = FALSE
      case("xray_gchf");    res = FALSE
      case("xray_uks");     res = TRUE
    ! case("pnd_uhf");      res = FALSE
    ! case("pnd_uks");      res = TRUE
    ! case("xray_pnd_uhf"); res = FALSE
    ! case("xray_pnd_uks"); res = TRUE
      case("rdvpt");        res = FALSE
      case("fragment-rhf "); res = FALSE 
      case("fragment-rks "); res = TRUE
    ! case default; DIE("unknown scf kind")
      end

   end

   is_constrained_wavefunction(SCF_kind) result (res) ::: PURE
   ! Return TRUE if the scf kind is a constrained wavefunction
      self :: IN
      SCF_kind :: STR, optional, IN
      res :: BIN

      s_kind :: STR

      s_kind = .SCF_kind
      if (present(SCF_kind)) s_kind = SCF_kind

      res = FALSE
      select case (s_kind)
      case("rhf");           res = FALSE
      case("rks");           res = FALSE
      case("rohf");          res = FALSE
      case("uhf");           res = FALSE
      case("uks");           res = FALSE
      case("ghf");           res = FALSE
      case("no_ghf");        res = FALSE
      case("rchf");          res = FALSE
      case("uchf");          res = FALSE
      case("gchf");          res = FALSE
      case("xray_rhf");      res = TRUE
      case("xray_rks");      res = TRUE
      case("xray_uhf");      res = TRUE
      case("xray_gchf");     res = TRUE
      case("xray_uks");      res = TRUE
    ! case("pnd_uhf");       res = TRUE
    ! case("pnd_uks");       res = TRUE
    ! case("xray_pnd_uhf");  res = TRUE
    ! case("xray_pnd_uks");  res = TRUE
      case("fragment-rhf");  res = FALSE
      case("fragment-rks");  res = FALSE
    ! case default; DIE("unknown scf kind")
      end

   end

   DFT_functional_name result (res) ::: PURE
   ! Return the name of the DFT functional
      self :: IN
      res :: STR

   ENSURE(.is_DFT_calculation,"must be a DFT calculation")

      res = " "
      if (.DFT_exchange_functional/=" " AND .DFT_exchange_functional/="none") then
         res = .DFT_exchange_functional
      end

      if (.DFT_correlation_functional/=" " AND .DFT_correlation_functional/="none") then
         if (res/=" ") then
            res = trim(res)//"-"//trim(.DFT_correlation_functional)
         else
            res = .DFT_correlation_functional
         end
      end

   end

   temperature_for_pFON result (res) ::: PURE
   ! Return the temperature (in Kelvin) to use in the pFON method.
   ! The temperature applies from iteration 0 i.e. theinitial guess
   ! NOTE: To see whether to apply pFON use .apply_pFON
      self :: IN
      res :: REAL

      if (.using_pFON) then
         if      (.DIIS_error<.DIIS_error_temp_cutoff) then; res = ZERO
         else if (.iteration<20) then;                       res = 1000d0 - 50*.iteration
         else;                                               res = ZERO
         end
      else
                                                             res = ZERO
      end

   end

   apply_pFON result (res) ::: pure
   ! Return TRUE if pFON is to be applied this iteration.
      self :: IN
      res :: BIN
      if      (NOT .using_pFON) then;                     res = FALSE
      else if (.DIIS_error<.DIIS_error_temp_cutoff) then; res = FALSE
      else;                                               res = .iteration<20
      end
   end

!  =====
!  Tests
!  =====

   SCF_done result (res) ::: pure
   ! Return TRUE if the scf procedure is done i.e. either converged or
   ! gone on for too long ... and, it must also have executed the
   ! requested minimum number of times ...
      self :: IN
      res :: BIN
      res = (.converged OR .exceeded_max_it) AND .exceeded_min_it
   end

   converged result (res) ::: pure
   ! Return TRUE if the SCFDATA appears to be converged
      self :: IN
      res :: BIN
      res = .delta_converged AND .SCF_DIIS.is_converged
   end

   delta_converged result (res) ::: pure
   ! For normal SCF calculations, return TRUE if the energy difference has
   ! converged. For constrained HF calculations, return TRUE if the fit_values
   ! have converged.
      self :: IN
      res :: BIN

      res = FALSE
      if (.fitting) then; res = abs(.fit_value-.old_fit_value) < .convergence
      else;               res = abs(.delta)                    < .convergence
      end

   end

   exceeded_max_it result (res) ::: pure
   ! Return TRUE if the SCFDATA has exceeded the maximum iterations
      self :: IN
      res :: BIN
      res = .iteration >= .max_iterations
   end

   exceeded_min_it result (res) ::: pure
   ! Return TRUE if the SCFDATA has exceeded the minimum iterations
      self :: IN
      res :: BIN
      res = .iteration >= .min_iterations
      if (.fitting) res = res AND (.iteration > 1)
   end

   exceeded_lambda_max result (res) ::: pure
   ! Return TRUE if the SCFDATA has exceeded the maximum lambda
      self :: IN
      res :: BIN
      res = .lambda > (ONE+TOL(10)) * .lambda_max
                         ! TOL(10) allows for roundoff errors
   end

   will_exceed_lambda_max result (res) ::: pure
   ! Return TRUE if the SCFDATA will exceeded the maximum lambda
   ! in the next iteration.
      self :: IN
      res :: BIN
      res = .lambda + .lambda_step > (ONE+TOL(10)) * .lambda_max
                         ! TOL(10) allows for roundoff errors
   end

   do_delta_build result (res) ::: pure
   ! Return TRUE if a delta fock matrix build is allowed (assuming that the old
   ! fock matrix and old density matrix are available)
      self :: IN
      res :: BIN
      res = .using_delta_build AND .iteration>0
   end

   using_GGA_functional result (res) ::: pure
   ! Return TRUE if a generalised gradient approximation (GGA) functional is
   ! being used in the DFT calculation.
      self :: IN
      res :: BIN
      res = .using_GGA_exchange OR .using_GGA_correlation
   end

   is_constrained_SCF result (res) ::: pure
   ! Return TRUE if we are doing a constrained SCF calculation.
      self :: IN
      res :: BIN
      res = .SCF_kind(1:5)=="xray_"
    ! res = .SCF_kind(1:5)=="xray_" OR .SCF_kind(1:4)=="pnd_"
   end

   using_nonstandrad_ERI_cutoffs result (res) ::: pure
   ! Return TRUE if nonstandard ERI cutoffs are being used
      self :: IN
      res :: BIN
      res = .ERI_disk_cutoff           /= SCFDATA_ERI_DISK_CUTOFF &
         OR .ERI_Schwarz_cutoff        /= SCFDATA_ERI_SCHWARZ_CUTOFF &
         OR .ERI_J_density_cutoff      /= SCFDATA_ERI_J_DENSITY_CUTOFF &
         OR .ERI_K_density_cutoff      /= SCFDATA_ERI_K_DENSITY_CUTOFF &
         OR .ERI_primitive_pair_cutoff /= SCFDATA_ERI_PAIR_CUTOFF
   end

!  ======================
!  DIIS tests. Be careful
!  ======================

   apply_DIIS result (res) ::: pure
   ! Return TRUE if DIIS extrapolation must be applied this iteration,
   ! or has been applied this iteration.
      self :: IN
      res :: BIN

      if (NOT .using_DIIS) then; res = FALSE
      else;                      res = .SCF_DIIS.apply_DIIS
      end

   end

   apply_damping result (res) ::: pure
   ! Return TRUE if density matrix damping is to be applied this iteration
      self :: IN
      res :: BIN

      res = .using_damping AND .iteration < .damp_finish

   end

   apply_level_shifting result (res) ::: pure
   ! Return TRUE if level shifting must be applied this iteration
      self :: IN
      res :: BIN

      res = NOT .level_shift.is_zero &
            AND .using_level_shift   &
            AND .iteration < .level_shift_finish

   end

   fitting result (res) ::: pure
   ! Return true if we are fitting the wavefunction.
      self :: IN
      res :: BIN

      res = FALSE
      select case (.SCF_kind)
      case("xray_rhf");     res = TRUE
      case("xray_rks");     res = TRUE
      case("xray_uhf");     res = TRUE
      case("xray_uks");     res = TRUE
      case("xray_gchf");    res = TRUE
      case("pnd_uhf ");     res = TRUE
      case("pnd_uks ");     res = TRUE
      case("xray_pnd_uhf"); res = TRUE
      case("xray_pnd_uks"); res = TRUE
      case default;         res = FALSE
      end

   end

 !  ===============
 !  Output routines
 !  ===============

   put_banner
   ! Prints out the nuclear energy and initial guess energy.
      self :: IN

      if (NOT .output) return

      stdout.flush
      stdout.text("===============")
      stdout.text("SCF calculation")
      stdout.text("===============")
      stdout.flush

   end

   put_options
   ! Prints out a summary of what options are stored in the scfdata object.
      self :: IN

      q :: VEC{REAL}(3)

      if (NOT .output) return

      stdout.show("SCF kind                       =", .SCF_kind)

      if (.use_Fermi_Amaldi) then
      stdout.show("Using Fermi Amaldi?            =", .use_Fermi_Amaldi)
      end

      if (.using_FON) then
      stdout.flush
      stdout.text("Finite temperature SCF:")
      stdout.flush
      stdout.show("Temperature (in Kelvin)        =", .temperature.to_units("kelvin"))
      end

      stdout.flush
      stdout.text("Initial guess options:")
      stdout.flush
      stdout.show("Kind of initial density        =", .initial_density)
      stdout.show("Kind of initial MO's           =", .initial_MOs)

      if (.is_DFT_calculation) then
      stdout.show("DFT Exchange functional        =", .DFT_exchange_functional)
      stdout.show("DFT Correlation functional     =", .DFT_correlation_functional)
      end

      if (NOT .using_direct_SCF) then
      stdout.show("Using direct SCF?              =", .using_direct_SCF)
      end

      if (NOT .using_delta_build) then
      stdout.show("Using delta build              =", .using_delta_build)
      end

      if (.using_cluster_charges) then
      stdout.show("Using cluster charges          =", .using_cluster_charges)
      stdout.show("Self consistent charges?       =", .using_SC_cluster_charges)
      stdout.show("Cluster radius                 =", .cluster_radius)
      stdout.show("Defragment                     =", .defragment)  !testing, turn off defragment in case of network compounds, Lorraine. 
      end

      if (.using_SC_Lorentz_fields) then
      stdout.show("Using SC Lorentz fields        =", .using_SC_Lorentz_fields)
      end

      if (.using_nonstandrad_ERI_cutoffs) then
      stdout.set_real_style("e")
      stdout.flush
      stdout.text("Integrals:")
      stdout.flush
      stdout.show("ERI disk cutoff                =", .ERI_disk_cutoff)
      stdout.show("ERI Schwarz test cutoff        =", .ERI_Schwarz_cutoff)
      stdout.show("ERI J density cutoff           =", .ERI_J_density_cutoff)
      stdout.show("ERI K density cutoff           =", .ERI_K_density_cutoff)
      stdout.show("ERI primitive pair cutoff      =", .ERI_primitive_pair_cutoff)
      stdout.set_real_style("f")
      end

      if (.using_NDDO) &
      stdout.show("Doing NDDO?                    =", .using_NDDO)

      if (.relativity_kind/="none") then

      stdout.flush
      stdout.text("Relativistic/Magnetic options:")
      stdout.flush

      stdout.show("Relativity kind                =", .relativity_kind)

      if (.relativity_kind=="iotc") then
      stdout.show("Using <PPXPP> integrals        =", .using_ppzpp)
      end

      if (.relativity_kind=="douglas-kroll-hess" OR .relativity_kind=="dkh" )  then
      stdout.show("Using DK1                      =", .DK1)
      stdout.show("Using DK2                      =", .DK2)
      stdout.show("Using DK3                      =", .DK3)
      stdout.show("Using <PPXPP> integrals        =", .using_ppzpp)
      stdout.show("Using SOfullDOUBLEfullFULL :P  =", .using_SO_FDFF)
      end

      if (.relativity_kind=="iotc" OR .relativity_kind=="douglas-kroll-hess" OR .relativity_kind=="dkh") then
      if (.PCE_CORR) then
      stdout.show("Using correction of PCE (DK0)  =", .PCE_CORR)
      stdout.show("Using DK1 PCE correction       =", .DK1_PCE)
      stdout.show("Using DK2 PCE correction       =", .DK2_PCE)
      end
      end

      if (.spinorbital_kind=="general_complex") then
      q  = .quantization_axis
      stdout.show("Quantization axis              =", q(1),q(2),q(3))
      stdout.show("ZORA (1 electron) terms        =", .using_1e_zora_term)
      stdout.show("Using B:L term                 =", .using_bl_term)
      stdout.show("Using B:S term                 =", .using_bs_term)
      stdout.show("Using B:S T term               =", .using_bs_t_term)
      stdout.show("Using A:A term                 =", .using_aa_term)
      stdout.show("Using 1e S:L term              =", .using_1e_sl_term)
      stdout.show("Using 1e S:(rxA) term          =", .using_1e_srxa_term)
      stdout.show("Using 2e S:L term              =", .using_2e_sl_term)
      stdout.show("Factor for 1e S:L term         =", .sl_1e_factor)
      stdout.show("Factor for 2e S:L term         =", .sl_2e_factor)
      end

      end ! relativity

      stdout.flush
      stdout.text("SCF termination options:")
      stdout.flush
      stdout.set_real_style("e")
      stdout.show("Delta E convergence tolerance  =", .convergence)
      stdout.show("Gradient/DIIS convergence      =", .SCF_DIIS.convergence_tolerance)
      stdout.set_real_style("f")
      stdout.show("Minimum # of iterations        =", .min_iterations)
      stdout.show("Maximum # of iterations        =", .max_iterations)

      stdout.flush
      stdout.text("Linear dependence options:")
      stdout.flush
      stdout.set_real_style("e")
      stdout.show("Linear dependence tolerance    =", .linear_dependence_tol)
      stdout.show("Linear dependence shift        =", .linear_dependence_shift)
      stdout.show("Min. overlap matrix eigenvalue =", .min_overlap_mx_eigenvalue)
      stdout.show("No. of small S eigenvalues     =", .n_small_S_eigenvalues)
      stdout.show("No. of neg.  S eigenvalues     =", .n_neg_S_eigenvalues)

      stdout.flush
      stdout.text("Convergence acceleration options:")
      stdout.flush
      stdout.set_real_style("f")
      stdout.show("Using level shift              =", .using_level_shift)

      if (.using_level_shift) then
      stdout.show("Level shift                    =", .level_shift)
      stdout.show("Level shift  quits at          =", .level_shift_finish)
      end

      if (.using_orbital_locking) then
      stdout.show("Using orbital locking          =", .using_orbital_locking)
      end

      stdout.show("Using density damping          =", .using_damping)

      if (.using_damping) then
      stdout.show("Damping factor                 =", .damp_factor)
      stdout.show("Damping quits at               =", .damp_finish)
      end

      if (.using_MO_gradient_update OR .using_exponential_update) then
      stdout.show("Using MO gradient update       =", .using_MO_gradient_update)
      stdout.show("Using exponential update       =", .using_exponential_update)
      stdout.set_real_style("e")
      stdout.show("MO gradient stepsize           =", .MO_gradient_stepsize)
      stdout.show("Maximum update stepsize        =", .max_update_stepsize)
      stdout.set_real_style("f")
      end

      stdout.show("Using DIIS                     =", .using_DIIS)

      if (.using_DIIS) .SCF_DIIS.put

      if (.fitting) then
      stdout.flush
      stdout.text("====================================")
      stdout.text("Experimental wavefunction parameters")
      stdout.text("====================================")
      stdout.flush
      stdout.show("Lambda fitting parameter       =", .lambda)
      stdout.show("Lambda max                     =", .lambda_max)
      stdout.show("Lambda step                    =", .lambda_step)
      stdout.show("Zero occ-occ constraint?       =", .zero_oo_constraint_block)
      .put_crystal_fit_info
      end

   end

   put_table_head
   ! Prints out the SCF iteration banner (and related options)
      self :: IN

   ENSURE(.table.allocated,"no table created")

      if (NOT .output) return

      stdout.flush
      stdout.text("==============")
      stdout.text("SCF iterations")
      stdout.text("==============")

      ! Put the table
      .table.put_headings

   end

   put_table_header
   ! Prints out the SCF iteration banner (and related options)
      self :: IN

   ENSURE(.table.allocated,"no table created")

      if (NOT .output) return

      ! Put the table
      .table.put_headings

   end

   put_table_body_and_footer(flush)
   ! Print out the results for the current iteration.
   ! If converged, print out footer as well.
   ! NOTE: must have called put_table_head before!
      self :: INOUT
      flush :: BIN, optional, IN

      if (NOT .output) return

      if (NOT .scf_done) then

         ! Set margin notes ...
         .set_margin_info

         ! Set table body (leaky)
         if (NOT .fitting) then
            .table(1).set_values([.iteration])
            .table(2).set_values([.energy])
            .table(3).set_values([.delta])
            .table(4).set_values([.DIIS_error])
            .table(5).set_values(.table_info)
            .table(5).force_width(0)
         else
            .table(1).set_values([.iteration])
            .table(2).set_values([.lambda])
            .table(3).set_values([.penalty])
            .table(4).set_values([.energy])
            .table(5).set_values([.fit_value])
            .table(6).set_values([.fit_value-.old_fit_value])
            .table(7).set_values([.DIIS_error])
            .table(8).set_values(.table_info)
            .table(8).force_width(0)
         end

         ! Put out the body
         .table.put_body

         ! Clear columns for next time (UNleaky!)
         .table.clear_columns

      else ! the SCF is done ...

        .table.put_footer

        stdout.flush
        if (.converged) then; stdout.text("* * * SCF has converged * * *")
        else;                 stdout.text("* * * SCF has not converged * * *")
        end

        .table.put_footer(flush=flush)

        if (.fitting AND NOT .will_exceed_lambda_max) then
           .put_crystal_footer
!           .table.put_headings
        end

      end

   end

   put_results
   ! Prints out the results
      self :: IN

      if (NOT .output_results) return

      stdout.flush
      stdout.text("===========")
      stdout.text("SCF results")
      stdout.text("===========")

      .put_energies

      if (.fitting) .put_crystal_fit_info

    ! if (.cluster_charges.allocated) .put_cluster_charges

   end

   put_initial_guess_energies
   ! Prints out initial guess energies
      self :: IN

      if (NOT .output) return

      stdout.flush
      stdout.text("======================")
      stdout.text("Initial guess energies")
      stdout.text("======================")

      .put_energies

   end

   put_energies
   ! Prints out the table foot for an SCF calculation, after convergence
   ! ornot as the case may be
      self :: IN
          
      wid :: INT
          
      if (NOT .output_results) return
          
      ! Nice width
      wid = len_trim(.nuclear_attraction_energy.to_str("f",50,stdout.real_precision)) + 1

      ! Print
      stdout.flush
      stdout.show("Total energy (E_e+V_NN)   E    =",.energy,wid)
      stdout.show("Total electronic energy   E_e  =",.energy-.nuclear_repulsion_energy,wid)
      stdout.show("Nuclear repulsion energy  V_NN =",.nuclear_repulsion_energy,wid)
      stdout.show("Electron repulsion energy V_ee =",.electron_repulsion_energy,wid)
      stdout.show("Nuclear attraction energy V_eN =",.nuclear_attraction_energy,wid)
      if (.using_cluster_charges) then
      stdout.show("Charge attraction energy  V_cN =",.charge_attraction_energy,wid)
      end
      stdout.show("Total potential energy    V    =",.energy-.kinetic_energy,wid)
      stdout.show("Kinetic energy            T    =",.kinetic_energy,wid)
      stdout.show("Virial ratio             -V/T  =",(.kinetic_energy-.energy)/.kinetic_energy,wid)

      if (.using_FON) then
      stdout.flush
      stdout.show("Fermi energy                   =",.E_Fermi,wid)
      end

   end

   put_crystal_fit_info
   ! Prints out the crystal structure factor statistics.
      self :: IN

      if (NOT .output_results) return

      if (NOT .fitting) return

      stdout.show("Penalty in F                   =", .penalty)

      if (.crystal.xray_data.allocated AND .SCF_kind.includes("xray")) then
         stdout.flush
         stdout.text("==========")
         stdout.text("X-ray data")
         stdout.text("==========")
         .crystal.xray_data.put_F_statistics
         if (.crystal.r_free_percentage>0 AND .crystal.xray_r_free_data.allocated) &
            .crystal.xray_r_free_data.put_F_free_stats
      end

    ! if (.crystal.pnd_data.allocated AND .SCF_kind.includes("pnd")) then
    !    stdout.flush
    !    stdout.text("========")
    !    stdout.text("PND data")
    !    stdout.text("========")
    !    .crystal.pnd_data.put_F_statistics
    !    if (.crystal.r_free_percentage>0 AND .crystal.pnd_r_free_data.allocated) &
    !       .crystal.pnd_r_free_data.put_F_free_stats
    ! end

   end

   put_crystal_footer
   ! Prints out the crystal structure factor statistics
   ! In the footer of a completed lambda calculation.
      self :: IN

      if (NOT .output) return

      if (NOT .fitting) return

!     stdout.show("Penalty in F                   =", .penalty)

      if (.crystal.xray_data.allocated AND .SCF_kind.includes("xray")) then
         .put_results
!        .crystal.xray_data.put_F_statistics
         if (.crystal.r_free_percentage>0 AND .crystal.xray_r_free_data.allocated) &
            .crystal.xray_r_free_data.put_F_free_stats
      end

    ! if (.crystal.pnd_data.allocated AND .SCF_kind.includes("pnd")) then
    !    .crystal.pnd_data.put_F_statistics
    !    if (.crystal.r_free_percentage>0 AND .crystal.pnd_r_free_data.allocated) &
    !       .crystal.pnd_r_free_data.put_F_free_stats
    ! end

   end

 !  =================================
 !  Coupled-perturbed output routines
 !  =================================

   put_CP_banner
   ! Prints out the coupled-perturbed banner
      self :: IN

      if (NOT .output) return

      stdout.flush
      stdout.text("=====================")
      stdout.text("Coupled-Perturbed SCF")
      stdout.text("=====================")
      stdout.flush

   end

   put_CP_options
   ! Prints out a summary of what options are stored in scfdata
      self :: IN

      if (NOT .output) return

      stdout.show("No. of perturbations           =", .n_pert)
      stdout.flush

      stdout.show("SCF kind                       =", .SCF_kind)

      stdout.flush
      stdout.text("Termination options:")
      stdout.flush
      stdout.set_real_style("e")
      stdout.show("|Delta U| convergence tol      =", .convergence)
      stdout.show("DIIS convergence tolerance     =", .SCF_DIIS.convergence_tolerance)
      stdout.set_real_style("f")
      stdout.show("Minimum # of iterations        =", .min_iterations)
      stdout.show("Maximum # of iterations        =", .max_iterations)

      stdout.show("Using DIIS                     =", .using_DIIS)

      if (.using_DIIS) then
         .SCF_DIIS.put
         stdout.flush
         stdout.text("Note:")
         stdout.text(". DIIS applies separately to each RHS")
         stdout.text(". The DIIS error vector is (H.U - RHS)")
         stdout.text(". Below, notes refer only to perturbation #1")
      end

   end

   put_CP_table_head
   ! Prints out the CP iteration banner
      self :: IN

   ENSURE(.table.allocated,"no table created")

      if (NOT .output) return

      stdout.flush
      stdout.text("====================")
      stdout.text("Solve CPHF equations")
      stdout.text("====================")

      ! Put the table
      .table.put_headings

   end

   put_CP_table_body_and_footer(flush)
   ! Print out the CP results for the current iteration. 
   ! If converged, print out footer as well.
   ! NOTE: must have called put_CP_table_head before!
      self :: INOUT
      flush :: BIN, optional, IN

      if (NOT .output) return

      if (NOT .scf_done) then

         ! Set margin notes ...
         .set_margin_info

         ! Set table body (leaky)
         if (NOT .fitting) then
            .table(1).set_values([.iteration])
            .table(2).set_values([.delta])
            .table(3).set_values([.DIIS_error])
            .table(4).set_values(.table_info)
            .table(4).force_width(0)
         end

         ! Put out the body
         if (.iteration>0) .table.put_body

         ! Clear columns for next time (UNleaky!)
         .table.clear_columns

      else ! the SCF is done ...

         .table.put_footer
        
         stdout.flush
         if (.converged) then; stdout.text("Converged")
         else;                 stdout.text("NOT Converged")
         end
        
         .table.put_body
         .table.put_footer(flush=flush)

      end

   end

 !  ======================
 !  Cluster-charges output
 !  ======================

   put_cluster
   ! Put the cluster out
      self :: IN

   ENSURE(.cluster.allocated,"no cluster!")

      .cluster.put

   end

   put_cluster_charges(name)
   ! Put the cluster charges out, for possible import
   ! into the gaussian program
      self :: IN
      name :: STR, IN

   ENSURE(.cluster_charges.allocated,"no cluster_charge array")
   ENSURE(.cluster_charge_positions.allocated,"no cluster_charge_positions array")

      i :: INT
      fac :: REAL

      fac = STR:conversion_factor("angstrom")

      ! Change to a new file
      stdout.redirect(name)

      stdout.flush
      stdout.text("===============================================")
      stdout.text("Cluster monopole & dipole charges and positions")
      stdout.text("===============================================")
      stdout.flush
      stdout.text(". Position (in A) is given first followed by the charge")
      stdout.flush
      stdout.text(". The charges include at least a monopole and dipole,")
      stdout.text("  the latter simulated by two close-space point charges")
      stdout.flush

      stdout.dash(real_fields=4)
      stdout.put("X")
      stdout.put("Y")
      stdout.put("Z")
      stdout.put("Charge")
      stdout.flush

      do i = 1,.cluster_charges.dim
         stdout.put(.cluster_charge_positions(1,i)*fac)
         stdout.put(.cluster_charge_positions(2,i)*fac)
         stdout.put(.cluster_charge_positions(3,i)*fac)
         stdout.put(.cluster_charges(i))
         stdout.flush
      end

      stdout.dash(int_fields=1,real_fields=4)

      ! Change back
      stdout.revert

   end

end
