!---------------------------------------------------------------------------
!
! VEC{EMAT{REAL}}: Vector of matrices
!
! Copyright (C) Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!---------------------------------------------------------------------------

module VEC{EMAT{REAL}}

   implicit none

contains

!  ==========
!  Allocation
!  ==========

   create(dim) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate vector
   end

   create(lb,ub) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Allocate the vector with lower bound "lb", upper bound "ub"
   end

   create(dim,dim1,dim2) ::: leaky, PURE
   ! Create space for a vector of matrices
      self :: allocatable, OUT
      dim,dim1,dim2 :: INT, IN

      .create(dim)
      .create_mat(dim1,dim2)

   end

   create_mat(dim1,dim2) ::: leaky, PURE
   ! Allocate the pointer parts
      self :: INOUT
      dim1,dim2 :: INT, IN

      i :: INT

      do i = 1,.dim
         self(i).element.create(dim1,dim2)
      end

   end

   destroy ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Deallocate the vector
   end

!  ======
!  Resize
!  ======

   expand(dim,grow_start) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Expand allocatable "self" to dimension "dim" adding to the end.
   ! If "grow_start" is present and TRUE, then "self" is expanded from
   ! the start, keeping the same lower bound.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Append the contents of vector "v" to allocatable "self".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky, PURE
   ! Appends the scalar "value" onto the end of allocatable "self".
   end

!  ===========
!  Set methods
!  ===========
!
!   weak_two_orthonormalise(vec)
!   ! two orthogonalise also with respect to the set of unit vectors
!   ! collinear to those in vec. 
!     self :: target
!     vec :: VEC{MAT_{REAL}}, IN
!
!   DIE_IF(vec.dim==0,"size of vec is zero")
!   DIE_IF(self(1).element.dim1/=vec(1).element.dim1,"vec.element: wrong dim1")
!   DIE_IF(self(1).element.dim2/=vec(1).element.dim2,"vec.element: wrong dim2")
!
!     old,new :: MAT{REAL}*
!     fac,norm :: REAL
!     n,p,dim1,dim2 :: INT
!
!     dim1 = vec(1).element.dim1
!     dim2 = vec(1).element.dim2
!     old.create(dim1,dim2)
!
!     ! Orthogonalisation to spectator bra's
!     do p = 1,vec.dim
!
!       old = vec(p)[:,:]
!       norm = MAT{REAL}:sum_elements(old*old)
!       old  = old/sqrt(norm)
!
!       do n = 1,self.dim
!         new => self(n)[:,:]
!         fac = MAT{REAL}:sum_elements(old*new)
!      !  if(n==1) write(6,*) "spectator number, fac for first state in the vector",p,fac
!         new = new - fac*old
!       end
!
!     end
!
!     nullify(new)
!     old.destroy
!
!   end
!
!   two_orthonormalise(eigenvectors)
!   ! project singlet geminals on the orthogonal complement of the 
!   !2_internal space (spanned by the
!   ! vectors in the argument "eigenvectors") of the exterior product 
!   ! of spectator geminals
!     self :: target
!     eigenvectors :: MAT{REAL}, IN
!
!     new :: MAT{REAL}*
!     resz,vec :: VEC{REAL}*
!     fac :: REAL
!     n,o,dim1,dim2,k,j,i :: INT
!
!     dim1= self(1).element.dim1
!     dim2= self(1).element.dim2
!
!     resz.create(dim1*dim1)
!     vec.create(dim1*dim1)
!
!     do n=1,self.dim
!
!       new => self(n)[:,:]
!       resz(:)=ZERO
!
!       do j=1,eigenvectors.dim1
!
!         fac = ZERO
!         vec = ZERO
!         o=1
!
!         do i=1,dim1
!           do k=1,i
!             if (i==k) then
!               fac=fac+eigenvectors(j,o)*new(i,i)
!               vec((i-1)*dim1+k)=eigenvectors(j,o)
!             else
!               fac=fac+eigenvectors(j,o)*(new(i,k)+new(k,i))/sqrt(TWO)
!               vec((i-1)*dim1+k)=eigenvectors(j,o)/sqrt(TWO)
!               vec((k-1)*dim1+i)=eigenvectors(j,o)/sqrt(TWO)
!             end
!             o=o+1
!           end
!         end
!
!         resz=resz+fac*vec
!
!       end
!
!       do i=1,dim1
!         do k=1,dim2
!           new(i,k)=new(i,k)-resz((i-1)*dim2+k)
!         end
!       end
!
!     end
!
!     resz.destroy
!     vec.destroy
!
!   end
!
!   strong_two_orthonormalise(eigenvectors)
!   ! project singlet geminals on the 2_external space (spanned by the
!   ! vectors in the argument "eigenvectors") of the exterior product 
!   ! of spectator geminals
!     self :: target
!     eigenvectors :: MAT{REAL}, IN
!
!     new :: MAT{REAL}*
!     resz :: VEC{REAL}*
!     vec :: VEC{REAL}*
!     fac :: REAL
!     n,o,dim1,dim2,k,j,i :: INT
!
!     dim1= self(1).element.dim1
!     dim2= self(1).element.dim2
!
!     resz.create(dim1*dim1)
!     vec.create(dim1*dim1)
!
!     do n=1,self.dim
!
!       new => self(n)[:,:]
!       resz = ZERO
!
!       do j=1,eigenvectors.dim1
!
!         fac=ZERO
!         vec=ZERO
!
!         o=1
!         do i=1,dim1
!           do k=1,i
!             if (i==k) then
!               fac=fac+eigenvectors(j,o)*new(i,i)
!               vec((i-1)*dim1+k)=eigenvectors(j,o)
!             else
!               fac=fac+eigenvectors(j,o)*(new(i,k)+new(k,i))/sqrt(TWO)
!               vec((i-1)*dim1+k)=eigenvectors(j,o)/sqrt(TWO)
!               vec((k-1)*dim1+i)=eigenvectors(j,o)/sqrt(TWO)
!             end
!             o=o+1
!           end
!         end
!
!         resz=resz+fac*vec
!
!       end
!
!       do i=1,dim1
!         do k=1,dim2
!           new(i,k)=resz((i-1)*dim2+k)
!         end
!       end
!
!     end
!
!     resz.destroy
!     vec.destroy
!
!   end
!
!   schmidt_orthonormalise(S,scales,n_dependent,ld_tol)
!   ! Schmidt orthonormalise the vectors in "self" using "S" as the
!   ! metric. "scales" is set to the
!   ! normalisation factors used to normalise each column after the Schmidt
!   ! procedure. Only those vectors with norm more than the linear dependence
!   ! tolerance are orthonormalised. the others are counted (n_dependent) 
!   ! and normalised if the norm is not initially below a certain threshold. 
!     S :: MAT{REAL} 
!     scales :: VEC{REAL}, OUT
!     n_dependent :: INT, OUT
!     ld_tol :: REAL, optional
!   ENSURE(NOT S.is_zero,"S is zero matrix")
!   ENSURE(S.is_square,"S matrix is not square")
!     unorthovec :: MAT{REAL}*
!     unorthovec.create(.dim,.dim)
!     unorthovec.to_unit_matrix !first index will run other the orthonormal vectors 
!     if(present(ld_tol)) then
!       unorthovec.schmidt_orthonormalise(S,scales,n_dependent,ld_tol)
!     else
!       unorthovec.schmidt_orthonormalise(S,scales,n_dependent)
!     end  
!     .change_basis_using(unorthovec)
!     unorthovec.destroy
!   end
!
!   schmidt_orthonormalise(S,keep,scales,n_dependent,ld_tol)
!   ! Schmidt orthonormalise the vectors in "self" using "S" as the
!   ! metric. "scales" is set to the
!   ! keep contains original vectors to restore: if the norm of a vector
!   ! to orthogonalise is less than ld_tol the corresponding vector in
!   ! keep is restored.
!   ! normalisation factors used to normalise each column after the Schmidt
!   ! procedure. Only those vectors with norm more than the linear dependence
!   ! tolerance are orthonormalised. the others are counted (n_dependent) 
!   ! and normalised if the norm is not initially below a certain threshold. 
!     self :: PTR
!     keep :: VEC{MAT_{REAL}}
!     S :: MAT{REAL} 
!     scales :: VEC{REAL}, OUT
!     n_dependent :: INT, OUT
!     ld_tol :: REAL, optional
!
!   ENSURE(NOT S.is_zero,  "S is zero matrix")
!   ENSURE(    S.is_square,"S matrix is not square")
!   ENSURE(.dim==keep.dim, "keep: wrong size")
!
!     unorthovec :: MAT{REAL}*
!     indices :: VEC{INT}*
!     i :: INT
!
!     unorthovec.create(.dim,.dim)
!     unorthovec.to_unit_matrix !first index will run other the orthonormal vectors 
!     if(present(ld_tol)) then
!       unorthovec.schmidt_orthonormalise(S,indices,scales,n_dependent,ld_tol)
!     else
!       unorthovec.schmidt_orthonormalise(S,indices,scales,n_dependent)
!     end  
!     .change_basis_using(unorthovec)
!     do i=.dim-n_dependent+1,.dim
!       self(i).element=keep(indices(i)).element
!     end  
!     indices.destroy !create in schmidt_orthonormalise
!     unorthovec.destroy
!   end
!
!   flatten(vec_vec)
!   ! flatten the matrices of a vector of matrices into vectors
!   ! meant for singlet contraction_wfs at present
!     vec_vec :: VEC{VEC_{REAL}}*
!     ENSURE(vec_vec.associated,"vec_vec not created")
!     n,o,p,dim1 :: INT
!     counter :: INT
!     dim1= self(1).element.dim1
!     do n = .lb,.ub
!       counter=0
!       do o = 1, dim1
!         counter=counter+1
!         vec_vec(n).element(counter)=self(n).element(o,o)
!       end
!       do o = 1, dim1
!         do p = 1,o-1
!           counter=counter+1
!           vec_vec(n).element(counter)=self(n).element(o,p)
!           DIE_IF(self(n).element(o,p)/=self(n).element(p,o),"not singlet")
!         end
!       end
!     end
!   end
!
!   flatten(mat)
!   ! flatten the matrices of a vector of matrices into vectors
!   ! meant for singlet contraction_wfs at present
!     mat :: MAT{REAL}*
!     ENSURE(mat.associated,"mat not created")
!     n,o,p,dim1 :: INT
!     counter :: INT
!     dim1= self(1).element.dim1
!     DIE_IF(mat.dim1/=self.dim ,"mat.dim1/=self.dim")
!     DIE_IF(mat.dim2/=dim1*(dim1+1)/2,"mat.dim2/=dim")
!     do n = .lb,.ub
!       counter=0
!       do o = 1, dim1
!         counter=counter+1
!         mat(n,counter)=self(n).element(o,o)
!       end
!       do o = 2, dim1
!         do p = 1,o-1
!           counter=counter+1
!           mat(n,counter)=self(n).element(o,p)
!           DIE_IF(self(n).element(o,p)/=self(n).element(p,o),"not singlet")
!         end
!       end
!     end
!   end
!
!   change_basis_using(mat,use_transpose)
!   ! transform the vector of matrices self into 
!   ! mat. self or transpose(mat). self if use_transpose is TRUE
!     mat :: MAT{REAL}, IN
!     use_transpose :: BIN, optional
!     ENSURE(mat.dim1==self.dim,"dimension of mat does not match that of self")
!     new :: VEC{MAT_{REAL}}*
!     use_tr :: BIN
!     dim,j :: INT
!     use_tr = FALSE
!     if (present(use_transpose)) use_tr=use_transpose
!     dim = mat.dim1
!     new.create_copy(self)
!     new.to_product_of(mat,self,use_tr)
!     do j = 1,dim
!       self(j).element = new(j).element
!     end
!     new.destroy 
!   end

end
