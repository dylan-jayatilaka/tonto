!=====================================================================
!
! GAUSSIAN_DATA
!
! This module is used to store precalculated information pertaining to
! gaussian functions, including gaussian powers an gaussian indices,
! data for the reduced multiplication scheme (RMS) used in electron
! repulsion integral evaluation, data for the transfer relation, and
! binomial coefficients for the reverse transfer relation. The type is
! a dummy: the data is all held as module arrays.
!
! Copyright (C) Dylan Jayatilaka, 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!=====================================================================

module GAUSSIAN_DATA

   implicit none

   l_max_saved :: INT, public = -1

   ! Standard angular momentum character symbols
   l_symbol :: VEC{STR}@, public

   ! List of cartesian powers for gaussian functions in increasing angular
   ! momentum. This defines the lexical order. 
   px :: VEC{INT}@, public
   py :: VEC{INT}@, public
   pz :: VEC{INT}@, public
   pp :: MAT{INT}@, public

   ! String representations of the gaussian powers
   pxyz_rep :: VEC{STR}@, public  ! e.g. xxyy
   pxyz_pow :: VEC{STR}@, public  ! e.g. x2y2
   p123_rep :: VEC{STR}@, public  ! e.g. 1122
   b123_rep :: VEC{STR}@, public  ! e.g. [1][1][2][2]
 ! pLM_real :: VEC{STR}@, public  ! e.g. 21+

   ! The *un* normalizing factors apply to cartesian gaussian basis
   ! functions (i.e. components) in an angular momentum L-shell
   ! such that they all have the normalization factor for
   ! the componenents x^L, y^L or z^L.
   ! IMPORTANT: Tonto uses cartesian gaussian basis functions for
   ! which *every* component in an L-shell is multiplied by the
   ! normalization factor for x^L (or y^l or z^L). Thus, cartesian
   ! gaussian basis functions different from these in an L-shell are
   ! *NOT* normalized to unity. The "unnormalizing factors" returned
   ! by this procedure multiply L-shell basis function components so
   ! that each component would be normalized.  This is needed to
   ! ensure spherical harmonic components are all normalized. The
   ! factors are introduced into the spherical harmonic transformation
   ! matrices, see below. They are also used when talking to other
   ! programs which usually have every cartesian gaussian normalized.
   ! i.e. tonto-norm = unit-norm * unnormalizing_factors
   unnormalizing_factors :: VEC{REAL}@, public

   ! List of cartesian indices for gaussian functions in increasing angular
   ! momentum. The indices are the powers plus 1.
   nx :: VEC{INT}@, public
   ny :: VEC{INT}@, public
   nz :: VEC{INT}@, public
   nn :: MAT{INT}@, public

   ! Set TRUE if Ishida's ordering is to be used
   ! This turns of special code in SHELL1QUARTET
   Ishida_ordering :: BIN, public = FALSE

   ! These are indexing arrays used for the horizontal recursion relation.
   ! They are set using the set_gaussian_indices routine.
   first_nonzero :: VEC{INT}@, public
   index_of :: MAT3{INT}@, public
   index_m1 ::  VEC{INT}@, public
   index_p1 ::  MAT{INT}@, public

   ! The binomial coefficients, plus 1, for reverse HRR
   binomial_p1 :: VEC{EVEC{INT}}@, public

   ! List of arrays used for the reduced multiplication scheme (RMS)
   rms_indices :: MAT{RMS_INDICES}@, public

   ! List of arrays used for the reduced multiplication scheme (RMS)
 ! rms2_indices :: MAT4{RMS2_INDICES}@, public
   rms2_indices :: MAT{RMS2_INDICES}@, public

   ! Array of spherical harmonic coefficients
   spherical_harmonics_for :: VEC{EMAT{REAL}}@, public

contains

! =================
! Memory allocation
! =================

   create ::: get_from(OBJECT), leaky
   ! Create an object. This version does not nullify point parts.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   destroy_data ::: selfless, leaky
   ! Destroy all module data and reset l_max_saved.

      spherical_harmonics_for.destroy

      rms2_indices.destroy
      rms_indices.destroy

      binomial_p1.destroy

      index_p1.destroy
      index_m1.destroy

      first_nonzero.destroy
      index_of.destroy

      unnormalizing_factors.destroy

      nn.destroy; nz.destroy; ny.destroy; nx.destroy
      pp.destroy; pz.destroy; py.destroy; px.destroy

      b123_rep.destroy
      p123_rep.destroy
      pxyz_pow.destroy
      pxyz_rep.destroy

      l_symbol.destroy

   end

! ===========
! Set methods
! ===========

   set_defaults
   ! Set defaults
      self :: INOUT

      .l_max = 0

   end

! =========================================
! Boundaries of each angular momentum range
! =========================================

   n_comp(l) result (res) ::: selfless, public, pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
      l :: INT, IN
      res :: INT

      res = (l+1)*(l+2)/2

   end

   n_comp_up_to(l) result (res) ::: selfless, public, pure
   ! No. of gaussian cartesian component functions up to and including
   ! the shell with momentum "l".
      l :: INT, IN
      res :: INT

      res = (l+1)*(l+2)*(l+3)/6

   end

   n_sph(l) result (res) ::: selfless, public, pure
   ! No. of spherical components in a gaussian shell of momentum "l".
      l :: INT, IN
      res :: INT

      res = 2*l+1

   end

   n_sph_up_to(l) result (res) ::: selfless, public, pure
   ! No. of spherical component functions up to and including the
   ! shell with momentum "l".
      l :: INT, IN
      res :: INT

      res = (l+1)*(l+1)

   end

! This is the main routine: all others are private.

   set_indices(l_max) ::: selfless, leaky, public
   ! Set the gaussian power indices, hrr indices, and the rms indices. 
      l_max :: INT, IN

   ENSURE(l_max<=23,"angular momentum too large:"// trim(l_max.to_str))

      l,l2,n :: INT

      ! Already made? Then return
      if (l_max<=l_max_saved) return

      ! Set l_lax_saved
      l_max_saved = l_max
      l2 = 2*l_max

      ! Set l symbols
      l_symbol.create(0,l_max)
      do l = 0,l_max
         select case (l)
         case (0);     l_symbol(l) = "s"
         case (1);     l_symbol(l) = "p"
         case (2);     l_symbol(l) = "d"
         case (3);     l_symbol(l) = "f"
         case default; l_symbol(l) = achar(l-4+iachar("g"))
         end
      end

      ! Set no of components up to 2*l
      n = GAUSSIAN_DATA::n_comp_up_to(l2)

      ! Destroy all data (leaky)
      GAUSSIAN_DATA::destroy_data  

      ! Set the gaussian data
      px.create(n); py.create(n); pz.create(n); pp.create(3,n)
      nx.create(n); ny.create(n); nz.create(n); nn.create(3,n)
      unnormalizing_factors.create(n)
      index_of.create(l2+1,l2+1,l2+1)
      first_nonzero.create(n)
      index_m1.create(n)
      index_p1.create(n,3)
      GAUSSIAN_DATA::set_gaussian_indices(l2,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1)
    ! GAUSSIAN_DATA::set_Ishida_indices(l2,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1)

      ! Set nn convenience arrays
      nn(1,:) = nx
      nn(2,:) = ny
      nn(3,:) = nz

      ! Set px,py,pz and pp convenience arrays
      px = nx - 1
      py = ny - 1
      pz = nz - 1
      pp = nn - 1

      ! Set the string representations
      pxyz_rep.create(n)
      pxyz_pow.create(n)
      p123_rep.create(n)
      b123_rep.create(n)
      GAUSSIAN_DATA::set_gaussian_power_str(pxyz_rep,pxyz_pow,p123_rep,b123_rep,px,py,pz)

      ! Set normalizing factors
      GAUSSIAN_DATA::set_unnormalizing_factors(l2,unnormalizing_factors,px,py,pz)

      ! Set binomial coefficients via Pascal's triangle
      GAUSSIAN_DATA::set_binomial_p1_coefficients(l_max,binomial_p1)

      ! Reduced multiplication scheme (rms) indices
      rms_indices.create(0,l_max,0,l_max)
      MAT{RMS_INDICES}:set_indices(rms_indices,l_max,nx,ny,nz,px,py,pz)

   !  l_tri = (l_max+1)*(l_max+2)/2
   !  rms2_indices.create(l_tri,l_tri)
   !  MAT{RMS2_INDICES}:set_indices(rms2_indices,l_max,rms_indices,nx,ny,nz)

      ! Make spherical harmonic coefficients -- created in here
      GAUSSIAN_DATA::make_xyz_to_solid_harmonics(spherical_harmonics_for) 

   end

   set_gaussian_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private
   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
   ! momentum up to "l_max". (Actually adds one to each power to avoid 0 as
   ! lower bound). Return "first_nonzero(i)", the cartesian index (between 1 and
   ! 3) of the first non-zero power for the gaussian with lexical index "i".
   ! Also return "index_m1(i)" and "index_p1(i)", the lexical indices of the
   ! gaussians with the first nonzero component decremented by one, and
   ! incrementred by one, respectively. In the latter case we must store all
   ! possible increments.  These are used to determine which gaussian are to be
   ! used in the HRR recursion relations.  
      l_max :: INT, IN
      nx,ny,nz :: VEC{INT}, OUT
      first_nonzero :: VEC{INT}, OUT
      index_of :: MAT3{INT}, OUT
      index_m1 :: VEC{INT}, OUT
      index_p1 :: MAT{INT}, OUT

   ENSURE(nx.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, nx")
   ENSURE(ny.dim==nx.dim,"wrong size, ny")
   ENSURE(nz.dim==nx.dim,"wrong size, nz")
   ENSURE(first_nonzero.dim==nx.dim,"wrong dimension, first_nonzero")
   ENSURE(index_m1.dim ==nx.dim,"wrong dimension, index_m1")
   ENSURE(index_p1.dim1==nx.dim,"wrong 1st dimension, index_p1")
   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
   ENSURE(index_of.dim1==(l_max+1),"wrong 1st dimension, index_of")
   ENSURE(index_of.dim2==(l_max+1),"wrong 2nd dimension, index_of")
   ENSURE(index_of.dim3==(l_max+1),"wrong 3rd dimension, index_of")
      
      L,a,b,c,i, a1,b1,c1,f :: INT
      p,m :: VEC{INT}(3)

      index_of = 0
      i = 1

      ! Loop over angular momentum
      do L = 0,l_max                            ! loop on L
      do a = L,floor((L+2)*THIRD),-1            ! 1st highest power
      do b = min(L-a,a),floor((L-a+1)*HALF),-1  ! 2nd highest power

         ! Get the third power
         c = L - a - b

         ! All powers equal
         if (a==b AND b==c) then

           a1 = a + 1
           nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = a1
           index_of(a1,a1,a1) = i
           first_nonzero(i)   = 1
           i = i + 1

         ! 2nd & 3rd pwers equal
         else if (a>b AND b==c) then

           a1 = a + 1
           b1 = b + 1

           nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = b1
           nx(i+1) = b1; ny(i+1) = a1; nz(i+1) = b1
           nx(i+2) = b1; ny(i+2) = b1; nz(i+2) = a1

           index_of(a1,b1,b1) = i
           index_of(b1,a1,b1) = i+1
           index_of(b1,b1,a1) = i+2

           first_nonzero(i  ) = 1
           first_nonzero(i+1) = 2
           first_nonzero(i+2) = 3
           if (b>0) then
             first_nonzero(i+1) = 1
             first_nonzero(i+2) = 1
           end

           i = i + 3

         ! 1st and 2nd powers equal
         else if (a==b AND b>c) then

           a1 = a + 1
           c1 = c + 1

           nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = c1
           nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = a1
           nx(i+2) = c1; ny(i+2) = a1; nz(i+2) = a1

           index_of(a1,a1,c1) = i
           index_of(a1,c1,a1) = i+1
           index_of(c1,a1,a1) = i+2

           first_nonzero(i)   = 1
           first_nonzero(i+1) = 1
           first_nonzero(i+2) = 2
           if (c>0) then
             first_nonzero(i+2) = 1
           end

           i = i + 3

         ! No power equal
         else

           a1 = a + 1
           b1 = b + 1
           c1 = c + 1

           nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
           nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = b1
           nx(i+2) = b1; ny(i+2) = a1; nz(i+2) = c1
           nx(i+3) = c1; ny(i+3) = a1; nz(i+3) = b1
           nx(i+4) = b1; ny(i+4) = c1; nz(i+4) = a1
           nx(i+5) = c1; ny(i+5) = b1; nz(i+5) = a1

           index_of(a1,b1,c1) = i
           index_of(a1,c1,b1) = i+1
           index_of(b1,a1,c1) = i+2
           index_of(c1,a1,b1) = i+3
           index_of(b1,c1,a1) = i+4
           index_of(c1,b1,a1) = i+5

           if (a>0) then
             first_nonzero(i  ) = 1
             first_nonzero(i+1) = 1
             first_nonzero(i+2) = 2
             first_nonzero(i+3) = 2
             first_nonzero(i+4) = 3
             first_nonzero(i+5) = 3
           else
             first_nonzero(i  ) = 3
             first_nonzero(i+1) = 3
             first_nonzero(i+2) = 3
             first_nonzero(i+3) = 3
             ! i+4,i+5 must have b or c nonzero.
           end

           if (b>0) then
             first_nonzero(i+2) = 1
             first_nonzero(i+4) = 1
             first_nonzero(i+5) = 2
           end
           if (c>0) then
             first_nonzero(i+3) = 1
             first_nonzero(i+5) = 1
           end

           i = i + 6

         end

      end
      end
      end

      ! Now make the index_p1, index_m1 arrays
      do i = 1,nx.dim         

         ! Powers plus one
         p = [nx(i),ny(i),nz(i)]
         m = p        

         ! First non-zero index
         f = first_nonzero(i)

         ! Subtract one power from first nonzero index
         m(f) = m(f) - 1

         ! Get index of first non-zero subtract one power
         if (any(m<1)) then; index_m1(1) = -1
         else;               index_m1(i) = index_of(m(1),m(2),m(3))
         end

         ! Now add one to each power amd get index
         do f = 1,3
            p(f) = p(f) + 1
            if (any(p>l_max+1)) then; index_p1(i,f) = -1
            else;                     index_p1(i,f) = index_of(p(1),p(2),p(3))
            end
            p(f) = p(f) - 1
         end

      end

      ! Fix up s function which has no non-zero
      first_nonzero(1) = -1   

   end

   set_gaussian_power_str(pxyz_rep,pxyz_pow,p123_rep,b123_rep,px,py,pz) ::: selfless, private
   ! Make the xyz powers in a string representation from the integer
   ! powers in "px", "py", "pz". Useful for output.
   ! "pxyz_rep" are the repeated string-components e.g. xxyy
   ! "p123_rep" are the repeated number-components e.g. 1122
   ! "pxyz_pow" have the string-components as powers e.g. x2y2
      pxyz_rep :: VEC{STR}, OUT
      pxyz_pow :: VEC{STR}, OUT
      p123_rep :: VEC{STR}, OUT
      b123_rep :: VEC{STR}, OUT
      px,py,pz :: VEC{INT}, IN

   ENSURE(pxyz_rep.dim1==px.dim1,"pxyz_rep: wrong dim1")
   ENSURE(pxyz_pow.dim1==px.dim1,"pxyz_pow: wrong dim1")
   ENSURE(p123_rep.dim1==px.dim1,"p123_rep: wrong dim1")
      
      dim,i :: INT
      val :: STR

      dim = px.dim1

      do i = 1,dim

         ! Make pxyz_rep
         pxyz_rep(i) = repeat("x",px(i))//repeat("y",py(i))//repeat("z",pz(i))

         ! Make p123_rep
         p123_rep(i) = repeat("1",px(i))//repeat("2",py(i))//repeat("3",pz(i))

         ! Make p123_rep
         b123_rep(i) = repeat("[1]",px(i))//repeat("[2]",py(i))//repeat("[3]",pz(i))

         ! Make pxyz_pow
         val = " "
         if (px(i)==1) val =            "x"
         if (px(i) >1) val =            "x"//trim(px(i).to_str)
         if (py(i)==1) val = trim(val)//"y"
         if (py(i) >1) val = trim(val)//"y"//trim(py(i).to_str)
         if (pz(i)==1) val = trim(val)//"z"
         if (pz(i) >1) val = trim(val)//"z"//trim(pz(i).to_str)
         pxyz_pow(i) = val

      end

   end

! Below is Ishida's original (corrected) ordering
! To use this change make_esfs -> make_esfs_general
! in SHELL1QUARTET

!   set_Ishida_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private
!   ! Same as set_indices except using Ishida's ordering scheme.
!   ! See Ishida (1993), JCP 98 p2176.
!   ! NOTE: NOT WORKING
!   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
!   ! momentum up to "l_max". (Actually adds one to each power to avoid 0 as
!   ! lower bound). Return "first_nonzero(i)", the cartesian index (between 1 and
!   ! 3) of the first non-zero power for the gaussian with lexical index "i".
!   ! Also return "index_m1(i)" and "index_p1(i)", the lexical indices of the
!   ! gaussians with the first nonzero component decremented by one, and
!   ! incrementred by one, respectively. In the latter case we must store all
!   ! possible increments.  These are used to determine which gaussian are to be
!   ! used in the HRR recursion relations.  
!      l_max :: INT, IN
!      nx,ny,nz :: VEC{INT}, OUT
!      first_nonzero :: VEC{INT}, OUT
!      index_of :: MAT3{INT}, OUT
!      index_m1 :: VEC{INT}, OUT
!      index_p1 :: MAT{INT}, OUT
!
!   ENSURE(nx.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, nx")
!   ENSURE(ny.dim==nx.dim,"wrong size, ny")
!   ENSURE(nz.dim==nx.dim,"wrong size, nz")
!   ENSURE(first_nonzero.dim==nx.dim,"wrong dimension, first_nonzero")
!   ENSURE(index_m1.dim==nx.dim,"wrong dimension, index_m1")
!   ENSURE(index_p1.dim1==nx.dim,"wrong 1st dimension, index_p1")
!   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
!   ENSURE(index_of.dim1==(l_max+1),"wrong 1st dimension, index_of")
!   ENSURE(index_of.dim2==(l_max+1),"wrong 2nd dimension, index_of")
!   ENSURE(index_of.dim3==(l_max+1),"wrong 3rd dimension, index_of")
!
!      i,i1,i2,L,M,N,a1,b1,c1,f :: INT
!      p,q :: VEC{INT}(3)
!
!      Ishida_ordering = TRUE
!      index_of = -1
!      index_p1 = -1
!
!      ! S-type gaussian
!      nx(1 ) = 1; ny(1 ) =  1; nz(1 ) =  1
!      index_of( 1, 1, 1) = 1
!      first_nonzero(1 )  = 1
!
!      ! P-type gaussians and greater
!      i = 2
!      do L = 1,l_max
!
!        a1 = L + 1
!
!        i1 = i + 1
!        i2 = i + 2
!
!        nx(i ) = a1; ny(i ) =  1; nz(i ) =  1
!        nx(i1) =  1; ny(i1) = a1; nz(i1) =  1
!        nx(i2) =  1; ny(i2) =  1; nz(i2) = a1
!
!        index_of(a1, 1, 1) = i
!        index_of( 1,a1, 1) = i1
!        index_of( 1, 1,a1) = i2
!
!        first_nonzero(i )  = 1
!        first_nonzero(i1)  = 2
!        first_nonzero(i2)  = 3
!
!        i = i + 3
!
!        if (L<2) cycle
!
!        do M = 1,L/2
!
!           a1 = M + 1
!           b1 = L - M + 1
!
!           i1 = i + 1
!           i2 = i + 2
!
!           nx(i ) = a1; ny(i ) = b1; nz(i ) =  1
!           nx(i1) =  1; ny(i1) = a1; nz(i1) = b1
!           nx(i2) = b1; ny(i2) =  1; nz(i2) = a1
!
!           index_of(a1,b1, 1) = i
!           index_of( 1,a1,b1) = i1
!           index_of(b1, 1,a1) = i2
!
!           first_nonzero(i )  = 1   ! These are not first non-zero
!           first_nonzero(i1)  = 2   ! but good enough for recurrence
!           first_nonzero(i2)  = 3
!
!           i = i + 3
!
!           if (a1==b1) cycle
!
!           i1 = i + 1
!           i2 = i + 2
!
!           nx(i ) = a1; ny(i ) =  1; nz(i ) = b1
!           nx(i1) = b1; ny(i1) = a1; nz(i1) =  1
!           nx(i2) =  1; ny(i2) = b1; nz(i2) = a1
!
!           index_of(a1, 1,b1) = i
!           index_of(b1,a1, 1) = i1
!           index_of( 1,b1,a1) = i2
!
!           first_nonzero(i )  = 1   ! These are not first non-zero
!           first_nonzero(i1)  = 2   ! but good enough for recurrence
!           first_nonzero(i2)  = 3
!
!           i = i + 3
!
!        end
!
!        if (L<3) cycle
!
!        do M = 2,(2*L)/3
!        do N = max(1,2*M-L),M/2     ! <<< Mistake from Ishida?
!
!           a1 = N + 1
!           b1 = M - N + 1
!           c1 = L - M + 1
!
!           nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
!           index_of(a1,b1,c1) = i
!           first_nonzero(i )  = 1  
!
!           i = i + 1
!
!           if (a1==b1 AND b1==c1) cycle
!
!           i1 = i + 1
!
!           nx(i ) = c1; ny(i ) = a1; nz(i ) = b1
!           nx(i1) = b1; ny(i1) = c1; nz(i1) = a1
!
!           index_of(c1,a1,b1) = i
!           index_of(b1,c1,a1) = i1
!
!           first_nonzero(i )  = 2  
!           first_nonzero(i1)  = 3  
!
!           i = i + 2
!
!           if (a1==b1 OR b1==c1 OR a1==c1) cycle
!
!           i1 = i + 1
!           i2 = i + 2
!
!           nx(i ) = a1; ny(i ) = c1; nz(i ) = b1
!           nx(i1) = b1; ny(i1) = a1; nz(i1) = c1
!           nx(i2) = c1; ny(i2) = b1; nz(i2) = a1
!
!           index_of(a1,c1,b1) = i
!           index_of(b1,a1,c1) = i1
!           index_of(c1,b1,a1) = i2
!
!           first_nonzero(i )  = 1  
!           first_nonzero(i1)  = 2   
!           first_nonzero(i2)  = 3
!
!           i = i + 3
!
!        end
!        end
!     
!      end
!
!      ! Now make the index_p1, index_m1 arrays
!      do i = 1,nx.dim         
!
!         ! Powers plus one
!         p = [nx(i),ny(i),nz(i)]
!         q = p        
!
!         ! First non-zero index
!         f = first_nonzero(i)
!
!         ! Subtract one power from first nonzero index
!         q(f) = q(f) - 1
!
!         ! Get index of first non-zero subtract one power
!         if (any(q<1)) then; index_m1(1) = -1
!         else;               index_m1(i) = index_of(q(1),q(2),q(3))
!         end
!
!         ! Now add one to each power amd get index
!         do f = 1,3
!            p(f) = p(f) + 1
!            if (any(p>l_max+1)) then; index_p1(i,f) = -1
!            else;                     index_p1(i,f) = index_of(p(1),p(2),p(3))
!            end
!            p(f) = p(f) - 1
!         end
!
!      end
!
!      ! Fix up s function which has no non-zero
!      first_nonzero(1) = -1   
!
!   end

! ========================================
! Cartesian product string representations
! ========================================

   xyz_product_str_for(l) result (res) ::: selfless, PURE
   ! Return the string representation of the cartesian part of a
   ! gaussian of angular momentum "l"
      l :: INT, IN
      res :: VEC{STR}(n_comp(l))

   ENSURE(l>=0,"l is negative")
   ENSURE(l<=l_max_saved,"l too large, "//trim(l.to_str))

      f,n :: INT

      f = ::n_comp_up_to(l-1)
      n = ::n_comp(l)

      res = pxyz_rep(f+1:f+n)

   end

! ==============================
! Normalising & binomial factors
! ==============================

   set_unnormalizing_factors(l_max,unnormalizing_factors,px,py,pz) ::: selfless, private, PURE
   ! IMPORTANT: Tonto uses cartesian gaussian basis functions for
   ! which *every* component in an L-shell is multiplied by the
   ! normalization factor for x^L (or y^l or z^L). Thus, cartesian
   ! gaussian basis functions different from these in an L-shell are
   ! *NOT* normalized to unity. The "normalising factors" returned by
   ! this procedure multiply L-shell basis function components so that
   ! each component would be normalized.  This is needed to ensure
   ! spherical harmonic components are all normalized. The factors are
   ! introduced into the spherical harmonic transformation matrices,
   ! see below. They are also used when talking to other programs
   ! which usually have every cartesian gaussian normalized.
   ! i.e. tonto-norm = unit-norm * unnormalizing_factors
      l_max :: INT, IN
      unnormalizing_factors :: VEC{REAL}, OUT
      px,py,pz :: VEC{INT}, IN

   ENSURE(px.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, px")
   ENSURE(py.dim==px.dim,"wrong size, py")
   ENSURE(pz.dim==px.dim,"wrong size, pz")
   ENSURE(unnormalizing_factors.dim==px.dim,"wrong dimension,")

      val :: REAL
      l,s,f,i :: INT

      f = 0
      do l = 0,l_max
         s = f + 1
         f = f + GAUSSIAN_DATA::n_comp(l)
         do i = s,f
            val =      l.double_factorial / &
                  (px(i).double_factorial   &
                  *py(i).double_factorial   &
                  *pz(i).double_factorial)
            unnormalizing_factors(i) = sqrt(val)
         end
      end

   end

   set_binomial_p1_coefficients(l_max,binomial_p1) ::: selfless, leaky, private, PURE
   ! Set the binomial coefficients (plus 1) using Pascal's triangle.
   ! In this version one is added to all indices to avoid indexing from 0.
      l_max :: INT, IN
      binomial_p1 :: VEC{EVEC{INT}}@, OUT

   ENSURE(l_max>=0,"l_max must be non-negative")

      n,i :: INT

      ! Create
      binomial_p1.create(l_max+1)
      binomial_p1(1).element.create(1)

      ! Initialize peak of triangle
      binomial_p1(1)[1] = 1

      ! Do Pascal's triangle
      do n = 2,l_max+1

         binomial_p1(n).element.create(n)

         do i = 1,n
            if      (i==1) then; binomial_p1(n)[i] = 1
            else if (i==n) then; binomial_p1(n)[i] = 1
            else;                binomial_p1(n)[i] = binomial_p1(n-1)[i-1] + binomial_p1(n-1)[i]
            end
         end

      end

   end

!  ===============================
!  Normalisation & unnormalisation
!  ===============================

! Tonto works with unnormalized cartesian L-shell gaussians
! So  when reading from other programs you must *unnormalize*
! And when printing out, remember to *renormalize*

   unnormalize(X,first,last,angmom) ::: template, selfless, PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      X :: MAT{TYPE?}, INOUT
      first,last,angmom :: VEC{INT}, IN

      GAUSSIAN_DATA:unnormalize(X,"1",first,last,angmom)
      GAUSSIAN_DATA:unnormalize(X,"2",first,last,angmom)

   end

   unnormalize(X,first,last,angmom) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
   end

   unnormalize(X,first,last,angmom) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
   end


   unnormalize(X,ind,first,last,angmom) ::: template, selfless, PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from matrix X (such factors are not used in Tonto). Works
   ! separatelty for ind equal to "row", or "1"; or "column" or "2".
   ! Requires baisis-fn shell arrays, as well as angular momentum.
   ! NOTE: do this before using foreign expansion coefficients.
   !
   ! Add normalization factors so that every shell component
   ! becomes unit-normalized. Tonto does not use these factors.
   ! You should do this before printing out Tonto operator
   ! cartesian-gaussian matrix elements
      X :: MAT{TYPE?}, INOUT
      ind :: STR, IN
      first,last,angmom :: VEC{INT}, IN

   ENSURE(all(ang<=4),"Cannot handle higher than G functions")

      s,f,l,Ls :: INT

      select case (ind)

      case("row","1")
         do s = 1,first.dim
            f  = first(s)
            l  =  last(s)
            Ls = angmom(s)
            if (Ls>1) then
               GAUSSIAN_DATA:unnormalize_block_L(X(f:l,:),Ls)
            end
         end

      case("column","2")
         do s = 1,first.dim
            f  = first(s)
            l  =  last(s)
            Ls = angmom(s)
            if (Ls>1) then
               GAUSSIAN_DATA:unnormalize_block_R(X(:,f:l),Ls)
            end
         end

      end

   end

   unnormalize(X,ind,first,last,angmom) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from matrix X (such factors are not used in Tonto). Works
   ! separatelty for ind equal to "row", or "1"; or "column" or "2".
   ! Requires baisis-fn shell arrays, as well as angular momentum.
   ! NOTE: do this before using foreign expansion coefficients.
   !
   ! Add normalization factors so that every shell component
   ! becomes unit-normalized. Tonto does not use these factors.
   ! You should do this before printing out Tonto operator
   ! cartesian-gaussian matrix elements
   end

   unnormalize(X,ind,first,last,angmom) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, PURE
   ! *Remove* the intra-shell basis function normalisation factors
   ! from matrix X (such factors are not used in Tonto). Works
   ! separatelty for ind equal to "row", or "1"; or "column" or "2".
   ! Requires baisis-fn shell arrays, as well as angular momentum.
   ! NOTE: do this before using foreign expansion coefficients.
   !
   ! Add normalization factors so that every shell component
   ! becomes unit-normalized. Tonto does not use these factors.
   ! You should do this before printing out Tonto operator
   ! cartesian-gaussian matrix elements
   end


   unnormalize_block_L(B,Ls) ::: template, selfless, pure
   ! Unnormalize the left index of the integral block "B".
      B  :: MAT{TYPE?}, INOUT
      Ls :: INT, IN

      j,nc,fg,lg :: INT

      nc = GAUSSIAN_DATA:n_comp(Ls)
      lg = GAUSSIAN_DATA:n_comp_up_to(Ls-1)

      fg = lg + 1
      lg = lg + nc

      do j = 1,B.dim2
         B(:,j) = B(:,j) * GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
      end

   end

   unnormalize_block_L(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, pure
   ! Unnormalize the left index of the integral block "B".
   end

   unnormalize_block_L(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, pure
   ! Unnormalize the left index of the integral block "B".
   end


   unnormalize_block_R(B,Ls) ::: template, selfless, pure
   ! Unnormalize the right index of the integral block "B".
      B  :: MAT{TYPE?}, INOUT
      Ls :: INT, IN

      i,nc,fg,lg :: INT

      nc = GAUSSIAN_DATA:n_comp(Ls)
      lg = GAUSSIAN_DATA:n_comp_up_to(Ls-1)

      fg = lg + 1
      lg = lg + nc

      do i = 1,B.dim1
         B(i,:) = B(i,:) * GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
      end

   end

   unnormalize_block_R(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, pure
   ! Unnormalize the right index of the integral block "B".
   end

   unnormalize_block_R(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, pure
   ! Unnormalize the right index of the integral block "B".
   end


   renormalize(X,first,last,angmom) ::: template, selfless, PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
      X :: MAT{TYPE?}, INOUT
      first,last,angmom :: VEC{INT}, IN

      GAUSSIAN_DATA:renormalize(X,"1",first,last,angmom)
      GAUSSIAN_DATA:renormalize(X,"2",first,last,angmom)

   end

   renormalize(X,first,last,angmom) ::: get_from,(GAUSSIAN_DATA, TYPE?=>REAL), selfless, PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
   end

   renormalize(X,first,last,angmom) ::: get_from,(GAUSSIAN_DATA, TYPE?=>CPX), selfless, PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from density matrices or operators "X".
   ! NOTE: do this before using foreign expansion coefficients.
   end


   renormalize(X,ind,first,last,angmom) ::: template, selfless, PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from matrix X (such factors are not used in Tonto). Works
   ! separatelty for ind equal to "row", or "1"; or "column" or "2".
   ! Requires baisis-fn shell arrays, as well as angular momentum.
   ! NOTE: do this before printing foreign Tonto coefficients.
   !
   ! Remove normalization factors so that every shell component
   ! becomes Tonto-normalized.
      X :: MAT{TYPE?}, INOUT
      ind :: STR, IN
      first,last,angmom :: VEC{INT}, IN

   ENSURE(all(angmom<=4),"Cannot handle higher than G functions")

      s,f,l,Ls :: INT

      select case (ind)

      case("row","1")
         do s = 1,first.dim
            f  = first(s)
            l  =  last(s)
            Ls = angmom(s)
            if (Ls>1) then
               GAUSSIAN_DATA:renormalize_block_L(X(f:l,:),Ls)
            end
         end

      case("column","2")
         do s = 1,first.dim
            f  = first(s)
            l  =  last(s)
            Ls = angmom(s)
            if (Ls>1) then
               GAUSSIAN_DATA:renormalize_block_R(X(:,f:l),Ls)
            end
         end

      end

   end

   renormalize(X,ind,first,last,angmom) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from matrix X (such factors are not used in Tonto). Works
   ! separatelty for ind equal to "row", or "1"; or "column" or "2".
   ! Requires baisis-fn shell arrays, as well as angular momentum.
   ! NOTE: do this before printing foreign Tonto coefficients.
   !
   ! Remove normalization factors so that every shell component
   ! becomes Tonto-normalized.
   end

   renormalize(X,ind,first,last,angmom) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, PURE
   ! *Include* the intra-shell basis function normalisation factors
   ! from matrix X (such factors are not used in Tonto). Works
   ! separatelty for ind equal to "row", or "1"; or "column" or "2".
   ! Requires baisis-fn shell arrays, as well as angular momentum.
   ! NOTE: do this before printing foreign Tonto coefficients.
   !
   ! Remove normalization factors so that every shell component
   ! becomes Tonto-normalized.
   end


   renormalize_block_L(B,Ls) ::: template, selfless, pure
   ! Renormalize the left index of the integral block "B".
      B  :: MAT{TYPE?}, INOUT
      Ls :: INT, IN

      j,nc,fg,lg :: INT

      nc = GAUSSIAN_DATA:n_comp(Ls)
      lg = GAUSSIAN_DATA:n_comp_up_to(Ls-1)

      fg = lg + 1
      lg = lg + nc

      do j = 1,B.dim2
         B(:,j) = B(:,j) / unnormalizing_factors(fg:lg)
      end

   end

   renormalize_block_L(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, pure
   ! Renormalize the left index of the integral block "B".
   end

   renormalize_block_L(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, pure
   ! Renormalize the left index of the integral block "B".
   end


   renormalize_block_R(B,Ls) ::: template, selfless, pure
   ! Renormalize the right index of the integral block "B".
      B  :: MAT{TYPE?}, INOUT
      Ls :: INT, IN

      i,nc,fg,lg :: INT

      nc = GAUSSIAN_DATA:n_comp(Ls)
      lg = GAUSSIAN_DATA:n_comp_up_to(Ls-1)

      fg = lg + 1
      lg = lg + nc

      do i = 1,B.dim1
         B(i,:) = B(i,:) / unnormalizing_factors(fg:lg)
      end

   end

   renormalize_block_R(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>REAL), selfless, pure
   ! Renormalize the right index of the integral block "B".
   end

   renormalize_block_R(B,Ls) ::: get_from(GAUSSIAN_DATA, TYPE?=>CPX), selfless, pure
   ! Renormalize the right index of the integral block "B".
   end

!  =======================================================
!  Cartesian to spherical harmonic transformation matrices
!  =======================================================

! For simplicity I've changed the ordering of the basis functions
! to be indentical to that in Molden & the Gaussian program.

   make_xyz_to_solid_harmonics(sph) ::: selfless, leaky, PURE
   ! Make the cartesian gaussian to *real* solid harmonic gaussian
   ! transformation matrices up to angular momentum "l_max". The
   ! particular transformation matrix for angular momentum "L" is
   ! S^(LM)_c = sph(L).element(c,M) where "c" is the lexical index of
   ! the cartesian gaussian and "M" is the spherical component index,
   ! as defined in the book by Helgaker, Olsen, and Simons, p.218. 
   ! NOTE: sph is created. 
   ! NOTE: the M index goes as -L:L
   ! ALSO: S^(L 0 ) =        (2 pi/2L+1)^(1/2) Re [    Y_(L 0)] 
   !       S^(L +M) = (-1)^M (8 pi/2L+1)^(1/2) Re [r^L Y_(L M)] M>0
   !       S^(L -M) = (-1)^M (8 pi/2L+1)^(1/2) Im [r^L Y_(L M)] M>0
   ! where Y_(L M) are the *complex* solid harminics also known as
   !                   the (complex) *harmonic polynomials*
   ! These are the same thge normal spherical harmonics but just
   ! multiplied by the factor r^L . See inside square brackets.
      sph :: VEC{EMAT{REAL}}@, OUT

   ENSURE(l_max_saved>=0,"l_max_saved must be non-negative")

      l_max,two :: INT
      L,M,i, del,nc :: INT
      x,y,z, fg,lg  :: INT
      lm1, lm0, lm2 :: INT
      top, bot, fac :: REAL
      val,valp,valm :: REAL
      ix,iy,iz, pow :: VEC{INT}(3)
      foreign :: VEC{INT}@
      new :: VEC{EMAT{REAL}}@

      ! Set l_max
      l_max = l_max_saved

      ! Initialising the tranformation matrices
      two = 2
      sph.create(0,l_max)
      do L = 0,l_max
         nc = GAUSSIAN_DATA::n_comp(L)
         sph(L).element.create(1,nc,-L,L)
         sph(L).element = ZERO
      end

      ! Initialising S function
      sph(0).element(1,0) = ONE

      ! Recurrence for the other functions
      do L = 0,l_max-1

         del = L.delta(0)
         top = 2*L+1
         fac = sqrt((two.raised_to(del))*top/(top+1))
         nc  = GAUSSIAN_DATA::n_comp(L)
         lm1 = GAUSSIAN_DATA::n_comp_up_to(L-1)
         lm0 = GAUSSIAN_DATA::n_comp_up_to(L)

         do i = 1,nc ! loop over cartesian gaussian in L-shell

            pow = GAUSSIAN_DATA::pp(:,lm1+i)
            ix  = pow+[1,0,0]+1; x = GAUSSIAN_DATA::index_of(ix(1),ix(2),ix(3)) - lm0 ! multipy by x
            iy  = pow+[0,1,0]+1; y = GAUSSIAN_DATA::index_of(iy(1),iy(2),iy(3)) - lm0 ! multipy by y
            iz  = pow+[0,0,1]+1; z = GAUSSIAN_DATA::index_of(iz(1),iz(2),iz(3)) - lm0 ! multipy by z

            valp = fac*        sph(L).element(i, L)
            valm = fac*(1-del)*sph(L).element(i,-L)

            sph(L+1).element(x, L+1) = sph(L+1).element(x, L+1) + valp
            sph(L+1).element(x,-L-1) = sph(L+1).element(x,-L-1) + valm
            sph(L+1).element(y, L+1) = sph(L+1).element(y, L+1) - valm
            sph(L+1).element(y,-L-1) = sph(L+1).element(y,-L-1) + valp

            do M = -L,L
               bot = (L+M+1)*(L-M+1)
               val = (top/sqrt(bot))*sph(L).element(i,M)
               sph(L+1).element(z,M) = sph(L+1).element(z,M) + val
            end

         end

         if (L<=0) cycle

         nc  = GAUSSIAN_DATA::n_comp(L-1)
         lm2 = GAUSSIAN_DATA::n_comp_up_to(L-2)

         do i = 1,nc ! loop over cartesian gaussians in (L-1)-shell

            pow = GAUSSIAN_DATA::pp(:,lm2+i)
            ix  = pow+[2,0,0]+1; x = GAUSSIAN_DATA::index_of(ix(1),ix(2),ix(3)) - lm0 ! multiply by x^2
            iy  = pow+[0,2,0]+1; y = GAUSSIAN_DATA::index_of(iy(1),iy(2),iy(3)) - lm0 ! multiply by y^2
            iz  = pow+[0,0,2]+1; z = GAUSSIAN_DATA::index_of(iz(1),iz(2),iz(3)) - lm0 ! multiply by y^2

            do M = -L+1,L-1
               bot = (L+M+1)*(L-M+1)
               val = sqrt((L+M)*(L-M)/bot)*sph(L-1).element(i,M)
               sph(L+1).element(x,M) = sph(L+1).element(x,M) - val
               sph(L+1).element(y,M) = sph(L+1).element(y,M) - val
               sph(L+1).element(z,M) = sph(L+1).element(z,M) - val
            end

         end

      end

      ! L-shell normalizing factors.
      ! Ensures all components are unit-normalized
      lg = 0
      do L = 0,l_max
         nc = GAUSSIAN_DATA::n_comp(L)
         fg = lg + 1
         lg = lg + nc
         do M = -L,L
            sph(L)[:,M] = sph(L)[:,M] * GAUSSIAN_DATA::unnormalizing_factors(fg:lg)
         end
      end

      ! Reorder to Molden-Gaussian order
      new.create(0,l_max)
      do L = 0,l_max
         nc = GAUSSIAN_DATA::n_comp(L)
         new(L).element.create(nc,2*L+1)
         foreign = GAUSSIAN_DATA:from_MG_S_order(L) ! new order
         new(L)[:,foreign] = sph(L)[:,:] 
      end
      sph.destroy
      call move_alloc(new,sph)

   end

! Molden & Gaussian cartesian gaussian basis function order

   from_MG_S_order(L) result (res) ::: pure, selfless
   ! This generates the Molden/Gaussian order corresponding to the
   ! canonical tonto order. For *gathering* molden -> tonto arrays.
   ! i.e. tonto(:) = molden(res(:)) e.g. for L=3 
   !
   ! Tonto : -2,-1, 0, 1, 2 
   ! Molden:  0, 1,-1, 2,-2 
   ! Horton:  0, c, s, c, s ... or
   !
   ! Tonto : -3,-2,-1, 0, 1, 2, 3 
   ! Molden:  0, 1,-1, 2,-2, 3,-3 
   ! Horton:  0, c, s, c, s, c, s
   ! i.e. tonto(:) = molden(res(:))
   ! NOTE: M>0 corresponds to Re [r^L Y_(L M)] or "cos like"
   !       M<0 corresponds to Im [r^L Y_(L M)] or "sin like"
      L :: INT, IN
      res :: VEC{INT}@

      L2, n, i :: INT

      L2 = 2*L
      allocate(res(L2+1))

      select case (L)

      case (0,1)
         res = [ (i, i = 1,L2+1) ]

      case default
         n = 0
         do i = L2, -L2, -2
            n = n + 1
            if (i>=0) then; res(n) =  i + 1
            else;           res(n) = -i
            end
         end

      end

   end

   into_MG_S_order(L) result (res) ::: pure, selfless
   ! This generates the Molden/Gaussian order corresponding to the
   ! canonical tonto order. For *gathering* molden -> tonto arrays.
   ! i.e. tonto(:) = molden(res(:)) e.g. for L=3 
   ! Tonto : -3,-2,-1, 0, 1, 2, 3 
   ! Molden:  0, 1,-1, 2,-2, 3,-3 
   ! Horton:  0, c, s, c, s, c, s
   ! i.e. molden(:) = tonto(res(:))
   ! NOTE: M>0 corresponds to Re [r^L Y_(L M)] or "cos like"
   !       M<0 corresponds to Im [r^L Y_(L M)] or "sin like"
      L :: INT, IN
      res :: VEC{INT}@

      L2, n, i :: INT

      L2 = 2*L
      allocate(res(L2+1))

      select case (L)

      case (0,1)
         res = [ (i, i = 1,L2+1) ]

      case default
         n = 0
         do i = L2+1, 1, -2
            n = n + 1
            res(i) = n
         end
         do i = 2, L2, 2
            n = n + 1
            res(i) = n
         end

      end

   end

!  ========================================================
!  Gaussian-program cartesian gaussian basis function order
!  ========================================================

   swap_from_Gaussian_C_order(X,ind,fbf,lbf,ang) ::: selfless, PURE
   ! Swap the order of F and G cartesian gaussian basis functions in
   ! matrix "X" from the Gaussian order into a Tonto order. "ind"
   ! is either "row" or "1", or "coloumn" or "2" if the first or
   ! second indices are to be reordered. "fbf" and "lbf" are the first
   ! and last basis function indices, and "ang" the angular momentum,
   ! for each cartesian L-shell.
   ! i.e. X(tonto) = swap_from_Gaussian_C_order(X(gaussian) ...))
      X :: MAT{REAL}, INOUT
      ind :: STR, IN
      fbf :: VEC{INT}, IN
      lbf :: VEC{INT}, IN
      ang :: VEC{INT}, IN

   ENSURE(all(ang<=4),"Cannot handle higher than G functions")

      s,Ls,f,l :: INT
    ! fac :: VEC{REAL}@
      Fo :: VEC{INT}(10)
      Go :: VEC{INT}(15)

      ! Tonto order:    xxx yyy zzz xxy xxz xyy yyz xzz yzz xyz
      ! Gaussian order: xxx yyy zzz xyy xxy xxz xzz yzz yyz xyz
      ! Yes, this is indeed the same as Molden ordering
      Fo = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]

      ! Tonto order:    
      ! xxxx yyyy zzzz xxxy xxxz xyyy yyyz xzzz yzzz xxyy xxzz yyzz xxyz xyyz xyzz
      ! Gaussian order: 
      ! zzzz yzzz yyzz yyyz yyyy xzzz xyzz xyyz xyyy xxzz xxyz xxyy xxxz xxxy xxxx
      ! This agrees with the HORTON2 convention in IOData
      Go = [15, 5, 1, 14, 13, 9, 4, 6, 2, 12, 10, 3, 11, 8, 7]

      select case (ind)

      case("row","1")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_from_Gaussian_C_shell_L(X(f:l,:),Ls,Fo,Go)
            GAUSSIAN_DATA:unnormalize_block_L(X(f:l,:),Ls)
         end

      case("column","2")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_from_Gaussian_C_shell_R(X(:,f:l),Ls,Fo,Go)
            GAUSSIAN_DATA:unnormalize_block_R(X(:,f:l),Ls)
         end

      end

   end

   swap_from_Gaussian_C_shell_L(B,Ls,Fo,Go) ::: selfless, pure
   ! Swap the left-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Gaussian order
   ! into a Tonto order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN
      Go :: VEC{INT}(15), IN

      select case (Ls)
      case (3); B = B(Fo,:)
      case (4); B = B(Go,:)
      end

   end

   swap_from_Gaussian_C_shell_R(B,Ls,Fo,Go) ::: selfless, pure
   ! Swap the left-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Gaussian order
   ! into a Tonto order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN
      Go :: VEC{INT}(15), IN

      select case (Ls)
      case (3); B = B(:,Fo)
      case (4); B = B(:,Go)
      end

   end

   swap_into_Gaussian_C_order(X,ind,fbf,lbf,ang) ::: selfless, PURE
   ! Swap the order of F and G cartesian gaussian basis functions in
   ! matrix "X" FROM the Tonto order INTO a Tonto order. "ind"
   ! is either "row" or "1", or "coloumn" or "2" if the first or
   ! second indices are to be reordered. "fbf" and "lbf" are the first
   ! and last basis function indices, and "ang" the angular momentum,
   ! for each cartesian L-shell.
   ! i.e. X(Gaussian) = swap_from_Tonto_C_order(X(Tonto) ...))
      X :: MAT{REAL}, INOUT
      ind :: STR, IN
      fbf :: VEC{INT}, IN
      lbf :: VEC{INT}, IN
      ang :: VEC{INT}, IN

   ENSURE(all(ang<=4),"Cannot handle higher than G functions")

      s,Ls,f,l :: INT
    ! fac :: VEC{REAL}@
      Fo :: VEC{INT}(10)
      Go :: VEC{INT}(15)

      ! Tonto order:    xxx yyy zzz xxy xxz xyy yyz xzz yzz xyz
      ! Gaussian order: xxx yyy zzz xyy xxy xxz xzz yzz yyz xyz
      ! Yes, this is indeed the same as Molden ordering
      Fo = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]

      ! Tonto order:    
      ! xxxx yyyy zzzz xxxy xxxz xyyy yyyz xzzz yzzz 
      ! xxyy xxzz yyzz xxyz xyyz xyzz
      ! Gaussian order: 
      Go = [15, 5, 1, 14, 13, 9, 4, 6, 2, 12, 10, 3, 11, 8, 7]

      select case (ind)

      case("row","l","1")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_into_Gaussian_C_shell_L(X(f:l,:),Ls,Fo,Go)
            GAUSSIAN_DATA:renormalize_block_L(X(f:l,:),Ls)
         end

      case("column","r","2")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_into_Gaussian_C_shell_R(X(:,f:l),Ls,Fo,Go)
            GAUSSIAN_DATA:renormalize_block_R(X(:,f:l),Ls)
         end

      end

   end

   swap_into_Gaussian_C_shell_L(B,Ls,Fo,Go) ::: selfless, pure
   ! Swap the left-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Tonto order
   ! into a Gaussian order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN
      Go :: VEC{INT}(15), IN

      select case (Ls)
      case (3); B(Fo,:) = B
      case (4); B(Go,:) = B
      end

   end

   swap_into_Gaussian_C_shell_R(B,Ls,Fo,Go) ::: selfless, pure
   ! Swap the right-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Tonto order
   ! into a Gaussian order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN
      Go :: VEC{INT}(15), IN

      select case (Ls)
      case (3); B(:,Fo) = B
      case (4); B(:,Go) = B
      end

   end

!  ==============================================
!  Molden cartesian gaussian basis function order
!  ==============================================

   swap_from_Molden_C_order(X,ind,fbf,lbf,ang) ::: selfless, PURE
   ! Swap the order of F and G cartesian gaussian basis functions in
   ! matrix "X" from the Molden order into a Tonto order. "ind"
   ! is either "row" or "1", or "coloumn" or "2" if the first or
   ! second indices are to be reordered. "fbf" and "lbf" are the first
   ! and last basis function indices, and "ang" the angular momentum,
   ! for each cartesian L-shell.
      X :: MAT{REAL}, INOUT
      ind :: STR, IN
      fbf :: VEC{INT}, IN
      lbf :: VEC{INT}, IN
      ang :: VEC{INT}, IN

   ENSURE(all(ang<=4),"Cannot handle higher than G functions")

      s,Ls,f,l :: INT
      Fo :: VEC{INT}(10)

      ! Tonto order:  xxx yyy zzz xxy xxz xyy yyz xzz yzz xyz
      ! Molden order: xxx yyy zzz xyy xxy xxz xzz yzz yyz xyz
      ! Yes, this is indeed the same as Gaussian ordering
      Fo = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]

      select case (ind)

      case("row","1")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_into_Molden_C_shell_L(X(f:l,:),Ls,Fo)
         end

      case("column","2")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_into_Molden_C_shell_R(X(:,f:l),Ls,Fo)
         end

      end

   end

   swap_from_Molden_C_shell_L(B,Ls,Fo) ::: selfless, pure
   ! Swap the left-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Molden order
   ! into a Tonto order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN

      select case (Ls)
      case (3); B = B(Fo,:)
      end

   end

   swap_from_Molden_C_shell_R(B,Ls,Fo) ::: selfless, pure
   ! Swap the left-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Molden order
   ! into a Tonto order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN

      select case (Ls)
      case (3); B = B(:,Fo)
      end

   end

   swap_into_Molden_C_order(X,ind,fbf,lbf,ang) ::: selfless, PURE
   ! Swap the order of F and G cartesian gaussian basis functions in
   ! matrix "X" FROM the Tonto order INTO a Tonto order. "ind"
   ! is either "row" or "1", or "coloumn" or "2" if the first or
   ! second indices are to be reordered. "fbf" and "lbf" are the first
   ! and last basis function indices, and "ang" the angular momentum,
   ! for each cartesian L-shell.
      X :: MAT{REAL}, INOUT
      ind :: STR, IN
      fbf :: VEC{INT}, IN
      lbf :: VEC{INT}, IN
      ang :: VEC{INT}, IN

   ENSURE(all(ang<=4),"Cannot handle higher than G functions")

      s,Ls,f,l :: INT
    ! fac :: VEC{REAL}@
      Fo :: VEC{INT}(10)

      ! Corresponding F and G function order
      Fo = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]

      select case (ind)

      case("row","l","1")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_into_Molden_C_shell_L(X(f:l,:),Ls,Fo)
         end

      case("column","r","2")
         do s = 1,fbf.dim
            f  = fbf(s)
            l  = lbf(s)
            Ls = ang(s)
            GAUSSIAN_DATA:swap_into_Molden_C_shell_R(X(:,f:l),Ls,Fo)
         end

      end

   end

   swap_into_Molden_C_shell_L(B,Ls,Fo) ::: selfless, pure
   ! Swap the left-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Tonto order
   ! into a Molden order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN

      select case (Ls)
      case (3); B(Fo,:) = B
      end

   end

   swap_into_Molden_C_shell_R(B,Ls,Fo) ::: selfless, pure
   ! Swap the right-index order of F and G cartesian gaussian basis
   ! functions in matrix element block "B" from the Tonto order
   ! into a Molden order. 
      B  :: MAT{REAL}, INOUT
      Ls :: INT, IN
      Fo :: VEC{INT}(10), IN

      select case (Ls)
      case (3); B(:,Fo) = B
      end

   end

! ==================================================
! Cartesian-product rotation representation matrices
! ==================================================

   d_xyz_rep_matrices_for(R,is_spherical) result (res) ::: selfless, leaky, PURE
   ! Return the representation matrices for d xyz products found in
   ! gaussian shells from the p xyz matrices.
      R   :: MAT3{REAL}, IN
      is_spherical :: BIN, IN
      res :: MAT3{REAL}@

   ENSURE(R.dim1==3,"wrong 1st dimension, self")
   ENSURE(R.dim2==3,"wrong 2nd dimension, self")
   ENSURE(R.dim3>0,"no p type matrices")

      n,order :: INT
      dtr :: MAT{REAL}@

      if (l_max_saved<2) return

      order = R.dim3

      if (NOT is_spherical) then

         res.create(6,6,order)
         do n = 1,order
            res(:,:,n) = GAUSSIAN_DATA:d_xyz_rep_mx_for(R(:,:,n))
         end

      else

         res.create(5,5,order)
         dtr.create(6,6)
         do n = 1,order
            dtr = GAUSSIAN_DATA:d_xyz_rep_mx_for(R(:,:,n))
            dtr.change_basis_to(res(:,:,n),spherical_harmonics_for(2)[:,:])
         end
         dtr.destroy

      end

   end

   f_xyz_rep_matrices_for(R,is_spherical) result (res) ::: selfless, leaky, PURE
   ! Return the representation matrices for f xyz products found in
   ! gaussian shells from the p xyz matrices
      R   :: MAT3{REAL}, IN
      is_spherical :: BIN, IN
      res :: MAT3{REAL}@

   ENSURE(R.dim1==3,"wrong 1st dimension, self")
   ENSURE(R.dim2==3,"wrong 2nd dimension, self")
   ENSURE(R.dim3>0,"no p type matrices")

      n,order :: INT
      ftr :: MAT{REAL}@

      if (l_max_saved<3) return

      order = R.dim3

      if (NOT is_spherical) then

         res.create(10,10,order)
         do n = 1,order
            res(:,:,n) = GAUSSIAN_DATA:f_xyz_rep_mx_for(R(:,:,n))
         end

      else

         res.create(7,7,order)
         ftr.create(10,10)
         do n = 1,order
            ftr = GAUSSIAN_DATA:f_xyz_rep_mx_for(R(:,:,n))
            ftr.change_basis_to(res(:,:,n),spherical_harmonics_for(3)[:,:])
         end
         ftr.destroy

      end

   end

   g_xyz_rep_matrices_for(R,is_spherical) result (res) ::: selfless, leaky, PURE
   ! Return the representation matrices for g xyz products found in
   ! gaussian shells from the p xyz matrices
      R   :: MAT3{REAL}, IN
      is_spherical :: BIN, IN
      res :: MAT3{REAL}@

   ENSURE(R.dim1==3,"wrong 1st dimension, self")
   ENSURE(R.dim2==3,"wrong 2nd dimension, self")
   ENSURE(R.dim3>0,"no p type matrices")

      n,order :: INT
      gtr :: MAT{REAL}@

      order = R.dim3

      if (l_max_saved<4) return

      if (NOT is_spherical) then

         res.create(15,15,order)
         do n = 1,order
            res(:,:,n) = GAUSSIAN_DATA:g_xyz_rep_mx_for(R(:,:,n))
         end

      else

         res.create(9,9,order)
         gtr.create(15,15)
         do n = 1,order
            gtr = GAUSSIAN_DATA:g_xyz_rep_mx_for(R(:,:,n))
            gtr.change_basis_to(res(:,:,n),spherical_harmonics_for(4)[:,:])
         end
         gtr.destroy

      end

   end


   make_gaussian_xyz_matrices(tr,R) ::: selfless, leaky, PURE
   ! Return representation matrices for the s, p, d, f, and g (l = 0
   ! ... 4) xyz cartesian gaussian shell components from a single p
   ! xyz representation matrix "ptr".
      tr :: VEC{EMAT{REAL}}@, OUT
      R :: MAT{REAL}, IN
   
   ENSURE(R.is_square,"ptr matrix is not square")
   ENSURE(R.dim2==3,"wrong 1st dimension, self")

      tr.create(0,4)

      tr(0).element.create(1,1)
      tr(1).element.create(3,3)
      tr(2).element.create(6,6)
      tr(3).element.create(10,10)
      tr(4).element.create(15,15)

      ! Now assign the transformation matrices
      tr(0).element = ONE
      tr(1).element = R
      tr(2).element = GAUSSIAN_DATA::d_xyz_rep_mx_for(R)
      tr(3).element = GAUSSIAN_DATA::f_xyz_rep_mx_for(R)
      tr(4).element = GAUSSIAN_DATA::g_xyz_rep_mx_for(R)

   end

   d_xyz_rep_mx_for(R) result (dtr) ::: selfless, PURE
   ! Return the representation matrix for a d-type xyz product found
   ! in gaussian shells, induced by an xyz rotation matrix "R". 
   ! The matrix representation induced is: d = d' * dtr, when the
   ! coordinates r of the gaussian shell functions are written in
   ! terms of new coordinates r' as: r = R^T * r'.
   ! ALTERNATIVELY:
   ! If R is used to *change basis* of symmetric matrix D -> D':
   !        D' = R^T * D * R    .... (1)
   ! and if Dv is the row composed of the lower triangle of D in the
   ! order given by "d1" and "d2" below, then this routine returns the
   ! 6 x 6 tensor product matrix "dtr" which performs:
   !       D'v = Dv * dtr       .... (2)
   ! That is, dtr *post multiplies* the row Dv. You can see this is
   ! correct because the (same) off-diagonal elements of D in (1)
   ! contribute twice to every element of D', hence D'v also. You can
   ! see these two contributions in the line below. 
   ! NOTE: If you want the rep matrix which *pre multiplies* a
   ! *column* Dv you need to transpose "dtr"; or else, supply R^T instead
   ! of R to this routine.
      R :: MAT{REAL}, IN
      dtr :: MAT{REAL}(6,6)

   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong size, R")

      i,i1,i2 :: INT
      d1,d2 :: VEC{INT}(6)

    ! sqrt3  = sqrt(THREE)

      d1 = [1,2,3,1,1,2]
      d2 = [1,2,3,2,3,3]

      do i = 1,6 ! loop on old coordinates

         i1 = d1(i)
         i2 = d2(i)

         dtr(1,i)  = R(1,i1)*R(1,i2)
         dtr(2,i)  = R(2,i1)*R(2,i2)
         dtr(3,i)  = R(3,i1)*R(3,i2)
         dtr(4,i)  = R(1,i1)*R(2,i2) &
                   + R(2,i1)*R(1,i2)
         dtr(5,i)  = R(1,i1)*R(3,i2) &
                   + R(3,i1)*R(1,i2)
         dtr(6,i)  = R(2,i1)*R(3,i2) &
                   + R(3,i1)*R(2,i2)
      end

    ! dtr(1:6,4:6) = dtr(1:6,4:6)*sqrt3 ! Put in correct normalization for old primitives
    ! dtr(4:6,1:6) = dtr(4:6,1:6)/sqrt3 ! Put in wrong   normalization for new primitives

   end

   f_xyz_rep_mx_for(R) result (ftr) ::: selfless, PURE
   ! Return the representation matrix for an f xyz product found in
   ! gaussian shells from a p-type xyz matrix. See comments above.
      R :: MAT{REAL}, IN
      ftr :: MAT{REAL}(10,10)

   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong size, R")

      i,i1,i2,i3 :: INT
      f1,f2,f3 :: VEC{INT}(10)

    ! sqrt5  = sqrt(FIVE)
    ! sqrt15 = sqrt(15d0)

      f1 = [1,2,3,1,1,2,2,3,3,1]
      f2 = [1,2,3,1,1,2,2,3,3,2]
      f3 = [1,2,3,2,3,1,3,1,2,3]

      do i = 1,10
         i1 = f1(i)
         i2 = f2(i)
         i3 = f3(i)
         ftr(1,i)  = R(1,i1)*R(1,i2)*R(1,i3)
         ftr(2,i)  = R(2,i1)*R(2,i2)*R(2,i3)
         ftr(3,i)  = R(3,i1)*R(3,i2)*R(3,i3)
         ftr(4,i)  = R(1,i1)*R(1,i2)*R(2,i3) &
                   + R(1,i1)*R(2,i2)*R(1,i3) &
                   + R(2,i1)*R(1,i2)*R(1,i3)
         ftr(5,i)  = R(1,i1)*R(1,i2)*R(3,i3) &
                   + R(1,i1)*R(3,i2)*R(1,i3) &
                   + R(3,i1)*R(1,i2)*R(1,i3)
         ftr(6,i)  = R(1,i1)*R(2,i2)*R(2,i3) &
                   + R(2,i1)*R(1,i2)*R(2,i3) &
                   + R(2,i1)*R(2,i2)*R(1,i3)
         ftr(7,i)  = R(3,i1)*R(2,i2)*R(2,i3) &
                   + R(2,i1)*R(3,i2)*R(2,i3) &
                   + R(2,i1)*R(2,i2)*R(3,i3)
         ftr(8,i)  = R(1,i1)*R(3,i2)*R(3,i3) &
                   + R(3,i1)*R(1,i2)*R(3,i3) &
                   + R(3,i1)*R(3,i2)*R(1,i3)
         ftr(9,i)  = R(2,i1)*R(3,i2)*R(3,i3) &
                   + R(3,i1)*R(2,i2)*R(3,i3) &
                   + R(3,i1)*R(3,i2)*R(2,i3)
         ftr(10,i) = R(1,i1)*R(2,i2)*R(3,i3) &
                   + R(1,i1)*R(3,i2)*R(2,i3) &
                   + R(2,i1)*R(1,i2)*R(3,i3) &
                   + R(2,i1)*R(3,i2)*R(1,i3) &
                   + R(3,i1)*R(1,i2)*R(2,i3) &
                   + R(3,i1)*R(2,i2)*R(1,i3)
      end

    ! ftr(1:10, 4:9 ) = ftr(1:10, 4:9 )*sqrt5
    ! ftr(1:10,10:10) = ftr(1:10,10:10)*sqrt15
    ! ftr(4:9 , 1:10) = ftr(4:9 , 1:10)/sqrt5
    ! ftr(10:10,1:10) = ftr(10:10,1:10)/sqrt15

   end

   g_xyz_rep_mx_for(R) result (gtr) ::: selfless, PURE
   ! Return the representation matrix for a g xyz product found in
   ! gaussian shells from a p-type xyz matrix. See commenst above.
      R :: MAT{REAL}, IN
      gtr :: MAT{REAL}(15,15)

   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong size, R")

      i,i1,i2,i3,i4 :: INT
      g1,g2,g3,g4 :: VEC{INT}(15)

    ! sqrt7  = sqrt(SEVEN)
    ! sqrt35 = sqrt(35d0)         ! = sqrt(35)
    ! sqrt353= sqrt35/sqrt(THREE) ! = sqrt(35)/sqrt(3)

      g1 = [1,2,3,1,1,2,2,3,3,1,1,2,1,2,3]
      g2 = [1,2,3,1,1,2,2,3,3,1,1,2,1,2,3]
      g3 = [1,2,3,1,1,2,2,3,3,2,3,3,2,1,1]
      g4 = [1,2,3,2,3,1,3,1,2,2,3,3,3,3,2]

      do i = 1,15
         i1 = g1(i)
         i2 = g2(i)
         i3 = g3(i)
         i4 = g4(i)
         gtr(1,i)  = R(1,i1)*R(1,i2)*R(1,i3)*R(1,i4)
         gtr(2,i)  = R(2,i1)*R(2,i2)*R(2,i3)*R(2,i4)
         gtr(3,i)  = R(3,i1)*R(3,i2)*R(3,i3)*R(3,i4)
         gtr(4,i)  = R(1,i1)*R(1,i2)*R(1,i3)*R(2,i4) &
                   + R(1,i1)*R(1,i2)*R(2,i3)*R(1,i4) &
                   + R(1,i1)*R(2,i2)*R(1,i3)*R(1,i4) &
                   + R(2,i1)*R(1,i2)*R(1,i3)*R(1,i4)
         gtr(5,i)  = R(1,i1)*R(1,i2)*R(1,i3)*R(3,i4) &
                   + R(1,i1)*R(1,i2)*R(3,i3)*R(1,i4) &
                   + R(1,i1)*R(3,i2)*R(1,i3)*R(1,i4) &
                   + R(3,i1)*R(1,i2)*R(1,i3)*R(1,i4)
         gtr(6,i)  = R(1,i1)*R(2,i2)*R(2,i3)*R(2,i4) &
                   + R(2,i1)*R(1,i2)*R(2,i3)*R(2,i4) &
                   + R(2,i1)*R(2,i2)*R(1,i3)*R(2,i4) &
                   + R(2,i1)*R(2,i2)*R(2,i3)*R(1,i4)
         gtr(7,i)  = R(3,i1)*R(2,i2)*R(2,i3)*R(2,i4) &
                   + R(2,i1)*R(3,i2)*R(2,i3)*R(2,i4) &
                   + R(2,i1)*R(2,i2)*R(3,i3)*R(2,i4) &
                   + R(2,i1)*R(2,i2)*R(2,i3)*R(3,i4)
         gtr(8,i)  = R(1,i1)*R(3,i2)*R(3,i3)*R(3,i4) &
                   + R(3,i1)*R(1,i2)*R(3,i3)*R(3,i4) &
                   + R(3,i1)*R(3,i2)*R(1,i3)*R(3,i4) &
                   + R(3,i1)*R(3,i2)*R(3,i3)*R(1,i4)
         gtr(9,i)  = R(2,i1)*R(3,i2)*R(3,i3)*R(3,i4) &
                   + R(3,i1)*R(2,i2)*R(3,i3)*R(3,i4) &
                   + R(3,i1)*R(3,i2)*R(2,i3)*R(3,i4) &
                   + R(3,i1)*R(3,i2)*R(3,i3)*R(2,i4)
         gtr(10,i) = R(1,i1)*R(1,i2)*R(2,i3)*R(2,i4) &
                   + R(1,i1)*R(2,i2)*R(1,i3)*R(2,i4) &
                   + R(1,i1)*R(2,i2)*R(2,i3)*R(1,i4) &
                   + R(2,i1)*R(1,i2)*R(1,i3)*R(2,i4) &
                   + R(2,i1)*R(1,i2)*R(2,i3)*R(1,i4) &
                   + R(2,i1)*R(2,i2)*R(1,i3)*R(1,i4)
         gtr(11,i) = R(1,i1)*R(1,i2)*R(3,i3)*R(3,i4) &
                   + R(1,i1)*R(3,i2)*R(1,i3)*R(3,i4) &
                   + R(1,i1)*R(3,i2)*R(3,i3)*R(1,i4) &
                   + R(3,i1)*R(1,i2)*R(1,i3)*R(3,i4) &
                   + R(3,i1)*R(1,i2)*R(3,i3)*R(1,i4) &
                   + R(3,i1)*R(3,i2)*R(1,i3)*R(1,i4)
         gtr(12,i) = R(2,i1)*R(2,i2)*R(3,i3)*R(3,i4) &
                   + R(2,i1)*R(3,i2)*R(2,i3)*R(3,i4) &
                   + R(2,i1)*R(3,i2)*R(3,i3)*R(2,i4) &
                   + R(3,i1)*R(2,i2)*R(2,i3)*R(3,i4) &
                   + R(3,i1)*R(2,i2)*R(3,i3)*R(2,i4) &
                   + R(3,i1)*R(3,i2)*R(2,i3)*R(2,i4)
         gtr(13,i) = R(1,i1)*R(1,i2)*R(2,i3)*R(3,i4) &
                   + R(1,i1)*R(1,i2)*R(3,i3)*R(2,i4) &
                   + R(1,i1)*R(2,i2)*R(1,i3)*R(3,i4) &
                   + R(1,i1)*R(2,i2)*R(3,i3)*R(1,i4) &
                   + R(1,i1)*R(3,i2)*R(1,i3)*R(2,i4) &
                   + R(1,i1)*R(3,i2)*R(2,i3)*R(1,i4) &
                   + R(2,i1)*R(1,i2)*R(1,i3)*R(3,i4) &
                   + R(2,i1)*R(1,i2)*R(3,i3)*R(1,i4) &
                   + R(2,i1)*R(3,i2)*R(1,i3)*R(1,i4) &
                   + R(3,i1)*R(1,i2)*R(1,i3)*R(2,i4) &
                   + R(3,i1)*R(1,i2)*R(2,i3)*R(1,i4) &
                   + R(3,i1)*R(2,i2)*R(1,i3)*R(1,i4)
         gtr(14,i) = R(2,i1)*R(2,i2)*R(1,i3)*R(3,i4) &
                   + R(2,i1)*R(2,i2)*R(3,i3)*R(1,i4) &
                   + R(2,i1)*R(1,i2)*R(2,i3)*R(3,i4) &
                   + R(2,i1)*R(1,i2)*R(3,i3)*R(2,i4) &
                   + R(2,i1)*R(3,i2)*R(2,i3)*R(1,i4) &
                   + R(2,i1)*R(3,i2)*R(1,i3)*R(2,i4) &
                   + R(1,i1)*R(2,i2)*R(2,i3)*R(3,i4) &
                   + R(1,i1)*R(2,i2)*R(3,i3)*R(2,i4) &
                   + R(1,i1)*R(3,i2)*R(2,i3)*R(2,i4) &
                   + R(3,i1)*R(2,i2)*R(2,i3)*R(1,i4) &
                   + R(3,i1)*R(2,i2)*R(1,i3)*R(2,i4) &
                   + R(3,i1)*R(1,i2)*R(2,i3)*R(2,i4)
         gtr(15,i) = R(3,i1)*R(3,i2)*R(1,i3)*R(2,i4) &
                   + R(3,i1)*R(3,i2)*R(2,i3)*R(1,i4) &
                   + R(3,i1)*R(1,i2)*R(3,i3)*R(2,i4) &
                   + R(3,i1)*R(1,i2)*R(2,i3)*R(3,i4) &
                   + R(3,i1)*R(2,i2)*R(3,i3)*R(1,i4) &
                   + R(3,i1)*R(2,i2)*R(1,i3)*R(3,i4) &
                   + R(1,i1)*R(3,i2)*R(3,i3)*R(2,i4) &
                   + R(1,i1)*R(3,i2)*R(2,i3)*R(3,i4) &
                   + R(1,i1)*R(2,i2)*R(3,i3)*R(3,i4) &
                   + R(2,i1)*R(3,i2)*R(3,i3)*R(1,i4) &
                   + R(2,i1)*R(3,i2)*R(1,i3)*R(3,i4) &
                   + R(2,i1)*R(1,i2)*R(3,i3)*R(3,i4)
      end

    ! gtr(1:15, 4:9 ) = gtr(1:15, 4:9 )*sqrt7
    ! gtr(1:15,10:12) = gtr(1:15,10:12)*sqrt353
    ! gtr(1:15,13:15) = gtr(1:15,13:15)*sqrt35
    ! gtr(4:9 , 1:15) = gtr(4:9 , 1:15)/sqrt7
    ! gtr(10:12,1:15) = gtr(10:12,1:15)/sqrt353
    ! gtr(13:15,1:15) = gtr(13:15,1:15)/sqrt35

   end

! Symmetric tensor product representation matrices

   symmetric_tensor_2_product_mx(res,R) ::: selfless, PURE
   ! If R is used to *change basis* of symmetric matrix D -> D':
   !        D' = R^T * D * R    .... (1)
   ! and if Dv is the row composed of the lower triangle of D in the
   ! order given by "l1" and "l2" below, then this routine returns the
   ! 6 x 6 cartesian tensor product matrix "res" which performs:
   !       D'v = res * Dv       .... (2)
   ! That is, res *pre multiplies* the column Dv. You can see this is
   ! correct because the (same) off-diagonal elements of D in (1)
   ! contribute twice to every element of D', hence D'v also. You can
   ! see these two contributions in the line below. 
   ! NOTE: this is the transpose of d_xyz_rep_mx_for(R)
   ! NOTE: If you use the MAT:change_basis_using(R) then use this
   ! routine with the same "R" and premultiply by "res" to achieve the
   ! same effect. This is important for 3rd and 4th order transforms.
      res :: MAT{REAL}(6,6), OUT
      R :: MAT{REAL}, IN

   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong size, R")

      l1,l2 :: VEC{INT}(6)
      i,i1,i2 :: INT

      ! Lexical order: read as columns
      l1 = [1,2,3,1,1,2]
      l2 = [1,2,3,2,3,3]

      do i = 1,6 

         i1 = l1(i)
         i2 = l2(i)

         res(i,1)  = R(i1,1)*R(i2,1)
         res(i,2)  = R(i1,2)*R(i2,2)
         res(i,3)  = R(i1,3)*R(i2,3)
         res(i,4)  = R(i1,1)*R(i2,2) + R(i1,2)*R(i2,1)
         res(i,5)  = R(i1,1)*R(i2,3) + R(i1,3)*R(i2,1)
         res(i,6)  = R(i1,2)*R(i2,3) + R(i1,3)*R(i2,2)

      end

   end

   symmetric_tensor_3_product_mx(res,R) ::: selfless, PURE
   ! Return the third-order cartesian tensor product matrix for the
   ! symmetric lower pyramid. See routine above.
      res :: MAT{REAL}(10,10), OUT
      R :: MAT{REAL}, IN

   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong size, R")

      l1,l2,l3 :: VEC{INT}(10)
      i,i1,i2,i3 :: INT

      ! Lexical order: read as columns
      l1 = [1,2,3,1,1,2,2,3,3,1]
      l2 = [1,2,3,1,1,2,2,3,3,2]
      l3 = [1,2,3,2,3,1,3,1,2,3]

      do i = 1,10

         i1 = l1(i)
         i2 = l2(i)
         i3 = l3(i)

         res(i, 1) = R(i1,1)*R(i2,1)*R(i3,1)
         res(i, 2) = R(i1,2)*R(i2,2)*R(i3,2)
         res(i, 3) = R(i1,3)*R(i2,3)*R(i3,3)

         res(i, 4) = R(i1,1)*R(i2,1)*R(i3,2) &
                   + R(i1,1)*R(i2,2)*R(i3,1) &
                   + R(i1,2)*R(i2,1)*R(i3,1)
         res(i, 5) = R(i1,1)*R(i2,1)*R(i3,3) &
                   + R(i1,1)*R(i2,3)*R(i3,1) &
                   + R(i1,3)*R(i2,1)*R(i3,1)
         res(i, 6) = R(i1,1)*R(i2,2)*R(i3,2) &
                   + R(i1,2)*R(i2,1)*R(i3,2) &
                   + R(i1,2)*R(i2,2)*R(i3,1)
         res(i, 7) = R(i1,3)*R(i2,2)*R(i3,2) &
                   + R(i1,2)*R(i2,3)*R(i3,2) &
                   + R(i1,2)*R(i2,2)*R(i3,3)
         res(i, 8) = R(i1,1)*R(i2,3)*R(i3,3) &
                   + R(i1,3)*R(i2,1)*R(i3,3) &
                   + R(i1,3)*R(i2,3)*R(i3,1)
         res(i, 9) = R(i1,2)*R(i2,3)*R(i3,3) &
                   + R(i1,3)*R(i2,2)*R(i3,3) &
                   + R(i1,3)*R(i2,3)*R(i3,2)

         res(i,10) = R(i1,1)*R(i2,2)*R(i3,3) &
                   + R(i1,1)*R(i2,3)*R(i3,2) &
                   + R(i1,2)*R(i2,1)*R(i3,3) &
                   + R(i1,2)*R(i2,3)*R(i3,1) &
                   + R(i1,3)*R(i2,1)*R(i3,2) &
                   + R(i1,3)*R(i2,2)*R(i3,1)

      end

   end

   symmetric_tensor_4_product_mx(res,R) ::: selfless, PURE
   ! Return the fourth-order cartesian tensor product matrix for the
   ! symmetric lower pyramid. See routine above.
      res :: MAT{REAL}(15,15), OUT
      R :: MAT{REAL}, IN

   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong size, R")

      l1,l2,l3,l4 :: VEC{INT}(15)
      i,i1,i2,i3,i4 :: INT

      ! Lexical order: read as columns
      l1 = [1,2,3,1,1,2,2,3,3,1,1,2,1,2,3]
      l2 = [1,2,3,1,1,2,2,3,3,1,1,2,1,2,3]
      l3 = [1,2,3,1,1,2,2,3,3,2,3,3,2,1,1]
      l4 = [1,2,3,2,3,1,3,1,2,2,3,3,3,3,2]

      do i = 1,15

         i1 = l1(i)
         i2 = l2(i)
         i3 = l3(i)
         i4 = l4(i)

         res(i, 1) = R(i1,1)*R(i2,1)*R(i3,1)*R(i4,1)
         res(i, 2) = R(i1,2)*R(i2,2)*R(i3,2)*R(i4,2)
         res(i, 3) = R(i1,3)*R(i2,3)*R(i3,3)*R(i4,3)

         res(i, 4) = R(i1,1)*R(i2,1)*R(i3,1)*R(i4,2) &
                   + R(i1,1)*R(i2,1)*R(i3,2)*R(i4,1) &
                   + R(i1,1)*R(i2,2)*R(i3,1)*R(i4,1) &
                   + R(i1,2)*R(i2,1)*R(i3,1)*R(i4,1)
         res(i, 5) = R(i1,1)*R(i2,1)*R(i3,1)*R(i4,3) &
                   + R(i1,1)*R(i2,1)*R(i3,3)*R(i4,1) &
                   + R(i1,1)*R(i2,3)*R(i3,1)*R(i4,1) &
                   + R(i1,3)*R(i2,1)*R(i3,1)*R(i4,1)
         res(i, 6) = R(i1,1)*R(i2,2)*R(i3,2)*R(i4,2) &
                   + R(i1,2)*R(i2,1)*R(i3,2)*R(i4,2) &
                   + R(i1,2)*R(i2,2)*R(i3,1)*R(i4,2) &
                   + R(i1,2)*R(i2,2)*R(i3,2)*R(i4,1)
         res(i, 7) = R(i1,3)*R(i2,2)*R(i3,2)*R(i4,2) &
                   + R(i1,2)*R(i2,3)*R(i3,2)*R(i4,2) &
                   + R(i1,2)*R(i2,2)*R(i3,3)*R(i4,2) &
                   + R(i1,2)*R(i2,2)*R(i3,2)*R(i4,3)
         res(i, 8) = R(i1,1)*R(i2,3)*R(i3,3)*R(i4,3) &
                   + R(i1,3)*R(i2,1)*R(i3,3)*R(i4,3) &
                   + R(i1,3)*R(i2,3)*R(i3,1)*R(i4,3) &
                   + R(i1,3)*R(i2,3)*R(i3,3)*R(i4,1)
         res(i, 9) = R(i1,2)*R(i2,3)*R(i3,3)*R(i4,3) &
                   + R(i1,3)*R(i2,2)*R(i3,3)*R(i4,3) &
                   + R(i1,3)*R(i2,3)*R(i3,2)*R(i4,3) &
                   + R(i1,3)*R(i2,3)*R(i3,3)*R(i4,2)

         res(i,10) = R(i1,1)*R(i2,1)*R(i3,2)*R(i4,2) &
                   + R(i1,1)*R(i2,2)*R(i3,1)*R(i4,2) &
                   + R(i1,1)*R(i2,2)*R(i3,2)*R(i4,1) &
                   + R(i1,2)*R(i2,1)*R(i3,1)*R(i4,2) &
                   + R(i1,2)*R(i2,1)*R(i3,2)*R(i4,1) &
                   + R(i1,2)*R(i2,2)*R(i3,1)*R(i4,1)
         res(i,11) = R(i1,1)*R(i2,1)*R(i3,3)*R(i4,3) &
                   + R(i1,1)*R(i2,3)*R(i3,1)*R(i4,3) &
                   + R(i1,1)*R(i2,3)*R(i3,3)*R(i4,1) &
                   + R(i1,3)*R(i2,1)*R(i3,1)*R(i4,3) &
                   + R(i1,3)*R(i2,1)*R(i3,3)*R(i4,1) &
                   + R(i1,3)*R(i2,3)*R(i3,1)*R(i4,1)
         res(i,12) = R(i1,2)*R(i2,2)*R(i3,3)*R(i4,3) &
                   + R(i1,2)*R(i2,3)*R(i3,2)*R(i4,3) &
                   + R(i1,2)*R(i2,3)*R(i3,3)*R(i4,2) &
                   + R(i1,3)*R(i2,2)*R(i3,2)*R(i4,3) &
                   + R(i1,3)*R(i2,2)*R(i3,3)*R(i4,2) &
                   + R(i1,3)*R(i2,3)*R(i3,2)*R(i4,2)

         res(i,13) = R(i1,1)*R(i2,1)*R(i3,2)*R(i4,3) &
                   + R(i1,1)*R(i2,1)*R(i3,3)*R(i4,2) &
                   + R(i1,1)*R(i2,2)*R(i3,1)*R(i4,3) &
                   + R(i1,1)*R(i2,2)*R(i3,3)*R(i4,1) &
                   + R(i1,1)*R(i2,3)*R(i3,1)*R(i4,2) &
                   + R(i1,1)*R(i2,3)*R(i3,2)*R(i4,1) &
                   + R(i1,2)*R(i2,1)*R(i3,1)*R(i4,3) &
                   + R(i1,2)*R(i2,1)*R(i3,3)*R(i4,1) &
                   + R(i1,2)*R(i2,3)*R(i3,1)*R(i4,1) &
                   + R(i1,3)*R(i2,1)*R(i3,1)*R(i4,2) &
                   + R(i1,3)*R(i2,1)*R(i3,2)*R(i4,1) &
                   + R(i1,3)*R(i2,2)*R(i3,1)*R(i4,1)
         res(i,14) = R(i1,2)*R(i2,2)*R(i3,1)*R(i4,3) &
                   + R(i1,2)*R(i2,2)*R(i3,3)*R(i4,1) &
                   + R(i1,2)*R(i2,1)*R(i3,2)*R(i4,3) &
                   + R(i1,2)*R(i2,1)*R(i3,3)*R(i4,2) &
                   + R(i1,2)*R(i2,3)*R(i3,2)*R(i4,1) &
                   + R(i1,2)*R(i2,3)*R(i3,1)*R(i4,2) &
                   + R(i1,1)*R(i2,2)*R(i3,2)*R(i4,3) &
                   + R(i1,1)*R(i2,2)*R(i3,3)*R(i4,2) &
                   + R(i1,1)*R(i2,3)*R(i3,2)*R(i4,2) &
                   + R(i1,3)*R(i2,2)*R(i3,2)*R(i4,1) &
                   + R(i1,3)*R(i2,2)*R(i3,1)*R(i4,2) &
                   + R(i1,3)*R(i2,1)*R(i3,2)*R(i4,2)
         res(i,15) = R(i1,3)*R(i2,3)*R(i3,1)*R(i4,2) &
                   + R(i1,3)*R(i2,3)*R(i3,2)*R(i4,1) &
                   + R(i1,3)*R(i2,1)*R(i3,3)*R(i4,2) &
                   + R(i1,3)*R(i2,1)*R(i3,2)*R(i4,3) &
                   + R(i1,3)*R(i2,2)*R(i3,3)*R(i4,1) &
                   + R(i1,3)*R(i2,2)*R(i3,1)*R(i4,3) &
                   + R(i1,1)*R(i2,3)*R(i3,3)*R(i4,2) &
                   + R(i1,1)*R(i2,3)*R(i3,2)*R(i4,3) &
                   + R(i1,1)*R(i2,2)*R(i3,3)*R(i4,3) &
                   + R(i1,2)*R(i2,3)*R(i3,3)*R(i4,1) &
                   + R(i1,2)*R(i2,3)*R(i3,1)*R(i4,3) &
                   + R(i1,2)*R(i2,1)*R(i3,3)*R(i4,3)
      end

   end

   symmetric_tensor_product_mx(res,R) ::: selfless, PURE
   ! This routine returns blocks of the above matrices in a direct
   ! sum, appropriate to the case when parameters are ordered in a
   ! pADP type vector.
      res :: MAT{REAL}, OUT
      R :: MAT{REAL}, IN

   ENSURE(res.is_square,"res not square")
   ENSURE(R.is_square,"R not square")
   ENSURE(R.dim1==3,"wrong dim1, R")
   ENSURE(res.dim1<=34,"wrong dim2, R")

      dim :: INT

      dim = res.dim1

      select case (dim)

      case (3)
         res = ZERO
         res = R

      case (9)
         res = ZERO
         res(1:3,1:3) = R
         GAUSSIAN_DATA::symmetric_tensor_2_product_mx(res( 4: 9, 4: 9),R)

      case (19)
         res = ZERO
         res(1:3,1:3) = R
         GAUSSIAN_DATA::symmetric_tensor_2_product_mx(res( 4: 9, 4: 9),R)
         GAUSSIAN_DATA::symmetric_tensor_3_product_mx(res(10:19,10:19),R)

      case (34)
         res = ZERO
         res(1:3,1:3) = R
         GAUSSIAN_DATA::symmetric_tensor_2_product_mx(res( 4: 9, 4: 9),R)
         GAUSSIAN_DATA::symmetric_tensor_3_product_mx(res(10:19,10:19),R)
         GAUSSIAN_DATA::symmetric_tensor_4_product_mx(res(20:34,20:34),R)

      end

   end

! ==================================================
! Reorder lexical order to lower pyramid for tensors
! ==================================================

   lexical_2_to_lower_pyramid(inp,res) ::: selfless, PURE
   ! The gaussian lexical order for L=2 is reordered to the lower
   ! pyramid for a 3x3 tensor. 
   !. Input  order "inp" is the lexical order
   !. Output order "res" is lower pyramid
      inp :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT

   ENSURE(inp.dim==6      ,"wrong size, inp")
   ENSURE(res.dim==inp.dim,"res and inp are inconsistent")

      i :: INT
      old :: VEC{INT}(6)

      ! Lower pyramid order translator
      old = [1, 4, 2, 5, 6, 3]

      do i = 1,6
         res(i) = inp(old(i))
      end

   end

   lexical_3_to_lower_pyramid(inp,res) ::: selfless, PURE
   ! The gaussian lexical order for L=3 is reordered to the lower
   ! pyramid for a 3x3x3 tensor. 
   ! . Input  order "inp" is the lexical order
   ! . Output order "res" is lower pyramid
   ! Checked by hand 22/06/16
      inp :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT

   ENSURE(inp.dim==10     ,"wrong size, inp")
   ENSURE(res.dim==inp.dim,"res and inp are inconsistent")

      i :: INT
      old :: VEC{INT}(10)

      ! Lower pyramid order translator
      old = [1, 4, 6, 2, 5, 10, 7, 8, 9, 3]

      do i = 1,10
         res(i) = inp(old(i))
      end

   end

   lexical_4_to_lower_pyramid(inp,res) ::: selfless, PURE
   ! The gaussian lexical order for L=4 is reordered to the lower
   ! pyramid for a 3x3x3x3 tensor. 
   ! . Input  order "inp" is the lexical order
   ! . Output order "res" is lower pyramid
   ! Checked by hand 22/06/16
      inp :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT

   ENSURE(inp.dim==15     ,"wrong size, inp")
   ENSURE(res.dim==inp.dim,"res and inp are inconsistent")

      i :: INT
      old :: VEC{INT}(15)

      ! Lower pyramid order translator
      old = [ 1, 4, 10, 6, 2, 5, 13, 14, 7, 11, 15, 12, 8, 9, 3 ]

      do i = 1,15
         res(i) = inp(old(i))
      end

   end

   lower_pyramid_to_lexical_2(inp,res) ::: selfless, PURE
   ! The gaussian lexical order for L=2 is reordered from the lower
   ! pyramid *to* a 3x3 tensor. 
   !. Input  order "res" is the lexical order
   !. Output order "inp" is lower pyramid
      inp :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT

   ENSURE(inp.dim==6      ,"wrong size, inp")
   ENSURE(res.dim==inp.dim,"res and inp are inconsistent")

      i :: INT
      old :: VEC{INT}(6)

      ! Lower pyramid order translator
      old = [1, 4, 2, 5, 6, 3]

      do i = 1,6
         res(old(i)) = inp(i)
      end

   end

   lower_pyramid_to_lexical_3(inp,res) ::: selfless, PURE
   ! The gaussian lexical order for L=3 is reordered from the lower
   ! pyramid *to* a 3x3x3 tensor. 
   !. Input  order "inp" is the lexical order
   !. Output order "res" is lower pyramid
      inp :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT

   ENSURE(inp.dim==10     ,"wrong size, inp")
   ENSURE(res.dim==inp.dim,"res and inp are inconsistent")

      i :: INT
      old :: VEC{INT}(10)

      ! Lower pyramid order translator
      old = [1, 4, 6, 2, 5, 10, 7, 8, 9, 3]

      do i = 1,10
         res(old(i)) = inp(i)
      end

   end

   lower_pyramid_to_lexical_4(inp,res) ::: selfless, PURE
   ! The gaussian lexical order for L=4 is reordered from the lower
   ! pyramid *to* a 3x3x3x3 tensor. 
   !. Input  order "res" is the lexical order
   !. Output order "inp" is lower pyramid
      inp :: VEC{REAL}, IN
      res :: VEC{REAL}, OUT

   ENSURE(inp.dim==15     ,"wrong size, inp")
   ENSURE(res.dim==inp.dim,"res and inp are inconsistent")

      i :: INT
      old :: VEC{INT}(15)

      ! Lower pyramid order translator
      old = [ 1, 4, 10, 6, 2, 5, 13, 14, 7, 11, 15, 12, 8, 9, 3 ]

      do i = 1,15
         res(old(i)) = inp(i)
      end

   end

! ================
! Gaussian ordering
! ================

   tonto_to_gaussian_spherical_indices(L) result (res) ::: pure, selfless
   ! This generates the gaussian/molden order for e.g. L=3
   ! M =  0, 1,-1, 2,-2, 3,-3 ... from the tonto order
   ! M = -3,-2,-1, 0, 1, 2, 3 ... 
   ! Checked 22/9/2020 by Dylan!
      L :: INT, IN
      res :: VEC{INT}@

      n, M :: INT

      allocate(res(2*L + 1))

      ! Gaussian BF index which
      ! points to the tonto index
      n = 1

      do M = 0, L

         ! The M=0 case is first
         res(n) = L + M + 1

         n = n + 1

         ! Add M<0 case immediately after
         if (M > 0) then
            res(n) = L - M + 1
            n = n + 1
         end

      end

   end

   gaussian_to_tonto_spherical_indices(l) result (res) ::: pure, selfless
   ! ??? Is this Kosher
      l :: INT, IN
      res :: VEC{INT}@

      lm, i :: INT

      allocate(res(2*l + 1))

      lm = 1
      do i = 2*l, -1, -2
         res(lm) = i + 1
         lm = lm + 1
      end

      do i = 1, 2*l, 2
         res(lm) = i + 1
         lm = lm + 1
      end

   end

end
