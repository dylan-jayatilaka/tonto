!===============================================================================
!
! MOLECULE.REL: An object representation of a molecule. Relativistic codes.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.foo 3762 2012-06-18 21:30:38Z dylan_ $
!===============================================================================

module MOLECULE.REL

   implicit none

contains

!  ===================
!  Primitive integrals
!  ===================

   make_primitive_overlap_matrix(S)
   ! Calculate the primitive overlap matrix "S"
   ! NOTE: if the contraction coefficients have been unnormalised (as
   ! is usually the case) then this overlap matrix will not have one's
   ! on the diagonal. The make normalised overlap integrals refers to
   ! the fact that the l > d shell type factors have been inlcuded and
   ! not the overall normalisation of the primitive.
      self :: IN
      S :: MAT{REAL}, OUT

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(S.is_square, "S must be square")
   ENSURE(S.dim1==.n_prim, "wrong size, S")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitve shells
      nps = frst.dim

      ! Calculate the primitive integrals
      do a = 1,nps

        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a)
        la = last(a)

        do b = 1,a

           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b)
           lb = last(b)

           ! Do it
           G.make_normalised_overlap_ints(S(fa:la,fb:lb),.use_spherical_basis)

        end

      end

      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy

      ! Make a symmetric matrix
      S.symmetric_reflect

      ! Debug
      .BASE:put_debug(S,"make_primitive_overlap_matrix: S")

   end

   make_primitive_kinetic_matrix(T)
   ! Calculate the primitive kinetic matrix "T"
      self :: IN
      T :: MAT{REAL}, OUT

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitve shells
      nps = frst.dim

      ! Calculate the primitive integrals
      do a = 1,nps

        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a)
        la = last(a)

        do b = 1,a

           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b)
           lb = last(b)

           ! Do it
           G.make_normalised_kinetic_ints(T(fa:la,fb:lb),.use_spherical_basis)

        end

      end

      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      T.symmetric_reflect
      .BASE:put_debug(T,"make_primitive_kinetic_matrix: T")

      ! Test
   ! ccm.create(.n_prim,.n_bf)
   ! Tb.create(.n_bf,.n_bf)
   ! .BASE:make_normalised_contraction_mx(ccm)
   ! T.change_basis_to(Tb,ccm)
   ! .BASE:put_debug(Tb,"basis fn overlap matrix")
   ! Tb.destroy
   ! ccm.destroy

   end

   make_primitive_nuclear_matrix(Z)
   ! Calculate the primitive nuclear attraction matrix "Z"
      self :: IN
      Z :: MAT{REAL}, OUT

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(Z.is_square, "Z must be square")
   ENSURE(Z.dim1==.n_prim, "wrong size, Z")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c,n,neta :: INT
      G :: GAUSSIAN2
      atom :: ATOM*
      Zc :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitve shells
      nps = frst.dim

      ! Calculate the primitive integrals
      Z = ZERO

      do a = 1,nps

        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a)
        la = last(a)
        na = la - fa + 1

        do b = 1,a

           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b)
           lb = last(b)
           nb = lb - fb + 1

           ! Integrate for each nucleus "c"
           Zc.create(na,nb)
           do c = 1,.n_atom
              atom => .atom(c)
              if (c==1)then
                n=.scfdata.nhf ! for numerical diff of energy by the change of the size of the nucleus
                ! only one (the first) nucleus at a time can be treated
              else
                n=0
              end if
              select case (.nucleus_model)
                case ("point")
           G.make_normalised_NA_ints(Zc,atom.position,.use_spherical_basis)                
                case ("finite","gaussian")
                neta= atom.atomic_number 
           G.make_normalised_finite_NA_ints(Zc,atom.position,neta,n,.use_spherical_basis)   
                case default
           DIE("Unknown model of nucleus")     
              end
          !    G.make_normalised_NA_ints(Zc,atom.position,.use_spherical_basis)
              Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Zc
           end

           Zc.destroy

        end

      end

      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy

      ! Make a symmetric matrix
      Z.symmetric_reflect

      ! Debug
      .BASE:put_debug(Z,"make_primitive_nuclear_matrix: Z")

      ! Test
    ! ccm.create(.n_prim,.n_bf)
    ! Zb.create(.n_bf,.n_bf)
    ! .BASE:make_normalised_contraction_mx(ccm)
    ! Z.change_basis_to(Zb,ccm)
    ! .BASE:put_debug(Zb,"basis fn NA matrix")
    ! Zb.destroy
    ! ccm.destroy

   end

!  ================================
!  Douglas-Kroll-Hess PVP integrals
!  ================================

   make_primitive_DKH_matrices(T,SOx,SOy,SOz)
   ! Calculate the primitive Douglas-Kroll-Hess integrals
      self :: IN
      T,SOx,SOy,SOz :: MAT{REAL}, OUT

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")
   ENSURE(SOx.is_same_shape_as(T),"wrong shape, SOx")
   ENSURE(SOy.is_same_shape_as(T),"wrong shape, SOy")
   ENSURE(SOz.is_same_shape_as(T),"wrong shape, SOz")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c,n,neta :: INT
      Z :: REAL
      G :: GAUSSIAN2
      atom :: ATOM*
      Tc,SOxc,SOyc,SOzc :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim

      T = ZERO
      SOx = ZERO
      SOy = ZERO
      SOz = ZERO

      do a = 1,nps

        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))

        fa = frst(a)
        la = last(a)
        na = la - fa + 1

        do b = 1,a

           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))

           fb = frst(b)
           lb = last(b)
           nb = lb - fb + 1

             Tc.create(na,nb)
           SOxc.create(na,nb)
           SOyc.create(na,nb)
           SOzc.create(na,nb)

           do c = 1,.n_atom

              atom => .atom(c)

              if (c==1)then
                n=.scfdata.nhf ! for numerical diff of energy by the change of the size of the nucleus
                ! only one (the first) nucleus at a time can be treated
              else
                n=0
              end if
              select case (.nucleus_model)
                case ("point")
                  G.make_normalised_DKH_ints(Tc,SOxc,SOyc,SOzc &
                     ,atom.position,.use_spherical_basis)                
                case ("finite","gaussian")
                  neta = atom.atomic_number 
                  G.make_normalised_finite_DKH_ints(Tc, &
                     SOxc,SOyc,SOzc,atom.position,neta,n,.use_spherical_basis)
                case default
                  DIE("Unknown model of nucleus")     
              end

              Z = atom.nuclear_charge

                T(fa:la,fb:lb) =   T(fa:la,fb:lb) - Z * Tc
              SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) - Z * SOxc
              SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) - Z * SOyc
              SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) - Z * SOzc

           end

           SOzc.destroy
           SOyc.destroy
           SOxc.destroy
           Tc.destroy

        end

      end

      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy

      ! Make a symmetric matrix
      T.symmetric_reflect
      SOx.antisymmetric_reflect
      SOy.antisymmetric_reflect
      SOz.antisymmetric_reflect

      ! Debug, turn on with debug_on "key"
      .BASE:put_debug(T,  "make_primitive_DKH_matrices: T")
      .BASE:put_debug(SOx,"make_primitive_DKH_matrices: SOx")
      .BASE:put_debug(SOy,"make_primitive_DKH_matrices: SOy")
      .BASE:put_debug(SOz,"make_primitive_DKH_matrices: SOz")

      ! Test
    ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

   make_primitive_DK3_ppZpp_mx(ppZpp)
   ! Calculate the primitive Douglas-Kroll-Hess integrals
      self  :: IN
      ppZpp :: MAT{REAL}, OUT

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(ppZpp.is_square, "T must be square")
   ENSURE(ppZpp.dim1==.n_prim, "wrong size, T")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,na,fb,lb,nb,c :: INT
     Z :: REAL
     G :: GAUSSIAN2
     atom :: ATOM*
     Tc :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! No. of primitive shells
     nps = frst.dim

     ! Zero
     ppZpp = ZERO 

     ! Calculate the primitive integrals
     do a = 1,nps

        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a)
        la = last(a)
        na = la - fa + 1

        do b = 1,a

           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b)
           lb = last(b)
           nb = lb - fb + 1

           Tc.create(na,nb)
           do c = 1,.n_atom
              atom => .atom(c)
              G.make_normalised_DK3_ppZpp_ints(Tc,atom.position,.use_spherical_basis)
              Z = atom.nuclear_charge
              ppZpp(fa:la,fb:lb) =  ppZpp(fa:la,fb:lb) - Z * Tc
           end
           Tc.destroy

        end

     end

     ! Clean up indexing arrays
     ex.destroy
     l.destroy
     at.destroy
     last.destroy
     frst.destroy

     ! Make a symmetric matrix
     ppZpp.symmetric_reflect

     ! Debug, turn on with debug_on "key"
     .BASE:put_debug(ppZpp,"make_primitive_DK3_ppZpp_mx: ppZpp")

   end

   make_fd_DKH_matrix(T,SOx,SOy,SOz)
   ! Calculate the primitive nuclear attraction matrix "Z"
   ! Using finidit difference to check the routine above.
      self :: IN
      T,SOx,SOy,SOz :: MAT{REAL}, OUT

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")
   ENSURE(SOx.is_same_shape_as(T),"wrong shape, SOx")
   ENSURE(SOy.is_same_shape_as(T),"wrong shape, SOy")
   ENSURE(SOz.is_same_shape_as(T),"wrong shape, SOz")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c :: INT
      G :: GAUSSIAN2
      atom :: ATOM*
      Zc :: MAT{REAL}*

      Zpq :: MAT4{REAL}*
      i,j,p,q :: INT
      pos  :: VEC{REAL}(3)
      step,step2 :: REAL

      step  = 0.00005d0
      step2 = QUARTER/(step*step)

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitive shells
      nps = frst.dim

      ! Calculate the primitive integrals
      Zpq.create(.n_prim,.n_prim,3,3)
      Zpq = ZERO

      ! Loop over finide difference steps
      do p =  1,3
      do i = -1,1,2
      do q =  1,3
      do j = -1,1,2

        ! Calculate Z integrals for this step
        do a = 1,nps

           G.a.set_l(l(a))
           pos = .atom(at(a)).position
           pos(p) = pos(p) + i*step
           G.a.set_position(pos)
           G.a.set_exponent(ex(a))
           fa = frst(a)
           la = last(a)
           na = la - fa + 1

           do b = 1,a

              G.b.set_l(l(b))
              pos = .atom(at(b)).position
              pos(q) = pos(q) + j*step
              G.b.set_position(pos)
              G.b.set_exponent(ex(b))
              fb = frst(b)
              lb = last(b)
              nb = lb - fb + 1

              Zc.create(na,nb)
              do c = 1,.n_atom
                 atom => .atom(c)
                 G.make_normalised_NA_ints(Zc,atom.position,.use_spherical_basis)
                 Zpq(fa:la,fb:lb,p,q) = Zpq(fa:la,fb:lb,p,q) - i*j*atom.nuclear_charge*Zc*step2
              end
              Zc.destroy

           end

        end

      end
      end
      end
      end

      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy

      ! Make a symmetric matrix
      do p =  1,3
      do q =  1,3
         Zpq(:,:,p,q).symmetric_reflect
      end
      end

      ! Make the T, SOx, SOy, SOz matrices
       T  = Zpq(:,:,1,1) + Zpq(:,:,2,2) + Zpq(:,:,3,3)
      SOx = Zpq(:,:,2,3) - Zpq(:,:,3,2)
      SOy = Zpq(:,:,3,1) - Zpq(:,:,1,3)
      SOz = Zpq(:,:,1,2) - Zpq(:,:,2,1)

      ! Clean up
      Zpq.destroy

      .BASE:put_debug(T  ,"make_fd_DKH_matrix: T")
      .BASE:put_debug(SOx,"make_fd_DKH_matrix: SOx")
      .BASE:put_debug(SOy,"make_fd_DKH_matrix: SOy")
      .BASE:put_debug(SOz,"make_fd_DKH_matrix: SOz")

   end

!  ========================================
!  Dylan's primitive linear depedence stuff
!  ========================================

   shift_linear_dependence_in_ngcm_from(F,Fnew)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors with small eigenvalue; place the result into "Fnew"
   ! WARNING: this routine assumed overlap_eigenvalues are ordered 
   ! smallest to largest.
      self :: IN
      F    :: MAT{REAL}, IN
      Fnew :: MAT{REAL}, OUT

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(F.is_square,"F not square")
   ENSURE(Fnew.is_square,"Fnew not square")
   ENSURE(F.is_same_shape_as(Fnew),"F and Fnew incompatible")

      n :: INT
      tol,shift :: REAL
      n_gcm :: INT
      m_out :: MAT{INT}*
      R,S,evec :: MAT{REAL}*
      eval :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .:make_ready_da_gcm_tr2(m_out,n_gcm) 
      ENSURE(F.dim1==n_gcm,"wrong size, F is not in n_gcm space")

      R.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,S,m_out)  
      m_out.destroy
      R.destroy

      evec.create(n_gcm,n_gcm)
      eval.create(n_gcm)

      S.solve_symmetric_eigenproblem(eval,evec)
      S.destroy

      ! Return if all overlap matrix eigenvalues are big enough
      tol = .scfdata.linear_dependence_tol
      n   = eval.index_of_first_greater_than(tol)
      eval.destroy
      if (n==1) then
         Fnew = F
         return
      end

      ! Change to the eigenvector basis
      F.change_basis_to(Fnew,evec)

      ! Decouple the linear dependencies
      Fnew(:n-1,n:) = ZERO
      Fnew(n:,:n-1) = ZERO

      ! Shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      !  Fnew.increment_diagonal_by(shift)
      Fnew(:n-1,:n-1).increment_diagonal_by(shift)

      ! Revert from the eigenvector basis
      Fnew.back_transform_using(evec)
      evec.destroy

   end

   shift_linear_dependence_in_ngcm_from(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors with small eigenvalue.
   ! WARNING: this routine assumed overlap_eigenvalues are ordered 
   ! smallest to largest.
      self :: IN
      F :: MAT{REAL}, INOUT

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(F.is_square,"F not square")

      n :: INT
      tol,shift :: REAL
      n_gcm :: INT
      m_out :: MAT{INT}*
      R,S,evec :: MAT{REAL}*
      eval :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .:make_ready_da_gcm_tr2(m_out,n_gcm) 
      ENSURE(F.dim1==n_gcm,"wrong size, F is not in n_gcm space")

      R.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,S,m_out)  
      m_out.destroy
      R.destroy

      evec.create(n_gcm,n_gcm)
      eval.create(n_gcm)

      S.solve_symmetric_eigenproblem(eval,evec)
      S.destroy

      ! Return if all overlap matrix eigenvalues are big enough
      tol = .scfdata.linear_dependence_tol
      n   = eval.index_of_first_greater_than(tol)
      eval.destroy
      if (n==1) return

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the linear dependencies
      F(:n-1,n:) = ZERO
      F(n:,:n-1) = ZERO

      ! Shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      ! F.increment_diagonal_by(shift)
      F(:n-1,:n-1).increment_diagonal_by(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)
      evec.destroy

   end

!  =================================
!  Primitive linear depedence stuff?
!  =================================

   get_n_gcm(m_out,n)
   ! routine which gains the m_out and n = n_gcm
      self :: IN
      m_out :: MAT{INT} , OUT 
      n :: INT, OUT

      .:make_ready_da_gcm_tr2(m_out,n)  

   end

   make_ready_da_gcm_tr2(m_out,n_gcm) 
   ! this routine works better than the previous
   ! but worked only for one atom
   ! I (LBxxx) have edited it at 3.oct.2008 
   ! the cycle if the gaussians are at different nuclei should work 
   ! TESTED !!!! & CALLED 
      self  :: IN
      m_out :: MAT{INT}, OUT
      n_gcm :: INT, OUT

      G :: GAUSSIAN2
      TRE, X_def,x,y,z,norm :: REAL
      i,j,k,nps,step :: INT
      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*

      ! Primitive basis function limits
      .atom.make_primitive_limits(frst,last,at,l,ex)

      X_def = TOL(8) ! WHY??? --dylan
      norm  = TOL(4) ! WHY???
      TRE = ZERO
      m_out = 0
      n_gcm = .n_prim

      ! No of primitive shells
      nps = .atom.no_of_primitive_shells

      do i = 1,nps-1

         G.a.set_position(.atom(at(i)).position)

         if (m_out(frst(i),frst(i))==1) cycle

         do j = i+1,nps

            G.b.set_position(.atom(at(j)).position)

            ! The nuc cycle condition (????)
            x = abs(G.a.position(1) - G.b.position(1))
            y = abs(G.a.position(2) - G.b.position(2))
            z = abs(G.a.position(3) - G.b.position(3))

            if (x>norm OR y>norm OR z>norm) cycle 
            if (l(i)/=l(j))                 cycle
            if (m_out(frst(j),frst(j))==1)  cycle

            TRE = ex(i) - ex(j)

            if (abs(TRE) < X_def) then

               step = frst(j)-frst(i)
               do k = frst(i),last(i)
                  m_out(k,k+step) = 1
                  m_out(k+step,k+step) = 1
               end
               n_gcm = n_gcm - last(i) + frst(i) - 1

            end 

         end

      end

      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy

   end

   get_da_gcm_now(M,M_gcm,m_out)  
   ! This routine is thought for the S,T,Z,PZP primitive integrals
   ! matrices. Meaning of variables:
   ! M any primitive matrix; input
   ! M_gcm non-redundant primitive matrix; output
   ! m_out matrix; input 
      self :: IN
      M :: MAT{REAL}, IN
      M_gcm :: MAT{REAL}, OUT
      m_out :: MAT{INT}, IN 

      i,j,k,l :: INT    

      M_gcm = ZERO  

      k = 0
      l = 0

      do i = 1,.n_prim

         ! If the line is the same like a previous line do not copy it
         ! to do M_gcm  (????)
         if (m_out(i,i)==1) cycle 
        
         k = k + 1
         l = k
        
         do j = i,.n_prim
        
            ! if the column j is the same like a previous column do not
            ! copy it to do M_gcm  (????)
            if (m_out(j,j)==1) cycle
        
            M_gcm(l,k) = M(j,i)
            l = l + 1
        
         end

      end

      M_gcm.symmetric_reflect

   end

   get_back_prim_now(M_gcm,M,m_out)  
   ! This routine is thought for the final DKH matrix in the
   ! non-redundant a-la general contraction primitive basis set style
   ! to get projected back to the tonto primitive often redundant
   ! basis set style. Meaning of variables:
   ! M_gcm any gcm matrix; input
   ! M primitive matrix; output 
   ! m_out matrix of
      self :: IN
      M_gcm :: MAT{REAL}, IN
      M :: MAT{REAL}, OUT
      m_out :: MAT{INT}, IN
      
      i,j,k,l :: INT    


      ! The routine has three steps first those lines(columns) which
      ! are non-redundant give back to the same place like they were
      ! obtained in the S to S_gcm transformation.  I am not sure if
      ! this can not be written in a more effective way.

      k = 0
      l = 0

      do i = 1,.n_prim

        if (m_out(i,i)==1) cycle

        k = k + 1
        l = k + 1

        M(i,i) = M_gcm(k,k)
        do j = i+1,.n_prim
           if (m_out(j,j)==1) cycle
           M(i,j) = M_gcm(k,l)
           M(j,i) = M_gcm(l,k)
           l = l + 1
        end

      end

      ! Second: copy each line which was deleted back

      do i = 1,.n_prim

         if (m_out(i,i)==1) cycle

         do j = i+1,.n_prim

            if (m_out(i,j)==1) then
               do k=1,.n_prim
                  M(j,k) = M(i,k) 
               end
            end

         end

      end

      ! Third: copy each column which was deleted back

      do i = 1,.n_prim

         if (m_out(i,i)==1) cycle
        
         do j = i+1,.n_prim

           if (m_out(i,j)==1) then
              do k=1,.n_prim
                 M(k,j) = M(k,i) 
              end
           end

         end

      end

   end

   get_da_gcm_now(M,M_gcm,m_out)  
   ! This routine is thought for the S,T,Z,PZP primitive integrals
   ! matrices. Meaning of variables:
   ! M any primitive matrix; input
   ! M_gcm non-redundant primitive matrix; output
   ! m_out matrix; input , complex version
      M :: MAT{CPX}, IN
      M_gcm :: MAT{CPX}, OUT
      m_out :: MAT{INT}, IN

      i,j,k,l :: INT    

      M_gcm = ZERO  
      k = 0
      l = 0

      do i = 1,.n_prim

         ! If the line is the sme like a previous line do not copy it
         ! to do M_gcm (????)
         if (m_out(i,i)==1) cycle 
        
         k = k + 1
         l = k
        
         do j = i,.n_prim
        
           ! If the column j is the sme like a previous column do not
           ! copy it to do M_gcm (????)
           if (m_out(j,j)==1) cycle
        
           M_gcm(l,k) = M(j,i)
           l = l + 1
        
         end

      end

      M_gcm.symmetric_reflect

   end

   get_back_prim_now(M_gcm,M,m_out)  
   ! This routine is thought for the final DKH matrix in the
   ! non-redundant a-la general contraction primitive basis set style
   ! to get projected back to the tonto primitive often redundant
   ! basis set style. Meaning of variables
   ! M_gcm any gcm matrix; input
   ! M primitive matrix; output 
   ! m_out matrix of
      self :: IN
      M_gcm :: MAT{CPX}, IN
      M :: MAT{CPX}, OUT
      m_out :: MAT{INT}, IN

      i,j,k,l :: INT    


      ! The routine has three steps first those lines(columns) which
      ! are non-redundant give back to the same place like they were
      ! obtained in the S to S_gcm transformation. I am not sure if
      ! this can not be written in a more effective way.
      k = 0
      l = 0
      do i = 1,.n_prim

         if (m_out(i,i)==1) cycle
        
         k = k + 1
         l = k + 1
         M(i,i) = M_gcm(k,k)
        
         do j = i+1,.n_prim
        
            if (m_out(j,j)==1) cycle
           
            M(i,j) = M_gcm(k,l)
            M(j,i) = M_gcm(l,k)
            l = l + 1

         end

      end

      ! Second: copy each line which was deleted back

      do i = 1,.n_prim

         if (m_out(i,i)==1) cycle
        
         do j = i+1,.n_prim
           if (m_out(i,j)==1) then
              do k=1,.n_prim
                 M(j,k)=M(i,k) 
              end
           end
         end

      end

      ! Third: copy each column which was deleted back

      do i = 1,.n_prim

        if (m_out(i,i)==1) cycle

        do j = i+1,.n_prim

          if (m_out(i,j)==1) then
             do k=1,.n_prim
                M(k,j)=M(k,i) 
             end
          end

        end

      end

   end

! =============
! Core matrices
! =============

! Relativistic

   make_r_DKH1_core_matrix(H)
   ! The 1-electron first-order dkh hamiltonian
   ! in the case of a scalar dkh calculation this routine should be called
   ! this routine is really long I should make it shorter using "subroutines"
   ! but I am lazy in the moment to do so (me=LBxxx)
      self :: IN
      H :: MAT{REAL}, OUT

      c :: REAL  
      i,j,n_gcm :: INT     
      SOx,SOy,SOz,R :: MAT{REAL}*
      A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
      D,WW,ppZpp :: MAT{REAL}*
      m_out :: MAT{INT}*
      sZ,sPZP :: MAT{REAL}*
      F, M,buco :: MAT{REAL}* 
      P2,E,Ap :: VEC{REAL}*

      ! Make the non-sigular primitive overlap
      ! Repeated primitives are explicitly removed
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      m_out.create(.n_prim,.n_prim) 
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)  

      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)  

      .BASE:put_debug(S,"make_r_DKH_core_matrix: S")

      ! Get transformation from primitive to orthonormal basis
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)

      ! Make the non-singular primitive kinetic matrix
      R = ZERO
      .REL:make_primitive_kinetic_matrix(R) 

      T.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,T,m_out)  

      .BASE:put_debug(T,"make_r_DKH_core_matrix: T")

      ! Change T to orthonormal basis
      A.create(n_gcm,n_gcm)
      A.to_product_of(Y,T)   
      T.to_product_of(A,Y)

      ! Solve T eigenproblem in orthonormal basis
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_symmetric_eigenproblem(P2,U)
      P2= TWO * P2

      ! Get the non-singular nuclear potential matrix Z
      R = ZERO
      .REL:make_primitive_nuclear_matrix(R)

      Z.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,Z,m_out)  

      .BASE:put_debug(Z,"make_r_DKH_core_matrix: Z")

      ! Change Z to the momentum basis
      A.to_product_of(Y,Z) 
      Z.to_product_of(A,Y)             
      A.to_product_of(U,Z,transpose_a=TRUE)
      Z.to_product_of(A,U)

      ! Make the PZP matrix
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy

      ! Change PZP to the momentum basis
      PZP.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,PZP,m_out)  

      .BASE:put_debug(PZP,"make_r_DKH_core_matrix: PZP")

      A.to_product_of(Y,PZP)  
      PZP.to_product_of(A,Y)
      A.to_product_of(U,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,U)

      ! The DK3 staff
      if (.scfdata.DK3 AND .scfdata.using_ppzpp) then
         ppZpp.create(n_gcm,n_gcm)
         .REL:make_primitive_DK3_ppZpp_mx(R)
         .REL:get_da_gcm_now(R,ppZpp,m_out)  
         A.to_product_of(Y,ppZpp) 
         ppZpp.to_product_of(A,Y)             
         A.to_product_of(U,ppZpp,transpose_a=TRUE)
         ppZpp.to_product_of(A,U)
      end 

      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU

      F.create(n_gcm,n_gcm)
      E.create(n_gcm)
      Ap.create(n_gcm)

      F = ZERO  

      do i = 1,n_gcm
         E(i)  = c * sqrt(P2(i) + c*c)
         Ap(i) = sqrt( (E(i) + c*c)/(TWO * E(i)) )  
         F(i,i)= E(i) - c*c
      end  

      B.create(n_gcm,n_gcm) 

      do i=1,n_gcm
      do j=1,n_gcm
         A(i,j) = Ap(i)*Z(i,j)*Ap(j)
         B(i,j) = c*c*(Ap(i)/(E(i)+c*c))*PZP(i,j)*(Ap(j)/(E(j)+c*c))                                        
      end
      end

      Z = A
      PZP = B

      if (.scfdata.DK1) then
         F = F + Z + PZP
      end


      if (.scfdata.DK2) then

         sZ.create(n_gcm,n_gcm)
         sPZP.create(n_gcm,n_gcm)

         A = ZERO  
         B = ZERO

         do i = 1,n_gcm

            B(i,i) = (c*P2(i)*c)/((c*c + E(i))*(c*c + E(i)))
            A(i,i) = ONE/B(i,i)

            do j = 1,n_gcm

               sZ(i,j)  = Z(i,j)  /(E(i) + E(j)) 
               sPZP(i,j)= PZP(i,j)/(E(i) + E(j)) 

            end

         end

         T =  matmul(Z, matmul(B,sZ) )
         T = T - matmul(PZP,sZ) 
         T = T - matmul(Z,sPZP) 
         T = T + matmul(PZP, matmul(A,sPZP) ) 
         T = T + matmul(sZ, matmul(B,Z) )
         T = T - matmul(sZ,PZP) 
         T = T - matmul(sPZP,Z) 
         T = T + matmul(sPZP, matmul(A,PZP) )

         if (.scfdata.using_SO_FDFF) then
            .:make_SO_fdff(T)
         end if

         F = F + HALF*T

         if (.scfdata.DK3) then

            ! W1W1
            D.create(n_gcm,n_gcm)
            WW.create(n_gcm,n_gcm)
      
            WW =    - matmul(sZ, matmul(B,sZ) )
            WW = WW + matmul(sPZP,sZ) 
            WW = WW + matmul(sZ,sPZP) 
            WW = WW - matmul(sPZP, matmul(A,sPZP) ) 
      
            D = Z + PZP
            T = HALF*(matmul(WW,D)+matmul(D,WW))
            WW.destroy
      
            if (.scfdata.using_ppzpp) then

              D = ZERO
              do i=1,n_gcm
              do j=1,n_gcm
                 D(i,j) = Ap(i)*(c**4)/((E(i)+c*c)**2)*ppZpp(i,j)*Ap(j)/((E(j)+c*c)**2) 
              end
              end

              ppZpp.destroy 

              D = D + PZP
              T = T - matmul(sPZP,matmul(A,matmul(D,sZ)))
              T = T + matmul(sPZP,matmul(A, matmul(D, matmul(A,sPZP))))
              T = T + matmul(sZ,matmul(D,sZ))
              T = T - matmul(sZ,matmul(D, matmul(A,sPZP)))

            else

              T = T - matmul(sPZP,matmul(A,matmul(PZP,sZ)))
              T = T - matmul(sPZP,matmul(Z,matmul(B,sZ)))
              T = T + matmul(sPZP,matmul(A, matmul(PZP, matmul(A,sPZP))))
              T = T + matmul(sPZP,matmul(Z,sPZP))
              T = T + matmul(sZ,matmul(PZP,sZ))
              T = T + matmul(sZ,matmul(B, matmul(Z, matmul(B,sZ))))
              T = T - matmul(sZ,matmul(PZP, matmul(A,sPZP)))
              T = T - matmul(sZ,matmul(B, matmul(Z,sPZP)))

            end if

            F = F + T
      
            D.destroy

         end if

      end if

      Z.destroy
      PZP.destroy
      sZ.destroy
      sPZP.destroy
     
      Ap.destroy 
      P2.destroy
      E.destroy
     
      T.destroy
     
      A.to_product_of(S,Y)
      B.to_product_of(A,U)
     
      S.destroy
      Y.destroy
      U.destroy
     
      A.to_product_of(B,F)
      F.to_product_of(A,B,transpose_b=TRUE)
     
      A.destroy
      B.destroy

      ! put the Fock matrix back to the space .n_prim space
      R = ZERO ! ???
      .:get_back_prim_now(F,R,m_out)  
      F.destroy
      m_out.destroy

      ! moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)
      buco.create(.n_bf,.n_prim)
      buco.to_product_of(M,R,transpose_a=TRUE)
      R.destroy
      A.create(.n_bf,.n_bf)
      A.to_product_of(buco,M)
      M.destroy
      buco.destroy
     
      H = A
      A.destroy
      H.symmetric_reflect
      .BASE:put_debug(H,"make_r_DKH_core_matrix: H")

   end

   make_r_DKH2_core_matrix(H)
   ! the 1-electron dkh hamiltonian
   ! In the case of a scalar dkh calculation this routine should be called
   ! this routine is really long I should make it shorter using "subroutines"
   ! but I am lazy in the moment to do so (me=LBxxx)
      self :: IN
      H :: MAT{REAL}, OUT

      c,tol :: REAL  
      n_small,i,j :: INT     
      SOx,SOy,SOz :: MAT{REAL}*
      A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
      evec,D,WW,ppZpp :: MAT{REAL}*
      sZ,sPZP :: MAT{REAL}*
      F,M :: MAT{REAL}* 
      eval,P2,E,Ap :: VEC{REAL}*

      ! Primitive overlap matrix, S
      S.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(S)

      ! Overlap eigenvectors
      Y.create(.n_prim,.n_prim)
      T.create(.n_prim,.n_prim)
      evec.create(.n_prim,.n_prim)
      eval.create(.n_prim)
      S.solve_symmetric_eigenproblem(eval,evec)

      ! Psuedo-inverse sqrt of overlap, Y
      tol = .scfdata.linear_dependence_tol
      Y.to_inverse_sqrt_of(eval,evec,tol,n_small)
      eval.destroy

      ! Kinetic energy matrix, T
      .:make_primitive_kinetic_matrix(T) 

      ! Change T to orthogonal basis
      T.change_basis_using(Y)

      ! Decouple T from linear dependencies
      MOLECULE.BASE:decouple_and_shift_r(T,evec,n_small,ZERO)
      evec.destroy

      ! Momentum^2 eigenvalues in orthogonal basis
      U.create(.n_prim,.n_prim)
      P2.create(.n_prim)
      T.solve_symmetric_eigenproblem(P2,U)
      P2 = TWO*P2
      P2(1:n_small) = ZERO

      ! Electron-nucleus matrix, Z
      Z.create(.n_prim,.n_prim)
      .:make_primitive_nuclear_matrix(Z)

      ! Change Z to orthogonal basis
      Z.change_basis_using(Y)
      Z.change_basis_using(U)

      ! PZP matrix
      PZP.create(.n_prim,.n_prim)
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy

      ! Change PZP to orthogonal basis, then momentum basis
      PZP.change_basis_using(Y)
      PZP.change_basis_using(U)
      .BASE:put_debug(PZP,"make_r_DKH_core_matrix2: PZP")

      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU

      E.create(.n_prim)
      Ap.create(.n_prim)
      F.create(.n_prim,.n_prim)

      Ap = ZERO
      F  = ZERO  

      do i = 1,.n_prim
         E(i)   = c * sqrt(P2(i) + c*c)
         if (i<=n_small) cycle ! skip small eigenvalues
         F(i,i) = E(i) - c*c
         Ap(i)  = sqrt( (E(i) + c*c)/(TWO*E(i)) )  
      end  

      A.create(.n_prim,.n_prim)
      B.create(.n_prim,.n_prim)

      A = ZERO
      B = ZERO

      do i = n_small+1,.n_prim
      do j = n_small+1,.n_prim
          A(i,j) = Ap(i)*Z(i,j)*Ap(j)
          B(i,j) = c*c * (Ap(i)/(E(i)+c*c)) * PZP(i,j) * (Ap(j)/(E(j)+c*c))
      end
      end

      Z   = A
      PZP = B

      if (.scfdata.DK1) then
         F = F + Z + PZP
      end

      if (.scfdata.DK2) then

         A = ZERO  
         B = ZERO
         do i = n_small+1,.n_prim ! skip small eigenvalues
            B(i,i) = (c*P2(i)*c) / ( (c*c + E(i)) * (c*c + E(i)) )
            A(i,i) = ONE/B(i,i)
         end

         sZ.create(.n_prim,.n_prim)
         sPZP.create(.n_prim,.n_prim)

         sZ = ZERO
         sPZP = ZERO
         do i = n_small+1,.n_prim
         do j = n_small+1,.n_prim
            sZ(i,j)   = Z(i,j)/(E(i)+E(j)) 
            sPZP(i,j) = PZP(i,j)/(E(i)+E(j)) 
         end
         end

         T =     matmul(Z, matmul(B,sZ) )
         T = T + matmul(sZ, matmul(B,Z) )
         T = T - matmul(PZP,sZ) 
         T = T - matmul(sZ,PZP) 
         T = T - matmul(Z,sPZP) 
         T = T - matmul(sPZP,Z) 
         T = T + matmul(PZP, matmul(A,sPZP) ) 
         T = T + matmul(sPZP, matmul(A,PZP) )

         F = F + HALF*T

         if (.scfdata.DK3) then

            ! W1W1
            D.create(.n_prim,.n_prim)
            WW.create(.n_prim,.n_prim)

            WW =    - matmul(sZ, matmul(B,sZ) )
            WW = WW - matmul(sPZP, matmul(A,sPZP) ) 
            WW = WW + matmul(sPZP,sZ) 
            WW = WW + matmul(sZ,sPZP) 
            D  = Z + PZP
            T  = HALF*(matmul(WW,D)+matmul(D,WW))

            WW.destroy

            if (.scfdata.using_ppzpp) then

               ppZpp.create(.n_prim,.n_prim)
               .:make_primitive_DK3_ppZpp_mx(ppZpp)
               ppZpp.change_basis_using(Y)
               ppZpp.change_basis_using(U)

               D = ZERO
               do i = n_small+1,.n_prim
               do j = n_small+1,.n_prim
                  D(i,j) = Ap(i)*(c**4)/( (E(i)+c*c)**2)*ppZpp(i,j)*Ap(j)/( (E(j)+c*c)**2 ) 
               end
               end
               ppZpp.destroy 

               D = D + PZP
               T = T - matmul(sPZP,matmul(A,matmul(D,sZ)))
               T = T - matmul(sZ,matmul(D, matmul(A,sPZP)))
               T = T + matmul(sPZP,matmul(A, matmul(D, matmul(A,sPZP))))
               T = T + matmul(sZ,matmul(D,sZ))

            else

               T = T - matmul(sPZP,matmul(A,matmul(PZP,sZ)))
               T = T - matmul(sZ,matmul(PZP, matmul(A,sPZP)))
               T = T - matmul(sPZP,matmul(Z,matmul(B,sZ)))
               T = T - matmul(sZ,matmul(B, matmul(Z,sPZP)))
               T = T + matmul(sPZP,matmul(A, matmul(PZP, matmul(A,sPZP))))
               T = T + matmul(sPZP,matmul(Z,sPZP))
               T = T + matmul(sZ,matmul(PZP,sZ))
               T = T + matmul(sZ,matmul(B, matmul(Z, matmul(B,sZ))))

            end 

            F = F + T

            D.destroy

         end ! DK3

         sPZP.destroy
         sZ.destroy

      end ! DK2

      Z.destroy
      PZP.destroy

      Ap.destroy 
      P2.destroy
      E.destroy

      T.destroy

      ! Make B = S^(1/2) . momentum eigenvectors
      A.to_product_of(S,Y)
      B.to_product_of(A,U)

      S.destroy
      Y.destroy
      U.destroy

      ! Back transform using B
      F.back_transform_using(B)

      A.destroy
      B.destroy

      ! Moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)

      ! Change back into contracted basis
      F.change_basis_to(H,M)

      M.destroy
      F.destroy

      H.symmetric_reflect
      .BASE:put_debug(H,"make_r_DKH_core_matrix2: H")

   end

   make_r_IOTC_core_matrix(H)
   ! the 1-electron IOTC hamiltonian
      self :: IN
      H :: MAT{REAL}, OUT

      c,alpha,alpha2 :: REAL  
      i,j,k,n_gcm :: INT     
      SOx,SOy,SOz,R :: MAT{REAL}*
      A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
      ppZpp,O :: MAT{REAL}*
      m_out :: MAT{INT}*
      F,Yr,M,buco :: MAT{REAL}* 
      P2,p,ep,bp,E,Ap :: VEC{REAL}*

      ! Analysis of the primitive basis set via the overap matrix.
      ! Trying to lower the problem to an general contracted basis set

      !!!  OVERLAP MATRIX !!!
      R.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(R)

      m_out.create(.n_prim,.n_prim) 
      .:make_ready_da_gcm_tr2(m_out,n_gcm)  

      S.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,S,m_out)  

      ! Y = S^{-1}
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)

      !!!  KINETIC ENERGY MATRIX !!!
      ! put the kinetic energy matrix into the n_gcm non-redundant
      ! space
      .:make_primitive_kinetic_matrix(R) 
      T.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,T,m_out)  

      ! T=YTY  kinetic energy in an orthogonal basis
      ! Use change basis here?
      A.create(n_gcm,n_gcm)
      A.to_product_of(Y,T)   
      T.to_product_of(A,Y)              
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_symmetric_eigenproblem(P2,U)
      P2= TWO * P2
      T.destroy
 
      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      ! put the potential energy matrix into the n_gcm non-redundant space
      .:make_primitive_nuclear_matrix(R)
      Z.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,Z,m_out)  
 
      ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 
      A.to_product_of(Y,Z) 
      Z.to_product_of(A,Y)             
      A.to_product_of(U,Z,transpose_a=TRUE)
      Z.to_product_of(A,U)
 
      !!!  PZP MATRIX  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy
 
      ! put the PZP matrix into the n_gcm non-redundant space
      PZP.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,PZP,m_out)  
      A.to_product_of(Y,PZP)  
      PZP.to_product_of(A,Y)
      A.to_product_of(U,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,U)

      ! DK3 stuff
      if (.scfdata.using_ppzpp) then
         ppZpp.create(n_gcm,n_gcm)
         .:make_primitive_DK3_ppZpp_mx(R)
         .:get_da_gcm_now(R,ppZpp,m_out)  
         ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 
         A.to_product_of(Y,ppZpp) 
         ppZpp.to_product_of(A,Y)             
         A.to_product_of(U,ppZpp,transpose_a=TRUE)
         ppZpp.to_product_of(A,U)
      end if 
 
      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
 
      E.create(n_gcm)
      Ap.create(n_gcm)
      ep.create(n_gcm)
      p.create(n_gcm)
      bp.create(n_gcm)
 
      do i = 1,n_gcm
         E(i)  = c * sqrt(P2(i) + c * c)
         p(i)  = sqrt(P2(i))
         ep(i) = sqrt(ONE+P2(i)*alpha2) 
         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )  
         bp(i) = ONE/(ep(i)+ONE)
      end  
 
      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
      end
      end
 
      if (.scfdata.using_ppzpp) then
         do i=1,n_gcm
         do j=1,n_gcm
            ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)
         end do
         end do
      end if

      ! lets find the transforation matrix
      Yr.create(n_gcm,n_gcm)
      .:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)

      .BASE:put_debug(Yr,"make_r_IOTC_core_matrix: Yr")
 
      O.create(n_gcm,n_gcm)

      O = ZERO

      ! Isn't this just a matrix multiply -- dylan?
      do i=1,n_gcm

         O(i,i) = ONE

         do j=1,n_gcm
         do k=1,n_gcm
             O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
         end do
         end do

      end do
 
      A.to_inverse_sqrt_of(O)
      O = A
 
      F.create(n_gcm,n_gcm)
      if (.scfdata.using_ppzpp) then; .:build_da_IOTC_F(F,Yr,PZP,Z,p,bp,E,n_gcm,ppZpp)
      else;                           .:build_da_IOTC_F(F,Yr,PZP,Z,p,bp,E,n_gcm)
      end if 
 
      .BASE:put_debug(F,"make_r_IOTC_core_matrix: F")
 
      ! normalization<F2>
      A = matmul(O,matmul(F,O))
      F = A

      O.destroy
      Yr.destroy

      .BASE:put_debug(F,"make_r_IOTCcore__matrix: OFO matrix")
 
      Z.destroy
      PZP.destroy
      if (.scfdata.using_ppzpp) then
         ppZpp.destroy
      end if
 
      Ap.destroy 
      P2.destroy
      E.destroy
      p.destroy
      bp.destroy
      ep.destroy
 
      B.create(n_gcm,n_gcm) 
      A.to_product_of(S,Y)
      B.to_product_of(A,U)
 
      S.destroy
      Y.destroy
      U.destroy
 
      A.to_product_of(B,F)
      F.to_product_of(A,B,transpose_b=TRUE)

      .BASE:put_debug(F,"U+YOFOYU matrix")
 
      A.destroy
      B.destroy
 
      ! moving back to tonto style primitive basis sets 
      ! put the Fock matrix back to the space .n_prim space
      .:get_back_prim_now(F,R,m_out)  

      F.destroy
      m_out.destroy
 
      ! moving back to contracted basis sets 
      A.create(.n_bf,.n_bf)
      M.create(.n_prim,.n_bf)
      buco.create(.n_bf,.n_prim)

      .BASE:make_normalised_contraction_mx(M)
      buco.to_product_of(M,R,transpose_a=TRUE)
      A.to_product_of(buco,M)
      
      A.symmetric_reflect
      H = A

      buco.destroy
      M.destroy
      A.destroy
      R.destroy

!      H.symmetric_reflect
      .BASE:put_debug(H,"core matrix")


   end

   make_gc_IOTC_core_matrix(H)
   ! the 1-electron IOTC hamiltonian  2C
      self :: IN
      H :: MAT{CPX}, OUT

      c,alpha,alpha2,eps :: REAL  
      i,j,n_gcm :: INT     
      Yr,F,buco,A,B2,M2,O :: MAT{CPX}*
      O1,O2 :: MAT{CPX}*
      A2,PAP,ppApp :: MAT{CPX}*
      SOx,SOy,SOz,R :: MAT{REAL}*
      YU :: MAT{REAL}*
      B,S,Y,U,Z,PZP,ppZpp,T :: MAT{REAL}*
      mmm :: MAT{INT}*
      M,Y0 :: MAT{REAL}* 
      P2,p,ep,bp,E,Ap,UN :: VEC{REAL}*
      II :: CPX

      !test if n_gcm == .n_prim == .n_bf
      mmm.create(.n_prim,.n_prim)
      .:get_n_gcm(mmm,n_gcm)
      mmm.destroy 
      if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
         DIE(" contracted gaussians do not work for IOTC at gchf level!")
      end if    

      ! this is actually not needed but I am also using n_gcm 
      R.create(n_gcm,n_gcm)
      S.create(n_gcm,n_gcm)
      Y.create(n_gcm,n_gcm)
      !!!  OVERLAP MATRIX + Y MX !!!
      .:make_primitive_overlap_matrix(S)
      Y.to_inverse_sqrt_of(S)

      T.create(n_gcm,n_gcm)
      .:make_primitive_kinetic_matrix(T) 
     
      R.to_product_of(Y,T)   
      T.to_product_of(R,Y)              
      ! T=YTY  kinetic energy in an orthogonal basis
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_symmetric_eigenproblem(P2,U)
      P2= TWO * P2
      T.destroy

      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      U.destroy
      Y.destroy

 
      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      Z.create(n_gcm,n_gcm)
      .:make_primitive_nuclear_matrix(Z)

      ! put the potential energy matrix into the YU space
      R.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(R,YU)
      R=ZERO
 
      !!!  PZP MATRIX  !!!
      PZP.create(n_gcm,n_gcm)
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
 
      ! Isn't this just a a change of basis??? --dylan
      R.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(R,YU)
      R.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(R,YU)
      R.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(R,YU)
      R.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(R,YU)
 
      ! the DK3 staff
      if( .scfdata.using_ppzpp)then
         ppZpp.create(n_gcm,n_gcm)
         .:make_primitive_DK3_ppZpp_mx(ppZpp)
         R.to_product_of(YU,ppZpp,transpose_a=TRUE)
         ppZpp.to_product_of(R,YU)
      end if
 
      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU
      alpha = ONE/c
      alpha2= alpha*alpha
 
      E.create(2*n_gcm)
      ep.create(2*n_gcm)
      p.create(2*n_gcm)
      bp.create(2*n_gcm)
      Ap.create(n_gcm)
 
      do i = 1,n_gcm
         E(i)      = c * sqrt(P2(i) + c * c)
         E(i+n_gcm)= c * sqrt(P2(i) + c * c)
         p(i)      =sqrt(P2(i))
         p(i+n_gcm)=sqrt(P2(i))
         ep(i)      =sqrt(ONE+P2(i)*alpha2)
         ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
         Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
         bp(i)      =ONE/(ep(i)+ONE)
         bp(i+n_gcm)=ONE/(ep(i)+ONE)
      end  
 
      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
      end
      end
 
      if( .scfdata.using_ppzpp)then
         do i=1,n_gcm
         do j=1,n_gcm
            ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)
         end do
         end do
      end if
 
      A2.create(2*n_gcm,2*n_gcm)
      A2 = (ZERO,ZERO)
      A2.alpha_alpha_plus(Z)
      A2.beta_beta_plus(Z)

      PAP.create(2*n_gcm,2*n_gcm)
      PAP=(ZERO,ZERO)
      PAP.alpha_alpha_plus(PZP)
      PAP.beta_beta_plus(PZP)
      II = (ZERO,ONE)
      PAP.beta_alpha_plus(SOx,II)
      PAP.beta_alpha_plus(SOy,-ONE)
      PAP.alpha_alpha_plus(SOz,II)
      PAP.beta_beta_plus(SOz,-II)
      PAP.make_hermitian   

      if (.scfdata.using_ppzpp) then
         ppApp.create(2*n_gcm,2*n_gcm)
         ppApp=(ZERO,ZERO)
         ppApp.alpha_alpha_plus(ppZpp)
         ppApp.beta_beta_plus(ppZpp)
         ppZpp.destroy
      end if

      Yr.create(2*n_gcm,2*n_gcm)
      Y0.create(n_gcm,n_gcm)

      ! lets find the transforation matrix
      Y0 = ZERO
      .:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      R.destroy
 
      ! lets find the transforation matrix
      Yr = (ZERO,ZERO)
      Yr.alpha_alpha_plus(Y0)
      Yr.beta_beta_plus(Y0)

      Y0.destroy
 
      .:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)

      A.create(2*n_gcm,2*n_gcm)
      O.create(2*n_gcm,2*n_gcm)
      O1.create(2*n_gcm,2*n_gcm)
      O2.create(2*n_gcm,2*n_gcm)

      ! to_unit_matrix? --dylan
      O1 = (ZERO,ZERO)
      do i = 1,2*n_gcm
         O1(i,i)=(ONE,ZERO)
      end do

      O.to_product_of(Yr,Yr,dagger_a=TRUE)

      ! Seems a waste just to add 1? --dylan
      O1 = O1 + O
 
      UN.create(2*n_gcm)
 
      ! make ready the preconditioning
      do i = 1,2*n_gcm
         UN(i) = ONE/sqrt(real(O1(i,i)))
      end 
 
      ! This is a diagonal change-of-basis --dylan
      do i=1,2*n_gcm
      do j=1,2*n_gcm
         O1(i,j)=O1(i,j)*UN(i)*UN(j)
      end
      end  
 
      ! Why power series inverse? --dylan
      A   = O1 
      eps = TOL(15)
      O.to_power_series_inv_sqrt_of(O1,eps)
      O1 = A
 
      ! normalization because the inverse power series needs it
      A.to_product_of(O1,O)
      O2.to_product_of(O,A,dagger_a=TRUE)
      A.to_unit_matrix
      A = A - O2
 
      ENSURE(O1.is_hermitian(eps),"1+YY is not hermitian")
      ENSURE(O.is_hermitian(eps),"inv_sqrt(1+YY) is not hermitian")

      O2.destroy
      O1.destroy
 
      ! The hamiltonian is gonna be built
      F.create(2*n_gcm,2*n_gcm)
      F = (ZERO,ZERO)
      if (.scfdata.using_ppzpp) then; .:build_da_IOTC_F(F,Yr,PAP,A2,p,bp,E,ppApp)
      else;                           .:build_da_IOTC_F(F,Yr,PAP,A2,p,bp,E)
      end if 
 
      A2.destroy
      PAP.destroy
      if (.scfdata.using_ppzpp) then
         ppApp.destroy
      end if 
 
      ! Normalization because the inverse power series needs it
      do i=1,2*n_gcm
      do j=1,2*n_gcm
         F(i,j) = F(i,j)*UN(j)*UN(i)
      end
      end

      UN.destroy

      A.to_product_of(F,O)
      ! I am pretty not sure whether to dagger O or not :(
      ! especially because of the inverse power series
      F.to_product_of(O,A,dagger_a=TRUE)
 !    F.to_product_of(O,A)  

      O.destroy
      Yr.destroy
 
      Ap.destroy 
      P2.destroy
      E.destroy
      p.destroy
      bp.destroy
      ep.destroy
 
      B.create(n_gcm,n_gcm) 
      B.to_product_of(S,YU)

      S.destroy
      YU.destroy

      B2.create(2*n_gcm,2*n_gcm)
      B2=(ZERO,ZERO)
      B2.alpha_alpha_plus(B)
      B2.beta_beta_plus(B)
      B.destroy
 
      A.to_product_of(B2,F)
      F.to_product_of(A,B2,dagger_b=TRUE)
 
      B2.destroy
 
      !!! moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)

      M2.create(2*.n_prim,2*.n_prim)
      M2=(ZERO,ZERO)
      M2.alpha_alpha_plus(M)
      M2.beta_beta_plus(M)

      buco.create(2*.n_prim,2*.n_prim)
      buco.to_product_of(M2,F,dagger_a=TRUE)
      A.to_product_of(buco,M2)

      M.destroy
      F.destroy
      M2.destroy
      buco.destroy
 
      H = A

      A.destroy

      .BASE:put_debug(H,"core matrix")

   end

! =========
! DKH stuff
! =========

   make_SO_fdff(T) ::: private
   ! add the fdff scalar correction to T. Is thins INOUT? --dylan
      self :: IN
      T :: MAT{REAL}, INOUT

      Lx,Ly,Lz :: MAT{REAL}*
      sLx,sLy,sLz :: MAT{REAL}*
      R,SOx,SOy,SOz,A,YU :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*
      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      c :: REAL

      m_out.create(.n_prim,.n_prim)
      .:get_n_gcm(m_out,n_gcm)

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)
      .:make_DKH_mxs(YU,Ap,Ep,P2)
     
      !!!  PZP and SO MATRICES  !!!
      R.create(.n_prim,.n_prim)
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      R.destroy

      A.create(n_gcm,n_gcm)
      Lx.create(n_gcm,n_gcm)
      Ly.create(n_gcm,n_gcm)
      Lz.create(n_gcm,n_gcm)
      .:get_da_gcm_now(SOx,Lx,m_out)  

      A.to_product_of(YU,Lx,transpose_a=TRUE)
      Lx.to_product_of(A,YU)
      .:get_da_gcm_now(SOy,Ly,m_out)  
      A.to_product_of(YU,Ly,transpose_a=TRUE)
      Ly.to_product_of(A,YU)
      .:get_da_gcm_now(SOz,Lz,m_out)  
      A.to_product_of(YU,Lz,transpose_a=TRUE)
      Lz.to_product_of(A,YU)

      SOx.destroy
      SOy.destroy
      SOx.destroy

      sLx.create(n_gcm,n_gcm)
      sLy.create(n_gcm,n_gcm)
      sLz.create(n_gcm,n_gcm)

      c = SPEED_OF_LIGHT_AU

      A = ZERO
 
      do i = 1,n_gcm
 
         A(i,i)=((c*c + Ep(i))*(c*c + Ep(i)))/(c*P2(i)*c)
        
         do j = 1,n_gcm
        
            Lx(i,j)  = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) 
            Ly(i,j)  = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) 
            Lz(i,j)  = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) 
            sLx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c))/(Ep(i) + Ep(j))
            sLy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c))/(Ep(i) + Ep(j))
            sLz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c))/(Ep(i) + Ep(j))
        
         end

      end
 
      ! Add to T
      T = T - matmul(Lx, matmul(A,sLx)) 
      T = T - matmul(Ly, matmul(A,sLy)) 
      T = T - matmul(Lz, matmul(A,sLz)) 
      T = T - matmul(sLx,matmul(A,Lx))
      T = T - matmul(sLy,matmul(A,Ly))
      T = T - matmul(sLz,matmul(A,Lz))
 
      sLx.destroy
      sLy.destroy
      sLx.destroy
      Lx.destroy
      Ly.destroy
      Lx.destroy
 
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      A.destroy
      m_out.destroy

   end

! Called from .SCF

   make_DKH_matrices(H,Lx,Ly,Lz)
   ! the DKH with SO interaction  included
   ! only when the scf kind=gchf is involved 
      self :: IN
      H, Lx,Ly,Lz :: MAT{REAL}, OUT

      c :: REAL  
      i,j,n_gcm :: INT     
      SOx,SOy,SOz :: MAT{REAL}*
      sSOx,sSOy,sSOz :: MAT{REAL}*
      A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
      Cx,Cy,Cz :: MAT{REAL}*
      sZ,sPZP :: MAT{REAL}*
      F, M,buco :: MAT{REAL}* 
      mmm :: MAT{INT}* 
      P2,E,Ap :: VEC{REAL}*

      ! test
      mmm.create(.n_prim,.n_prim)
      .:get_n_gcm(mmm,n_gcm)
      mmm.destroy 

      if (abs(.n_prim-n_gcm)>0) then
         DIE(" contracted gaussians do not work for DKH at gchf level!")
      end if     
     
      S.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(S)

      Y.create(.n_prim,.n_prim)
      Y.to_inverse_sqrt_of(S)

      T.create(.n_prim,.n_prim)
      .:make_primitive_kinetic_matrix(T) 
     
      A.create(.n_prim,.n_prim)
      A.to_product_of(Y,T)   
      T.to_product_of(A,Y)              
      ! T=YTY  kinetic energy in an orthogonal basis
      U.create(.n_prim,.n_prim)
      P2.create(.n_prim)
      T.solve_symmetric_eigenproblem(P2,U)
      P2= TWO * P2
     
      Z.create(.n_prim,.n_prim)
      .:make_primitive_nuclear_matrix(Z)
     
      A.to_product_of(Y,Z) 
      Z.to_product_of(A,Y)             
      ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 
      A.to_product_of(U,Z,transpose_a=TRUE)
      Z.to_product_of(A,U)
     
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
     
      .:make_primitive_DKH_matrices(A,SOx,SOy,SOz) 

      ! lets move the matrices A,SOx,SOy,SOz into the orthonormal basis
      ! set 
      PZP.create(.n_prim,.n_prim)
      PZP = A
      A.to_product_of(Y,PZP)  
      PZP.to_product_of(A,Y)
      A.to_product_of(Y,SOx)  
      SOx.to_product_of(A,Y)
      A.to_product_of(Y,SOy)  
      SOy.to_product_of(A,Y)
      A.to_product_of(Y,SOz)  
      SOz.to_product_of(A,Y)
 
      ! lets move to the momentum space 
      A.to_product_of(U,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,U)
      A.to_product_of(U,SOx,transpose_a=TRUE)
      SOx.to_product_of(A,U)
      A.to_product_of(U,SOy,transpose_a=TRUE)
      SOy.to_product_of(A,U)
      A.to_product_of(U,SOz,transpose_a=TRUE)
      SOz.to_product_of(A,U)
 
      .BASE:put_debug(SOx,"SOx matrix YU")
      .BASE:put_debug(SOy,"SOy matrix YU")
      .BASE:put_debug(SOz,"SOz matrix YU")
 
      c = SPEED_OF_LIGHT_AU
 
      F.create(.n_prim,.n_prim)
      E.create(.n_prim)
      Ap.create(.n_prim)
 
      F = ZERO  
 
      do i = 1,.n_prim
         E(i)= c * sqrt(P2(i) + c * c)
         Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
         F(i,i)= E(i) - c * c
      end  
 
      B.create(.n_prim,.n_prim)
      Cx.create(.n_prim,.n_prim)
      Cy.create(.n_prim,.n_prim)
      Cz.create(.n_prim,.n_prim)
 
      do i=1,.n_prim
      do j=1,.n_prim
         A(i,j)  = Ap(i)*Z(i,j)*Ap(j)
         B(i,j)  = c*c*(Ap(i)/(E(i)+c*c))*PZP(i,j)*(Ap(j)/(E(j)+c*c))                                        
         Cx(i,j) = c*c*(Ap(i)/(E(i)+c*c))*SOx(i,j)*(Ap(j)/(E(j)+c*c))                                        
         Cy(i,j) = c*c*(Ap(i)/(E(i)+c*c))*SOy(i,j)*(Ap(j)/(E(j)+c*c))                                        
         Cz(i,j) = c*c*(Ap(i)/(E(i)+c*c))*SOz(i,j)*(Ap(j)/(E(j)+c*c))                                        
      end
      end
 
      Ap.destroy 
 
      Z   = A
      PZP = B
      SOx = Cx
      SOy = Cy
      SOz = Cz
      F   = F + Z + PZP
 
      A = ZERO  
      B = ZERO
 
      sZ.create(.n_prim,.n_prim)
      sPZP.create(.n_prim,.n_prim)
      sSOx.create(.n_prim,.n_prim)
      sSOy.create(.n_prim,.n_prim)
      sSOz.create(.n_prim,.n_prim)
 
      do i = 1,.n_prim
 
         B(i,i)=(c*P2(i)*c) / ( (c*c + E(i)) * (c*c + E(i)) )
         A(i,i)=ONE/B(i,i)
 
         do j = 1,.n_prim
            sZ(i,j)= Z(i,j) / ( E(i) + E(j) ) 
            sPZP(i,j)= PZP(i,j) / ( E(i) + E(j) ) 
            sSOx(i,j)= SOx(i,j) / ( E(i) + E(j) ) 
            sSOy(i,j)= SOy(i,j) / ( E(i) + E(j) ) 
            sSOz(i,j)= SOz(i,j) / ( E(i) + E(j) ) 
         end
 
      end
 
      P2.destroy
      E.destroy
 
      T =     matmul(Z, matmul(B,sZ) )
      T = T - matmul(PZP,sZ) 
      T = T - matmul(Z,sPZP) 
      T = T + matmul(PZP, matmul(A,sPZP) ) 
      T = T + matmul(sZ, matmul(B,Z) )
      T = T - matmul(sZ,PZP) 
      T = T - matmul(sPZP,Z) 
      T = T + matmul(sPZP, matmul(A,PZP) )
 
      if (.scfdata.using_SO_FDFF) then
 
         ! these are additional scalar terms due to presence of SO terms
         ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz 
         ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz) 
 
         T = T - matmul(SOx, matmul(A,sSOx) ) 
         T = T - matmul(SOy, matmul(A,sSOy) ) 
         T = T - matmul(SOz, matmul(A,sSOz) ) 
         T = T - matmul(sSOx, matmul(A,SOx) )
         T = T - matmul(sSOy, matmul(A,SOy) )
         T = T - matmul(sSOz, matmul(A,SOz) )
      end 
 
      T = (ONE/TWO) * T
      F = F + T
 
      ! lets build the DKH x-component SO matrix 
      T =   - matmul(SOx,sZ) 
      T = T - matmul(Z,sSOx) 
      T = T + matmul(SOx, matmul(A,sPZP) ) + matmul(PZP, matmul(A,sSOx) ) 
      T = T - matmul(sZ,SOx) 
      T = T - matmul(sSOx,Z) 
      T = T + matmul(sSOx, matmul(A,PZP) ) + matmul(sPZP, matmul(A,SOx) )
 
      if (.scfdata.using_SO_FDFF) then
         ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa x-component terms   
         T = T - matmul(SOy, matmul(A,sSOz) ) + matmul(SOz, matmul(A,sSOy) ) 
         T = T - matmul(sSOy, matmul(A,SOz) ) + matmul(sSOz, matmul(A,SOy) )
      end 
 
      ! SOx comes from the E1 hamiltonian counterpart of Ap*P*V*P*Ap scalar term
      T  = (ONE/TWO) * T
      Cx = T + SOx
 
      ! lets build the DKH y-component SO matrix 
      T =   - matmul(SOy,sZ) 
      T = T - matmul(Z,sSOy) 
      T = T + matmul(SOy, matmul(A,sPZP) ) + matmul(PZP, matmul(A,sSOy) ) 
      T = T - matmul(sZ,SOy) 
      T = T - matmul(sSOy,Z) 
      T = T + matmul(sSOy, matmul(A,PZP) ) + matmul(sPZP, matmul(A,SOy) )
 
      if(.scfdata.using_SO_FDFF) then
         ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa y-component terms   
         T = T - matmul(SOz, matmul(A,sSOx) ) + matmul(SOx, matmul(A,sSOz) ) 
         T = T - matmul(sSOz, matmul(A,SOx) ) + matmul(sSOx, matmul(A,SOz) )
      end 
 
      ! SOy comes from the E1 hamiltonian counterpart of Ap*P*V*P*Ap scalar term
      T =  (ONE/TWO) * T
      Cy = T + SOy
 
      ! lets build the DKH z-component SO matrix 
      T =   - matmul(SOz,sZ) 
      T = T - matmul(Z,sSOz) 
      T = T + matmul(SOz, matmul(A,sPZP) ) + matmul(PZP, matmul(A,sSOz) ) 
      T = T - matmul(sZ,SOz) 
      T = T - matmul(sSOz,Z) 
      T = T + matmul(sSOz, matmul(A,PZP) ) + matmul(sPZP, matmul(A,SOz) )
 
      if (.scfdata.using_SO_FDFF) then
         ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa z-component terms   
         T = T - matmul(SOx, matmul(A,sSOy) ) + matmul(SOy, matmul(A,sSOx) ) 
         T = T - matmul(sSOx, matmul(A,SOy) ) + matmul(sSOy, matmul(A,SOx) )
      end
 
      ! SOz comes from the E1 hamiltonian counterpart of Ap*P*V*P*Ap scalar term
      T  =  (ONE/TWO) * T
      Cz = T + SOz
      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      sZ.destroy
      sPZP.destroy
      sSOx.destroy
      sSOy.destroy
      sSOz.destroy
 
      T.destroy
 
      A.to_product_of(S,Y)
      B.to_product_of(A,U)
 
      S.destroy
      Y.destroy
      U.destroy
 
      A.to_product_of(B,F)
      F.to_product_of(A,B,transpose_b=TRUE)
      A.to_product_of(B,Cx)
      Cx.to_product_of(A,B,transpose_b=TRUE)
      A.to_product_of(B,Cy)
      Cy.to_product_of(A,B,transpose_b=TRUE)
      A.to_product_of(B,Cz)
      Cz.to_product_of(A,B,transpose_b=TRUE)
 
      A.destroy
      B.destroy
 
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)
 
      buco.create(.n_bf,.n_prim)
      buco.to_product_of(M,F,transpose_a=TRUE)
      F.destroy
      A.create(.n_bf,.n_bf)
      A.to_product_of(buco,M)
      H = A
 
      buco.to_product_of(M,Cx,transpose_a=TRUE)
      Cx.destroy
      A.to_product_of(buco,M)
      Lx = A
 
      buco.to_product_of(M,Cy,transpose_a=TRUE)
      Cy.destroy
      A.to_product_of(buco,M)
      Ly = A
 
      buco.to_product_of(M,Cz,transpose_a=TRUE)
      Cz.destroy
      A.to_product_of(buco,M)
      Lz = A
 
      ! is this really necessary
      .BASE:put_debug(H, "make_DKH_matrices: H")
      .BASE:put_debug(Lx,"make_DKH_matrices: Lx")
      .BASE:put_debug(Ly,"make_DKH_matrices: Ly")
      .BASE:put_debug(Lz,"make_DKH_matrices: Lz")
 
      M.destroy
      buco.destroy
      A.destroy

   end

! Called from .MAIN

   make_DKH_density_norm
   !actually this routine does not work properly
   ! it has to be called in the stdin input
     g,ga,gb,norm,norma,normb :: REAL 
     MO,MOa,MOb :: MAT{REAL}*
     D,Da,Db :: MAT{REAL}*

     select case (.scfdata.scf_kind)

        case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")

           ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
           ENSURE(.spin_multiplicity==1,"this is not a singlet state")

           MO => .molecular_orbitals.restricted(:,1:.n_a)
           D  => .density_matrix.restricted
           D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

           .:density_DKH_norm(g,norm,D)

           stdout.flush
           stdout.text("renormalization check")
           stdout.flush
           stdout.text("summ  = ")
           stdout.put(g)
           stdout.flush
           stdout.text("norm  = ")
           stdout.put(norm)

        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

           ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")

           MOa => .molecular_orbitals.alpha(:,1:.n_a)
           MOb => .molecular_orbitals.beta(:,1:.n_b)
           Da => .density_matrix.alpha
           Db => .density_matrix.beta
           Da.to_product_of(MOa,MOa,transpose_b=TRUE)
           Db.to_product_of(MOb,MOb,transpose_b=TRUE)

           .:density_DKH_norm(ga,norma,Da)
           .:density_DKH_norm(gb,normb,Db)

           stdout.flush
           stdout.text("renormalization check")
           stdout.flush
           stdout.text("summ alpha  = ")
           stdout.put(ga)
           stdout.flush
           stdout.text("summ beta   = ")
           stdout.put(gb)
           stdout.flush
           stdout.text("summ total  = ")
           stdout.put(ga+gb)
           stdout.flush
           stdout.text("norm alpha  = ")
           stdout.put(norma)
           stdout.flush
           stdout.text("norm beta   = ")
           stdout.put(normb)
           stdout.flush
           stdout.text("norm total  = ")
           stdout.put(ONE/(ga+gb))
           stdout.flush

        case default
           DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))

     end

   end

   density_DKH_norm(g,norm,D) ::: private
   ! gives back g and norm the summ and the normalization
   ! constant which is false becasue the wave function is
   ! normalized to the number of electrons and not to unity
   ! in the moment it is so or so not used, but actually
   ! it might be necessary to renormalised due to the dkh transformation
   ! of the density which has to be normalised
      self :: IN
      g,norm :: REAL, OUT
      D :: MAT{REAL}, IN

      n_gcm,dim :: INT
      i,j :: INT
      m_out :: MAT{INT}* 
      YU,GG :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .:get_n_gcm(m_out,n_gcm)  

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .:make_DKH_mxs(YU,Ap,Ep,P2)

      select case (.scfdata.scf_kind)

         case("gchf")
            dim = 2*.n_bf
            GG.create(dim,dim)

         case default
            dim = .n_bf
            GG.create(dim,dim)
            .:make_DENSITY_norm(GG,YU,Ap,Ep,P2,m_out,n_gcm)
      end        

      g = ZERO

      do i=1,dim
      do j=1,dim
         g = g + D(i,j)*GG(i,j)
      end            
      end            

      norm= ONE / sqrt(g)    

      GG.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

   make_DENSITY_norm(D,YU,Ap,Ep,P2,m_out,n_gcm) ::: private
   ! correct the picture change
   ! this routine is based on the make_r_core_DKH_matrix(H) routine
      self :: IN
      D :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN
      Ap,Ep,P2 :: VEC{REAL}, IN
      m_out :: MAT{INT}, IN
      n_gcm :: INT, IN

      c :: REAL  
      i,j :: INT   
      R :: MAT{REAL}*  
      S,T,SS,Z,PZP,X :: MAT{REAL}*
      XX,WW,W2,sZ,sPZP,TX :: MAT{REAL}*
      Cx,Cy,Cz,SOx,SOy,SOz :: MAT{REAL}*
      A,B :: MAT{REAL}*
      M,buco :: MAT{REAL}* 

      !!!  The density matrix S  !!!
      R.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(R)

      ! put the S matrix into the n_gcm non-redundant space
      S.create(n_gcm,n_gcm)
      SS.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,S,m_out)  
      SS=S

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,S,transpose_a=TRUE)
      S.to_product_of(A,YU)

      !!!  the (YU)+ T YU MATRIX = Half*P2 diagonal !!!
      T.create(n_gcm,n_gcm)
      T = ZERO
      do i = 1,n_gcm
         T(i,i) = P2(i)
      end

      if (trim(.scfdata.scf_kind)=="gchf") then

         SOx.create(.n_bf,.n_bf)
         SOy.create(.n_bf,.n_bf)
         SOz.create(.n_bf,.n_bf)

         Cx.create(.n_prim,.n_prim)
         Cy.create(.n_prim,.n_prim)
         Cz.create(.n_prim,.n_prim)
         .:get_da_gcm_now(Cx,SOx,m_out)  
         .:get_da_gcm_now(Cy,SOy,m_out)  
         .:get_da_gcm_now(Cz,SOz,m_out)  
         Cx.destroy 
         Cy.destroy 
         Cz.destroy 

      end if 


      !!! A-O LETS GO !!!

      B.create(n_gcm,n_gcm) 

      c = SPEED_OF_LIGHT_AU

      do i=1,n_gcm
      do j=1,n_gcm
         A(i,j) = Ap(i)*S(i,j)*Ap(j)
         B(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*T(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
      end
      end

      S = A
      T = B

      if (trim(.scfdata.scf_kind)== "gchf") then
         do i=1,n_gcm
         do j=1,n_gcm
            SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
            SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
            SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         end
         end
      end

      if (.scfdata.DK1_PCE) then

         sZ.create(n_gcm,n_gcm) 
         sPZP.create(n_gcm,n_gcm) 
         .:make_DKH_mxs2(sZ,sPZP,YU)

         A = ZERO
         B = ZERO

         do i = 1,n_gcm
            B(i,i) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
            A(i,i) = ONE/B(i,i)
         end

         X.create(n_gcm,n_gcm)
         X =       matmul(sPZP, matmul(A,T) )
         X = X  -  matmul(sPZP,S)
         X = X  -  matmul(sZ,T)
         X = X  +  matmul(sZ, matmul(B,S) )
         X = X  +  matmul(S, matmul(B,sZ) )
         X = X  -  matmul(T,sZ)
         X = X  -  matmul(S,sPZP)
         X = X  +  matmul(T, matmul(A,sPZP) )

      end if

      if (.scfdata.DK2_PCE) then

         !!! W1W1
         WW.create(n_gcm,n_gcm)
         WW =      -  matmul(sZ, matmul(B,sZ) )
         WW =  WW  +  matmul(sPZP,sZ) 
         WW =  WW  +  matmul(sZ,sPZP) 
         WW =  WW  -  matmul(sPZP, matmul(A,sPZP) ) 
   
         XX.create(n_gcm,n_gcm)
         TX.create(n_gcm,n_gcm)

         XX = S + T
         TX = HALF*(matmul(WW,XX) + matmul(XX,WW))

         WW.destroy
   
         Z.create(n_gcm,n_gcm)
         PZP.create(n_gcm,n_gcm)
         XX.destroy
   
         do i = 1,n_gcm
         do j = 1,n_gcm
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
         end do
         end do
   
         TX = TX - matmul(sPZP,matmul(A,matmul(T,sZ)))
         TX = TX - matmul(sPZP,matmul(S,matmul(B,sZ)))
         TX = TX + matmul(sPZP,matmul(A, matmul(T, matmul(A,sPZP))))
         TX = TX + matmul(sPZP, matmul(S,sPZP))
         TX = TX + matmul(sZ,matmul(T,sZ))
         TX = TX + matmul(sZ,matmul(B, matmul(S, matmul(B,sZ))))
         TX = TX - matmul(sZ,matmul(T, matmul(A,sPZP)))
         TX = TX - matmul(sZ,matmul(B, matmul(S,sPZP)))

         !!!  The [W2,X(odd,0)] terms
         !   the second derivatives are not used

         W2.create(n_gcm,n_gcm)
         W2 =      matmul( sPZP, matmul(A, matmul(PZP,A) ) )
         W2 = W2 + matmul( sPZP, Z )
         W2 = W2 - matmul( sZ, ( matmul(PZP,A) ) )
         W2 = W2 - matmul( sZ, ( matmul(B,Z) ) )
         W2 = W2 - matmul( Z,  matmul(sPZP,A)  )
         W2 = W2 - matmul( PZP,  matmul(sPZP,A)  )
         W2 = W2 + matmul( Z,  sZ  )
         W2 = W2 + matmul( PZP,  sZ  )
         do i=1,n_gcm
         do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
         end do
         end do
        
         TX = TX + matmul(W2,T)
        
         W2 =      matmul( sZ, Z )
         W2 = W2 + matmul( sZ, PZP )
         W2 = W2 - matmul( matmul(A,sPZP), Z )
         W2 = W2 - matmul( matmul(A,sPZP), PZP )
         W2 = W2 - matmul( matmul(A,PZP)  ,   sZ)
         W2 = W2 - matmul( matmul(Z,B)  ,   sZ)
         W2 = W2 + matmul( matmul(A,matmul(PZP,A)) , sPZP)
         W2 = W2 + matmul( Z , sPZP)
         do i = 1,n_gcm
         do j = 1,n_gcm
             W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
         end do
         end do
        
         TX = TX + matmul(T,W2)

         ! Bug below? -- dylan
        
         W2 =    - matmul( matmul(B,sZ), Z )
         W2 = W2 - matmul( matmul(B,sZ), PZP )
         W2 = W2 + matmul( sPZP  ,   Z )
         W2 = W2 + matmul( sPZP  , PZP )
         W2 = W2 + matmul( PZP   ,  sZ )
         W2 = W2 + matmul( matmul(B,matmul(Z,B)) , sZ)
         W2 = W2 - matmul( matmul(PZP,A) , sPZP )
         W2 = W2 - matmul( matmul(B,Z) , sPZP )
         do i = 1,n_gcm
         do j = 1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
         end do
         end do
        
         TX = TX + matmul(S,W2)
        
         W2 =    - matmul( sPZP  , matmul(A,PZP) )
         W2 = W2 - matmul( sPZP  , matmul(Z,B) )
         W2 = W2 + matmul( sZ    , PZP)
         W2 = W2 + matmul( sZ    , matmul( B, matmul(Z,B) ) )
         W2 = W2 + matmul( Z , sPZP  )
         W2 = W2 + matmul( PZP , sPZP  )
         W2 = W2 - matmul( Z ,  matmul(sZ,B) )
         W2 = W2 - matmul( PZP ,  matmul(sZ,B) )
         do i = 1,n_gcm
         do j = 1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
         end do
         end do
        
        
         TX = TX + matmul(W2,S)

         W2.destroy
         Z.destroy
         PZP.destroy

      end if

      S = S + T
      T.destroy

      if (.scfdata.DK1_PCE) then
         S = S + X
         X.destroy
      end if   

      if (.scfdata.DK2_PCE) then
         S = S + TX
         TX.destroy
      end if

     B.to_product_of(SS,YU)
     A.to_product_of(B,S)
     S.to_product_of(A,B,transpose_b=TRUE)

     if (trim(.scfdata.scf_kind)=="gchf") then
        A.to_product_of(B,SOx)
        SOx.to_product_of(A,B,transpose_b=TRUE)
        A.to_product_of(B,SOy)
        SOy.to_product_of(A,B,transpose_b=TRUE)
        A.to_product_of(B,SOz)
        SOz.to_product_of(A,B,transpose_b=TRUE)
     end

     A.destroy
     B.destroy

     !!! moving back to tonto style primitive basis sets 
     ! put the Fock matrix back to the space .n_prim space
     .:get_back_prim_now(S,R,m_out)  
     S.destroy

     !!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .BASE:make_normalised_contraction_mx(M)

     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     A.create(.n_bf,.n_bf)
     A.to_product_of(buco,M)

     if (trim(.scfdata.scf_kind)== "gchf") then

        D = ZERO ! I added this --dylan
        D.alpha_alpha_plus(A)
        D.beta_beta_plus(A)

        ! What is this for? --dylan
        .:get_back_prim_now(SOx,R,m_out) 
        SOx.destroy
        buco.to_product_of(M,R,transpose_a=TRUE)
        A.to_product_of(buco,M)

        .:get_back_prim_now(SOy,R,m_out)  
        SOy.destroy
        buco.to_product_of(M,R,transpose_a=TRUE)
        A.to_product_of(buco,M)

        .:get_back_prim_now(SOy,R,m_out)  
        SOz.destroy
        buco.to_product_of(M,R,transpose_a=TRUE)
        A.to_product_of(buco,M)
     
     else

        D = A

     end

     A.destroy
     R.destroy
     M.destroy
     buco.destroy
     SS.destroy
     sZ.destroy
     sPZP.destroy

   end

!  ==========================
!  mxs routines ... what for?
!  ==========================

   make_DKH_mxs(YU,Ap,Ep,P2)
   ! things necessary for the DKH transformation 
   ! within the PCE and the dkh_norm staff
      self :: IN
      YU :: MAT{REAL}, OUT
      P2,Ap,Ep :: VEC{REAL}, OUT
     
      m_out :: MAT{INT}* 
      i,n_gcm :: INT
      c :: REAL
      R,S,Y,U :: MAT{REAL}*
     
      m_out.create(.n_prim,.n_prim)
      .:get_n_gcm(m_out,n_gcm)
     
      !!!  OVERLAP ENERGY MATRIX  !!!
      R.create(.n_prim,.n_prim)
      .:make_primitive_overlap_matrix(R)
     
      S.create(n_gcm,n_gcm)
      .:get_da_gcm_now(R,S,m_out)  
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)
     
      !!!  KINETIC ENERGY MATRIX  !!!
      .:make_primitive_kinetic_matrix(R) 
      .:get_da_gcm_now(R,S,m_out)  
      m_out.destroy
      R.destroy
     
      U.create(n_gcm,n_gcm)
      U.to_product_of(Y,S)   
      S.to_product_of(U,Y)   
      S.solve_symmetric_eigenproblem(P2,U)
      S.destroy
      P2 = TWO * P2
     
      c = SPEED_OF_LIGHT_AU

      do i = 1,n_gcm
         Ep(i) = c * sqrt(P2(i) + c * c)
         Ap(i) = sqrt( (Ep(i) + c * c)/(TWO * Ep(i)) )  
      end  
     
      YU.to_product_of(Y,U)
     
      Y.destroy
      U.destroy

   end

   make_DKH_mxs2(Z,PZP,YU)
   ! get the Z and PZP matrix 
   ! which are in the momentum space
      self :: IN
      Z,PZP :: MAT{REAL}, OUT
      YU :: MAT{REAL} , IN

      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      R,SOx,SOy,SOz,A,X :: MAT{REAL}*
      c :: REAL
      Ep,P2,Ap :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .:get_n_gcm(m_out,n_gcm)

      !!!  Z MATRIX  !!!
      R.create(.n_prim,.n_prim)
      .:make_primitive_nuclear_matrix(R)
      .:get_da_gcm_now(R,Z,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)
 
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)

      !!!  PZP MATRIX  !!!
      .:make_primitive_DKH_matrices(R,SOx,SOy,SOz) 
      SOx.destroy
      SOy.destroy
      SOx.destroy

      .:get_da_gcm_now(R,PZP,m_out) 

      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)

      X.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .:make_DKH_mxs(X,Ap,Ep,P2)
 
      c = SPEED_OF_LIGHT_AU

      ! Make Z and PZP
      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
      end
      end
 
      X.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      R.destroy
      A.destroy
      m_out.destroy

   end

   make_DKH_mxs4(PPZPP,YU)
   ! get the Z and PZP matrix 
   !  which are in the momentum space
      self :: IN
      PPZPP :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN

      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      R,A,X :: MAT{REAL}*
      c :: REAL
      Ep,P2,Ap :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .:get_n_gcm(m_out,n_gcm)

      !!!  PPZPP MATRIX  !!!
      R.create(.n_prim,.n_prim)
      .:make_primitive_DK3_ppZpp_mx(R)
      .:get_da_gcm_now(R,PPZPP,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,PPZPP,transpose_a=TRUE)
      PPZPP.to_product_of(A,YU)
 
      X.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .:make_DKH_mxs(X,Ap,Ep,P2)
 
      c = SPEED_OF_LIGHT_AU

      ! Make PPZPP
      do i=1,n_gcm
      do j=1,n_gcm
         PPZPP(i,j) = c**4*(Ap(i)/(Ep(i)+c*c)**2)*PPZPP(i,j)*(Ap(j)/(Ep(j)+c*c)**2) 
      end
      end
 
      X.destroy
      Ap.destroy
      Ep.destroy
      R.destroy
      A.destroy
      m_out.destroy
      P2.destroy

   end

! ====
! IOTC
! ====

!   make_S_Y(S,Y) ::: private
!   ! ? Why isn't this routine used more often?
!      self :: IN
!      S,Y :: MAT{REAL}, OUT
!
!      R :: MAT{REAL}*
!      m_out :: MAT{INT}*
!      n_gcm :: INT
!
!      R.create(.n_prim,.n_prim)
!      .:make_primitive_overlap_matrix(R)
!
!      m_out.create(.n_prim,.n_prim) 
!      .:make_ready_da_gcm_tr2(m_out,n_gcm) 
!      ! put the overlap matrix into the n_gcm non-redundant space
!      .:get_da_gcm_now(R,S,m_out)  
!      Y.to_inverse_sqrt_of(S)
! 
!      m_out.destroy
!      R.destroy
!
!   end

!   make_U_P2(U,P2,Y) ::: private
!   ! ? Make the eigenvectors "U" of the "P2" operator given the
!   ! inverse overlap matrix "Y". All in the primitive basis.
!   ! Why not used more often? --dylan
!      self :: IN
!      U :: MAT{REAL}, OUT
!      P2 :: VEC{REAL}, OUT
!      Y :: MAT{REAL}, IN
!
!      R,T,A :: MAT{REAL}*
!      m_out :: MAT{INT}*
!      n_gcm :: INT
!
!      R.create(.n_prim,.n_prim)
!      .:make_primitive_kinetic_matrix(R) 
!
!      m_out.create(.n_prim,.n_prim) 
!      .:make_ready_da_gcm_tr2(m_out,n_gcm) 
!
!      ! put the kinetic energy matrix into the n_gcm non-redundant space
!      T.create(n_gcm,n_gcm)
!      .:get_da_gcm_now(R,T,m_out)  
! 
!      ! T=YTY  kinetic energy in an orthogonal basis
!      A.create(n_gcm,n_gcm)
!      A.to_product_of(Y,T)   
!      T.to_product_of(A,Y)              
!      T.solve_eigenproblem(P2,U)
!      ! the momentum squared instead of kinetic energy
!      P2 = TWO * P2
! 
!      A.destroy
!      T.destroy
!      m_out.destroy
!      R.destroy
!
!   end

   find_da_Y_iterative(Y,PZP,Z,p,b,ep)
   ! the iterative solution of the Y matrix for IOTC
      self :: IN
      Y :: MAT{REAL}, OUT
      PZP,Z :: MAT{REAL}, IN
      p,b,ep :: VEC{REAL}, IN

      i,j,n_gcm,n :: INT
      fine :: BIN
      THRESH,THRESH2,XXX,val :: REAL
      Y0,dY :: MAT{REAL}*
      m_out :: MAT{INT}*

      fine    = FALSE
      THRESH  = TOL(9) ! Why different to above?
      THRESH2 = TOL(5)
  
      m_out.create(.n_prim,.n_prim) 
      .:make_ready_da_gcm_tr2(m_out,n_gcm)  
      m_out.destroy

      Y0.create(n_gcm,n_gcm) 
      dY.create(n_gcm,n_gcm) 

      Y0 = ZERO
      dY = ZERO

      ! Iteration
      n = 0
  
      do
   
         ! Iteration
         n = n + 1

         if (fine) exit

         MOLECULE.REL:build_da_Y(Y,Y0,PZP,Z,p,b,ep,n_gcm)

         dY = Y - Y0
         Y0 = Y

         ! Convergence check  
         ! Why not use maxval()?
         XXX = ZERO

         do i = 1,n_gcm
         do j = 1,n_gcm
             if (abs(Y0(i,j))<TOL(12)) cycle
             val = dY(i,j)/Y0(i,j) 
             if (abs(val)>XXX) XXX = abs(val)
         end do
         end do
   
         ! Output if converged
         if (XXX<THRESH) then        
            fine = TRUE       
            stdout.flush    
            stdout.flush    
            stdout.text("The Y has converged")      
            stdout.show("The number of iterations = ",n,dots=FALSE)         
            stdout.flush    
         end if    
            
         if (n>80 AND XXX<THRESH2) then    
            fine = TRUE       
            stdout.text("The Y has converged only to THRESH2")  
            stdout.show("The number of iterations = ",n,dots=FALSE)         
            stdout.put(n)   
            stdout.flush    
         end if
   
         if (n>80 AND XXX>THRESH2) then
            stdout.flush
            stdout.text("The Y has not converged.") 
            DIE("Exceeded the number of iterations (n_max=200) uuups !!!")
         end if
  
      end do
  
      Y0.destroy
      dY.destroy

   end

   find_da_Y_iterative(Y,PZP,Z,p,b,ep)
   ! the iterative solution of the Y matrix for IOTC
   ! NOTE: this version requires Yr input initially? --dylan
      self :: IN
      Y :: MAT{CPX}, INOUT
      PZP,Z :: MAT{CPX}, IN
      p,b,ep :: VEC{REAL}, IN

      i,j,n_gcm,n :: INT
      fine :: BIN
      THRESH,THRESH2,XXX,YYY,val :: REAL
      Y0,dY :: MAT{CPX}*
      m_out :: MAT{INT}*

      fine    = FALSE
      THRESH  = TOL(8)
      THRESH2 = TOL(5)

      m_out.create(.n_prim,.n_prim) 
      .:make_ready_da_gcm_tr2(m_out,n_gcm)  
      m_out.destroy

      Y0.create(2*n_gcm,2*n_gcm)
      dY.create(2*n_gcm,2*n_gcm) 
      Y0 = Y
      dY = (ZERO,ZERO)
  
      ! Iteration
      n = 0

      do
   
         n = n + 1

         MOLECULE.REL:build_da_Y_2(Y,Y0,PZP,Z,p,b,ep,n_gcm)

         dY = Y - Y0
         Y0 = Y

         ! Convergence check  
         XXX = ZERO
         YYY = ZERO

         ! Why is the convergence check done separately on the real
         ! and imaginary parts??? --dylan
         do i = 1,2*n_gcm
         do j = 1,2*n_gcm

             if (abs(real(Y0(i,j)))>TOL(12)) then 
                val = real(dY(i,j))/real(Y0(i,j)) 
                if (abs(val)>XXX) then
                  XXX = abs(val)
                end if   
             end if   

             ! Why is this convergence higher than above??? --dylan
             if ( abs(aimag(Y0(i,j)))> TOL(13)) then
                val = aimag(dY(i,j))/aimag(Y0(i,j)) 
                if (abs(val)>YYY) then 
                   YYY = abs(val)
                end if
             end if

         end do
         end do
   
         ! Output if converged or not
         if (XXX<THRESH) then        
            fine = TRUE       
            stdout.flush    
            stdout.flush    
            stdout.text("The Y has converged")      
            stdout.show("The number of iterations = ",n,dots=FALSE)         
            stdout.flush    
         end if    
            
         ! Apparently this is OK?? --dylan
         if (n>80 AND XXX < THRESH2) then    
            fine = TRUE       
            stdout.text("The Y has converged only to THRESH2")  
            stdout.show("The number of iterations = ",n,dots=FALSE)         
            stdout.put(n)   
            stdout.flush    
         end if
   
         if (n>80 AND ((XXX>THRESH2) OR (YYY>THRESH2))) then
            stdout.flush
            stdout.text("The Y has not converged.") 
            DIE("Exceeded the number of iterations (n_max=200) uuups !!!")
         end if

         if (fine) exit
  
      end do
  
      Y0.destroy
      dY.destroy

   end

   build_da_Y_2(Y,Yr0,PAP,A,p,b,ep,n_gcm) ::: selfless, private
   ! build the IOTC Y matrix, complex version
      Y :: MAT{CPX}, OUT
      Yr0,PAP,A :: MAT{CPX}, IN
      p,b,ep :: VEC{REAL}, IN
      n_gcm :: INT, IN

      i,j,dim :: INT
      c,alpha,alpha2,alpha3,alpha4 :: REAL
      Y1L,Y1R,Y2 :: MAT{CPX}*

      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
      alpha3 = alpha2*alpha
      alpha4 = alpha3*alpha
 
      dim = 2*n_gcm
 
      Y1L.create(dim,dim)
      Y1R.create(dim,dim)
       Y2.create(dim,dim)
 
      do i = 1,dim
      do j = 1,dim
          Y(i,j)  =  alpha3 * (p(i)*b(i)*A(i,j) - PAP(i,j)/p(i)*b(j))  
         Y1L(i,j) = -alpha2 * A(i,j) - alpha4 * b(i)*PAP(i,j)*b(j) 
         Y1R(i,j) =  alpha2 * PAP(i,j)/p(i)/p(j) + alpha4*p(i)*b(i)*A(i,j)*b(j)*p(j)
          Y2(i,j) =  alpha3 * (b(i)*PAP(i,j)/p(j) - A(i,j)*b(j)*p(j))
      end do
      end do


      Y.plus_product_of(Yr0,Y1L)
      Y.plus_product_of(Y1R,Yr0)
      Y1L=(ZERO,ZERO)
      Y1L.to_product_of(Y2,Yr0)
      Y2=(ZERO,ZERO)
      Y2.to_product_of(Yr0,Y1L)
      ! this is wrong it is non symetric
!      Y2.change_basis_using(Yr0)
      Y.plus(Y2)
 
      ! Avoid matmul for precision -- dylan
    ! Y = Y + matmul(Yr0,Y1L) + matmul(Y1R,Yr0) + matmul(Yr0,matmul(Y2,Yr0))
 
      do i = 1,dim
      do j = 1,dim
         Y(i,j) = Y(i,j) / ( ep(i)+ep(j) )
      end do
      end do
 
      Y1L.destroy
      Y1R.destroy
      Y2.destroy

   end

   build_da_Y(Y,Yr0,PZP,Z,p,b,ep,n_gcm) ::: selfless, private
   ! build the IOTC Y matrix, real version 
      Y :: MAT{REAL}, OUT
      Yr0,PZP,Z :: MAT{REAL}, IN
      p,b,ep :: VEC{REAL}, IN
      n_gcm :: INT, IN

      i,j :: INT
      c,alpha,alpha2,alpha3,alpha4 :: REAL
      Y1L,Y1R,Y2 :: MAT{REAL}*

      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
      alpha3 = alpha2*alpha
      alpha4 = alpha3*alpha
 
      Y1L.create(n_gcm,n_gcm)
      Y1R.create(n_gcm,n_gcm)
       Y2.create(n_gcm,n_gcm)
 
      do i = 1,n_gcm
      do j = 1,n_gcm
           Y(i,j) =  alpha3 * (p(i)*b(i)*Z(i,j) - PZP(i,j)/p(i)*b(j))  
         Y1L(i,j) = -alpha2 * Z(i,j) - alpha4 * b(i)*PZP(i,j)*b(j) 
         Y1R(i,j) =  alpha2 * PZP(i,j)/p(i)/p(j) + alpha4*p(i)*b(i)*Z(i,j)*b(j)*p(j) 
          Y2(i,j) =  alpha3 * (b(i)*PZP(i,j)/p(j) - Z(i,j)*b(j)*p(j))
      end do
      end do
 
   ! Yr0 is asymetric
   ! Warning: assumes Yr0 symmetric --dylan
   !   Y2.change_basis_using(Yr0) ! do not do this --lukas

      Y.plus_product_of(Yr0,Y1L)
      Y.plus_product_of(Y1R,Yr0)
      Y1L=ZERO
      Y1L.to_product_of(Y2,Yr0)
      Y2=ZERO
      Y2.to_product_of(Yr0,Y1L)
      Y.plus(Y2)

      ! Avoid matmul for precision --dylan
   ! Y = Y + matmul(Yr0,Y1L) + matmul(Y1R,Yr0) + matmul(Yr0,matmul(Y2,Yr0))
 
      do i = 1,n_gcm
      do j = 1,n_gcm
         Y(i,j) = Y(i,j)/(ep(i)+ep(j))
      end do
      end do
 
      Y1L.destroy
      Y1R.destroy
      Y2.destroy

   end

   build_da_IOTC_F(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)
   ! build the IOTC Y matrix, real version
      self :: IN
      F :: MAT{REAL}, OUT
      Yr,PAP,A :: MAT{REAL}, IN
      p,bp,E :: VEC{REAL}, IN
      n_gcm :: INT, IN
      ppApp :: MAT{REAL}, optional, IN

      i,j :: INT
      c,alpha,alpha2 :: REAL
      F1L,F1R,F2,AAA :: MAT{REAL}*

      c = SPEED_OF_LIGHT_AU
      alpha = ONE/c
      alpha2= alpha*alpha

      F1L.create(n_gcm,n_gcm)
      F1R.create(n_gcm,n_gcm)
       F2.create(n_gcm,n_gcm)
      AAA.create(n_gcm,n_gcm)

      if (.scfdata.using_ppzpp) then

         DIE_IF(NOT present(ppApp),"wtf?")

         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
         end do
         end do

      else

         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j) = alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do

      end

      F  = ZERO
      F2 = ZERO

      do i = 1,n_gcm
         F(i,i)  =  E(i)-c*c 
         F2(i,i) = -E(i)-c*c  
         do j = 1,n_gcm
            F(i,j)   =  F(i,j) + A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
            F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
            F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
            F2(i,j)  =  F2(i,j)+ PAP(i,j)/p(j)/p(i) + AAA(i,j)
         end do
      end do

      F2.change_basis_using(Yr)

      F.plus_product_of( Yr,F1L,transpose_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)

      ! Avoid matmul
    ! F = F + matmul(transpose(Yr),F1L) 
    ! F = F + matmul(F1R,Yr)
    ! F = F + matmul(transpose(Yr),matmul(F2,Yr))

      AAA.destroy     
       F2.destroy
      F1R.destroy
      F1L.destroy

   end

   build_da_IOTC_F(F,Yr,PAP,A,p,bp,E,ppApp)
   ! build the IOTC Y matrix, complex version`
      self :: IN
      F :: MAT{CPX}, OUT
      Yr,PAP,A :: MAT{CPX}, IN
      p,bp,E :: VEC{REAL}, IN
      ppApp :: MAT{CPX}, optional, IN

      i,j,n_gcm,dim :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{CPX}*

      n_gcm  = .n_prim ! Why is n_gcm set like this here? --dylan
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha

      dim = 2*n_gcm

      F1L.create(dim,dim)
      F1R.create(dim,dim)
       F2.create(dim,dim)
      AAA.create(dim,dim)

      if( .scfdata.using_ppzpp)then

         DIE_IF(NOT present(ppApp),"wtf?")

         do i = 1,dim
         do j = 1,dim
            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
         end do
         end do

      else

         do i = 1,dim
         do j = 1,dim
            AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do

      end

      F  = ZERO
      F2 = ZERO

      do i = 1,dim
         F(i,i)  =  E(i)-c*c     
         F2(i,i) = -E(i)-c*c     
         do j = 1,dim
            F(i,j)   =  F(i,j) + A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
            F1L(i,j) = alpha * (bp(i)*p(i)*A(i,j)- PAP(i,j)/p(i)*bp(j))         
            F1R(i,j) = alpha * (A(i,j)*bp(j)*p(j)- bp(i)*PAP(i,j)/p(j))
            F2(i,j)  = F2(i,j) + PAP(i,j)/p(j)/p(i) + AAA(i,j)
         end do
      end do

      F2.change_basis_using(Yr)

      F.plus_product_of( Yr,F1L,dagger_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)

      ! Avoid matmul --dylan
    ! AAA.to_product_of(Yr,F1L,dagger_a=TRUE)
    ! F = F + AAA + matmul(F1R,Yr)
    ! AAA.to_product_of(Yr,F2,dagger_a=TRUE)
    ! F = F + matmul(AAA,Yr)

      AAA.destroy     
       F2.destroy
      F1R.destroy
      F1L.destroy

   end

!  ======================================
!  Primitive density/integral evaluations
!  ======================================

   make_primitive_density_matrix(D,x,y,z)
   ! Calculate the primitive density matrix "D" at x,y,z coors
      self :: IN
      D :: MAT{REAL}, OUT
      x,y,z :: REAL, IN

   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.is_square, "S must be square")
   ENSURE(D.dim1==.n_prim, "wrong size, S")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2
 
      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitive shells
      nps = frst.dim
 
      ! Calculate the primitive integrals

      do a = 1,nps

         G.a.set_l(l(a))
         G.a.set_position(.atom(at(a)).position)
         G.a.set_exponent(ex(a))
         fa = frst(a)
         la = last(a)

         do b = 1,a

            G.b.set_l(l(b))
            G.b.set_position(.atom(at(b)).position)
            G.b.set_exponent(ex(b))
            fb = frst(b)
            lb = last(b)

            G.make_normalised_density_gg(D(fa:la,fb:lb),x,y,z,.use_spherical_basis)

         end

      end
 
      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy
 
      ! Make a symmetric matrix
      D.symmetric_reflect

   end

   make_primitive_pDp_matrix(T,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
      self :: IN
      T :: MAT{REAL}, OUT
      x,y,z :: REAL, IN
 
    ENSURE(.atom.associated,  "no atom list")
    ENSURE(.basis_info_made, "no basis info")
    ENSURE(T.is_square, "T must be square")
    ENSURE(T.dim1==.n_prim, "wrong size, T")
 
      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2
 
      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primtive shells
      nps = frst.dim
 
      ! Calculate the primitive integrals
      do a = 1,nps

         G.a.set_l(l(a))
         G.a.set_position(.atom(at(a)).position)
         G.a.set_exponent(ex(a))
         fa = frst(a)
         la = last(a)

         do b = 1,a

            G.b.set_l(l(b))
            G.b.set_position(.atom(at(b)).position)
            G.b.set_exponent(ex(b))
            fb = frst(b)
            lb = last(b)

            G.make_normalised_pDp_gg(T(fa:la,fb:lb),x,y,z,.use_spherical_basis)

         end

      end
 
      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy
 
      ! Make a symmetric matrix
      T.symmetric_reflect

      .BASE:put_debug(T,"make_primitive_pDp_matrix: T")

   end

   make_primitive_ppDpp_matrix(T,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
      self :: IN
      T :: MAT{REAL}, OUT
      x,y,z :: REAL, IN
 
    ENSURE(.atom.associated,  "no atom list")
    ENSURE(.basis_info_made, "no basis info")
    ENSURE(T.is_square, "T must be square")
    ENSURE(T.dim1==.n_prim, "wrong size, T")
 
      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2
 
      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitive shells
      nps = frst.dim
 
      ! Calculate the primitive integrals
      do a = 1,nps

         G.a.set_l(l(a))
         G.a.set_position(.atom(at(a)).position)
         G.a.set_exponent(ex(a))
         fa = frst(a)
         la = last(a)

         do b = 1,a

            G.b.set_l(l(b))
            G.b.set_position(.atom(at(b)).position)
            G.b.set_exponent(ex(b))
            fb = frst(b)
            lb = last(b)

            G.make_normalised_ppDpp_gg(T(fa:la,fb:lb),x,y,z,.use_spherical_basis)

         end

      end

 
      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy
 
      ! Make a symmetric matrix
      T.symmetric_reflect

      .BASE:put_debug(T,"make_primitive_ppDpp_matrix: T")

   end

   make_primitive_pppDp_matrix(T,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     T :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_pppDp_gg(T(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     T.symmetric_reflect
     .BASE:put_debug(T,"make_primitive_ppDpp_matrix: T")

   end

   make_primitive_pDppp_matrix(T,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     T :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_pDppp_gg(T(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     T.symmetric_reflect
     .BASE:put_debug(T,"make_primitive_ppDpp_matrix: T")

   end

   make_primitive_ppDpp_SO_matrix(Dx,Dy,Dz,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     Dx,Dy,Dz :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(Dx.is_square, "density SOx must be square")
   ENSURE(Dx.dim1==.n_prim, "wrong size, density SOx")
   ENSURE(Dy.is_square, "density SOy must be square")
   ENSURE(Dy.dim1==.n_prim, "wrong size, density SOy")
   ENSURE(Dz.is_square, "density SOz must be square")
   ENSURE(Dz.dim1==.n_prim, "wrong size, density SOz")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_ppDpp_SO_gg(Dx(fa:la,fb:lb),Dy(fa:la,fb:lb),Dz(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     Dx.antisymmetric_reflect
     Dy.antisymmetric_reflect
     Dz.antisymmetric_reflect
     .BASE:put_debug(Dx,"make_primitive_pDp_SO_matrix: Dx")
     .BASE:put_debug(Dy,"make_primitive_pDp_SO_matrix: Dy")
     .BASE:put_debug(Dz,"make_primitive_pDp_SO_matrix: Dz")

   end

   make_primitive_pppDp_SO_matrix(Dx,Dy,Dz,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     Dx,Dy,Dz :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(Dx.is_square, "density SOx must be square")
   ENSURE(Dx.dim1==.n_prim, "wrong size, density SOx")
   ENSURE(Dy.is_square, "density SOy must be square")
   ENSURE(Dy.dim1==.n_prim, "wrong size, density SOy")
   ENSURE(Dz.is_square, "density SOz must be square")
   ENSURE(Dz.dim1==.n_prim, "wrong size, density SOz")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_pppDp_SO_gg(Dx(fa:la,fb:lb),Dy(fa:la,fb:lb),Dz(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     Dx.antisymmetric_reflect
     Dy.antisymmetric_reflect
     Dz.antisymmetric_reflect
     .BASE:put_debug(Dx,"make_primitive_pDp_SO_matrix: Dx")
     .BASE:put_debug(Dy,"make_primitive_pDp_SO_matrix: Dy")
     .BASE:put_debug(Dz,"make_primitive_pDp_SO_matrix: Dz")

   end

   make_primitive_pDppp_SO_matrix(Dx,Dy,Dz,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     Dx,Dy,Dz :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(Dx.is_square, "density SOx must be square")
   ENSURE(Dx.dim1==.n_prim, "wrong size, density SOx")
   ENSURE(Dy.is_square, "density SOy must be square")
   ENSURE(Dy.dim1==.n_prim, "wrong size, density SOy")
   ENSURE(Dz.is_square, "density SOz must be square")
   ENSURE(Dz.dim1==.n_prim, "wrong size, density SOz")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_pDppp_SO_gg(Dx(fa:la,fb:lb),Dy(fa:la,fb:lb),Dz(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     Dx.antisymmetric_reflect
     Dy.antisymmetric_reflect
     Dz.antisymmetric_reflect
     .BASE:put_debug(Dx,"make_primitive_pDp_SO_matrix: Dx")
     .BASE:put_debug(Dy,"make_primitive_pDp_SO_matrix: Dy")
     .BASE:put_debug(Dz,"make_primitive_pDp_SO_matrix: Dz")

   end

   make_primitive_pDp_SO_matrix(Dx,Dy,Dz,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
      self :: IN
      Dx,Dy,Dz :: MAT{REAL}, OUT
      x,y,z :: REAL, IN
 
    ENSURE(.atom.associated,  "no atom list")
    ENSURE(.basis_info_made, "no basis info")
    ENSURE(Dx.is_square, "density SOx must be square")
    ENSURE(Dx.dim1==.n_prim, "wrong size, density SOx")
    ENSURE(Dy.is_square, "density SOy must be square")
    ENSURE(Dy.dim1==.n_prim, "wrong size, density SOy")
    ENSURE(Dz.is_square, "density SOz must be square")
    ENSURE(Dz.dim1==.n_prim, "wrong size, density SOz")
 
      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2
 
      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! No. of primitve shells
      nps = frst.dim
 
      ! Calculate the primitive integrals
      do a = 1,nps

         G.a.set_l(l(a))
         G.a.set_position(.atom(at(a)).position)
         G.a.set_exponent(ex(a))
         fa = frst(a)
         la = last(a)

         do b = 1,a

            G.b.set_l(l(b))
            G.b.set_position(.atom(at(b)).position)
            G.b.set_exponent(ex(b))
            fb = frst(b)
            lb = last(b)

            G.make_normalised_pDp_SO_gg(Dx(fa:la,fb:lb),Dy(fa:la,fb:lb),Dz(fa:la,fb:lb),x,y,z,.use_spherical_basis)

         end
      
      end
 
      ! Clean up indexing arrays
      ex.destroy
      l.destroy
      at.destroy
      last.destroy
      frst.destroy
 
      ! Make a symmetric matrix
      Dx.antisymmetric_reflect
      Dy.antisymmetric_reflect
      Dz.antisymmetric_reflect

      .BASE:put_debug(Dx,"make_primitive_pDp_SO_matrix: Dx")
      .BASE:put_debug(Dy,"make_primitive_pDp_SO_matrix: Dy")
      .BASE:put_debug(Dz,"make_primitive_pDp_SO_matrix: Dz")

   end

   make_primitive_pgpg_matrix(grid,x,y,z)
   ! Calculate the primitive ft matrix for a given hkl
      grid :: MAT{REAL}
      x,y,z :: REAL, IN 
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.basis_info_made, "no basis info")
   ENSURE(grid.is_square, "ft must be square")
   ENSURE(grid.dim1==.n_prim, "wrong size, ft")
     
     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     grid_ab :: MAT{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

  !   ! Calculate the primitive integrals
     nps = frst.dim
     grid = ZERO
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           
            grid_ab.create(la-fa+1,lb-fb+1)
            grid_ab=ZERO
            
            G.make_normalised_pDp_gg(grid_ab,x,y,z,.use_spherical_basis) ! cleaner newer version

            !perhaps the thermal smearing should come after building
            !the whole sf-matrix
            grid(fa:la,fb:lb)=grid_ab
           
            grid_ab.destroy
           
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
      grid.symmetric_reflect
!    do a = 1,nps
!      p=real(ft(a,a))
!      ft(a,a)=(ZERO,ZERO)
!      ft(a,a)=p
!    end do 

     ! Make a hermitian matrix
 !     ft.make_hermitian

     ! Debug, turn on with debug_on "key"
     .BASE:put_debug(grid,  "make_primitive_pgpg_matrix: grid")

     ! Test
   ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

   make_primitive_p2gg_matrix(grid,x,y,z)
   ! Calculate the primitive ft matrix for a given hkl
      grid :: MAT{REAL}
      x,y,z :: REAL, IN 
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.basis_info_made, "no basis info")
   ENSURE(grid.is_square, "ft must be square")
   ENSURE(grid.dim1==.n_prim, "wrong size, ft")
     
     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     grid_ab :: MAT{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

  !   ! Calculate the primitive integrals
     nps = frst.dim
     grid = ZERO
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           
            grid_ab.create(la-fa+1,lb-fb+1)
            grid_ab=ZERO
            
            G.make_normalised_ppD_gg(grid_ab,x,y,z,.use_spherical_basis) ! cleaner newer version

            !perhaps the thermal smearing should come after building
            !the whole sf-matrix
            grid(fa:la,fb:lb)=grid_ab
           
            grid_ab.destroy
           
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
      grid.symmetric_reflect
!    do a = 1,nps
!      p=real(ft(a,a))
!      ft(a,a)=(ZERO,ZERO)
!      ft(a,a)=p
!    end do 

     ! Make a hermitian matrix
 !     ft.make_hermitian

     ! Debug, turn on with debug_on "key"
     .BASE:put_debug(grid,  "make_primitive_p2gg_matrix: grid")

     ! Test
   ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

   make_primitive_gp2g_matrix(grid,x,y,z)
   ! Calculate the primitive ft matrix for a given hkl
      grid :: MAT{REAL}
      x,y,z :: REAL, IN 
!   ENSURE(.atom.associated,  "no atom list")
!   ENSURE(.basis_info_made, "no basis info")
   ENSURE(grid.is_square, "ft must be square")
   ENSURE(grid.dim1==.n_prim, "wrong size, ft")
     
     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     grid_ab :: MAT{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

  !   ! Calculate the primitive integrals
     nps = frst.dim
     grid = ZERO
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           
            grid_ab.create(la-fa+1,lb-fb+1)
            grid_ab=ZERO
            
            G.make_normalised_Dpp_gg(grid_ab,x,y,z,.use_spherical_basis) ! cleaner newer version

            !perhaps the thermal smearing should come after building
            !the whole sf-matrix
            grid(fa:la,fb:lb)=grid_ab
           
            grid_ab.destroy
           
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
      grid.symmetric_reflect
!    do a = 1,nps
!      p=real(ft(a,a))
!      ft(a,a)=(ZERO,ZERO)
!      ft(a,a)=p
!    end do 

     ! Make a hermitian matrix
 !     ft.make_hermitian

     ! Debug, turn on with debug_on "key"
     .BASE:put_debug(grid,  "make_primitive_p2gg_matrix: grid")

     ! Test
   ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

!  =======================================
!  The finite nucleus integrals-properties
!  =======================================

   make_primitive_G_overlap_on_nuc(gg,c)
   ! Calculate the primitive overlap on Gaussian nucleus c
      gg :: MAT{REAL}
      c :: INT
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,neta :: INT
      G :: GAUSSIAN2
      atom :: ATOM*
      Zb :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)
     
      ! Calculate the primitive integrals
      nps = frst.dim
      Zb.create(.n_prim,.n_prim)
    !  
      select case (.nucleus_model)
         case ("finite","gaussian")
         atom => .atom(c)
         neta= atom.atomic_number 
         Zb = ZERO

      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1
           G.make_normalised_G_overlap_ints(Zb(fa:la,fb:lb),atom.position,neta,.use_spherical_basis)   
           end
        end

      Zb.symmetric_reflect

      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end

      gg=Zb

     Zb.destroy

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

   end

   make_primitive_pGp_overlap_on_nuc(gg,ggx,ggy,ggz,c)
   ! Calculate the primitive overlap on Gaussian nucleus c
      gg,ggx,ggy,ggz :: MAT{REAL}
      c :: INT
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")

      frst,last,at,l :: VEC{INT}*
      ex,ap :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,neta :: INT
      G :: GAUSSIAN2
      atom :: ATOM*
      d,dx,dy,dz :: MAT{REAL}*
      usb :: BIN

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)
     
      ! Calculate the primitive integrals
      nps = frst.dim
      usb = .use_spherical_basis
      select case (.nucleus_model)
         case ("finite","gaussian")
!      do c = 1,.n_atom
         ap.create(3)
         atom => .atom(c)
         neta= atom.atomic_number
         ap=atom.position
         gg = ZERO; ggx = ZERO; ggy = ZERO; ggz = ZERO 
      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1
           d.create(na,nb);dx.create(na,nb);dy.create(na,nb);dz.create(na,nb)
           d=ZERO;dx=ZERO;dy=ZERO;dz=ZERO
            G.make_normalised_pGp_overlap_ints(d,dx,dy,dz,ap,neta,usb)   
            gg(fa:la,fb:lb)=d
            ggx(fa:la,fb:lb)=dx
            ggy(fa:la,fb:lb)=dy
            ggz(fa:la,fb:lb)=dz
           d.destroy;dx.destroy;dy.destroy;dz.destroy
           end
        end

      gg.symmetric_reflect
      ggx.antisymmetric_reflect
      ggy.antisymmetric_reflect
      ggz.antisymmetric_reflect
!     end
      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy
      
      ap.destroy
   end

   make_primitive_dEdR_NA_matrix(NAI,cn)
   ! Calculate the primitive dEdR integrals for num diff,
   ! i.e. the diferentiation of nuclear potential with respect to
   ! the size of the nucleus
      NAI :: MAT{REAL}
      cn :: INT
    ENSURE(.atom.associated,  "no atom list")
    ENSURE(.basis_info_made, "no basis info")
    ENSURE(NAI.is_square, "T must be square")
    ENSURE(NAI.dim1==.n_prim, "wrong size, T")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c,neta :: INT
      Z :: REAL
      G :: GAUSSIAN2
      atom :: ATOM*
      NAc :: MAT3{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim
      NAI = ZERO
      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1
            NAc.create(na,nb,4)
!           do c = 1,.n_atom
          !  c=1 ! works only for nucleus numero uno
            c=cn ! works for nucleus numero cn
            NAc=ZERO
            atom => .atom(c)
              select case (.nucleus_model)
                case ("finite","gaussian")
                neta= atom.atomic_number
    !       if (c==1) then
 G.make_normalised_finite_NA_ints(NAc(:,:,1),atom.position,neta,-2,.use_spherical_basis)
 G.make_normalised_finite_NA_ints(NAc(:,:,2),atom.position,neta,-1,.use_spherical_basis)
 G.make_normalised_finite_NA_ints(NAc(:,:,3),atom.position,neta, 1,.use_spherical_basis)
 G.make_normalised_finite_NA_ints(NAc(:,:,4),atom.position,neta, 2,.use_spherical_basis)
    !       end if
                case default
           DIE("Unknown model of nucleus")     
              end
             Z  =  atom.nuclear_charge/SIX/1.0000000E-6
             NAI(fa:la,fb:lb) = NAI(fa:la,fb:lb) - Z *( &
             NAc(:,:,1) - EIGHT*NAc(:,:,2) + &
             EIGHT*NAc(:,:,3) - NAc(:,:,4) )

   !        end
           NAc.destroy
        end
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      NAI.symmetric_reflect

      ! Debug, turn on with debug_on "key"
      .BASE:put_debug(NAI,  "make_primitive_dEdR_NA_matrices: NAI")

   end

   make_primitive_dEdR_DKH_matrices(T,SOx,SOy,SOz,cn)
   ! Calculate the primitive Douglas-Kroll-Hess type integrals
   ! on the diferentiation of nuclear potential with respect to
   ! the size of the nucleus
      T,SOx,SOy,SOz :: MAT{REAL}
      cn :: INT
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")
   ENSURE(SOx.is_same_shape_as(T),"wrong shape, SOx")
   ENSURE(SOy.is_same_shape_as(T),"wrong shape, SOy")
   ENSURE(SOz.is_same_shape_as(T),"wrong shape, SOz")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c,neta :: INT
      Z :: REAL
      G :: GAUSSIAN2
      atom :: ATOM*
      Tc,SOxc,SOyc,SOzc :: MAT3{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim
      T = ZERO
      SOx = ZERO; SOy = ZERO; SOz = ZERO
      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1
             Tc.create(na,nb,4)
           SOxc.create(na,nb,4)
           SOyc.create(na,nb,4)
           SOzc.create(na,nb,4)
!           do c = 1,.n_atom
           c = 1 ! works only for nucleus numero uno
           c = cn ! works for nucleus numero cn
           Tc=ZERO;SOxc=ZERO;SOyc=ZERO;SOzc=ZERO
              atom => .atom(c)
              select case (.nucleus_model)
                case ("finite","gaussian")
                  neta = atom.atomic_number
                ! if (c==1) then
                  G.make_normalised_finite_DKH_ints( &
                  Tc(:,:,1),SOxc(:,:,1),SOyc(:,:,1),SOzc(:,:,1),atom.position,neta,-2,.use_spherical_basis)
                  G.make_normalised_finite_DKH_ints( &
                  Tc(:,:,2),SOxc(:,:,2),SOyc(:,:,2),SOzc(:,:,2),atom.position,neta,-1,.use_spherical_basis)
                  G.make_normalised_finite_DKH_ints( &
                  Tc(:,:,3),SOxc(:,:,3),SOyc(:,:,3),SOzc(:,:,3),atom.position,neta, 1,.use_spherical_basis)
                  G.make_normalised_finite_DKH_ints( &
                  Tc(:,:,4),SOxc(:,:,4),SOyc(:,:,4),SOzc(:,:,4),atom.position,neta, 2,.use_spherical_basis)
                ! end if
                case default
                  DIE("Unknown model of nucleus")     
              end
             Z  =  atom.nuclear_charge/SIX/1.0000000E-6
             T(fa:la,fb:lb) = T(fa:la,fb:lb) - Z *( &
             Tc(:,:,1) - EIGHT*Tc(:,:,2) + &
             EIGHT*Tc(:,:,3) - Tc(:,:,4) )
             SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) - Z *( &
             SOxc(:,:,1) - EIGHT*SOxc(:,:,2) + &
             EIGHT*SOxc(:,:,3) - SOxc(:,:,4) )
             SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) - Z *( &
             SOyc(:,:,1) - EIGHT*SOyc(:,:,2) + &
             EIGHT*SOyc(:,:,3) - SOyc(:,:,4) )
             SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) - Z *( &
             SOzc(:,:,1) - EIGHT*SOzc(:,:,2) + &
             EIGHT*SOzc(:,:,3) - SOzc(:,:,4) )
 !          end
           SOzc.destroy; SOyc.destroy; SOxc.destroy
           Tc.destroy
        end
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      T.symmetric_reflect
      SOx.antisymmetric_reflect
      SOy.antisymmetric_reflect
      SOz.antisymmetric_reflect

      ! Debug, turn on with debug_on "key"
      .BASE:put_debug(T,  "make_primitive_DKH_matrices: T")
      .BASE:put_debug(SOx,"make_primitive_DKH_matrices: SOx")
      .BASE:put_debug(SOy,"make_primitive_DKH_matrices: SOy")
      .BASE:put_debug(SOz,"make_primitive_DKH_matrices: SOz")

   end

!  ==========================
!  expectation value routines
!  ==========================

   build_da_IOTC_even_expectval(F,Yr,PAP,A,p,bp,n_gcm) ::: selfless
   ! build the IOTC expectation value matrix, real version
      F :: MAT{REAL}, OUT
      Yr,PAP,A :: MAT{REAL}, IN
      p,bp :: VEC{REAL}, IN
      n_gcm :: INT, IN

      i,j :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{REAL}*

      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
 
      F1L.create(n_gcm,n_gcm); F1R.create(n_gcm,n_gcm);
      F2.create(n_gcm,n_gcm); AAA.create(n_gcm,n_gcm)
 
         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do
 
      do i = 1,n_gcm
      do j = 1,n_gcm
          F(i,j)  = A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) = alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) = alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
          F2(i,j) = PAP(i,j)/p(j)/p(i) + AAA(i,j)
         end do
      end do

      F2.change_basis_using(Yr)
 
      F.plus_product_of( Yr,F1L,transpose_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)
      
      AAA.destroy; F2.destroy;
      F1R.destroy; F1L.destroy

   end
   
   build_da_IOTC_even_expectval(F,Yr,PAP,A,p,bp)
   ! build the IOTC expectation value matrix, general complex version 
      F :: MAT{CPX}, OUT
      Yr,PAP,A :: MAT{CPX}, IN
      p,bp :: VEC{REAL}, IN

      i,j,n_gcm,dim :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{CPX}*

      n_gcm=.n_prim
      c = SPEED_OF_LIGHT_AU
      alpha = ONE/c
      alpha2= alpha*alpha
 
      dim = 2*n_gcm
 
      F1L.create(dim,dim); F1R.create(dim,dim);
      F2.create(dim,dim); AAA.create(dim,dim)
 
         do i = 1,dim
         do j = 1,dim
            AAA(i,j) = alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do

      do i = 1,dim
      do j = 1,dim
          F(i,j)  =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
          F2(i,j) =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
      end do
      end do
 
      F2.change_basis_using(Yr)

      F.plus_product_of( Yr,F1L,dagger_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)

      AAA.destroy; F1L.destroy;
      F1R.destroy; F2.destroy

   end

!  ===========================
!  Gaussian nucleus properties
!  ===========================

   get_G_overlap_nuc 
   ! The evaluation of electron density over the Gaussian nucleus 

      MO,MOa,MOb :: MAT{REAL}*
      CMO :: MAT{CPX}*
      D,Da,Db :: MAT{REAL}*
      CD :: MAT{CPX}*
      

      stdout.text("routine: get_G_overlap_nuc")

      select case (.scfdata.scf_kind)

         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
            ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            if (.scfdata.PCE_CORR) then
               stdout.flush
               stdout.text("The integrated rhf electron density (PCE corrected) at each nucleus:")
               .:get_PCEc_G_overlap_on_nuc(D)
            else
               stdout.flush
               stdout.text("The integrated rhf electron density (PCE contaminated) at each nucleus:")
               .:get_G_overlap_on_nuc(D)
            end if

         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            if (.scfdata.PCE_CORR) then
               stdout.flush
               stdout.text("The integrated uhf ele and spin density (PCE corrected) at each nucleus:")
               .:get_PCEc_G_overlap_on_nuc(Da,Db)
            else
               stdout.flush
               stdout.text("The integrated uhf ele and spin density (PCE contaminated) at each nucleus:")
               .:get_G_overlap_on_nuc(Da,Db)
            end if

         case ("gchf","xray_gchf")
            ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)
            CD => .density_matrix.general_complex
            CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            if (.scfdata.PCE_CORR) then
               stdout.flush
               stdout.text("The integrated gchf electron density (PCE corrected) at each nucleus:")
               .:get_PCEc_2cG_overlap_on_nuc(CD)
            else
               D.create(.n_bf,.n_bf)
               D =     RE(CD(1:.n_bf,1      :  .n_bf)) + RE(CD(.n_bf+1:2*.n_bf,1      :  .n_bf))
               D = D + RE(CD(1:.n_bf,1+.n_bf:2*.n_bf)) + RE(CD(.n_bf+1:2*.n_bf,1+.n_bf:2*.n_bf))
               stdout.flush
               stdout.text("The integrated gchf electron density (PCE contaminated) at each nucleus:")
               .:get_G_overlap_on_nuc(D)
               D.destroy
            end if

         case default
            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))

      end

   end

   get_G_overlap_on_nuc(D)
   ! Calculate the primitive nuclear attraction matrix "Z"
      D :: MAT{REAL}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")

      c,neta,i,j :: INT
      atom :: ATOM*
      Zc :: MAT{REAL}*
      gg :: REAL
      ccm,Zb,buco :: MAT{REAL}*

      ! Calculate the primitive integrals
    !  n=.scfdata.nhf ! for numerical diff of energy by the change of the size of the nucleus

      select case (.nucleus_model)
         case ("finite","gaussian")

        stdout.flush
        !stdout.text(" Weighted electron density in the Gaussian nucleus")
        stdout.dash(int_fields=1,real_fields=1)
        stdout.put("Atom" , int_width = TRUE)
        stdout.put("rho_e")
        stdout.flush
        stdout.dash(int_fields=1,real_fields=1)

        do c = 1,.n_atom
           atom => .atom(c)
           neta= atom.atomic_number 
           Zb.create(.n_prim,.n_prim)
           Zb = ZERO

           .:make_primitive_G_overlap_on_nuc(Zb,c)

           ccm.create(.n_prim,.n_bf)
           ccm=ZERO
           Zc.create(.n_bf,.n_bf)
           Zc=ZERO
           .BASE:make_normalised_contraction_mx(ccm)
           buco.create(.n_bf,.n_prim)
           buco=ZERO
           buco.to_product_of(ccm,Zb,transpose_a=TRUE)
           Zb.destroy
           Zc.to_product_of(buco,ccm)
           buco.destroy
           ccm.destroy
       
           gg=ZERO
           do i=1,.n_bf
           do j=1,.n_bf
              gg = gg + D(j,i)*Zc(i,j)
           end            
           end            
           stdout.put(c)
           stdout.put(gg)
           stdout.flush

           Zc.destroy
        end

        stdout.dash(int_fields=1,real_fields=1)
        stdout.flush

      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end

   end

   get_G_overlap_on_nuc(Da,Db)
   ! Calculate the primitive nuclear attraction matrix "Z"
      Da,Db :: MAT{REAL}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")

      c,neta,i,j :: INT
      atom :: ATOM*
      Zc :: MAT{REAL}*
      gga,ggb :: REAL
      ccm,Zb,buco :: MAT{REAL}*

      ! Calculate the primitive integrals
      select case (.nucleus_model)
         case ("finite","gaussian")

        stdout.flush
        !stdout.text(" Weighted electron density in the Gaussian nucleus")
        stdout.dash(int_fields=1,real_fields=2)
        stdout.put("Atom", int_width = TRUE)
        stdout.put("rho_e")
        stdout.put("rho_s")
        stdout.flush
        stdout.dash(int_fields=1,real_fields=2)

        do c = 1,.n_atom
          atom => .atom(c)
          neta= atom.atomic_number 
          Zb.create(.n_prim,.n_prim)
          Zb = ZERO

           .:make_primitive_G_overlap_on_nuc(Zb,c)

          ccm.create(.n_prim,.n_bf)
          ccm=ZERO
          Zc.create(.n_bf,.n_bf)
          Zc=ZERO
          .BASE:make_normalised_contraction_mx(ccm)
          buco.create(.n_bf,.n_prim)
          buco=ZERO
          buco.to_product_of(ccm,Zb,transpose_a=TRUE)
          Zb.destroy
          Zc.to_product_of(buco,ccm)
          buco.destroy
          ccm.destroy
       
          gga=ZERO
          ggb=ZERO
          do i=1,.n_bf
          do j=1,.n_bf
            gga = gga + Da(j,i)*Zc(i,j)
            ggb = ggb + Db(j,i)*Zc(i,j)
          end            
          end           
          stdout.put(c)
          stdout.put(gga+ggb)
          stdout.put(gga-ggb)
          stdout.flush

          Zc.destroy
        end

        stdout.dash(int_fields=1,real_fields=2)
        stdout.flush

      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end

   end

   get_PCEc_G_overlap_on_nuc(D)
   ! Calculate the primitive nuclear attraction matrix "Z"
      D :: MAT{REAL}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.scfdata.relativity_kind=="iotc", "works only with iotc")

      c,i,j :: INT
      gg :: REAL
      Zb :: MAT{REAL}*

      ! Calculate the primitive integrals
      Zb.create(.n_bf,.n_bf)
      select case (.nucleus_model)
         case ("finite","gaussian")

        stdout.flush
        !stdout.text(" Weighted electron density in the Gaussian nucleus")
        stdout.dash(int_fields=1,real_fields=1)
        stdout.put("Atom", int_width = TRUE)
        stdout.put("rho_e")
        stdout.flush
        stdout.dash(int_fields=1,real_fields=1)

        do c = 1,.n_atom
          Zb = ZERO
        
          .:make_1c_PCEc_G_overlap_on_nuc(Zb,c)

          gg=ZERO
          do i=1,.n_bf
          do j=1,.n_bf
            gg = gg + D(j,i)*Zb(i,j)
          end            
          end            
          stdout.put(c)
          stdout.put(gg)
          stdout.flush

        end

        stdout.dash(int_fields=1,real_fields=1)
        stdout.flush

      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end
     Zb.destroy

   end

   get_PCEc_G_overlap_on_nuc(Da,Db)
   ! Calculate the primitive nuclear attraction matrix "Z"
      Da,Db :: MAT{REAL}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.scfdata.relativity_kind=="iotc", "works only with iotc")

      c,i,j :: INT
      gga,ggb :: REAL
      Zb :: MAT{REAL}*

      ! Calculate the primitive integrals
      Zb.create(.n_bf,.n_bf)
      select case (.nucleus_model)
        case ("finite","gaussian")

        stdout.flush
        !stdout.text(" Weighted electron density in the Gaussian nucleus")
        stdout.dash(int_fields=1,real_fields=2)
        stdout.put("Atom" , int_width = TRUE)
        stdout.put("rho_e")
        stdout.put("rho_s")
        stdout.flush
        stdout.dash(int_fields=1,real_fields=2)

        do c = 1,.n_atom
          Zb = ZERO
        
          .:make_1c_PCEc_G_overlap_on_nuc(Zb,c)

          gga=ZERO
          ggb=ZERO
          do i=1,.n_bf
          do j=1,.n_bf
            gga = gga + Da(j,i)*Zb(i,j)
            ggb = ggb + Db(j,i)*Zb(i,j)
          end            
          end            
          stdout.put(c)
          stdout.put(gga+ggb)
          stdout.put(gga-ggb)
          stdout.flush

        end

        stdout.dash(int_fields=1,real_fields=2)
        stdout.flush

      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end
     Zb.destroy

   end

   get_PCEc_2cG_overlap_on_nuc(CD)
   ! Calculate the primitive nuclear attraction matrix "Z"
      CD :: MAT{CPX}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.scfdata.relativity_kind=="iotc", "works only with iotc")

      c,i,j :: INT
      gg :: REAL
      ggc :: CPX
      Zc :: MAT{CPX}*

      ! Calculate the primitive integrals
      Zc.create(2*.n_bf,2*.n_bf)
      select case (.nucleus_model)
         case ("finite","gaussian")
        do c = 1,.n_atom
          Zc = (ZERO,ZERO)

          stdout.flush
          !stdout.text(" Weighted electron density in the Gaussian nucleus")
          stdout.dash(int_fields=1,real_fields=2)
          stdout.put("Atom" , int_width = TRUE)
          stdout.put("rho_e")
          stdout.put("rho_s")
          stdout.flush
          stdout.dash(int_fields=1,real_fields=2)
        
          .:make_2c_PCEc_G_overlap_on_nuc(Zc,c)

          ggc=(ZERO,ZERO)
          do i=1,2*.n_bf
          do j=1,2*.n_bf
            ggc = ggc + CD(j,i)*Zc(i,j)
          end            
          end
          gg=real(ggc)
          stdout.put(c)
          stdout.put(ggc)
          stdout.flush

        end

        stdout.dash(int_fields=1,real_fields=2)
        stdout.flush

      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end
   ! Zb.destroy
     Zc.destroy

   end

   make_1c_PCEc_G_overlap_on_nuc(Zb,nc)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    Zb :: MAT{REAL} , OUT
    nc :: INT , IN
    n_gcm :: INT
    i,j,k :: INT
    c,alpha,alpha2 :: REAL
    m_out :: MAT{INT}*
    R,Y,U,A,T,O :: MAT{REAL}*
    SOx,SOy,SOz,Yr :: MAT{REAL}*
    YU,GG,S,Z,PZP :: MAT{REAL}*
    P2,Ap,E,p,ep,bp :: VEC{REAL}*

!!! analysis of the primitive basis set via the overap matrix
!!! trying to lower the problem to an general contracted basis set
!!!  OVERLAP MATRIX !!!
     R.create(.n_prim,.n_prim)
    .:make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .:make_ready_da_gcm_tr2(m_out,n_gcm)  
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
! put the overlap matrix into the n_gcm non-redundant space
     S.create(n_gcm,n_gcm)
     .:get_da_gcm_now(R,S,m_out)  
     
     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)

!!!  KINETIC ENERGY MATRIX !!!
     R=ZERO
     .:make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,T,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_symmetric_eigenproblem(P2,U)
     P2= TWO * P2
     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     T.destroy
     Y.destroy
     U.destroy
   
!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     .:make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
! put the potential energy matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,Z,m_out)  

     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

!!!  PZP MATRIX  !!!
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
     .:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
     SOx.destroy
     SOy.destroy
     SOz.destroy

     PZP.create(n_gcm,n_gcm)
! put the PZP matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,PZP,m_out) 

     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)
     R.destroy

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha
 
     E.create(n_gcm)
     p.create(n_gcm)
     ep.create(n_gcm)
     Ap.create(n_gcm)
     bp.create(n_gcm)

     E=ZERO 
     p=ZERO
     ep=ZERO
     Ap=ZERO
     bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE)

     end  
    P2.destroy

     do i=1,n_gcm
       do j=1,n_gcm
    
        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
    
       end
     end

     Yr.create(n_gcm,n_gcm)

    .:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
    .BASE:put_debug(Yr,"Y matrix")

! lets make ready the normalzation matrix
     O.create(n_gcm,n_gcm)
     O=ZERO
     do i=1,n_gcm
       O(i,i)=ONE
       do j=1,n_gcm
         do k=1,n_gcm
           O(i,j)=O(i,j)+Yr(k,i)*Yr(k,j)
         end do
       end do
     end do
        
     A.to_inverse_sqrt_of(O)
     O=A
     Z.destroy
     PZP.destroy
     A.destroy

    GG.create(.n_bf,.n_bf)
     GG=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .:make_GG_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,nc,m_out,n_gcm,S,O)

    Zb=GG

    S.destroy
    O.destroy
    GG.destroy
    YU.destroy
    Yr.destroy
    Ap.destroy
    E.destroy
    p.destroy
    bp.destroy
    ep.destroy
    m_out.destroy

   end

   make_2c_PCEc_G_overlap_on_nuc(Zb,nc)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    Zb :: MAT{CPX} , OUT
    nc :: INT, IN
    n_gcm :: INT
    i,j :: INT
    fac,c,alpha,alpha2,eps :: REAL
    II :: CPX
    mmm :: MAT{INT}* 
    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    A2,PAP,O,Ox,Yr :: MAT{CPX}*
    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

     !test
     mmm.create(.n_prim,.n_prim)
      .:get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" contracted gaussians do not work for IOTC at gchf level!")
     end if    
     
  !!! n_gcm = .n_prim = .n_bf

! this is actually not needed but I am also using n_gcm 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
     S=ZERO; Y=ZERO
!!!  OVERLAP MATRIX + Y MX !!!
    .:make_primitive_overlap_matrix(S)
     Y.to_inverse_sqrt_of(S)
   !  .make_S_Y(S,Y)  !  ???

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     T.create(n_gcm,n_gcm)
     T=ZERO
     .:make_primitive_kinetic_matrix(T)
     R=ZERO
     R.to_product_of(Y,T)   
     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     P2.create(n_gcm)
     U.create(n_gcm,n_gcm)
     P2=ZERO;U=ZERO
     T.solve_symmetric_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy
     T.destroy
     
!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .:make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO
    
!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     .:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .BASE:put_debug(PZP,"PZP matrix")
    .BASE:put_debug(SOx,"SOx matrix")
    .BASE:put_debug(SOy,"SOy matrix")
    .BASE:put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

    .BASE:put_debug(PZP,"PZP matrix YU")
    .BASE:put_debug(SOx,"SOx matrix YU")
    .BASE:put_debug(SOy,"SOy matrix YU")
    .BASE:put_debug(SOz,"SOz matrix YU")
!    .put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha
 
     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
     end do

     P2.destroy

     do i = 1,n_gcm
       do j=1,n_gcm
    
        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
    
       end
     end

    .BASE:put_debug(PZP,"PZP matrix YUAp")
    .BASE:put_debug(SOx,"SOx matrix YUAp")
    .BASE:put_debug(SOy,"SOy matrix YUAp")
    .BASE:put_debug(SOz,"SOz matrix YUAp")
     
   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
    .BASE:put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
     PAP.beta_alpha_plus(SOx,fac*II)
     PAP.beta_alpha_plus(SOy,-fac)
     PAP.alpha_alpha_plus(SOz,fac*II)
     PAP.beta_beta_plus(SOz,-fac*II)
     PAP.make_hermitian   
    .BASE:put_debug(PAP,"PAP matrix")
     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
    .:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy
    
! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

!    .find_da_Y_iterative(Yr,PZP,SOx,SOy,SOz,Z,p,bp,ep)
    .:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .BASE:put_debug(Yr,"Y matrix")
     
    PAP.destroy
    A2.destroy
      
     O.create(2*n_gcm,2*n_gcm)
     Ox.create(2*n_gcm,2*n_gcm)
     O=(ZERO,ZERO)
!     A=(ZERO,ZERO)
     Ox=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox(i,i)=ONE
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox=Ox+O
     O=(ZERO,ZERO)
    UN.create(2*n_gcm)
    UN=ZERO

    ! make ready the preconditioning
    do i=1,2*n_gcm
      UN(i)=ONE/sqrt(real(Ox(i,i)))
    end 

    do i=1,2*n_gcm
      do j=1,2*n_gcm
        Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
    end  
    .BASE:put_debug(Ox,"Ox matrix")
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(Ox,eps)
    do i=1,2*n_gcm
      do j=1,2*n_gcm
        O(i,j)=O(i,j)*UN(j)
      end
    end  
    UN.destroy
    Ox.destroy

    .BASE:put_debug(O,"O matrix")

    GG22.create(2*n_gcm,2*n_gcm)
    GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code is comparing to it's non-relativistic
! counter part really not effective :(
     .:make_GG_IOTC_SO_PCE_off(GG22,Yr,YU,Ap,bp,p,nc,n_gcm,S,O)
    
    Zb=GG22

    S.destroy
    O.destroy
    Yr.destroy
    GG22.destroy
    YU.destroy
    Ap.destroy
    E.destroy
    bp.destroy
    ep.destroy
    p.destroy
   end
  
   make_GG_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,nc,m_out,n_gcm,S,O)
   ! correct the picture change
   ! g is the electron density in a given point with nucleus nc 
   ! this routine is based on the make_r_DKH_matrix(H) routine
        GG :: MAT{REAL} , OUT
        Yr,YU :: MAT{REAL} , IN
        Ap,bp,p :: VEC{REAL} , IN
        nc :: INT , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S,O :: MAT{REAL} , IN

        i,j :: INT   
        R :: MAT{REAL}*  
        D,PDP :: MAT{REAL}*
        Rx,Ry,Rz :: MAT{REAL}*
        A,B :: MAT{REAL}*
        M,buco :: MAT{REAL}* 

!!!  the density operator X !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
! it do not exist in the moment
     .:make_primitive_G_overlap_on_nuc(R,nc)
     D.create(n_gcm,n_gcm)
     D=ZERO
! put the potential energy matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,D,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)

!!!  PDP MATRIX  !!!
      R=ZERO
     Rx.create(.n_prim,.n_prim);Ry.create(.n_prim,.n_prim);Rz.create(.n_prim,.n_prim)
     .:make_primitive_pGp_overlap_on_nuc(R,Rx,Ry,Rz,nc)
     Rx.destroy;Ry.destroy;Rz.destroy

     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
! put the PDP matrix into the n_gcm non-redundant space
    .:get_da_gcm_now(R,PDP,m_out)  
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)

   if( .scfdata.using_ppzpp)then
     WARN("ppzpp is ignored")
   end if 

!!! A-O LETS GO !!!
        
     do i=1,n_gcm
       do j=1,n_gcm
    
        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)                                        
    
       end
     end

     B.create(n_gcm,n_gcm) 
     B=ZERO  
     if(.scfdata.using_ppzpp)then
     ! ::build_da_IOTC_dens(B,Yr,PDP,D,p,bp,E,n_gcm,PPDPP)
     else
       MOLECULE.REL:build_da_IOTC_even_expectval(B,Yr,PDP,D,p,bp,n_gcm)
     end if  

     D=ZERO
     D=matmul(O,matmul(B,O))

    PDP.destroy
   
     B=ZERO
     B.to_product_of(S,YU)

     A=ZERO
     A.to_product_of(B,D)
     D.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .:get_back_prim_now(D,R,m_out)  
     D.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .BASE:make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy

     GG.to_product_of(buco,M)

     M.destroy
     buco.destroy
   end   
  
   make_GG_IOTC_SO_PCE_off(GG,Yr,YU,Ap,bp,p,nc,n_gcm,S,O)
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine
   
        GG,Yr :: MAT{CPX} 
        YU :: MAT{REAL} , IN
        Ap,bp,p :: VEC{REAL} , IN
        nc :: INT , IN
        n_gcm :: INT , IN
        S :: MAT{REAL} , IN
        O :: MAT{CPX} 

        II :: CPX
        c,fac :: REAL  
        i,j :: INT  
        F,A2,B2,M2,buco,PAP :: MAT{CPX}*
        D,PDP,SOx,SOy,SOz :: MAT{REAL}*  
        A,B,M :: MAT{REAL}*

!!!  the density X operator !!!
!     R.create(.n_prim,.n_prim)
!     R=ZERO
     D.create(n_gcm,n_gcm)
     D=ZERO
     .:make_primitive_G_overlap_on_nuc(D,nc)
     A.create(n_gcm,n_gcm)
     A=ZERO
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)
!!!  the density PXP operator !!!
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
      SOx=ZERO; SOy=ZERO; SOz=ZERO
     .:make_primitive_pGp_overlap_on_nuc(PDP,SOx,SOy,SOz,nc)
!!!  SO MATRICES  !!!
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,YU)
!!! A-O LETS GO !!!

!     B.create(n_gcm,n_gcm) 
     A=ZERO
!     B=ZERO  
        
     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm
    
        D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
    
       end
     end
     
     if(.scfdata.using_ppzpp)then
     WARN("PPGPP is not used")
      end if  
    A.destroy

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(D)
     A2.beta_beta_plus(D)
!   A.make_hermitian   
    .BASE:put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PDP)
     PAP.beta_beta_plus(PDP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
   PAP.make_hermitian   
    .BASE:put_debug(PAP,"PAP matrix")
     D.destroy
     PDP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
!     R.destroy
    
     F.create(2*n_gcm,2*n_gcm)
     F=(ZERO,ZERO)

     .:build_da_IOTC_even_expectval(F,Yr,PAP,A2,p,bp)

    .BASE:put_debug(F,"F matrix")
     
     PAP.destroy
!    if( .scfdata.using_ppzpp)then
!      ppApp.destroy
!    end if 

     A2=(ZERO,ZERO)
     ! normalization
     A2.to_product_of(F,O)
     F.to_product_of(O,A2,dagger_a=TRUE)
    
! back to cartesian basis set
     B.create(n_gcm,n_gcm) 
     B.to_product_of(S,YU)
     B2.create(2*n_gcm,2*n_gcm)
     B2=(ZERO,ZERO)
     B2.alpha_alpha_plus(B)
     B2.beta_beta_plus(B)
     B.destroy

     A2=(ZERO,ZERO)
     A2.to_product_of(B2,F)
     F.to_product_of(A2,B2,dagger_b=TRUE)
    .BASE:put_debug(F,"U+YOFOYU matrix")

     B2.destroy

     A2=(ZERO,ZERO)

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     M=ZERO
    .BASE:make_normalised_contraction_mx(M)
    .BASE:put_debug(M,"M matrix")
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
    .BASE:put_debug(M2,"M2 matrix")
     buco.create(2*.n_prim,2*.n_prim)
     buco=(ZERO,ZERO)
     buco.to_product_of(M2,F,dagger_a=TRUE)
     A2.to_product_of(buco,M2)
    .BASE:put_debug(A2,"MU+YOFOYUM matrix")
     M.destroy
     F.destroy
     M2.destroy
     buco.destroy

     GG = A2
     A2.destroy
     .BASE:put_debug(GG,"GG matrix")

   end   

   get_dEdR_IOTC
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
   !
  MO,MOa,MOb :: MAT{REAL}*
  CMO :: MAT{CPX}*
  D,Da,Db :: MAT{REAL}*
  CD :: MAT{CPX}*
     select case (.scfdata.scf_kind)
       case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
           ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
           ENSURE(.spin_multiplicity==1,"this is not a singlet state")
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            stdout.flush
            stdout.flush
            stdout.text("Effective electron density via get_dEdR_IOTC")
            .:get_dEdR_IOTC(D)
          case ("uhf","uks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            D.create(.n_bf,.n_bf)
            D=Da+Db
            stdout.flush
            stdout.flush
            stdout.text("Effective electron density via get_dEdR_IOTC")
            .:get_dEdR_IOTC(D)
            D=Da-Db
            stdout.flush
            stdout.flush
            stdout.text("Effective spin density via get_dEdR_IOTC")
            .:get_dEdR_IOTC(D)
            D.destroy
      case ("gchf","xray_gchf")
            ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)
            CD => .density_matrix.general_complex
            CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            stdout.flush
            stdout.flush
            stdout.text("Effective electron density via get_dEdR_IOTC")
            .:get_dEdR_IOTC(CD)
       case default
          DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))
       end
   end

   get_dEdR_IOTC(D)
   ! Calculate the primitive nuclear attraction matrix "Z"
      D :: MAT{REAL}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.scfdata.relativity_kind=="iotc", "works only with iotc")

      c,i,j,nc :: INT
      atom :: ATOM*
      gg,eta :: REAL
      Zb :: MAT{REAL}*

      ! Calculate the primitive integrals
      Zb.create(.n_bf,.n_bf)
      select case (.nucleus_model)
         case ("finite","gaussian")

         do c = 1,.atom.dim
           Zb = ZERO
        
           .:make_1c_dEdR_IOTC(Zb,c)

           gg=ZERO
           do i=1,.n_bf
           do j=1,.n_bf
             gg = gg + D(j,i)*Zb(i,j)
           end            
           end

           stdout.show("nucleus =",c)
           stdout.show("dE/dR =",gg)

        !   c=1 
           atom => .atom(c)
           nc=atom.atomic_number
           eta = GAUSSIAN2:nucleus_eta(nc)
           gg=gg*THREE/FOUR/PI/nc/sqrt(THREE/TWO/eta)
           stdout.show("rho =",gg)
           stdout.flush
        end
      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end
     Zb.destroy

   end

   get_dEdR_IOTC(CD)
   ! Calculate the primitive nuclear attraction matrix "Z"
      CD :: MAT{CPX}
   ENSURE(.atom.associated,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.scfdata.relativity_kind=="iotc", "works only with iotc")

      c,i,j,nc :: INT
      atom :: ATOM*
      gg :: CPX
      eta :: REAL
      Zb :: MAT{CPX}* ! ????

      ! info
      ! stdout.text("  real & imaginary parts are shown,")
      ! stdout.text("  imaginary part should be zero !!!")
      ! stdout.flush

      ! Calculate the primitive integrals
      Zb.create(2*.n_bf,2*.n_bf)
      select case (.nucleus_model)
         case ("finite","gaussian")

         do c = 1,.atom.dim
         Zb = (ZERO,ZERO)
        
         .:make_2c_dEdR_IOTC(Zb,c)

         gg=ZERO
         do i=1,.n_bf*2
         do j=1,.n_bf*2
           gg = gg + CD(j,i)*Zb(i,j)
         end            
         end 
         stdout.show("nucleus =",c)
         stdout.show("dE/dR =",real(gg))

         !c=1 
         atom => .atom(c)
         nc=atom.atomic_number
         eta = GAUSSIAN2:nucleus_eta(nc)
         gg=gg*THREE/FOUR/PI/nc/sqrt(THREE/TWO/eta)
         stdout.show("rho =",real(gg))
         stdout.flush
         end do
      case default
         DIE("Works only for the Gaussian nucleus model!")     
      end
     Zb.destroy

   end

   make_1c_dEdR_IOTC(Zb,cn)
   ! the matrix representation of the differentiation V(nuc-ele)
   ! with respect to the size of the nucleus
    Zb :: MAT{REAL} , OUT
    cn :: INT , IN
    n_gcm :: INT
    i,j,k :: INT
    c,alpha,alpha2 :: REAL
    m_out :: MAT{INT}*
    R,Y,U,A,T,O :: MAT{REAL}*
    SOx,SOy,SOz,Yr :: MAT{REAL}*
    YU,GG,S,Z,PZP :: MAT{REAL}*
    P2,Ap,E,p,ep,bp :: VEC{REAL}*

!!! analysis of the primitive basis set via the overap matrix
!!! trying to lower the problem to an general contracted basis set
!!!  OVERLAP MATRIX !!!
     R.create(.n_prim,.n_prim)
    .:make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .:make_ready_da_gcm_tr2(m_out,n_gcm)  
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
! put the overlap matrix into the n_gcm non-redundant space
     S.create(n_gcm,n_gcm)
     .:get_da_gcm_now(R,S,m_out)  
     
     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)

!!!  KINETIC ENERGY MATRIX !!!
     R=ZERO
     .:make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,T,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_symmetric_eigenproblem(P2,U)
     P2= TWO * P2
     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     T.destroy
     Y.destroy
     U.destroy
   
!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     .:make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
! put the potential energy matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,Z,m_out)  

     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

!!!  PZP MATRIX  !!!
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
     .:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
     SOx.destroy
     SOy.destroy
     SOz.destroy
     PZP.create(n_gcm,n_gcm)
! put the PZP matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,PZP,m_out) 

     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)
     R.destroy

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha
 
     E.create(n_gcm)
     p.create(n_gcm)
     ep.create(n_gcm)
     Ap.create(n_gcm)
     bp.create(n_gcm)

     E=ZERO 
     p=ZERO
     ep=ZERO
     Ap=ZERO
     bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE)

     end  
    P2.destroy

     do i=1,n_gcm
       do j=1,n_gcm
    
        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
    
       end
     end

     Yr.create(n_gcm,n_gcm)

    .:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
    .BASE:put_debug(Yr,"Y matrix")

! lets make ready the normalzation matrix
     O.create(n_gcm,n_gcm)
     O=ZERO
     do i=1,n_gcm
       O(i,i)=ONE
       do j=1,n_gcm
         do k=1,n_gcm
           O(i,j)=O(i,j)+Yr(k,i)*Yr(k,j)
         end do
       end do
     end do
        
     A.to_inverse_sqrt_of(O)
     O=A
     Z.destroy
     PZP.destroy
     A.destroy

    GG.create(.n_bf,.n_bf)
     GG=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .:make_dEdR_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,m_out,n_gcm,S,O,cn)

    Zb=GG

    S.destroy
    O.destroy
    GG.destroy
    YU.destroy
    Yr.destroy
    Ap.destroy
    E.destroy
    p.destroy
    bp.destroy
    ep.destroy
    m_out.destroy

   end

   make_2c_dEdR_IOTC(Zb,cn)
   ! the matrix representation of the differentiation V(nuc-ele)
   ! with respect to the size of the nucleus
    Zb :: MAT{CPX} , OUT
    cn :: INT , IN
    n_gcm :: INT
    i,j :: INT
    fac,c,alpha,alpha2,eps :: REAL
    II :: CPX
    mmm :: MAT{INT}* 
    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    A2,PAP,O,Ox,Yr :: MAT{CPX}*
    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

     !test
     mmm.create(.n_prim,.n_prim)
     .:get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" contracted gaussians do not work for IOTC at gchf level!")
     end if    
     
  !!! n_gcm = .n_prim = .n_bf

! this is actually not needed but I am also using n_gcm 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
     S=ZERO; Y=ZERO
!!!  OVERLAP MATRIX + Y MX !!!
    .:make_primitive_overlap_matrix(S)
     Y.to_inverse_sqrt_of(S)
   !  .make_S_Y(S,Y)  !  ???

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     T.create(n_gcm,n_gcm)
     T=ZERO
     .:make_primitive_kinetic_matrix(T)
     R=ZERO
     R.to_product_of(Y,T)   
     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     P2.create(n_gcm)
     U.create(n_gcm,n_gcm)
     P2=ZERO;U=ZERO
     T.solve_symmetric_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy
     T.destroy
     
!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .:make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO
    
!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
    .:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .BASE:put_debug(PZP,"PZP matrix")
    .BASE:put_debug(SOx,"SOx matrix")
    .BASE:put_debug(SOy,"SOy matrix")
    .BASE:put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

    .BASE:put_debug(PZP,"PZP matrix YU")
    .BASE:put_debug(SOx,"SOx matrix YU")
    .BASE:put_debug(SOy,"SOy matrix YU")
    .BASE:put_debug(SOz,"SOz matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha
 
     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
     end do

     P2.destroy

     do i = 1,n_gcm
       do j=1,n_gcm
    
        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
    
       end
     end

    .BASE:put_debug(PZP,"PZP matrix YUAp")
    .BASE:put_debug(SOx,"SOx matrix YUAp")
    .BASE:put_debug(SOy,"SOy matrix YUAp")
    .BASE:put_debug(SOz,"SOz matrix YUAp")
     
     A2.create(2*n_gcm,2*n_gcm)
     A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
    .BASE:put_debug(A2,"A matrix")
     PAP.create(2*n_gcm,2*n_gcm)
     PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
     PAP.beta_alpha_plus(SOx,fac*II)
     PAP.beta_alpha_plus(SOy,-fac)
     PAP.alpha_alpha_plus(SOz,fac*II)
     PAP.beta_beta_plus(SOz,-fac*II)
     PAP.make_hermitian   
    .BASE:put_debug(PAP,"PAP matrix")
     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
    .:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy
    
! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

    .:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .BASE:put_debug(Yr,"Y matrix")
     
     PAP.destroy
     A2.destroy
      
     O.create(2*n_gcm,2*n_gcm)
     Ox.create(2*n_gcm,2*n_gcm)
     O=(ZERO,ZERO)
     Ox=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox(i,i)=ONE
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox=Ox+O
     O=(ZERO,ZERO)
     UN.create(2*n_gcm)
     UN=ZERO

     ! make ready the preconditioning
     do i=1,2*n_gcm
       UN(i)=ONE/sqrt(real(Ox(i,i)))
     end 

     do i=1,2*n_gcm
       do j=1,2*n_gcm
         Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
       end
     end  
    .BASE:put_debug(Ox,"Ox matrix")
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(Ox,eps)
     do i=1,2*n_gcm
       do j=1,2*n_gcm
         O(i,j)=O(i,j)*UN(j)
       end
     end  
     UN.destroy
     Ox.destroy

    .BASE:put_debug(O,"O matrix")

     GG22.create(2*n_gcm,2*n_gcm)
     GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code is comparing to it's non-relativistic
! counter part really not effective :(

     .:make_dEdR_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,n_gcm,S,O,cn)

     Zb=GG22
    
     S.destroy
     O.destroy
     Yr.destroy
     GG22.destroy
     YU.destroy
     Ap.destroy
     E.destroy
     bp.destroy
     ep.destroy
     p.destroy
   end
  
   make_dEdR_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,m_out,n_gcm,S,O,cn)
   ! correct the  picture change for the differentiation of V(nuc-ele) 
   ! with respect to the size of the nucleus 
        GG :: MAT{REAL} , OUT
        Yr,YU :: MAT{REAL} , IN
        Ap,bp,p :: VEC{REAL} , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S,O :: MAT{REAL} , IN
        cn :: INT , IN

        i,j :: INT   
        R :: MAT{REAL}*  
        D,PDP :: MAT{REAL}*
        Rx,Ry,Rz :: MAT{REAL}*
        A,B :: MAT{REAL}*
        M,buco :: MAT{REAL}* 

!!!  the density operator X !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
! it do not exist in the moment
     .:make_primitive_dEdR_NA_matrix(R,cn)
     D.create(n_gcm,n_gcm)
     D=ZERO
! put the potential energy matrix into the n_gcm non-redundant space
     .:get_da_gcm_now(R,D,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)

!!!  PDP MATRIX  !!!
      R=ZERO
     Rx.create(.n_prim,.n_prim);Ry.create(.n_prim,.n_prim);Rz.create(.n_prim,.n_prim)
    .:make_primitive_dEdR_DKH_matrices(R,Rx,Ry,Rz,cn)
     Rx.destroy;Ry.destroy;Rz.destroy

     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
! put the PDP matrix into the n_gcm non-redundant space
    .:get_da_gcm_now(R,PDP,m_out)  
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)

   if( .scfdata.using_ppzpp)then
     WARN("ppzpp is ignored")
   end if 

!!! A-O LETS GO !!!
        
     do i=1,n_gcm
       do j=1,n_gcm
    
        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)                                        
    
       end
     end

    ! if(.scfdata.using_ppzpp)then
    !   do i=1,n_gcm
    !     do j=1,n_gcm
    !       PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j) 
    !     end do
    !   end do
    ! end if  
    
     B.create(n_gcm,n_gcm) 
     B = ZERO  
     MOLECULE.REL:build_da_IOTC_even_expectval(B,Yr,PDP,D,p,bp,n_gcm)

     D=ZERO
     D=matmul(O,matmul(B,O))

    PDP.destroy
   
     B=ZERO
     B.to_product_of(S,YU)

     A=ZERO
     A.to_product_of(B,D)
     D.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .:get_back_prim_now(D,R,m_out)  
     D.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .BASE:make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy

     GG.to_product_of(buco,M)

     M.destroy
     buco.destroy
   end   
  
   make_dEdR_IOTC_PCE_SO_off(GG,Yr,YU,Ap,bp,p,n_gcm,S,O,cn)
   ! correct the  picture change for the differentiation of V(nuc-ele)
   ! with respect to the size of the nucleus 
        GG,Yr :: MAT{CPX} 
        YU :: MAT{REAL} , IN
        Ap,bp,p :: VEC{REAL} , IN
        n_gcm :: INT , IN
        S :: MAT{REAL} , IN
        O :: MAT{CPX} 
        cn :: INT , IN

        II :: CPX
        c,fac :: REAL  
        i,j :: INT  
        F,A2,B2,M2,buco,PAP :: MAT{CPX}*
        D,PDP,SOx,SOy,SOz :: MAT{REAL}*  
        A,B,M :: MAT{REAL}*

!!!  the density X operator !!!
     D.create(n_gcm,n_gcm)
     D=ZERO
     .:make_primitive_dEdR_NA_matrix(D,cn)
     A.create(n_gcm,n_gcm)
     A=ZERO
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)
!!!  the PXP operator !!!
!!!         &        !!!
!!!  SO MATRICES  !!!
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
     SOx=ZERO; SOy=ZERO; SOz=ZERO
     .:make_primitive_dEdR_DKH_matrices(PDP,SOx,SOy,SOz,cn)
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,YU)

!!! A-O LETS GO !!!

     A=ZERO
     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm
    
        D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
    
       end
     end
     
    A.destroy

    A2.create(2*n_gcm,2*n_gcm)
    A2=(ZERO,ZERO)
    A2.alpha_alpha_plus(D)
    A2.beta_beta_plus(D)
    .BASE:put_debug(A2,"A matrix")
    PAP.create(2*n_gcm,2*n_gcm)
    PAP=(ZERO,ZERO)
    PAP.alpha_alpha_plus(PDP)
    PAP.beta_beta_plus(PDP)
    II = (ZERO,ONE)
    fac= ONE
    PAP.beta_alpha_plus(SOx,fac*II)
    PAP.beta_alpha_plus(SOy,-fac)
    PAP.alpha_alpha_plus(SOz,fac*II)
    PAP.beta_beta_plus(SOz,-fac*II)
    PAP.make_hermitian   
    .BASE:put_debug(PAP,"PAP matrix")
    D.destroy
    PDP.destroy
    SOx.destroy
    SOy.destroy
    SOz.destroy
    
    F.create(2*n_gcm,2*n_gcm)
    F=(ZERO,ZERO)
! the hamiltonian is gonna be built
    .:build_da_IOTC_even_expectval(F,Yr,PAP,A2,p,bp)
    .BASE:put_debug(F,"F matrix")
     
    PAP.destroy

    A2=(ZERO,ZERO)
    ! normalization
    A2.to_product_of(F,O)
    F.to_product_of(O,A2,dagger_a=TRUE)
    
! back to cartesian basis set
    B.create(n_gcm,n_gcm) 
    B.to_product_of(S,YU)
    B2.create(2*n_gcm,2*n_gcm)
    B2=(ZERO,ZERO)
    B2.alpha_alpha_plus(B)
    B2.beta_beta_plus(B)
    B.destroy

    A2=(ZERO,ZERO)
    A2.to_product_of(B2,F)
    F.to_product_of(A2,B2,dagger_b=TRUE)
   .BASE:put_debug(F,"U+YOFOYU matrix")

    B2.destroy

    A2=(ZERO,ZERO)

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     M=ZERO
    .BASE:make_normalised_contraction_mx(M)
    .BASE:put_debug(M,"M matrix")
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
    .BASE:put_debug(M2,"M2 matrix")
     buco.create(2*.n_prim,2*.n_prim)
     buco=(ZERO,ZERO)
     buco.to_product_of(M2,F,dagger_a=TRUE)
     A2.to_product_of(buco,M2)
    .BASE:put_debug(A2,"MU+YOFOYUM matrix")
     M.destroy
     F.destroy
     M2.destroy
     buco.destroy

     GG = A2
     A2.destroy
     .BASE:put_debug(GG,"GG matrix")

   end   

end


