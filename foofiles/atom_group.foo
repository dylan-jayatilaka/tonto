!=====================================================================
!
! ATOM_GROUP:
!
! For storing the lists of integers which make up separate atom 
! groups within a list of atoms.
!
! Copyright (C) Dylan Jayatilaka, June 2011
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!=====================================================================

module ATOM_GROUP

   implicit none

   keys :: VEC{STR}@, private

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   update(atom) ::: leaky
   ! Do all the sanity checks and default settings
      self :: INOUT
      atom :: VEC{ATOM}, IN

      DIE_IF(atom.dim==0,"no atoms")

      ! Set the atom information
      .set_atom(atom)

      ! Ensure .atom_index is defined and OK
      DIE_IF(.atom_index.deallocated,"no atom_index in the group")
      DIE_IF(.atom_index.dim>.atom.dim,"more atom_index than # of atoms!")
      DIE_IF(.atom_index.has_repetitions,"there are repeated atom_index!")
      DIE_IF(any(.atom_index<=0),"non-positive atom atom_index!")
      DIE_IF(any(.atom_index>.atom.dim),"index too large")

   end

!  ===
!  Set
!  ===

   set_defaults ::: pure
   ! Set up defaults
      self :: INOUT

      .name            = " "
      .n_atoms         = 0
      .charge          = 0
      .MO_file_name    = " "
      .transform_group = FALSE
      .rotation_mx = ZERO
      .shift           = ZERO
      .n_MOs           = 0

   end

   set_atom(atom) ::: pure
   ! Set the .atom's to which .atom_index refers.
   ! NOTE: this is a copy, it may go out of date.
      self :: INOUT
      atom :: VEC{ATOM}, IN
      .atom = atom
   end

   set_atom_index(val) ::: pure
   ! Generic set
      self :: INOUT
      val :: VEC{INT}, IN
      .atom_index = val
      .n_atoms    = val.dim
   end

   set_charge(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.charge), pure
   ! Generic set
   end

   set_FChk_file_name(val) ::: PURE
   ! Generic set
      self :: INOUT
      val  :: STR, IN

   ENSURE(val.ends_in("fchk"),"file name does not end in .FChk")

      .FChk_file_name = val

   end

   set_MO_file_name(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.MO_file_name), pure
   ! Generic set
   end

!   set_mol(mol)
!   ! Set the molecule corresponding to .atom_index
!      self :: INOUT
!      mol :: MOLECULE, target, IN
!      .mol => mol
!   end

   set_molden_file_name(val) ::: PURE
   ! Generic set
      self :: INOUT
      val  :: STR, IN

   ENSURE(val.ends_in("molden"),"file name does not end in .molden")

      .molden_file_name = val

   end

   set_n_atoms(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.n_atoms), pure
   ! Generic set
   end

   set_n_MOs(val) ::: get_from(OBJECT:set, VAL?=>INT, ARG?=>.n_MOs), pure
   ! Generic set
   end

   set_name(val) ::: get_from(OBJECT:set, VAL?=>STR, ARG?=>.name), pure
   ! Generic set
   end

   set_one_group ::: PURE
   ! Set up one group comprising all the atoms
      self :: INOUT

   ENSURE(.atom.allocated,"atom list not created")

      i :: INT

      .atom_index = [ (i, i=1,.atom.dim) ]

   end

   set_rotation_mx(val) ::: get_from(OBJECT:set, VAL?=>MAT{REAL}(3,3), ARG?=>.rotation_mx), pure
   ! Generic set
   end

   set_sbf_file_name(val) ::: PURE
   ! Generic set
      self :: INOUT
      val  :: STR, IN

      .sbf_file_name = val

   end

   set_spin_multiplicity(val) ::: PURE
   ! Set the spin multiplicity for the group
      self :: INOUT
      val :: INT, IN

   ENSURE(val/=0,"cannot have zero multiplicity")

      .spin_multiplicity = val
      .spin_multiplicity_set = TRUE

   end

   set_shift(val) ::: get_from(OBJECT:set, VAL?=>VEC{REAL}(3), ARG?=>.shift), pure
   ! Generic set
   end

   set_transform_group(val) ::: get_from(OBJECT:set, VAL?=>BIN, ARG?=>.transform_group), pure
   ! Generic set
   end

!  =======
!  Inquiry
!  =======

   has_wfn_file result (res) ::: elemental
   ! Return TRUE if there is a wavefunction file of some type set.
      self :: IN
      res :: BIN 
      res =    .FChk_file_name /= " " &
          OR    .sbf_file_name /= " " &
          OR .molden_file_name /= " "
   end

   wfn_file result (res) ::: pure
   ! Return TRUE if there is a wavefunction file of some type set.
      self :: IN
      res :: STR

      res = " "
      if      (  .FChk_file_name /= " ") then; res =   .FChk_file_name
      else if (   .sbf_file_name /= " ") then; res =    .sbf_file_name
      else if (.molden_file_name /= " ") then; res = .molden_file_name
      end

   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any further required data needed 
   ! by the "keyword" is inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
      case ("}                 ")  ! exit read_loop
      case ("atom_indices=     "); .read_atom_indices
      case ("charge=           "); .read_charge
      case ("deserialize=      "); .read_sbf_file_name
      case ("fchk_file=        "); .read_FChk_file_name
      case ("fchk_file_name=   "); .read_FChk_file_name
      case ("mo_file=          "); .read_MO_file_name
      case ("mo_file_name=     "); .read_MO_file_name
      case ("molden_file=      "); .read_molden_file_name
      case ("molden_file_name= "); .read_molden_file_name
      case ("multiplicity=     "); .read_multiplicity
      case ("n_mos=            "); .read_n_MOs
      case ("name=             "); .read_name
      case ("rotation=         "); .read_rotation
      case ("sbf_file=         "); .read_sbf_file_name
      case ("shift=            "); .read_shift
      case ("spin_multiplicity="); .read_multiplicity
      case ("transform_group=  "); .read_transform_group
      case default; UNKNOWN(word)
      end

   end

! A

   docu_atom_indices(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("read_atom_indices= VEC{INT}@ ")
      stdout.flush
      stdout.text(". The indices of the atoms in the molecule to which this")
      stdout.text("  object belongs, which define this atom group.")
      if (present(die)) stop
   end

   read_atom_indices ::: leaky
   ! Read the atom atom_indices in the group
      self :: INOUT
      val :: VEC{INT}@

      stdin.read_all(val)
      .set_atom_index(val)
   end

! C

   docu_charge(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("charge= INT ")
      stdout.flush
      stdout.text(". The charge in a.u. associated to this atom group.")
      if (present(die)) stop
   end

   read_charge ::: leaky
   ! Read the charges on the group
      self :: INOUT

      val :: INT

      stdin.read(val)
      .set_charge(val)

   end

! F

   docu_FChk_file_name(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("fchk_file=      STR")
      stdout.text("fchk_file_name= STR")
      stdout.flush
      stdout.text(". The name of the Gaussian FChk file associated with the group of")
      stdout.text("  atoms, which contains electronic structure information, perhaps")
      stdout.text("  needed for further calculations.")
      stdout.flush
      stdout.text(". Any file suffix must also be included.")
      if (present(die)) stop
   end

   read_FChk_file_name ::: leaky
   ! Read the name of gaussian FChk file for group
      self :: INOUT

      val :: STR

      stdin.read(val)
      .set_FChk_file_name(val)

   end

! M

   docu_MO_file_name(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("mo_file=      STR")
      stdout.text("mo_file_name= STR")
      stdout.flush
      stdout.text(". The name of the Tonto file containing the MOs associated with")
      stdout.text("  this group of atoms of atoms, containing electronic structure")
      stdout.text("  information, perhaps needed for further calculations.")
      stdout.flush
      stdout.text(". Any file suffix must also be included.")
      if (present(die)) stop
   end

   read_MO_file_name ::: leaky
   ! Read the name of tonto MO file for group
      self :: INOUT

      val :: STR

      stdin.read(val)
      .set_MO_file_name(val)

   end


   docu_molden_file_name(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("molden_file=      STR")
      stdout.text("molden_file_name= STR")
      stdout.flush
      stdout.text(". The name of the Molden formatted file associated with this")
      stdout.text("  group of atoms, containing electronic structure information")
      stdout.text("  perhaps needed for further calculations.")
      stdout.flush
      stdout.text(". Information concerning the format can be found at: ")
      stdout.text("  www.theochem.ru.nl/molden/molden_format.html")
      if (present(die)) stop
   end

   read_molden_file_name ::: leaky
   ! Read the name of .molden file for the atom group
      self :: INOUT

      val :: STR

      stdin.read(val)
      .set_molden_file_name(val)

   end


   docu_multiplicity(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("multiplicity= INT ")
      stdout.flush
      stdout.text(". The spin multiplicity 2*S+1 associated to this atom group")
      stdout.text("  and which may be needed for electronic structure calcs.")
      if (present(die)) stop
   end

   read_multiplicity ::: leaky
   ! Read the spin multiplicity on the group
      self :: INOUT

      val :: INT

      stdin.read(val)
      .set_spin_multiplicity(val)

   end

! R

   docu_rotation(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("rotation= MAT{REAL}(3,3)")
      stdout.flush
      stdout.text(". A 3x3 rotation matrix, comprising nine numbers entered in")
      stdout.text("  column major order, which is applied to rotate the geometry")
      stdout.text("  orbitals, and density matrix for this atom group before use.")
      stdout.flush
      stdout.text("* Note: the matrix is not allocatable, braces are not needed.")
      if (present(die)) stop
   end

   read_rotation ::: leaky
   ! Read a 3x3 rotation matrix
      self :: INOUT

      val :: MAT{REAL}(3,3)

      stdin.read(val)
      .set_rotation_mx(val)

   end

! S

   docu_sbf_file(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("sbf_file= STR")
      stdout.text("deserialize= STR")
      stdout.flush
      stdout.text(". The name of the Tonto simple binary file (SBF) file used")
      stdout.text("  to store information, perhaps for further calculations.")
      stdout.flush
      stdout.text(". Any file suffix must also be included.")
      if (present(die)) stop
   end

   read_sbf_file_name ::: leaky
   ! Read the name of sbf file for the atom group
      self :: INOUT

      val :: STR

      stdin.read(val)
      .set_sbf_file_name(val)

   end


   docu_shift(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("shift= VEC{REAL}(3)")
      stdout.text("deserialize= STR")
      stdout.flush
      stdout.text(". A 3 vector which is used to translate the geometry of")
      stdout.text("  this atom group before use.")
      stdout.flush
      stdout.text("* Note: the units are assumed in Angstrom.")
      stdout.flush
      stdout.text("* Note: Braces are not needed.")
      if (present(die)) stop
   end

   read_shift ::: leaky
   ! Read shift vector ***in angstrom units***
       self :: INOUT

       val :: VEC{REAL}(3)

       stdin.read(val)
       val = val * BOHR_PER_ANGSTROM

       .set_shift(val)

   end

! N

   docu_n_MOs(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("n_mos= INT")
      stdout.flush
      stdout.text(". An integer describing the number of MOs to use")
      stdout.text("  to make the density matrix")
      stdout.flush
      if (present(die)) stop
   end

   read_n_MOs ::: leaky
   ! Read the number of MOs to use to make the density matrix
      self :: INOUT

      val :: INT

      stdin.read(val)
      .set_n_MOs(val)

   end


   docu_name(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("name= STR")
      stdout.flush
      stdout.text(". A STR used to describe this group of atoms.")
      stdout.flush
      stdout.text(". If not set it may default to group-<formula>,")
      stdout.text("  where <formula> is the chemical formula.")
      stdout.flush
      if (present(die)) stop
   end

   read_name ::: leaky
   ! Read the name for the groups
      self :: INOUT

      val :: STR

      stdin.read(val)
      .set_name(val)

   end

! T

   docu_transform_group(die) ::: selfless, private
   ! Documentation.
      die :: BIN, optional, IN
      stdout.flush
      stdout.flush
      stdout.text("transform_group= BIN")
      stdout.flush
      stdout.text(". Set TRUE if this atom group should be transformed by a")
      stdout.text("  (spacegroup) symmetry operator, in a later calculation.")
      stdout.flush
      if (present(die)) stop
   end

   read_transform_group ::: leaky
   ! Read whether to symmetry-transform a group
      self :: INOUT

      val :: BIN

      stdin.read(val)
      .set_transform_group(val)

   end


!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

end
