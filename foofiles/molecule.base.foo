!===============================================================================
!
! MOLECULE.BASE
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below.
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further.
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! Updated 2014-12-01
!
! .BASE
!     3 .REL
!    16---24 .GRID
!    14---12---- 1 .XTAL
!     2--- |---- |---- 4 .CE =
!     7--- |---- 1---- |-- | .INTS
!    14--- |---- 5---- |-- |---- 2 .FOCK
!    30--- 5---- 4---- 5-- |----10---- 5 .SCF
!     2--- |---- |---- |-- |---- 1---- 5--- 1 .GEM =     =     =
!    11--- |---- |---- 1-- |----15---- 5---13--- | .PROP =     =
!     4--- |---- 6---- |-- |---- 3---- |--- 2--- |---- | .PLOT =
!     4--- |---- 5---- |-- |---- 4---- 2--- 1--- |---- |---- | .CP
!    12--- |---- 7---- |-- |---- |---- |--- 1--- |---- |---- 1-- | .TAD
!    15--- |---- 5---- 1-- |---- 5---- 6--- 5--- |---- |---- |-- |--- 2 .MISC
!    76--- 3---- 3----13-- 7---- 1---- |---13--- 3----19---- 6-- 9---11----24 .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!===============================================================================

module MOLECULE.BASE

   implicit none

   saved_self :: MOLECULE*, private

   debug_list :: VEC{STR}*  DEFAULT_NULL

contains

!  ==================
!  Create and destroy
!  ==================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, recursive
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule

      nullify(.atom)
      nullify(.atoms_bonded_to_atom)
      nullify(.atom_group)

      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      nullify(.plot_grid)
      nullify(.interpolator)
      nullify(.isosurface)

      nullify(.becke_grid)

      nullify(.crystal)
      nullify(.cluster)
      nullify(.cif)
      nullify(.pointgroup)

      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.last_shell_for_atom)
      nullify(.basis_shell_for_shell)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.angular_moment_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.precomputed_basis_shellpair)
      nullify(.max_I)
      nullify(.overlapping_atoms)
      nullify(.overlapping_atoms_for_atom)

      nullify(.scfdata)

      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.old_density_matrix)
      nullify(.delta_density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)
      nullify(.overlap_matrix)
      nullify(.overlap_eigenvectors)
      nullify(.overlap_eigenvalues)
      nullify(.max_S)
      nullify(.kinetic_energy_matrix)
      nullify(.nuclear_attraction_matrix)
      nullify(.core_matrix)
      nullify(.fock_matrix)
      nullify(.fock_2e_matrix)
      nullify(.constraint_matrix)

      nullify(.roby)
      nullify(.saved)
      nullify(.localiser)

      nullify(.U_electric_dipole)
      nullify(.dipole_polarisability)
      nullify(.dipole_hyperpolarisability)
      nullify(.U2_electric_dipole)

      nullify(.force_constants)
      nullify(.normal_mode_eigenvectors)
      nullify(.normal_mode_eigenvalues)
      nullify(.phi3_force_constants)
      nullify(.phi4_force_constants)

   end

   destroy_ptr_part ::: recursive, leaky
   ! Destroy the pointer parts of a molecule object

      ! Saved molecule
      .saved.:destroy

      ! Atoms (nullify pointed-to atoms before)
      .atom.destroy

      ! Atom_groups
      .:destroy_atom_group

      ! Destroy bases and pointed
      .basis.destroy
      .slaterbasis.destroy
      .coppensbasis.destroy

      ! Grids, interpolators & plots
      .plot_grid.destroy
      .interpolator.destroy
      .isosurface.destroy
      .becke_grid.destroy

      ! Crystals and clusters
      .crystal.destroy
      .cluster.destroy
      .cif.destroy
      .pointgroup.destroy

      ! Basis set & integral info arrays
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .basis_shell_for_shell.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .precomputed_basis_shellpair.destroy
      .max_I.destroy
      .overlapping_atoms.destroy
      .overlapping_atoms_for_atom.destroy

      ! SCF data
      .scfdata.destroy

      ! SCF info
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .kinetic_energy_matrix.destroy
      .nuclear_attraction_matrix.destroy

      ! SCF intermediates
      .core_matrix.destroy
      .fock_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

      ! Bond analysis
      .roby.destroy

      ! Localised MO's
      .localiser.destroy

      ! CPHF and response properties
      .U_electric_dipole.destroy
      .dipole_polarisability.destroy
      .dipole_hyperpolarisability.destroy
      .U2_electric_dipole.destroy

      ! Force constants
      .force_constants.destroy
      .normal_mode_eigenvectors.destroy
      .normal_mode_eigenvalues.destroy
      .phi3_force_constants.destroy
      .phi4_force_constants.destroy

   end

   destroy_atom_group ::: recursive, leaky
   ! Destroy the pointer parts of a molecule object

      g :: INT
      mol :: MOLECULE*

      if (.atom_group.disassociated) return

      do g = 1,.atom_group.dim

         mol => .atom_group(g).mol

         if (mol.:destroyed) cycle

         mol.atom.nullify_ptr_part ! do not destroy these
         nullify(mol.basis)        ! do not destroy this
         nullify(mol.slaterbasis)  ! do not destroy this
         nullify(mol.coppensbasis) ! do not destroy this
         nullify(mol.crystal)      ! do not destroy this

         mol.:destroy

      end

      .atom_group.destroy

   end

   destroy_matrices ::: leaky
   ! Destroy the matrices of a molecule object

      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy

      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .kinetic_energy_matrix.destroy
      .nuclear_attraction_matrix.destroy

      .core_matrix.destroy
      .fock_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

      .atom_group.destroy
      .elmo_connection_table.destroy

   end

   save ::: leaky
   ! Save everything about "self" in ".saved".
      self :: PTR

      saved :: MOLECULE*

      ! Save self
      saved => self

      ! Recreate
      .:create

      ! Set .saved
      .saved => saved

   end

   unsave ::: leaky
   ! Revert back to a previously saved molecule stored in .saved, and
   ! destroy everything about the current molecule in "self".
   ! WARNING: be careful when setting up self, make sure none of its pointer
   ! parts refer to .saved information.
      self :: PTR

   ENSURE(.saved.associated,"no previous settings")

      saved :: MOLECULE*

      ! Save .saved
      saved => .saved

      ! Destroy self (not .saved)
      nullify(.saved)
      .:destroy

      ! Restore self
      self => saved

   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(mol) ::: leaky
   ! Set self to be a copy of "mol"
      mol :: MOLECULE, IN

      ! Copy all non-pointer fields
      self = mol

      ! Create a copy of all pointer fields
      .:nullify_ptr_part

      if (mol.atom.associated)                       .atom.create_copy(mol.atom)

      if (mol.basis.associated)                      .basis.create_copy(mol.basis)
      if (mol.slaterbasis.associated)                .slaterbasis.create_copy(mol.slaterbasis)
      if (mol.coppensbasis.associated)               .coppensbasis.create_copy(mol.coppensbasis)

      if (mol.plot_grid.associated)                  .plot_grid.create_copy(mol.plot_grid)
      if (mol.interpolator.associated)               .interpolator.create_copy(mol.interpolator)
      if (mol.isosurface.associated)                 .isosurface.create_copy(mol.isosurface)

      if (mol.becke_grid.associated)                 .becke_grid.create_copy(mol.becke_grid)

      if (mol.crystal.associated)                    .crystal.create_copy(mol.crystal)
      if (mol.cluster.associated)                    .cluster.create_copy(mol.cluster)
      if (mol.cif.associated)                        .cif.create_copy(mol.cif)
      if (mol.pointgroup.associated)                 .pointgroup.create_copy(mol.pointgroup)

      if (mol.saved.:created)                     .saved.:create_copy(mol.saved)

      if (mol.atom_for_shell.associated)             .atom_for_shell.create_copy(mol.atom_for_shell)
      if (mol.atom_shell_for_shell.associated)       .atom_shell_for_shell.create_copy(mol.atom_shell_for_shell)
      if (mol.first_shell_for_atom.associated)       .first_shell_for_atom.create_copy(mol.first_shell_for_atom)
      if (mol.last_shell_for_atom.associated)        .last_shell_for_atom.create_copy(mol.last_shell_for_atom)
      if (mol.first_basis_fn_for_shell.associated)   .first_basis_fn_for_shell.create_copy(mol.first_basis_fn_for_shell)
      if (mol.last_basis_fn_for_shell.associated)    .last_basis_fn_for_shell.create_copy(mol.last_basis_fn_for_shell)
      if (mol.angular_moment_for_shell.associated)   .angular_moment_for_shell.create_copy(mol.angular_moment_for_shell)
      if (mol.overlapping_atoms.associated)          .overlapping_atoms.create_copy(mol.overlapping_atoms)
      if (mol.overlapping_atoms_for_atom.associated) &
         .overlapping_atoms_for_atom.create_copy(mol.overlapping_atoms_for_atom)
      if (mol.first_basis_fn_for_atom.associated)    .first_basis_fn_for_atom.create_copy(mol.first_basis_fn_for_atom)
      if (mol.last_basis_fn_for_atom.associated)     .last_basis_fn_for_atom.create_copy(mol.last_basis_fn_for_atom)

      if (mol.scfdata.associated)                    .scfdata.create_copy(mol.scfdata)

      if (mol.orbital_energies.associated)           .orbital_energies.create_copy(mol.orbital_energies)
      if (mol.molecular_orbitals.associated)         .molecular_orbitals.create_copy(mol.molecular_orbitals)
      if (mol.density_matrix.associated)             .density_matrix.create_copy(mol.density_matrix)
      if (mol.old_density_matrix.associated)         .old_density_matrix.create_copy(mol.old_density_matrix)
      if (mol.delta_density_matrix.associated)       .delta_density_matrix.create_copy(mol.delta_density_matrix)
      if (mol.natural_orbitals.associated)           .natural_orbitals.create_copy(mol.natural_orbitals)
      if (mol.occupation_numbers.associated)         .occupation_numbers.create_copy(mol.occupation_numbers)
      if (mol.overlap_matrix.associated)             .overlap_matrix.create_copy(mol.overlap_matrix)
      if (mol.overlap_eigenvectors.associated)       .overlap_eigenvectors.create_copy(mol.overlap_eigenvectors)
      if (mol.overlap_eigenvalues.associated)        .overlap_eigenvalues.create_copy(mol.overlap_eigenvalues)
      if (mol.max_S.associated)                      .max_S.create_copy(mol.max_S)
      if (mol.kinetic_energy_matrix.associated)      .kinetic_energy_matrix.create_copy(mol.kinetic_energy_matrix)
      if (mol.nuclear_attraction_matrix.associated)  &
         .nuclear_attraction_matrix.create_copy(mol.nuclear_attraction_matrix)

      if (mol.core_matrix.associated)                .core_matrix.create_copy(mol.core_matrix)
      if (mol.fock_matrix.associated)                .fock_matrix.create_copy(mol.fock_matrix)
      if (mol.fock_2e_matrix.associated)             .fock_2e_matrix.create_copy(mol.fock_2e_matrix)
      if (mol.constraint_matrix.associated)          .constraint_matrix.create_copy(mol.constraint_matrix)

      if (mol.atom_group.associated)                 .atom_group.create_copy(mol.atom_group)

      if (mol.U_electric_dipole.associated)          .U_electric_dipole.create_copy(mol.U_electric_dipole)
      if (mol.dipole_polarisability.associated)      .dipole_polarisability.create_copy(mol.dipole_polarisability)
      if (mol.dipole_hyperpolarisability.associated) &
         .dipole_hyperpolarisability.create_copy(mol.dipole_hyperpolarisability)
      if (mol.U2_electric_dipole.associated)         .U2_electric_dipole.create_copy(mol.U2_electric_dipole)

      if (mol.force_constants.associated)            .force_constants.create_copy(mol.force_constants)
      if (mol.normal_mode_eigenvectors.associated)   .normal_mode_eigenvectors.create_copy(mol.normal_mode_eigenvectors)
      if (mol.normal_mode_eigenvalues.associated)    .normal_mode_eigenvalues.create_copy(mol.normal_mode_eigenvalues)
      if (mol.phi3_force_constants.associated)       .phi3_force_constants.create_copy(mol.phi3_force_constants)
      if (mol.phi4_force_constants.associated)       .phi4_force_constants.create_copy(mol.phi4_force_constants)
      if (mol.elmo_connection_table.associated)       .elmo_connection_table.create_copy(mol.elmo_connection_table)

   end

!  ================
!  Specific cleanup
!  ================

   destroy_ANOs ::: leaky
   ! Destroy the ANO's for all atoms in the molecule.

   ENSURE(.atom.associated,"no atoms")

      if (NOT .:has_all_ANOs_made) return

      .atom.destroy_ANOs

   end

   destroy_ANO_interpolators ::: leaky
   ! Destroy the (non-unique) ANO interpolators

   ENSURE(.atom.associated,"no atoms")

      if (NOT .:has_all_ANO_interpolators) return

      .atom.destroy_ANO_interpolators

   end

   destroy_interpolators ::: leaky
   ! Destroy the (unique) interpolators (*not* ANO interpolators)

   ENSURE(.atom.associated,"no atoms")

      if (NOT .:has_all_interpolators) return

      .atom.destroy_interpolators

   end

   destroy_spherical_atom_data ::: leaky
   ! Destroy the restricted atomic natural orbitals (ANO) data for
   ! all atoms in the molecule.

   ENSURE(.atom.associated,"no atoms")

      if (NOT .:has_all_spherical_atom_data) return

      .atom.destroy_spherical_atom_data

   end

   destroy_atom_shell_info ::: leaky
   ! Destroy the atom precomputed shellpair info.

   ENSURE(.atom.associated,"no atoms")

      if (NOT .:has_all_atom_shell_info) return

      .atom.destroy_shell_info

   end

!  SCF

   destroy_scf_results(keep_MOs,keep_DM) ::: leaky
   ! Destroy the SCF results in memory
      self :: INOUT
      keep_MOs,keep_DM :: BIN, optional

      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      if (delete_MOs) .molecular_orbitals.destroy
      if (delete_DM)  .density_matrix.destroy

      .orbital_energies.destroy
      .fock_matrix.destroy

   end

   destroy_tmp_scf_matrices
   ! Destroy any temporary matrices stored in memory.
      self :: INOUT

      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

   end

   destroy_scf_integrals ::: leaky
   ! Destroy all SCF-related integrals in memory.

      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy

      .kinetic_energy_matrix.destroy
      .nuclear_attraction_matrix.destroy
      .core_matrix.destroy

   end

!  ============
!  Set defaults
!  ============

   set_defaults ::: leaky
   ! Set up a default molecule

      .name                = "unknown"
      .charge              = 0
      .spin_multiplicity   = 1
      .n_e                 = 0
      .n_a                 = 0
      .n_b                 = 0
      .E_field             = ZERO
      .B_field             = ZERO
      .gauge_origin        = ZERO

      .n_atom              = 0
      .atom_info_made      = FALSE
      .n_atom_kind         = 0

      .n_bf                = 0
      .basis_name          = " "
      .n_basis             = 0
      .basis_l_max         = -1
      .use_spherical_basis = FALSE
      .n_bf                = 0
      .n_prim              = 0
      .slaterbasis_name    = " "
      .coppensbasis_name   = " "
      .basis_info_made     = FALSE

      .use_interpolators   = TRUE

      .n_shell             = 0
      .n_shell_pairs       = 0
      .n_unique_shells     = 0

      .CX_file_name        = " "
      .CX_uses_angstrom    = FALSE

      .nucleus_model       = "point"

      ! Do want to set this always?
      ! e.g. for .make_mol_from_atom(a) methods?
      .Hirshfeld_atom_info_made     = FALSE
      .uHirshfeld_atom_info_made    = FALSE
      .atomic_polarisabilities_made = FALSE

      if (.atom.associated) then
         .name              = .:chemical_formula
         .spin_multiplicity = .:default_spin_multiplicity
         .:set_atom_info
      end

   end

   set_scf_guess_defaults_from(scfdata) ::: leaky
   ! Set scf  data options for a guess-type SCF defaults
      scfdata :: SCFDATA*

      ! Set the SCF defaults (leaky)
      if (scfdata.disassociated) then
         .:set_scf_defaults
         .scfdata.set_output(FALSE)
      else if (scfdata.use_default_guess_options) then
         .:set_scf_defaults
         .scfdata.set_output(FALSE)
      else
         .:set_scf_defaults(scfdata) ! leaky
      end

      ! Reset some defaults from scfdata, if it is there
      if (scfdata.associated) then
         .scfdata.set_output(scfdata.guess_output)
         .scfdata.set_convergence(scfdata.convergence)
         .scfdata.diis.set_convergence_tolerance(scfdata.diis.convergence_tolerance)
         .scfdata.set_relativity_kind(scfdata.relativity_kind)
      end

      ! Nuclear energy
      .scfdata.nuclear_repulsion_energy = .:nuclear_repulsion_energy

      ! Finalise
      .scfdata.finalize

   end

   set_scf_defaults(scfdata) ::: leaky
   ! Set up scf defaults for molecule
      scfdata :: SCFDATA*, optional

      if (.scfdata.disassociated) then; .scfdata.create
      else;                         .scfdata.set_defaults
      end

      ! Restricted?
      if (.spin_multiplicity==1) .scfdata.set_scf_kind("rhf")
      if (.spin_multiplicity/=1) .scfdata.set_scf_kind("uhf")

      if (present(scfdata)) then

         ! Set defaults from scfdata
         .scfdata = scfdata
         nullify(.scfdata.cluster)
         nullify(.scfdata.cluster_charges)
         nullify(.scfdata.cluster_charge_positions)

         if (.scfdata.scf_kind/=" ") then

            ! Process scfkind , make sure it is sensible
            ! Always use restricted
            if (.scfdata.is_DFT_calculation) then
               if (.spin_multiplicity==1) .scfdata.set_scf_kind("rks")
               if (.spin_multiplicity/=1) then
                ! DIE("cannot yet do ROKS (for, e.g. atomic SCF)")
                  .scfdata.set_scf_kind("uks")
               end
            else
               if (.spin_multiplicity==1) .scfdata.set_scf_kind("rhf")
               if (.spin_multiplicity/=1) then
                  .scfdata.set_scf_kind("uhf")
               !  .scfdata.set_using_diis(FALSE)
               end
            end

         end

      end

      .scfdata.nuclear_repulsion_energy = .:nuclear_repulsion_energy

      if (.scfdata.is_DFT_calculation) .:initialize_DFT_grids

   end

   initialize_DFT_grids ::: leaky
   ! Initialise DFT grids, if not already done so.
   ENSURE(.scfdata.associated,"no scfdata")

      if (.becke_grid.disassociated) then
         .becke_grid.create
         .becke_grid.set_grid_data(.atom)
      end

      .BASE:make_overlapping_atoms

   end

!  ==============
!  Set saved-self
!  ==============

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self
   end

   set_from_saved_self ::: get_from(OBJECT)
   ! Set from saved_self
   end

!  ===========
!  Set methods
!  ===========

   set_name(val)
   ! Set the molecule name
      self :: INOUT
      val :: STR

   DIE_IF(any(ATOM::element_symbols==val),"job name must not be an element symbol")

      .name = val

   end

   set_charge(val) ::: get_from(OBJECT:set, ARG?=>.charge, VAL?=>INT)
   ! Generic set
   end

   set_spin_multiplicity(val)
   ! Set the spin multiplicity
      self :: INOUT
      val :: INT, IN

   ENSURE(val/=0,"cannot have zero multiplicity")

      .spin_multiplicity = val

      if (.atom.associated) then
         .n_a = .BASE:no_of_alpha_electrons
         .n_b = .BASE:no_of_beta_electrons
      end

   end

! Bases

   set_atom_info ::: leaky
   ! Set the associated atom information
   ! . Atom tags and kind indices
   ! . The spin multiplicity
   ! . The number of alpha and beta electrons.
     self :: INOUT

   ENSURE(.atom.associated,"no atom info")

      if (.atom_info_made) return

      ! Finalize 
      .atom.update

      ! No. of atoms
      .n_atom = .atom.dim

      ! No. of atom kinds
      .n_atom_kind = maxval(.atom.kind)

      ! Reset multiplicity?
      if (NOT .:has_valid_no_of_beta_electrons) then
      !  WARN("Inconsistent charge and multiplicity")
      !  WARN("Reassigning the multiplicity")
         .spin_multiplicity = .:default_spin_multiplicity
      end

      ! Now can set # of electrons
      .n_e = .:no_of_electrons
      .n_a = .:no_of_alpha_electrons
      .n_b = .:no_of_beta_electrons

      ! Make connetion table
      .:make_atom_connections

      .atom_info_made = TRUE

   end

   resolve_basis_info ::: leaky
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any finalization procedures to fully define all objects.
   ! This version is supposed to work for multiple bases.
      .:resolve_coppensbases
      .:resolve_slaterbases
      .:resolve_gaussianbases
   end

   resolve_gaussianbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.disassociated) return

      if (.n_atom<1) return

      if (.atom.bases_are_resolved) return

      ! Resolve from a library .....
      if (.basis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.basis.associated) .basis.renormalise

         ! Read the basis from the library
         library = .basis.library_file(.basis_name)
         library_basis_labels => .atom.library_basis_labels(.basis_name)

         .basis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.basis.associated) then

            .basis.set_spherical(.use_spherical_basis)
            .atom.resolve_bases(.basis,.basis_name)
            .atom.set_basis_kind("gaussian")

            ! Unnormalise if completely done
            .basis.unnormalise

            .:set_basis_info

         end

      ! Resolve from existing .basis .....
      else if (.basis.associated) then

            .basis.set_spherical(.use_spherical_basis)
            .atom.resolve_bases(.basis)
            .atom.set_basis_kind("gaussian")

            ! Unnormalise if completely done
            if (.atom.bases_are_resolved) .:set_basis_info

      end

      if (.basis.associated) then
      if (NOT .atom.bases_are_resolved) then
         stdout.flush
         WARN("not all Gaussian bases were resolved")
      end
      end

   end

   resolve_slaterbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.disassociated) return

      if (.n_atom<1) return

      if (.atom.slaterbases_are_resolved) return

      ! Resolve from a library .....
      if (.slaterbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.slaterbasis.associated) .slaterbasis.renormalise

         ! Read the basis from the library
         library = .slaterbasis.library_file(.slaterbasis_name)
         library_basis_labels => .atom.library_basis_labels(.slaterbasis_name)
         .slaterbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.slaterbasis.associated) then
            .atom.resolve_bases(.slaterbasis,.slaterbasis_name)
            .atom.set_basis_kind("slater")

            ! Unnormalise if completely done
            .slaterbasis.unnormalise
         end

      ! Resolve from existing .basis .....
      else if (.slaterbasis.associated) then

            .atom.resolve_bases(.slaterbasis)
            .atom.set_basis_kind("slater")

      end

      if (.slaterbasis.associated) then
      if (NOT .atom.slaterbases_are_resolved) then
         stdout.flush
         WARN("not all Slater bases were resolved")
      end
      end

   end

   resolve_coppensbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.disassociated) return

      if (.n_atom<1) return

      if (.atom.coppensbases_are_resolved) return

      ! Resolve from a library .....
      if (.coppensbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.coppensbasis.associated) .coppensbasis.renormalise

         ! Read the basis from the library
         library = .coppensbasis.library_file(.coppensbasis_name)
         library_basis_labels => .atom.library_basis_labels(.coppensbasis_name)
         .coppensbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.coppensbasis.associated) then
            .atom.resolve_bases(.coppensbasis,.coppensbasis_name)
            .atom.set_basis_kind("coppens")

            ! Unnormalise if completely done
            .coppensbasis.unnormalise
         end

      ! Resolve from existing .basis .....
      else if (.coppensbasis.associated) then

            .atom.resolve_bases(.coppensbasis)
            .atom.set_basis_kind("coppens")

      end

      if (.coppensbasis.associated) then
      if (NOT .atom.coppensbases_are_resolved) then
         stdout.flush
         WARN("not all Coppens bases were resolved")
      end
      end

   end

   set_basis_directory(directory)
   ! Set the basis directory (for all kinds of bases)
      directory :: STR, IN

      .basis.set_library_directory(directory)
      .slaterbasis.set_library_directory(directory)
      .coppensbasis.set_library_directory(directory)

   end

   set_basis_info ::: leaky
   ! Set the molecule basis set information; the atom list must exist.
   ENSURE(.atom.associated,"no atom info")

      if (.basis.disassociated) return

      if (NOT .atom.bases_are_resolved) then

         .basis_info_made = FALSE

      else

         .n_basis       = .basis.dim
         .n_bf          = .atom.no_of_basis_functions
         .n_prim        = .atom.no_of_primitives
         .n_shell       = .atom.no_of_shells
         .n_shell_pairs = .atom.no_of_shell_pairs

         ! Make shell-basis-function limts, etc. (keaky)
         .:make_shell_info

         .basis_info_made = TRUE

      end

   end

   set_basis_name(name) ::: leaky
   ! Set a gaussian *library* basis set name
      name :: STR

 ! DIE_IF(any(name==non_gaussian),"basis "//trim(name)//"is not a gaussian basis")

 !    non_gaussian :: VEC{STR}(len=17,4) = &
 !       ["Clementi-Roetti  ", &
 !        "Thakkar          ", &
 !        "vanLenthe-Barends", &
 !        "Coppens          "  ]

      ! Set the basis kind
      .basis_name = name

      ! Destroy links to previous bases
      if (.atom.associated) .atom.nullify_basis_part
      .basis.destroy

      ! Make fresh basis set links (might be leaky)
      .:resolve_gaussianbases

   end

   set_slaterbasis_name(name) ::: leaky
   ! Set a slater *library* basis set name
      name :: STR

 ! DIE_IF(all(name/=slater),"basis "//trim(name)//"is not a known slater basis")

 !    slater :: VEC{STR}(len=17,3) = &
 !       ["Clementi-Roetti  ",       &
 !        "Thakkar          ",       &
 !        "vanLenthe-Barends"        ]

      ! Set the basis kind
      .slaterbasis_name = name

      ! Destroy links to previous bases
      if (.atom.associated) .atom.nullify_slaterbasis_part
      .slaterbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .:resolve_slaterbases

   end

   set_coppensbasis_name(name) ::: leaky
   ! Set a coppens *library* basis set name
      name :: STR

   ENSURE(name=="Coppens","basis "//trim(name)//"is not a known coppens basis")

      ! Set the basis kind
      .coppensbasis_name = name

      ! Destroy links to previous bases
      if (.atom.associated) .atom.nullify_coppensbasis_part
      .coppensbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .:resolve_coppensbases

   end

! Axes

   resolve_axis_system ::: PURE
   ! Change the axis system to cartesian, if required.
   ! NOTE: Errors (if any) are transformed straightforwardly
      self :: INOUT

      if (.crystal.disassociated) return
      if (.atom.disassociated)    return

      .atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

   end

   change_axis_system_to
   ! Change the axis system.
   ! NOTE: Errors (if any) are transformed straightforwardly
      self :: INOUT

      axis_system :: STR

      if (.crystal.disassociated) return
      if (.atom.disassociated)    return

      stdin.read(axis_system)

      .atom.change_axis_system_to(axis_system,.crystal.unit_cell,FALSE)

   end

   set_scf_occupations(NO_kind) ::: PURE
   ! Set the SCF occupation numbers for the natural orbitals
      self :: INOUT
      NO_kind :: STR, IN

      select case (NO_kind)

      case ("restricted")
         .occupation_numbers.restricted(1:.n_a) = TWO

      case ("unrestricted")
         .occupation_numbers.alpha(1:.n_a) = ONE
         .occupation_numbers.beta(1:.n_b)  = ONE

      case ("general")
         .occupation_numbers.general(1:.n_e) = ONE

      case ("restricted_complex")
         .occupation_numbers.restricted(1:.n_a) = TWO

      case ("unrestricted_complex")
         .occupation_numbers.alpha(1:.n_a) = ONE
         .occupation_numbers.beta(1:.n_b)  = ONE

      case ("general_complex")
         .occupation_numbers.general(1:.n_e) = ONE

      end

   end

   set_force_constants(fc) ::: leaky
   ! Set the .force_constants to the flat array "fc".
   ! Since it is a symmetric matrix the order does not matter.
      fc :: VEC{REAL}, IN

   ENSURE(.atom.associated,"no atom list")
   ENSURE(fc.dim==9*.atom.dim*.atom.dim,"wrong size, fc")

      n3n :: INT

      ! Create space
      n3n = 3*.atom.dim
      .force_constants.destroy
      .force_constants.create(n3n,n3n)

      ! Reshape
      .force_constants = reshape(fc,[n3n,n3n])

   end

!  ============
!  Read routine
!  ============

   read_CIF_ADPs(cif) ::: leaky
   ! Read atom ADP information from a Crystallographic Information File, "cif".
      cif :: CIF

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")
   ENSURE(.crystal.associated,"must have crystal information")

      if (NOT cif.file.is_open) cif.open

      .atom.read_CIF_ADPs(cif)

      .:resolve_axis_system

   end

!  ===================
!  Redirect and revert
!  ===================

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   redirect_stdout ::: leaky
   ! Redirect stdout to the file whose name is the following string
   ! in the current input file.

      name :: STR

      if (FALSE) self = self

      stdin.read(name)
      stdout.redirect(name)

   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   revert_stdout ::: leaky
   ! Revert stdout back to the previously stored input file
      if (FALSE) self = self
      stdout.revert
   end

!  ==================
!  Read/write archive
!  ==================

   read_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g.  "restricted".
   ! For use with TONTO generated archives.
   ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR

      stdin.read(name)
      stdin.read(genre)

      stdout.text("reading archive : " // trim(name))
      .:read_archive(name,genre)

   end

   read_archive(name,genre) ::: leaky
   ! Read the archive called "name" with "genre", e.g. "restricted".
   ! For use with TONTO generated archives.
      name,genre :: STR, IN

   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      arch :: ARCHIVE

      ! Set the archive "name" & "genre"
      arch.set(.name,name,genre=genre)

      ! Read the archive
      select case (name)

         case ("molecular_orbitals")
            if (.molecular_orbitals.disassociated) .molecular_orbitals.create(.n_bf)
            arch.read(.molecular_orbitals)

         case ("density_matrix    ")
            if (.density_matrix.disassociated) .density_matrix.create(.n_bf)
            arch.read(.density_matrix)

         case ("MP2_density_matrix")
            if (.density_matrix.disassociated) .density_matrix.create(.n_bf)
            arch.read(.density_matrix)

         case ("MP3_density_matrix")
            if (.density_matrix.disassociated) .density_matrix.create(.n_bf)
            arch.read(.density_matrix)

         case ("fock_matrix       ")
            if (.fock_matrix.disassociated) .fock_matrix.create(.n_bf)
            arch.read(.fock_matrix)

         case ("orbital_energies  ")
            if (.orbital_energies.disassociated) .orbital_energies.create(.n_bf)
            arch.read(.orbital_energies)

         case ("natural_orbitals  ")
            if (.natural_orbitals.disassociated) .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals)

         case ("occupation_numbers")
            if (.occupation_numbers.disassociated) .occupation_numbers.create(.n_bf)
            arch.read(.occupation_numbers)

         case ("covalent_orbitals ")
            if (.natural_orbitals.disassociated) .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals)

         case ("ionic_orbitals    ")
            if (.natural_orbitals.disassociated) .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals)

         case ("U_electric_dipole ")
            if (.U_electric_dipole.disassociated) .U_electric_dipole.create(.n_bf,.n_bf,3)
            arch.read(.U_electric_dipole)

         case ("U2_electric_dipole ")
            if (.U2_electric_dipole.disassociated) .U2_electric_dipole.create(.n_bf,.n_bf,6)
            arch.read(.U2_electric_dipole)

         case default
            UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   read_ascii_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g. "restricted".
   ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR
      arch :: ARCHIVE

      ! Read archive name & genre
      stdin.read(name)
      stdin.read(genre)

      ! Set archive "name", "genre" & ascii format
      arch.set(.name,name,genre=genre,format="ascii")

      ! Read the archive
      select case (name)

         case ("molecular_orbitals")
            if (.molecular_orbitals.disassociated) .molecular_orbitals.create(.n_bf)
            arch.read(.molecular_orbitals,by_column=TRUE)

         case ("density_matrix    ")
            if (.density_matrix.disassociated)     .density_matrix.create(.n_bf)
            arch.read(.density_matrix,by_column=TRUE)

         case ("MP2_density_matrix")
            if (.density_matrix.disassociated)     .density_matrix.create(.n_bf)
            arch.read(.density_matrix,by_column=TRUE)

         case ("MP3_density_matrix")
            if (.density_matrix.disassociated)     .density_matrix.create(.n_bf)
            arch.read(.density_matrix,by_column=TRUE)

         case ("orbital_energies  ")
            if (.orbital_energies.disassociated)   .orbital_energies.create(.n_bf)
            arch.read(.orbital_energies)

         case ("natural_orbitals  ")
            if (.natural_orbitals.disassociated)   .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals,by_column=TRUE)

         case ("occupation_numbers")
            if (.occupation_numbers.disassociated) .occupation_numbers.create(.n_bf)
            arch.read(.occupation_numbers)

         case ("covalent_orbitals ")
            if (.natural_orbitals.disassociated)   .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals,by_column=TRUE)

         case ("ionic_orbitals    ")
            if (.natural_orbitals.disassociated)   .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals,by_column=TRUE)

         case ("fock_matrix       ")
            if (.fock_matrix.disassociated)        .fock_matrix.create(.n_bf)
            arch.read(.fock_matrix,by_column=TRUE)

         case default
            UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   write_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.

      name :: STR
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set archive "name"
      arch.set(.name,name)

      ! Write the archive, "genre" from object
      select case (name)

         case ("molecular_orbitals")
            DIE_IF(.molecular_orbitals.disassociated,"no molecular_orbitals")
            arch.write(.molecular_orbitals)

         case ("density_matrix    ")
            DIE_IF(.density_matrix.disassociated,"no density_matrix")
            arch.write(.density_matrix)

         case ("natural_orbitals  ")
            DIE_IF(.natural_orbitals.disassociated,"no natural_orbitals")
            arch.write(.natural_orbitals)

         case ("occupation_numbers")
            DIE_IF(.occupation_numbers.disassociated,"no occupation_numbers")
            arch.write(.occupation_numbers)

         case ("fock_matrix       ")
            DIE_IF(.fock_matrix.disassociated,"no fock_matrix")
            arch.write(.fock_matrix)

         case ("orbital_energies  ")
            DIE_IF(.orbital_energies.disassociated,"no orbital_energies")
            arch.write(.orbital_energies)

         case ("U_electric_dipole ")
            DIE_IF(.U_electric_dipole.disassociated,"no U_electric_dipole")
            arch.write(.U_electric_dipole)

         case ("U2_electric_dipole ")
            DIE_IF(.U2_electric_dipole.disassociated,"no U2_electric_dipole")
            arch.write(.U2_electric_dipole)

         case default
            UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   write_ascii_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.

      name :: STR
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set the archive "name" and ascii format
      arch.set(.name,name,format="ascii")

      ! Write the archive, "genre" from object
      select case (name)
         case ("molecular_orbitals"); arch.write(.molecular_orbitals,by_column=TRUE)
         case ("density_matrix    "); arch.write(.density_matrix,    by_column=TRUE)
         case ("natural_orbitals  "); arch.write(.natural_orbitals,  by_column=TRUE)
         case ("occupation_numbers"); arch.write(.occupation_numbers,by_column=TRUE)
         case ("fock_matrix       "); arch.write(.fock_matrix,       by_column=TRUE)
         case ("orbital_energies  "); arch.write(.orbital_energies,  by_column=TRUE)
         case default;     UNKNOWN(name)
      end

      ! Clean up
      arch.close

   end

!  ================
!  Molden interface
!  ================

   read_molden_MOs(file_name) ::: leaky
   ! Read a Molden MOs file
      file_name :: STR, optional

      molden_file,save :: TEXTFILE*
      archive :: ARCHIVE
      pos :: VEC{REAL}(3)
      orb :: VEC{REAL}*
      fac,n_e,val,energy,occ :: REAL
      name,units,item,label,spin :: STR
      op,cl :: STR(len=1)
      found,is_unrestricted :: BIN
      line, a,i,f,Z :: INT

      ! Get file name
      if (present(file_name)) then;              name = file_name
      else if (NOT stdin.buffer_exhausted) then; stdin.read(name)
      else;                                      name = .name
      end

      ! Constants
      op = achar(91)
      cl = achar(93)

      ! Open Molden file
      molden_file.create(name)
      molden_file.open_for("read")

      ! Find out if this file is using a spherical basis
      line = molden_file.line_number
      molden_file.look_for(op//"5D"//cl,found=found)
      if(found) .use_spherical_basis = TRUE
      molden_file.move_to_line(line)

      ! Find [ATOMS] block
      ! or [Atoms]
      molden_file.look_for(op//"Atoms"//cl,found=found)
      if(NOT found) molden_file.look_for(op//"ATOMS"//cl,found=found)
      DIE_IF(NOT found, "No ATOMS line")
      DIE_IF(molden_file.n_line_items/=2, "Expecting two items on ATOMS line")

      ! Read units
      molden_file.read(units)
      fac = ONE
      if (units=="Angs") fac = BOHR_PER_ANGSTROM

      ! Store start of atoms list
      molden_file.read_line
      line = molden_file.line_number

      ! Get no. of atoms ...
      .n_atom = 0
      do
         molden_file.read(item)
         if (item(1:1)==op) exit
         DIE_IF(molden_file.end_of_file,"file ended unexpectedly")
         .n_atom = .n_atom + 1
         molden_file.read_line
      end

      ! Create atom list (leaky)
      if (.atom.associated)  .atom.destroy
      .atom.create(.n_atom)

      ! Create basis -- Different one for every atom (leaky)
      if (.basis.associated) .basis.destroy
      .basis.create(.n_atom)
      if(.use_spherical_basis) .basis.set_spherical(TRUE)

      ! Move back to atoms line
      molden_file.move_to_line(line)

      ! For each atom a: read label, Z, coordinates
      do a = 1,.n_atom

         ! Read label
         molden_file.read(label)

         ! Read Z
         molden_file.skip_next_item
         molden_file.read(Z)

         ! Set
         .atom(a).set_atomic_number(Z)
         .atom(a).set_atom_data_from_label(label)

         ! Read position, change units
         molden_file.read(pos)
         pos = fac*pos
         .atom(a).set_position(pos)

         ! Set basis label
         .atom(a).set_basis_label("molden-"//trim(.atom(a).generic_chemical_symbol))

      end

      ! Read basis set
      molden_file.look_for(op//"GTO"//cl,found=found)
      DIE_IF(NOT found, "No GTO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on GTO line")
      molden_file.read_line

      ! Read basis
      save => stdin
      stdin => molden_file
      do a = 1,.n_atom
         .basis(a).read_molden
         .basis(a).set_label(.atom(a).basis_label)
      end
      stdin => save

      ! Remove repetitions
    ! .basis.remove_repetitions

      ! Find [MO] tag
      molden_file.look_for(op//"MO"//cl,found=found)
      DIE_IF(NOT found, "No MO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on MO line")
      line = molden_file.line_number + 1

      ! Any Beta tag?
      molden_file.look_for("Beta",found=is_unrestricted)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)

      ! Get no. of electrons
      n_e = ZERO
      do
         molden_file.look_for("Occup=",found=found)
         if (NOT found) exit
         molden_file.move_to_line_item(2)
         molden_file.read(val)
         molden_file.read_line
         n_e = n_e + val
      end

      ! Now set charge
      .charge = .atom.no_of_electrons - nint(n_e)

      ! Set multiplicity
      .spin_multiplicity = .:default_spin_multiplicity

      ! Finally: set atom info & basis info
      .:set_atom_info
      .:finalize_atom_groups
      .:resolve_basis_info

      .atom.put

      ! Create scfdata (leaky)
      .scfdata.destroy
      .scfdata.create

      ! Create MO arrays (leaky)
      .orbital_energies.destroy
      .molecular_orbitals.destroy

      if (is_unrestricted) then

         .scfdata.set_scf_kind("uhf")

         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.beta = ZERO

         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.beta = ZERO

      else

         .scfdata.set_scf_kind("rhf")

         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO

         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO

      end

      ! Set occupation numbers (leaky)
      spin = .scfdata.spinorbital_kind
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,spin)
      .occupation_numbers.set_to_zero
      .:set_scf_occupations(spin)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)
      orb.create(.n_bf)

      ! Read in orbitals and energies.
      i = 0
      do

         molden_file.look_for("Ene=",found=found)

         if (NOT found) exit

         ! Read energy
         molden_file.skip_next_item
         molden_file.read(energy)

         ! Read spin
         molden_file.skip_next_item
         molden_file.read(spin)

         ! Read occupation
         molden_file.skip_next_item
         molden_file.read(occ)

         ! Read orbital
         do f = 1,.n_bf
            molden_file.skip_next_item
            molden_file.read(orb(f))
         end
         stdout.show("Read orbital", i)
         stdout.show("orb:", orb)

         ! Increment orbital
         if (spin=="Alpha") i = i + 1
         DIE_IF(i>.n_bf,"too many orbitals specified")

         ! Assign MO's
         if (is_unrestricted) then

            select case (spin)
               case ("Alpha")
                  .orbital_energies.alpha(i) = energy
                  .molecular_orbitals.alpha(:,i) = orb
               case ("Beta")
                  .orbital_energies.beta(i) = energy
                  .molecular_orbitals.beta(:,i) = orb
               case default
                  DIE("unknown spin: "//trim(spin))
            end

         else

            select case (spin)
               case ("Alpha")
                  .orbital_energies.restricted(i) = energy
                  .molecular_orbitals.restricted(:,i) = orb
               case default
                  DIE("unexpected spin: "//trim(spin))
            end

         end

      end

      ! Clean
      orb.destroy

      ! Swap orbital order
      stdout.text("Reordering basis functions into tonto order")
      if (is_unrestricted) then
         .:swap_molden_orbital_order(.molecular_orbitals.alpha,"row")
         .:swap_molden_orbital_order(.molecular_orbitals.beta,"row")
      else
         .:swap_molden_orbital_order(.molecular_orbitals.restricted,"row")
      end


      ! Make density matrix (leaky)
      .:make_scf_density_matrix
      stdout.text("Occupation")
      stdout.put(.occupation_numbers)
      !if(NOT .natural_orbitals.associated) .:make_natural_orbitals

      ! Print out data
      stdout.flush
      stdout.text("===========")
      stdout.text("Molden data")
      stdout.text("===========")
      stdout.flush
      stdout.text("Below are the molden:")
      stdout.text(". Atom coordinates and bases")
      stdout.text(". Molecular orbitals and their occupancies")
      stdout.flush
      if (is_unrestricted) then; stdout.text("The data is for *unrestricted* orbitals")
      else;                      stdout.text("The data is for *restricted* orbitals")
      end

      stdout.flush
      stdout.text("Molden atom coordinates and bases:")
      .:put_atoms

      stdout.flush
      stdout.text("Occupation numbers:")
      stdout.flush
      stdout.put(.occupation_numbers)

      stdout.flush
      stdout.text("Orbital energies:")
      stdout.flush
      stdout.put(.orbital_energies)

      stdout.flush
      stdout.text("Density matrix:")
      stdout.flush
      stdout.put(.density_matrix)

      stdout.flush
      !.SCF:make_fock_matrix
      !.SCF:put_scf_energy
      stdout.flush

     !stdout.flush
     !stdout.text("Natural orbitals:")
     !stdout.flush
     !stdout.put(.natural_orbitals)

      ! Save data in archive files
      archive.set_defaults

      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)

      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)

      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      ! Set crystal data
      if (associated(.crystal)) then
         .:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

      ! Clean
      molden_file.destroy

   end

   read_molden_NOs(file_name) ::: leaky
   ! Read a Molden natural orbitals file.
   ! Here the occupation numbers are not integers.
      file_name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      molden_file,save :: TEXTFILE*
      archive :: ARCHIVE
      pos :: VEC{REAL}(3)
      orb :: VEC{REAL}*
      fac,n_e,val,energy,occ :: REAL
      name,units,item,label,spin :: STR
      op,cl :: STR(len=1)
      found,is_unrestricted :: BIN
      line, a,i,f,Z :: INT

      ! Get file name
      if (present(file_name)) then;              name = file_name
      else if (NOT stdin.buffer_exhausted) then; stdin.read(name)
      else;                                      name = .name
      end

      ! Constants
      op = achar(91)
      cl = achar(93)

      ! Open Molden file
      molden_file.create(name)
      molden_file.open_for("read")

      ! Find [ATOMS] block
      molden_file.look_for(op//"ATOMS"//cl,found=found)
      DIE_IF(NOT found, "No ATOMS line")
      DIE_IF(molden_file.n_line_items/=2, "Expecting two items on ATOMS line")

      ! Read units
      molden_file.read(units)
      fac = ONE
      if (units=="Angs") fac = BOHR_PER_ANGSTROM

      ! Store start of atoms list
      molden_file.read_line
      line = molden_file.line_number

      ! Get no. of atoms ...
      .n_atom = 0
      do
         molden_file.read(item)
         if (item==op//"Molden") exit
         DIE_IF(molden_file.end_of_file,"file ended unexpectedly")
         .n_atom = .n_atom + 1
         molden_file.read_line
      end

      ! Create atom list (leaky)
      if (.atom.associated)  .atom.destroy
      .atom.create(.n_atom)

      ! Create basis -- Different one for every atom (leaky)
      if (.basis.associated) .basis.destroy
      .basis.create(.n_atom)

      ! Move back to atoms line
      molden_file.move_to_line(line)

      ! For each atom a: read label, Z, coordinates
      do a = 1,.n_atom

         ! Read label
         molden_file.read(label)

         ! Read Z
         molden_file.skip_next_item
         molden_file.read(Z)

         ! Set
         .atom(a).set_atomic_number(Z)
         .atom(a).set_atom_data_from_label(label)

         ! Read position, change units
         molden_file.read(pos)
         pos = fac*pos
         .atom(a).set_position(pos)

         ! Set basis label
         .atom(a).set_basis_label("molden-"//trim(.atom(a).generic_chemical_symbol))

      end

      ! Read basis set
      molden_file.look_for(op//"GTO"//cl,found=found)
      DIE_IF(NOT found, "No GTO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on GTO line")
      molden_file.read_line

      ! Read basis
      save => stdin
      stdin => molden_file
      do a = 1,.n_atom
         .basis(a).read_molden
         .basis(a).put
         .basis(a).set_label(.atom(a).basis_label)
      end
      stdin => save

      ! Find [MO] tag
      molden_file.look_for(op//"MO"//cl,found=found)
      DIE_IF(NOT found, "No MO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on MO line")
      line = molden_file.line_number + 1

      ! Any Beta tag?
      molden_file.look_for("Beta",found=is_unrestricted)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)

      ! Get no. of electrons
      n_e = ZERO
      do
         molden_file.look_for("Occup=",found=found)
         if (NOT found) exit
         molden_file.move_to_line_item(2)
         molden_file.read(val)
         molden_file.read_line
         n_e = n_e + val
      end

      ! Now set charge
      .charge = .atom.no_of_electrons - nint(n_e)

      ! Set multiplicity
      .spin_multiplicity = .:default_spin_multiplicity

      ! Finally: set atom info & basis info (leaky)
      .:set_atom_info
      .:finalize_atom_groups
      .:resolve_basis_info

      ! Create MO arrays (leaky)
      .density_matrix.destroy
      .occupation_numbers.destroy
      .natural_orbitals.destroy

      if (is_unrestricted) then

         .occupation_numbers.create(.n_bf,"unrestricted")
         .occupation_numbers.alpha = ZERO
         .occupation_numbers.beta = ZERO

         .density_matrix.create(.n_bf,"unrestricted")
         .natural_orbitals.create(.n_bf,"unrestricted")
         .natural_orbitals.alpha = ZERO
         .natural_orbitals.beta = ZERO

      else

         .occupation_numbers.create(.n_bf,"restricted")
         .occupation_numbers.restricted = ZERO

         .density_matrix.create(.n_bf,"unrestricted")
         .natural_orbitals.create(.n_bf,"restricted")
         .natural_orbitals.restricted = ZERO

      end

      ! Move back to [MO]'s
      molden_file.move_to_line(line)
      orb.create(.n_bf)

      ! Read in orbitals and energies.
      i = 0
      do

         molden_file.look_for("Ene=",found=found)

         if (NOT found) exit

         ! Read energy
         molden_file.skip_next_item
         molden_file.read(energy)

         ! Read spin
         molden_file.skip_next_item
         molden_file.read(spin)

         ! Read occupation
         molden_file.skip_next_item
         molden_file.read(occ)

         ! Read orbital
         do f = 1,.n_bf
            molden_file.skip_next_item
            molden_file.read(orb(f))
         end

         ! Increment orbital
         if (spin=="Alpha") i = i + 1
         DIE_IF(i>.n_bf,"too many orbitals specified")

         ! Assign MO's
         if (is_unrestricted) then

            select case (spin)
               case ("Alpha")
                  .occupation_numbers.alpha(i) = occ
                  .natural_orbitals.alpha(:,i) = orb
               case ("Beta")
                  .occupation_numbers.beta(i) = occ
                  .natural_orbitals.beta(:,i) = orb
               case default
                  DIE("unknown spin: "//trim(spin))
            end

         else

            select case (spin)
               case ("Alpha")
                  .occupation_numbers.restricted(i) = occ
                  .natural_orbitals.restricted(:,i) = orb
               case default
                  DIE("unexpected spin: "//trim(spin))
            end

         end

      end

      ! Clean
      orb.destroy

      ! Swap orbital order
      if (is_unrestricted) then
         .:swap_molden_orbital_order(.natural_orbitals.alpha,"row")
         .:swap_molden_orbital_order(.natural_orbitals.beta,"row")
      else
         .:swap_molden_orbital_order(.natural_orbitals.restricted,"row")
      end


      ! Make density matrix
      if (is_unrestricted) then
         .:make_density_matrix_from(.natural_orbitals,.occupation_numbers,"unrestricted")
      else
         .:make_density_matrix_from(.natural_orbitals,.occupation_numbers,"restricted")
      end

      ! Print out data
      stdout.flush
      stdout.text("===========")
      stdout.text("Molden data")
      stdout.text("===========")
      stdout.flush
      stdout.text("Below are the data read from the molden file:")
      stdout.text(". Atom coordinates and bases")
      stdout.text(". Natural orbitals and their occupancies")
      stdout.flush
      if (is_unrestricted) then; stdout.text("The data is for *restricted* orbitals")
      else;                      stdout.text("The data is for *unrestricted* orbitals")
      end

      stdout.flush
      stdout.text("Molden atom coordinates and bases:")
      .:put_atoms

      stdout.flush
      stdout.text("Occupation numbers:")
      stdout.flush
      stdout.put(.occupation_numbers)

      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.flush
      stdout.put(.natural_orbitals)

      ! Save data in archive files
      archive.set_defaults

      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)

      archive.set(.name,"natural_orbitals")
      archive.write(.natural_orbitals)

      archive.set(.name,"occupation_numbers")
      archive.write(.occupation_numbers)

      ! Set crystal data
      if (associated(.crystal)) then
         .:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

      ! Clean
      molden_file.destroy

   end

   swap_molden_orbital_order(X,swap)
   ! Swap the order of orbitals on matrix "X" after reading a
   ! molden input file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2".  This is nearly the same as gaussian.
   !
   ! The molden orderring is as follows:
   !  5D: D 0, D+1, D-1, D+2, D-2
   !  6D: xx, yy, zz, xy, xz, yz
   !  7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
   ! 10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
   !  9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
   ! 15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy,
   !      xxyy xxzz yyzz xxyz yyxz zzxy
      X :: MAT{REAL}
      swap :: STR

      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}*
      ff :: VEC{INT}(10) = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 /)
      sph_reorder :: VEC{INT}@

      select case (swap)

         case("row","1")
            do s = 1,.n_shell
               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)
               if(.atom(.atom_for_shell(s)).basis.is_spherical) then
                  ! do spherical test
                  sph_reorder = GAUSSIAN_DATA:tonto_to_gaussian_spherical_indices(ls)
                  stdout.show("Reordering: ", sph_reorder)
                  if (ls>=1) then ! swap f functions
                     X(f:l,:) = X(f-1+sph_reorder,:)
                  end
                  if (ls>1) then  ! normalisation factors
                     lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                     fg = lg + 1
                     lg = lg + GAUSSIAN_DATA:n_comp(ls)
                     fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                     do i = f,l
                        X(i,:) = X(i,:)*fac(i-f+1)
                     end
                  end
               else
                  ENSURE(ls<=4,"cannot yet convert order for h shells")
                  if (ls==3) then ! swap f functions
                     X(f:l,:) = X(f-1+ff,:)
                  end
                  if (ls>1) then  ! normalisation factors
                     lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                     fg = lg + 1
                     lg = lg + GAUSSIAN_DATA:n_comp(ls)
                     fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                     do i = f,l
                        X(i,:) = X(i,:)*fac(i-f+1)
                     end
                  end
               end
            end

         case("column","2")
            do s = 1,.n_shell
               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)
               ENSURE(ls<=4,"cannot yet convert order for h shells")
               if (ls==3) then ! swap f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
               if (ls>1) then  ! normalisation factors
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do j = f,l
                     X(:,j) = X(:,j)*fac(j-f+1)
                  end
               end
            end

         case default
            DIE("unknown swap kind, "//trim(swap))

      end

   end

!  ======================
!  Gaussian chk interface
!  ======================

! Read *only* Tonto MO's and density from g09

   read_tonto_FChk_file(name) ::: leaky
   ! Read the MO's and density matrix from a g09 checkpoint file
   ! as if these were just placed there in TONTO format.
   ! WARNING: only works for restricted
      self :: INOUT
      name :: STR, optional

   DIE_IF(NOT .basis_info_made,"must be a tonto basis set!")

      chkfile :: TEXTFILE*
      fchk :: STR

      ! Get FChk file name
      if (present(name)) then
         fchk = name
      else if (NOT stdin.buffer_exhausted) then
         stdin.read(fchk) ! specified on stdin
      else
         fchk = .name
      end

      ! Create FChk file
      chkfile.create(name)

    ! ! Create orbital energies.
    ! .orbital_energies.destroy
    ! .orbital_energies.create(.n_bf,"restricted")

    ! ! Find & read orbital energies.
    ! chkfile.look_for("Alpha Orbital Energies",from=1)
    ! chkfile.read(.orbital_energies)

      ! Create MOs
      .molecular_orbitals.destroy
      .molecular_orbitals.create(.n_bf,"restricted")

      ! Find & read in orbitals
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read(.molecular_orbitals,by_column=TRUE)

      ! Create DM 
      .density_matrix.destroy
      .density_matrix.create(.n_bf,"restricted")

      ! Find & read in DM
      chkfile.look_for("SCF density",from=1)
      chkfile.read(.density_matrix,by_column=TRUE)

   end

   write_tonto_FChk_MO ::: leaky
   ! Write the MO's in a way which can replace g09 fchk file section

   ENSURE(NOT .use_spherical_basis,   "spherical basis not implemented")
   ENSURE(.molecular_orbitals.associated,"no MO's")

      arch :: ARCHIVE 

      arch.set(.name,"gaussian_MO",genre=.molecular_orbitals.spinorbital_kind,format="ascii")
      arch.write(.molecular_orbitals,by_column=TRUE,ascii=TRUE)

   end

   write_tonto_FChk_DM ::: leaky
   ! Write the MO's in a way which can replace g09 fchk file section

   ENSURE(NOT .use_spherical_basis,   "spherical basis not implemented")
   ENSURE(.density_matrix.associated,"no MO's")

      arch :: ARCHIVE 

      arch.set(.name,"gaussian_DM",genre=.density_matrix.spinorbital_kind,format="ascii")
      arch.write(.density_matrix,by_column=TRUE,ascii=TRUE)

   end

! Can thesed be condensed into one?

   read_g09_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   DIE_IF(.use_spherical_basis,"spherical basis not implemented")

      fchk,label :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      pos :: VEC{REAL}(3)
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.associated) .basis.destroy
      if (.atom.associated)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then
         fchk = name
      else if (NOT stdin.buffer_exhausted) then
         stdin.read(fchk) ! specified on stdin
      else
         fchk = .name
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open_for("read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independ",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis fns /= no. of independent fns")
      WARN_IF(.n_bf/=n_independent,"MO's are wrong, but density matrix is correct")

      ! Read atomic numbers & set
      chkfile.look_for("Atomic numbers",from=1)
      chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
         .atom(a).set_nuclear_charge(REALIFY(Z))
      end

      ! Assign core electrons if any
      chkfile.look_for("Nuclear charges",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         Z = .atom(a).atomic_number
         if (nint(Nc)/=Z) then
            Z = Z - nint(Nc)
            .atom(a).set_n_core_electrons(Z)
         end
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(pos)
         .atom(a).set_position(pos)
      end

      ! Set a name?
      if (.name=="unknown") .name = .atom.chemical_formula

      ! Read gaussian shell info.
      label = "Number of contracted shells"
      chkfile.look_for(label,from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + atom_p.sum_elements
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy
      G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis
      .:set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! .basis.unnormalise ! NOTE this
      .:set_atom_info
      .:finalize_atom_groups
      .:resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(n_independent,.n_bf)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .:swap_from_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .:read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.associated) then
         if (.molecular_orbitals.restricted.associated) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .:read_gX_MP2_dm(chkfile,restricted,.density_matrix)

      ! Extract MP3 density matrix to file.  UHF untested
      .:read_gX_MP3_dm(chkfile,restricted,.density_matrix)

      ! Extract CC density matrix to file.  UHF untested
      .:read_gX_CC_dm(chkfile,restricted,.density_matrix)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   read_g03_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy, fc :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      pos :: VEC{REAL}(3)
      Z, a,s,t, f,l,g,h, n3n,ntr :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.associated) .basis.destroy
      if (.atom.associated)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open_for("read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independant functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis fns /= no. of independent fns")
      WARN_IF(.n_bf/=n_independent,"MO's are wrong, but density matrix is correct")

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in nuclear charges
      chkfile.look_for("Nuclear charges",from=1); chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         .atom(a).set_nuclear_charge(Nc)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(pos)
         .atom(a).set_position(pos)
      end

      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + atom_p.sum_elements
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy; G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis
      .:set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! Set atom/basis info
      .:set_atom_info
      .:finalize_atom_groups
      .:resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .:swap_from_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .:read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.associated) then
         if (.molecular_orbitals.restricted.associated) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .:read_gX_MP2_dm(chkfile,restricted,.density_matrix)

      ! Extract MP3 density matrix to file.  UHF untested
      .:read_gX_MP3_dm(chkfile,restricted,.density_matrix)

      ! Extract CC density matrix to file.  UHF untested
      .:read_gX_CC_dm(chkfile,restricted,.density_matrix)

      ! Read in force constants
      if (chkfile.has_string("Cartesian Force Constants")) then
         n3n = 3*.atom.dim
         ntr = n3n.triangle_number
         .force_constants.create(n3n,n3n)
         fc.create(ntr)
         chkfile.look_for("Cartesian Force Constants",from=1)
         chkfile.read_line
         chkfile.read(fc)
         .force_constants.symmetric_unzip_triangle(fc)
         fc.destroy
      end

      ! Close chkfile
      chkfile.close
      chkfile.destroy

      ! Save data in archives
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   read_g94_FChk_file(name) ::: leaky
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      pos :: VEC{REAL}(3)
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE

      ! Destroy existing basis, and atom list
      if (.basis.associated) .basis.destroy
      if (.atom.associated)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open_for("read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independant functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis fns /= no. of independent fns")
      WARN_IF(.n_bf/=n_independent,"MO's are wrong, but density matrix is correct")

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(pos)
         .atom(a).set_position(pos)
      end

      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + atom_p.sum_elements
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        ! Expand out L shell
        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        ! Normal shell
        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy
      G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis
      .:set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! .basis.unnormalise ! NOTE this
      .:set_atom_info
      .:finalize_atom_groups
      .:resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .:swap_from_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .:read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.:debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.associated) then
         if (.molecular_orbitals.restricted.associated) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .:read_gX_MP2_dm(chkfile,restricted,.density_matrix)

      ! Extract MP3 density matrix to file.  UHF untested
      .:read_gX_MP3_dm(chkfile,restricted,.density_matrix)

      ! Extract CC density matrix to file.  UHF untested
      .:read_gX_CC_dm(chkfile,restricted,.density_matrix)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .:resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   set_basis_from_gX_data(l_4_shell,n_cc_4_sh,atom_4_sh,ex_4_prim,cc_4_prim) ::: private, leaky
   ! Set the basis from gaussian data "XXX_4_sh" are the shell data
   ! flattened over all molecular shells. "XXX_4_prim" are (likewise)
   ! data flattened over molecular primitives.
      l_4_shell,n_cc_4_sh,atom_4_sh :: VEC{INT}, IN
      ex_4_prim,cc_4_prim :: VEC{REAL}, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.atom.associated,"no atonm list")
   ENSURE(.atom.dim==.n_atom,"wrong size, atom list")

      n_basis,n_shell,n_cc :: INT
      a,s,t, f,l, b :: INT
      basis :: BASIS*
      sh :: SHELL*
      same :: BIN

      ! Molecular basis (to be appended to)
      n_basis = 0
      .basis.create(n_basis)

      ! Basis fn/shell counters
      l = 0   ! Last primitive, flattened over all atoms
      t = 0   ! Last shell, flattened over all shells

      ! Loop atom "a"
      do a = 1,.n_atom

         ! Basis for atom "a"
         basis.create
         basis.label = trim(.atom(a).generic_chemical_symbol) // ":gaussian"

         ! Set basis label and kind
         .atom(a).set_basis_label(basis.label)
         .atom(a).set_basis_kind("gaussian")

         ! No. of shells
         n_shell = count(atom_4_sh==a)

         ! Create basis shells
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part

         ! Set basis shells
         do s = 1,n_shell

            ! This shell
            sh => basis.shell(s)

            ! Set shell L
            sh.set_l(l_4_shell(t+s))
            sh.set_n_comp

            ! Set shell n_cc
            n_cc    = n_cc_4_sh(t+s)
            sh.n_cc = n_cc

            ! Set shell exponents/contractions
            sh.exponent.create(n_cc)
            sh.contraction.create(n_cc)
            f = l + 1
            l = l + n_cc
            sh.exponent    = ex_4_prim(f:l)
            sh.contraction = cc_4_prim(f:l)

         end

         ! Set no. of bf'd and primitives
         basis.n_bf   = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise ! Note this

         t = t + n_shell

         ! Seen basis before?
         same = FALSE
         do b = 1,n_basis
            if (NOT .basis(b).same_as(basis)) cycle
            same = TRUE
            exit
         end

         ! Append only new basis to .basis
         if (NOT same) then
            n_basis = n_basis + 1
            .basis.append(basis)
         end

         ! Clean
         basis.destroy

      end

   end


   read_gX_dm(chkfile,restricted,dm) ::: template, private
   ! Read a gaussian density matrix with TAG? which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
      chkfile :: TEXTFILE*
      restricted :: BIN, IN
      dm :: OPMATRIX*, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.n_bf>0,"no basis functions")

      D,spin,total :: OPMATRIX*
      archive :: ARCHIVE

      ! Extract density matrix
      if (NOT chkfile.has_string("TAG? Density")) return

      if (restricted) then

         ! Read restricted density (triangle) "name" into "D"
         D.create(.n_bf, "restricted")
         D.triangle.create(D.l_compress("restricted"))
         chkfile.look_for("Total TAG? Density")
         chkfile.read_line
         chkfile.read(D.triangle)
         D.uncompress

         ! Swap orbital order
         .:swap_from_g94_orbital_order(D.restricted,"row")
         .:swap_from_g94_orbital_order(D.restricted,"column")

      else

         ! Create
         D.create(.n_bf,"unrestricted")
         total.create(.n_bf, "restricted")
         spin.create(.n_bf, "restricted")

         ! Read total density (triangle) TAG? into "total"
         total.triangle.create(total.l_compress("restricted"))
         chkfile.look_for("Total TAG? Density")
         chkfile.read_line
         chkfile.read(total.triangle)
         total.uncompress

         ! Read spin density (triangle) trim(tag) into "spin"
         spin.triangle.create(spin.l_compress("restricted"))
         chkfile.look_for("Spin TAG? Density")
         chkfile.read_line
         chkfile.read(spin.triangle)
         spin.uncompress

         ! Define alpha and beta densities
         D.beta  = (total.restricted - spin.restricted)/2
         D.alpha = (spin.restricted  + total.restricted)/2

         ! Clean
         spin.destroy
         total.destroy

         ! Swap orbital order
         .:swap_from_g94_orbital_order(D.alpha,"row")
         .:swap_from_g94_orbital_order(D.alpha,"column")
         .:swap_from_g94_orbital_order(D.beta, "row")
         .:swap_from_g94_orbital_order(D.beta, "column")

      end

      ! Archive the density "D"
      archive.set_defaults
      archive.set(.name,NAME?)
      archive.write(D)

      ! Clean
      if (present(dm)) then
         dm.destroy
         dm => D
      else
         D.destroy
      end

   end

   read_gX_SCF_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>SCF, NAME?=>"SCF_density_matrix"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP2_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>MP2,  NAME?=>"MP2_density_matrix"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP3_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>MP3,  NAME?=>"MP3_density_matrix"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_CC_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>CC,  NAME?=>"CC_density_matrix"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end


   swap_from_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a
   ! gaussian checkpoint file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2". Also: remove the intra-shell basis function
   ! normalisation factors which are not used in Tonto.
      X :: MAT{REAL}
      swap :: STR

      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}*
      ff :: VEC{INT}(10) = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]

      select case (swap)

         case("row","1")

            do s = 1,.n_shell

               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)

               ENSURE(ls<=4,"cannot yet convert order for h shells")
               ! Swap f functions; g functions - no change
               if (ls==3) then
                  X(f:l,:) = X(f-1+ff,:)
               end

               ! Normalisation factors
               if (ls>1) then  
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do i = f,l
                     X(i,:) = X(i,:)*fac(i-f+1)
                  end
               end

            end

         case("column","2")

            do s = 1,.n_shell

               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)

               ENSURE(ls<=4,"cannot yet convert order for h shells")

               ! Swap f functions; g functions - no change
               if (ls==3) then
                  X(:,f:l) = X(:,f-1+ff)
               end

               ! Normalisation factors
               if (ls>1) then  
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do j = f,l
                     X(:,j) = X(:,j)*fac(j-f+1)
                  end
               end

            end

         case default
            DIE("unknown swap kind, "//trim(swap))

      end

   end

   swap_into_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a
   ! gaussian checkpoint file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2". Also: remove the intra-shell basis function
   ! normalisation factors which are not used in Tonto.
      X :: MAT{REAL}
      swap :: STR

      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}*
      ff :: VEC{INT}(10) = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]

      select case (swap)

         case("row","1")

            do s = 1,.n_shell

               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)

               ENSURE(ls<=4,"cannot yet convert order for h shells")

               ! Normalisation factors
               if (ls>1) then  
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do i = f,l
                     X(i,:) = X(i,:)/fac(i-f+1)
                  end
               end

               ! Swap f functions; g functions - no change
               if (ls==3) then
                  X(f-1+ff,:) = X(f-1+ff,:)
               end

            end

         case("column","2")

            do s = 1,.n_shell

               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)

               ENSURE(ls<=4,"cannot yet convert order for h shells")

               ! Normalisation factors
               if (ls>1) then  
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do j = f,l
                     X(:,j) = X(:,j)/fac(j-f+1)
                  end
               end

               ! Swap f functions; g functions - no change
               if (ls==3) then
                  X(:,f-1+ff) = X(:,f:l)
               end

            end

         case default
            DIE("unknown swap kind, "//trim(swap))

      end

   end

!  ========================
!  AIM2000/Morphy interface
!  ========================

   write_morphy98_wfn_file ::: leaky
   ! Write a morphy98 .wfn file

   ENSURE(.occupation_numbers.is_associated_with_genre("restricted"), "No occupation numbers")
   ENSURE(  .orbital_energies.is_associated_with_genre("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
!      title_format :: STR, parameter = "(A80)"
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".wfn")
      wfnfile.open_for("write")

      if (mod(.n_e, 2)==0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec

      lvec.destroy
      evec.destroy

      dmatrix.create(.n_prim, .n_bf)
      cc.create(.n_prim, .n_bf)

      .:make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)

      do i = 1, n_orbitals
         write(unit = wfnfile.unit, fmt = mol_title_format) &
            "MO  ", i, &
            "OCC NO = ", .occupation_numbers.restricted(i), &
            " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      if (.scfdata.associated) then
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, TWO
      else
      write(unit = wfnfile.unit, fmt = e_v_format) ZERO, TWO
      end

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

   write_aim2000_wfn_file ::: leaky
   ! Writes a proaim2000 .wfn file
   ENSURE(.orbital_energies.is_associated_with_genre("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"), "No orbitals")
      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
      occ :: REAL

      n_vars_format :: STR, parameter = "(A8, 10X, I5,' MOL ORBITALS', I7,' PRIMITIVES', I9,' NUCLEI')"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '  CHARGE =', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO  ', I3,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".wfn")
      wfnfile.open_for("write")

      if (mod(.n_e, 2)==0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec

      lvec.destroy
      evec.destroy

      dmatrix.create(.n_prim, .n_bf)
      cc.create(.n_prim, .n_bf)

      .:make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)

      do i = 1, n_orbitals
         occ = ZERO
         if (i<.n_a) occ = TWO
         write(unit=wfnfile.unit, fmt=mol_title_format) &
            i, occ, .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      if (.scfdata.associated) then
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      else
      write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
      end

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

   write_florian_wfn_file ::: leaky
   ! Writes a full wavefunction .ffn file
   ENSURE(.orbital_energies.is_associated_with_genre("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"), "No orbitals")
      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, a, l, atomn, shelln :: INT
      occ :: REAL

      n_vars_format :: STR, parameter = "(A8, 10X, I5,' MOL ORBITALS', I7,' PRIMITIVES', I9,' NUCLEI')"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '  CHARGE =', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO ', I4,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".ffn")
      wfnfile.open_for("write")

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", .n_bf-1, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec

      lvec.destroy
      evec.destroy

      dmatrix.create(.n_prim, .n_bf)
      cc.create(.n_prim, .n_bf)

      .:make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)

      do i = 1, .n_bf
         occ = ZERO
         if (i<.n_a) occ = TWO
         write(unit=wfnfile.unit, fmt=mol_title_format) &
            i, occ, .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

!	==================
!	= Write XYZ File =
!	==================

   write_xyz_file ::: leaky
   ! Prints out an asymmetric-unit xyz file.
   ! cartesian axes.
      name :: STR
      xyzfile :: TEXTFILE*
      i :: INT

      atomnumber :: STR, parameter = "(I3)"
      comment :: STR, parameter = "(' written by tonto')"
      atom_format :: STR, parameter = "(A5, 3F12.6)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      xyzfile.create(trim(name)//".xyz")
      xyzfile.open_for("write")

      write(unit = xyzfile.unit, fmt = atomnumber) .n_atom
      write(unit = xyzfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
      write(unit = xyzfile.unit, fmt = atom_format) (.atom(i).label, .atom(i).position*ANGSTROM_PER_BOHR, i=1, .n_atom)

      ! Cleanup
      xyzfile.close
      xyzfile.destroy

   end

!  =====================================
!  Make molecule from atom or atom group
!  =====================================

   make_molecule_from_atom(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
   ! The new molecule is ready for an SCF calculation.
   ! DANGER: see warnings below
      n :: INT, IN
      mol :: MOLECULE

   ENSURE(.atom.associated,"no atom info")
   ENSURE(n<=.n_atom,"atom number n too big")

      i :: INT

      ! Clear the pointer part
      mol.:nullify_ptr_part

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom
      mol.atom.create_copy(.atom(n:n))
      mol.atom(1).set_position([ZERO,ZERO,ZERO])

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.:set_defaults

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol
      mol.:set_basis_data_from(self)

      ! Don't remake ANO data if there
      i = 0
      mol.:set_ANOs_from_sublist_of(self,[(i,i=n,n)])

      ! Set guess-type SCF defaults
      mol.:set_scf_guess_defaults_from(.scfdata)

   end

   make_molecule_from_atom_group(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from group "n" of atoms
   ! specified in .atom_group(n).element(:), ready fro an SCF calculation.
      n :: INT
      mol :: MOLECULE

   DIE_IF(.atom.disassociated,"no atom info")
   DIE_IF(.atom_group.disassociated,"no atom_group info")
   DIE_IF(n>.atom_group.dim,"group number n too big")
   DIE_IF(n<1,"group number n less than 1!")

      ! Clear the pointer part
      mol.:nullify_ptr_part

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom
      mol.atom.create_copy(.atom(.atom_group(n).atom_index))

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.:set_defaults

      ! Reset .name after .set_defaults
      mol.name              = .atom_group(n).name
      mol.charge            = .atom_group(n).charge
      mol.spin_multiplicity = mol.:default_spin_multiplicity
      mol.atom_info_made    = FALSE
      mol.:set_atom_info

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol !
      mol.:set_basis_data_from(self)

      ! Don't remake ANO data if there
      mol.:set_ANOs_from_sublist_of(self,.atom_group(n).atom_index)

      ! Assign the crystal
      ! WARNING: dont destroy ...
      if (.crystal.associated) mol.crystal => .crystal

      ! Set guess-type SCF defaults
      mol.:set_scf_guess_defaults_from(.scfdata)

      ! Set density matrix from parent?
      ! Restricted only. Do not clobber
      if (.density_matrix.associated) then
      if (.density_matrix.restricted.associated) then
      if (mol.density_matrix.disassociated) then
         mol.density_matrix.create(mol.n_bf,"restricted")
         .:put_group_density_to(mol.density_matrix.restricted,n,mol)
      end
      end
      end

   end

!  create_from_molecule(parent,name,ind,charge,multiplicity) ::: leaky
!  ! Create a molecule "self" from a "parent" molecule; set the
!  ! "name", "charge" and "multiplicity"; use only the atoms with
!  ! indices "ind" in the parent atom list. Make the molecule ready
!  ! for an SCF calculation using intelligent guesses from the
!  ! "parent" molecule.
!     self :: PTR
!     parent :: MOLECULE, IN
!     name :: STR, IN
!     ind :: VEC{INT}, IN
!     charge :: INT, optional, IN
!     multiplicity :: INT, optional, IN

!  ENSURE(parent.atom_info_made,     "parent: no atom info")
!  ENSURE(ind.dim    <=parent.n_atom,"ind: array too large")
!  ENSURE(maxval(ind)<=parent.n_atom,"ind: element is too large")
!  ENSURE(minval(ind)>0,             "ind: element is too small")
!  ENSURE(NOT ind.has_repetitions,  "ind: has repeated elements")

!     ! Create
!     .:create

!     ! Create the single atom and copy its pointers
!     ! WARNING: dont destroy ptr parts of .atom
!     .atom.create_copy(parent.atom(ind))

!     ! Set default molecule e.g. the name, atom_info
!     ! and default multiplicity ...
!     .:set_defaults

!     ! Set details & re-make atom info
!     .name = name
!     if (present(charge)) .charge = charge
!     if (present(multiplicity)) .spin_multiplicity = multiplicity

!     ! re-make atom info
!     .atom_info_made    = FALSE
!     .:set_atom_info

!     ! Copy the basis set and set the basis info
!     ! WARNING: dont destroy basis of mol !
!     .:set_basis_data_from(parent)

!     ! Don't remake ANO data if there
!     .:set_ANOs_from_sublist_of(parent,ind)

!     ! Assign the crystal
!     ! WARNING: dont destroy ...
!     if (parent.crystal.associated) .crystal => parent.crystal

!     ! Set guess-type SCF defaults
!     .:set_scf_guess_defaults_from(parent.scfdata)

!  end

!   make_scfdata_cluster_molecule(n,mol) ::: leaky
!   ! Make a fully fledged molecule "mol" from the cluster stored
!   ! in the .scfdata.cluster "n".
!      n :: INT
!      mol :: MOLECULE
!
!   ENSURE(.scfdata.associated,"no scfdata")
!   ENSURE(.scfdata.cluster.associated,"no scfdata cluster")
!   ENSURE(.atom_group.associated,"no atom_group info")
!   ENSURE(n<=.scfdata.cluster.n_molecules," n too big")
!
!      ! Clear the pointer part
!      mol.nullify_ptr_part
!
!      ! Create the single atom and copy its pointers
!      ! WARNING: dont destroy ptr parts of mol.atom
!      mol.atom.create(.atom_group(n).n_atoms)
!      mol.atom = .atom(.atom_group(n).atom_index)
!
!      ! Reset the .atom list to the cluster fragment
!      .cluster.create_fragment_atom_list(mol.atom)
!      mol.set_atom_info
!      mol.resolve_basis_info
!      mol.set_basis_info
!
!      ! The name for the new cluster
!      mol.name = trim(.name) // "_" // trim(n.to_str)
!
!      ! If a CIF exists, copy that
!      if (.saved.cif.associated) .cif.create_copy(.saved.cif)
!
!      ! We want the saved crystal
!      ! It should be consistent with the cluster.
!      mol.crystal.create_copy(.crystal)
!
!      ! Set up basis sets
!      if (.atom.associated) .atom.nullify_bases
!      if (mol.basis.associated)               mol.basis.create_copy(.basis)
!      if (.saved.slaterbasis.associated)   mol.slaterbasis.create_copy(.slaterbasis)
!      if (.saved.coppensbasis.associated)  mol.coppensbasis.create_copy(.coppensbasis)
!      mol.basis_name        = .saved.basis_name
!      mol.slaterbasis_name  = .saved.slaterbasis_name
!      mol.coppensbasis_name = .saved.coppensbasis_name
!      .resolve_basis_info
!      .set_basis_info
!
!   end

   set_basis_data_from(mol) ::: leaky
   ! Set the basis data from molecule "mol"
   ! Make sure none of these bases are destroyed.
      mol :: MOLECULE, IN

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol
      .use_spherical_basis = mol.use_spherical_basis
      .basis              => mol.basis
      .slaterbasis        => mol.slaterbasis
      .coppensbasis       => mol.coppensbasis

      .:set_basis_info ! leaky

   end

   set_ANOs_from_sublist_of(mol,list) ::: private
   ! Set ANO data and atom shell info from molecule "mol" from the
   ! sublist "list". Make sure none of these are destroyed!
   ! NOTE: No point to assign unique data, all data is non-unique
      mol :: MOLECULE, IN
      list :: VEC{INT}, IN

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.n_atom_kind>0,"atoms not finalized")
   ENSURE(mol.atom.associated,"mol has no atoms")
   ENSURE(mol.n_atom_kind>0,"mol atoms not finalized")
   ENSURE(list.dim==.atom.dim,"inconsistent list length")

      a,b :: INT
      made_ANO,made_int,made_shl :: BIN

      ! Assign ANO orbitals
      made_ANO = mol.:has_all_ANOs_made
      .atom.set_ANOs_made(made_ANO)
      if (made_ANO) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).density_matrix     => mol.atom(b).density_matrix
            .atom(a).natural_orbitals   => mol.atom(b).natural_orbitals
            .atom(a).occupation_numbers => mol.atom(b).occupation_numbers
            .atom(a).atomic_orbitals    => mol.atom(b).atomic_orbitals
            .atom(a).set_energy(mol.atom(b).energy)
         end
      end

      ! Assign ANO interpolators
      made_ANO = mol.:has_all_ANO_interpolators
      made_int = mol.:has_all_interpolators
      .atom.set_ANO_interpolators_made(made_ANO)
      .atom.set_interpolators_made(made_int)
      if (made_ANO OR made_int) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).interpolator => mol.atom(b).interpolator
         end
      end

      ! Assign atom shell info
      made_shl = mol.:has_all_atom_shell_info
      .atom.set_shell_info_made(made_shl)
      if (made_shl) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).first_basis_fn_for_shell    => mol.atom(b).first_basis_fn_for_shell
            .atom(a).last_basis_fn_for_shell     => mol.atom(b).last_basis_fn_for_shell
            .atom(a).precomputed_basis_shellpair => mol.atom(b).precomputed_basis_shellpair
         end
      end

      ! Since all are ptr assigned, no atom is unique
      ! and all ptrs must be nullified
      .atom.set_is_unique_kind(FALSE)

   end

!  ================
!  Atoms group info
!  ================

   finalize_atom_groups ::: leaky
   ! Finalize the .atom_group information
      self :: INOUT

      g :: INT

      if (.atom_group.associated) then

         if (.atom_group.has_wavefunction_files) then; .:make_groups_from_wavefunction_files
         else if (.atom_group.has_atom_indices)  then; .:make_groups_from_self
         else;          DIE("Can't finalize atom groups")
         end

      else if (.atom.associated AND .atom.has_groups) then

         .atom_group.create(.atom.no_of_groups)
         do g = 1,.atom_group.dim
            .atom_group(g).atom_index => .atom(:).group.indices_of_elements_matching(g)
            .atom_group(g).n_atoms     = .atom_group(g).atom_index.dim
         end

      end

   end

   make_groups_from_wavefunction_files ::: private, leaky
   ! Make the atom groups by read in Gaussian Fchk files in they are defined for the groups
   DIE_IF(.atom.associated,"atoms already exists!")
   DIE_IF(.atom_group.disassociated,"no atom groups")
   DIE_IF(NOT .atom_group.has_wavefunction_files,"no wavefunction files")

      mol :: MOLECULE*
      g :: INT
      do g = 1,.atom_group.dim
         ! Create the mol & define it from FChk file
         mol.:create
         ! Read in either the fchk or sbf_file
         if(.atom_group(g).wavefunction_file_name.ends_in("fchk", case_sensitive=FALSE)) then
            mol.:read_g09_FChk_file(.atom_group(g).wavefunction_file_name)
         else
            mol.:deserialize(.atom_group(g).wavefunction_file_name)
         end if

         if (mol.scfdata.is_unrestricted) then
            if(.scfdata.disassociated) then
               .scfdata.create
               .scfdata.set_defaults
            end
            .scfdata.set_scf_kind("uhf")
         end
         ! Rotate and translate it
         mol.:rotate_by(.atom_group(g).rotation_matrix)
         mol.atom.translate_by(.atom_group(g).shift)
         mol.atom.set_group_to(g)

         ! Add it to atom_group
         .atom_group(g).mol => mol

      end

      ! Define .atom list
      .:merge_atom_groups

      ! Update group info from self
      if (.atom_group.has_all_mols) then
         .:update_group_info
      end

   end


   make_groups_from_self ::: private, leaky
   ! Make the atom groups from "self"
   DIE_IF(NOT .atom_group.associated,"no atom groups!")

      mol :: MOLECULE*
      g :: INT

      ! Check is indices are sensible
      .atom_group.finalize(.atom)

      ! Create each group from "self"
      do g = 1,.atom_group.dim

         ! Create mol & define it
         mol.:create
         self.:make_molecule_from_atom_group(g,mol)

         ! Read the MOs & make the density
         ! This won't work until Tonto can read in its own dump
         if (.atom_group(g).MO_file_name/=" ") then
             mol.:read_archive("molecular_orbitals","restricted")
             mol.:make_scf_density_matrix
         end

         ! Rotate and translate mol
         if (.atom_group(g).transform_group) then
            mol.:rotate_by(.atom_group(g).rotation_matrix)
            mol.atom.translate_by(.atom_group(g).shift)
         end
         mol.atom.set_group_to(g)

         ! Add it to atom_group
         .atom_group(g).mol.BASE:destroy
         .atom_group(g).mol => mol

      end

      ! Define .atom list
    ! .:merge_atom_groups

      ! Update group infor from self
      ! Is the below needed????
      .:update_group_info

   end

   update_group_info ::: leaky
   ! Update .atom_group information (ANOs, crystal, SCF guess ...)
      self :: INOUT

   ENSURE(.atom.associated,"atom groups must be defined after atoms=")
   ENSURE(.atom_group.has_all_mols,"atom_group has missing mols")

      mol :: MOLECULE*
      g :: INT

      if (.scfdata.disassociated) then
         .:set_scf_defaults
         .scfdata.set_output(FALSE)
      end

      do g = 1,.atom_group.dim

         mol => .atom_group(g).mol
         ENSURE(mol.associated,"atom_group molecule "//trim(g.to_str)//" does not exist")

         ! Don't remake ANO data if there
         mol.:set_ANOs_from_sublist_of(self,.atom_group(g).atom_index)

         ! Assign the crystal
         ! WARNING: dont destroy ...
         if (.crystal.associated) mol.crystal => .crystal

         ! Set guess-type SCF defaults
         mol.:set_scf_guess_defaults_from(.scfdata)

      end

   end

   merge_atom_groups ::: private, leaky
   ! Delete any existing .atom and .basis and set to the concatenation
   ! of the molecules in .atom_group

      mol :: MOLECULE*
      g, charge, unpaired_electrons :: INT

      if (.atom.associated)  .atom.destroy
      if (.basis.associated) .basis.destroy

      charge = 0
      unpaired_electrons = 0

      ! Append remaining ...
      do g = 1,.atom_group.dim

         mol => .atom_group(g).mol

         DIE_IF(mol.disassociated,"no mol "//trim(g.to_str))
         DIE_IF(mol.basis.disassociated,"no basis on mol "//trim(g.to_str))
         DIE_IF(mol.atom.disassociated,"no atom list in mol "//trim(g.to_str))

         charge = charge + mol.charge
         unpaired_electrons = unpaired_electrons + mol.spin_multiplicity - 1 

         if (g==1) then

            ! Initial atom/basis list
            .name = .atom_group(g).name
            .basis.create_copy(mol.basis)
            .atom.create_copy(mol.atom)

         else

            ! Append basis & atoms
            .name = trim(.name) // "_" // trim(.atom_group(g).name)
            .basis.append(mol.basis)
            .atom.append(mol.atom)

         end

      end

      ! Unresolve atomic bases
      .atom.nullify_bases

      ! Uniquify basis
      .basis.remove_repetitions

      ! Finally: set atom info & basis info (leaky)
      ! NOTE: multiplicity not set - assume singlet
      if(.scfdata.disassociated) then
          WARN("No SCF data set, assuming singlet state, rhf")
      endif
      .:set_charge(charge)
      .:set_spin_multiplicity(unpaired_electrons + 1)
      .:set_atom_info
      .:resolve_basis_info

   end

!  =================
!  VEC{ATOM} methods
!  =================

   default_spin_multiplicity result (res) ::: PURE
   ! Return the default multiplicity for a molecule.
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"no atom info")

      n_e :: INT

      n_e = .:no_of_electrons

      if (.atom.dim==1) then

         if (.atom(1).atomic_number==-1) then
            res = 2 ! This is an El electron
         else
            res = .atom(1).ground_state_multiplicity(n_e)
         end

      else

         ! Singlet or doublet
         res = mod(n_e,2) + 1

      end

   end

   nuclear_repulsion_energy result (res) ::: PURE
   ! Return the nuclear repulsion energy
      self :: IN
      res :: REAL

   ENSURE(.atom.associated,"atom list required")

      i :: INT
      scf_kind :: STR

      scf_kind = "unknown"
      if (.scfdata.associated) scf_kind = .scfdata.scf_kind

      i = 0
      res = ZERO
      select case (scf_kind)
         case ("embedded_rhf"); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
         case ("crystal_rhf "); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
         case default;          res = .atom.nuclear_repulsion_energy
      end

   end

   nuclear_dipole_moment result (res)
   ! Return the nuclear dipole moment
      res :: VEC{REAL}(3)
      res = .atom.nuclear_dipole_moment
   end

   chemical_formula(with_spaces) result (res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical
   ! order of elements
      with_spaces :: BIN, optional
      res :: STR
   ENSURE(.atom.associated,"atom list required")
      res = .atom.chemical_formula(with_spaces)
   end

   center_of_mass result(center)
   ! Return the center of mass
      center :: VEC{REAL}(3)
   ENSURE(.atom.associated,"atom list required")
      center = .atom.center_of_mass
   end

   change_to_principal_axes
   ! Move the origin to the center of mass and change to the principal axis
   ! coordinate system
   ENSURE(.atom.associated,"atom list required")
      .atom.change_to_principal_axes
   end

   change_to_principal_top_axes
   ! Move the origin to the center of mass and change to the principal axis
   ! coordinate system, where the symmetric top axis is the z axis and where the
   ! determinant of the axes transformation is 1.
      self :: INOUT

   ENSURE(.atom.associated,"atom list required")

      .atom.change_to_principal_top_axes

   end

   molecular_weight result (res)
   ! Return the molceular weight
      res :: REAL
   ENSURE(.atom.associated,"atom list required")
      res = .atom.molecular_weight
   end

   reduced_mass result (res)
   ! Return the reduced mass
      res :: REAL
   ENSURE(.atom.associated,"atom list required")
      res = .atom.reduced_mass
   end

   move_origin_to_center_of_mass
   ! Move the origin to the center of mass
   ENSURE(.atom.associated,"atom list required")

      .atom.move_origin_to_center_of_mass

      if (.becke_grid.associated) .becke_grid.set_grid_data(.atom) ! leaky

   end

   move_origin_to_center_of_atoms
   ! Move the origin to the center of atoms
   ENSURE(.atom.associated,"atom list required")

      .atom.move_origin_to_center_of_atoms

      if (.becke_grid.associated) .becke_grid.set_grid_data(.atom) ! leaky

   end

   move_origin
   ! Move the origin by a user specified vector
   ENSURE(.atom.associated,"atom list required")
   ENSURE(stdin.buffer.n_items==4 OR stdin.buffer.n_items==5,"origin shift needed on same line")
      shift :: VEC{REAL}(3)

      stdin.read_quantity(shift)
      .atom.translate_by(shift)

      if (.becke_grid.associated) .becke_grid.set_grid_data(.atom) ! leaky

   end

!  ===============
!  Inquiry methods
!  ===============

   has_all_NAOs_made result (res) ::: PURE
   ! Return TRUE if the NAOs are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.associated
      if (res) res = .atom.has_all_NAO_matrices

   end

   has_all_ANOs_made result (res) ::: PURE
   ! Return TRUE if the ANO data is made for every atom.
      self :: IN
      res :: BIN

      res = .atom.associated

      if (res) res = .atom.has_all_ANO_matrices

   end

   has_all_ANO_interpolators result (res) ::: PURE
   ! Return TRUE if the ANO interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.associated

      if (res) res = .atom.has_all_ANO_interpolators

   end

   has_all_interpolators result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.associated
      if (res) res = .atom.has_all_interpolators

   end

   has_all_spherical_atom_data result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.associated
      if (res) res = .atom.has_all_spherical_atom_data

   end

   has_all_atom_shell_info result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.associated
      if (res) res = .atom.has_all_shell_info

   end


   no_of_electrons result (res) ::: PURE
   ! Work out and return the number of electrons in the molecule.
   ! NOTE: removed the core electrons, if any.
      self :: IN
      res :: INT

   ENSURE(.atom.associated,  "no atom list")

      res = .atom.no_of_electrons - .charge - sum(.atom(:).n_core_electrons)

   end

   no_of_alpha_electrons result (res) ::: PURE
   ! Work out and return the number of alpha electrons in the molecule.
      self :: IN
      res :: INT

      res = .:no_of_electrons - .:no_of_beta_electrons

   end

   no_of_beta_electrons result (res) ::: PURE
   ! Work out and return the number of beta electrons in the molecule.
   ! Normally the number of beta electrons is smaller than alpha, but
   ! if the atom list is a single explicit (alpha) "El" electron it is
   ! assumed that there is one beta electron surrounding it. This is
   ! to ensure a good initial guess for promolecule SCF guess.
      self :: IN
      res :: INT

   ENSURE(.atom.associated,  "no atom list")

      tmp :: INT

      if (.atom.dim==1 AND .atom(1)%tag(1:2)=="El") then

         res = 1 ! Assume one beta electron surrounds the "El"

      else

         tmp = .:no_of_electrons - .:no_of_unpaired_electrons
         res = tmp/2
         ENSURE(tmp.is_even,"Inconsistent multiplicity, non integer # of beta electrons")

      end

   end

   has_valid_no_of_beta_electrons result (res) ::: PURE
   ! Return TRUE if the number of beta electrons is valid based on the
   ! assigned charge and multiplicity i.e. it must come out integral
   ! *except* in the case when the atom list is a single explicit
   ! (alpha) "El" electron - in which case there must be one beta
   ! electron. See above.
      self :: IN
      res :: BIN

   ENSURE(.atom.associated,  "no atom list")

      tmp :: INT

      if (.atom.dim==1 AND .atom(1).tag(1:2)=="El") then

         tmp = .:no_of_electrons
         res = tmp==1 ! must have one beta electron

      else

         tmp = .:no_of_electrons - .:no_of_unpaired_electrons
         res = tmp.is_even

      end

   end

   no_of_unpaired_electrons result (res) ::: PURE
   ! Work out and return the number of unpaired electrons in the molecule
      self :: IN
      res :: INT

      res = .spin_multiplicity - 1

      ENSURE(res<=.:no_of_electrons,"Wrong multiplicity, not enough electrons")

   end


   no_of_atom_pairs result (res) ::: PURE
   ! Return the number of atom pairs in the molecule
      self :: IN
      res :: INT

   ENSURE(.atom.associated,"no atom list")

      res = .n_atom*(.n_atom+1)/2

   end


   no_of_occupied_NOs(genre,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      genre :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.occupation_numbers.associated,"no occupation numbers")

      res = .occupation_numbers.no_of_occupied(genre,tol)

   end


   DFT_grid_info_made result (res) ::: PURE
   ! Return TRUE if the DFT grid information is made
      self :: IN
      res :: BIN

      res = .becke_grid.associated  &
          AND .overlapping_atoms.associated &
          AND .overlapping_atoms_for_atom.associated

   end

   has_Hirshfeld_inputs result (res) ::: PURE
   ! Return TRUE if the inputs for a Hirshfeld calc are there
      self :: IN
      res :: BIN

      res =  .:DFT_grid_info_made &
         AND .:has_all_ANOs_made &
         AND ( .:has_all_ANO_interpolators &
         OR    .:has_all_interpolators &
         OR    .:has_all_spherical_atom_data )

   end


   guess_scf_method result (res)
   ! Guess the scf method in use.
      self :: INOUT
      res :: STR

      if      (.scfdata.associated) then;            res = .scfdata.scf_kind
      else if (.molecular_orbitals.associated) then; res = .molecular_orbitals.guess_scf_kind
      else;                                       DIE("no way to  guess!")
      end

   end

!  =================
!  Overlapping atoms
!  =================

   is_overlapping_atom(a,b) result (res) ::: PURE
   ! Return TRUE if atoms "a" and "b" overlap.
      self :: IN
      a,b :: INT, IN
      res :: BIN

   ENSURE(.overlapping_atoms.associated,"no .overlapping_atoms")

      aa,bb,ab :: INT

      if (a==b) then
         res = TRUE
      else
         aa = max(a,b)
         bb = min(a,b)
         ab = int(HALF*aa*(aa-1)) + bb
         res = .overlapping_atoms(ab)
      end

   end

   is_overlapping_atom(a,list) result (res) ::: PURE
   ! Return TRUE if atom "a" overlaps with *any* atoms in the "list".
      self :: IN
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: BIN

   ENSURE(.overlapping_atoms.associated,"no .overlapping_atoms")

      i,b,aa,bb,ab :: INT

      res = FALSE

      do i = 1,list.dim

         b = list(i)

         if (a==b) then
            res = TRUE
            exit
         else
            aa = max(a,b)
            bb = min(a,b)
            ab = int(HALF*aa*(aa-1)) + bb
            if (.overlapping_atoms(ab)) then
               res = TRUE
               exit
            end
         end

      end

   end

   overlapping_atoms_for(list) result (res) ::: leaky, PURE
   ! Return the list of atoms which overlaps with those in "list".
      self :: IN
      list :: VEC{INT}, IN
      res :: VEC{INT}*

      a,k :: INT

      res.create(.n_atom)

      k = 0

      do a = 1,.n_atom

         if (NOT .:is_overlapping_atom(a,list)) cycle

         k = k + 1
         res(k) = a

      end

      res.shrink(k)

   end

   make_max_S_for_shell_pairs(max_S) ::: PURE
   ! Make "max_S", the maximum of the overlap integrals between basis
   ! functions in pairs of shells.
      self :: IN
      max_S :: VEC{REAL}, OUT

   ENSURE(.overlap_matrix.associated,"no overlap_matrix")
   ENSURE(max_S.dim==.n_shell_pairs,"wrong size, S_max")

      ab,a,b,fa,fb,la,lb :: INT

      do ab = 1,.n_shell_pairs

         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2

         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)

         max_S(ab) = maxval(abs(.overlap_matrix(fa:la,fb:lb)))

      end

   end

! Below does not work ... but it does with lower cutoff

   make_overlapping_atoms ::: leaky, PURE
   ! Make the list of overlapping atoms
      self :: INOUT

   ENSURE(.basis_info_made,"no basis set")
   ENSURE(.becke_grid.associated,"no becke_grid")

      r_max :: VEC{REAL}*
      d :: VEC{REAL}(3)
      r :: REAL
      a,b,ab,n_atom_pairs :: INT

      n_atom_pairs = .:no_of_atom_pairs

      ! Overlapping atoms pair array
      .overlapping_atoms.destroy
      .overlapping_atoms.create(n_atom_pairs)

      ! Overlapping atoms list array
      .overlapping_atoms_for_atom.destroy
      .overlapping_atoms_for_atom.create(.n_atom)

      ! Make the maximum radii
      r_max.create(.n_atom)
      do a = 1,.n_atom
         ! sqrt because we are dealing with overlaps
         r_max(a) = .atom(a).r_max(.becke_grid.basis_function_cutoff)
      end

      ! Make the overlapping atom arrays
      do ab = 1,n_atom_pairs
         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2
         d = .atom(a).position - .atom(b).position
         r = sqrt(dot_product(d,d))
         if (r>(r_max(a)+r_max(b))) then
            .overlapping_atoms(ab) = FALSE
         else
            .overlapping_atoms(ab) = TRUE
         end
      end

      ! Make the overlapping atom arrays
      do a = 1,.n_atom

         ! Atom a overlaps itself
         .overlapping_atoms_for_atom(a).element.append(a)

         ! Loop over other atoms "b"
         do b = 1,a-1

            ! Distance "r" to atom "b"
            d = .atom(a).position - .atom(b).position
            r = sqrt(dot_product(d,d))
            if (r>(r_max(a)+r_max(b))) cycle

            ! Atoms "a" and "b" overlap
            .overlapping_atoms_for_atom(a).element.append(b)
            .overlapping_atoms_for_atom(b).element.append(a)

         end

      end

      r_max.destroy

      ! Reorder the lists
      do a = 1,.n_atom
         .overlapping_atoms_for_atom(a).element.sort
      end

   end

!  ================
!  Atom connections
!  ================

   make_atom_connections ::: leaky, PURE
   ! Make the list of bonded atoms
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")

      .atom.make_connection_table(.atoms_bonded_to_atom)

   end

   connected(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are connected
      self :: IN
      a,b :: INT, IN
      res :: BIN
      
      if (a <= .atoms_bonded_to_atom.dim1) then
         res = any(b==.atoms_bonded_to_atom(a).element(:))
      else
         res = FALSE
      end if

   end
  
   connected_or_identical(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are connected
   ! or if they are the same atom
      self :: IN
      a,b :: INT, IN
      res :: BIN
     
      if (a == b) then 
         res = TRUE
      else if (a <= .atoms_bonded_to_atom.dim1) then
         res = any(b==.atoms_bonded_to_atom(a).element(:))
      else
         res = FALSE
      end if

   end

   make_elmo_connection_table ::: leaky
      self :: INOUT
   ! construct the elmo connection table
      i, j :: INT
      .elmo_connection_table.create(.n_atom,.n_atom)

      ! set default connection to something huge
      ! to signify not connected
      ! divide by 2 to prevent overflow errors
      .elmo_connection_table = (huge(i) - 1) / 2

      ! initialize same atom connections
      do i = 1, .n_atom
         .elmo_connection_table(i,i) = 0
      end do

      do i = 1, .n_atom
         do j = 1, .atoms_bonded_to_atom(i).element.dim
            .elmo_connection_table(i, .atoms_bonded_to_atom(i).element(j)) = 1
         end do
      end do
      .elmo_connection_table = .elmo_connection_table.floyd_warshall
   end

   elmo_connected(a,b, degree) result(res) ::: pure
      self :: IN
      a, b, degree :: INT, IN
      res :: BIN
      res = (.elmo_connection_table(a,b) <= degree)
   end 


!  =================
!  Atom pair indices
!  =================

   get_atom_pair_indices(index,a,b,fa,la,na,fb,lb,nb)
   ! Return the atom indicies "a" and "b" which map to an atom-pair "index".
   ! Also get "fa", "la" and "fb", "lb", the indices of first and last basis
   ! functions for atoms "a" and "b", and "na" and "nb", the number of basis
   ! functions on those atoms, respectively. NOTE: "fa" and "fb" are actually
   ! the first basis functions for atoms "a" and "b" *minus 1*.
      index :: INT, IN
      a,b,fa,la,na,fb,lb,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_atom(a) - 1
      la =  .last_basis_fn_for_atom(a)
      na = la - fa

      fb = .first_basis_fn_for_atom(b) - 1
      lb =  .last_basis_fn_for_atom(b)
      nb = lb - fb

   end

!  ==================================
!  VEC{ATOM} shell extraction methods
!  ==================================

! The set routines should be quicker, but I'm not sure.
! When allocatable components are used it may be easier
! to allocate an entire basis set array once and for all.

   get_shell(shell,index) ::: leaky
   ! Get basis set "shell" (SHELL) corresponding to "index"
   ! This version creates exponent/contraction arrays
      self :: IN
      shell :: SHELL, OUT
      index :: INT, IN

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa))

   end

   set_shell(shell,index) ::: leaky
   ! Set basis set "shell" (SHELL) corresponding to "index"
   ! This version does not create exponent/contraction arrays
      self :: IN
      shell :: SHELL, OUT
      index :: INT, IN

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.set(.atom(aa).basis.shell(sa))

   end

   get_shell(shell,index) ::: leaky
   ! Get basis set "shell" (SHELL1) corresponding to "index"
   ! This version creates exponent/contraction arrays
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   set_shell(shell,index) ::: leaky
   ! Get basis set "shell" (SHELL1) corresponding to "index"
   ! This version does not create exponent/contraction arrays
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.set(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   get_shell(shell,index,fa,la) ::: leaky
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la". This version creates arrays.
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   set_shell(shell,index,fa,la) ::: leaky
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la". This version sets arrays.
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)

      shell.set(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   get_shell(shell,index,fa,la,na) ::: leaky
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la", and "na" the no. of bf's in the shell.
   ! This version create-copies arrays.
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la,na :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      na = la - fa + 1

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   set_shell(shell,index,fa,la,na) ::: leaky
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la", and "na" the no. of bf's in the shell.
   ! This version pointer-assigns arrays.
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la,na :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      na = la - fa + 1

      shell.set(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

!  ==================
!  Shell pair indices
!  ==================

   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb) ::: pure
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      self :: IN
      index :: INT, IN
      a,b,fa,la,fb,lb,na,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      na = la - fa + 1
      nb = lb - fb + 1

   end

   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: pure
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
   ! Also return the atom indices "atom_a" and "atom_b" for each shell.
      self :: IN
      index :: INT, IN
      a,b,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

   end

!  ===========
!  Shell pairs
!  ===========

   get_precomputed_shell_pair(shell,index) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT

      a,b,aa,sa,bb,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from( &
         .precomputed_basis_shellpair(sa,sb), &
         .atom(aa).position,.atom(bb).position, &
         aa==bb,skip=FALSE)

   end

   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,na,fb,lb,nb :: INT, OUT
      a,b,aa,sa,bb,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), &
         .atom(aa).position,.atom(bb).position, &
         aa==bb,skip=FALSE)

   end

   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,na,fb,lb,nb,atom_a,atom_b :: INT, OUT
      a,b,sa,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), &
         .atom(atom_a).position,.atom(atom_b).position, &
         atom_a==atom_b,FALSE)

   end

   get_precomputed_shell_pair(shell,index,a,fa,la,na,b,fb,lb,nb,atom_a,atom_b) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      a,fa,la,na,b,fb,lb,nb,atom_a,atom_b :: INT, OUT

      sa,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), &
         .atom(atom_a).position,.atom(atom_b).position, &
         atom_a==atom_b,FALSE)

   end

!  =====================
!  Shell quartet indices
!  =====================

   get_shell_quartet_indices(index,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index". Also return the basis function
   ! start indices "fa", "la", etc ...
      index :: INT, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      a,b,c,d :: INT
      ab,cd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)

   end

   get_shell_quartet_indexes(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
   ! For the quartet index "index" return the shell indicies "a", "b", "c" and
   ! "d" which map to "index" and the corresponding atom centers. Note different
   ! spelling for this routine and the one above to avoid overload problems.
      index :: INT, IN
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd :: INT
      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

!  ==============
!  Shell quartets
!  ==============

   copy_shell_quartet(shell,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the indicies "a", "b", "c"
   ! and "d".
      shell :: SHELL4, OUT
      a,b,c,d :: INT, IN
      aa,sa,bb,sb,cc,sc,dd,sd :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

   end

   copy_shell_quartet(shell,index,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

   end

   copy_shell_quartet(shell,index,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)

   end

   copy_shell_quartet(shell,index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd,sa,sb,sc,sd :: INT
      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      atom_b = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      atom_c = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      atom_d = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_c).basis.shell(sc), .atom(atom_d).basis.shell(sd), &
                 .atom(atom_a).position, .atom(atom_b).position, &
                 .atom(atom_c).position, .atom(atom_d).position )
   end

   copy_shell_quartet_ab(shell,a,b) ::: leaky
   ! Set the a and b parts of the "shell" SHELL4 object.
      shell :: SHELL4, INOUT
      a,b :: INT, IN
      aa,sa,bb,sb :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)

      shell.copy_ab(.atom(aa).basis.shell(sa), &
                    .atom(bb).basis.shell(sb), &
                    .atom(aa).position, .atom(bb).position)

   end

   copy_shell_quartet_cd(shell,c,d) ::: leaky
   ! Set the c and d parts of the "shell" SHELL4 object.
      shell :: SHELL4, INOUT
      c,d :: INT, IN
      cc,sc,dd,sd :: INT

      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy_cd(.atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(cc).position, .atom(dd).position)

   end


   set_new_shell_quartet_ab(shell,a,b,skip) ::: leaky
   ! Set the "a" and "b" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
      shell :: SHELL1QUARTET, INOUT
      a,b :: INT, IN
      skip :: BIN

      aa,sa,bb,sb :: INT

      aa = .atom_for_shell(a)         !which atom.
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)  !which shell.
      sb = .basis_shell_for_shell(b)

      shell.set_ab_new(.precomputed_basis_shellpair(sa,sb),   &
                       .atom(aa).position,.atom(bb).position, &
                       aa==bb,skip)

   end

   set_new_shell_quartet_cd(shell,c,d,skip) ::: leaky
   ! Set the "c" and "d" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
      shell :: SHELL1QUARTET, INOUT
      c,d :: INT, IN
      skip :: BIN

      cc,sc,dd,sd :: INT

      cc = .atom_for_shell(c)         !which atom.
      dd = .atom_for_shell(d)

      sc = .basis_shell_for_shell(c)  !which shell.
      sd = .basis_shell_for_shell(d)

      shell.set_cd_new(.precomputed_basis_shellpair(sc,sd),   &
                       .atom(cc).position,.atom(dd).position, &
                       cc==dd,skip)

   end

!  ======================
!  Make shell information
!  ======================

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule's
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
   ENSURE(.atom.associated,"no atom information")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")
   ENSURE(.n_atom>0,"no atoms")
   ENSURE(.basis.associated,"no basis set")

      ! Set basis l_max before anything else
      .basis_l_max = .basis.maximum_basis_set_l_value
      GAUSSIAN_DATA:set_indices(.basis_l_max)

      ! Set atom for shell
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .atom_for_shell       => .atom.atom_for_shell
      .atom_shell_for_shell => .atom.atom_shell_for_shell

      ! Set first/last shell for atom
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_shell_for_atom.create(.n_atom)
      .last_shell_for_atom.create(.n_atom)
      .atom.make_shell_for_atom_limits(.first_shell_for_atom,.last_shell_for_atom)

      ! Set first/last bf for shell
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .atom.make_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      ! Set first/last bf for atom
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)

      ! Shell pointer into flattened .basis vector
      .:make_basis_shell_for_shell

      ! Precalculate non-positional basis-pair information
      .:make_precomputed_shellpairs

   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type

   ENSURE(.basis.associated,"no basis set")
      i,j,a,b,p,q :: INT

      .n_unique_shells = .basis.no_of_shells

      ! Recreate
      .precomputed_basis_shellpair.destroy
      .precomputed_basis_shellpair.create(.n_unique_shells,.n_unique_shells)

      ! Loop over bases "p"
      p = 0
      do i = 1,.basis.dim
      do a = 1,.basis(i).n_shell

        p = p + 1

        ! Loop over bases "q"
        q = 0
        do j = 1,.basis.dim
        do b = 1,.basis(j).n_shell

           q = q + 1

           ! Copy the shells
           .precomputed_basis_shellpair(p,q).copy_a(.basis(i).shell(a))
           .precomputed_basis_shellpair(p,q).copy_b(.basis(j).shell(b))

           ! Precalculate non-positional info
           .precomputed_basis_shellpair(p,q).make_precalculated_data

        end
        end

      end
      end

   end

   first_basis_shell_for_atom(atom) result (res)
   ! Return the index of the first shell in .basis (treating .basis as a
   ! flattened list of shells) which has the same basis label as "atom".
   ! NOTE for later: this should be a basisvec routine.
      atom :: INT, IN
      res :: INT

      i,j :: INT

      res = 0

      i = 1
      ! Loop over bases
      do j = 1,.basis.dim
         if (.basis(j).label==.atom(atom).basis.label) then
            res = i
            exit
         else
            i = i + .basis(j).n_shell
         end
      end

      DIE_IF(res==0,"atom basis label not found")

   end

   make_basis_shell_for_shell ::: leaky
   ! Return the index of the first shell in .basis (treating .basis as
   ! a flattened list of shells) for a given shell index in the
   ! molecular basis set (i.e. the flattened list of shells in the
   ! .atom list).  NOTE for later: this should be a basisvec routine.
   ENSURE(.basis.associated,"no basis set")

      sh,at,atom_shell,ind :: INT

      .basis_shell_for_shell.destroy
      .basis_shell_for_shell.create(.n_shell)

      do sh = 1,.n_shell

         ! Which atom?
         at = .atom_for_shell(sh)

         ! Which shell for this atom?
         atom_shell = .atom_shell_for_shell(sh)

         ! First shell for this atom in the basis set
         ind = .:first_basis_shell_for_atom(at)

         ! The shell-index for the flattened basis vector
         .basis_shell_for_shell(sh) = ind + atom_shell - 1

      end

   end

!  ===============
!  Atom-shell info
!  ===============

   make_atom_shell_info ::: leaky
   ! Get the atom shell info for all atoms in the molecule. We make it
   ! only for the unique atoms and pointer copy to the non-unique
   ! atoms, just like for ANO atom information.
      self :: INOUT

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.basis.associated,"no basis set")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      a,b :: INT

      if (.:has_all_atom_shell_info) return

      ! Destroy ...  in case .ANO_data_made
      ! was deliberately set FALSE
      .:destroy_atom_shell_info

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Make the shell info
         .atom(a).make_shell_info

         ! Copy it to non-unique atoms
         do b = a+1,.n_atom

            if (.atom(b).kind/=.atom(a).kind) cycle

            .atom(b).first_basis_fn_for_shell    => .atom(a).first_basis_fn_for_shell
            .atom(b).last_basis_fn_for_shell     => .atom(a).last_basis_fn_for_shell
            .atom(b).precomputed_basis_shellpair => .atom(a).precomputed_basis_shellpair

         end

      end

      .atom.set_shell_info_made(TRUE)

   end

!  ========================
!  Contraction Coefficients
!  ========================

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      b = 1
      p = 1

      cc_mat = ZERO

      do a = 1,.n_atom

         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf

         .atom(a).basis.make_contraction_matrix(cc_mat(p:p+ap-1,b:b+ab-1))

         p = p + ap
         b = b + ab

      end

   end

   make_normalised_contraction_mx(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each
   ! basis set. Size of cc_mat is [.n_prim,.n_bf]. Primitive components
   ! are properly normalised.
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      .basis.renormalise

      b = 1
      p = 1
      cc_mat = ZERO
      do a = 1,.n_atom
         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf
         .atom(a).basis.make_normalised_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))
         p = p + ap
         b = b + ab
      end

      .basis.unnormalise

   end

!  ========================
!  Atom AO subspace setting
!  ========================

   AO_subspace_set(A,B,row_atom,col_atom)
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then copy
   ! the entire row or col, i.e.  A(small) = B(row_atom,col_atom)
      self :: IN
      A :: MAT{REAL}, OUT
      B :: MAT{REAL}, IN
      row_atom,col_atom :: VEC{INT}, IN, optional

   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")

      n_row_atoms,n_col_atoms, a1,a2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT

      if (present(row_atom) AND present(col_atom)) then

         n_row_atoms = row_atom.dim
         n_col_atoms = col_atom.dim
         a1 = .atom(row_atom).no_of_basis_functions
         a2 = .atom(col_atom).no_of_basis_functions
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_i = 0
         do i = 1,n_row_atoms

            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = l_i - f_i + 1

            b_j = 0

            do j = 1,n_col_atoms

               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = l_j - f_j + 1

               A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)

               b_j = b_j + n_j

            end

            b_i = b_i + n_i

         end

      else if (present(row_atom)) then

         n_row_atoms = row_atom.dim
         a1 = .atom(row_atom).no_of_basis_functions
         a2 = .n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_i = 0

         do i = 1,n_row_atoms

            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = l_i - f_i + 1

            A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)

            b_i = b_i + n_i

         end

      else if (present(col_atom)) then

         n_col_atoms = col_atom.dim
         a1 = .n_bf
         a2 = .atom(col_atom).no_of_basis_functions
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_j = 0

         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j))
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = l_j - f_j + 1

            A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)

            b_j = b_j + n_j

         end

      end

   end

!  ======================
!  Density matrix methods
!  ======================

   make_density_matrix_from_NOs ::: leaky
   ! Make the .density_matrix from the *natural_orbitals* and the
   ! *occupation_numbers* vector. Only restricted so far.

   ENSURE(.occupation_numbers.associated, "no occupation numbers")
   ENSURE(.natural_orbitals.associated, "no natural orbitals")

      NO,D :: MAT{REAL}*
      occ :: VEC{REAL}*
      genre :: STR
      arch :: ARCHIVE

      genre = .natural_orbitals.spinorbital_kind

      ! Destroy
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      ! Make it
      select case (genre)

         case ("restricted")

            ENSURE(.natural_orbitals.is_associated_with_genre("restricted"),"no NO's")

            occ.create(.n_bf)
            NO.create(.n_bf,.n_bf)

            occ = sqrt(.occupation_numbers.restricted)
            NO.to_product_with_diagonal(.natural_orbitals.restricted,occ)
            D => .density_matrix.restricted
            D.to_product_of(NO,NO,transpose_b=TRUE)

            NO.destroy
            occ.destroy

         case default

            DIE("unknown SCF kind, "//trim(genre))

      end

      ! Archive
      arch.set(.name,"density_matrix",genre)
      arch.write(.density_matrix)

   end

   make_scf_density_matrix(damp,n_a,method) ::: leaky
   ! Make the density matrix from the molecular orbitals.
   ! . If "damp" is present use it to damp the updated density matrix.
   !   An .old_density_matrix must exist for this to work.
   ! . If "n_a" is present it is used as the number of alpha electrons
   !   in embedded scf calculations.
   ! . If "method" is present it is used as the kind of density matrix
   !   to make, otherwise taken from .scfdata.scf_kind, or guessed
   !   from the spinorbital_kind of the MO's.
   ! NOTE:
   ! . If .scfdata.do_delta_build is set and a a .delta_density_matrix
   !   is created, then a delta density is made.
   ! . If .scfdata.apply_pFON a finite temperature density matrix is
   !   made with temperature .scfdata.temperature_for_pFON (untested)
      self :: INOUT
      damp :: BIN, optional
      n_a :: INT, optional
      method :: STR, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.associated, "no molecular orbitals")
   ENSURE(.molecular_orbitals.has_any_genre, "no molecular orbitals")

      T :: REAL
      damping,do_archive,do_delta_density :: BIN
      use_NOMO,use_ELMO,use_pFON,use_FON :: BIN
      MO,D,MOa,MOb,Da,Db,F,Fa,Fb :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      EV,Ea,Eb :: VEC{REAL}*
      scf_method,genre :: STR

      ! Determine (or guess) the kind of SCF method to be used.
      if      (present(method))     then; scf_method = method
      else if (.scfdata.associated) then; scf_method = .scfdata.scf_kind
      else;                               scf_method = .molecular_orbitals.guess_scf_kind
      end

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                          genre = .molecular_orbitals.spinorbital_kind
      end

      ! Make the delta density matrix?
      do_delta_density = .delta_density_matrix.associated
      if (.scfdata.associated) do_delta_density = do_delta_density AND .scfdata.do_delta_build

      ! Determine if density matrix damping is to be used
      damping = .old_density_matrix.associated
      if      (present(damp)) then;       damping = damping AND damp
      else if (.scfdata.associated) then; damping = damping AND .scfdata.apply_damping
      end

      ! Determine if NOMO should be used
      use_NOMO = FALSE
      if (.scfdata.associated) use_NOMO = .scfdata.use_NOMO

      ! Determine if ELMO should be used
      use_ELMO = FALSE
      if (.scfdata.associated) use_ELMO = .scfdata.use_ELMO

      ! Determine if pFON should be used
      use_pFON = FALSE
      if (.scfdata.associated) then
      if (.fock_matrix.associated) then
      if (.fock_matrix.is_associated_with_genre(genre)) then
         use_pFON = .scfdata.apply_pFON
      end
      end
      end

      ! Determine if finite temperature FON should be used
      use_FON = FALSE
      if (.scfdata.associated) use_pFON = .scfdata.using_FON

      ! Create the density matrix (leaky)
      if (.density_matrix.disassociated) .density_matrix.create(.n_bf)
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      ! Save the old density if damping
      .old_density_matrix.destroy
      if (do_delta_density OR damping) then
         .old_density_matrix.create_copy(.density_matrix)
         .old_density_matrix.compress
      end

      ! Make the density matrix
      select case (scf_method)

      case ("group")

         ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         ENSURE(present(n_a),"n_a must be specified")

         MO => .molecular_orbitals.restricted(:,1:n_a)
         D  => .density_matrix.restricted
         D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

      case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")

         ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.BASE:chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))

         if (use_pFON) then

            D  => .density_matrix.restricted
            MO => .molecular_orbitals.restricted
            F  => .fock_matrix.restricted
            T  =  .scfdata.temperature_for_pFON
            ::make_finite_T_density_matrix(D,MO,F,T,.n_a)
            D  = TWO*D

         else if (use_FON) then

            D  => .density_matrix.restricted
            MO => .molecular_orbitals.restricted
            EV => .orbital_energies.restricted
            T  =  .scfdata.temperature
            ::make_finite_T_DM_r(D,.scfdata.E_Fermi,MO,EV,T,.n_a)
            D  = TWO*D

         else if (.scfdata.use_NOMO) then
           
            D  => .density_matrix.restricted
            MO => .molecular_orbitals.restricted

            .:make_NOMO_density_matrix_r(D,MO)
         
         else

            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

         end

         if (scf_method(1:4)=="xray" AND .scfdata.stabilize_density) .:stabilize(D)

      case ("rohf")

         ENSURE(.molecular_orbitals.is_associated_with_genre("restricted"),"no MO's")

         Da  => .density_matrix.alpha
         Db  => .density_matrix.beta
         MOa => .molecular_orbitals.restricted(:,1:.n_a)
         MOb => .molecular_orbitals.restricted(:,1:.n_b)
         Da.to_product_of(MOa,MOa,transpose_b=TRUE)
         Db.to_product_of(MOb,MOb,transpose_b=TRUE)

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

         ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted"),"no MO's")

         if (use_pFON) then

            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta
            MOa => .molecular_orbitals.alpha
            MOb => .molecular_orbitals.beta
            Fa  => .fock_matrix.alpha
            Fb  => .fock_matrix.beta
            T = .scfdata.temperature_for_pFON
            ::make_finite_T_density_matrix(Da,MOa,Fa,T,.n_a)
            ::make_finite_T_density_matrix(Db,MOb,Fb,T,.n_b)

         else if (use_FON) then

            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta
            MOa => .molecular_orbitals.alpha
            MOb => .molecular_orbitals.beta
            Ea  => .orbital_energies.alpha
            Eb  => .orbital_energies.beta
            T = .scfdata.temperature
            ::make_finite_T_DM_u(Da,Db,.scfdata.E_Fermi,MOa,MOb,Ea,Eb,T,.n_a,.n_b)

         else if (.scfdata.use_NOMO) then
           
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta

            .:make_NOMO_density_matrix_u(Da,Db,MOa,MOb)
         
         else

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)

         end

      case ("ghf","no_ghf")
            
         ENSURE(.molecular_orbitals.is_associated_with_genre("general"),"no MO's")
         !WTF!!!? Should this be here?
         !ENSURE(.spin_multiplicity==1,"this is not a singlet state")

         if (.scfdata.use_NOMO) then
            
            D  => .density_matrix.general
            MO => .molecular_orbitals.general(:,1:.n_e)

            .:make_NOMO_density_matrix_g(D,MO)
         
         else


            MO => .molecular_orbitals.general(:,1:.n_e)
            D  => .density_matrix.general
            D.to_product_of(MO,MO,transpose_b=TRUE)
         
         end if

      case ("rchf")

         ENSURE(.molecular_orbitals.is_associated_with_genre("restricted_complex"),"no MO's")

         CMO => .molecular_orbitals.restricted_complex(:,1:.n_a)
         CD  => .density_matrix.restricted_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
         CD = TWO*CD

      case ("uchf")

         ENSURE(.molecular_orbitals.is_associated_with_genre("unrestricted_complex"),"no MO's")

         CMOa => .molecular_orbitals.alpha_complex(:,1:.n_a)
         CMOb => .molecular_orbitals.beta_complex(:,1:.n_b)
         CDa  => .density_matrix.alpha_complex
         CDb  => .density_matrix.beta_complex
         CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
         CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)

      case ("gchf","xray_gchf")

         ENSURE(.molecular_orbitals.is_associated_with_genre("general_complex"),"no MO's")

         CMO => .molecular_orbitals.general_complex(:,1:.n_e)
         CD  => .density_matrix.general_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)

      case default

         DIE("unknown SCF kind, "//trim(scf_method))

      end

      ! Damp the density matrix if required
      if (damping) then
         .old_density_matrix.uncompress
         .density_matrix.damp(.old_density_matrix,.scfdata.damp_factor)
      end

      ! Archive density matrix?
      do_archive = FALSE
      if (do_archive) .:archive(.density_matrix,"density_matrix")

      ! Debug
      .:put_debug(.density_matrix,"make_scf_density_matrix: density matrix")

      ! Save the delta density matrix for incremental Fock build
      if (do_delta_density) then
         .delta_density_matrix => .old_density_matrix
         .delta_density_matrix.scale_by(-ONE)
         .delta_density_matrix.plus(.density_matrix)
      else
         .old_density_matrix.destroy
      end

   end

   make_NOMO_density_matrix_g(D,MO)
   ! Make the inverse of the occupied-coccupied block of the MO
   ! overlap matrix.
      self :: IN
      D :: MAT{REAL}, OUT
      MO :: MAT{REAL}, IN

      S_inv :: MAT{REAL}@

      ! Make (S^MO){-1} in MO basis & back transform
      S_inv.create(.n_e,.n_e)
      S_inv = ZERO
      .:make_NOMO_S_inv_g(S_inv,MO)

      ! Back transform -> D
      S_inv.back_transform_to(D,MO)
      S_inv.destroy

   end
   
   make_NOMO_density_matrix_r(D,MO)
   ! Make the inverse of the occupied-coccupied block of the MO
   ! overlap matrix.
      self :: IN
      D :: MAT{REAL}, OUT
      MO :: MAT{REAL}, IN

      S_inv :: MAT{REAL}@

      ! Make (S^MO){-1} in MO basis & back transform
      S_inv.create(.n_a,.n_a)
      .:make_NOMO_S_inv_r(S_inv,MO)

      ! Back transform -> D
      S_inv.back_transform_to(D,MO(:,1:.n_a))
      S_inv.destroy

      ! Factor 2 for RHF
      D = TWO*D

   end
   
   make_NOMO_density_matrix_u(Da,Db,MOa,MOb)
   ! Make the inverse of the occupied-coccupied block of the MO
   ! overlap matrix.
      self :: IN
      
      Da,Db :: MAT{REAL}, OUT
      MOa,MOb :: MAT{REAL}, IN

      S_inv :: MAT{REAL}@

      ! alpha
      ! Make (S^MO){-1} in MO basis & back transform
      S_inv.create(.n_a,.n_a)
      .:make_NOMO_S_inv_u_a(S_inv,MOa)

      ! Back transform -> Da
      S_inv.back_transform_to(Da,MOa)
      S_inv.destroy


      ! beta
      ! Make (S^MO){-1} in MO basis & back transform
      S_inv.create(.n_b,.n_b)
      .:make_NOMO_S_inv_u_b(S_inv,MOb)

      ! Back transform -> Db
      S_inv.back_transform_to(Db,MOb)
      S_inv.destroy

   end

   make_NOMO_S_inv_g(S_inv,MO)
   ! Make the inverse of the occupied-occupied block of the
   ! general MO overlap matrix.
      self :: IN
      S_inv :: MAT{REAL}, OUT
      MO :: MAT{REAL}, IN

   ENSURE(.overlap_matrix.created, "NO overlap_matrix!")

      S :: MAT{REAL}*
      V :: MAT{REAL}*

      ! Make S in the SAO asis 
      V.create(2*.n_bf, 2*.n_bf)
      V = ZERO
      V.alpha_alpha_set_to(.overlap_matrix)
        V.beta_beta_set_to(.overlap_matrix)

      ! Make S in the occupied MO basis 
      S.create(.n_e,.n_e)
      V.change_basis_to(S,MO(:,1:.n_e))
      
      ! Make S^{-1} (IMPURE)
      S_inv.to_inverse_of(S)

      ! Cleanup
      S.destroy
      V.destroy

   end

   make_NOMO_S_inv_r(S_inv,MO)
   ! Make the inverse of the occupied-occupied block of the MO
   ! overlap matrix.
      self :: IN
      S_inv :: MAT{REAL}, OUT
      MO :: MAT{REAL}, IN

   ENSURE(.overlap_matrix.created, "NO overlap_matrix!")

      S :: MAT{REAL}*

      ! Make S in the occupied MO basis 
      S.create(.n_a,.n_a)
      .overlap_matrix.change_basis_to(S,MO(:,1:.n_a))
      
      ! Make S^{-1} (IMPURE)
      S_inv.to_inverse_of(S)

      ! Cleanup
      S.destroy

   end

   make_NOMO_S_inv_u_a(S_inv,MO)
   ! Make the inverse of the occupied-coccupied block of the MO
   ! overlap matrix.
      self :: IN
      S_inv :: MAT{REAL}, OUT
      MO :: MAT{REAL}, IN

   ENSURE(.overlap_matrix.created, "NO overlap_matrix!")

      S :: MAT{REAL}*

      ! Make S in the occupied MO basis 
      S.create(.n_a,.n_a)
      .overlap_matrix.change_basis_to(S,MO)
      
      ! Make S^{-1} (IMPURE)
      S_inv.to_inverse_of(S)

      ! Cleanup
      S.destroy

   end

   make_NOMO_S_inv_u_b(S_inv,MO)
   ! Make the inverse of the occupied-coccupied block of the MO
   ! overlap matrix.
      self :: IN
      S_inv :: MAT{REAL}, OUT
      MO :: MAT{REAL}, IN

   ENSURE(.overlap_matrix.created, "NO overlap_matrix!")

      S :: MAT{REAL}*

      ! Make S in the occupied MO basis 
      S.create(.n_b,.n_b)
      .overlap_matrix.change_basis_to(S,MO)
      
      ! Make S^{-1} (IMPURE)
      S_inv.to_inverse_of(S)

      ! Cleanup
      S.destroy

   end
   
!   make_ELMO_S_S_inv_r(S,S_inv,MO) ::: PURE
!   ! Make "S", the occupied-occupied block of the MO overlap matrix
!   ! and it's inverse "S_inv".
!      self :: IN
!      S,S_inv :: MAT{REAL}, OUT
!      MO :: MAT{REAL}, IN
!
!   ENSURE(.overlap_matrix.created, "NO overlap_matrix!")
!   ENSURE(S.dim1==.n_a, "wrong size, S")
!   ENSURE(S.is_square, "S is not square")
!   ENSURE(S_inv.dim1==.n_a, "wrong size, S_inv")
!   ENSURE(S_inv.is_square, "S_inv is not square")
!
!      ! Make S in the occupied MO basis 
!      .overlap_matrix.change_basis_to(S,MO(:,1:.n_a))
!      
!      ! Make S^{-1} 
!      S_inv.to_inverse_of(S)
!
!   end

   make_finite_T_density_matrix(D,MO,F,T,n_e) ::: selfless
   ! Make the finite temperature density matrix "D" from molecular
   ! orbitals "MO" according to the pFON method with temperature "T"
   ! and number of electrons "n_e" *for a given spin*, as in Rabuck
   ! and Scuseria, JCP 110, 695 (1999).  There must exist a current
   ! fock_matrix "F" made from "D" which is used to get the
   ! eigenvalues for the Fermi-Dirac distribution.
      D,MO :: MAT{REAL}
      F :: MAT{REAL}
      T :: REAL
      n_e :: INT

   ENSURE(F.is_square,"F must be square")
   ENSURE(F.is_same_shape_as(MO),"incompatible F and MO")
   ENSURE(n_e<MO.dim2,"fewer MO's than electrons")
   ENSURE(T>=ZERO,"T must be positive")

      W :: MAT{REAL}*
      occ :: VEC{REAL}*
      ind :: VEC{INT}*
      beta,e_homo,e_lumo,e_fermi,homo_lumo_gap :: REAL
      n_orb,i,j,n_frac :: INT

      n_orb = F.dim1

      occ.create(n_orb)
      ind.create(n_orb)

      ! Make the occupation numbers
      W.create(n_orb,n_orb)
      W.to_product_of(F,MO)
      do i = 1,n_orb        ! These are energies
        occ(i) = dot_product(MO(:,i),W(:,i))
      end
      occ.quick_sort(ind)   ! "ind" has the energies sorted
      W.destroy

      beta    = KELVIN_PER_HARTREE/T
      e_homo  = occ(ind(n_e))
      e_lumo  = occ(ind(n_e+1))
      e_fermi = HALF*(e_homo + e_lumo)
      homo_lumo_gap = e_lumo - e_homo
      do j = 1,n_orb        ! These are the occupation numbers
         i = ind(j)
         occ(i) = ONE/(ONE+exp(beta*(occ(i)-e_fermi)))
      end

      ! The number of fractional orbitals
      if      (homo_lumo_gap>0.135e0) then; n_frac = 5
      else if (homo_lumo_gap<0.090e0) then; n_frac = 3
      else;                                 n_frac = 4
      end

      ! Reset the fractional occupancies
      do j = 1,n_orb
         i = ind(j)
         if      (j<=n_e-n_frac) then; occ(i) = ONE
         else if (j >n_e+n_frac) then; occ(i) = ZERO
         end
      end

      ! Form the temperature broadended density
      D = ZERO
      do j = 1,n_e+n_frac
         i = ind(j)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ(i),transpose_b=TRUE)
      end

      ind.destroy
      occ.destroy

   end

   make_finite_T_DM_r(D,E_Fermi,MO,eig,T,n_e) ::: selfless
   ! Make the restricted finite temperature density matrix "D" from
   ! molecular orbitals "MO" according to the FON method with
   ! temperature "T" in Kelvin and number of electrons "n_e" *for a
   ! given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
      D :: MAT{REAL}, OUT
      E_Fermi :: REAL, OUT
      MO :: MAT{REAL}, IN
      eig :: VEC{REAL}, IN
      T :: REAL, IN
      n_e :: INT, IN

   ENSURE( D.is_square, "D must be square")
   ENSURE(MO.dim2==eig.dim,"MO and eig are incomptabile")
   ENSURE(n_e<=MO.dim2,"fewer MO's than electrons")
   ENSURE(T>ZERO,"T must be positive")

      i :: INT
      occ :: REAL

      ! Set temperature and eigenvalues
      REAL:set_T_Fermi(T)
      REAL:set_E_level(eig)
      REAL:set_n_electrons(n_e)

      ! Find the Fermi energy
      REAL:find_root_brent(REAL::Fermi_Dirac_excess_fn,x1=eig(1),x2=eig(n_e+1),root=E_Fermi,tol=TOL(6))

      if (TRUE) then
         stdout.show("HOMO      =",eig(n_e))
         stdout.show("LUMO      =",eig(n_e+1))
         stdout.show("E_Fermi   =",E_Fermi)
      end

      ! Set the Fermi energy
      REAL:set_E_Fermi(E_Fermi)

      ! Form the temperature broadended density
      D = ZERO
      do i = 1,MO.dim2
         occ = REAL:Fermi_Dirac_fn(i)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ,transpose_b=TRUE)
      end

   end

   make_finite_T_DM_u(Da,Db,E_Fermi,MOa,MOb,Ea,Eb,T,n_a,n_b) ::: selfless
   ! Make the restricted finite temperature density matrix "D" from
   ! molecular orbitals "MO" according to the FON method with
   ! temperature "T" in Kelvin and number of electrons "n_e" *for a
   ! given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
      Da,Db :: MAT{REAL}, OUT
      E_Fermi :: REAL, OUT
      MOa,MOb :: MAT{REAL}, IN
      Ea,Eb :: VEC{REAL}, IN
      T :: REAL, IN
      n_a,n_b :: INT, IN

   ENSURE( Da.is_square, "Da must be square")
   ENSURE( Db.is_square, "Da must be square")
   ENSURE(MOa.dim2==Ea.dim,"MOa and Ea are incomptabile")
   ENSURE(MOb.dim2==Eb.dim,"MOb and Eb are incomptabile")
   ENSURE(n_b<=MOb.dim2,"fewer MOb's than electrons")
   ENSURE(T>ZERO,"T must be positive")

      i :: INT
      Emin,Emax,occ :: REAL

      ! Set temperature and eigenvalues
      REAL:set_T_Fermi(T)
      REAL:set_E_level(Ea,Eb)
      REAL:set_n_electrons(n_a+n_b)

      ! Find the Fermi energy
      Emin = min(Ea( 1 ),Eb( 1 ))
      Emax = max(Ea(n_a),Eb(n_b))
      REAL:find_root_brent(REAL::Fermi_Dirac_excess_fn,x1=Emin,x2=Emax,root=E_Fermi,tol=TOL(6))

      if (TRUE) then
         stdout.show("HOMOa     =",Ea(n_a))
         stdout.show("HOMOb     =",Eb(n_b))
         stdout.show("LUMOa     =",Ea(n_a+1))
         stdout.show("LUMOb     =",Ea(n_b+1))
         stdout.show("E_Fermi   =",E_Fermi)
      end

      ! Set the Fermi energy
      REAL:set_E_Fermi(E_Fermi)

      ! Form the temperature broadended density
      Da = ZERO
      do i = 1,MOa.dim2
         occ = REAL:Fermi_Dirac_fn(i)
         Da.plus_scaled_product_of(MOa(:,i:i),MOa(:,i:i),fac=occ,transpose_b=TRUE)
      end

      Db = ZERO
      do i = 1,MOb.dim2
         occ = REAL:Fermi_Dirac_fn(n_a+i)
         Db.plus_scaled_product_of(MOb(:,i:i),MOb(:,i:i),fac=occ,transpose_b=TRUE)
      end

   end

   make_ao_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix. The result is placed in the "restricted" part of the density
   ! matrix.

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")

      ! Leaky
      .:make_ao_density_matrix(.density_matrix)

   end

   make_ao_density_matrix(D) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix.
      self :: IN
      D :: OPMATRIX*

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.associated, "no density matrix")
   ENSURE(D.has_any_genre, "no density matrix")

      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = D.spinorbital_kind
      end

      select case (genre)

         case ("restricted")
            ! do nothing

         case ("unrestricted")

            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.alpha + D.beta

         case ("general")

            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.general.alpha_alpha + D.general.beta_beta

         case ("restricted_complex")
            ! do nothing

         case ("unrestricted_complex")

            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.alpha_complex + D.beta_complex

         case ("general_complex")

            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.general_complex.alpha_alpha + D.general_complex.beta_beta

         case default

            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_density_matrix(P)
   ! Make the AO (spin independent) density matrix "P" from the
   ! existing density matrix.
      P :: MAT{REAL}

      .:make_ao_RE_density_matrix(P)

   end

   make_ao_RE_density_matrix(P)
   ! Make the REAL AO (spin independent) density matrix "P" from the
   ! existing density matrix.
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      select case (genre)

         case ("restricted")
            P = .density_matrix.restricted

         case ("unrestricted")
            P = .density_matrix.alpha + .density_matrix.beta

         case ("general")
            P = .density_matrix.general.alpha_alpha &
              + .density_matrix.general.beta_beta

         case ("restricted_complex")
            P = RE(.density_matrix.restricted_complex)

         case ("unrestricted_complex")
            P = RE(.density_matrix.alpha_complex) &
              + RE(.density_matrix.beta_complex)

         case ("general_complex")
            P = RE(.density_matrix.general_complex.alpha_alpha) &
              + RE(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_IM_density_matrix(P)
   ! Make the IMAGINARY AO (spin independent) density matrix "P" from
   ! the existing density matrix.
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      P = ZERO

      if (genre=="restricted")   return
      if (genre=="unrestricted") return
      if (genre=="general")      return

      select case (genre)

         case ("restricted_complex")
            P = IM(.density_matrix.restricted_complex)

         case ("unrestricted_complex")
            P = IM(.density_matrix.alpha_complex) &
              + IM(.density_matrix.beta_complex)

         case ("general_complex")
            P = IM(.density_matrix.general_complex.alpha_alpha) &
              + IM(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_sz_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included.

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")

      .:make_ao_sz_density_matrix(.density_matrix)   ! leaky

   end

   make_ao_sz_density_matrix(D) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included!
      D :: OPMATRIX*

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.associated, "no density matrix")
   ENSURE(D.has_any_genre, "no density matrix")

      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = D.spinorbital_kind
      end

      if (genre=="restricted") return

      select case (genre)

         case ("unrestricted")
            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.alpha - D.beta

         case ("general")
            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.general.alpha_alpha - D.general.beta_beta

         case ("unrestricted_complex")
            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.alpha_complex - D.beta_complex

         case ("general_complex")
            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.general_complex.alpha_alpha - D.general_complex.beta_beta

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_sz_density_matrix(P) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included!
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            P = .density_matrix.alpha &
              - .density_matrix.beta

         case ("general")
            P = .density_matrix.general.alpha_alpha &
              - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            P = RE(.density_matrix.alpha_complex) &
              - RE(.density_matrix.beta_complex )

         case ("general_complex")
            P = RE(.density_matrix.general_complex.alpha_alpha) &
              - RE(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_spin_densities(S) ::: leaky
   ! Make  the AO spin density matrices.
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            S(:,:,3) = .density_matrix.alpha &
                     - .density_matrix.beta

         case ("general")
            S(:,:,1) = .density_matrix.general.alpha_beta  &
                     + .density_matrix.general.beta_alpha
            S(:,:,3) = .density_matrix.general.alpha_alpha &
                     - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            S(:,:,3) = .density_matrix.alpha_complex &
                     - .density_matrix.beta_complex

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) =   .density_matrix.general_complex.alpha_beta  &
                     +   .density_matrix.general_complex.beta_alpha
            S(:,:,2) = I*.density_matrix.general_complex.alpha_beta  &
                     - I*.density_matrix.general_complex.beta_alpha
            S(:,:,3) =   .density_matrix.general_complex.alpha_alpha &
                     -   .density_matrix.general_complex.beta_beta

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_RE_spin_densities(S) ::: leaky
   ! Make the REAL part of the AO spin density matrices.
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            S(:,:,3) = .density_matrix.alpha &
                     - .density_matrix.beta

         case ("general")
            S(:,:,1) = .density_matrix.general.alpha_beta  &
                     + .density_matrix.general.beta_alpha
            S(:,:,3) = .density_matrix.general.alpha_alpha &
                     - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            S(:,:,3) = RE(.density_matrix.alpha_complex) &
                     - RE(.density_matrix.beta_complex)

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) = RE(  .density_matrix.general_complex.alpha_beta)  &
                     + RE(  .density_matrix.general_complex.beta_alpha)
            S(:,:,2) = RE(I*.density_matrix.general_complex.alpha_beta)  &
                     - RE(I*.density_matrix.general_complex.beta_alpha)
            S(:,:,3) = RE(  .density_matrix.general_complex.alpha_alpha) &
                     - RE(  .density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_IM_spin_densities(S) ::: leaky
   ! Make the IMAGINARY part of the AO spin density matrices.
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted")   return
      if (genre=="unrestricted") return
      if (genre=="general")      return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted_complex")
            S(:,:,3) = IM(.density_matrix.alpha_complex) &
                     - IM(.density_matrix.beta_complex)

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) = IM(  .density_matrix.general_complex.alpha_beta)  &
                     - IM(  .density_matrix.general_complex.beta_alpha)
            S(:,:,2) = IM(I*.density_matrix.general_complex.alpha_beta)  &
                     - IM(I*.density_matrix.general_complex.beta_alpha)
            S(:,:,3) = IM(  .density_matrix.general_complex.alpha_alpha) &
                     - IM(  .density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      n :: INT, IN
      nb :: INT, IN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.associated, "no molecular orbitals")

      MO,D,MOa,MOb,Da,Db :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      genre :: STR
      arch :: ARCHIVE
      m :: INT
      uhf :: BIN

      uhf = .scfdata.scf_kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")

      m = n
      if (present(nb)) m = nb

      genre = .scfdata.spinorbital_kind
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      select case (.scfdata.scf_kind)

         case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")

            ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.BASE:chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))

            D  => .density_matrix.restricted

            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals.restricted(:,n:n)
               D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            else
               D = ZERO
            end

         case ("rohf")

            Da => .density_matrix.alpha
            Db => .density_matrix.beta

            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               MOb => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Da = ZERO
               Db = ZERO
            end

         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

            Da => .density_matrix.alpha
            Db => .density_matrix.beta

            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals.alpha(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end

            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals.beta(:,m:m)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end

         case ("ghf", "no_ghf")

            ENSURE(.spin_multiplicity==1,"this is not a singlet state")

            D =>  .density_matrix.general

            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals.general(:,n:n)
               D.to_product_of(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end

         case ("rchf")

            CD => .density_matrix.restricted_complex

            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals.restricted_complex(:,n:n)
               CD.to_scaled_product_of(CMO,CMO,fac=TWO,dagger_b=TRUE)
            else
               CD = ZERO
            end

         case ("uchf")

            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex

            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals.alpha_complex(:,n:n)
               CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
            else
               CDa = ZERO
            end

            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals.beta_complex(:,m:m)
               CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)
            else
               CDb = ZERO
            end

         case ("gchf","xray_gchf")

            CD =>  .density_matrix.general_complex

            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals.general_complex(:,n:n)
               CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end

         case default;
            DIE("unknown kind, "//trim(.scfdata.scf_kind))

      end

      ! Archive
      arch.set(.name,"density_matrix",genre)
      arch.write(.density_matrix)

   end

!  ==========================
!  Set atoms density matrices
!  ==========================

   make_aspherical_atoms ::: leaky
   ! Get the aspherical atom density matrix i.e. just copy the
   ! atom-atom block from the molecular density matrix.

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.associated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.has_any_genre,"no density_matrix")

      D :: OPMATRIX*
      genre :: STR
      a :: INT

      if (.:has_all_ANOs_made) .:destroy_ANOs

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .molecular_orbitals.spinorbital_kind
      end

      ! Copy existing density matrix
      D.create_copy(.density_matrix)

      ! Make the restricted density matrix
      .:make_ao_density_matrix(D)


      ! Set athe atom densities
      do a = 1,.n_atom
         .:set_density_matrix_for_atom(a,D.restricted)
      end

      D.destroy

   end

   set_density_matrix_for_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      a :: INT
      D :: MAT{REAL}, IN

   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.restricted.associated,"no density_matrix")

      f,l :: INT

      ! Create a-th atoms density matrix
      .atom(a).density_matrix.destroy
      .atom(a).density_matrix.create(.atom(a).basis.n_bf)
      .atom(a).density_matrix.create(genre="restricted")

      ! Copy the a-th atom-atom block
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      .atom(a).density_matrix.restricted = D(f:l,f:l)

      .atom(a).set_spherical_atom_data_made(TRUE)

   end

!  Spherically average atoms in existing density

   make_spherical_atoms ::: leaky
   ! Get the spherical atom natural orbitals (ANO) data for all
   ! atoms in the molecule.

   ENSURE(.atom.associated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.associated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.has_any_genre,"no density_matrix")

      D :: OPMATRIX*
      genre :: STR
      a :: INT

      if (.:has_all_spherical_atom_data) return

      if (.:has_all_ANOs_made) .:destroy_ANOs

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.associated) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .molecular_orbitals.spinorbital_kind
      end

      ! Copy existing density matrix
      D.create(.n_bf,genre)
      D.create_copy(.density_matrix)

      ! Make the restricted density matrix
      .:make_ao_density_matrix(D)


      ! Spherically average the molecule AO density
      do a = 1,.n_atom
         .:spherically_average_atom(a,D.restricted)
      end
      D.destroy

      .atom.set_spherical_atom_data_made(TRUE)

   end

   spherically_average_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      a :: INT
      D :: MAT{REAL}

   ENSURE(.atom(a).natural_orbitals.disassociated,  "NOs, atom "//trim(a.to_str))
   ENSURE(.atom(a).occupation_numbers.disassociated,"occ, atom "//trim(a.to_str))
   ENSURE(.atom(a).density_matrix.disassociated,    "DM, atom "//trim(a.to_str))

      f,l :: INT
      mol :: MOLECULE*

      ! Create the molecule
      mol.:create
      .:make_molecule_from_atom(a,mol)

      ! Get the density matrix
      mol.density_matrix.create(mol.n_bf)
      mol.density_matrix.create(genre="restricted")
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      mol.density_matrix.restricted = D(f:l,f:l)

      ! Spherically average the AO density
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.:symmetrize(mol.density_matrix)

      ! Make the natural orbitals
      mol.:make_natural_orbitals

      ! Clean up the SCF files
      mol.:delete_archive("natural_orbitals")
      mol.:delete_archive("occupation_numbers")

      ! Destroy the atoms's NO and interpolator info
      .atom(a).interpolator.destroy
      .atom(a).density_matrix.destroy
      .atom(a).occupation_numbers.destroy
      .atom(a).natural_orbitals.destroy

      ! Copy the results
      .atom(a).natural_orbitals   => mol.natural_orbitals
      .atom(a).occupation_numbers => mol.occupation_numbers
      .atom(a).density_matrix     => mol.density_matrix

      ! Make the interpolator
      .atom(a).make_interpolator

      ! Nullify parts we just copied or can't destroy
      mol.atom.nullify_ptr_part       ! do not destroy ptr part
      nullify(mol.natural_orbitals)   ! do not destroy this
      nullify(mol.occupation_numbers) ! do not destroy this
      nullify(mol.density_matrix)     ! do not destroy this
      nullify(mol.basis)              ! do not destroy this
      nullify(mol.slaterbasis)        ! do not destroy this
      nullify(mol.coppensbasis)       ! do not destroy this

      ! Safe to destroy
      mol.:destroy

   end

   put_atomic_form_factors
   ! Put the spherically averaged restricted atomic form factors
   ! for the unique atoms.

   ENSURE(.atom.associated,"no atom")
   ENSURE(.crystal.associated,"no crystal - specify H form factor type")

      length,spacing :: REAL
      IAM,val :: BIN
      a :: INT

      ! Type of IAM SF's
      IAM = .crystal.data.use_IAM_ITC_FFs

      ! Table length
      length  = 2.00d0 * FOUR*PI * ANGSTROM_PER_BOHR
      spacing = 0.05d0 * FOUR*PI * ANGSTROM_PER_BOHR

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Structure factors
         stdout.flush
         stdout.text("========================")
         stdout.text("Real form factors for "//trim(.atom(a).chemical_symbol))
         stdout.text("========================")
         stdout.flush

         val = .atom(a).use_IAM_ITC_FFs
         .atom(a).set_use_IAM_ITC_FFs(IAM)
         .atom(a).put_FT_along_z_r(length,spacing)
         .atom(a).set_use_IAM_ITC_FFs(val)  ! Put back

       ! ! Structure factors
       ! stdout.flush
       ! stdout.text("=============================")
       ! stdout.text("Imaginary form factors for "//trim(.atom(a).chemical_symbol))
       ! stdout.text("=============================")
       ! stdout.flush
       ! .atom(a).put_FT_along_z_i(length,spacing)

      end

   end

!  =============
!  Group density
!  =============

! These can be made much better if the atoms
! in the groups are assumed contigous.

   put_group_density_to(P,g,mol) ::: PURE
   ! Put the atom group "g" in the whole .density matrix into "P".
   ! "mol" is a molecule created from the appropriate atom group "g".
      self :: IN
      P :: MAT{REAL}, OUT
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")

      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT

      P = ZERO

      do a = 1,.atom_group(g).n_atoms ! Copy this atom density
      do b = 1,.atom_group(g).n_atoms
         aa  = .atom_group(g).atom_index(a)
         bb  = .atom_group(g).atom_index(b)
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         P(fa:la,fb:lb) = .density_matrix.restricted(faa:laa,fbb:lbb)
      end
      end

   end

   set_group_density_from(P,g,mol) ::: PURE
   ! Set the atom group "g" density matrix from "P". "mol" must be a
   ! molecule created from the appropriate atom group "g".
      self :: INOUT
      P :: MAT{REAL}, IN
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")

      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT

      do a = 1,.atom_group(g).n_atoms ! Copy this atom density
      do b = 1,.atom_group(g).n_atoms
         aa  = .atom_group(g).atom_index(a)
         bb  = .atom_group(g).atom_index(b)
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         .density_matrix.restricted(faa:laa,fbb:lbb) = P(fa:la,fb:lb)
      end
      end

   end

   set_group_density(g,mol) ::: PURE
   ! Set the atom group "g" .density_matrix from "P". "mol" must be a
   ! molecule created from the appropriate atom group "g".
      self :: INOUT
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.restricted.associated,"no restricted density_matrix")

      a,b,ga,gb, fga,lga, fgb,lgb, fa,la,fb,lb :: INT

     do a = 1,.atom_group(g).n_atoms
     do b = 1,.atom_group(g).n_atoms

        ga  = .atom_group(g).atom_index(a)
        gb  = .atom_group(g).atom_index(b)
        fga =    .first_basis_fn_for_atom(ga)
        lga =     .last_basis_fn_for_atom(ga)
        fgb =    .first_basis_fn_for_atom(gb)
        lgb =     .last_basis_fn_for_atom(gb)

        fa  = mol.first_basis_fn_for_atom(a)
        la  =  mol.last_basis_fn_for_atom(a)

        fb  = mol.first_basis_fn_for_atom(b)
        lb  =  mol.last_basis_fn_for_atom(b)

        .density_matrix.restricted(fga:lga,fgb:lgb) = mol.density_matrix.restricted(fa:la,fb:lb)

     end
     end

   end

   set_group_MOs(g,mol) ::: PURE
   ! Set the atom group "g" .density_matrix from "P". "mol" must be a
   ! molecule created from the appropriate atom group "g".
      self :: INOUT
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.associated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
   ENSURE(.molecular_orbitals.associated,"no MOs")
   ENSURE(.occupation_numbers.associated,"no occupation_numbers")
   ENSURE(mol.molecular_orbitals.associated,"no mol MOs")
   ENSURE(mol.molecular_orbitals.restricted.associated,"no restricted mol MOs")

      a,ga, fga,lga, fa,la, ms,mf,no :: INT

      mf = .atom_group.n_bf_up_to_mol(g)
      ms = mf + 1
      mf = mf + mol.n_bf

      do a = 1,.atom_group(g).n_atoms

         ga  = .atom_group(g).atom_index(a)
         fga =    .first_basis_fn_for_atom(ga)
         lga =     .last_basis_fn_for_atom(ga)
         fa  = mol.first_basis_fn_for_atom(a)
         la  =  mol.last_basis_fn_for_atom(a)

         .molecular_orbitals.restricted(fga:lga,ms:mf) = mol.molecular_orbitals.restricted(fa:la,:)

      end

      no = mol.n_e/2
      .occupation_numbers.restricted(ms:ms+no-1) = TWO

   end

!  =================
!  Expectation value
!  =================

   expectation(X) result (res)
   ! Evaluates the expectation value of the matrix of the operator X
   ! with the current density matrix
      self :: IN
      X :: MAT{REAL}, IN
      res :: REAL

   ENSURE(X.is_square,"X operator matrix is not square")

      orb_kind :: STR
      W :: MAT{REAL}*

      res = ZERO

      orb_kind = .density_matrix.spinorbital_kind

      select case (orb_kind)

        case ("restricted")
           ENSURE(X.dim1==.n_bf,"(rhf) wrong size, X")
           res = .density_matrix.restricted.trace_product_with(X)

        case ("unrestricted")
           ENSURE(X.dim1==.n_bf,"(uhf) wrong size, X")
           res = .density_matrix.alpha.trace_product_with(X)
           res = .density_matrix.beta.trace_product_with(X) + res

        case ("general_complex")
           ENSURE(X.dim1==2*.n_bf,"(gchf) wrong size, X")
           W.create(2*.n_bf,2*.n_bf)
           W = RE(.density_matrix.general_complex)
           res = MAT{REAL}:trace_product_with(W,X)
           W.destroy

        case default
           DIE("unimplemented kind, "//trim(orb_kind))

      end

   end

   expectation(X,with_cross_terms) result (res)
   ! Evaluates the expectation value of the matrix of the opmatrix X
   ! with the current density matrix
      self :: IN
      X :: OPMATRIX, IN
      with_cross_terms :: BIN, optional
      res :: REAL

      orb_kind, op_kind :: STR
      cross_terms :: BIN

      res = ZERO
      cross_terms = FALSE
      if (present(with_cross_terms)) cross_terms = with_cross_terms

      orb_kind = .density_matrix.spinorbital_kind
      op_kind = X.spinorbital_kind

      select case (orb_kind)
        case ("restricted")
           if(op_kind == "restricted") then
              ENSURE(X.restricted.dim1==.n_bf,"(rhf) wrong size, X")
              res = .density_matrix.restricted.trace_product_with(X.restricted)
           else
              ENSURE(X.alpha.dim1==.n_bf,"(rhf) wrong size, X")
              res = .density_matrix.restricted.trace_product_with(X.alpha)
              res = .density_matrix.restricted.trace_product_with(X.beta) + res
           end

        case ("unrestricted")
           if(op_kind == "restricted") then
              ENSURE(X.restricted.dim1==.density_matrix.alpha.dim1,"(uhf) wrong size, X")
              res = .density_matrix.alpha.trace_product_with(X.restricted)
              res = .density_matrix.beta.trace_product_with(X.restricted) + res
           else
              ENSURE(X.alpha.dim1==.density_matrix.alpha.dim1,"(uhf) wrong size, X")
              res = .density_matrix.alpha.trace_product_with(X.alpha)
              res = .density_matrix.beta.trace_product_with(X.beta) + res
              if(cross_terms) then
                 res = .density_matrix.alpha.trace_product_with(X.beta) + res
                 res = .density_matrix.beta.trace_product_with(X.alpha) + res
              end
           end

        case default
           DIE("unimplemented kind, "//trim(orb_kind))

      end

   end


!  =================
!  Molecule rotation
!  =================

   rotate_by(R)
   ! Rotate the whole molecule using matrix "R" which specifies how positions in
   ! space are to be transformed i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(R.is_square,"rotation matrix is not square")
   ENSURE(R.dim1==3,"rotation matrix must be 3x3")

      if (R.is_zero) return

      .atom.rotate_by(R)

      .:rotate_molecular_orbitals(R)
      .:rotate_density_matrix(R)

   end

   rotate_molecular_orbitals(R)
   ! Rotate the molecular orbital matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

      genre :: STR

      if (.molecular_orbitals.disassociated) return
      if (.molecular_orbitals.is_disassociated_or_no_genre) return

      genre = .molecular_orbitals.spinorbital_kind

      select case (genre)

         case("restricted")
            .:rotate_molecular_orbitals_r(.molecular_orbitals.restricted,R)

         case("unrestricted")
            .:rotate_molecular_orbitals_r(.molecular_orbitals.alpha,R)
            .:rotate_molecular_orbitals_r(.molecular_orbitals.beta,R)

         case default;   DIE("unknown kind, "//trim(genre))

      end

   end

   rotate_molecular_orbitals_r(MO,R)
   ! Rotate a restricted molecular orbitals "MO" using matrix "R",
   ! where "R" specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: IN
      MO :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO orbitals")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")
   ENSURE(NOT .use_spherical_basis,"only for cartesian bases")

      new :: MAT{REAL}*
      tr :: VEC{MAT_{REAL}}*
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      tr.make_gaussian_xyz_matrices(R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],MO(f:l,:))
      end

      MO = new

      tr.destroy
      new.destroy

   end

   rotate_density_matrix(R)
   ! Rotate the resricted density matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
   ! NOTE: the kind is taken from the MO's.
      self :: INOUT
      R :: MAT{REAL}, IN

      genre :: STR

      if (.molecular_orbitals.disassociated) return
      if (.molecular_orbitals.is_disassociated_or_no_genre) return

      genre = .molecular_orbitals.spinorbital_kind

      select case (genre)

         case("restricted")
            .:rotate_density_matrix_r(.density_matrix.restricted,R)

         case("unrestricted")
            .:rotate_density_matrix_r(.density_matrix.alpha,R)
            .:rotate_density_matrix_r(.density_matrix.beta,R)


         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   rotate_density_matrix_r(P,R)
   ! Rotate the density matrix "P" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      self :: IN
      P :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(P.is_square,"wrong shape for density matrix P")
   ENSURE(P.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")

      new :: MAT{REAL}*
      tr :: VEC{MAT_{REAL}}*
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      tr.make_gaussian_xyz_matrices(R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],P(f:l,:))
      end

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         P(:,f:l).to_product_of(new(:,f:l),tr(a)[:,:],transpose_b=TRUE)
      end

      tr.destroy
      new.destroy

   end

   rotate_group(g,axis,angle) ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
      g :: INT
      axis :: VEC{REAL}(3)
      angle :: REAL

   ENSURE(.atom_group.associated,"no atom group information")

      mol :: MOLECULE*
      archive :: ARCHIVE
      R :: MAT{REAL}(3,3)
      v :: VEC{REAL}(3)
      P :: MAT{REAL}*
      i,a :: INT

      ! Clean up different-geometry data
      .:delete_scf_archives

      R.to_3x3_rotation_matrix(axis,angle)

      ! Rotate atoms; the line below does not work
      do i = 1,.atom_group(g).n_atoms
         a = .atom_group(g).atom_index(i)
         v = .atom(a).position
         .atom(a).position.to_product_of(R,v)
         .atom(a).ADP_tensor.back_transform_using(R)
      end

      .molecular_orbitals.destroy         ! leaky here
      if (.density_matrix.disassociated) return

      ENSURE(.density_matrix.restricted.associated,"group rotation for restricted DM only")

      ! Create molecule
      mol.:create
      .:make_molecule_from_atom_group(g,mol)

      ! Rotate density
      P.create(mol.n_bf,mol.n_bf)
      .:put_group_density_to(P,g,mol)
      mol.:rotate_density_matrix_r(P,R)
      .:set_group_density_from(P,g,mol)
      P.destroy

      mol.atom.nullify_ptr_part ! do not destroy these
      nullify(mol.basis)        ! do not destroy this
      nullify(mol.slaterbasis)  ! do not destroy this
      nullify(mol.coppensbasis) ! do not destroy this
      mol.:destroy

      ! Write out the density matrix
      archive.set(.name,"density_matrix",genre="restricted")
      archive.write(.density_matrix)

   end

!  ==============================
!  Shift/remove linear dependence
!  ==============================

   shift_dependence_from(F)
   ! Level shift the linear dependence in "F"
      F :: OPMATRIX, INOUT

   ENSURE(.scfdata.associated,"no scfdata")

      s_kind :: STR

      ! Extrapolate compressed entities
      s_kind = .scfdata.spinorbital_kind
      select case (s_kind)
         case("rhf","rks","xray_rhf","xray_rks","rdvpt")
            .:shift_dependence_from_r(F.restricted)
         case("uhf","uks","rohf","pnd_uhf","pnd_uks","xray_uhf","xray_uks","xray_pnd_uhf","xray_pnd_uks")
            .:shift_dependence_from_r(F.alpha)
            .:shift_dependence_from_r(F.beta)
         case default
            ! Unimplemented !!!
      end

   end

   shift_dependence_from_r(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors "evec" with small eigenvalue "eval".
   ! WARNING: this routine assumes eval's are ordered
   ! smallest to largest.
      F :: MAT{REAL}

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.overlap_eigenvectors.associated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.associated,"no overlap_eigenvalues")
   ENSURE(F.dim1==.n_bf,"wrong size, F")

      n :: INT
      tol,shift :: REAL

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Decouple and shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      ::decouple_and_shift_r(F,.overlap_eigenvectors,n,shift)

   end

   decouple_and_shift_r(F,evec,n,shift) ::: selfless
   ! In "F", decouple the first "n" eigenvectors "evec" and shift them
   ! to eigenvalue "shift". NOTE: ensure "evec" is orthonormal.
      F :: MAT{REAL}
      evec :: MAT{REAL}, IN
      n :: INT, IN
      shift  :: REAL, IN

      ! Return if no vectores to shift/decouple
      if (n<=0) return

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the vectors
      F(:n,n+1:) = ZERO
      F(n+1:,:n) = ZERO

      ! Shift the first n eigenvectors
      F(:n,:n).set_diagonal_to(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)

   end

   remove_dependence_from(F)
   ! Zero-out the linear dependence in "F"
      self :: INOUT
      F :: OPMATRIX, INOUT

   ENSURE(.scfdata.associated,"no scfdata")

      s_kind :: STR

      ! Extrapolate compressed entities
      s_kind = .scfdata.spinorbital_kind
      select case (s_kind)
         case("rhf","rks","xray_rhf","xray_rks","rdvpt")
            .:remove_dependence_from_r(F.restricted)
         case("uhf","uks","rohf","pnd_uhf","pnd_uks","xray_uhf","xray_uks","xray_pnd_uhf","xray_pnd_uks")
            .:remove_dependence_from_r(F.alpha)
            .:remove_dependence_from_r(F.beta)
         case default
            ! Unimplemented !!!
      end

   end

   remove_dependence_from_r(F) ::: PURE
   ! In "F", remove the linearly-dependent overlap eigenvectors.
      self :: INOUT
      F :: MAT{REAL}, INOUT

   ENSURE(.scfdata.associated,"no scfdata")
   ENSURE(.overlap_eigenvectors.associated,"no overlap_eigenvectors")
   ENSURE(F.dim1==.n_bf,"wrong size, F")

      tol :: REAL
      n :: INT

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Return if no vectores to shift/decouple
      if (n<=0) return

      ! Change to the eigenvector basis
      F.change_basis_using(.overlap_eigenvectors)

      ! Zero couplings 
      F( : ,1:n) = ZERO
      F(1:n, : ) = ZERO

      ! Revert from the eigenvector basis
      F.back_transform_using(.overlap_eigenvectors)

   end

!  ================
!  Natural orbitals
!  ================

   make_natural_orbitals(genre) ::: leaky
   ! Make the natural orbitals from the density matrix
      genre :: STR, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.has_any_genre, "no density matrix")

      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .density_matrix.spinorbital_kind
      end

      select case (orb_kind)
         case ("restricted        "); .:make_restricted_NOs
         case ("unrestricted      "); .:make_unrestricted_NOs
!        case ("general           "); .:make_general_NOs
         case ("restricted_complex"); .:make_restricted_complex_NOs
         case ("general_complex   "); .:make_general_complex_NOs
         case default;                UNKNOWN(orb_kind)
      end

   end

   make_restricted_NOs ::: leaky
   ! Make the restricted natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.restricted.associated, "no density matrix")
   ENSURE(.overlap_matrix.associated, "no overlap matrix")

      ! Recreate (leaky)
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")

      ! Make the restricted NO's
      .:make_r_NOs(.natural_orbitals.restricted,   &
                    .occupation_numbers.restricted, &
                    .density_matrix.restricted)

   end

   make_unrestricted_NOs ::: leaky
   ! Make the unrestricted natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.alpha.associated, "no density matrix")
   ENSURE(.density_matrix.beta.associated, "no density matrix")
   ENSURE(.overlap_matrix.associated, "no overlap matrix")

      ! Recreate (leaky)
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"unrestricted")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"unrestricted")

      ! Make the unrestricted NO's
      .:make_r_NOs(.natural_orbitals.alpha,.occupation_numbers.alpha,.density_matrix.alpha)
      .:make_r_NOs(.natural_orbitals.beta, .occupation_numbers.beta, .density_matrix.beta)

   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      self :: INOUT
      NO,P :: MAT{REAL}
      occupation :: VEC{REAL}

   ENSURE(.overlap_matrix.associated,"no overlap matrix")

      V,X :: MAT{REAL}*

      V.create(.n_bf,.n_bf)
      .:make_r_overlap_sqrt(V)

      X.create(.n_bf,.n_bf)

      P.change_basis_to(X,V)
      X.solve_symmetric_eigenproblem(occupation,V)

      .:make_r_overlap_inverse_sqrt(X)

      NO.to_product_of(X,V)

      X.destroy
      V.destroy

      occupation = occupation(.n_bf:1:-1)
      NO         = NO(:,.n_bf:1:-1)

      if (.:debugging("make_r_NOs")) then
         stdout.flush
         stdout.show("Formula = ",.BASE:chemical_formula)
         stdout.text("occupation:")
         stdout.put(occupation)
         stdout.text("NO:")
         stdout.put(NO)
      end

   end

   make_restricted_complex_NOs ::: leaky
   ! Make the restricted complex natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_matrix.associated, "no density matrix")
   ENSURE(.density_matrix.restricted_complex.associated, "no density matrix")
   ENSURE(.overlap_matrix.associated, "no overlap matrix")

      V,X :: MAT{CPX}*
      O :: MAT{REAL}*

      ! Recreate
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted_complex")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")

      V.create(.n_bf,.n_bf)
      O.create(.n_bf,.n_bf)

      .:make_r_overlap_sqrt(O)

      X.create(.n_bf,.n_bf)
      .density_matrix.restricted_complex.change_basis_to(X,O)
      X.solve_hermitian_eigenproblem(.occupation_numbers.restricted,V)
      X.destroy

      .:make_r_overlap_inverse_sqrt(O)

      .natural_orbitals.restricted_complex.to_product_of(O,V)

      O.destroy
      V.destroy

      .occupation_numbers.restricted       = .occupation_numbers.restricted(.n_bf:1:-1)
      .natural_orbitals.restricted_complex = .natural_orbitals.restricted_complex(:,.n_bf:1:-1)

   end

   make_general_complex_NOs ::: leaky
   ! Make the general natural orbitals and occupations from the
   ! complex density matrix.
      self :: INOUT

   ENSURE(.density_matrix.associated,"no density matrix")
   ENSURE(.density_matrix.general_complex.associated,"no density matrix")
   ENSURE(.overlap_matrix.associated, "no overlap matrix")

      R :: MAT{REAL}*
      V,X :: MAT{CPX}*

      ! Recreate
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"general_complex")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"general")


      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)

      .:make_r_overlap_sqrt(R)

      V = ZERO
      V.alpha_alpha_set_to(R)
      V.beta_beta_set_to(R)

      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .density_matrix.general_complex
      X.change_basis_using(V)
      X.solve_hermitian_eigenproblem(.occupation_numbers.general,V)

      R.create(.n_bf,.n_bf)
      .:make_r_overlap_inverse_sqrt(R)

      X = ZERO
      X.alpha_alpha_set_to(R)
      X.beta_beta_set_to(R)
      R.destroy

      .natural_orbitals.general_complex.to_product_of(X,V)
      .occupation_numbers.general = .occupation_numbers.general(2*.n_bf:1:-1)
      .natural_orbitals.general   = .natural_orbitals.general(:,2*.n_bf:1:-1)

      X.destroy
      V.destroy

   end

   make_density_matrix_from(NO,occupations,genre) ::: leaky
   ! Make the density_matrix from the natural orbitals and the
   ! occupation numbers.
      NO :: OPMATRIX, IN
      occupations :: OPVECTOR, IN
      genre :: STR, IN, optional

   ENSURE(.basis_info_made, "no basis info")


      genus :: STR
      Pr :: MAT{REAL}*
    ! Pc :: MAT{CPX}*


      if (present(genre)) then; genus = genre
      else;                     genus = .natural_orbitals.spinorbital_kind
      end

      select case (genus)

         case ("restricted        ")

             ENSURE(NO.restricted.associated,"no restricted NOs")
             ENSURE(occupations.restricted.associated,"no restricted occupations")

             .density_matrix.destroy
             .density_matrix.create(.n_bf,"restricted")

             Pr.create(.n_bf,.n_bf)

             Pr.to_product_with_diagonal(NO.restricted,occupations.restricted)
             .density_matrix.restricted.to_product_of(Pr,NO.restricted,transpose_b=TRUE)

             Pr.destroy

         case ("unrestricted      ")

             ENSURE(NO.alpha.associated,"no alpha NOs")
             ENSURE(NO.beta.associated, "no beta NOs")
             ENSURE(occupations.alpha.associated,"no alpha occupations")
             ENSURE(occupations.beta.associated, "no beta occupations")

             .density_matrix.destroy
             .density_matrix.create(.n_bf,"unrestricted")

             Pr.create(.n_bf,.n_bf)

             Pr.to_product_with_diagonal(NO.alpha,occupations.alpha)
             .density_matrix.alpha.to_product_of(Pr,NO.alpha,transpose_b=TRUE)

             Pr.to_product_with_diagonal(NO.beta,occupations.beta)
             .density_matrix.beta.to_product_of(Pr,NO.beta,transpose_b=TRUE)

             Pr.destroy

         case default;                UNKNOWN(genus)

      end

   end

!  ===================
!  Overlap matrix sqrt
!  ===================

   make_r_overlap_sqrt(S_sqrt) ::: leaky
   ! Get "S_sqrt", the sqrt overlap matrix
      S_sqrt :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.associated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.associated,"no overlap_values")
   ENSURE(S_sqrt.is_square,"non-square S_qrt")
   ENSURE(S_sqrt.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.associated) then
         tol   = .scfdata.linear_dependence_tol
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

   make_r_overlap_inverse_sqrt(S_inv) ::: leaky
   ! Get "S_inv", the inverse sqrt overlap matrix
      S_inv :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.associated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.associated,"no overlap_values")
   ENSURE(S_inv.is_square,"non-square S_inv")
   ENSURE(S_inv.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.associated) then
         tol   = .scfdata.linear_dependence_tol
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

!  ==========================
!  Natural orbital assignment
!  ==========================

   assign_NOs_to_MOs ::: leaky
   ! Assign the natural orbitals to be the molecular_orbitals
   ENSURE(.molecular_orbitals.associated, "no molecular orbitals")
   ENSURE(.molecular_orbitals.has_any_genre, "no molecular orbitals")

      NO_kind :: STR

      .natural_orbitals.destroy
      .natural_orbitals.create_copy(.molecular_orbitals)

      NO_kind = .natural_orbitals.spinorbital_kind

      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,NO_kind)

      .occupation_numbers.set_to_zero
      .:set_scf_occupations(NO_kind)

   end

   assign_MOs_to_NOs ::: leaky
   ! Assign the MOs to be the same as the natural orbitals

      NO_kind :: STR

      .molecular_orbitals.destroy
      .molecular_orbitals.create_copy(.natural_orbitals)

      NO_kind = .natural_orbitals.spinorbital_kind

      .occupation_numbers.destroy
      .occupation_numbers.create(NO_kind)

      .occupation_numbers.set_to_zero
      .:set_scf_occupations(NO_kind)

   end

!  ================
!  Symmetry methods
!  ================

   symmetrize(mat,orb_kind)
   ! Symmetrize an opmatrix matrix "mat" and of spinorbital_kind
   ! "orb_kind" (if specified)
      mat :: OPMATRIX
      orb_kind :: STR, optional

      itemkind :: STR

      itemkind = mat.spinorbital_kind
      if (present(orb_kind)) itemkind = orb_kind

      select case (itemkind)
         case ("restricted");           .:symmetrize(mat.restricted)
         case ("unrestricted");         .:symmetrize(mat.alpha)
                                        .:symmetrize(mat.beta)
         case ("general");              .:symmetrize(mat.general.alpha_alpha)
                                        .:symmetrize(mat.general.beta_beta)
                                        .:symmetrize(mat.general.alpha_beta)
                                        .:symmetrize(mat.general.beta_alpha)
         case ("restricted_complex");   .:symmetrize(mat.restricted_complex)
         case ("unrestricted_complex"); .:symmetrize(mat.alpha_complex)
                                        .:symmetrize(mat.beta_complex)
         case ("general_complex");      .:symmetrize(mat.general_complex.alpha_alpha)
                                        .:symmetrize(mat.general_complex.beta_beta)
                                        .:symmetrize(mat.general_complex.alpha_beta)
                                        .:symmetrize(mat.general_complex.beta_alpha)
         case default;   DIE("unknown kind, "//trim(orb_kind))
      end

   end

   symmetrize(mat) ::: template
   ! Symmetrize a matrix
      mat :: MAT{TYPE}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,"no atom list")
   ENSURE(.pointgroup.associated, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,W :: MAT{TYPE}*
      tra,trb :: MAT{REAL}*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}*

      image.create(.n_shell, .pointgroup.order)
      .:make_image_of_shell(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.pointgroup.order

         do a = 1,.n_shell

            tra => .pointgroup.xyz_matrix(n,.angular_moment_for_shell(a))
            i = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb => .pointgroup.xyz_matrix(n,.angular_moment_for_shell(b))
               j = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               W.create(na,nb)
               W.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(W,trb,transpose_b=TRUE)
               W.destroy

            end

         end

      end

      mat = sym/REALIFY(.pointgroup.order)

      sym.destroy
      image.destroy

   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE=>REAL)
   ! Symmetrize a matrix
   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE=>CPX)
   ! Symmetrize a matrix
   end

   make_image_of_shell(res) ::: PURE
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! pointgroup operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      self :: IN
      res :: MAT{INT}, OUT

   ENSURE(.pointgroup.associated, "no pointgroup")
   ENSURE(res.dim1==.n_shell,          "wrong dim2, res")
   ENSURE(res.dim2==.pointgroup.order, "wrong dime2, res")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.pointgroup.order
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos.to_product_of(.pointgroup.mat(:,:,n), .atom(aa).position)

         new_atom = .atom.atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end


!   stabilize(mat,orb_kind) ::: get_from(stabilize, symmetrise=>stabilize)
!   ! Symmetrise an opmatrix matrix "mat" of spinorbital_kind "orb_kind" (if
!   ! specified)
!   end

   stabilize(mat) ::: template
   ! Stabilize a matrix
      mat :: MAT{TYPE}

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.associated,"no atom list")
   ENSURE(.crystal.associated, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,w :: MAT{TYPE}*
      tra,trb :: MAT{REAL}*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}*

      image.create(.n_shell,.crystal.n_stabilizer_symops)
      .:make_image_of_stabilizer(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.crystal.n_stabilizer_symops

         do a = 1,.n_shell

            tra => .crystal.xyz_stabilizer_matrix(n,.angular_moment_for_shell(a))

            i  = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb => .crystal.xyz_stabilizer_matrix(n,.angular_moment_for_shell(b))

               j  = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               w.create(na,nb)
               w.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(w,trb,transpose_b=TRUE)
               w.destroy

            end

         end

      end

      mat = sym/REALIFY(.crystal.n_stabilizer_symops)

      sym.destroy
      image.destroy

   end

   stabilize(mat) ::: get_from(stabilize, TYPE=>REAL)
   ! Stabilize a matrix
   end

   stabilize(mat) ::: get_from(stabilize, TYPE=>CPX)
   ! Stabilize a matrix
   end

   make_image_of_stabilizer(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! a crystal stabilizer operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      self :: IN
      res :: MAT{INT}, OUT

   ENSURE(.crystal.associated, "no crystal")
   ENSURE(res.dim1==.n_shell,                    "wromg dim1, res")
   ENSURE(res.dim2==.crystal.n_stabilizer_symops,"wromg dim2, res")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.crystal.n_stabilizer_symops
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos.to_product_of(.crystal.ptr(:,:,n), .atom(aa).position)

         new_atom = .atom.atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end

!  ==================
!  Archiving routines
!  ==================

   archive(opmatrix,archive_name,genre,with_lambda)
   ! Save "opmatrix" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opmatrix :: OPMATRIX
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opmatrix,genre)

      if (avec_lambda) then
        if (.scfdata.associated) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opmatrix,genre)
        end
        end
      end

   end

   archive(opvector,archive_name,genre,with_lambda)
   ! Save "opvector" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opvector,genre)
      if (avec_lambda) then
        if (.scfdata.associated) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opvector,genre)
        end
        end
      end
   end

   archive(item,archive_name,genre,with_lambda)
   ! Save "item" to an archive on disk with name "archive_name".
      item :: REAL
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(item,genre)
      if (avec_lambda) then
        if (.scfdata.associated) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(item,genre)
        end
        end
      end
   end

   unarchive(opmatrix,archive_name,genre) ::: leaky
   ! Recover the "opmatrix" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opmatrix".
      opmatrix :: OPMATRIX*
      archive_name :: STR
      genre :: STR, optional
   ENSURE(opmatrix.has_any_genre,"no opmatrix genre created")
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opmatrix,genre)
   end

   unarchive(opvector,archive_name,genre) ::: leaky
   ! Recover the "opvector" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opvector".
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
   ENSURE(opvector.has_any_genre,"no opvector genre created")
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opvector,genre)
   end

   unarchive(item,archive_name,genre) ::: leaky
   ! Recover the "item" from an archive on disk with name "archive_name".
      item :: REAL
      archive_name :: STR
      genre :: STR, optional
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(item,genre)
   end

   unarchive(archive_name,genre) ::: template
   ! Recover the object from an archive on disk
      archive_name,genre :: STR, optional
   ENSURE(.basis_info_made,"no basis set info")
      name :: STR
      name = "NAME"
      if (present(archive_name)) name = archive_name
      if (.NAME.disassociated) then
        ENSURE(present(genre),"missing genre")
        .NAME.create(.n_bf,genre)
      end
      .unarchive(.NAME,name,genre)
   end

   delete_archive(name)
   ! Delete the archive called "name"
      name :: STR, IN

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,name)
      archive.delete_all_genres

   end

   archive_exists(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      archive_name,genre :: STR
      res :: BIN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = archive.exists
   end

   archive_doesnt_exist(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      archive_name,genre :: STR
      res :: BIN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = NOT archive.exists
   end

!  ===================
!  SCF archive cleanup
!  ===================

! May be needed by involved non-SCF routines

   delete_scf_archives(keep_MOs,keep_DM) ::: recursive
   ! Delete any SCF-procedure generated archives stored on disk.
      self :: IN
      keep_MOs,keep_DM :: BIN, optional

      archive :: ARCHIVE
      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      archive.set_defaults

      if (delete_MOs) then
      archive.set(.name,"molecular_orbitals");          archive.delete_all_genres
      archive.set(.name,"orbital_energies");            archive.delete_all_genres
      end

      if (delete_DM) then
      archive.set(.name,"density_matrix");              archive.delete_all_genres
      end

      archive.set(.name,"fock_matrix");                 archive.delete_all_genres
      archive.set(.name,"natural_orbitals");            archive.delete_all_genres
      archive.set(.name,"occupation_numbers");          archive.delete_all_genres
      archive.set(.name,"energy");                      archive.delete_all_genres

      archive.set(.name,"promolecule_density_matrix");  archive.delete_all_genres
      archive.set(.name,"group_density_matrix");        archive.delete_all_genres
      archive.set(.name,"group_molecular_orbitals");    archive.delete_all_genres

      archive.set(.name,"U_electric_dipole");           archive.delete_all_genres
      archive.set(.name,"U2_electric_dipole");          archive.delete_all_genres

      archive.set(.name,"j_matrix");                    archive.delete_all_genres
      archive.set(.name,"constraint_matrix");           archive.delete_all_genres

      archive.set(.name,"eri_integrals");               archive.delete_all_genres
      archive.set(.name,"eri_index");                   archive.delete_all_genres

      ! WARNING: These two below are recursive
      .:delete_atom_scf_archives
      .:delete_group_scf_archives

      .:delete_lambda_scf_archives(keep_MOs)

   end

   delete_lambda_scf_archives(keep_MOs) ::: private
   ! Delete any lambda type archives stored on disk.
      keep_MOs :: BIN, optional

      l,l_max :: REAL
      l_str :: STR(len=5)
      archive :: ARCHIVE
      delete_MOs :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      if (NOT delete_MOs)                  return
      if (.scfdata.disassociated)              return
      if (NOT .scfdata.is_constrained_scf) return

      archive.set_defaults
      l = .scfdata.initial_lambda
      l_max = .scfdata.lambda_max + l

      do
         if (l>l_max) exit
         l_str = trim(l.to_str("f5.3"))
         archive.set(.name,"molecular_orbitals,lambda="//trim(l_str)); archive.delete_all_genres
         archive.set(.name,"orbital_energies,lambda="//trim(l_str));   archive.delete_all_genres
         l = l + .scfdata.lambda_step
      end

   end

   delete_atom_scf_archives ::: recursive, leaky
   ! Delete the atom SCF archives, if they exist.
      self :: IN

      a :: INT
      mol :: MOLECULE*

      if (.n_atom_kind<=0) return

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Delete
         mol.:create
         mol.name = .atom(a).chemical_symbol
         mol.:delete_scf_archives
         mol.:destroy

      end

   end

   delete_group_scf_archives ::: recursive, private
   ! Delete any group type SCF archives.
      self :: IN
      g :: INT

      if (.atom_group.disassociated) return

      do g = 1,.atom_group.dim
         if (.atom_group(g).mol.disassociated) cycle
         .atom_group(g).mol.:delete_scf_archives
      end

   end

   delete_scf_MO_archive
   ! Delete the SCF MO archives
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,"molecular_orbitals"); archive.delete_all_genres
      archive.set(.name,"orbital_energies");   archive.delete_all_genres
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put all the available molecule information on file

   DIE_IF(tonto.disassociated,"no tonto variable")

      .:put_basics

      if (tonto.low_verbosity) then
      if (.atom.associated) then
         if (.atom.dim>100) return
      end
      end

      if (.atom.associated)        .:put_atoms
      if (.atom_group.associated)  .:atom_group.put
      if (.pointgroup.associated)  .:put_pointgroup
      if (.crystal.associated)     .:put_crystal
      if (.cluster.associated)     .:put_cluster
      if (.becke_grid.associated)  .:put_becke_grid

      if (.overlapping_atoms.associated AND .atom.associated) then
         .:put_overlapping_atoms
         .:put_overlapping_atoms_4_atom
      end

   end

   put_basics
   ! Put basic molecule information

      stdout.flush
      stdout.flush
      stdout.text("====================")
      stdout.text("Molecule information")
      stdout.text("====================")

      stdout.flush
      stdout.show("Name                   =",.name)

      stdout.flush
      stdout.show("Chemical Formula       =",trim(.:chemical_formula(with_spaces=TRUE)))
      stdout.show("Molecular weight       =",.atom.molecular_weight)

      stdout.flush
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.spin_multiplicity)

      stdout.flush
      stdout.show("No. of atoms           =",.n_atom)
      stdout.show("No. of electrons       =",.n_e)
      stdout.show("No. of alpha electrons =",.n_a)
      stdout.show("No. of beta  electrons =",.n_b)

      if (.atom.has_all_bases) stdout.flush
      if (.basis_name/=" ") then
      stdout.show("Gaussian basis name    =",.basis_name)
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      end
      if (.slaterbasis_name/=" ") &
      stdout.show("Slater basis name      =",.slaterbasis_name)
      if (.coppensbasis_name/=" ") &
      stdout.show("Coppens basis name     =",.coppensbasis_name)

      if (NOT .E_field.is_zero) &
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      if (NOT .B_field.is_zero) &
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      if (NOT .gauge_origin.is_zero) &
      stdout.show("B field Gauge origin   =",.gauge_origin)

   end

   put_atoms
   ! Output the atom coordinate and basis set information
      self :: IN

   ENSURE(.atom.associated,"no atom list")

      have_wavelength :: BIN

      have_wavelength = .crystal.associated
      if (have_wavelength) have_wavelength = .crystal.data.associated
      if (have_wavelength) have_wavelength = .crystal.data.have_set_wavelength

      if (have_wavelength) then
         .atom.put_coordinate_info(.crystal.data.wavelength)
      else
         .atom.put_coordinate_info
      end

      if (.basis.associated)        .:put_bases
    ! if (.coppensbasis.associated) .put_coppensbases
    ! if (.slaterbasis.associated)  .put_slaterbases

    ! .atom.put_ADPs

   end

   put_ADPs
   ! Output the ADPs in cartesian axes
   ENSURE(.atom.associated,"no atom list")

      .atom.put_ADPs

   end


   put_bond_length_with_error ::: leaky
   ! Read two atoms, and output the bond length with associated error

   ENSURE(.atom.associated,"no atom list")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.data.associated,"no diffraction data")
   ENSURE(.crystal.data.covariance_matrix.associated,"no cov matrix created")

      cm :: MAT{REAL}*
      a1,a2,n_f :: INT

      ! Read the two atoms
      stdin.read(a1)
      stdin.read(a2)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.data.fragment_covariance_matrix.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx

      ! Extract positional-covariances
      .crystal.make_pos_covariance_matrix(cm)

      ! Put the bond length
      .atom.put_bond_length_with_error(a1,a2,cm)

      ! Clean
      cm.destroy

   end

   put_bond_angle_with_error ::: leaky
   ! Output the atom coordinate and basis set information
   ! Read three atoms, and output the bond angle with associated error

   ENSURE(.atom.associated,"no atom list")
   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.data.associated,"no diffraction data")
   ENSURE(.crystal.data.covariance_matrix.associated,"no cov matrix created")

      cm :: MAT{REAL}*
      a1,a2,a3,n_f :: INT

      ! Read the three atoms defining the angle
      stdin.read(a1)
      stdin.read(a2)
      stdin.read(a3)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.data.fragment_covariance_matrix.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx

      ! Extract positional-covariances
      .crystal.make_pos_covariance_matrix(cm)

      ! Put the bond angle
      .atom.put_bond_angle_with_error(a1,a2,a3,cm)

      cm.destroy

   end

   put_torsion_angle_with_error ::: leaky
   ! Output the atom coordinate and basis set information
   ENSURE(.atom.associated,"no atom list")

   ENSURE(.crystal.associated,"no crystal")
   ENSURE(.crystal.data.associated,"no diffraction data")
   ENSURE(.crystal.data.covariance_matrix.associated,"no cov matrix created")

      cm :: MAT{REAL}*
      a1,a2,a3,a4,n_f :: INT

      ! Read the three atoms defining the angle
      stdin.read(a1)
      stdin.read(a2)
      stdin.read(a3)
      stdin.read(a4)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.data.fragment_covariance_matrix.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx

      ! Extract positional-covariances
      .crystal.make_pos_covariance_matrix(cm)

      ! Put the torsion angle
      .atom.put_torsion_angle_with_error(a1,a2,a3,a4,cm)

      ! Clean
      cm.destroy

   end


   put_principal_axes
   ! Output the atom principal axes
   ENSURE(.atom.associated,"no atom list")
      .atom.put_principal_axes
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.

   ENSURE(.atom.associated,"no atom list")
   ENSURE(.basis.associated,"no basis set list")

      if (NOT .atom.bases_are_resolved) return

      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian basis sets")
      stdout.text("===================")
      stdout.flush
      stdout.show("Basis name             =",.basis_name)
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      stdout.flush

      .basis.renormalise
      .basis.put
      .basis.unnormalise

   end

   put_slaterbases
   ! Output the molecule slaterbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.associated,"no atom list")
   ENSURE(.slaterbasis.associated,"no basis set list")
      if (NOT .atom.slaterbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom slaterbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.slaterbasis.dim)
      .slaterbasis.put
   end

   put_coppensbases
   ! Output the molecule coppensbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.associated,"no atom list")
   ENSURE(.coppensbasis.associated,"no basis set list")
      if (NOT .atom.coppensbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom coppensbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.coppensbasis.dim)
      stdout.show("Maximum N value   =",.coppensbasis.maximum_basis_n_value)
      stdout.show("No. of orbitals   =",.coppensbasis.no_of_orbitals)
      stdout.show("No. of primitives =",.coppensbasis.no_of_primitives)
      .coppensbasis.put
   end

!   put_atom_ADP_tensors
!   ! Output the ADP (thermal) tensors if they exist.
!
!   ENSURE(.atom.associated,"no atom info")
!
!      xmodel,nmodel :: STR
!
!      if (NOT .atom.has_nonzero_ADPs) return
!
!      xmodel = "none"
!      nmodel = "none"
!      if (.crystal.associated) then
!         if (.crystal.xray_data.associated) xmodel = .crystal.xray_data.thermal_smearing_model
!         if (.crystal.pnd_data.associated)  nmodel = .crystal.pnd_data.thermal_smearing_model
!      end
!
!      stdout.flush
!      stdout.flush
!      stdout.text("==============================")
!      stdout.text("Atomic displacement parameters")
!      stdout.text("==============================")
!      stdout.flush
!      stdout.show("X-ray ADP model =",xmodel)
!      stdout.show("PND   ADP model =",nmodel)
!
!      .atom.put_ADPs(.crystal.unit_cell)
!
!   end

   put_atom_groups
   ! Out out the .atom_group info array
   ENSURE(.atom_group.associated,"no atom group information")
      .atom_group.put
   end

   put_overlapping_atoms
   ! Out out the .overlapping_atom info array
   ENSURE(.overlapping_atoms.associated,"no overlapping_atoms")
   ENSURE(.atom.associated,"no atoms")

      i,j,k :: INT

      stdout.save
      stdout.set_int_width(4)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms:")
      stdout.text(" ")

      do i = 1,.atom.dim
         k = 1
         stdout.put(i)
         do j = 1,.atom.dim
            if (NOT .:is_overlapping_atom(i,j)) cycle
            k = k + 1
            stdout.put(j)
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave

   end

   put_overlapping_atoms_4_atom
   ! Out out the .overlapping_atoms_for_atom info array
   ENSURE(.overlapping_atoms.associated,"no overlapping_atoms")
   ENSURE(.atom.associated,"no atoms")

      i,j,k :: INT

      stdout.save
      stdout.set_int_width(4)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms for atom:")
      stdout.text(" ")

      do i = 1,.atom.dim
         stdout.put(i)
         k = 1
         do j = 1,.overlapping_atoms_for_atom(i).element.dim
            k = k + 1
            stdout.put(.overlapping_atoms_for_atom(i)[j])
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave

   end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put
   end

   put_plot_grid
   ! Output the current grid.
   ENSURE(.plot_grid.associated,"no plot grid to output")
      .plot_grid.put
   end

   put_becke_grid
   ! Output the current DFT grid.
   ENSURE(.becke_grid.associated,"no Becke integration grid to output")
      .becke_grid.put
   end

   put_crystal
   ! Output the current crystal
      .crystal.put
   end

   put_cluster
   ! Put out the cluster information
   ENSURE(.cluster.associated,"no cluster data")
      .cluster.put
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_MOs_and_energies
   ! Output the current associated molecular orbitals and their energies
      self :: IN

      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies)
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)

   end

   put_MO_energies
   ! Output the molecular orbital energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers)
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix
   ENSURE(.density_matrix.associated,"no density matrix")
      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix
   ENSURE(.fock_matrix.associated,"no fock matrix")
      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_matrix)
   end

   put_vrml
   ! Output a VRML file for the coordinate geometry
      self :: IN

   ENSURE(.atom.associated,"no atom list!")

      out :: TEXTFILE*

      out.create(trim(.name)//achar(46)//"wrl")
      out.open_for("write")
      stdout.text("Generating VRML molecule")
      out.text("#VRML V2.0 utf8")
      out.text("NavigationInfo { type " // achar(34) // "EXAMINE" // achar(34) // " }")
      out.text("Viewpoint { ")
      out.text("position 0 0 10")
      out.text("fieldOfView 1")
      out.text("orientation 0 0 1 0")
      out.text('description "camera z"')
      out.text("}")
      out.text("DirectionalLight {")
      out.text("  color 1 1 1")
      out.text("  direction 1 0 0")
      out.text("  intensity 0.4")
      out.text("}")
      .atom.put_vrml(out)
      if (.isosurface.associated) .isosurface.put_vrml(out)
      stdout.text("done VRML molecule")

   end

!  =====
!  ANO's
!  =====

   put_ANOs ::: leaky
   ! Put the ANO data out for all atoms in the molecule.
   ENSURE(.atom.associated,"no atoms")

      k,a,b :: INT
      list :: STR

      if (NOT .:has_all_ANOs_made) return

      if (.n_atom_kind<=0) return

      stdout.flush
      stdout.text("========")
      stdout.text("ANO data")
      stdout.text("========")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle
         k = .atom(a).kind

         list = trim(a.to_str)
         do b = a+1,.n_atom
            if (.atom(b).kind/=k) cycle
            list = trim(list)//" "//trim(b.to_str)
         end
         list = "ANO's for atoms ... "//trim(list)

         stdout.flush
         stdout.text(repeat("=",len_trim(list)))
         stdout.text(list)
         stdout.text(repeat("=",len_trim(list)))
         .atom(a).put_ANOs
         stdout.flush

      end

   end

!  =======
!  Put CIF
!  =======

   put_CIFs(with_ESDs)
   ! Prints out an asymmetric and fragment cif file.
   ! Does both cartesian and crystal axes.
   ! NOTE: IF "with_esds" is present and TRUE, it is assumed
   ! that the covariances from a refinement are present, and
   ! these are used to make the ESDs; otherwise ESDs are still
   ! made by transforming in a straightforward way.
      self :: INOUT
      with_ESDs :: BIN, optional, IN

   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.atom.associated, "No atom")

      clean,change_ESDs,H_U_iso :: BIN

      ! Make sure CIF is there ...
      clean = FALSE
      if (.cif.disassociated) then
         clean = TRUE
         .cif.create(trim(.name)//".cif")
      end

      ! Cartesian fragment/CIF2
      .cif.set_use_CIF2(TRUE)
      stdout.redirect(trim(.name)//".cartesian.cif2")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
      .crystal.put_fragment_CIF(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.data.associated) H_U_iso = .crystal.data.refine_H_U_iso

        .:put_tonto_fcf 
        .:put_xd_fco

      ! Crystal asymmetric-unit/CIF1
      .cif.set_use_CIF2(FALSE)
      stdout.redirect(trim(.name)//".archive.cif")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
      .crystal.asymmetric_unit_atom.change_axis_system_to("crystal",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.put_asymm_unit_CIF(.cif)
      .crystal.asymmetric_unit_atom.change_axis_system_to("cartesian",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.put_asymm_unit_CIF_bond_info ! Must be cartesian
      stdout.revert

      ! Put other files
      if (.crystal.data.associated) then
      if (.crystal.data.reflections.associated) then


      ! .:put_shelx_hkl3
      ! .:put_shelx_hkl4
      ! .:put_shelx_fcf5
      ! .:put_shelx_fcf6

      ! Crystal fragment/CIF1
      .cif.set_use_CIF2(FALSE)
      stdout.redirect(trim(.name)//".fractional.cif1")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
      .crystal.fragment_atom.change_axis_system_to("crystal",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.put_fragment_CIF(.cif)
      .crystal.fragment_atom.change_axis_system_to("cartesian",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.put_fragment_CIF_bond_info   ! Must be cartesian
      stdout.revert

      end
      end

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_CIF_banner(CIF2) ::: private
   ! Prints out the CIF banner, with "CIF2" format if needed.
      self :: IN
      CIF2 :: BIN, IN

      date :: STR

      if (CIF2) then
      stdout.text("#\#CIF_2.0")
      stdout.flush
      end

      stdout.text("# ========================")
      stdout.text("# Tonto generated CIF file")
      stdout.text("# ========================")
      stdout.flush
      stdout.text("# NOTE: This is an incomplete CIF file")
      stdout.text("# Manually edit it to pass checkCIF")
      stdout.flush
      stdout.text("data_"//trim(.name))
      stdout.flush
      date = TIME:current_date_YMD_str()
      stdout.text("_audit_creation_date                "//trim(date))
      stdout.text("_audit_creation_method              'Tonto "//TONTO_VERSION//" github v. "//GIT_VERSION//"'")

      stdout.flush
      stdout.text("# ============")
      stdout.text("# QCr software")
      stdout.text("# ============")

      stdout.flush
      stdout.text("_QCr_software                       'Tonto'")
      stdout.text("_QCr_software_version               '"//TONTO_VERSION//" v. "//GIT_VERSION//"'")
      stdout.text("_QCr_software_platform              '"//TONTO_PLATFORM//"'")
      stdout.text("_QCr_software_build_date            '"//TONTO_BUILD_DATE//"'")
      stdout.text("_QCr_software_website               'https://github.com/dylan-jayatilaka/tonto'")

   end

   put_CIF_basics ::: private
   ! Put basic molecule information
      self :: IN

      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Publication")
      stdout.text("# ===========")

      stdout.flush
      stdout.text("_publ_contact_author")
      stdout.text(";")
      stdout.text("    Prof. Dr. Sir Tonto Magnifico")
      stdout.text(";")
      stdout.text("_publ_contact_author_email          'tonto.magnifico@gmail.com'")
      stdout.text("_publ_contact_author_phone          '+61 8 6488 3138'")
      stdout.text("_publ_requested_journal             'IUCrJ'")
      stdout.text("_publ_section_title")
      stdout.text(";")
      stdout.text("   'Hirshfeld atom-refinement (HAR) for "//trim(.name)//"'")
      stdout.text("   'X-ray wavefunction refinement (XWR) for "//trim(.name)//"'")
      stdout.text("   Tonto Magnifico, IUCrJ (XXXX)")
      stdout.text(";")

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _publ_author_name")
      stdout.text("    'Tonto Magnifico'")

      stdout.flush
      stdout.text("_publ_author_address")
      stdout.text(";")
      stdout.text("    Prof. Dr. Sir Tonto Magnifico")
      stdout.text("    1 El Camino Ciberespacio")
      stdout.text("    Tierra Austral del Espiritu Santo")
      stdout.text(";")

      stdout.flush
      stdout.text("# ========")
      stdout.text("# Chemical")
      stdout.text("# ========")

      stdout.flush
      stdout.text("_chemical_name_common               "//trim(.name))
      stdout.text("_chemical_formula_sum               '"//trim(.:chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_moiety            '"//trim(.:chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_weight            "//trim(REAL:to_str(.atom.molecular_weight,"f10.4")))
      stdout.text("_chemical_compound_source           'see text'")
      stdout.text("_chemical_absolute_configuration    unk")


   end

   put_CIF_wavefunction ::: private
   ! Put the wavefunction information out
      self :: IN

      psi :: VEC{STR}(19)

      if (.scfdata.disassociated) return

      ! Get wavefunction details
      psi = .:wavefunction_descriptor

      stdout.flush
      stdout.text("# ==========")
      stdout.text("# QCr method")
      stdout.text("# ==========")

      stdout.flush
      stdout.text("_QCr_calc_method                    '"//trim(psi(1))//"'")
      stdout.text("_QCr_calc_spinorbital_kind          '"//trim(psi(2))//"'")
      stdout.text("_QCr_calc_gaussian_basis_set        '"//trim(psi(3))//"'")
      stdout.text("_QCr_calc_gaussian_basis_set_kind   '"//trim(psi(4))//"'")
      stdout.text("_QCr_calc_basis_max_l               '"//trim(psi(5))//"'")

      stdout.flush
      stdout.text("_QCr_calc_unit                      'See _atom_site_* in tonto.cif2'")
      stdout.text("_QCr_calc_unit_spin_multiplicity    "//trim(INT:to_str(.spin_multiplicity)))
      stdout.text("_QCr_calc_unit_n_electrons          "//trim(INT:to_str(.n_e)))
      stdout.text("_QCr_calc_unit_n_alpha_electrons    "//trim(INT:to_str(.n_a)))
      stdout.text("_QCr_calc_unit_n_beta_electrons     "//trim(INT:to_str(.n_b)))
                                                    
      if (psi(6)/="?") then
      stdout.flush
      stdout.text("_QCr_Becke_grid_kind                "//trim(psi( 6)))
      stdout.text("_QCr_Becke_grid_accuracy            "//trim(psi( 7)))
      stdout.text("_QCr_Becke_grid_L_angular_grid      "//trim(psi(17)))
      stdout.text("_QCr_Becke_grid_L_H_angular_grid    "//trim(psi(18)))
      stdout.text("_QCr_Becke_grid_reduce_L_H_ang_grid "//trim(psi(19)))
      stdout.text("_QCr_Becke_grid_core_pruning_scheme "//trim(psi( 8)))
      stdout.text("_QCr_Becke_grid_scale_H-He_grid     "//trim(psi(11)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_1     "//trim(psi(12)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_2     "//trim(psi(13)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_3     "//trim(psi(14)))
      stdout.text("_QCr_Becke_grid_n_radial_H_pts      "//trim(psi(15)))
      stdout.text("_QCr_Becke_grid_H_pts_per_n_shell   "//trim(psi(16)))
      stdout.text("_QCr_Becke_grid_basis_fn_cutoff     "//trim(psi( 9)))
      stdout.text("_QCr_Becke_grid_rho_cutoff          "//trim(psi(10)))
      end

   end

   wavefunction_descriptor result (psi) ::: private
   ! Get the wavefunction details. Only call this if an SCF
   ! calculation was completed!
      self :: IN
      psi :: VEC{STR}(19)

   ENSURE(.scfdata.associated,"no SCF data!")

      field :: STR
      radius :: REAL
      L :: INT

      psi = "?"

      if (.scfdata.disassociated) return

      ! QM method
      psi(1) = "Hartree-Fock"
      if (.scfdata.is_DFT_calculation) then
         psi(1) = "Kohn-Sham/"// &
                  trim(.scfdata.dft_exchange_functional)// &
                  trim(.scfdata.dft_correlation_functional)
      end

      if (.scfdata.using_cluster_charges) then

         ! Add crystal field
         field = "CF"
         if (.scfdata.using_SC_cluster_charges) field = "SCCF"

         ! Add L
         if (.scfdata.using_qq_cluster_charges) then
            field = trim(field)//" L=2"
         else
            field = trim(field)//" L=1"
         end

         ! Radius
         radius = .scfdata.cluster_radius*ANGSTROM_PER_BOHR

         ! All bits
         psi(1) = trim(psi(1))//"/"//   &
                  trim(field) //" R="// &
                  trim(radius.to_str("f3.1"))//" A"
      end

      ! AO kind
      psi(2) = .scfdata.spinorbital_kind

      ! Basis
      psi(3) = "custom?"
      if (.basis_name/=" ") psi(3) = trim(.basis_name)

      ! Basis kind
      psi(4) = "cartesian"
      if (.use_spherical_basis) psi(4) = "spherical-harmonic"

      ! Basis max L
      L = .basis.maximum_basis_set_l_value
      psi(5) = trim(L.to_str)

      ! Becke grid
      if (.scfdata.is_DFT_calculation) then
      if (.becke_grid.associated) then
      psi( 6) = trim(.becke_grid.kind)
      psi( 7) = trim(.becke_grid.accuracy)
      psi( 8) = trim(.becke_grid.pruning_scheme)
      psi( 9) = trim(.becke_grid.basis_function_cutoff.to_str(fmt="e6.1"))
      psi(10) = trim(.becke_grid.rho_cutoff.to_str(fmt="e6.1"))
      psi(11) = trim(.becke_grid.scale_atomic_grids.to_str)
      psi(12) = trim(INT:to_str(.becke_grid.no_of_points_for_row(1)))
      psi(13) = trim(INT:to_str(.becke_grid.no_of_points_for_row(2)))
      psi(14) = trim(INT:to_str(.becke_grid.no_of_points_for_row(3)))
      psi(15) = trim(.becke_grid.n_radial_points.to_str)
      psi(16) = trim(.becke_grid.n_extra_points_per_shell.to_str)
      psi(17) = trim(.becke_grid.l_angular_grid.to_str)
      psi(18) = trim(.becke_grid.l_H_angular_grid.to_str)
      psi(19) = trim(.becke_grid.reduce_H_angular_grid.to_str)
      end
      end

   end

   put_shelx_hkl3
   ! Prints out reflections in shelx hkl3 format
      self :: INOUT

   ENSURE(.atom.associated, "No atom")
   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.crystal.data.associated, "No crystal diffraction data")
   ENSURE(.crystal.data.reflections.associated, "No crystal reflections")

      ! Fragment
      stdout.redirect(trim(.name)//".hkl3")
      .crystal.data.reflections.put_shelx_hkl3
      stdout.revert

   end

   put_shelx_hkl4
   ! Prints out reflections in shelx hkl4 format
      self :: INOUT

   ENSURE(.atom.associated, "No atom")
   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.crystal.data.associated, "No crystal diffraction data")
   ENSURE(.crystal.data.reflections.associated, "No crystal reflections")

      ! Fragment
      stdout.redirect(trim(.name)//".hkl4")
      .crystal.data.reflections.put_shelx_hkl4
      stdout.revert

   end

   put_shelx_fcf5
   ! Prints out just the reflection information plus minimal
   ! extra stuff as in the shelx fcf LIST=5 file.
      self :: INOUT

   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.atom.associated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.disassociated) then
         clean = TRUE
         .cif.create(trim(.name)//".fcf5")
      end

      ! Fragment
      stdout.redirect(trim(.name)//".fcf5")
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_shelx_fcf5
      stdout.revert

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_shelx_fcf6
   ! Prints out just the reflection information plus minimal
   ! extra stuff as in the shelx fcf LIST=6 file.
      self :: INOUT

   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.atom.associated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.disassociated) then
         clean = TRUE
         .cif.create(trim(.name)//".fcf6")
      end

      ! Fragment
      stdout.redirect(trim(.name)//".fcf6")
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_shelx_fcf6
      stdout.revert

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_tonto_fcf
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.atom.associated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.disassociated) then
         clean = TRUE
         .cif.create(trim(.name)//".archive.fco")
      end

      ! Fragment
      stdout.save
      stdout.redirect(trim(.name)//".archive.fcf")
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_tonto_fcf
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_xd_fco
   ! Prints out just the F2 reflection information plus minimal
   ! extra stuff as in the XD fco file.
      self :: INOUT

   ENSURE(.crystal.associated, "No crystal")
   ENSURE(.atom.associated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.disassociated) then
         clean = TRUE
         .cif.create(trim(.name)//".archive.fco")
      end

      ! Fragment
      stdout.save
      stdout.redirect(trim(.name)//".archive.fco")
      stdout.set_int_width(5)
      stdout.set_real_precision(4)
      stdout.set_real_width(13)
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_xd_fco
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

!  ==============
!  Debug printing
!  ==============

   set_debug_on(name) ::: get_from(DEBUG), leaky
   ! Add a debug descriptor to the list.
   end

   set_debug_off(name) ::: get_from(DEBUG), leaky
   ! Remove a debug descriptor from the list.
   end

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>STR)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>BIN)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>INT)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug_2D(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *matrix* "X" to output as a raw 2D array, with descriptor
   ! "name", if the debug switch for it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>SHELL2)
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG)
   ! Put *opmatrix* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   serialize(filename)
   ! Write out data from sbf file
      filename :: STR
      datafile :: DATAFILE
      labels :: STR(len=1), dimension(:,:), allocatable
      i, label_length = 1 :: INT

      ! how long is the longest label
      do i = 1, .atom.size
         if (len(trim(.atom(i).label)) > label_length) label_length = len(trim(.atom(i).label))
      end do

      ! need to convert the labels to an MxN character array
      allocate(labels(.atom.size, label_length))
      do i = 1, .atom.size
         labels(i, :) = .atom(i).label.character_array(label_length)
      end do

      datafile.open(filename)
      call datafile%sbf%add_dataset(sbf_Dataset("name", trim(.name)))
      call datafile%sbf%add_dataset(sbf_Dataset("basis_name", trim(.basis_name)))
      call datafile%sbf%add_dataset(sbf_Dataset("atomic_labels", labels))
      call datafile%sbf%add_dataset(sbf_Dataset("atomic_numbers", .atom(:).atomic_number))
      call datafile%sbf%add_dataset(sbf_Dataset("atomic_coordinates", .atom.coordinate_vector))

      ! SCF data
      ! TODO should really check if it's created and DONE not just if it's unrestricted
      if (.scfdata.associated) then
      if (.scfdata.is_unrestricted) then
         call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("unrestricted")))
         call datafile%sbf%add_dataset(sbf_Dataset("density_matrix.alpha", .density_matrix.alpha))
         call datafile%sbf%add_dataset(sbf_Dataset("density_matrix.beta", .density_matrix.beta))
         call datafile%sbf%add_dataset(sbf_Dataset("molecular_orbitals.alpha", .molecular_orbitals.alpha))
         call datafile%sbf%add_dataset(sbf_Dataset("molecular_orbitals.beta", .molecular_orbitals.alpha))
      else
         call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("restricted")))
         call datafile%sbf%add_dataset(sbf_Dataset("density_matrix", .density_matrix.restricted))
         call datafile%sbf%add_dataset(sbf_Dataset("molecular_orbitals", .molecular_orbitals.restricted))
      end if
      end if
      call datafile%sbf%serialize
      datafile.close
   end 

   deserialize(filename)
   ! Read in data from sbf file
      self :: PTR
      filename :: STR
      datafile :: DATAFILE
      tmp_str :: STR(len=:)@
      atomic_labels :: STR(len=1), dimension(:,:), allocatable
      atomic_numbers :: VEC{INT}@
      atomic_coordinates :: VEC{REAL}@
      tmp_mat :: MAT{REAL}@
      labels :: VEC{STR}@
      i, err :: INT
      success = 1 :: INT

      .:create

      datafile.open(filename)

      call datafile%sbf%deserialize

      call datafile%sbf%get("name", tmp_str, err)
      DIE_IF(err /= success, sbf_strerr(err))

      .name = tmp_str
      call datafile%sbf%get("basis_name", tmp_str, err)
      DIE_IF(err /= success, sbf_strerr(err))

      .basis_name = tmp_str

      call datafile%sbf%get("atomic_labels", atomic_labels, err)
      DIE_IF(err /= success, sbf_strerr(err))

      ! convert back
      allocate(labels(size(atomic_labels, 1)))
      do i = 1, size(atomic_labels, dim=1)
         labels(i) = trim(VEC{STR}:char_array_to_str(atomic_labels(i,:)))
      end do

      call datafile%sbf%get("atomic_numbers", atomic_numbers, err)
      DIE_IF(err /= success, sbf_strerr(err))
      .atom.create(size(atomic_numbers))

      call datafile%sbf%get("atomic_coordinates", atomic_coordinates, err)
      DIE_IF(err /= success, sbf_strerr(err))
      .atom.set_positions_from_vector(atomic_coordinates)

      .atom.set_atom_data_from_labels(labels)

      .BASE:set_atom_info
      .BASE:finalize_atom_groups
      .BASE:resolve_basis_info

      call datafile%sbf%get("scf_kind", tmp_str, err)

      ! TODO CHECK FOR ERRORS
      if (err == success) then
         .scfdata.create
         .density_matrix.create(.n_bf)
         .molecular_orbitals.create(.n_bf)
         if(tmp_str == "unrestricted") then
            .scfdata.set_scf_kind("uhf")
            .density_matrix.create("unrestricted")
            call datafile%sbf%get("density_matrix.alpha", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_matrix.alpha= tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("density_matrix.beta", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_matrix.beta = tmp_mat
            deallocate(tmp_mat)
            .molecular_orbitals.create("unrestricted")
            call datafile%sbf%get("molecular_orbitals.alpha", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .molecular_orbitals.alpha = tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("molecular_orbitals.beta", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .molecular_orbitals.beta = tmp_mat
            deallocate(tmp_mat)
         else
            .scfdata.set_scf_kind("rhf")
            call datafile%sbf%get("density_matrix", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_matrix.create("restricted")
            .density_matrix.restricted = tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("molecular_orbitals", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .molecular_orbitals.create("restricted")
            .molecular_orbitals.restricted = tmp_mat
            deallocate(tmp_mat)
         end if
      else
         stdout.text("No SCF data in "//trim(filename)//", skipping reading density matrix etc.")
      end if
      datafile.close

   end

   make_atomic_multipoles(charge,dipole,quadrupole,octupole,od,oc,no_s)
   ! Make the atomic multipoles using the tanaka partitioing
      self :: IN
      charge :: VEC{REAL}, OUT
      dipole, quadrupole, octupole :: MAT{REAL}, OUT
      od, oc, no_s :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")
   ENSURE(.density_matrix.associated,"no density_matrix")
   ENSURE(.density_matrix.restricted.associated,"no restricted density_matrix")
   ENSURE(NOT .use_spherical_basis,"not implememnted for spherical")

      off_diagonal,only_disconnected, no_s_functions :: BIN
      S,Sa,Sb,P,part :: MAT{REAL}*
      Ax,Ay,Az,Bx,By,Bz :: MAT{REAL}*
      Axx,Ayy,Azz,Axy,Axz,Ayz,Bxx,Byy,Bzz,Bxy,Bxz,Byz :: MAT{REAL}*
      Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz :: MAT{REAL}*
      Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz :: MAT{REAL}*
      q,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT
      sh :: SHELL2
      fac :: REAL

      off_diagonal = FALSE
      only_disconnected = FALSE
      no_s_functions = FALSE
      if (present(od)) off_diagonal = od
      if (present(oc)) only_disconnected = oc
      if (present(no_s)) no_s_functions = no_s

      
      P => .density_matrix.restricted

      charge     = ZERO
      dipole     = ZERO
      quadrupole = ZERO
      octupole   = ZERO

      do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (atom_a==atom_b) then

            if (no_s_functions AND sh.a.l == 0 AND sh.b.l == 0) cycle
            if (off_diagonal) cycle
            if (only_disconnected) cycle

            fac = TWO
            if (fa==fb) fac=ONE

            S.create(na,nb)
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)

            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 

            sh.make_overlap_ints(S)
            sh.make_dipole_ints(Ax,Ay,Az,sh.a.position)
            sh.make_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz,sh.a.position)
            sh.make_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz,sh.a.position)

            charge(atom_a)       = charge(atom_a)       + fac*sum(S*P(fa:la,fb:lb))
            dipole(atom_a,1)     = dipole(atom_a,1)     + fac*sum(Ax*P(fa:la,fb:lb))
            dipole(atom_a,2)     = dipole(atom_a,2)     + fac*sum(Ay*P(fa:la,fb:lb))
            dipole(atom_a,3)     = dipole(atom_a,3)     + fac*sum(Az*P(fa:la,fb:lb))
            quadrupole(atom_a,1) = quadrupole(atom_a,1) + fac*sum(Axx*P(fa:la,fb:lb))
            quadrupole(atom_a,2) = quadrupole(atom_a,2) + fac*sum(Ayy*P(fa:la,fb:lb))
            quadrupole(atom_a,3) = quadrupole(atom_a,3) + fac*sum(Azz*P(fa:la,fb:lb))
            quadrupole(atom_a,4) = quadrupole(atom_a,4) + fac*sum(Axy*P(fa:la,fb:lb))
            quadrupole(atom_a,5) = quadrupole(atom_a,5) + fac*sum(Axz*P(fa:la,fb:lb))
            quadrupole(atom_a,6) = quadrupole(atom_a,6) + fac*sum(Ayz*P(fa:la,fb:lb))

            octupole(atom_a, 1)  = octupole(atom_a, 1)  + fac*sum(Axxx*P(fa:la,fb:lb))
            octupole(atom_a, 2)  = octupole(atom_a, 2)  + fac*sum(Ayyy*P(fa:la,fb:lb))
            octupole(atom_a, 3)  = octupole(atom_a, 3)  + fac*sum(Azzz*P(fa:la,fb:lb))
            octupole(atom_a, 4)  = octupole(atom_a, 4)  + fac*sum(Axxy*P(fa:la,fb:lb))
            octupole(atom_a, 5)  = octupole(atom_a, 5)  + fac*sum(Axxz*P(fa:la,fb:lb))
            octupole(atom_a, 6)  = octupole(atom_a, 6)  + fac*sum(Ayyx*P(fa:la,fb:lb))
            octupole(atom_a, 7)  = octupole(atom_a, 7)  + fac*sum(Ayyz*P(fa:la,fb:lb))
            octupole(atom_a, 8)  = octupole(atom_a, 8)  + fac*sum(Azzx*P(fa:la,fb:lb))
            octupole(atom_a, 9)  = octupole(atom_a, 9)  + fac*sum(Azzy*P(fa:la,fb:lb))
            octupole(atom_a,10)  = octupole(atom_a,10)  + fac*sum(Axyz*P(fa:la,fb:lb))

            S.destroy
            Ax.destroy; Ay.destroy; Az.destroy
            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 

         else

            if(only_disconnected) then
               if (.atom.has_a_connection(atom_a,atom_b)) cycle
            end

            ! Partition factors
            part.create(sh.a.n_cc,sh.b.n_cc)
            sh.make_KM_partition(part)

            ! Get weighted overlap integrals
            Sa.create(na,nb); Sb.create(na,nb)

            sh.make_weighted_overlap_ints(Sa,Sb,part)

            charge(atom_a) = charge(atom_a) + TWO*sum(Sa*P(fa:la,fb:lb))
            charge(atom_b) = charge(atom_b) + TWO*sum(Sb*P(fa:la,fb:lb))

            Sb.destroy; Sa.destroy

            ! Dipoles
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Bx.create(na,nb); By.create(na,nb); Bz.create(na,nb)

            sh.make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz,part)

            dipole(atom_a,1) = dipole(atom_a,1) + TWO*sum(Ax*P(fa:la,fb:lb))
            dipole(atom_a,2) = dipole(atom_a,2) + TWO*sum(Ay*P(fa:la,fb:lb))
            dipole(atom_a,3) = dipole(atom_a,3) + TWO*sum(Az*P(fa:la,fb:lb))

            dipole(atom_b,1) = dipole(atom_b,1) + TWO*sum(Bx*P(fa:la,fb:lb))
            dipole(atom_b,2) = dipole(atom_b,2) + TWO*sum(By*P(fa:la,fb:lb))
            dipole(atom_b,3) = dipole(atom_b,3) + TWO*sum(Bz*P(fa:la,fb:lb))

            Ax.destroy; Ay.destroy; Az.destroy
            Bx.destroy; By.destroy; Bz.destroy

            ! Quadrupoles
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)
            Bxx.create(na,nb); Byy.create(na,nb); Bzz.create(na,nb)
            Bxy.create(na,nb); Bxz.create(na,nb); Byz.create(na,nb)

            sh.make_weighted_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz &
                                            ,Bxx,Byy,Bzz,Bxy,Bxz,Byz, part)

            quadrupole(atom_a,1) = quadrupole(atom_a,1) + TWO*sum(Axx*P(fa:la,fb:lb))
            quadrupole(atom_a,2) = quadrupole(atom_a,2) + TWO*sum(Ayy*P(fa:la,fb:lb))
            quadrupole(atom_a,3) = quadrupole(atom_a,3) + TWO*sum(Azz*P(fa:la,fb:lb))
            quadrupole(atom_a,4) = quadrupole(atom_a,4) + TWO*sum(Axy*P(fa:la,fb:lb))
            quadrupole(atom_a,5) = quadrupole(atom_a,5) + TWO*sum(Axz*P(fa:la,fb:lb))
            quadrupole(atom_a,6) = quadrupole(atom_a,6) + TWO*sum(Ayz*P(fa:la,fb:lb))

            quadrupole(atom_b,1) = quadrupole(atom_b,1) + TWO*sum(Bxx*P(fa:la,fb:lb))
            quadrupole(atom_b,2) = quadrupole(atom_b,2) + TWO*sum(Byy*P(fa:la,fb:lb))
            quadrupole(atom_b,3) = quadrupole(atom_b,3) + TWO*sum(Bzz*P(fa:la,fb:lb))
            quadrupole(atom_b,4) = quadrupole(atom_b,4) + TWO*sum(Bxy*P(fa:la,fb:lb))
            quadrupole(atom_b,5) = quadrupole(atom_b,5) + TWO*sum(Bxz*P(fa:la,fb:lb))
            quadrupole(atom_b,6) = quadrupole(atom_b,6) + TWO*sum(Byz*P(fa:la,fb:lb))

            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy
            Bxx.destroy; Byy.destroy; Bzz.destroy
            Bxy.destroy; Bxz.destroy; Byz.destroy

            ! Octupoles
            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 
            Bxxx.create(na,nb); Byyy.create(na,nb); Bzzz.create(na,nb)
            Bxxy.create(na,nb); Bxxz.create(na,nb); Byyx.create(na,nb)
            Byyz.create(na,nb); Bzzx.create(na,nb); Bzzy.create(na,nb)
            Bxyz.create(na,nb); 

            sh.make_weighted_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz & 
                                          ,Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz,part)

            octupole(atom_a, 1) = octupole(atom_a, 1) + TWO*sum(Axxx*P(fa:la,fb:lb))
            octupole(atom_a, 2) = octupole(atom_a, 2) + TWO*sum(Ayyy*P(fa:la,fb:lb))
            octupole(atom_a, 3) = octupole(atom_a, 3) + TWO*sum(Azzz*P(fa:la,fb:lb))
            octupole(atom_a, 4) = octupole(atom_a, 4) + TWO*sum(Axxy*P(fa:la,fb:lb))
            octupole(atom_a, 5) = octupole(atom_a, 5) + TWO*sum(Axxz*P(fa:la,fb:lb))
            octupole(atom_a, 6) = octupole(atom_a, 6) + TWO*sum(Ayyx*P(fa:la,fb:lb))
            octupole(atom_a, 7) = octupole(atom_a, 7) + TWO*sum(Ayyz*P(fa:la,fb:lb))
            octupole(atom_a, 8) = octupole(atom_a, 8) + TWO*sum(Azzx*P(fa:la,fb:lb))
            octupole(atom_a, 9) = octupole(atom_a, 9) + TWO*sum(Azzy*P(fa:la,fb:lb))
            octupole(atom_a,10) = octupole(atom_a,10) + TWO*sum(Axyz*P(fa:la,fb:lb))

            octupole(atom_b, 1) = octupole(atom_b, 1) + TWO*sum(Bxxx*P(fa:la,fb:lb))
            octupole(atom_b, 2) = octupole(atom_b, 2) + TWO*sum(Byyy*P(fa:la,fb:lb))
            octupole(atom_b, 3) = octupole(atom_b, 3) + TWO*sum(Bzzz*P(fa:la,fb:lb))
            octupole(atom_b, 4) = octupole(atom_b, 4) + TWO*sum(Bxxy*P(fa:la,fb:lb))
            octupole(atom_b, 5) = octupole(atom_b, 5) + TWO*sum(Bxxz*P(fa:la,fb:lb))
            octupole(atom_b, 6) = octupole(atom_b, 6) + TWO*sum(Byyx*P(fa:la,fb:lb))
            octupole(atom_b, 7) = octupole(atom_b, 7) + TWO*sum(Byyz*P(fa:la,fb:lb))
            octupole(atom_b, 8) = octupole(atom_b, 8) + TWO*sum(Bzzx*P(fa:la,fb:lb))
            octupole(atom_b, 9) = octupole(atom_b, 9) + TWO*sum(Bzzy*P(fa:la,fb:lb))
            octupole(atom_b,10) = octupole(atom_b,10) + TWO*sum(Bxyz*P(fa:la,fb:lb))

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 
            Bxxx.destroy; Byyy.destroy; Bzzz.destroy
            Bxxy.destroy; Bxxz.destroy; Byyx.destroy
            Byyz.destroy; Bzzx.destroy; Bzzy.destroy
            Bxyz.destroy; 

            part.destroy

         end

         sh.destroy_ptr_part

      end

      ! Electron charge
      dipole     = -ONE * dipole
      quadrupole = -ONE * quadrupole
      octupole   = -ONE * octupole

   end


end
