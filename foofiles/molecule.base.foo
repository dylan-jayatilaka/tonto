!===============================================================================
!
! MOLECULE.BASE
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below.
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further.
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! Updated 2014-12-01
!
! .BASE
!     3 .REL
!    16---24 .GRID
!    14---12---- 1 .XTAL
!     2--- |---- |---- 4 .CE =
!     7--- |---- 1---- |-- | .INTS
!    14--- |---- 5---- |-- |---- 2 .FOCK
!    30--- 5---- 4---- 5-- |----10---- 5 .SCF
!     2--- |---- |---- |-- |---- 1---- 5--- 1 .GEM =     =     =
!    11--- |---- |---- 1-- |----15---- 5---13--- | .PROP =     =
!     4--- |---- 6---- |-- |---- 3---- |--- 2--- |---- | .PLOT =
!     4--- |---- 5---- |-- |---- 4---- 2--- 1--- |---- |---- | .CP
!    12--- |---- 7---- |-- |---- |---- |--- 1--- |---- |---- 1-- | .TAD
!    15--- |---- 5---- 1-- |---- 5---- 6--- 5--- |---- |---- |-- |--- 2 .MISC
!    76--- 3---- 3----13-- 7---- 1---- |---13--- 3----19---- 6-- 9---11----24 .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===============================================================================

module MOLECULE.BASE

   implicit none

   saved_self :: MOLECULE@, private

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

   destroy_ptr_part ::: leaky, PURE
   ! Destroy the pointer parts of a molecule object
      self :: INOUT

      ! Saved molecule
      .saved.:destroy

      ! Atoms (nullify pointed-to atoms before)
      .atom.destroy

      ! Atom_groups
      .:destroy_atom_group

      ! Destroy bases and pointed
      .basis.destroy
      .slaterbasis.destroy
      .coppensbasis.destroy

      ! Grids, interpolators & plots
      .plot_grid.destroy
      .interpolator.destroy
      .isosurface.destroy
      .becke_grid.destroy

      ! Crystals and clusters
      .crystal.destroy
      .cluster.destroy
      .cif.destroy
      .pointgroup.destroy

      ! Basis set & integral info arrays
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .basis_shell_for_shell.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .basis_shell1pair.destroy
      .max_I.destroy
      .overlapping_atoms.destroy
      .overlapping_atoms_for_atom.destroy

      ! SCF data
      .scfdata.destroy

      ! SCF info
      .MO_energies.destroy
      .MOs.destroy
      .density_mx.destroy
      .old_density_mx.destroy
      .delta_density_mx.destroy
      .NOs.destroy
      .NO_occ_nos.destroy
      .overlap_mx.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .kinetic_energy_mx.destroy
      .nuclear_attraction_mx.destroy

      ! SCF intermediates
      .core_mx.destroy
      .fock_mx.destroy
      .fock_2e_mx.destroy
      .constraint_mx.destroy

      ! Bond analysis
      .roby.destroy

      ! Localised MO's
      .localiser.destroy

      ! CPHF and response properties
      .U_electric_dipole.destroy
      .dipole_polarisability.destroy
      .dipole_hyperpolarisability.destroy
      .U2_electric_dipole.destroy

      ! Force constants
      .force_constants.destroy
      .normal_mode_eigenvectors.destroy
      .normal_mode_eigenvalues.destroy
      .phi3_force_constants.destroy
      .phi4_force_constants.destroy

      ! Atomic multipoles
      .charges.destroy
      .dipoles.destroy
      .octupoles.destroy
      .quadrupoles.destroy

   end

   save ::: leaky, PURE
   ! Save everything about "self" in ".saved", and make "self" fresh.
      self :: allocatable, INOUT

      saved :: MOLECULE@

      ! Save self
      saved = self

      ! Recreate fresh
      .:destroy
      .:create

      ! Set .saved
      .saved = saved

   end

   unsave ::: leaky, PURE
   ! Revert back to a previously saved molecule stored in .saved, and
   ! destroy everything about the current molecule in "self".
   ! WARNING: be careful when setting up self, make sure none of its
   ! pointer parts refer to .saved information.
      self :: INOUT

   ENSURE(.saved.allocated,"no previous settings")

      ! Restore self
      self = .saved

      ! Clean up
      .saved.:destroy

   end

!  ================
!  Specific cleanup
!  ================

   destroy_atom_group ::: leaky, PURE
   ! Destroy the pointer parts of a molecule object
      self :: INOUT

      .atom_group.destroy

      if (allocated(.mol)) deallocate(.mol)

   end

   destroy_matrices ::: leaky, PURE
   ! Destroy the matrices of a molecule object
      self :: INOUT

      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy

      .MO_energies.destroy
      .MOs.destroy
      .density_mx.destroy
      .old_density_mx.destroy
      .delta_density_mx.destroy
      .NOs.destroy
      .NO_occ_nos.destroy
      .overlap_mx.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .kinetic_energy_mx.destroy
      .nuclear_attraction_mx.destroy

      .core_mx.destroy
      .fock_mx.destroy
      .fock_2e_mx.destroy
      .constraint_mx.destroy

    ! .atom_group.destroy
      .:destroy_atom_group
      .elmo_connection_table.destroy

   end

   destroy_NAO_matrices ::: leaky, PURE
   ! Destroy the NAO's for all atoms in the molecule.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")

      .atom.destroy_NAO_matrices

   end

   destroy_ANO_matrices ::: leaky, PURE
   ! Destroy the ANO's for all atoms in the molecule.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")

      .atom.destroy_ANO_matrices

   end

   destroy_interpolators ::: leaky, PURE
   ! Destroy the (non-unique) interpolators
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")

      .atom.destroy_interpolators

   end

   destroy_atom_data ::: leaky, PURE
   ! Destroy the restricted atomic natural orbitals (ANO) data for all
   ! atoms in the molecule.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")

      .atom.destroy_atom_data

   end

   destroy_atom_shell_info ::: leaky, PURE
   ! Destroy the atom precomputed shellpair info.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")

      .atom.destroy_shell_info

   end

!  SCF

   destroy_SCF_results(keep_MOs,keep_DM) ::: leaky, PURE
   ! Destroy the SCF results in memory
      self :: INOUT
      keep_MOs :: BIN, optional, IN
      keep_DM  :: BIN, optional, IN

      delete_MOs :: BIN
      delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      if (delete_MOs) .MOs.destroy
      if (delete_DM)  .density_mx.destroy

      .MO_energies.destroy
      .fock_mx.destroy

   end

   destroy_tmp_SCF_matrices ::: PURE
   ! Destroy any temporary matrices stored in memory.
      self :: INOUT

      .old_density_mx.destroy
      .delta_density_mx.destroy
      .fock_2e_mx.destroy
      .constraint_mx.destroy

   end

   destroy_SCF_integrals ::: leaky, PURE
   ! Destroy all SCF-related integrals in memory.
      self :: INOUT

      .overlap_mx.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy

      .kinetic_energy_mx.destroy
      .nuclear_attraction_mx.destroy
      .core_mx.destroy

   end

!  ============
!  Set defaults
!  ============

   set_defaults ::: leaky
   ! Set up a default molecule
      self :: INOUT

      .name                = "unknown"
      .charge              = 0
      .spin_multiplicity   = 1
      .n_e                 = 0
      .n_a                 = 0
      .n_b                 = 0
      .E_field             = ZERO
      .B_field             = ZERO
      .gauge_origin        = ZERO

      .n_atom              = 0
      .atom_info_made      = FALSE
      .n_atom_kind         = 0

      .n_bf                = 0
      .basis_name          = " "
      .n_basis             = 0
      .basis_l_max         = -1
      .use_spherical_basis = FALSE
      .n_bf                = 0
      .n_prim              = 0
      .slaterbasis_name    = " "
      .coppensbasis_name   = " "
      .basis_info_made     = FALSE

      .use_interpolators   = TRUE

      .n_shell             = 0
      .n_shell_pairs       = 0
      .n_unique_shells     = 0

      .CX_file_name        = " "
      .CX_uses_angstrom    = FALSE

      .nucleus_model       = "point"

      ! Do want to set this always?
      ! e.g. for .make_mol_from_atom(a) methods?
      .HA_info_made        = FALSE
      .u_HA_info_made      = FALSE
      .atomic_polarisabilities_made = FALSE

      if (.atom.allocated) then
         .name              = .atom.chemical_formula
         .spin_multiplicity = .:default_spin_multiplicity
         ! Set unique atom tags if needed, multiplicity, no. of
         ! electrons; resolve basis sets, set basis-shell info; 
         ! and (possibly) resent kinds
         .:update_atom_info
         .:resolve_bases_and_update ! NOT PURE
         .atom.update_kinds    
         .n_atom_kind = maxval(.atom.kind)
      end

   end

   set_SCF_guess_defaults_from(scfdata) ::: leaky
   ! Set scf  data options for a guess-type SCF defaults
      self :: INOUT
      scfdata :: SCFDATA@, IN

      ! Set the SCF defaults (leaky)
      if (scfdata.deallocated) then

         .:set_SCF_defaults ! NOT PURE
         .scfdata.set_output(FALSE)

      else if (scfdata.SCF_kind(1:7)=="fraghar") then

         .:set_SCF_defaults(scfdata) ! leaky

      else if (NOT scfdata.use_default_guess_options) then

         .:set_SCF_defaults(scfdata) ! leaky

      else 

         .:set_SCF_defaults
         .scfdata.set_output(FALSE)

      end

      ! Reset some defaults from scfdata, if it is there
      if (scfdata.allocated) then

         .scfdata.set_output(scfdata.guess_output)
         if (scfdata.initial_MOs/="--using density--")  .scfdata.set_initial_MOs(scfdata.initial_MOs)
         if (scfdata.initial_density/="--using MO's--") .scfdata.set_initial_density(scfdata.initial_density)
         .scfdata.set_convergence(scfdata.convergence)
         .scfdata.SCF_DIIS.set_convergence_tolerance(scfdata.SCF_DIIS.convergence_tolerance)
         .scfdata.set_relativity_kind(scfdata.relativity_kind)

      end

      ! Nuclear energy
      .scfdata.nuclear_repulsion_energy = .:nuclear_repulsion_energy

      ! Finalise
      .scfdata.update

   end

   set_general_SCF_guess_defaults_from(scfdata) ::: leaky
   ! Set scf  data options for a guess-type SCF defaults
      self :: INOUT
      scfdata :: SCFDATA@, IN

      ! Set the SCF defaults (leaky)
      if (scfdata.deallocated) then

         .:set_SCF_defaults ! NOT PURE
         .scfdata.set_output(FALSE)

      else if (scfdata.use_default_guess_options) then

         .:set_SCF_defaults
         .scfdata.set_output(FALSE)

      else

         .:set_SCF_defaults(scfdata) ! leaky

      end

      .scfdata.set_SCF_kind("ghf")
      
      ! Reset some defaults from scfdata, if it is there
      if (scfdata.allocated) then
         .scfdata.set_output(scfdata.guess_output)
         .scfdata.set_convergence(scfdata.convergence)
         .scfdata.SCF_DIIS.set_convergence_tolerance(scfdata.SCF_DIIS.convergence_tolerance)
         .scfdata.set_relativity_kind(scfdata.relativity_kind)
      end

      ! Nuclear energy
      .scfdata.nuclear_repulsion_energy = .:nuclear_repulsion_energy

      ! Finalise
      .scfdata.update

   end

   set_SCF_defaults(scfdata) ::: leaky
   ! Set up scf defaults for molecule
      self :: INOUT
      scfdata :: SCFDATA@, optional, IN

      if (.scfdata.deallocated) then; .scfdata.create
      else;                           .scfdata.set_defaults
      end

      ! Restricted?
      if (.spin_multiplicity==1) .scfdata.set_SCF_kind("rhf")
      if (.spin_multiplicity/=1) .scfdata.set_SCF_kind("uhf")

      if (present(scfdata)) then
      if (scfdata.allocated) then

         ! Set defaults from scfdata
         .scfdata = scfdata
         .scfdata.cluster.destroy
         .scfdata.cluster_charges.destroy
         .scfdata.cluster_charge_positions.destroy

         if (.scfdata.SCF_kind/=" ") then

            ! Process scfkind , make sure it is sensible
            ! Always use restricted
            if (.scfdata.is_DFT_calculation) then
               if (.spin_multiplicity==1) .scfdata.set_SCF_kind("rks")
               if (.spin_multiplicity/=1) then
                ! DIE("cannot yet do ROKS (for, e.g. atomic SCF)")
                  .scfdata.set_SCF_kind("uks")
               end
            else
               if (.spin_multiplicity==1) .scfdata.set_SCF_kind("rhf")
               if (.spin_multiplicity/=1) then
                  .scfdata.set_SCF_kind("uhf")
               !  .scfdata.set_using_DIIS(FALSE)
               end
            end

         end

      end
      end

      .scfdata.nuclear_repulsion_energy = .:nuclear_repulsion_energy

      if (.scfdata.is_DFT_calculation) then
         .:initialize_DFT_grids ! NOT PURE
      end

   end

   initialize_DFT_grids ::: leaky
   ! Initialise DFT grids, if not already done so.
      self :: INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      .becke_grid.destroy
      .becke_grid.create

      .becke_grid.set_atom_info(.atom) ! NOT PURE
      .becke_grid.set_grid_data

      .BASE:make_overlapping_atoms

   end

!  ==============
!  Set saved-self
!  ==============

   set_saved_self
   ! Set saved_self. Allocatable version.
      self :: IN
      saved_self = self
   end

   set_from_saved_self
   ! Set from saved_self. Allocatable version.
      self :: OUT
      self = saved_self
   end

!  ===========
!  Set methods
!  ===========

   set_name(val) ::: PURE
   ! Set the molecule name
      self :: INOUT
      val :: STR, IN

   ENSURE(all(ATOM::element_symbols/=val),"job name must not be an element symbol")

      .name = val

   end

   set_charge(val) ::: get_from(OBJECT:set, ARG?=>.charge, VAL?=>INT), PURE
   ! Generic set
   end

   set_spin_multiplicity(val) ::: PURE
   ! Set the spin multiplicity and no. of alpha & beta electrons
      self :: INOUT
      val :: INT, IN

   ENSURE(val/=0,"cannot have zero multiplicity")

      .spin_multiplicity = val

      if (.atom.allocated) then
         .n_e = .:no_of_electrons
         .n_a = .BASE:no_of_alpha_electrons
         .n_b = .BASE:no_of_beta_electrons
      end

   end

   set_n_a_n_b_and_multiplicity(n_a,n_b) ::: PURE
   ! Set the no. of alpha and beta electrons, and then the spin
   ! multiplicity. This is needed only for Molden files!
      self :: INOUT
      n_a :: INT, IN
      n_b :: INT, IN

   ENSURE(n_a>=n_b,"n_a can't be smaller than n_b")

      .n_a = n_a
      .n_b = n_b
      .spin_multiplicity = (n_a - n_b) + 1

   end

   set_SCF_occupations_for_NOs(genre) ::: PURE
   ! Set the SCF occupation numbers for the NOs
      self  :: INOUT
      genre :: STR, IN

      select case (genre)

      case ("r ")
         .NO_occ_nos.r(1:.n_a) = TWO

      case ("u ")
         .NO_occ_nos.a(1:.n_a) = ONE
         .NO_occ_nos.b(1:.n_b) = ONE

      case ("gc")
         .NO_occ_nos.g(1:.n_e) = ONE

      end

   end

   set_force_constants(fc) ::: leaky, PURE
   ! Set the .force_constants to the flat array "fc".
   ! Since it is a symmetric matrix the order does not matter.
      self :: INOUT
      fc :: VEC{REAL}, IN

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(fc.dim==9*.atom.dim*.atom.dim,"wrong size, fc")

      n3n :: INT

      ! Create space
      n3n = 3*.atom.dim
      .force_constants.destroy
      .force_constants.create(n3n,n3n)

      ! Reshape
      .force_constants = reshape(fc,[n3n,n3n])

   end

!  Atoms

   update_atom_and_basis_info(do_groups) ::: leaky
   ! Update the atom labels, no of electrons, spin multiplicities,
   ! axis system, crystal fragment info, and bases; remove isosurface.
      self :: INOUT
      do_groups :: BIN, optional, IN

      groups :: BIN

      groups = TRUE
      if (present(do_groups)) groups = do_groups

      ! Set unique atom tags if needed, multiplicity, no. of
      ! electrons; resolve basis sets, set basis-shell info; 
      ! and (possibly) resent kinds
      .BASE:update_atom_info
      .BASE:resolve_bases_and_update
      .atom.update_kinds    
      .n_atom_kind = maxval(.atom.kind)

      ! Finalize crystal
      if (.crystal.allocated) then
         .BASE:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

      ! Avoid calling update_atom_groups recursively
      if (groups) then
         .BASE:update_atom_groups
      end

      ! Destroy stored atoms here
      .isosurface.destroy

      .atom_info_made = TRUE

   end

   update_atom_info ::: leaky, private, PURE
   ! Set the associated atom information
   ! . Atom tags and kind indices
   ! . The spin multiplicity
   ! . The number of alpha and beta electrons.
   ! WARNING: .atom.update depends on .atom.basis, so you might need
   !          to call this routine again!
      self :: INOUT

      if (.atom.deallocated) return
    ! if (.atom_info_made) return

      ! Finalize 
      .atom.update

      ! No. of atoms & no. of atom kinds
      .n_atom = .atom.dim
      .n_atom_kind = maxval(.atom.kind)

      ! Reset multiplicity?
      if (NOT .:has_valid_no_of_beta_electrons) then
      !  WARN("Inconsistent charge and multiplicity")
      !  WARN("Reassigning the multiplicity")
         .spin_multiplicity = .:default_spin_multiplicity
      end

      ! Now can set # of electrons
      .n_e = .:no_of_electrons
      .n_a = .:no_of_alpha_electrons
      .n_b = .:no_of_beta_electrons

      ! Make connetion table
      .:make_atom_connections

    ! .atom_info_made = TRUE

   end

!  Bases

   set_basis_directory(directory)
   ! Set the basis directory (for all kinds of bases)
      self :: IN
      directory :: STR, IN
      .basis.set_library_directory(directory)       ! NOT PURE
      .slaterbasis.set_library_directory(directory)
      .coppensbasis.set_library_directory(directory)
   end

   set_basis_name(name) ::: leaky
   ! Set a gaussian *library* basis set name
      self :: INOUT
      name :: STR

 ! DIE_IF(any(name==non_gaussian),"basis "//trim(name)//"is not a gaussian basis")

 !    non_gaussian :: VEC{STR}(len=17,4) = &
 !       ["Clementi-Roetti  ", &
 !        "Thakkar          ", &
 !        "vanLenthe-Barends", &
 !        "Coppens          "  ]

      ! Set the basis kind
      .basis_name = name

      ! Destroy links to previous bases
      if (.atom.allocated) .atom.destroy_basis_part
      .basis.destroy

      ! Make fresh basis set links (might be leaky)
      .:resolve_gaussianbases ! NOT PURE

   end

   set_slaterbasis_name(name) ::: leaky
   ! Set a slater *library* basis set name
      self :: INOUT
      name :: STR, IN

      ! Set the basis kind
      .slaterbasis_name = name

      ! Destroy links to previous bases
      if (.atom.allocated) .atom.destroy_slaterbasis_part
      .slaterbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .:resolve_slaterbases ! NOT PURE

   end

   set_coppensbasis_name(name) ::: leaky
   ! Set a coppens *library* basis set name
      self :: INOUT
      name :: STR, IN

   ENSURE(name=="Coppens","basis "//trim(name)//"is not a known coppens basis")

      ! Set the basis kind
      .coppensbasis_name = name

      ! Destroy links to previous bases
      if (.atom.allocated) .atom.destroy_coppensbasis_part
      .coppensbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .:resolve_coppensbases ! NOT PURE

   end

!  Resolve bases

   resolve_bases_and_update ::: leaky
   ! Match the basis set labels with a basis set, either from a
   ! library or from the user input. The atoms must exist!
      self :: INOUT

      if (.atom.deallocated) return

      ! Read and resolve
      if (NOT .atom.bases_are_resolved) then
         .basis_info_made = FALSE
         .:resolve_coppensbases ! NOT PURE
         .:resolve_slaterbases
         .:resolve_gaussianbases
      end

      ! Update
      .:update_basis_info

   end

   resolve_bases_and_update_from(mol) ::: leaky
   ! Set the basis data from molecule "mol" assumed to be a parent
   ! "supermolecule" NOTE: atom kinds are *NOT* updated
      self :: INOUT
      mol :: MOLECULE, IN

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol
      .use_spherical_basis = mol.use_spherical_basis

      if (mol.basis.allocated)        .basis        = mol.basis
      if (mol.slaterbasis.allocated)  .slaterbasis  = mol.slaterbasis
      if (mol.coppensbasis.allocated) .coppensbasis = mol.coppensbasis

      ! Do it, but don't update atom.kind's
      .:resolve_bases_and_update ! NOT PURE
      .atom_info_made  = TRUE    ! Assume kinds ared OK

   end

   resolve_gaussianbases ::: leaky, private
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set nby reading a library basis, if not there.
      self :: INOUT

      library_basis_labels :: VEC{STR}@
      n_unique :: INT
      library :: STR

      if (.atom.deallocated) return

      if (.n_atom<1) return

      if (.atom.bases_are_resolved) return

      ! Read from a library
      if (.basis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.basis.allocated) .basis.renormalise

         ! Read the basis from the library
         library = .basis.library_file(.basis_name)
         library_basis_labels = .atom.library_basis_labels(.basis_name)
         .basis.read_library_data(library,library_basis_labels,n_unique) ! NOT PURE
         library_basis_labels.destroy

         if (.basis.allocated) .basis.unnormalise

      end

      ! Resolve 
      if (.basis.allocated) then
         .basis.set_spherical(.use_spherical_basis)
         .atom.resolve_bases(.basis,.basis_name)
         .atom.set_basis_kind("gaussian")
         .atom_info_made = FALSE ! Need new atom kinds
      end

   end

   resolve_slaterbases ::: leaky, private
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set by reading a library basis set, if not there.
      self :: INOUT

      library_basis_labels :: VEC{STR}@
      n_unique :: INT
      library :: STR

      if (.atom.deallocated) return

      if (.n_atom<1) return

      if (.atom.slaterbases_are_resolved) return

      ! Read from a library
      if (.slaterbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.slaterbasis.allocated) .slaterbasis.renormalise

         ! Read the basis from the library
         library = .slaterbasis.library_file(.slaterbasis_name)
         library_basis_labels = .atom.library_basis_labels(.slaterbasis_name)
         .slaterbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         if (.slaterbasis.allocated) .slaterbasis.unnormalise

      end

      ! Resolve
      if (.slaterbasis.allocated) then
         .atom.resolve_bases(.slaterbasis,.slaterbasis_name)
         .atom.set_basis_kind("slater")
         .atom_info_made = FALSE ! Need new atom kinds
      end

   end

   resolve_coppensbases ::: leaky, private
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set by reading a library basis set, if not there.
      self :: INOUT

      library_basis_labels :: VEC{STR}@
      n_unique :: INT
      library :: STR

      if (.atom.deallocated) return

      if (.n_atom<1) return

      if (.atom.coppensbases_are_resolved) return

      ! Read from a library 
      if (.coppensbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.coppensbasis.allocated) .coppensbasis.renormalise
         ! Read the basis from the library
         library = .coppensbasis.library_file(.coppensbasis_name)
         library_basis_labels = .atom.library_basis_labels(.coppensbasis_name)
         .coppensbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         if (.coppensbasis.allocated) .coppensbasis.unnormalise

      end

      ! Resolve 
      if (.coppensbasis.allocated) then
         .atom.resolve_bases(.coppensbasis,.coppensbasis_name)
         .atom.set_basis_kind("coppens")
         .atom_info_made = FALSE ! Need new atom kinds
      end

   end

   update_basis_info ::: leaky, private, PURE
   ! Make the basis set information including shell-basis-fn limits
      self :: INOUT

      if (.basis.deallocated) return
      if (.atom.deallocated)  return

      .n_basis       = .basis.dim
      .n_bf          = .atom.no_of_basis_functions
      .n_prim        = .atom.no_of_primitives
      .n_shell       = .atom.no_of_shells
      .n_shell_pairs = .atom.no_of_shell_pairs

      ! Make shell-basis-function limts, etc. (leaky)
      .:update_shell_info

      .basis_info_made = TRUE
      .atom_info_made  = FALSE ! Since kinds depend on bases

   end

!  ANOs

   resolve_ANOs_from(mol,list) ::: PURE
   ! Set ANO data and atom shell info from molecule "mol" from the
   ! sublist "list". Make sure none of these are destroyed!
   ! NOTE: No point to assign unique data, all data is non-unique
      self :: INOUT
      mol :: MOLECULE, IN
      list :: VEC{INT}, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.n_atom_kind>0,"atoms not finalized")
   ENSURE(mol.atom.allocated,"mol has no atoms")
   ENSURE(mol.n_atom_kind>0,"mol atoms not finalized")
   ENSURE(list.dim==.atom.dim,"inconsistent list length")

      made_ANO,made_int,made_shl :: BIN
      a,b :: INT

      ! Assign ANO orbitals
      made_ANO =  mol.:has_all_ANO_matrices
      if (made_ANO) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).density_mx = mol.atom(b).density_mx
            .atom(a).NOs        = mol.atom(b).NOs
            .atom(a).NO_occ_nos = mol.atom(b).NO_occ_nos
            .atom(a).AOs        = mol.atom(b).AOs
            .atom(a).set_energy(mol.atom(b).energy)
         end
      end

      ! Assign ANO interpolators
      made_int = mol.:has_all_interpolators
      if (made_int) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).interpolator = mol.atom(b).interpolator
         end
      end

      ! Assign atom shell info
      made_shl = mol.:has_all_shell_info
      if (made_shl) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).first_basis_fn_for_shell = mol.atom(b).first_basis_fn_for_shell
            .atom(a).last_basis_fn_for_shell  = mol.atom(b).last_basis_fn_for_shell
            .atom(a).basis_shell1pair         = mol.atom(b).basis_shell1pair
         end
      end

   end

!  Some probs with routine below, use above if you can?

   resolve_ANOs_from(mol) ::: PURE
   ! Set ANO data and atom shell info from molecule "mol" by comparing
   ! the atom kinds directly. Make sure none of the assigned ANO data
   ! is destroyed!
      self :: INOUT
      mol  :: MOLECULE, IN

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.n_atom_kind>0,"atoms not finalized")
   ENSURE(mol.atom.allocated,"mol has no atoms")
   ENSURE(mol.n_atom_kind>0,"mol atoms not finalized")

      a,b :: INT

      ! Assign ANO orbitals
      do a = 1,.atom.dim
      do b = 1,mol.atom.dim
         if (.atom(a).is_same_kind_as(mol.atom(b))) then
         if (mol.atom(b).has_ANO_matrices) then
            .atom(a).density_mx     = mol.atom(b).density_mx
            .atom(a).NOs            = mol.atom(b).NOs
            .atom(a).NO_occ_nos     = mol.atom(b).NO_occ_nos
            .atom(a).AOs            = mol.atom(b).AOs
            .atom(a).set_energy(mol.atom(b).energy)
            exit ! next atom "a"
         end
         end
      end
      end

      ! Assign ANO interpolators
      do a = 1,.atom.dim
      do b = 1,mol.atom.dim
         if (.atom(a).is_same_kind_as(mol.atom(b))) then
         if (mol.atom(b).interpolator.allocated) then
            .atom(a).interpolator = mol.atom(b).interpolator
            exit ! next atom "a"
         end
         end
      end
      end

      ! Assign atom shell info
      do a = 1,.atom.dim
      do b = 1,mol.atom.dim
         if (.atom(a).is_same_kind_as(mol.atom(b))) then
         if (mol.atom(b).has_shell_info) then
            .atom(a).first_basis_fn_for_shell = mol.atom(b).first_basis_fn_for_shell
            .atom(a).last_basis_fn_for_shell  = mol.atom(b).last_basis_fn_for_shell
            .atom(a).basis_shell1pair         = mol.atom(b).basis_shell1pair
            exit ! next atom "a"
         end
         end
      end
      end

   end

!  Axes

   resolve_axis_system ::: PURE
   ! Change the axis system to cartesian, if required.
   ! NOTE: Errors (if any) are transformed straightforwardly
      self :: INOUT

      if (.crystal.deallocated) return
      if (.atom.deallocated)    return

      .atom.change_axis_system_to("cartesian",.crystal.unit_cell,FALSE)

   end

   change_axis_system_to
   ! Change the axis system.
   ! NOTE: Errors (if any) are transformed straightforwardly
      self :: INOUT

      axis_system :: STR

      if (.crystal.deallocated) return
      if (.atom.deallocated)    return

      stdin.read(axis_system)

      .atom.change_axis_system_to(axis_system,.crystal.unit_cell,FALSE)

   end


!  ============
!  Read routine
!  ============

!   read_CIF_ADPs(cif) ::: leaky
!   ! Read atom ADP information from a Crystallographic Information File, "cif".
!      cif :: CIF
!
!   ENSURE(cif.start_of_data>0,"no start of data in CIF")
!   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")
!   ENSURE(.crystal.allocated,"must have crystal information")
!
!      if (NOT cif.file.is_open) cif.open
!
!      .atom.read_CIF_ADPs(cif)
!
!      .:resolve_axis_system
!
!   end

!  ===================
!  Redirect and revert
!  ===================

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   redirect_stdout ::: leaky
   ! Redirect stdout to the file whose name is the following string
   ! in the current input file.

      name :: STR

      if (FALSE) self = self

      stdin.read(name)
      stdout.redirect(name)

   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   revert_stdout ::: leaky
   ! Revert stdout back to the previously stored input file
      if (FALSE) self = self
      stdout.revert
   end

!  ==================
!  Read/write archive
!  ==================

   read_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g.  "r ".
   ! For use with TONTO generated archives.
      self :: INOUT

   ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR

      stdin.read(name)
      stdin.read(genre)

      stdout.text("reading archive : " // trim(name))
      .:read_archive(name,genre)

   end

   read_archive(name,genre) ::: leaky
   ! Read the archive called "name" with "genre", e.g. "r ".
   ! For use with TONTO generated archives. Handle specific
   ! lambda's in the name (if the name is of the form ....,lambda=...)
      self :: INOUT
      name :: STR, IN
      genre :: STR, IN

   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      i  :: INT
      nm :: STR
      normalise :: STR
      do_norm :: BIN
      arch :: ARCHIVE

      ! Set the archive "name" & "genre"
      arch.set(.name,name,genre=genre)

      ! Now remove any lambda in the "name"
      nm = name
      i  = nm.index_of_character_in(",")
      if (i>0) then
         nm = name(1:i-1)
      end

      ! Second word on line is normalise?
      normalise = " "
      if (stdin.buffer.n_items==2) stdin.read(normalise)
      do_norm = normalise(1:9)=="normalise" OR normalise(1:9)=="normalize"
      ! Tell them
      if (do_norm) then
         stdout.flush
         stdout.text("Writing normalised "//trim(nm))
         stdout.flush
      end

      ! Read the archive
      select case (nm)

      case ("covalent_orbitals ","RG_COs            ")
         if (.NOs.deallocated) .NOs.create(.n_bf)
         arch.read(.NOs)
         if (do_norm) &
            .NOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("ionic_orbitals    ","RG_IOs            ")
         if (.NOs.deallocated) .NOs.create(.n_bf)
         arch.read(.NOs)
         if (do_norm) &
            .NOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
         if (.MOs.deallocated) .MOs.create(.n_bf)
         arch.read(.MOs)
         if (do_norm) &
            .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         if (.MO_energies.deallocated) .MO_energies.create(.n_bf)
         arch.read(.MO_energies)

      case ("natural_orbitals  ","NOs               ")
         if (.NOs.deallocated) .NOs.create(.n_bf)
         arch.read(.NOs)
         if (do_norm) &
         .NOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("occupation_nos    ","NO_occ_nos        ")
         if (.NO_occ_nos.deallocated) .NO_occ_nos.create(.n_bf)
         arch.read(.NO_occ_nos)

      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
         if (.density_mx.deallocated) .density_mx.create(.n_bf)
         arch.read(.density_mx)
         if (do_norm) &
            .density_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
         if (.fock_mx.deallocated) .fock_mx.create(.n_bf)
         arch.read(.fock_mx)
         if (do_norm) &
            .fock_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("U_electric_dipole ")
         if (.U_electric_dipole.deallocated) .U_electric_dipole.create(.n_bf,.n_bf,3)
         arch.read(.U_electric_dipole)

      case ("U2_electric_dipole ")
         if (.U2_electric_dipole.deallocated) .U2_electric_dipole.create(.n_bf,.n_bf,6)
         arch.read(.U2_electric_dipole)

      case default
         UNKNOWN(nm)

      end

      ! Clean up
      arch.close

   end

   read_ascii_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g. "r ".
      self :: INOUT

   ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR
      arch :: ARCHIVE

      ! Read archive name & genre
      stdin.read(name)
      stdin.read(genre)

      ! Set archive "name", "genre" & ascii format
      arch.set(.name,name,genre=genre,format="ascii")

      ! Read the archive
      select case (name)

      case ("covalent_orbitals ","RG_COs            ")
         if (.NOs.deallocated)   .NOs.create(.n_bf)
         arch.read(.NOs,by_column=TRUE)

      case ("ionic_orbitals    ","RG_IOs            ")
         if (.NOs.deallocated)   .NOs.create(.n_bf)
         arch.read(.NOs,by_column=TRUE)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
         if (.MOs.deallocated) .MOs.create(.n_bf)
         arch.read(.MOs,by_column=TRUE)

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         if (.MO_energies.deallocated)   .MO_energies.create(.n_bf)
         arch.read(.MO_energies)

      case ("natural_orbitals  ","NOs               ")
         if (.NOs.deallocated)   .NOs.create(.n_bf)
         arch.read(.NOs,by_column=TRUE)

      case ("no_occupation_nos ","NO_occ_nos        ")
         if (.NO_occ_nos.deallocated) .NO_occ_nos.create(.n_bf)
         arch.read(.NO_occ_nos)

      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
         if (.density_mx.deallocated)     .density_mx.create(.n_bf)
         arch.read(.density_mx,by_column=TRUE)

      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
         if (.fock_mx.deallocated)        .fock_mx.create(.n_bf)
         arch.read(.fock_mx,by_column=TRUE)

      case default
         UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   write_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.
      self :: INOUT

      name,normalise :: STR
      do_norm :: BIN
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set archive "name"
      arch.set(.name,name)

      ! Second word on line is normalise?
      normalise = " "
      if (stdin.buffer.n_items==2) stdin.read(normalise)
      do_norm = normalise(1:9)=="normalise" OR normalise(1:9)=="normalize"

      ! Tell them
      if (do_norm) then
         stdout.flush
         stdout.text("Writing normalised "//trim(name))
         stdout.flush
      end

      ! Write the archive, "genre" from object
      select case (name)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
         DIE_IF(.MOs.deallocated,"no MOs")
         if (do_norm) then
            .MOs.renormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.write(.MOs)
            .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         else
            arch.write(.MOs)
         end

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         DIE_IF(.MO_energies.deallocated,"no MO_energies")
         arch.write(.MO_energies)

      case ("natural_orbitals  ","NOs               ")
         DIE_IF(.NOs.deallocated,"no NOs")
         if (do_norm) then
            .NOs.renormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.write(.NOs)
            .NOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         else
            arch.write(.NOs)
         end

      case ("no_occupation_nos ","NO_occ_nos        ")
         DIE_IF(.NO_occ_nos.deallocated,"no NO_occ_nos")
         arch.write(.NO_occ_nos)


      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
         DIE_IF(.density_mx.deallocated,"no density_mx")
         if (do_norm) then
            .density_mx.renormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.write(.density_mx)
            .density_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         else
            arch.write(.density_mx)
         end

      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
         DIE_IF(.fock_mx.deallocated,"no fock_mx")
         if (do_norm) then
            .fock_mx.renormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.write(.fock_mx)
            .fock_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         else
            arch.write(.fock_mx)
         end

      case default
         UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   write_ascii_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.
      self :: INOUT

      name :: STR
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set the archive "name" and ascii format
      arch.set(.name,name,format="ascii")

      ! Write the archive, "genre" from object
      select case (name)

      case ("molecular_orbitals","MOs               ", &
            "HF_MOs            ","KS_MOs            ")
       ! .MOs.renormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.MOs,by_column=TRUE)
       ! .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("MO_energies       ", &
            "HF_MO_energies    ","KS_MO_energies    ")
         arch.write(.MO_energies,  by_column=TRUE)

      case ("natural_orbitals  ","NOs               ")
       ! .NOs.renormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.NOs,  by_column=TRUE)
       ! .NOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case ("occupation_nos    ","NO_occ_nos        ")
         arch.write(.NO_occ_nos,by_column=TRUE)

      case ("density_matrix    ","density_mx        ", &
            "hf_density_matrix ","HF_density_mx     ", &
            "ks_density_matrix ","KS_density_mx     ", &
            "mp2_density_matrix","MP2_density_mx    ", &
            "mp3_density_matrix","MP3_density_mx    ")
       ! .density_mx.renormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.density_mx,    by_column=TRUE)
       ! .density_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
      
      case ("fock_matrix       ", &
            "Fock_mx           ","Kohn-Sham_mx      ")
       ! .fock_mx.renormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
         arch.write(.fock_mx,       by_column=TRUE)
       ! .fock_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      case default
         UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

!  ================
!  Molden interface
!  ================

   read_molden_MOs(file_name, do_groups, print_output) ::: leaky
   ! Read a Molden MOs file
      self :: INOUT
      file_name :: STR, optional, IN
      do_groups    :: BIN, optional, IN
      print_output :: BIN, optional, IN

      molden_file,save :: TEXTFILE*
      archive :: ARCHIVE
      pos :: VEC{REAL}(3)
      orb :: VEC{REAL}@
      fac,n_e,n_a,n_b,val,energy,occ :: REAL
      name,units,item,label,spin :: STR
      op,cl :: STR(len=1)
      output,found,is_unrestricted :: BIN
      line, a,i,f,Z :: INT

      ! Get file name
      if (present(file_name)) then;              name = file_name
      else if (NOT stdin.buffer_exhausted) then; stdin.read(name)
      else;                                      name = .name
      end

      if (present(print_output)) then; output = print_output
      else;                            output = FALSE
      endif

      ! Constants
      op = achar(91)
      cl = achar(93)

      ! Open Molden file
      molden_file.create(name)
      molden_file.open_for("read")

      ! Find out if this file is using a spherical basis
      line = molden_file.line_number
      molden_file.look_for(op//"5D"//cl,found=found)
      if(found) .use_spherical_basis = TRUE
      molden_file.move_to_line(line)

      ! Find [ATOMS] block
      ! or [Atoms]
      molden_file.look_for(op//"Atoms"//cl,found=found)
      if(NOT found) molden_file.look_for(op//"ATOMS"//cl,found=found)
      DIE_IF(NOT found, "No ATOMS line")
      DIE_IF(molden_file.n_line_items/=2, "Expecting two items on ATOMS line")

      ! Read units
      molden_file.read(units)
      fac = ONE
      if (units=="Angs") fac = BOHR_PER_ANGSTROM

      ! Store start of atoms list
      molden_file.read_line
      line = molden_file.line_number

      ! Get no. of atoms ...
      .n_atom = 0
      do
         molden_file.read(item)
         if (item(1:1)==op) exit
         DIE_IF(molden_file.end_of_file,"file ended unexpectedly")
         .n_atom = .n_atom + 1
         molden_file.read_line
      end

      ! Create atom list (leaky)
      if (.atom.allocated)  .atom.destroy
      .atom.create(.n_atom)
      .atom_info_made = FALSE

      ! Create basis -- Different one for every atom (leaky)
      if (.basis.allocated) .basis.destroy
      .basis.create(.n_atom)
      if(.use_spherical_basis) .basis.set_spherical(TRUE)

      ! Move back to atoms line
      molden_file.move_to_line(line)

      ! For each atom a: read label, Z, coordinates
      do a = 1,.n_atom

         ! Read label
         molden_file.read(label)

         ! Read Z
         molden_file.skip_next_item
         molden_file.read(Z)

         ! Set
         .atom(a).set_atomic_number(Z)
         .atom(a).set_atom_data_from_label(label)

         ! Read position, change units
         molden_file.read(pos)
         pos = fac*pos
         .atom(a).set_position(pos)

         ! Set basis label
         .atom(a).set_basis_label(trim(.atom(a).generic_chemical_symbol)//":molden")

      end

      ! Read basis set
      molden_file.look_for(op//"GTO"//cl,found=found)
      DIE_IF(NOT found, "No GTO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on GTO line")
      molden_file.read_line

      ! Read basis
      save => stdin
      stdin => molden_file
      do a = 1,.n_atom
         .basis(a).read_molden
         .basis(a).set_label(.atom(a).basis_label)
      end
      stdin => save

      ! Remove repetitions
      .basis.remove_repetitions

      if (output) then
         .:put_bases
      end 

      ! Find [MO] tag
      molden_file.look_for(op//"MO"//cl,found=found)
      DIE_IF(NOT found, "No MO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on MO line")
      line = molden_file.line_number + 1

      ! Any Beta tag?
      molden_file.look_for("Beta",found=is_unrestricted)

      ! Move back to [MO]'s
      ! Get no. of electrons
      molden_file.move_to_line(line)
      n_e = ZERO
      do
         molden_file.look_for("Occup=",found=found)
         if (NOT found) exit
         molden_file.move_to_line_item(2)
         molden_file.read(val)
         molden_file.read_line
         n_e = n_e + val
      end

      ! Now set charge
      .n_e    = nint(n_e)
      .charge = .atom.no_of_electrons - .n_e

      if (is_unrestricted) then

         ! Now find no. of alpha electrons (assuming unrestricted)
         molden_file.move_to_line(line)
         n_a = ZERO
         do
            molden_file.look_for("Alpha",found=found)
            if (NOT found) exit
            molden_file.look_for("Occup=",found=found)
            if (NOT found) exit
            molden_file.move_to_line_item(2)
            molden_file.read(val)
            molden_file.read_line
            n_a = n_a + val
         end
        
         ! Set no. of beta electrons
         n_b = n_e - n_a
        
         ! Set multiplicity
         .:set_n_a_n_b_and_multiplicity(nint(n_a),nint(n_b))

      else

         ! Restricted
         .spin_multiplicity = .:default_spin_multiplicity

      end

      ! Finalize atom info/basis sets
      .:update_atom_and_basis_info(do_groups)

      if (output) then
         .atom.put
      end

      ! Create scfdata (leaky)
      .scfdata.destroy
      .scfdata.create
      .scfdata.set_output(output)

      ! Create MO arrays (leaky)
      .MO_energies.destroy
      .MOs.destroy

      if (is_unrestricted) then

         .scfdata.set_SCF_kind("uhf")
         .MO_energies.create(.n_bf,"u ")
         .MO_energies.a = ZERO
         .MO_energies.b = ZERO
         .MOs.create(.n_bf,"u ")
         .MOs.a = ZERO
         .MOs.b = ZERO

      else

         .scfdata.set_SCF_kind("rhf")
         .MO_energies.create(.n_bf,"r ")
         .MO_energies.r = ZERO
         .MOs.create(.n_bf,"r ")
         .MOs.r = ZERO

      end

      ! Set occupation numbers (leaky)
      spin = .scfdata.spinorbital_genre
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,spin)
      .NO_occ_nos.set_to_zero
      .:set_SCF_occupations_for_NOs(spin)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)
      orb.create(.n_bf)

      ! Read in orbitals and energies.
      i = 0
      do

         molden_file.look_for("Ene=",found=found)

         if (NOT found) exit

         ! Read energy
         molden_file.skip_next_item
         molden_file.read(energy)

         ! Read spin
         molden_file.skip_next_item
         molden_file.read(spin)

         ! Read occupation
         molden_file.skip_next_item
         molden_file.read(occ)

         ! Read orbital
         do f = 1,.n_bf
            molden_file.skip_next_item
            molden_file.read(orb(f))
         end

         ! Increment orbital
         i = i + 1

         ! Assign MO's
         if (is_unrestricted) then

            DIE_IF(i>2*.n_bf,"too many orbitals specified")
            select case (spin)
            case ("Alpha")
               .MO_energies.a(i) = energy
               .MOs.a(:,i) = orb
            case ("Beta")
               .MO_energies.b(i-.n_bf) = energy
               .MOs.b(:,i-.n_bf) = orb
            case default
               DIE("unknown spin: "//trim(spin))
            end

         else

            DIE_IF(i>.n_bf,"too many orbitals specified")
            select case (spin)
            case ("Alpha")
               .MO_energies.r(i) = energy
               .MOs.r(:,i) = orb
            case default
               DIE("unexpected spin: "//trim(spin))
            end

         end

      end

      ! Clean
      orb.destroy

      ! Swap orbital order
      if (output) then
         stdout.text("Reordering basis functions into tonto order")
      end

      if (is_unrestricted) then
         .:swap_molden_orbital_order(.MOs.a,"row")
         .:swap_molden_orbital_order(.MOs.b,"row")
      else
         .:swap_molden_orbital_order(.MOs.r,"row")
      end


      ! Make density matrix (leaky)
      .:make_SCF_density_mx

      ! Echo what was read
      if (output) then

         stdout.text("Occupation")
         stdout.put(.NO_occ_nos)

         ! Print out data
         stdout.flush
         stdout.text("===========")
         stdout.text("Molden data")
         stdout.text("===========")
         stdout.flush
         stdout.text("Below are the molden:")
         stdout.text(". Atom coordinates and bases")
         stdout.text(". Molecular orbitals and their occupancies")
         stdout.flush
         if (is_unrestricted) then; stdout.text("The data is for *unrestricted* orbitals")
         else;                      stdout.text("The data is for *restricted* orbitals")
         end

         stdout.flush
         stdout.text("Molden atom coordinates and bases:")
         .:put_atoms

         stdout.flush
         stdout.text("Occupation numbers:")
         stdout.flush
         stdout.put(.NO_occ_nos)

         stdout.flush
         stdout.text("Orbital energies:")
         stdout.flush
         stdout.put(.MO_energies)

         stdout.flush
         stdout.text("MOs:")
         stdout.flush
         stdout.put(.MOs)

         stdout.flush
         stdout.text("Density matrix:")
         stdout.flush
         stdout.put(.density_mx)

         stdout.flush

      endif

      ! Save data in archive files
      archive.set_defaults

      archive.set(.name,"density_mx")
      .density_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
      archive.write(.density_mx)

      archive.set(.name,"MOs")
      .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
      archive.write(.MOs)

      archive.set(.name,"MO_energies")
      archive.write(.MO_energies)

      ! Set crystal data
      if (.crystal.allocated) then
         .:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

      ! Clean
      molden_file.destroy

   end

   read_molden_NOs(file_name) ::: leaky
   ! Read a Molden natural orbitals file.
   ! Here the occupation numbers are not integers.
      self :: INOUT
      file_name :: STR, optional, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")

      molden_file,save :: TEXTFILE*
      archive :: ARCHIVE
      pos :: VEC{REAL}(3)
      orb :: VEC{REAL}@
      fac,n_e,val,energy,occ :: REAL
      name,units,item,label,spin :: STR
      op,cl :: STR(len=1)
      found,is_unrestricted :: BIN
      line, a,i,f,Z :: INT

      ! Get file name
      if (present(file_name)) then;              name = file_name
      else if (NOT stdin.buffer_exhausted) then; stdin.read(name)
      else;                                      name = .name
      end

      ! Constants
      op = achar(91)
      cl = achar(93)

      ! Open Molden file
      molden_file.create(name)
      molden_file.open_for("read")

      ! Find [ATOMS] block
      molden_file.look_for(op//"ATOMS"//cl,found=found)
      DIE_IF(NOT found, "No ATOMS line")
      DIE_IF(molden_file.n_line_items/=2, "Expecting two items on ATOMS line")

      ! Read units
      molden_file.read(units)
      fac = ONE
      if (units=="Angs") fac = BOHR_PER_ANGSTROM

      ! Store start of atoms list
      molden_file.read_line
      line = molden_file.line_number

      ! Get no. of atoms ...
      .n_atom = 0
      do
         molden_file.read(item)
         if (item==op//"Molden") exit
         DIE_IF(molden_file.end_of_file,"file ended unexpectedly")
         .n_atom = .n_atom + 1
         molden_file.read_line
      end

      ! Create atom list (leaky)
      if (.atom.allocated)  .atom.destroy
      .atom.create(.n_atom)
      .atom_info_made = FALSE

      ! Create basis -- Different one for every atom (leaky)
      if (.basis.allocated) .basis.destroy
      .basis.create(.n_atom)

      ! Move back to atoms line
      molden_file.move_to_line(line)

      ! For each atom a: read label, Z, coordinates
      do a = 1,.n_atom

         ! Read label
         molden_file.read(label)

         ! Read Z
         molden_file.skip_next_item
         molden_file.read(Z)

         ! Set
         .atom(a).set_atomic_number(Z)
         .atom(a).set_atom_data_from_label(label)

         ! Read position, change units
         molden_file.read(pos)
         pos = fac*pos
         .atom(a).set_position(pos)

         ! Set basis label
         .atom(a).set_basis_label("molden-"//trim(.atom(a).generic_chemical_symbol))

      end

      ! Read basis set
      molden_file.look_for(op//"GTO"//cl,found=found)
      DIE_IF(NOT found, "No GTO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on GTO line")
      molden_file.read_line

      ! Read basis
      save => stdin
      stdin => molden_file
      do a = 1,.n_atom
         .basis(a).read_molden
         .basis(a).put
         .basis(a).set_label(.atom(a).basis_label)
      end
      stdin => save

      ! Find [MO] tag
      molden_file.look_for(op//"MO"//cl,found=found)
      DIE_IF(NOT found, "No MO line")
      DIE_IF(molden_file.n_line_items/=1, "Expecting only one item on MO line")
      line = molden_file.line_number + 1

      ! Any Beta tag?
      molden_file.look_for("Beta",found=is_unrestricted)

      ! Move back to [MO]'s
      molden_file.move_to_line(line)

      ! Get no. of electrons
      n_e = ZERO
      do
         molden_file.look_for("Occup=",found=found)
         if (NOT found) exit
         molden_file.move_to_line_item(2)
         molden_file.read(val)
         molden_file.read_line
         n_e = n_e + val
      end

      ! Now set charge
      .charge = .atom.no_of_electrons - nint(n_e)

      ! Set multiplicity
      .spin_multiplicity = .:default_spin_multiplicity

      ! Finalize atom info/basis sets
      .:update_atom_and_basis_info

      ! Create MO arrays (leaky)
      .density_mx.destroy
      .NO_occ_nos.destroy
      .NOs.destroy

      if (is_unrestricted) then

         .NO_occ_nos.create(.n_bf,"u ")
         .NO_occ_nos.a = ZERO
         .NO_occ_nos.b = ZERO

         .density_mx.create(.n_bf,"u ")
         .NOs.create(.n_bf,"u ")
         .NOs.a = ZERO
         .NOs.b = ZERO

      else

         .NO_occ_nos.create(.n_bf,"r ")
         .NO_occ_nos.r = ZERO

         .density_mx.create(.n_bf,"u ")
         .NOs.create(.n_bf,"r ")
         .NOs.r = ZERO

      end

      ! Move back to [MO]'s
      molden_file.move_to_line(line)
      orb.create(.n_bf)

      ! Read in orbitals and energies.
      i = 0
      do

         molden_file.look_for("Ene=",found=found)

         if (NOT found) exit

         ! Read energy
         molden_file.skip_next_item
         molden_file.read(energy)

         ! Read spin
         molden_file.skip_next_item
         molden_file.read(spin)

         ! Read occupation
         molden_file.skip_next_item
         molden_file.read(occ)

         ! Read orbital
         do f = 1,.n_bf
            molden_file.skip_next_item
            molden_file.read(orb(f))
         end

         ! Increment orbital
         if (spin=="Alpha") i = i + 1
         DIE_IF(i>.n_bf,"too many orbitals specified")

         ! Assign MO's
         if (is_unrestricted) then

            select case (spin)

            case ("Alpha")
               .NO_occ_nos.a(i) = occ
               .NOs.a(:,i) = orb

            case ("Beta")
               .NO_occ_nos.b(i) = occ
               .NOs.b(:,i) = orb

            case default
               DIE("unknown spin: "//trim(spin))

            end

         else

            select case (spin)

            case ("Alpha")
               .NO_occ_nos.r(i) = occ
               .NOs.r(:,i) = orb

            case default
               DIE("unexpected spin: "//trim(spin))

            end

         end

      end

      ! Clean
      orb.destroy

      ! Swap orbital order
      if (is_unrestricted) then
         .:swap_molden_orbital_order(.NOs.a,"row")
         .:swap_molden_orbital_order(.NOs.b,"row")
      else
         .:swap_molden_orbital_order(.NOs.r,"row")
      end


      ! Make density matrix
      if (is_unrestricted) then
         .:make_density_mx_from(.NOs,.NO_occ_nos,"u ")
      else
         .:make_density_mx_from(.NOs,.NO_occ_nos,"r ")
      end

      ! Print out data
      stdout.flush
      stdout.text("===========")
      stdout.text("Molden data")
      stdout.text("===========")
      stdout.flush
      stdout.text("Below are the data read from the molden file:")
      stdout.text(". Atom coordinates and bases")
      stdout.text(". Natural orbitals and their occupancies")
      stdout.flush
      if (is_unrestricted) then; stdout.text("The data is for *restricted* orbitals")
      else;                      stdout.text("The data is for *unrestricted* orbitals")
      end

      stdout.flush
      stdout.text("Molden atom coordinates and bases:")
      .:put_atoms

      stdout.flush
      stdout.text("Occupation numbers:")
      stdout.flush
      stdout.put(.NO_occ_nos)

      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.flush
      stdout.put(.NOs)

      ! Save data in archive files
      archive.set_defaults

      archive.set(.name,"density_mx")
      archive.write(.density_mx)

      archive.set(.name,"NOs")
      archive.write(.NOs)

      archive.set(.name,"NO_occ_nos")
      archive.write(.NO_occ_nos)

      ! Set crystal data
      if (.crystal.allocated) then
         .:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

      ! Clean
      molden_file.destroy

   end

   swap_molden_orbital_order(X,swap) ::: PURE
   ! Swap the order of orbitals on matrix "X" after reading a
   ! molden input file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2".  This is nearly the same as gaussian.
   !
   ! The molden orderring is as follows:
   !  5D: D 0, D+1, D-1, D+2, D-2
   !  6D: xx, yy, zz, xy, xz, yz
   !  7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
   ! 10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
   !  9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
   ! 15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy,
   !      xxyy xxzz yyzz xxyz yyxz zzxy
      self :: IN
      X :: MAT{REAL}, INOUT
      swap :: STR, IN

      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}@
      ff  :: VEC{INT}(10)
      sph_reorder :: VEC{INT}@

      ff = [1, 2, 3, 5, 6, 4, 9, 7, 8, 10]

      select case (swap)

      case("row","1")
         do s = 1,.n_shell
            f  = .first_basis_fn_for_shell(s)
            l  = .last_basis_fn_for_shell(s)
            ls = .angular_moment_for_shell(s)
            if(.atom(.atom_for_shell(s)).basis.is_spherical) then
               ! do spherical test
               sph_reorder = GAUSSIAN_DATA:tonto_to_gaussian_spherical_indices(ls)
               if (ls>=1) then ! swap f functions
                  X(f:l,:) = X(f-1+sph_reorder,:)
               end
               if (ls>1) then  ! normalisation factors
                  lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg  = lg + 1
                  lg  = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do i = f,l
                     X(i,:) = X(i,:)*fac(i-f+1)
                  end
               end
            else
               ENSURE(ls<=4,"cannot yet convert order for h shells")
               ! fix for nwchem molden MOs, PGTO normalization for xy, xy, yz
               if (ls == 2) then
                  X(f+3:l,:) = X(f+3:l,:) / sqrt(3d0)
               end
               if (ls==3) then ! swap f functions
                  X(f:l,:) = X(f-1+ff,:)
                  ! if the same trend from D is true for F above these may be needed
                  ! X(f+3:l-1,:) = X(f+3:l-1,:) / sqrt(3d0)
                  ! X(l-1:l,:) = X(l-1:l,:) / sqrt(15d0)
               end
               if (ls>1) then  ! normalisation factors
                  lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg  = lg + 1
                  lg  = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do i = f,l
                     X(i,:) = X(i,:)*fac(i-f+1)
                  end
               end
            end
         end

      case("column","2")
         do s = 1,.n_shell
            f  = .first_basis_fn_for_shell(s)
            l  = .last_basis_fn_for_shell(s)
            ls = .angular_moment_for_shell(s)
            ENSURE(ls<=4,"cannot yet convert order for h shells")
            if (ls==3) then ! swap f functions
               X(:,f:l) = X(:,f-1+ff)
            end
            if (ls>1) then  ! normalisation factors
               lg  = GAUSSIAN_DATA:n_comp_up_to(ls-1)
               fg  = lg + 1
               lg  = lg + GAUSSIAN_DATA:n_comp(ls)
               fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
               do j = f,l
                  X(:,j) = X(:,j)*fac(j-f+1)
               end
            end
         end

    ! case default
    !    DIE("unknown swap kind, "//trim(swap))

      end

   end

!  ======================
!  Gaussian chk interface
!  ======================

! Read *only* Tonto MO's and density from g09

   read_tonto_FChk_file(name) ::: leaky
   ! Read the MO's and density matrix from a g09 checkpoint file
   ! as if these were just placed there in TONTO format.
   ! WARNING: only works for restricted
      self :: INOUT
      name :: STR, optional, IN

   DIE_IF(NOT .basis_info_made,"must be a tonto basis set!")

      chkfile :: TEXTFILE*
      fchk :: STR

      ! Get FChk file name
      if (present(name)) then
         fchk = name
      else if (NOT stdin.buffer_exhausted) then
         stdin.read(fchk) ! specified on stdin
      else
         fchk = .name
      end

      ! Create FChk file
      chkfile.create(name)

    ! ! Create orbital energies.
    ! .MO_energies.destroy
    ! .MO_energies.create(.n_bf,"r ")

    ! ! Find & read orbital energies.
    ! chkfile.look_for("Alpha Orbital Energies",from=1)
    ! chkfile.read(.MO_energies)

      ! Create MOs
      .MOs.destroy
      .MOs.create(.n_bf,"r ")

      ! Find & read in orbitals
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read(.MOs,by_column=TRUE)

      ! Create DM 
      .density_mx.destroy
      .density_mx.create(.n_bf,"r ")

      ! Find & read in DM
      chkfile.look_for("SCF density",from=1)
      chkfile.read(.density_mx,by_column=TRUE)

   end

   write_tonto_FChk_MO ::: leaky
   ! Write the MO's in a way which can replace g09 fchk file section
      self :: IN

   ENSURE(NOT .use_spherical_basis,   "spherical basis not implemented")
   ENSURE(.MOs.allocated,"no MO's")

      arch :: ARCHIVE 

      arch.set(.name,"gaussian_MO",genre=.MOs.genre,format="ascii")
      arch.write(.MOs,by_column=TRUE,ascii=TRUE)

   end

   write_tonto_FChk_DM ::: leaky
   ! Write the MO's in a way which can replace g09 fchk file section
      self :: IN

   ENSURE(NOT .use_spherical_basis,   "spherical basis not implemented")
   ENSURE(.density_mx.allocated,"no MO's")

      arch :: ARCHIVE 

      arch.set(.name,"gaussian_DM",genre=.density_mx.genre,format="ascii")
      arch.write(.density_mx,by_column=TRUE,ascii=TRUE)

   end

! Can thesed be condensed into one?

   read_g09_FChk_file(name,do_groups) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      self :: INOUT
      name :: STR, optional, IN
      do_groups :: BIN, optional, IN

   DIE_IF(.use_spherical_basis,"spherical basis not implemented")

      fchk,label :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}@
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}@
      G_ex,G_cc,G_cp, ex,cc,orb_energy,fc :: VEC{REAL}@
      pos :: VEC{REAL}(3)
      temp_mat :: MAT{REAL}@
      Z, a,s,t, f,l,g,h,n3n,ntr :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.allocated) .basis.destroy
      if (.atom.allocated)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create
      .scfdata.set_output(FALSE)

      ! Get FChk file name
      if (present(name)) then
         fchk = name
      else if (NOT stdin.buffer_exhausted) then
         stdin.read(fchk) ! specified on stdin
      else
         fchk = .name
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open_for("read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independ",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis fns /= no. of independent fns")
      WARN_IF(.n_bf/=n_independent,"MO's are wrong, but density matrix is correct")

      ! Read atomic numbers & set
      chkfile.look_for("Atomic numbers",from=1)
      chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
         .atom(a).set_nuclear_charge(REALIFY(Z))
      end

      ! Assign core electrons if any
      chkfile.look_for("Nuclear charges",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         Z = .atom(a).atomic_number
         if (nint(Nc)/=Z) then
            Z = Z - nint(Nc)
            .atom(a).set_n_core_electrons(Z)
         end
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(pos)
         .atom(a).set_position(pos)
      end

      ! Set a name?
      if (.name=="unknown") .name = .atom.chemical_formula

      ! Read gaussian shell info.
      label = "Number of contracted shells"
      chkfile.look_for(label,from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + atom_p.sum_elements
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

    ! stdout.show(" n_shell =", n_shell)
    ! stdout.show(".n_shell =",.n_shell)

    ! stdout.text("Shell types:")
    ! stdout.put(G_shell_type)

    ! stdout.text("Number of prims for:")
    ! stdout.put(G_n_prim_for_shell)

    ! stdout.text("Atom for shell:")
    ! stdout.put(G_atom_for_shell)

    ! stdout.text("Primitive exponents:")
    ! stdout.put(G_ex)

    ! stdout.text("Contractions:")
    ! stdout.put(G_cc)

    ! stdout.text("P(SP) contractions:")
    ! stdout.put(G_cp)

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy
      G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Set basis
      .:set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! Finalize atom info/basis sets
      .:update_atom_and_basis_info(do_groups)

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .MO_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_SCF_kind("uhf")
         .MO_energies.create(.n_bf,"u ")
         .MO_energies.a = ZERO
         .MO_energies.a(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .MO_energies.b = ZERO
         .MO_energies.b(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_SCF_kind("rhf")
         .MO_energies.create(.n_bf,"r ")
         .MO_energies.r = ZERO
         .MO_energies.r(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(n_independent,.n_bf)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .MOs.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .MOs.create(.n_bf,"u ")
         .MOs.a = ZERO
         .MOs.a(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .MOs.b = ZERO
         .MOs.b(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.MOs.a,"row")
         .:swap_from_g94_orbital_order(.MOs.b, "row")
      else
         .MOs.create(.n_bf,"r ")
         .MOs.r = ZERO
         .MOs.r(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .:swap_from_g94_orbital_order(.MOs.r,"row")
      end

      ! Read in density matrix.
      .:read_gX_SCF_dm(chkfile,restricted,.density_mx)

      ! Extract MP2 density matrix to file.  UHF untested
      .:read_gX_MP2_dm(chkfile,restricted,.density_mx)

      ! Extract MP3 density matrix to file.  UHF untested
      .:read_gX_MP3_dm(chkfile,restricted,.density_mx)

      ! Extract CC density matrix to file.  UHF untested
      .:read_gX_CC_dm(chkfile,restricted,.density_mx)

      ! Read in force constants
      if (chkfile.has_string("Cartesian Force Constants")) then
         n3n = 3*.atom.dim
         ntr = n3n.triangle_number
         .force_constants.create(n3n,n3n)
         fc.create(ntr)
         chkfile.look_for("Cartesian Force Constants",from=1)
         chkfile.read_line
         chkfile.read(fc)
         .force_constants.symmetric_unzip_triangle(fc)
         fc.destroy
      end

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archive files
      ! NOTE: MO's & density matrix are wrt unnormalised basis fn's
      archive.set_defaults

      archive.set(.name,"density_mx")
    ! .density_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
      archive.write(.density_mx)

      archive.set(.name,"MOs")
    ! .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
      archive.write(.MOs)

      archive.set(.name,"MO_energies")
      archive.write(.MO_energies)

      if (.crystal.allocated) then
         .:resolve_axis_system
         .crystal.update_fragment_info(.atom)
      end

   end

   set_basis_from_gX_data(l_4_shell,n_cc_4_sh,atom_4_sh,ex_4_prim,cc_4_prim) ::: private, leaky, PURE
   ! Set the basis from gaussian data "XXX_4_sh" are the shell data
   ! flattened over all molecular shells. "XXX_4_prim" are (likewise)
   ! data flattened over molecular primitives.
      self :: INOUT
      l_4_shell,n_cc_4_sh,atom_4_sh :: VEC{INT}, IN
      ex_4_prim,cc_4_prim :: VEC{REAL}, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.atom.allocated,"no atonm list")
   ENSURE(.atom.dim==.n_atom,"wrong size, atom list")

      n_basis,n_shell,n_cc :: INT
      a,s,t, f,l, b :: INT
      basis :: BASIS@, target
      sh :: SHELL*
      same :: BIN

      ! Molecular basis (to be appended to)
      n_basis = 0
      .basis.create(n_basis)

      ! Basis fn/shell counters
      l = 0   ! Last primitive, flattened over all atoms
      t = 0   ! Last shell, flattened over all shells

      ! Loop atom "a"
      do a = 1,.n_atom

         ! Basis for atom "a"
         basis.create
         basis.label = trim(.atom(a).generic_chemical_symbol) // ":gaussian"

         ! Set basis label and kind
         .atom(a).set_basis_label(basis.label)
         .atom(a).set_basis_kind("gaussian")

         ! No. of shells
         n_shell = count(atom_4_sh==a)

         ! Create basis shells
         basis.n_shell = n_shell
         basis.shell.create(n_shell)

         ! Set basis shells
         do s = 1,n_shell

            ! This shell
            sh => basis.shell(s)

            ! Set shell L
            sh.set_l(l_4_shell(t+s))
            sh.set_n_comp

            ! Set shell n_cc
            n_cc    = n_cc_4_sh(t+s)
            sh.n_cc = n_cc

            ! Set shell exponents/contractions
            sh.exponent.create(n_cc)
            sh.contraction.create(n_cc)
            f = l + 1
            l = l + n_cc
            sh.exponent    = ex_4_prim(f:l)
            sh.contraction = cc_4_prim(f:l)

         end

         ! Set no. of bf'd and primitives
         basis.n_bf   = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise ! Note this

         t = t + n_shell

         ! Seen basis before?
         same = FALSE
         do b = 1,n_basis
            if (NOT .basis(b).same_as(basis)) cycle
            same = TRUE
            exit
         end

         ! Append only new basis to .basis
         if (NOT same) then
            n_basis = n_basis + 1
            .basis.append(basis)
         end

         ! Clean
         basis.destroy

      end

   end


   read_gX_dm(chkfile,restricted,dm) ::: template, private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
      chkfile :: TEXTFILE*
      restricted :: BIN, IN
      dm :: OPMATRIX@, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.n_bf>0,"no basis functions")

      D,spin,total :: OPMATRIX@
      archive :: ARCHIVE

      ! Extract density matrix
      if (NOT chkfile.has_string("TAG? Density")) return

      if (restricted) then

         ! Read restricted density (triangle) "name" into "D"
         D.create(.n_bf, "r ")
         D.tri.create(D.l_compress("r "))
         chkfile.look_for("Total TAG? Density")
         chkfile.read_line
         chkfile.read(D.tri)
         D.uncompress

         ! Swap orbital order
         .:swap_from_g94_orbital_order(D.r,"row")
         .:swap_from_g94_orbital_order(D.r,"column")

      else

         ! Create
         D.create(.n_bf,"u ")
         total.create(.n_bf, "r ")
         spin.create(.n_bf, "r ")

         ! Read total density (triangle) TAG? into "total"
         total.tri.create(total.l_compress("r "))
         chkfile.look_for("Total TAG? Density")
         chkfile.read_line
         chkfile.read(total.tri)
         total.uncompress

         ! Read spin density (triangle) trim(tag) into "spin"
         spin.tri.create(spin.l_compress("r "))
         chkfile.look_for("Spin TAG? Density")
         chkfile.read_line
         chkfile.read(spin.tri)
         spin.uncompress

         ! Define alpha and beta densities
         D.b  = (total.r - spin.r)/2
         D.a = (spin.r  + total.r)/2

         ! Clean
         spin.destroy
         total.destroy

         ! Swap orbital order
         .:swap_from_g94_orbital_order(D.a,"row")
         .:swap_from_g94_orbital_order(D.a,"column")
         .:swap_from_g94_orbital_order(D.b, "row")
         .:swap_from_g94_orbital_order(D.b, "column")

      end

      ! Archive the density "D"
      archive.set_defaults
      archive.set(.name,NAME?)
      archive.write(D)

      ! Clean
      if (present(dm)) then
         dm.destroy
         dm = D
      end

      D.destroy

   end

   read_gX_SCF_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>SCF, NAME?=>"SCF_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP2_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>MP2,  NAME?=>"MP2_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP3_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>MP3,  NAME?=>"MP3_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_CC_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG?=>CC,  NAME?=>"CC_density_mx"), private
   ! Read a gaussian density matrix with TAG? which may be
   ! "r " (or not) from "chkfile". Archive it as NAME?.
   ! If "dm" is present it is created to be the density matrix.
   end

! Should go into GAUSIAN_DATA?

   swap_from_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a
   ! gaussian checkpoint file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2". Also: remove the intra-shell basis function
   ! normalisation factors which are not used in Tonto.
      X :: MAT{REAL}
      swap :: STR

      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}@
      ff :: VEC{INT}(10) = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]
      gg :: VEC{INT}(15) = [15, 5, 1, 14, 13, 9, 4, 6, 2, 12, 10, 3, 11, 8, 7]

      select case (swap)

      case("row","1")

         do s = 1,.n_shell

            f  = .first_basis_fn_for_shell(s)
            l  = .last_basis_fn_for_shell(s)
            ls = .angular_moment_for_shell(s)

            ENSURE(ls<=4,"cannot yet convert order for h shells")

            ! Swap f & g functions
            select case (ls)
            case (3); X(f:l,:) = X(f-1+ff,:)
            case (4); X(f:l,:) = X(f-1+gg,:)
            end

            ! Normalisation factors
            if (ls>1) then  
               lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
               fg = lg + 1
               lg = lg + GAUSSIAN_DATA:n_comp(ls)
               fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
               do i = f,l
                  X(i,:) = X(i,:)*fac(i-f+1)
               end
            end

         end

      case("column","2")

         do s = 1,.n_shell

            f  = .first_basis_fn_for_shell(s)
            l  = .last_basis_fn_for_shell(s)
            ls = .angular_moment_for_shell(s)

            ENSURE(ls<=4,"cannot yet convert order for h shells")

            ! Swap f functions; g functions - no change
            if (ls==3) then
               X(:,f:l) = X(:,f-1+ff)
            end

            ! Swap f & g functions
            select case (ls)
            case (3); X(:,f:l) = X(:,f-1+ff)
            case (4); X(:,f:l) = X(:,f-1+gg)
            end

            ! Normalisation factors
            if (ls>1) then  
               lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
               fg = lg + 1
               lg = lg + GAUSSIAN_DATA:n_comp(ls)
               fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
               do j = f,l
                  X(:,j) = X(:,j)*fac(j-f+1)
               end
            end

         end

      case default
         DIE("unknown swap kind, "//trim(swap))

      end

   end

   swap_into_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a
   ! gaussian checkpoint file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2". Also: remove the intra-shell basis function
   ! normalisation factors which are not used in Tonto.
      X :: MAT{REAL}
      swap :: STR

      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}@
      ff :: VEC{INT}(10) = [ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 ]
      gg :: VEC{INT}(15) = [15, 5, 1, 14, 13, 9, 4, 6, 2, 12, 10, 3, 11, 8, 7]

      select case (swap)

      case("row","1")

         do s = 1,.n_shell

            f  = .first_basis_fn_for_shell(s)
            l  = .last_basis_fn_for_shell(s)
            ls = .angular_moment_for_shell(s)

            ENSURE(ls<=4,"cannot yet convert order for h shells")

            ! Normalisation factors
            if (ls>1) then  
               lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
               fg = lg + 1
               lg = lg + GAUSSIAN_DATA:n_comp(ls)
               fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
               do i = f,l
                  X(i,:) = X(i,:)/fac(i-f+1)
               end
            end

            ! Swap f functions; g functions - no change
            select case (ls)
            case (3); X(f-1+ff,:) = X(f:l,:)
            case (4); X(f-1+gg,:) = X(f:l,:)
            end

         end

      case("column","2")

         do s = 1,.n_shell

            f  = .first_basis_fn_for_shell(s)
            l  = .last_basis_fn_for_shell(s)
            ls = .angular_moment_for_shell(s)

            ENSURE(ls<=4,"cannot yet convert order for h shells")

            ! Normalisation factors
            if (ls>1) then  
               lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
               fg = lg + 1
               lg = lg + GAUSSIAN_DATA:n_comp(ls)
               fac = GAUSSIAN_DATA::normalising_factors(fg:lg)
               do j = f,l
                  X(:,j) = X(:,j)/fac(j-f+1)
               end
            end

            ! Swap f functions; g functions - no change
            select case (ls)
            case (3); X(:,f-1+ff) = X(:,f:l)
            case (4); X(:,f-1+gg) = X(:,f:l)
            end

         end

      case default
         DIE("unknown swap kind, "//trim(swap))

      end

   end

!  ========================
!  AIM2000/Morphy interface
!  ========================

   write_morphy98_wfn_file ::: leaky
   ! Write a morphy98 .wfn file
      self :: IN

   ENSURE(.NO_occ_nos.is_allocated_with_genre("r "), "No occupation numbers")
   ENSURE(  .MO_energies.is_allocated_with_genre("r "), "No orbital energies")
   ENSURE(.MOs.is_allocated_with_genre("r "), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}@
      evec :: VEC{REAL}@
      dmatrix, cc :: MAT{REAL}@
      sh :: SHELL@
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".wfn")
      wfnfile.open_for("write")
       
      if (IO_IS_ALLOWED) then

         if (mod(.n_e, 2)==0) then
            n_orbitals = .n_e / 2
         else
            n_orbitals = (.n_e + 1) / 2
         end
       
         write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
         write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
         write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
            .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
         write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)
       
         pcount = 1
         lvec.create(.n_prim)
         evec.create(.n_prim)

         do a = 1, .n_shell

           atomn  = .atom_for_shell(a)
           shelln = .atom_shell_for_shell(a)
           sh     = .atom(atomn).basis.shell(shelln)
           l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
           do j = 1, sh.n_cc
             if (sh.l==3) then
               lvec(pcount  ) = l + 1
               lvec(pcount+1) = l + 2
               lvec(pcount+2) = l + 3
               lvec(pcount+3) = l + 4
               lvec(pcount+4) = l + 5
               lvec(pcount+5) = l + 7
               lvec(pcount+6) = l + 6
               lvec(pcount+7) = l + 8
               lvec(pcount+8) = l + 9
               lvec(pcount+9) = l + 10
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 pcount = pcount + 1
               end
             else
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 lvec(pcount) = l + i
                 pcount = pcount + 1
               end
             end
           end
         end
       
         write(unit=wfnfile.unit, fmt=t_assignment_format) lvec
         write(unit=wfnfile.unit, fmt=exponent_format) evec
       
         lvec.destroy
         evec.destroy
       
         dmatrix.create(.n_prim, .n_bf)
         cc.create(.n_prim, .n_bf)
       
         .:make_contraction_mx(cc)
       
         dmatrix.to_product_of(cc,.MOs.r)
       
         do i = 1, n_orbitals
            write(unit=wfnfile.unit, fmt=mol_title_format) &
               "MO  ", i, &
               "OCC NO = ", .NO_occ_nos.r(i), &
               " ORB. ENERGY = ", .MO_energies.r(i)
            write(unit=wfnfile.unit, fmt=coefficient_format) dmatrix(:, i)
         end
       
         write(unit=wfnfile.unit, fmt="(1A8)") "END DATA"
         if (.scfdata.allocated) then
         write(unit=wfnfile.unit, fmt=e_v_format) .scfdata.energy, TWO
         else
         write(unit=wfnfile.unit, fmt=e_v_format) ZERO, TWO
         end
       
         ! Clean
         cc.destroy
         dmatrix.destroy

      end

      wfnfile.close
      wfnfile.destroy

   end

   write_aim2000_wfn_file ::: leaky
   ! Writes a proaim2000 .wfn file
      self :: IN

   ENSURE(.MO_energies.is_allocated_with_genre("r "), "No orbital energies")
   ENSURE(.MOs.is_allocated_with_genre("r "), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}@
      evec :: VEC{REAL}@
      dmatrix, cc :: MAT{REAL}@
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
      sh :: SHELL@
      occ :: REAL

      n_vars_format :: STR, parameter = "(A8, 10X, I5,' MOL ORBITALS', I7,' PRIMITIVES', I9,' NUCLEI')"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '  CHARGE =', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO  ', I3,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".wfn")
      wfnfile.open_for("write")

      if (IO_IS_ALLOWED) then
       
         if (mod(.n_e, 2)==0) then
            n_orbitals = .n_e / 2
         else
            n_orbitals = (.n_e + 1) / 2
         end
       
         write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
         write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
         write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
            .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
         write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)
       
         pcount = 1
         lvec.create(.n_prim)
         evec.create(.n_prim)

         do a = 1, .n_shell
           atomn  = .atom_for_shell(a)
           shelln = .atom_shell_for_shell(a)
           sh     = .atom(atomn).basis.shell(shelln)
           l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
           do j = 1, sh.n_cc
             if (sh.l==3) then
               lvec(pcount  ) = l + 1
               lvec(pcount+1) = l + 2
               lvec(pcount+2) = l + 3
               lvec(pcount+3) = l + 4
               lvec(pcount+4) = l + 5
               lvec(pcount+5) = l + 7
               lvec(pcount+6) = l + 6
               lvec(pcount+7) = l + 8
               lvec(pcount+8) = l + 9
               lvec(pcount+9) = l + 10
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 pcount = pcount + 1
               end
             else
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 lvec(pcount) = l + i
                 pcount = pcount + 1
               end
             end
           end
         end
       
         write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
         write(unit = wfnfile.unit, fmt = exponent_format) evec
       
         lvec.destroy
         evec.destroy
       
         dmatrix.create(.n_prim, .n_bf)
         cc.create(.n_prim, .n_bf)
       
         .:make_contraction_mx(cc)
       
         dmatrix.to_product_of(cc,.MOs.r)
       
         do i = 1, n_orbitals
            occ = ZERO
            if (i<=.n_a) occ = TWO
            write(unit=wfnfile.unit, fmt=mol_title_format) &
               i, occ, .MO_energies.r(i)
            write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
         end
       
         write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
         if (.scfdata.allocated) then
         write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
         else
         write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
         end
       
         ! Clean
         cc.destroy
         dmatrix.destroy
      end

      wfnfile.close
      wfnfile.destroy

   end

   write_florian_wfn_file(with_lambda)
   ! Writes a full wavefunction .ffn file
      self :: IN
      with_lambda :: BIN, optional, IN

   ENSURE(.MO_energies.is_allocated_with_genre("r "), "No orbital energies")
   ENSURE(.MOs.is_allocated_with_genre("r "), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}@
      evec :: VEC{REAL}@
      dmatrix, cc :: MAT{REAL}@
      sh :: SHELL@
      i, j, pcount, a, l, atomn, shelln :: INT
      occ :: REAL
      avec_lambda :: BIN

      n_vars_format :: STR, parameter = "(A8, 10X, I5,' MOL ORBITALS', I7,' PRIMITIVES', I9,' NUCLEI')"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '  CHARGE =', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO ', I4,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      if (avec_lambda) then
        wfnfile.create(trim(name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".ffn")
      else
        wfnfile.create(trim(name)//".ffn")
      end
      
      wfnfile.open_for("write")
      if (IO_IS_ALLOWED) then
         write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
         write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", .n_bf, .n_prim, .n_atom
         write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
            .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
         write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)

         pcount = 1
         lvec.create(.n_prim)
         evec.create(.n_prim)
         do a = 1, .n_shell
           atomn  = .atom_for_shell(a)
           shelln = .atom_shell_for_shell(a)
           sh     = .atom(atomn).basis.shell(shelln)
           l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
           do j = 1, sh.n_cc
             if (sh.l==3) then
               lvec(pcount  ) = l + 1
               lvec(pcount+1) = l + 2
               lvec(pcount+2) = l + 3
               lvec(pcount+3) = l + 4
               lvec(pcount+4) = l + 5
               lvec(pcount+5) = l + 7
               lvec(pcount+6) = l + 6
               lvec(pcount+7) = l + 8
               lvec(pcount+8) = l + 9
               lvec(pcount+9) = l + 10
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 pcount = pcount + 1
               end
             else
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 lvec(pcount) = l + i
                 pcount = pcount + 1
               end
             end
           end
         end
       
         write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
         write(unit = wfnfile.unit, fmt = exponent_format) evec
       
         lvec.destroy
         evec.destroy
       
         dmatrix.create(.n_prim, .n_bf)
         cc.create(.n_prim, .n_bf)
       
         .:make_contraction_mx(cc)
       
         dmatrix.to_product_of(cc,.MOs.r)
       
         do i = 1, .n_bf
            occ = ZERO
            if (i<=.n_a) occ = TWO
            write(unit=wfnfile.unit, fmt=mol_title_format) &
               i, occ, .MO_energies.r(i)
            write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
         end
       
         write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
         if (.scfdata.allocated) then
            write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
         else
            write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
         end
       
         ! Clean
         cc.destroy
         dmatrix.destroy
      end
      wfnfile.close
      wfnfile.destroy

   end

!	==================
!	= Write XYZ File =
!	==================

   write_xyz_file ::: leaky
   ! Prints out an asymmetric-unit xyz file.
   ! cartesian axes.
      self :: IN

      name :: STR
      xyzfile :: TEXTFILE*
      i :: INT

      atomnumber :: STR, parameter = "(I3)"
      comment :: STR, parameter = "(' written by tonto')"
      atom_format :: STR, parameter = "(A5, 3F12.6)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      xyzfile.create(trim(name)//".xyz")
      xyzfile.open_for("write")
      
      xyzfile.put(.n_atom)
      xyzfile.flush
      xyzfile.put(trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION)
      xyzfile.flush
      do i=1,.n_atom
          xyzfile.put(.atom(i).label)
          xyzfile.put(.atom(i).position(1)*ANGSTROM_PER_BOHR)
          xyzfile.put(.atom(i).position(2)*ANGSTROM_PER_BOHR)
          xyzfile.put(.atom(i).position(3)*ANGSTROM_PER_BOHR)
          xyzfile.flush
      end do
      
      ! Cleanup
      xyzfile.close
      xyzfile.destroy

   end

!  =====================================
!  Make molecule from atom or atom group
!  =====================================

   make_molecule_from_atom(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
   ! The new molecule is ready for an SCF calculation.
   ! DANGER: see warnings below
      self :: IN
      n :: INT, IN
      mol :: MOLECULE, OUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(n<=.n_atom,"atom number n too big")

      i,k :: INT

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom
      mol.atom = .atom(n:n)
      mol.atom(1).set_position([ZERO,ZERO,ZERO])

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.:set_defaults ! NOT PURE

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol
      mol.:resolve_bases_and_update_from(self)
      mol.:update_atom_info

      ! Don't remake ANO data if there
      i = 0
      mol.:resolve_ANOs_from(self,[(i,i=n,n)])

      ! Set guess-type SCF defaults
      mol.:set_SCF_guess_defaults_from(.scfdata)

      ! Set nondefault atomic default state
      if (.scfdata.initial_atomic_states.allocated) then
         k = .atom(n).kind
         mol.:set_charge(.scfdata.initial_atomic_states(k,1))
         mol.:set_spin_multiplicity(.scfdata.initial_atomic_states(k,2))
      end

   end

   make_molecule_from_atom_group(g,mol,set_name) ::: leaky
   ! Make a fully fledged molecule "mol" from group "g" of atoms
   ! specified in .atom_group(g).element(:), ready for an SCF
   ! calculation.
      self :: INOUT
      g    :: INT, IN
      mol  :: MOLECULE, OUT
      set_name :: BIN, optional, IN

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(g<=.atom_group.dim,"group number g too big")
   ENSURE(g>=1,"group number g less than 1!")

      name :: STR
      reset_name :: BIN

      reset_name = TRUE
      if (present(set_name)) reset_name = set_name

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom
      mol.atom = .atom(.atom_group(g).atom_index)

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.:set_defaults ! NOT PURE

      ! Reset .name after .set_defaults
      name = .atom_group(g).name
      if (reset_name) then
      if (name==" ") then
         name = "group-"//trim(g.to_str)//"-"
         name = trim(name)//trim(mol.atom.chemical_formula(with_spaces=FALSE))
         mol.:set_name(name)
         .atom_group(g).set_name(name)
      end
      end

      ! Set charge & multiplicity
      mol.charge            = .atom_group(g).charge
      mol.spin_multiplicity = mol.:default_spin_multiplicity

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol !
      mol.:resolve_bases_and_update_from(self)
      mol.:update_atom_info

      ! Don't remake ANO data if there
      mol.:resolve_ANOs_from(self,.atom_group(g).atom_index)

      ! Make atom info. No recursive groups. Yet?
      mol.atom_info_made = FALSE
      mol.:update_atom_and_basis_info(do_groups=FALSE) 

      ! Assign the crystal & gegenerate unit cell atoms
      if (.crystal.allocated) then
         mol.crystal = .crystal
         mol.crystal.update_fragment_info(mol.atom)
      end

      ! Set guess-type SCF defaults
      mol.:set_SCF_guess_defaults_from(.scfdata)

      ! Reset scf_kind for fraghar calculations
      if (.scfdata.allocated) then
      if (.scfdata.SCF_kind(1:8)=="fraghar-") then
         mol.scfdata.set_SCF_kind(.scfdata.SCF_kind(9:11))
      end
      end

      ! Set density matrix from parent?
      ! Restricted only. Do not clobber
      if (.density_mx.allocated) then
      if (.density_mx.r.allocated) then
      if (mol.density_mx.deallocated) then
         mol.density_mx.create(mol.n_bf,"r ")
         .:put_group_density_to(mol.density_mx.r,g,mol)
      end
      end
      end

   end


!  =====================
!  Ryde fragment capping
!  =====================

   make_Ryde_capped_groups ::: leaky
   ! Make Ulf Ryde's atom capped groups
   ! The strategy is to make them from the compound_sequence_id's
   ! which are found in an mmCIF, normally ....
      self :: INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atoms_bonded_to_atom.allocated,"no connection table")

      n_comp, g :: INT
      IDs :: VEC{INT}@

      if (NOT .crystal.use_Ryde_capping) return

      ! Assign connections ... NOT PURE
      VEC{ATOM}:assign_connection_table(.atoms_bonded_to_atom)

      n_comp = .atom.no_of_compounds

      if (.atom_group.deallocated) then
      
         ! Make groups from compound_id's
         .atom_group.create(n_comp)
         do g = 1,n_comp
            IDs = .atom(:).compound_sequence_id
            .atom_group(g).set_atom_index(IDs.indices_of_elements_matching(g))
            .atom_group(g).set_n_atoms(.atom_group(g).atom_index.dim)
         end

      end

      ! Check indices are sensible
      .atom_group.update(.atom)

      ! Destroy the group .mol s
      deallocate(.mol)
      allocate(.mol(.atom_group.dim))

      ! Make Ryde's molecular caps ... in .mol(g)
      do g = 1,.atom_group.dim
         self.:make_Ryde_cap_for_group(g)
      end

      ! Clear connections
      VEC{ATOM}:destroy_connection_table

   end

   make_NN_capped_groups ::: leaky
   ! Make atom capped groupsi for periodic network molecule.
      self :: INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atoms_bonded_to_atom.allocated,"no connection table")
   ENSURE(.crystal.allocated, "no crystal info")

      name,label :: STR
      n_comp,nc_atoms,a :: INT

      n_comp = .crystal.n_asymmetric_unit_atoms 

      if (.atom_group.deallocated) then
      
         ! Make groups from asym atoms
         .atom_group.create(n_comp)
         allocate(.mol(n_comp))
         
         do a = 1,n_comp

            ! Make cap atoms
            .cluster.make_asym_occupation_list(a)
            .cluster.do_NN_defragment(.cluster.occupation_list,1,nc_atoms)
            .cluster.create_atom_list(.mol(a).atom) 
            .atom_group(a).set_atom_index( [ a ] )
            .atom_group(a).set_n_atoms(.cluster.n_atoms)
            .mol(a).atom(2:).set_is_cap_atom(TRUE)

            ! Correct label & atomic number for last added atom
            ! WARNING: AN has to be set after setting unique label
            label = "H-cap"
            ATOM:set_label(.mol(a).atom(nc_atoms+1:),label,skip_mass=TRUE)
            ATOM:set_atomic_number_and_mass(.mol(a).atom(nc_atoms+1:),"H ")
            
            ! Set charge
            .mol(a).:set_charge(.atom_group(a).charge)

            ! Make atom info; groups should not contain subgroups!
            .mol(a).atom_info_made = FALSE
            .mol(a).atom.set_group_to(a)
            .mol(a).:update_atom_and_basis_info(do_groups=FALSE) ! no recursion

            ! Reset multiplicity? NOTE: reset no. of alpha & beta electrons
            if (.atom_group(a).spin_multiplicity_set) then
               .mol(a).:set_spin_multiplicity(.atom_group(a).spin_multiplicity)
            end

            ! Set guess-type SCF defaults: no output
            ! Will reset scf_kind based on multiplicity
            .mol(a).:set_SCF_guess_defaults_from(.scfdata)

            ! Set .name
            name = "group-"//trim(a.to_str)//"-"
            name = trim(name)//trim(.mol(a).atom.chemical_formula(with_spaces=FALSE))
            .mol(a).:set_name(name)
            .atom_group(a).set_name(name)

            ! Assign basis set -- don't destroy!
            .mol(a).:set_basis_name(.basis_name) ! NOT PURE

            ! Copy the crystal -- destroy it!
            ! Make separate asymm unit with only mol in it later ...
            ! mol.crystal = .crystal
            ! mol.crystal.update_fragment_info(mol.atom)
               
            ! Don't remake ANO data if there
            .mol(a).:resolve_ANOs_from(self)
         end
      end

   end

   make_Ryde_cap_for_group(g) ::: leaky
   ! Make a capped fragment for molecule "mol, the atom_group(g).mol
   ! with compound_sequence_id "g", ready for fragHAR calculation.
   ! *This routine will add extra atoms*.
      self :: INOUT
      g :: INT, IN

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(g<=.atom_group.dim,"group number g too big")
   ENSURE(g>=1,"group number g less than 1!")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")

      name :: STR
      
      ! Start with *uncapped* .atom_group(g) atom indices ...
      .mol(g).atom = .atom(.atom_group(g).atom_index)

      ! Add cap atoms !!!!!!!!!!!!!!!
      .:add_Ryde_cap_for_group(g,.mol(g))
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      ! Set charge
      .mol(g).:set_charge(.atom_group(g).charge)

      ! Make atom info; groups should not contain subgroups!
      .mol(g).atom_info_made = FALSE
      .mol(g).atom.set_group_to(g)
      .mol(g).:update_atom_and_basis_info(do_groups=FALSE) ! no recursion

      ! Reset multiplicity? NOTE: reset no. of alpha & beta electrons
      if (.atom_group(g).spin_multiplicity_set) then
         .mol(g).:set_spin_multiplicity(.atom_group(g).spin_multiplicity)
      end

      ! Set guess-type SCF defaults: no output
      ! Will reset scf_kind based on multiplicity
      .mol(g).:set_SCF_guess_defaults_from(.scfdata)

      ! Set .name
      name = .atom(.atom_group(g).atom_index(1)).id_compound_str
      if (name==" ") then
         name = "group-"//trim(g.to_str)//"-"
         name = trim(name)//trim(.mol(g).atom.chemical_formula(with_spaces=FALSE))
      end
      .mol(g).:set_name(name)
      .atom_group(g).set_name(name)

      ! Assign basis set -- don't destroy!
      .mol(g).:set_basis_name(.basis_name) ! NOT PURE

      ! Copy the crystal -- destroy it!
      ! Make separate asymm unit with only mol in it later ...
      if (.crystal.allocated) then
         .mol(g).crystal = .crystal
         .mol(g).crystal.update_fragment_info(.mol(g).atom)
      end
      
      ! Don't remake ANO data if there
      .mol(g).:resolve_ANOs_from(self)

   end

   add_Ryde_cap_for_group(g,mol) ::: private, leaky, PURE
   ! Add Ryde' caps fragment for molecule the atom_group(g).mol with
   ! compound_sequence_id "g".
      self :: INOUT
      g :: INT, IN
      mol :: MOLECULE, INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(g<=.atom_group.dim,"group number g too big")
   ENSURE(g>=1,"group number g less than 1!")

      in_residue :: BIN
      bonded_atom :: MAT{INT}@
      n_bonds, g2,b,ap,bp :: INT

      ! Residue atom?
      in_residue = .atom(.atom_group(g).atom_index(1)).is_in_a_residue

      if (NOT in_residue) return

      do g2 = 1,.atom_group.dim
      
         ! Skip group "g" itself
         if (g2==g) cycle
      
         ! No. of bonds to atom_group "g2"
         n_bonds = .:n_bonds_between_atom_groups(g,g2)
      
         ! Any bonds to group "g2"?
         if (n_bonds<=0) cycle
      
         ! Cap each connected group
         bonded_atom = .:bonded_atoms_between_groups(g,g2)
      
         do b = 1,n_bonds
      
            ! Get atoms from each group
            ap = bonded_atom(1,b)
            bp = bonded_atom(2,b)
      
            ! Use them to start the Ryde cap
            .:add_Ryde_cap_from_atoms(ap,bp,mol)

         end
      
         ! Clean
         bonded_atom.destroy
      
      end
 
   end

   add_Ryde_cap_from_atoms(ap,bp,mol) ::: private, leaky, PURE
   ! Cap residue molecule "mol" starting from atom "ap" in that
   ! residue, which is connected to atom "bp" in another group.
   ! WARNING: This will add extra atoms to atom_group(g1).mol.atom 
   ! but it won't add extra indices into atom_index!
   ! Zhang, D. W. & Zhang, J. Z. H. (2003). J. Chem. Phys., 119(7), 3599-3605.
   ! Soederhjelm, P.& Ryde, U. (2008). J. Phys. Chem. A, 113(3), 617-627
      self :: INOUT
      ap,bp :: INT, IN
      mol :: MOLECULE, INOUT

   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.atoms_bonded_to_atom.allocated,"no connection table")

      i,j, cp,cf,dp,last :: INT
      bp_bonds,cp_bonds :: VEC{INT}@
      length :: REAL
      label :: STR

      ! Append connected atom bp in atom_group(g2)
      mol.atom.append(.atom(bp))
      last = mol.atom.dim
      mol.atom(last).set_cap_atom(TRUE)

      ! Find connections to atom bp ... in SMILES:
      ! -ap-res1 - bp-res2(cp_1-res2)(cp_2-res2) ...
      bp_bonds = .atoms_bonded_to_atom(bp).element

      ! Find connections to bp
      do i = 1,bp_bonds.dim

         ! This case cap atom 2
         cp = bp_bonds(i) 

         ! Already found atom in residue g
         if (cp==ap) cycle 

         ! Append new cap atom 2
         mol.atom.append(.atom(cp))
         last = mol.atom.dim
         mol.atom(last).set_cap_atom(TRUE)

         if (.atom(ap).atomic_number>1) then

            ! Add caps for all non-H atom ... should be 3
            ! (serging for cap atom 3)
            cp_bonds = .atoms_bonded_to_atom(cp).element

            ! Index of cp in atom_group(g) fragment
            cf = last

            ! Find connections to cp
            do j = 1,cp_bonds.dim

               dp = cp_bonds(j)

               ! Already found atom bp
               if (dp==bp) cycle 

               ! Append new cap atom, keep its index
               mol.atom.append(.atom(dp))
               last = mol.atom.dim
               mol.atom(last).set_cap_atom(TRUE)

               ! Correct label & atomic number for last added atom
               ! WARNING: AN has to be set after setting unique label
               label = "H-" // trim(.atom(dp).atom_sequence_id.to_str) // "-"
               label = trim(label) // trim(.atom(dp).compound_id_str)
               mol.atom(last).set_label(label,skip_mass=TRUE)
               mol.atom(last).set_atomic_number_and_mass("H ")
               mol.atom(last).set_cap_atom(TRUE)

               ! Reset bond length to last added atom
               length = CIF_CH_BOND_LENGTH*BOHR_PER_ANGSTROM
               mol.atom.set_bond_length(cf,last,length)

            end

         end

      end

   end

   n_bonds_between_atom_groups(g1,g2) result (res) ::: pure
   ! Return the number of connections between ".atom_group(g1)" and
   ! ".atom_group(g2)". 
      self :: IN
      g1,g2 :: INT, IN
      res :: INT

      i,j,a,b :: INT
      bonded :: BIN

      res = 0
      residue1: do i = 1,.atom_group(g1).atom_index.dim
         a = .atom_group(g1).atom_index(i)
         residue2: do j = 1,.atom_group(g2).atom_index.dim
            b = .atom_group(g2).atom_index(j)
            bonded = VEC{ATOM}:has_a_connection(a,b)
            if (bonded) then
               res = res + 1
            end
         end do residue2
      end do residue1

   end

   bonded_atoms_between_groups(g1,g2) result (res) ::: pure
   ! Return the number of connections between ".atom_group(g1)" and
   ! ".atom_group(g2)" in a table "res(1:2,n_bonds)". 
      self :: IN
      g1,g2 :: INT, IN
      res :: MAT{INT}(2,.:n_bonds_between_atom_groups(g1,g2))

      n :: INT
      i,j :: INT
      a,b :: INT
      bonded :: BIN

      n = 0
      residue1: do i = 1,.atom_group(g1).atom_index.dim
         a = .atom_group(g1).atom_index(i)
         residue2: do j = 1,.atom_group(g2).atom_index.dim
            b = .atom_group(g2).atom_index(j)
            ! Are a & b bonded?
            bonded = VEC{ATOM}:has_a_connection(a,b)
            ! Store pair of bonded atoms
            if (bonded) then
               n = n + 1
               res(1,n) = a
               res(2,n) = b
            end
         end do residue2
      end do residue1

   end

!  ===============
!  Atom group info
!  ===============

   update_atom_groups ::: leaky
   ! Update the .atom_group information
      self :: INOUT

      if (.atom.deallocated) then
         ! Make .atom()'s and .atom_group().mol's from files
         if (.atom_group.has_wavefunction_files) then
            .:make_groups_from_wfn_files
         end
      else if (.atom.has_cartesian_axes) then
         ! We have .atom()'s ...
         if (.crystal.use_Ryde_capping) then
            ! Ulf Ryde's capped residues
            ! WARNING: .atom_groups list only (parent) uncapped atoms
            .:make_Ryde_capped_groups ! NOT PURE
         else if (.atom_group.has_atom_indices) then
            ! User set atom_indices for each atom_group 
            .:make_atom_group_mols    ! NOT PURE
         else 
            ! Make .atom_group's from connection table
            .:make_connected_atom_groups
            .:make_atom_group_mols
         end
      end

   end

   make_connected_atom_groups ::: leaky, PURE
   ! Make .atom_group's from the connection table.
      self :: INOUT

      n_group,g :: INT

      ! Set group indices, if possible
      .atom.set_connected_groups
      if (.atom.has_groups) then

         ! Each .atom() had a .group index
         n_group = .atom.no_of_groups
         if (.atom_group.deallocated) then
            .atom_group.create(n_group)
         else
            ENSURE(n_group==.atom_group.dim,"inconsistent .atom_group size")
         end
      
         ! Make groups from group index
         do g = 1,.atom_group.dim
            .atom_group(g).set_atom_index(.atom(:).group.indices_of_elements_matching(g))
            .atom_group(g).set_n_atoms(.atom_group(g).atom_index.dim)
         end
      
         ! Set charges
         if (.atom_group_charges.allocated) then
            ENSURE(.atom_group_charges.dim==.atom_group.dim,"Wrong size, .atom_group_charges")
            do g = 1,.atom_group.dim
               .atom_group(g).set_charge(.atom_group_charges(g))
            end
         end

      end

   end

   make_atom_group_mols ::: private, leaky
   ! Make the ".atom_group.mol" molecules
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms!")

      g :: INT

      if (.atom_group.deallocated) return

      ! Regenerate molecules
      if (allocated(.mol)) deallocate(.mol)
      allocate(.mol(.atom_group.dim))

      ! Check is indices are sensible
      .atom_group.update(.atom)
      
      ! Create each group from "self"
      do g = 1,.atom_group.dim
      
         ! Create mol & define it
         ! ... including mol.crystal part
         self.:make_molecule_from_atom_group(g,.mol(g)) ! NOT PURE
      
         ! Read the MOs & make the density
         ! This won't work until Tonto can read in its own dump
         if (.atom_group(g).MO_file_name/=" ") then
             .mol(g).:read_archive("MOs","r ")
             .mol(g).:make_SCF_density_mx
         end
      
         ! Rotate and translate mol
         if (.atom_group(g).transform_group) then
            .mol(g).:rotate_by(.atom_group(g).rotation_mx)
            .mol(g).atom.translate_by(.atom_group(g).shift)
         end
         .mol(g).atom.set_group_to(g)
         .mol(g).name = .atom_group(g).name
      
      end

      ! Update atom_group info from self
      ! ANOs done above already.
      .:update_atom_group_info(skip_ANOs=TRUE)

   end

! How is below different from update_atom_groups?
! It should have a better name ...

   update_atom_group_info(skip_ANOs) ::: leaky
   ! Update .atom_group information (ANOs, crystal, SCF guess ...)
   ! WARNING: atom_group(:).mol.crystal's are clones of .crystal
      self :: INOUT
      skip_ANOs :: BIN, IN, optional

   ENSURE(.atom.allocated,"atom groups must be defined after atoms=")
   ENSURE(.atom_group.allocated,"no atom_group")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")

      g :: INT

      ! Below sounds not good?
      if (.scfdata.deallocated) then
         .:set_SCF_defaults ! NOT PURE
         .scfdata.set_output(FALSE)
      end

      do g = 1,.atom_group.dim

         ! Don't remake ANO data if there
         if (present(skip_ANOs)) then
         if (NOT skip_ANOs) then
            .mol(g).:resolve_ANOs_from(self,.atom_group(g).atom_index)
         end
         end

         ! Assign the crystal & gegenerate unit cell atoms
         if (.crystal.allocated) then
            .mol(g).crystal = .crystal ! Should be minimal copy?
            .mol(g).crystal.update_fragment_info(.mol(g).atom)
         end

         ! Set guess-type SCF defaults
         ! Don't know why this makes 4AP fail ... commented out
       ! if (NOT .atom_group(g).spin_multiplicity_set) then 
       !    .atom_group(g).mol.:set_SCF_guess_defaults_from(.scfdata)
       ! end

      end

   end

! WFN file stuff

   create_from_mols(mol_A, mol_B) ::: leaky
   ! Create a molecule by merging "mol_A" and "mol_B"
      self  :: allocatable, OUT
      mol_A :: MOLECULE, target, INOUT
      mol_B :: MOLECULE, target, INOUT

      i, n_A, n_B :: INT

      .:create
      .:set_defaults ! NOT PURE

      allocate(.mol(2))

      ! Is this necessary
      mol_A.:make_SCF_density_mx
      mol_B.:make_SCF_density_mx

      n_A = mol_A.atom.dim
      n_B = mol_B.atom.dim

      .atom = mol_A.atom
      .atom.append(mol_B.atom)
      .atom_group.create(2)
      .atom_group(1).set_atom(mol_A.atom)
      .atom_group(1).atom_index = [ (i, i=1,n_A) ]
      .mol(1) = mol_A

      .atom_group(2).set_atom(mol_B.atom)
      .atom_group(2).atom_index = [ (i, i=n_A+1,n_A+n_B) ]
      .mol(2) = mol_B

      .:join_atom_groups

      .:update_atom_group_info

   end

   read_wfn_file(filename,do_groups) ::: leaky
   ! Open and read a file named "name", either a gaussian .FChk file
   ! or an .sbf file.
      self :: INOUT
      filename :: STR, IN
      do_groups :: BIN, optional, IN

      if (filename.ends_in("fchk", case_sensitive=FALSE)) then
         .:read_g09_FChk_file(filename,do_groups)
      else if (filename.ends_in("sbf", case_sensitive=FALSE)) then
         .:deserialize(filename,do_groups)
      else if (filename.ends_in("molden", case_sensitive=FALSE)) then
         .:read_molden_MOs(filename,do_groups)
      else
         DIE("unknown file format for file '"//trim(filename)//"'")
      end

   end

   make_groups_from_wfn_files ::: private, leaky
   ! Make the atom groups by read in Gaussian Fchk files in they are defined for the groups
      self :: INOUT

   DIE_IF(.atom.allocated,"atoms already exists!")
   DIE_IF(.atom_group.deallocated,"no atom groups")
   DIE_IF(NOT .atom_group.has_wavefunction_files,"no wavefunction files")

      wavefunction_file :: STR
      g :: INT

      allocate(.mol(.atom_group.dim))

      do g = 1,.atom_group.dim

         ! Define mol from FChk or sbf file
         wavefunction_file = .atom_group(g).wavefunction_file_name
         .mol(g).:read_wfn_file(wavefunction_file,do_groups=FALSE)

         ! Set kind of SCF
         ! ... this seems always to be UHF?
         if (.mol(g).scfdata.is_unrestricted) then
            if(.scfdata.deallocated) then
               .scfdata.create
               .scfdata.set_defaults
            end
            .scfdata.set_SCF_kind("uhf")
         end

         ! Rotate and translate it
         .mol(g).:rotate_by(.atom_group(g).rotation_mx)
         .mol(g).atom.translate_by(.atom_group(g).shift)
         .mol(g).atom.set_group_to(g)

      end

      ! Define .atom list
      .:join_atom_groups

      ! Update group info from self
      .:update_atom_group_info

   end

   join_atom_groups ::: leaky, private
   ! Delete any existing .atom and .basis and set to the concatenation
   ! of the molecules in .atom_group
      self :: target, INOUT

   ENSURE(.atom_group.allocated,"no .atom_group")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")

      g, charge, unpaired_electrons :: INT

      if (.atom.allocated)  .atom.destroy
      if (.basis.allocated) .basis.destroy

      charge = 0
      unpaired_electrons = 0

      ! Append remaining ...
      do g = 1,.atom_group.dim

         DIE_IF(.mol(g).basis.deallocated,"no basis on mol "//trim(g.to_str))
         DIE_IF(.mol(g).atom.deallocated, "no atoms in mol "//trim(g.to_str))

         charge = charge + .mol(g).charge
         unpaired_electrons = unpaired_electrons + .mol(g).spin_multiplicity - 1 

         if (g==1) then

            ! Initial atom/basis list
            .name  = .atom_group(g).name
            .basis = .mol(g).basis
            .atom  = .mol(g).atom

         else

            ! Append basis & atoms
            .name = trim(.name) // "_" // trim(.atom_group(g).name)
            .basis.append(.mol(g).basis)
            .atom.append(.mol(g).atom)

         end

      end

      ! Unresolve atomic bases
      .atom.destroy_bases

      ! Uniquify basis
      .basis.remove_repetitions

      ! Finally: set atom info & basis info (leaky)
      .:set_charge(charge)
      .:set_spin_multiplicity(unpaired_electrons + 1)

      ! Finalise atom info
      .:update_atom_and_basis_info(do_groups=FALSE)

   end

!  =================
!  VEC{ATOM} methods
!  =================

   default_spin_multiplicity result (res) ::: PURE
   ! Return the default multiplicity for a molecule.
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,"no atom info")

      n_e :: INT

      n_e = .:no_of_electrons
      if (.atom.dim==1) then
         ! One atom
         if (.atom(1).atomic_number==-1) then
            res = 2 ! This is an El electron
         else
            res = .atom(1).ground_state_multiplicity(n_e)
         end
      else
         ! Singlet or doublet
         res = mod(n_e,2) + 1
      end

   end

   nuclear_repulsion_energy result (res) ::: PURE
   ! Return the nuclear repulsion energy
      self :: IN
      res :: REAL

   ENSURE(.atom.allocated,"atom list required")

      i :: INT
      scf_kind :: STR

      scf_kind = "unknown"
      if (.scfdata.allocated) scf_kind = .scfdata.SCF_kind

      i = 0
      res = ZERO
      select case (scf_kind)
      case ("embedded_rhf"); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
      case ("crystal_rhf "); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
      case default;          res = .atom.nuclear_repulsion_energy
      end

   end

!  ============================
!  Axis change and origin shift
!  ============================

!   change_to_principal_axes ::: PURE
!   ! Move the origin to the center of mass and change to the principal axis
!   ! coordinate system
!      self :: INOUT
!
!   ENSURE(.atom.allocated,"atom list required")
!
!      .atom.change_to_principal_axes
!
!   end

!   change_to_principal_top_axes ::: PURE
!   ! Move the origin to the center of mass and change to the principal axis
!   ! coordinate system, where the symmetric top axis is the z axis and where the
!   ! determinant of the axes transformation is 1.
!      self :: INOUT
!
!   ENSURE(.atom.allocated,"atom list required")
!
!      .atom.change_to_principal_top_axes
!
!   end

   move_origin_to_center_of_mass
   ! Move the origin to the center of mass
      self :: INOUT

   ENSURE(.atom.allocated,"atom list required")

      .atom.move_origin_to_center_of_mass

      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom) ! NOT PURE
         .becke_grid.set_grid_data
      end

   end

   move_origin_to_center_of_atoms
   ! Move the origin to the center of atoms
      self :: INOUT

   ENSURE(.atom.allocated,"atom list required")

      .atom.move_origin_to_center_of_atoms

      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom) ! NOT PURE
         .becke_grid.set_grid_data
      end

   end

   move_origin 
   ! Move the origin by a user specified vector
      self :: INOUT

   ENSURE(.atom.allocated,"atom list required")
   ENSURE(stdin.buffer.n_items==4 OR stdin.buffer.n_items==5,"origin shift needed on same line")

      shift :: VEC{REAL}(3)

      stdin.read_quantity(shift)
      .atom.translate_by(shift)

      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom) ! NOT PURE
         .becke_grid.set_grid_data
      end

   end

!  ===============
!  Inquiry methods
!  ===============

   has_all_NAO_matrices result (res) ::: PURE
   ! Return TRUE if the NAOs are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated
      if (res) res = .atom.has_all_NAO_matrices

   end

   has_all_ANO_matrices result (res) ::: PURE
   ! Return TRUE if the ANO data is made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_ANO_matrices

   end

   has_all_interpolators result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_interpolators

   end

   has_all_atom_data result (res) ::: PURE
   ! Return TRUE if all the atom ANOs and interpolators are made for
   ! every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_atom_data

   end

   has_all_shell_info result (res) ::: PURE
   ! Return TRUE if the per-atom interpolators are made for every atom.
      self :: IN
      res :: BIN

      res = .atom.allocated

      if (res) res = .atom.has_all_shell_info

   end


   no_of_electrons result (res) ::: PURE
   ! Work out and return the number of electrons in the molecule.
   ! NOTE: removed the core electrons, if any.
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,  "no atom list")

      res = .atom.no_of_electrons &
          - .charge &
          - sum(.atom(:).n_core_electrons)

   end

   no_of_alpha_electrons result (res) ::: PURE
   ! Work out and return the number of alpha electrons in the molecule.
      self :: IN
      res :: INT

      res = .:no_of_electrons - .:no_of_beta_electrons

   end

   no_of_beta_electrons result (res) ::: PURE
   ! Work out and return the number of beta electrons in the molecule.
   ! Normally the number of beta electrons is smaller than alpha, but
   ! if the atom list is a single explicit (alpha) "El" electron it is
   ! assumed that there is one beta electron surrounding it. This is
   ! to ensure a good initial guess for promolecule SCF guess.
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,  "no atom list")

      tmp :: INT

      if (.atom.dim==1 AND .atom(1)%tag(1:2)=="El") then

         res = 1 ! Assume one beta electron surrounds the "El"

      else

         tmp = .:no_of_electrons - .:no_of_unpaired_electrons
         res = tmp/2
         ENSURE(tmp.is_even,"Inconsistent multiplicity, non integer # of beta electrons")

      end

   end

   has_valid_no_of_beta_electrons result (res) ::: PURE
   ! Return TRUE if the number of beta electrons is valid based on the
   ! assigned charge and multiplicity i.e. it must come out integral
   ! *except* in the case when the atom list is a single explicit
   ! (alpha) "El" electron - in which case there must be one beta
   ! electron. See above.
      self :: IN
      res :: BIN

   ENSURE(.atom.allocated,  "no atom list")

      tmp :: INT

      if (.atom.dim==1 AND .atom(1).tag(1:2)=="El") then

         tmp = .:no_of_electrons
         res = tmp==1 ! must have one beta electron

      else

         tmp = .:no_of_electrons - .:no_of_unpaired_electrons
         res = tmp.is_even

      end

   end

   no_of_unpaired_electrons result (res) ::: PURE
   ! Work out and return the number of unpaired electrons in the molecule
      self :: IN
      res :: INT

      res = .spin_multiplicity - 1

      ENSURE(res<=.:no_of_electrons,"Wrong multiplicity, not enough electrons")

   end


   no_of_atom_pairs result (res) ::: PURE
   ! Return the number of atom pairs in the molecule
      self :: IN
      res :: INT

   ENSURE(.atom.allocated,"no atom list")

      res = .n_atom*(.n_atom+1)/2

   end


   no_of_occupied_NOs(genre,tol) result (res) ::: PURE
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      genre :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT

   ENSURE(.NO_occ_nos.allocated,"no occupation numbers")

      res = .NO_occ_nos.no_of_occupied(genre,tol)

   end


   DFT_grid_info_made result (res) ::: PURE
   ! Return TRUE if the DFT grid information is made
      self :: IN
      res :: BIN

      res = .becke_grid.allocated  &
          AND .overlapping_atoms.allocated &
          AND .overlapping_atoms_for_atom.allocated

   end

   has_Hirshfeld_inputs result (res) ::: PURE
   ! Return TRUE if the inputs for a Hirshfeld calc are there
      self :: IN
      res :: BIN

      res =  .:DFT_grid_info_made &
         AND .:has_all_ANO_matrices &
         AND ( .:has_all_interpolators OR .:has_all_atom_data )

   end


   guess_SCF_method result (res) ::: PURE
   ! Guess the scf method in use.
      self :: IN
      res :: STR
      res = "?"
      if      (.scfdata.allocated) then;            res = .scfdata.SCF_kind
      else if (.MOs.allocated) then; res = .MOs.guess_SCF_kind
    ! else;                                       DIE("no way to  guess!")
      end
   end

!  =================
!  Overlapping atoms
!  =================

   is_overlapping_atom(a,b) result (res) ::: PURE
   ! Return TRUE if atoms "a" and "b" overlap.
      self :: IN
      a,b :: INT, IN
      res :: BIN

   ENSURE(.overlapping_atoms.allocated,"no .overlapping_atoms")

      aa,bb,ab :: INT

      if (a==b) then
         res = TRUE
      else
         aa = max(a,b)
         bb = min(a,b)
         ab = int(HALF*aa*(aa-1)) + bb
         res = .overlapping_atoms(ab)
      end

   end

   is_overlapping_atom(a,list) result (res) ::: PURE
   ! Return TRUE if atom "a" overlaps with *any* atoms in the "list".
      self :: IN
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: BIN

   ENSURE(.overlapping_atoms.allocated,"no .overlapping_atoms")

      i,b,aa,bb,ab :: INT

      res = FALSE

      do i = 1,list.dim

         b = list(i)

         if (a==b) then
            res = TRUE
            exit
         else
            aa = max(a,b)
            bb = min(a,b)
            ab = int(HALF*aa*(aa-1)) + bb
            if (.overlapping_atoms(ab)) then
               res = TRUE
               exit
            end
         end

      end

   end

   overlapping_atoms_for(list) result (res) ::: leaky, PURE
   ! Return the list of atoms which overlaps with those in "list".
      self :: IN
      list :: VEC{INT}, IN
      res :: VEC{INT}@

      a,k :: INT

      res.create(.n_atom)

      k = 0
      do a = 1,.n_atom
         if (NOT .:is_overlapping_atom(a,list)) cycle
         k = k + 1
         res(k) = a
      end

      res.shrink(k)

   end

   make_max_S_for_shell_pairs(max_S) ::: PURE
   ! Make "max_S", the maximum of the overlap integrals between basis
   ! functions in pairs of shells.
      self :: IN
      max_S :: VEC{REAL}, OUT

   ENSURE(.overlap_mx.allocated,"no overlap_mx")
   ENSURE(max_S.dim==.n_shell_pairs,"wrong size, S_max")

      ab,a,b,fa,fb,la,lb :: INT

      do ab = 1,.n_shell_pairs

         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2

         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)

         max_S(ab) = maxval(abs(.overlap_mx(fa:la,fb:lb)))

      end

   end

! Below does not work ... but it does with lower cutoff

   make_overlapping_atoms ::: leaky, PURE
   ! Make the list of overlapping atoms
      self :: INOUT

   ENSURE(.becke_grid.allocated,"no becke_grid")

      r_max :: VEC{REAL}@
      d :: VEC{REAL}(3)
      r :: REAL
      a,b,ab,n_atom_pairs :: INT

      n_atom_pairs = .:no_of_atom_pairs

      ! Overlapping atoms pair array
      .overlapping_atoms.destroy
      .overlapping_atoms.create(n_atom_pairs)

      ! Overlapping atoms list array
      .overlapping_atoms_for_atom.destroy
      .overlapping_atoms_for_atom.create(.n_atom)

      ! Make the maximum radii
      r_max.create(.n_atom)
      do a = 1,.n_atom
         ! sqrt because we are dealing with overlaps
         r_max(a) = .atom(a).r_max(.becke_grid.basis_function_cutoff)
      end

      ! Make the overlapping atom arrays
      do ab = 1,n_atom_pairs
         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2
         d = .atom(a).position - .atom(b).position
         r = sqrt(dot_product(d,d))
         if (r>(r_max(a)+r_max(b))) then
            .overlapping_atoms(ab) = FALSE
         else
            .overlapping_atoms(ab) = TRUE
         end
      end

      ! Make the overlapping atom arrays
      do a = 1,.n_atom

         ! Atom a overlaps itself
         .overlapping_atoms_for_atom(a).element.append(a)

         ! Loop over other atoms "b"
         do b = 1,a-1

            ! Distance "r" to atom "b"
            d = .atom(a).position - .atom(b).position
            r = sqrt(dot_product(d,d))
            if (r>(r_max(a)+r_max(b))) cycle

            ! Atoms "a" and "b" overlap
            .overlapping_atoms_for_atom(a).element.append(b)
            .overlapping_atoms_for_atom(b).element.append(a)

         end

      end

      r_max.destroy

      ! Reorder the lists
      do a = 1,.n_atom
         .overlapping_atoms_for_atom(a).element.sort
      end

   end

!  ================
!  Atom connections
!  ================

   make_atom_connections ::: leaky, PURE
   ! Make the list of bonded atoms
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")

      .atom.make_connection_table(.atoms_bonded_to_atom)

   end

   connected(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are connected
      self :: IN
      a,b :: INT, IN
      res :: BIN
      
      if (a <= .atoms_bonded_to_atom.dim1) then
         res = any(b==.atoms_bonded_to_atom(a).element(:))
      else
         res = FALSE
      end if

   end
  
   connected_or_identical(a,b) result (res) ::: pure
   ! Return true if atoms "a" and "b" are connected
   ! or if they are the same atom
      self :: IN
      a,b :: INT, IN
      res :: BIN
     
      if (a == b) then 
         res = TRUE
      else if (a <= .atoms_bonded_to_atom.dim1) then
         res = any(b==.atoms_bonded_to_atom(a).element(:))
      else
         res = FALSE
      end if

   end

!  =================
!  Atom pair indices
!  =================

   get_atom_pair_indices_from(index,a,b,fa,la,na,fb,lb,nb) ::: PURE
   ! Return the atom indicies "a" and "b" which map to an atom-pair
   ! "index".  Also get "fa", "la" and "fb", "lb", the indices of
   ! first and last basis functions for atoms "a" and "b", and "na"
   ! and "nb", the number of basis functions on those atoms,
   ! respectively. NOTE: "fa" and "fb" are actually the first basis
   ! functions for atoms "a" and "b" *minus 1*.
      self :: IN
      index :: INT, IN
      a,b   :: INT, OUT
      fa,la,na :: INT, OUT
      fb,lb,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_atom(a) - 1
      la =  .last_basis_fn_for_atom(a)
      na = la - fa

      fb = .first_basis_fn_for_atom(b) - 1
      lb =  .last_basis_fn_for_atom(b)
      nb = lb - fb

   end

!  ==================================
!  VEC{ATOM} shell extraction methods
!  ==================================

! The set routines should be quicker, but I'm not sure.
! When allocatable components are used it may be easier
! to allocate an entire basis set array once and for all.

   set_shell_from(index,shell) ::: leaky, PURE
   ! Set basis set "shell" (SHELL) corresponding to "index"
      self :: IN
      index :: INT, IN
      shell :: SHELL, OUT

      aa,sa :: INT

      aa    = .atom_for_shell(index)
      sa    = .atom_shell_for_shell(index)
      shell = .atom(aa).basis.shell(sa)

   end

   set_shell1_from(index,shell) ::: leaky, PURE
   ! Get basis set "shell" (SHELL1) corresponding to "index"
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.set(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   set_shell1_from(index,shell,fa,la) ::: leaky, PURE
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la".
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)

      shell.set(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   set_shell1_from(index,shell,fa,la,na) ::: leaky, PURE
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la", and "na" the no. of bf's in the shell.
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la,na :: INT, OUT

      .:set_shell1_from(index,shell,fa,la)
      na = la - fa + 1

   end

!  ==================
!  Shell pair indices
!  ==================

   set_shell2_indices_from(index,a,b,fa,la,na,fb,lb,nb) ::: pure
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      self :: IN
      index :: INT, IN
      a,b      :: INT, OUT
      fa,la,na :: INT, OUT
      fb,lb,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la =  .last_basis_fn_for_shell(a)
      lb =  .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

   end

   set_shell2_indices_from(index,a,b,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: pure
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
   ! Also return the atom indices "atom_a" and "atom_b" for each shell.
      self :: IN
      index :: INT, IN
      a,b      :: INT, OUT
      fa,la,na :: INT, OUT
      fb,lb,nb :: INT, OUT
      atom_a,atom_b :: INT, OUT

      .:set_shell2_indices_from(index,a,b,fa,la,na,fb,lb,nb)

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

   end

!  =======================
!  Precomputed shell pairs
!  =======================

   set_shell2_from(index,sh2) ::: leaky, PURE
   ! Get SHELL2 "sh2" correponding to the pair index "index".
      self  :: IN
      index :: INT, IN
      sh2   :: SHELL2, OUT

      a,b,aa,sa,bb,sb :: INT
      pa,pb :: VEC{REAL}(3)

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      pa = .atom(aa).position
      pb = .atom(bb).position

      sh2.set_and_precompute_from(.basis_shell1pair(sa,sb),pa,pb,aa==bb,skip=FALSE)

   end

   set_shell2_from(index,sh2,fa,la,na,fb,lb,nb) ::: leaky, PURE
   ! Get the SHELL2 object "sh2" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      self  :: IN
      index :: INT, IN
      sh2   :: SHELL2, OUT
      fa,la,na :: INT, OUT
      fb,lb,nb :: INT, OUT

      a,b,aa,sa,bb,sb :: INT
      pa,pb :: VEC{REAL}(3)

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la =  .last_basis_fn_for_shell(a)
      lb =  .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      pa = .atom(aa).position
      pb = .atom(bb).position

      sh2.set_and_precompute_from(.basis_shell1pair(sa,sb),pa,pb,aa==bb,skip=FALSE)

   end

   set_shell2_from(index,sh2,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: leaky, PURE
   ! Get the SHELL2 object "sh2" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      self  :: IN
      index :: INT, IN
      sh2   :: SHELL2, OUT
      fa,la,na :: INT, OUT
      fb,lb,nb :: INT, OUT
      atom_a,atom_b :: INT, OUT

      a,b,sa,sb :: INT
      pa,pb :: VEC{REAL}(3)

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la =  .last_basis_fn_for_shell(a)
      lb =  .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

      pa = .atom(atom_a).position
      pb = .atom(atom_b).position

      sh2.set_and_precompute_from(.basis_shell1pair(sa,sb),pa,pb,atom_a==atom_b,FALSE)

   end

   set_shell2_from(index,sh2,a,fa,la,na,b,fb,lb,nb,atom_a,atom_b) ::: leaky, PURE
   ! Get the SHELL2 object "sh2" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      self  :: IN
      index :: INT, IN
      sh2   :: SHELL2, OUT
      a,fa,la,na :: INT, OUT
      b,fb,lb,nb :: INT, OUT
      atom_a,atom_b :: INT, OUT

      sa,sb :: INT
      pa,pb :: VEC{REAL}(3)

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la =  .last_basis_fn_for_shell(a)
      lb =  .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

      pa = .atom(atom_a).position
      pb = .atom(atom_b).position

      sh2.set_and_precompute_from(.basis_shell1pair(sa,sb),pa,pb,atom_a==atom_b,FALSE)

   end

!  =====================
!  Shell quartet indices
!  =====================

   set_shell4_indices_from(index,fa,la,fb,lb,fc,lc,fd,ld) ::: pure
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index". Also return the basis function
   ! start indices "fa", "la", etc ...
      self  :: IN
      index :: INT, IN
      fa,la,fb,lb :: INT, OUT
      fc,lc,fd,ld :: INT, OUT

      a,b,c,d :: INT
      ab,cd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2

      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)

      la =  .last_basis_fn_for_shell(a)
      lb =  .last_basis_fn_for_shell(b)
      lc =  .last_basis_fn_for_shell(c)
      ld =  .last_basis_fn_for_shell(d)

   end

   set_shell4_indexes_from(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: pure
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index" and the corresponding atom
   ! centers. Note different spelling for this routine and the one
   ! above to avoid overload problems.
      self    :: IN
      index   :: INT, IN
      a,b,c,d :: INT, OUT
      atom_a,atom_b :: INT, OUT
      atom_c,atom_d :: INT, OUT

      ab,cd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2

      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)

   end

!  ==============
!  Shell quartets
!  ==============

   set_shell4_from(a,b,c,d,sh4) ::: leaky, PURE
   ! Get the SHELL4 object "sh4" correponding to the indicies "a",
   ! "b", "c" and "d".
      self    :: IN
      a,b,c,d :: INT, IN
      sh4     :: SHELL4, OUT

      aa,bb,cc,dd :: INT
      sa,sb,sc,sd :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      sh4.a.set(.atom(aa).basis.shell(sa), .atom(aa).position)
      sh4.b.set(.atom(bb).basis.shell(sb), .atom(bb).position)
      sh4.c.set(.atom(cc).basis.shell(sc), .atom(cc).position)
      sh4.d.set(.atom(dd).basis.shell(sd), .atom(dd).position)

   end

   set_shell4_from(index,sh4,a,b,c,d) ::: leaky, PURE
   ! Get the SHELL4 object "sh4" correponding to the quartet index
   ! "index" Also return the shell indicies "a", "b", "c" and "d"
   ! which map to "index"
      self    :: IN
      index   :: INT, IN
      sh4     :: SHELL4, OUT
      a,b,c,d :: INT, OUT

      ab,cd :: INT
      aa,bb,cc,dd :: INT
      sa,sb,sc,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2

      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      sh4.a.set(.atom(aa).basis.shell(sa), .atom(aa).position)
      sh4.b.set(.atom(bb).basis.shell(sb), .atom(bb).position)
      sh4.c.set(.atom(cc).basis.shell(sc), .atom(cc).position)
      sh4.d.set(.atom(dd).basis.shell(sd), .atom(dd).position)

   end

   set_shell4_from(index,sh4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky, PURE
   ! Get the SHELL4 object "sh4" correponding to the quartet index
   ! "index" Also return the shell indicies "a", "b", "c" and "d"
   ! which map to "index" Also return the basis function start indices
   ! "fa", "la", etc ...
      self  :: IN
      index :: INT, IN
      sh4   :: SHELL4, OUT
      a,b,c,d     :: INT, OUT
      fa,la,fb,lb :: INT, OUT
      fc,lc,fd,ld :: INT, OUT

      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2

      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa =       .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb =       .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc =       .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd =       .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)

      sh4.a.set(.atom(aa).basis.shell(sa), .atom(aa).position)
      sh4.b.set(.atom(bb).basis.shell(sb), .atom(bb).position)
      sh4.c.set(.atom(cc).basis.shell(sc), .atom(cc).position)
      sh4.d.set(.atom(dd).basis.shell(sd), .atom(dd).position)

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)

      la =  .last_basis_fn_for_shell(a)
      lb =  .last_basis_fn_for_shell(b)
      lc =  .last_basis_fn_for_shell(c)
      ld =  .last_basis_fn_for_shell(d)

   end

   set_shell4_from(index,sh4,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: leaky, PURE
   ! Get the SHELL4 object "shell" correponding to the quartet index
   ! "index" Also return the shell indicies "a", "b", "c" and "d"
   ! which map to "index" Plus the atoms which the shells are on.
      self  :: IN
      index :: INT, IN
      sh4   :: SHELL4, OUT
      a,b,c,d       :: INT, OUT
      atom_a,atom_b :: INT, OUT
      atom_c,atom_d :: INT, OUT

      ab,cd,sa,sb,sc,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2

      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      atom_a =       .atom_for_shell(a)
      sa     = .atom_shell_for_shell(a)
      atom_b =       .atom_for_shell(b)
      sb     = .atom_shell_for_shell(b)
      atom_c =       .atom_for_shell(c)
      sc     = .atom_shell_for_shell(c)
      atom_d =       .atom_for_shell(d)
      sd     = .atom_shell_for_shell(d)

      sh4.a.set(.atom(atom_a).basis.shell(sa), .atom(atom_a).position)
      sh4.b.set(.atom(atom_b).basis.shell(sb), .atom(atom_b).position)
      sh4.c.set(.atom(atom_c).basis.shell(sc), .atom(atom_c).position)
      sh4.d.set(.atom(atom_d).basis.shell(sd), .atom(atom_d).position)

   end

   set_shell4_ab_from(a,b,sh4) ::: leaky, PURE
   ! Set the a and b parts of the "sh4" SHELL4 object.
      self :: IN
      a,b  :: INT, IN
      sh4  :: SHELL4, OUT

      aa,sa :: INT
      bb,sb :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)

      sh4.a.set(.atom(aa).basis.shell(sa), .atom(aa).position)
      sh4.b.set(.atom(bb).basis.shell(sb), .atom(bb).position)

   end

   set_shell4_cd_from(c,d,sh4) ::: leaky, PURE
   ! Set the c and d parts of the "sh4" SHELL4 object.
      self :: IN
      c,d  :: INT, IN
      sh4  :: SHELL4, OUT

      cc,sc :: INT
      dd,sd :: INT

      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      sh4.c.set(.atom(cc).basis.shell(sc), .atom(cc).position)
      sh4.d.set(.atom(dd).basis.shell(sd), .atom(dd).position)

   end

   set_shell1q_ab_from(a,b,sh1q,skip) ::: leaky, PURE
   ! Set the "a" and "b" parts of the "sh1q" SHELL1QUARTET object. 
   ! If "skip" is TRUE then some primitive pairs are ignored, if too
   ! small (this should not be set if any atoms in the qurtet are the
   ! same; if in doubt set skip=FALSE).
      self :: IN
      a,b  :: INT, IN
      sh1q :: SHELL1QUARTET, INOUT
      skip :: BIN, IN

      aa,sa,bb,sb :: INT
      pa,pb :: VEC{REAL}(3)

      aa = .atom_for_shell(a)         !which atom.
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)  !which shell.
      sb = .basis_shell_for_shell(b)

      pa = .atom(aa).position
      pb = .atom(bb).position

      sh1q.set_ab_new(.basis_shell1pair(sa,sb),pa,pb,aa==bb,skip)

   end

   set_shell1q_cd_from(c,d,sh1q,skip) ::: leaky, PURE
   ! Set the "c" and "d" parts of the "sh1q" SHELL1QUARTET object. 
   ! If "skip" is TRUE then some primitive pairs are ignored, if too
   ! small (this should not be set if any atoms in the qurtet are the
   ! same; if in doubt set skip=FALSE).
      self :: IN
      c,d  :: INT, IN
      sh1q :: SHELL1QUARTET, INOUT
      skip :: BIN, IN

      cc,sc,dd,sd :: INT
      pc,pd :: VEC{REAL}(3)

      cc = .atom_for_shell(c)         !which atom.
      dd = .atom_for_shell(d)

      sc = .basis_shell_for_shell(c)  !which shell.
      sd = .basis_shell_for_shell(d)

      pc = .atom(cc).position
      pd = .atom(dd).position

      sh1q.set_cd_new(.basis_shell1pair(sc,sd),pc,pd,cc==dd,skip)

   end

!  ======================
!  Make shell information
!  ======================

   update_shell_info ::: leaky, PURE
   ! Define a vector of atom numbers corresponding to the molecule's
   ! basis set shell numbers; also define a vector of atom shell
   ! numbers corresponding to the molecule basis set shell number; 
   ! and precalculated shell info for integrals.
      self :: INOUT

   ENSURE(.atom.allocated,"no atom information")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")
   ENSURE(.n_atom>0,"no atoms")
   ENSURE(.basis.allocated,"no basis set")

      ! Set basis l_max before anything else
      .basis_l_max = .basis.maximum_basis_set_l_value
    ! GAUSSIAN_DATA:set_indices(.basis_l_max)

      ! Set atom for shell
      .atom_for_shell.destroy
      .atom.make_atom_for_shell(.atom_for_shell)

      .atom_shell_for_shell.destroy
      .atom.make_atom_shell_for_shell(.atom_shell_for_shell)

      ! Set first/last shell for atom
      .first_shell_for_atom.destroy
       .last_shell_for_atom.destroy
      .first_shell_for_atom.create(.n_atom)
       .last_shell_for_atom.create(.n_atom)
      .atom.make_shell_for_atom_limits(.first_shell_for_atom,.last_shell_for_atom)

      ! Set first/last bf for shell
      .first_basis_fn_for_shell.destroy
       .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .atom.make_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      ! Set first/last bf for atom
      .first_basis_fn_for_atom.destroy
       .last_basis_fn_for_atom.destroy
      .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)

      ! Shell pointer into flattened .basis vector
      .basis_shell_for_shell.destroy
      .atom.make_basis_shell_for_shell(.basis_shell_for_shell,.basis)

      ! Precalculate non-positional basis-pair information
      .n_unique_shells = .basis.no_of_shells
      .basis_shell1pair.destroy
      .basis_shell1pair.create(.n_unique_shells,.n_unique_shells)
      .basis_shell1pair.make_precomputed_shellpairs(.basis)

   end

!  ===============
!  Atom-shell info
!  ===============

   update_atom_shell_info ::: leaky, PURE
   ! Get the atom shell info for all atoms in the molecule. We make it
   ! only for the unique atoms and pointer copy to the non-unique
   ! atoms, just like for ANO atom information.
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      a,b :: INT
      done :: VEC{BIN}@
      first :: BIN

      if (.:has_all_shell_info) return

      done.create(.n_atom)
      done  = FALSE
      first = TRUE

      do a = 1,.n_atom

         ! Unique atom?
         if (done(a)) cycle

         ! Make the shell info
         .atom(a).make_shell_info

         done(a) = TRUE

         ! Copy it to non-unique atoms
         do b = a+1,.n_atom

            ! Skip?
            if (done(b)) cycle
            if (NOT .atom(b).is_same_kind_as(.atom(a))) cycle

            .atom(b).first_basis_fn_for_shell = .atom(a).first_basis_fn_for_shell
            .atom(b).last_basis_fn_for_shell  = .atom(a).last_basis_fn_for_shell
            .atom(b).angular_moment_for_shell = .atom(a).angular_moment_for_shell
            .atom(b).basis_shell1pair         = .atom(a).basis_shell1pair

            done(b) = TRUE

         end

      end

      done.destroy

   end

!  ========================
!  Contraction Coefficients
!  ========================

   make_contraction_mx(cc_mat) ::: PURE
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      self :: IN
      cc_mat :: MAT{REAL}, OUT

   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      b = 1
      p = 1

      cc_mat = ZERO

      do a = 1,.n_atom

         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf

         .atom(a).basis.make_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))

         p = p + ap
         b = b + ab

      end

   end

   make_normalised_contraction_mx(cc_mat) ::: PURE
   ! Returns the matrix of complete contraction coefficients for each
   ! basis set. Size of cc_mat is [.n_prim,.n_bf]. Primitive components
   ! are properly normalised.
      self :: INOUT
      cc_mat :: MAT{REAL}, OUT

   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      .basis.renormalise

      b = 1
      p = 1
      cc_mat = ZERO

      do a = 1,.n_atom

         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf

         .atom(a).basis.make_normalised_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))

         p = p + ap
         b = b + ab

      end

      .basis.unnormalise

   end

!  ========================
!  Atom AO subspace setting
!  ========================

   AO_subspace_set(A,B,row_atom,col_atom) ::: PURE
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then copy
   ! the entire row or col, i.e.  A(small) = B(row_atom,col_atom)
      self :: IN
      A :: MAT{REAL}, OUT
      B :: MAT{REAL}, IN
      row_atom :: VEC{INT}, optional, IN
      col_atom :: VEC{INT}, optional, IN

   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")

      n_row_atoms,n_col_atoms, a1,a2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT

      if (present(row_atom) AND present(col_atom)) then

         n_row_atoms = row_atom.dim
         n_col_atoms = col_atom.dim
         a1 = .atom(row_atom).no_of_basis_functions
         a2 = .atom(col_atom).no_of_basis_functions
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_i = 0
         do i = 1,n_row_atoms

            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = l_i - f_i + 1

            b_j = 0

            do j = 1,n_col_atoms

               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = l_j - f_j + 1

               A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)

               b_j = b_j + n_j

            end

            b_i = b_i + n_i

         end

      else if (present(row_atom)) then

         n_row_atoms = row_atom.dim
         a1 = .atom(row_atom).no_of_basis_functions
         a2 = .n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_i = 0

         do i = 1,n_row_atoms

            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = l_i - f_i + 1

            A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)

            b_i = b_i + n_i

         end

      else if (present(col_atom)) then

         n_col_atoms = col_atom.dim
         a1 = .n_bf
         a2 = .atom(col_atom).no_of_basis_functions
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_j = 0

         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j))
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = l_j - f_j + 1

            A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)

            b_j = b_j + n_j

         end

      end

   end

!  ======================
!  Density matrix methods
!  ======================

   make_density_mx_from_NOs ::: leaky
   ! Make the .density_mx from the *NOs* and the
   ! *NO_occ_nos* vector. Only restricted so far.
      self :: INOUT

   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")
   ENSURE(.NOs.allocated, "no natural orbitals")

      NO :: MAT{REAL}@
      occ :: VEC{REAL}@
      genre :: STR
      arch :: ARCHIVE

      genre = .NOs.genre

      ! Destroy
      .density_mx.destroy(genre)
      .density_mx.create(genre)

      ! Make it
      select case (genre)

      case ("r ")

         ENSURE(.NOs.is_allocated_with_genre("r "),"no NO's")

         occ.create(.n_bf)
         NO.create(.n_bf,.n_bf)

         occ = sqrt(.NO_occ_nos.r)
         NO.to_product_with_diagonal(.NOs.r,occ)
         .density_mx.r.to_product_of(NO,NO,transpose_b=TRUE)

         NO.destroy
         occ.destroy

      case default

         DIE("unknown SCF kind, "//trim(genre))

      end

      ! Archive
      arch.set(.name,"density_mx",genre)
      arch.write(.density_mx)

   end

   make_SCF_density_mx(damp,n_a,method) ::: leaky
   ! Make the density matrix from the molecular orbitals.
   ! . If "damp" is present use it to damp the updated density matrix.
   !   An .old_density_mx must exist for this to work.
   ! . If "n_a" is present it is used as the number of alpha electrons
   !   in embedded scf calculations.
   ! . If "method" is present it is used as the kind of density matrix
   !   to make, otherwise taken from .scfdata.SCF_kind, or guessed
   !   from the spinorbital_genre of the MO's.
   ! NOTE:
   ! . If .scfdata.do_delta_build is set and a a .delta_density_mx
   !   is created, then a delta density is made.
   ! . If .scfdata.apply_pFON a finite temperature density matrix is
   !   made with temperature .scfdata.temperature_for_pFON (untested)
      self :: INOUT
      damp :: BIN, optional, IN
      n_a :: INT, optional, IN
      method :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")

      T :: REAL
      damping,do_archive,do_delta_density :: BIN
      use_pFON,use_FON :: BIN
      scf_method,genre :: STR

      ! Determine (or guess) the kind of SCF method to be used.
      if      (present(method))    then; scf_method = method
      else if (.scfdata.allocated) then; scf_method = .scfdata.SCF_kind
      else;                              scf_method = .MOs.guess_SCF_kind
      end

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Make the delta density matrix?
      do_delta_density = .delta_density_mx.allocated
      if (.scfdata.allocated) do_delta_density = do_delta_density AND .scfdata.do_delta_build

      ! Determine if density matrix damping is to be used
      damping = .old_density_mx.allocated
      if      (present(damp)) then;      damping = damping AND damp
      else if (.scfdata.allocated) then; damping = damping AND .scfdata.apply_damping
      end

      ! Determine if pFON should be used
      use_pFON = FALSE
      if (.scfdata.allocated) then
      if (.fock_mx.allocated) then
      if (.fock_mx.is_allocated_with_genre(genre)) then
         use_pFON = .scfdata.apply_pFON
      end
      end
      end

      ! Determine if finite temperature FON should be used
      use_FON = FALSE
      if (.scfdata.allocated) use_pFON = .scfdata.using_FON

      ! Create the density matrix (leaky)
      if (.density_mx.deallocated) .density_mx.create(.n_bf)
      .density_mx.destroy(genre)
      .density_mx.create(genre)

      ! Save the old density if damping
      .old_density_mx.destroy
      if (do_delta_density OR damping) then
         .old_density_mx = .density_mx
         .old_density_mx.compress
      end

      ! Make the density matrix
      select case (scf_method)

      case ("group")
         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         ENSURE(present(n_a),"n_a must be specified")
         .density_mx.r.to_scaled_product_of(.MOs.r(:,1:.n_a) &
                                                        ,.MOs.r(:,1:.n_a) &
                                                        ,fac=TWO,transpose_b=TRUE)

      case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
         ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.atom.chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))

         if (use_pFON) then

            T  =  .scfdata.temperature_for_pFON
            ::make_finite_T_density_mx(.density_mx.r &
                                          ,.MOs.r &
                                          ,.fock_mx.r,T,.n_a)
            .density_mx.r  = TWO*.density_mx.r

         else if (use_FON) then

            T  =  .scfdata.temperature
            ::make_finite_T_DM_r(.density_mx.r &
                                ,.scfdata.E_Fermi &
                                ,.MOs.r &
                                ,.MO_energies.r,T,.n_a)
            .density_mx.r  = TWO*.density_mx.r

         else

            .density_mx.r.to_scaled_product_of(.MOs.r(:,1:.n_a) &
                                                           ,.MOs.r(:,1:.n_a) &
                                                           ,fac=TWO,transpose_b=TRUE)

         end

         if (scf_method(1:4)=="xray" AND .scfdata.stabilize_density) then
            .:stabilize(.density_mx.r)
         end

      case ("rohf")

         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")

         .density_mx.a.to_product_of(.MOs.a(:,1:.n_a) &
                                            ,.MOs.a(:,1:.n_a) &
                                            ,transpose_b=TRUE)
         .density_mx.b.to_product_of(.MOs.b(:,1:.n_b) &
                                           ,.MOs.b(:,1:.n_b) &
                                           ,transpose_b=TRUE)

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

         ENSURE(.MOs.is_allocated_with_genre("u "),"no MO's")

         if (use_pFON) then

            T = .scfdata.temperature_for_pFON
            ::make_finite_T_density_mx(.density_mx.a     &
                                          ,.MOs.a &
                                          ,.fock_mx.a,T,.n_a)
            ::make_finite_T_density_mx(.density_mx.b      &
                                          ,.MOs.b, &
                                          .fock_mx.b,T,.n_b)

         else if (use_FON) then

            T = .scfdata.temperature
            ::make_finite_T_DM_u(.density_mx.a     &
                                ,.density_mx.b      &
                                ,.scfdata.E_Fermi &
                                ,.MOs.a &
                                ,.MOs.b  &
                                ,.MO_energies.a   &
                                ,.MO_energies.b    &
                                ,T,.n_a,.n_b)

         else

            .density_mx.a.to_product_of(.MOs.a(:,1:.n_a) &
                                               ,.MOs.a(:,1:.n_a),transpose_b=TRUE)
            .density_mx.b.to_product_of( .MOs.b(:,1:.n_b)  &
                                              , .MOs.b(:,1:.n_b), transpose_b=TRUE)

         end

      case ("gchf","xray_gchf")

         ENSURE(.MOs.is_allocated_with_genre("gc"),"no MO's")

         .density_mx.gc.to_product_of(.MOs.gc(:,1:.n_e) &
                                                      ,.MOs.gc(:,1:.n_e) &
                                                      ,dagger_b=TRUE)

      case default

         DIE("unknown SCF kind, "//trim(scf_method))

      end

      ! Damp the density matrix if required
      if (damping) then
         .old_density_mx.uncompress
         .density_mx.damp(.old_density_mx,.scfdata.damp_factor)
      end

      ! Archive density matrix?
      do_archive = FALSE
      if (do_archive) .:archive(.density_mx,"density_mx")

      ! Save the delta density matrix for incremental Fock build
      if (do_delta_density) then
         .delta_density_mx = .old_density_mx
         .delta_density_mx.scale_by(-ONE)
         .delta_density_mx.plus(.density_mx)
      else
         .old_density_mx.destroy
      end

   end

!   make_S_g(S)
!   ! Make the 2x.n_bf sizes AO overlap matrix
!      self :: IN
!      S :: MAT{REAL}, OUT
!
!   ENSURE(.overlap_mx.allocated, "NO overlap_mx!")
!
!      S = ZERO
!
!      ! Make S in the SAO asis 
!      S.set_aa_block_to(.overlap_mx)
!        S.set_bb_block_to(.overlap_mx)
!
!   end

   make_finite_T_density_mx(D,MO,F,T,n_e) ::: selfless
   ! Make the finite temperature density matrix "D" from molecular
   ! orbitals "MO" according to the pFON method with temperature "T"
   ! and number of electrons "n_e" *for a given spin*, as in Rabuck
   ! and Scuseria, JCP 110, 695 (1999).  There must exist a current
   ! fock_mx "F" made from "D" which is used to get the
   ! eigenvalues for the Fermi-Dirac distribution.
      D :: MAT{REAL}, OUT
      MO,F :: MAT{REAL}, IN
      T :: REAL, IN
      n_e :: INT, IN

   ENSURE(F.is_square,"F must be square")
   ENSURE(F.is_same_shape_as(MO),"incompatible F and MO")
   ENSURE(n_e<MO.dim2,"fewer MO's than electrons")
   ENSURE(T>=ZERO,"T must be positive")

      W :: MAT{REAL}@
      occ :: VEC{REAL}@
      ind :: VEC{INT}@
      beta,e_homo,e_lumo,e_fermi,homo_lumo_gap :: REAL
      n_orb,i,j,n_frac :: INT

      n_orb = F.dim1

      occ.create(n_orb)
      ind.create(n_orb)

      ! Make the occupation numbers
      W.create(n_orb,n_orb)
      W.to_product_of(F,MO)
      do i = 1,n_orb        ! These are energies
         occ(i) = dot_product(MO(:,i),W(:,i))
      end
      occ.quick_sort(ind)   ! "ind" has the energies sorted
      W.destroy

      beta    = KELVIN_PER_HARTREE/T
      e_homo  = occ(ind(n_e))
      e_lumo  = occ(ind(n_e+1))
      e_fermi = HALF*(e_homo + e_lumo)
      homo_lumo_gap = e_lumo - e_homo
      do j = 1,n_orb        ! These are the occupation numbers
         i = ind(j)
         occ(i) = ONE/(ONE+exp(beta*(occ(i)-e_fermi)))
      end

      ! The number of fractional orbitals
      if      (homo_lumo_gap>0.135e0) then; n_frac = 5
      else if (homo_lumo_gap<0.090e0) then; n_frac = 3
      else;                                 n_frac = 4
      end

      ! Reset the fractional occupancies
      do j = 1,n_orb
         i = ind(j)
         if      (j<=n_e-n_frac) then; occ(i) = ONE
         else if (j >n_e+n_frac) then; occ(i) = ZERO
         end
      end

      ! Form the temperature broadended density
      D = ZERO
      do j = 1,n_e+n_frac
         i = ind(j)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ(i),transpose_b=TRUE)
      end

      ind.destroy
      occ.destroy

   end

   make_finite_T_DM_r(D,E_Fermi,MO,eig,T,n_e) ::: selfless
   ! Make the restricted finite temperature density matrix "D" from
   ! molecular orbitals "MO" according to the FON method with
   ! temperature "T" in Kelvin and number of electrons "n_e" *for a
   ! given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
      D :: MAT{REAL}, OUT
      E_Fermi :: REAL, OUT
      MO :: MAT{REAL}, IN
      eig :: VEC{REAL}, IN
      T :: REAL, IN
      n_e :: INT, IN

   ENSURE( D.is_square, "D must be square")
   ENSURE(MO.dim2==eig.dim,"MO and eig are incomptabile")
   ENSURE(n_e<=MO.dim2,"fewer MO's than electrons")
   ENSURE(T>ZERO,"T must be positive")

      i :: INT
      occ :: REAL

      ! Set temperature and eigenvalues
      REAL:set_T_Fermi(T)
      REAL:set_E_level(eig)
      REAL:set_n_electrons(n_e)

      ! Find the Fermi energy
      REAL:find_root_brent(REAL::Fermi_Dirac_excess_fn,x1=eig(1),x2=eig(n_e+1),root=E_Fermi,tol=TOL(6))

      if (TRUE) then
         stdout.show("HOMO      =",eig(n_e))
         stdout.show("LUMO      =",eig(n_e+1))
         stdout.show("E_Fermi   =",E_Fermi)
      end

      ! Set the Fermi energy
      REAL:set_E_Fermi(E_Fermi)

      ! Form the temperature broadended density
      D = ZERO
      do i = 1,MO.dim2
         occ = REAL:Fermi_Dirac_fn(i)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ,transpose_b=TRUE)
      end

   end

   make_finite_T_DM_u(Da,Db,E_Fermi,MOa,MOb,Ea,Eb,T,n_a,n_b) ::: selfless
   ! Make the restricted finite temperature density matrix "D" from
   ! molecular orbitals "MO" according to the FON method with
   ! temperature "T" in Kelvin and number of electrons "n_e" *for a
   ! given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
      Da,Db :: MAT{REAL}, OUT
      E_Fermi :: REAL, OUT
      MOa,MOb :: MAT{REAL}, IN
      Ea,Eb :: VEC{REAL}, IN
      T :: REAL, IN
      n_a,n_b :: INT, IN

   ENSURE( Da.is_square, "Da must be square")
   ENSURE( Db.is_square, "Da must be square")
   ENSURE(MOa.dim2==Ea.dim,"MOa and Ea are incomptabile")
   ENSURE(MOb.dim2==Eb.dim,"MOb and Eb are incomptabile")
   ENSURE(n_b<=MOb.dim2,"fewer MOb's than electrons")
   ENSURE(T>ZERO,"T must be positive")

      i :: INT
      Emin,Emax,occ :: REAL

      ! Set temperature and eigenvalues
      REAL:set_T_Fermi(T)
      REAL:set_E_level(Ea,Eb)
      REAL:set_n_electrons(n_a+n_b)

      ! Find the Fermi energy
      Emin = min(Ea( 1 ),Eb( 1 ))
      Emax = max(Ea(n_a),Eb(n_b))
      REAL:find_root_brent(REAL::Fermi_Dirac_excess_fn,x1=Emin,x2=Emax,root=E_Fermi,tol=TOL(6))

      if (TRUE) then
         stdout.show("HOMOa     =",Ea(n_a))
         stdout.show("HOMOb     =",Eb(n_b))
         stdout.show("LUMOa     =",Ea(n_a+1))
         stdout.show("LUMOb     =",Ea(n_b+1))
         stdout.show("E_Fermi   =",E_Fermi)
      end

      ! Set the Fermi energy
      REAL:set_E_Fermi(E_Fermi)

      ! Form the temperature broadended density
      Da = ZERO
      do i = 1,MOa.dim2
         occ = REAL:Fermi_Dirac_fn(i)
         Da.plus_scaled_product_of(MOa(:,i:i),MOa(:,i:i),fac=occ,transpose_b=TRUE)
      end

      Db = ZERO
      do i = 1,MOb.dim2
         occ = REAL:Fermi_Dirac_fn(n_a+i)
         Db.plus_scaled_product_of(MOb(:,i:i),MOb(:,i:i),fac=occ,transpose_b=TRUE)
      end

   end

   make_r_density_mx ::: leaky, PURE
   ! Make the AO (spin independent) density matrix any existing density
   ! matrix. The result is placed in the "r " part.
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      ! Leaky
      .:make_r_density_mx(.density_mx)

   end

   make_r_density_mx(D) ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix.
      self :: IN
      D :: OPMATRIX, INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.has_any_genre, "no density matrix")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = D.genre
      end

      select case (genre)

      case ("r ")
         ! do nothing

      case ("u ")
         D.r = D.a + D.b

      case ("gc")
         D.r = RE(D.gc.aa_block) + RE(D.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_r_density_mx(P) ::: PURE
   ! Make the AO (spin independent) density matrix "P" from the
   ! existing density matrix.
      self :: IN
      P :: MAT{REAL}, OUT
      .:make_ao_RE_density_mx(P)
   end

   make_ao_RE_density_mx(P) ::: PURE
   ! Make the REAL AO (spin independent) density matrix "P" from the
   ! existing density matrix.
      self :: IN
      P :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      select case (genre)

      case ("r ")
         P = .density_mx.r

      case ("u ")
         P = .density_mx.a + .density_mx.b

      case ("gc")
         P = RE(.density_mx.gc.aa_block) &
           + RE(.density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_IM_density_mx(P) ::: PURE
   ! Make the IMAGINARY AO (spin independent) density matrix "P" from
   ! the existing density matrix.
      self :: IN
      P :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      P = ZERO

      if (genre=="r ") return
      if (genre=="u ") return

      select case (genre)

      case ("gc")
         P = IM(.density_mx.gc.aa_block) &
           + IM(.density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_r_Sz_density_mx ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix. NOTE: factor 1/2 not included.
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      .:make_r_Sz_density_mx(.density_mx)   ! leaky

   end

   make_r_Sz_density_mx(D) ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix. NOTE: factor 1/2 not included!
      self :: IN
      D :: OPMATRIX@, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.allocated, "no density matrix")
   ENSURE(D.has_any_genre, "no density matrix")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = D.genre
      end

      if (genre=="r ") return

      select case (genre)

      case ("u ")
         D.destroy("r ")
         D.create("r ")
         D.r = D.a - D.b

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_r_Sz_density_mx(P) ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix. NOTE: factor 1/2 not included!
      self :: IN
      P :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end


      select case (genre)

      case ("r ") 
         ! return

      case ("u ")
         P = .density_mx.a &
           - .density_mx.b

      case ("gc")
         P = RE(.density_mx.gc.aa_block) &
           - RE(.density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_c_S_densities(S) ::: leaky, PURE
   ! Make  the complex spin density matrices
   ! NOTE: factor 1/2 IS included.
      self :: IN
      S :: MAT3{CPX}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      S = ZERO


      select case (genre)

      case ("r ")
         ! return

      case ("u ")
         S(:,:,3) = .density_mx.a - .density_mx.b

      case ("gc")
         I = IMAGIFY(ONE)
         S(:,:,1) =   .density_mx.gc.ab_block &
                  +   .density_mx.gc.ba_block
         S(:,:,2) = I*.density_mx.gc.ab_block &
                  - I*.density_mx.gc.ba_block
         S(:,:,3) =   .density_mx.gc.aa_block &
                  -   .density_mx.gc.bb_block

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_RE_c_S_densities(S) ::: leaky, PURE
   ! Make the REAL part of the complex spin density matrices.
   ! NOTE: factor 1/2 IS included.
      self :: IN
      S :: MAT3{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      S = ZERO


      select case (genre)

      case ("r ")
         ! return

      case ("u ")
         S(:,:,3) = .density_mx.a - .density_mx.b

      case ("gc")
         I = IMAGIFY(ONE)
         S(:,:,1) = RE(  .density_mx.gc.ab_block)  &
                  + RE(  .density_mx.gc.ba_block)
         S(:,:,2) = RE(I*.density_mx.gc.ab_block)  &
                  - RE(I*.density_mx.gc.ba_block)
         S(:,:,3) = RE(  .density_mx.gc.aa_block) &
                  - RE(  .density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_IM_spin_densities(S) ::: leaky, PURE
   ! Make the IMAGINARY part of the AO spin density matrices.
   ! NOTE: factor 1/2 IS included.
      self :: IN
      S :: MAT3{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      S = ZERO

      if (genre=="r ")   return
      if (genre=="u ") return

      select case (genre)

      case ("gc")
         I = IMAGIFY(ONE)
         S(:,:,1) = IM(  .density_mx.gc.ab_block)  &
                  - IM(  .density_mx.gc.ba_block)
         S(:,:,2) = IM(I*.density_mx.gc.ab_block)  &
                  - IM(I*.density_mx.gc.ba_block)
         S(:,:,3) = IM(  .density_mx.gc.aa_block) &
                  - IM(  .density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_SCF_density_mx(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      self :: INOUT
      n  :: INT, IN
      nb :: INT, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.MOs.allocated, "no molecular orbitals")

      genre :: STR
      arch :: ARCHIVE
      m :: INT
      uhf :: BIN

      uhf = .scfdata.SCF_kind.includes("u ")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")

      m = n
      if (present(nb)) m = nb

      genre = .scfdata.spinorbital_genre
      .density_mx.destroy(genre)
      .density_mx.create(genre)

      select case (.scfdata.SCF_kind)

      case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")

         ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.atom.chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))

         if (n>0 AND n<=.n_a) then
            .density_mx.r.to_scaled_product_of(.MOs.r(:,n:n),.MOs.r(:,n:n),fac=TWO,transpose_b=TRUE)
         else
            .density_mx.r = ZERO
         end

      case ("rohf")

         if (n>0 AND n<=.n_b) then
            .density_mx.a.to_product_of(.MOs.a(:,n:n),.MOs.a(:,n:n),transpose_b=TRUE)
            .density_mx.b.to_product_of(.MOs.b(:,n:n),.MOs.b(:,n:n),transpose_b=TRUE)
         else if (n>nb AND n<=.n_a) then
            .MOs.a(:,n:n) = .MOs.r(:,n:n)
            .density_mx.a.to_product_of(.MOs.a(:,n:n),.MOs.a(:,n:n),transpose_b=TRUE)
            .density_mx.a = ZERO
            .density_mx.b = ZERO
         end

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")


         if (n>0 AND n<=.n_a) then
            .density_mx.a.to_product_of(.MOs.a(:,n:n),.MOs.a(:,n:n),transpose_b=TRUE)
         else
            .density_mx.a = ZERO
         end

         if (m>0 AND m<=.n_b) then
            .density_mx.b.to_product_of(.MOs.b(:,m:m),.MOs.b(:,m:m),transpose_b=TRUE)
         else
            .density_mx.b = ZERO
         end

      case ("gchf","xray_gchf")

         if (n>0 AND n<=.n_e) then
            .density_mx.gc.to_product_of(.MOs.gc(:,n:n),.MOs.gc(:,n:n),dagger_b=TRUE)
         else
            .density_mx.gc = ZERO
         end

      case default;
         DIE("unknown kind, "//trim(.scfdata.SCF_kind))

      end

      ! Archive
      arch.set(.name,"density_mx",genre)
      arch.write(.density_mx)

   end

!  ==========================
!  Set atoms density matrices
!  ==========================

   make_aspherical_atoms ::: leaky
   ! Get the aspherical atom density matrix i.e. just copy the
   ! atom-atom block from the molecular density matrix.

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.has_any_genre,"no density_mx")

      D :: OPMATRIX@
      genre :: STR
      a :: INT

      if (.:has_all_ANO_matrices) .:destroy_ANO_matrices

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Copy existing density matrix
      D = .density_mx

      ! Make the restricted density matrix
      .:make_r_density_mx(D)


      ! Set athe atom densities
      do a = 1,.n_atom
         .:set_density_mx_for_atom(a,D.r)
      end

      D.destroy

   end

   set_density_mx_for_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      a :: INT
      D :: MAT{REAL}, IN

   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no density_mx")

      f,l :: INT

      ! Create a-th atoms density matrix
      .atom(a).density_mx.destroy
      .atom(a).density_mx.create(.atom(a).basis.n_bf)
      .atom(a).density_mx.create(genre="r ")

      ! Copy the a-th atom-atom block
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      .atom(a).density_mx.r = D(f:l,f:l)

      .atom(a).set_atom_data_made(TRUE)

   end

!  Spherically average atoms in existing density

   make_spherical_atoms ::: leaky
   ! Get the spherical atom natural orbitals (ANO) data for all
   ! atoms in the molecule.

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.has_any_genre,"no density_mx")

      D :: OPMATRIX@
      genre :: STR
      a :: INT

      if (.:has_all_atom_data) return

      if (.:has_all_ANO_matrices) .:destroy_ANO_matrices

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Copy existing density matrix
      D = .density_mx

      ! Make the restricted density matrix
      .:make_r_density_mx(D)


      ! Spherically average the molecule AO density
      do a = 1,.n_atom
         .:spherically_average_atom(a,D.r)
      end
      D.destroy

      .atom.set_atom_data_made(TRUE)

   end

   spherically_average_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      self :: INOUT
      a :: INT, IN
      D :: MAT{REAL}, IN

   ENSURE(.atom(a).NOs.deallocated,  "NOs, atom "//trim(a.to_str))
   ENSURE(.atom(a).NO_occ_nos.deallocated,"occ, atom "//trim(a.to_str))
   ENSURE(.atom(a).density_mx.deallocated,    "DM, atom "//trim(a.to_str))

      f,l :: INT
      mol :: MOLECULE@

      ! Create the molecule
      mol.:create
      .:make_molecule_from_atom(a,mol)

      ! Get the density matrix
      mol.density_mx.create(mol.n_bf)
      mol.density_mx.create(genre="r ")
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      mol.density_mx.r = D(f:l,f:l)

      ! Spherically average the AO density
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.:symmetrize(mol.density_mx)

      ! Make the natural orbitals
      mol.:make_NOs

      ! Clean up the SCF files
      mol.:delete_archive("NOs")
      mol.:delete_archive("NO_occ_nos")

      ! Destroy the atoms's NO and interpolator info
      .atom(a).interpolator.destroy
      .atom(a).density_mx.destroy
      .atom(a).NO_occ_nos.destroy
      .atom(a).NOs.destroy

      ! Copy the results
      .atom(a).NOs   = mol.NOs
      .atom(a).NO_occ_nos = mol.NO_occ_nos
      .atom(a).density_mx     = mol.density_mx

      ! Make the interpolator
      .atom(a).make_interpolator

      ! Nullify parts we just copied or can't destroy
      mol.atom.destroy_ptr_part       ! do not destroy ptr part

      ! Safe to destroy
      mol.:destroy

   end

   put_atomic_form_factors
   ! Put the spherically averaged restricted atomic form factors
   ! for the unique atoms.

   ENSURE(.atom.allocated,"no atom")
   ENSURE(.crystal.allocated,"no crystal - specify H form factor type")

      length,spacing :: REAL
      IAM,val :: BIN
      a :: INT

      ! Type of IAM SF's
      IAM = .crystal.xray_data.use_IAM_ITC_FFs

      ! Table length
      length  = 2.00d0 * FOUR*PI * ANGSTROM_PER_BOHR
      spacing = 0.05d0 * FOUR*PI * ANGSTROM_PER_BOHR

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Structure factors
         stdout.flush
         stdout.text("========================")
         stdout.text("Real form factors for "//trim(.atom(a).chemical_symbol))
         stdout.text("========================")
         stdout.flush

         val = .atom(a).use_IAM_ITC_FFs
         .atom(a).set_use_IAM_ITC_FFs(IAM)
         .atom(a).put_FT_along_z_r(length,spacing)
         .atom(a).set_use_IAM_ITC_FFs(val)  ! Put back

       ! ! Structure factors
       ! stdout.flush
       ! stdout.text("=============================")
       ! stdout.text("Imaginary form factors for "//trim(.atom(a).chemical_symbol))
       ! stdout.text("=============================")
       ! stdout.flush
       ! .atom(a).put_FT_along_z_i(length,spacing)

      end

   end

!  =============
!  Group density
!  =============

! These can be made much better if the atoms
! in the groups are assumed contigous.

   put_group_density_to(P,g,mol) ::: PURE
   ! Put the atom group "g" in the whole .density matrix into "P".
   ! "mol" is a molecule created from the appropriate atom group "g".
      self :: IN
      P :: MAT{REAL}, OUT
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")

      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT

      P = ZERO

      do a = 1,.atom_group(g).n_atoms ! Copy this atom density
      do b = 1,.atom_group(g).n_atoms
         aa  = .atom_group(g).atom_index(a)
         bb  = .atom_group(g).atom_index(b)
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         P(fa:la,fb:lb) = .density_mx.r(faa:laa,fbb:lbb)
      end
      end

   end

   set_group_density_from(P,g,mol) ::: PURE
   ! Set the atom group "g" density matrix from "P". "mol" must be a
   ! molecule created from the appropriate atom group "g".
      self :: INOUT
      P :: MAT{REAL}, IN
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")

      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT

      do a = 1,.atom_group(g).n_atoms ! Copy this atom density
      do b = 1,.atom_group(g).n_atoms

         aa  = .atom_group(g).atom_index(a)
         bb  = .atom_group(g).atom_index(b)

         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         faa =    .first_basis_fn_for_atom(aa)
         fbb =    .first_basis_fn_for_atom(bb)

         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         laa =    .last_basis_fn_for_atom(aa)
         lbb =    .last_basis_fn_for_atom(bb)


         .density_mx.r(faa:laa,fbb:lbb) = P(fa:la,fb:lb)

      end
      end

   end

   set_group_density(g,mol) ::: PURE
   ! Set the atom group "g" .density_mx from "P". "mol" must be a
   ! molecule created from the appropriate atom group "g".
      self :: INOUT
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no restricted density_mx")

     a,b,     ga,gb :: INT
     fga,lga, fa,la :: INT
     fgb,lgb, fb,lb :: INT

     do a = 1,.atom_group(g).n_atoms
     do b = 1,.atom_group(g).n_atoms

        ga  = .atom_group(g).atom_index(a)
        gb  = .atom_group(g).atom_index(b)

        fa  = mol.first_basis_fn_for_atom(a)
        fga =    .first_basis_fn_for_atom(ga)
        fb  = mol.first_basis_fn_for_atom(b)
        fgb =    .first_basis_fn_for_atom(gb)

        la  = mol.last_basis_fn_for_atom(a)
        lga =    .last_basis_fn_for_atom(ga)
        lb  = mol.last_basis_fn_for_atom(b)
        lgb =    .last_basis_fn_for_atom(gb)

        .density_mx.r(fga:lga,fgb:lgb) = mol.density_mx.r(fa:la,fb:lb)

     end
     end

   end

   set_group_MOs(g,mol) ::: PURE
   ! Set the atom group "g" .density_mx from "P". "mol" must be a
   ! molecule created from the appropriate atom group "g".
      self :: INOUT
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.allocated,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
   ENSURE(.MOs.allocated,"no MOs")
   ENSURE(.NO_occ_nos.allocated,"no NO_occ_nos")
   ENSURE(mol.MOs.allocated,"no mol MOs")
   ENSURE(mol.MOs.r.allocated,"no restricted mol MOs")

      a,ga, ms,mf,no :: INT
      fga,lga, fa,la :: INT

      mf = .:n_bf_up_to_mol(g)
      ms = mf + 1
      mf = mf + mol.n_bf

      do a = 1,.atom_group(g).n_atoms

         ga  = .atom_group(g).atom_index(a)

         fa  = mol.first_basis_fn_for_atom(a)
         fga =    .first_basis_fn_for_atom(ga)

         la  = mol.last_basis_fn_for_atom(a)
         lga =    .last_basis_fn_for_atom(ga)

         .MOs.r(fga:lga,ms:mf) = mol.MOs.r(fa:la,:)

      end

      no = mol.n_e/2
      .NO_occ_nos.r(ms:ms+no-1) = TWO

   end

   n_bf_up_to_mol(g) result (res) ::: PURE
   ! Return the no. of basis functions up to the "g"-th
   ! molecule .mol(g) assuming they are concatenated.
      self :: IN
      g    :: INT, IN
      res  :: INT
 
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(g>0 AND g<=.mol.dim,"group out of range")
 
      i :: INT
 
      res = 0
      do i = 1,g-1
         res = res + .mol(i).n_bf
      end
 
   end

!  =================
!  Expectation value
!  =================

   expectation(X) result (res) ::: PURE
   ! Evaluates the expectation value of the matrix of the operator X
   ! with the current density matrix
      self :: IN
      X :: MAT{REAL}, IN
      res :: REAL

   ENSURE(X.is_square,"X operator matrix is not square")

      orb_kind :: STR
      W :: MAT{REAL}@

      res = ZERO

      orb_kind = .density_mx.genre

      select case (orb_kind)

      case ("r ")
         ENSURE(X.dim1==.n_bf,"(rhf) wrong size, X")
         res = .density_mx.r.trace_product_with(X)

      case ("u ")
         ENSURE(X.dim1==.n_bf,"(uhf) wrong size, X")
         res = .density_mx.a.trace_product_with(X)
         res = .density_mx.b.trace_product_with(X) + res

      case ("gc")
         ENSURE(X.dim1==2*.n_bf,"(gchf) wrong size, X")
         W.create(2*.n_bf,2*.n_bf)
         W = RE(.density_mx.gc)
         res = MAT{REAL}:trace_product_with(W,X)
         W.destroy

    ! case default
    !    DIE("unimplemented kind, "//trim(orb_kind))

      end

   end

   expectation(X,with_cross_terms) result (res) ::: PURE
   ! Evaluates the expectation value of the matrix of the opmatrix X
   ! with the current density matrix
      self :: IN
      X :: OPMATRIX, IN
      with_cross_terms :: BIN, optional, IN
      res :: REAL

      orb_kind :: STR
      op_kind  :: STR
      cross_terms :: BIN

      res = ZERO
      cross_terms = FALSE
      if (present(with_cross_terms)) cross_terms = with_cross_terms

      orb_kind = .density_mx.genre
      op_kind = X.genre

      select case (orb_kind)

      case ("r ")
         if(op_kind=="r ") then
            ENSURE(X.r.dim1==.n_bf,"(rhf) wrong size, X")
            res = .density_mx.r.trace_product_with(X.r)
         else
            ENSURE(X.a.dim1==.n_bf,"(rhf) wrong size, X")
            res = .density_mx.r.trace_product_with(X.a)
            res = .density_mx.r.trace_product_with(X.b) + res
         end

      case ("u ")
         if(op_kind=="r ") then
            ENSURE(X.r.dim1==.density_mx.a.dim1,"(uhf) wrong size, X")
            res = .density_mx.a.trace_product_with(X.r)
            res = .density_mx.b.trace_product_with(X.r) + res
         else
            ENSURE(X.a.dim1==.density_mx.a.dim1,"(uhf) wrong size, X")
            res = .density_mx.a.trace_product_with(X.a)
            res = .density_mx.b.trace_product_with(X.b) + res
            if (cross_terms) then
               res = .density_mx.a.trace_product_with(X.b) + res
               res = .density_mx.b.trace_product_with(X.a) + res
            end
         end

    ! case default
    !    DIE("unimplemented kind, "//trim(orb_kind))

      end

   end


!  =================
!  Molecule rotation
!  =================

   rotate_by(R) ::: PURE
   ! Rotate the whole molecule using matrix "R" which specifies how
   ! positions in space are to be transformed i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(R.is_square,"rotation matrix is not square")
   ENSURE(R.dim1==3,"rotation matrix must be 3x3")

      if (R.is_zero) return

      .atom.rotate_by(R)
      .:rotate_MOs(R)
      .:rotate_density_mx(R)

   end

   rotate_MOs(R) ::: PURE
   ! Rotate the molecular orbital matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(STR:is_one_of(.MOs.genre,["r ","u "]),"unimplemented rotation")

      genre :: STR

      if (.MOs.deallocated) return
      if (.MOs.is_deallocated_or_no_genre) return

      genre = .MOs.genre

      select case (genre)

      case("r ")
         .:rotate_MOs_r(.MOs.r,R)

      case("u ")
         .:rotate_MOs_r(.MOs.a,R)
         .:rotate_MOs_r(.MOs.b,R)

      end

   end

   rotate_MOs_r(MO,R) ::: PURE
   ! Rotate a restricted molecular orbitals "MO" using matrix "R",
   ! where "R" specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: IN
      MO :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO orbitals")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")
   ENSURE(NOT .use_spherical_basis,"only for cartesian bases")

      new :: MAT{REAL}@
      tr :: VEC{EMAT{REAL}}@
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],MO(f:l,:))
      end

      MO = new

      tr.destroy
      new.destroy

   end

   rotate_density_mx(R) ::: PURE
   ! Rotate the resricted density matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
   ! NOTE: the kind is taken from the MO's.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(STR:is_one_of(.MOs.genre,["r ","u "]),"unimplemented rotation")

      genre :: STR

      if (.MOs.deallocated) return
      if (.MOs.is_deallocated_or_no_genre) return

      genre = .MOs.genre

      select case (genre)

      case("r ")
         .:rotate_density_mx_r(.density_mx.r,R)

      case("u ")
         .:rotate_density_mx_r(.density_mx.a,R)
         .:rotate_density_mx_r(.density_mx.b,R)


      end

   end

   rotate_density_mx_r(P,R) ::: PURE
   ! Rotate the density matrix "P" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      self :: IN
      P :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(P.is_square,"wrong shape for density matrix P")
   ENSURE(P.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")

      new :: MAT{REAL}@
      tr :: VEC{EMAT{REAL}}@
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],P(f:l,:))
      end

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         P(:,f:l).to_product_of(new(:,f:l),tr(a)[:,:],transpose_b=TRUE)
      end

      tr.destroy
      new.destroy

   end

   rotate_fock(R) ::: PURE
   ! Rotate the molecular orbital matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(STR:is_one_of(.fock_mx.genre,["r ","u "]),"unimplemented rotation")

      genre :: STR

      if (.fock_mx.deallocated) return
      if (.fock_mx.is_deallocated_or_no_genre) return

      genre = .fock_mx.genre

      select case (genre)

      case("r ")
         .:rotate_fock_mx_r(.fock_mx.r,R)

      case("u ")
         .:rotate_fock_mx_r(.fock_mx.a,R)
         .:rotate_fock_mx_r(.fock_mx.b,R)

      end

   end

   rotate_fock_mx_r(G,R) ::: PURE
   ! Rotate the fock matrix "G" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
   ! NOTE: THIOS IS WRONG ... SEE DM rotation!
      self :: IN
      G :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(G.is_square,"wrong shape for density matrix P")
   ENSURE(G.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")

      new :: MAT{REAL}@
      tr :: VEC{EMAT{REAL}}@
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,R)

      do s = 1,.n_shell

         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)

         new(f:l,:).to_product_of(tr(a)[:,:],G(f:l,:), transpose_b=TRUE)

      end

      G = new

      tr.destroy
      new.destroy

   end


   rotate_group(g,axis,angle) ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
      self :: INOUT
      g :: INT, IN
      axis :: VEC{REAL}(3), IN
      angle :: REAL, IN

   ENSURE(.atom_group.allocated,"no atom group information")

      mol :: MOLECULE@
      archive :: ARCHIVE
      R :: MAT{REAL}(3,3)
      v :: VEC{REAL}(3)
      P :: MAT{REAL}@
      i,a :: INT

      ! Clean up different-geometry data
      .:delete_SCF_archives

      R.to_3x3_rotation_mx(axis,angle)

      ! Rotate atoms; the line below does not work
      do i = 1,.atom_group(g).n_atoms
         a = .atom_group(g).atom_index(i)
         v = .atom(a).position
         .atom(a).position.to_product_of(R,v)
         .atom(a).ADP_tensor.back_transform_using(R)
      end

      .MOs.destroy         ! leaky here
      if (.density_mx.deallocated) return

      ENSURE(.density_mx.r.allocated,"group rotation for restricted DM only")

      ! Create molecule
      mol.:create
      .:make_molecule_from_atom_group(g,mol)

      ! Rotate density
      P.create(mol.n_bf,mol.n_bf)
      .:put_group_density_to(P,g,mol)
      mol.:rotate_density_mx_r(P,R)
      .:set_group_density_from(P,g,mol)
      P.destroy

      mol.atom.destroy_ptr_part ! do not destroy these
      mol.:destroy

      ! Write out the density matrix
      archive.set(.name,"density_mx",genre="r ")
      archive.write(.density_mx)

   end

!  ==============================
!  Shift/remove linear dependence
!  ==============================

   shift_dependence_from(F)
   ! Level shift the linear dependence in "F"
      F :: OPMATRIX, INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      s_kind :: STR

      ! Extrapolate compressed entities
      s_kind = .scfdata.spinorbital_genre
      select case (s_kind)
         case("rhf","rks","xray_rhf","xray_rks","rdvpt")
            .:shift_dependence_from_r(F.r)
         case("uhf","uks","rohf","pnd_uhf","pnd_uks","xray_uhf","xray_uks","xray_pnd_uhf","xray_pnd_uks")
            .:shift_dependence_from_r(F.a)
            .:shift_dependence_from_r(F.b)
         case default
            ! Unimplemented !!!
      end

   end

   shift_dependence_from_r(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors "evec" with small eigenvalue "eval".
   ! WARNING: this routine assumes eval's are ordered
   ! smallest to largest.
      F :: MAT{REAL}

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_eigenvalues")
   ENSURE(F.dim1==.overlap_eigenvectors.dim1,"wrong size, F")

      n :: INT
      tol,shift :: REAL

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Decouple and shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      ::decouple_and_shift_r(F,.overlap_eigenvectors,n,shift)

   end

   decouple_and_shift_r(F,evec,n,shift) ::: selfless
   ! In "F", decouple the first "n" eigenvectors "evec" and shift them
   ! to eigenvalue "shift". NOTE: ensure "evec" is orthonormal.
      F :: MAT{REAL}
      evec :: MAT{REAL}, IN
      n :: INT, IN
      shift  :: REAL, IN

   ENSURE(F.is_square,"F is not square")

      d :: INT

      ! Return if no vectores to shift/decouple
      if (n<=0) return

      d = F.dim1

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the vectors
      F(  1:n,n+1:d) = ZERO
      F(n+1:d,  1:n) = ZERO

      ! Shift the first n eigenvectors
      F(1:n,1:n).set_diagonal_to(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)

   end

   remove_dependence_from(F)
   ! Zero-out the linear dependence in "F"
      self :: INOUT
      F :: OPMATRIX, INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      s_kind :: STR

      ! Extrapolate compressed entities
      s_kind = .scfdata.spinorbital_genre
      select case (s_kind)
         case("rhf","rks","xray_rhf","xray_rks","rdvpt")
            .:remove_dependence_from_r(F.r)
         case("uhf","uks","rohf","pnd_uhf","pnd_uks","xray_uhf","xray_uks","xray_pnd_uhf","xray_pnd_uks")
            .:remove_dependence_from_r(F.a)
            .:remove_dependence_from_r(F.b)
         case default
            ! Unimplemented !!!
      end

   end

   remove_dependence_from_r(F) ::: PURE
   ! In "F", remove the linearly-dependent overlap eigenvectors.
      self :: INOUT
      F :: MAT{REAL}, INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(F.dim1==.n_bf,"wrong size, F")

      tol :: REAL
      n :: INT

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Return if no vectores to shift/decouple
      if (n<=0) return

      ! Change to the eigenvector basis
      F.change_basis_using(.overlap_eigenvectors)

      ! Zero couplings 
      F( : ,1:n) = ZERO
      F(1:n, : ) = ZERO

      ! Revert from the eigenvector basis
      F.back_transform_using(.overlap_eigenvectors)

   end

!  ================
!  Natural orbitals
!  ================

   make_NOs(genre) ::: leaky
   ! Make the natural orbitals from the density matrix
      genre :: STR, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .density_mx.genre
      end

      select case (orb_kind)
      case ("r "); .:make_r_NOs
      case ("u "); .:make_u_NOs
      case ("gc"); .:make_gc_NOs
      case default; UNKNOWN(orb_kind)
      end

   end

   make_r_NOs ::: leaky
   ! Make the restricted natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.r.allocated, "no density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .NOs.destroy
      .NOs.create(.n_bf,"r ")
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,"r ")

      ! Make the restricted NO's
      .:make_r_NOs(.NOs.r,   &
                   .NO_occ_nos.r, &
                   .density_mx.r)

   end

   make_u_NOs ::: leaky
   ! Make the unrestricted natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.a.allocated, "no density matrix")
   ENSURE(.density_mx.b.allocated, "no density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .NOs.destroy
      .NOs.create(.n_bf,"u ")
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,"u ")

      ! Make the unrestricted NO's
      .:make_r_NOs(.NOs.a,.NO_occ_nos.a,.density_mx.a)
      .:make_r_NOs(.NOs.b, .NO_occ_nos.b, .density_mx.b)

   end

   make_gc_NOs ::: leaky
   ! Make the general natural orbitals and occupations from the
   ! complex density matrix.
      self :: INOUT

   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.gc.allocated,"no density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      R :: MAT{REAL}@
      V,X :: MAT{CPX}@

      ! Recreate
      .NOs.destroy
      .NOs.create(.n_bf,"gc")
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,"g")


      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)

      .:make_r_overlap_sqrt(R)

      V = ZERO
      V.set_aa_block_to(R)
      V.set_bb_block_to(R)

      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .density_mx.gc
      X.change_basis_using(V)
      X.solve_hermitian_eigenproblem(.NO_occ_nos.g,V)

      R.create(.n_bf,.n_bf)
      .:make_r_overlap_inverse_sqrt(R)

      X = ZERO
      X.set_aa_block_to(R)
      X.set_bb_block_to(R)
      R.destroy

      .NOs.gc.to_product_of(X,V)
      .NO_occ_nos.g = .NO_occ_nos.g(2*.n_bf:1:-1)
      .NOs.gc       =     .NOs.gc(:,2*.n_bf:1:-1)

      X.destroy
      V.destroy

   end


   make_E_NOs(genre) ::: leaky
   ! Make the energy natural orbitals from the energy density matrix
      self :: INOUT
      genre :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.E_density_mx.allocated, "no density matrix")
   ENSURE(.E_density_mx.has_any_genre, "no density matrix")

      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .E_density_mx.genre
      end

      select case (orb_kind)
      case ("r "); .:make_r_ENOs
      case ("u "); .:make_u_ENOs
      case ("gc"); .:make_gc_ENOs
      case default;  UNKNOWN(orb_kind)
      end

   end

   make_r_ENOs ::: leaky
   ! Make the restricted energy natural orbitals from the energy density matrix
      self :: INOUT

   ENSURE(.E_density_mx.allocated, "no E density matrix")
   ENSURE(.E_density_mx.r.allocated, "no E density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .E_NO_energies.destroy
      .E_NO_energies.create(.n_bf,"r ")
      .E_NOs.destroy
      .E_NOs.create(.n_bf,"r ")

      ! Make the restricted NO's
      .:make_r_NOs(.E_NOs.r,.E_NO_energies.r,.E_density_mx.r)

   end

   make_u_ENOs ::: leaky
   ! Make the unrestricted energy natural orbitals from the energy density matrix
      self :: INOUT

   ENSURE(.E_density_mx.allocated, "no E density matrix")
   ENSURE(.E_density_mx.a.allocated, "no E density matrix")
   ENSURE(.E_density_mx.b.allocated, "no E density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .E_NO_energies.destroy
      .E_NO_energies.create(.n_bf,"u ")
      .E_NOs.destroy
      .E_NOs.create(.n_bf,"u ")

      ! Make the unrestricted NO's
      .:make_r_NOs(.E_NOs.a,.E_NO_energies.a,.E_density_mx.a,reverse_order=FALSE)
      .:make_r_NOs(.E_NOs.b, .E_NO_energies.b, .E_density_mx.b, reverse_order=FALSE)

   end

   make_gc_ENOs ::: leaky
   ! Make the general energy natural orbitals and eigenvalues from the
   ! general complex energy density matrix.
      self :: INOUT

   ENSURE(.E_density_mx.allocated,"no E_density matrix")
   ENSURE(.E_density_mx.gc.allocated,"no E density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      R :: MAT{REAL}@
      V,X :: MAT{CPX}@

      ! Recreate
      .E_NOs.destroy
      .E_NOs.create(.n_bf,"gc")
      .E_NO_energies.destroy
      .E_NO_energies.create(.n_bf,"g ")


      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)
      .:make_r_overlap_sqrt(R)

      V = ZERO
      V.set_aa_block_to(R)
      V.set_bb_block_to(R)
      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .E_density_mx.gc
      X.change_basis_using(V)
      X.solve_hermitian_eigenproblem(.E_NO_energies.g,V)

      R.create(.n_bf,.n_bf)
      .:make_r_overlap_inverse_sqrt(R)

      X = ZERO
      X.set_aa_block_to(R)
      X.set_bb_block_to(R)
      R.destroy

      .E_NOs.gc.to_product_of(X,V)

      X.destroy
      V.destroy

   end


   make_r_NOs(NO,occupation,P,reverse_order)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      self :: INOUT
      NO,P :: MAT{REAL}
      occupation :: VEC{REAL}
      reverse_order :: BIN, optional, IN

   ENSURE(.overlap_mx.allocated,"no overlap matrix")

      reverse :: BIN
      V,X :: MAT{REAL}@

      reverse = TRUE
      if (present(reverse_order)) reverse = reverse_order

      V.create(.n_bf,.n_bf)
      .:make_r_overlap_sqrt(V)

      X.create(.n_bf,.n_bf)

      P.change_basis_to(X,V)
      X.solve_symmetric_eigenproblem(occupation,V)

      .:make_r_overlap_inverse_sqrt(X)

      NO.to_product_of(X,V)

      X.destroy
      V.destroy

      if (reverse) then
         occupation = occupation(.n_bf:1:-1)
         NO         = NO(:,.n_bf:1:-1)
      end

   end


   make_density_mx_from(NO,occupations,genre) ::: leaky
   ! Make the density_mx from the natural orbitals and the
   ! occupation numbers.
      NO :: OPMATRIX, IN
      occupations :: OPVECTOR, IN
      genre :: STR, IN, optional

   ENSURE(.basis_info_made, "no basis info")


      genus :: STR
      Pr :: MAT{REAL}@


      if (present(genre)) then; genus = genre
      else;                     genus = .NOs.genre
      end

      select case (genus)

      case ("r ")
          ENSURE(NO.r.allocated,"no restricted NOs")
          ENSURE(occupations.r.allocated,"no restricted occupations")
          .density_mx.destroy
          .density_mx.create(.n_bf,"r ")
          Pr.create(.n_bf,.n_bf)
          Pr.to_product_with_diagonal(NO.r,occupations.r)
          .density_mx.r.to_product_of(Pr,NO.r,transpose_b=TRUE)
          Pr.destroy

      case ("u ")
          ENSURE(NO.a.allocated,"no alpha NOs")
          ENSURE(NO.b.allocated, "no beta NOs")
          ENSURE(occupations.a.allocated,"no alpha occupations")
          ENSURE(occupations.b.allocated, "no beta occupations")
          .density_mx.destroy
          .density_mx.create(.n_bf,"u ")
          Pr.create(.n_bf,.n_bf)
          Pr.to_product_with_diagonal(NO.a,occupations.a)
          .density_mx.a.to_product_of(Pr,NO.a,transpose_b=TRUE)
          Pr.to_product_with_diagonal(NO.b,occupations.b)
          .density_mx.b.to_product_of(Pr,NO.b,transpose_b=TRUE)
          Pr.destroy

      case default
          UNKNOWN(genus)

      end

   end


!  ===================
!  Overlap matrix sqrt
!  ===================

   make_r_overlap_sqrt(S_sqrt) ::: leaky
   ! Get "S_sqrt", the sqrt overlap matrix
      S_sqrt :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_values")
   ENSURE(S_sqrt.is_square,"non-square S_qrt")
   ENSURE(S_sqrt.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.allocated) then
         tol   = .scfdata.linear_dependence_tol
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

   make_r_overlap_inverse_sqrt(S_inv) ::: leaky, PURE
   ! Get "S_inv", the inverse sqrt overlap matrix
      self  :: INOUT
      S_inv :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_values")
   ENSURE(S_inv.is_square,"non-square S_inv")
   ENSURE(S_inv.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.allocated) then
         tol = .scfdata.linear_dependence_tol
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

!  ==========================
!  Natural orbital assignment
!  ==========================

   assign_NOs_to_MOs ::: leaky
   ! Copy the natural orbitals to be the MOs.
   ! If the MO's are not there, try and read them from disk.
   ! The occupation numbers are the MO ones.
      self :: target, INOUT

   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")

      arch  :: ARCHIVE
      genre :: STR
      g :: INT

      ! Get MOs
      if (.MOs.allocated) then
         ! Already there
         genre = .MOs.genre
      else if (.scfdata.allocated) then
         ! Does it exist on disk?
         genre = .scfdata.spinorbital_genre
         arch.set(.name,"MOs",genre)
         if (arch.exists) then
            .MOs.create(.n_bf)
            arch.read(.MOs)
            .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.close
         end
      end

      ! Clone the MO's
      if (.MOs.allocated) then
         .NOs = .MOs
         .NO_occ_nos.create(.n_bf,genre)
         .NO_occ_nos.set_to_zero
         .:set_SCF_occupations_for_NOs(genre)
      end

      if (.atom_group.allocated) then
      if (.mol.allocated) then
         
         do g = 1,.atom_group.dim

            ! Should be generalised to read archives like above ...
            if (.mol(g).MOs.deallocated) cycle

            genre = .mol(g).MOs.genre
            .mol(g).NOs = .mol(g).MOs
            .mol(g).NO_occ_nos.create(.mol(g).n_bf,genre)
            .mol(g).NO_occ_nos.set_to_zero
            .mol(g).:set_SCF_occupations_for_NOs(genre)

         end

      end
      end

   end

   assign_MOs_to_NOs ::: leaky
   ! Copy the MOs to be the same as the natural orbitals
   ! The occupation numbers are the MO ones.
      self :: target, INOUT

      genre :: STR
      g :: INT

      ! Clone
      if (.NOs.allocated) then
         genre = .NOs.genre
         .MOs = .NOs
         .NO_occ_nos.create(.n_bf,genre)
         .NO_occ_nos.set_to_zero
         .:set_SCF_occupations_for_NOs(genre)
      end

      if (.atom_group.allocated) then
      if (.mol.allocated) then
         
         do g = 1,.atom_group.dim

            if (.mol(g).NOs.deallocated) cycle

            genre = .NOs.genre
            .mol(g).MOs = .mol(g).NOs
            .mol(g).NO_occ_nos.create(.n_bf,genre)
            .mol(g).NO_occ_nos.set_to_zero
            .mol(g).:set_SCF_occupations_for_NOs(genre)

         end

      end
      end

   end

!  ================
!  Symmetry methods
!  ================

   symmetrize(mat,orb_kind)
   ! Symmetrize an opmatrix matrix "mat" and of spinorbital_genre
   ! "orb_kind" (if specified)
      self :: IN
      mat :: OPMATRIX, INOUT
      orb_kind :: STR, optional, IN

      itemkind :: STR

      itemkind = mat.genre
      if (present(orb_kind)) itemkind = orb_kind

      select case (itemkind)
      case ("r "); .:symmetrize(mat.r)
      case ("u "); .:symmetrize(mat.a)
                   .:symmetrize(mat.b)
      case ("gc"); .:symmetrize(mat.gc.aa_block_ptr)
                   .:symmetrize(mat.gc.bb_block_ptr)
                   .:symmetrize(mat.gc.ab_block_ptr)
                   .:symmetrize(mat.gc.ba_block_ptr)
    ! case default;   DIE("unknown kind, "//trim(orb_kind))
      end

   end


   symmetrize(mat) ::: template, PURE
   ! Symmetrize a matrix
      self :: IN
      mat :: MAT{TYPE?}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.pointgroup.allocated, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,W :: MAT{TYPE?}@
      tra,trb :: MAT{REAL}@
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}@

      image.create(.n_shell, .pointgroup.order)
      .:make_pg_image_of_shell(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.pointgroup.order

         do a = 1,.n_shell

            tra = .pointgroup.xyz_mx(n,.angular_moment_for_shell(a))
            i  = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb = .pointgroup.xyz_mx(n,.angular_moment_for_shell(b))
               j  = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               W.create(na,nb)
               W.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(W,trb,transpose_b=TRUE)
               W.destroy

            end

         end

      end

      mat = sym/REALIFY(.pointgroup.order)

      sym.destroy
      image.destroy

   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE?=>REAL)
   ! Symmetrize a matrix
   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE?=>CPX)
   ! Symmetrize a matrix
   end

   make_pg_image_of_shell(res) ::: PURE
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! pointgroup operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      self :: IN
      res :: MAT{INT}, OUT

   ENSURE(.pointgroup.allocated, "no pointgroup")
   ENSURE(res.dim1==.n_shell,          "wrong dim2, res")
   ENSURE(res.dim2==.pointgroup.order, "wrong dime2, res")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.pointgroup.order
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos.to_product_of(.pointgroup.mx(:,:,n), .atom(aa).position)

         new_atom = .atom.atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end


   symmetrize_DM_like_mx(DM) ::: template, PURE
   ! Symmetrize a density matrix-like object "DM" using the crystal
   ! seitz operators. 
      self :: IN
      DM :: MAT{TYPE?}, INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"No crystal")
   ENSURE(.crystal.fragment_info_made,"No crystal")
   ENSURE(DM.is_square,"non-square matrix")
   ENSURE(DM.dim1==.n_bf,"incorrectly dimensioned matrix")

      tr :: VEC{EMAT{REAL}}@
      sym,blk :: MAT{TYPE?}@
      tra,trb :: MAT{REAL}@
      imshcnt :: MAT{INT}@
      g :: INT
      a,fa,la,ma :: INT
      b,fb,lb,mb :: INT
      i,fi,li    :: INT
      j,fj,lj    :: INT
      symops  :: MAT3{REAL}@
      image  :: MAT{INT}@

      ! Symops
      symops = .crystal.xyz_seitz_matrices

      ! Make image shell map
      image.create(.n_shell,.crystal.spacegroup.n_seitz)
      .:make_sg_image_of_shell(image)

      ! Rotated and accumulated SM coeffcients
      sym.create(.n_bf,.n_bf)
      sym = DM

    ! stdout.text("DM:")
    ! stdout.put(DM)
      
      ! Counter for image-shell blocks
      imshcnt.create(.n_shell, .n_shell)
      imshcnt = 1

      ! Zero lower-triangle symmetry-dependent blocks
      ! Reset image shell block counts
    ! do a = 1,.n_shell
    ! do b = 1,a
    !    
    !    atom_a = .atom_for_shell(a)
    !    atom_b = .atom_for_shell(b)

    !    !  Unique atom block?
    !    ua = any(atom_a==.crystal.unique_frag_atom) 
    !    ub = any(atom_b==.crystal.unique_frag_atom) 

    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)
    !    fb = .first_basis_fn_for_shell(b)
    !    lb = .last_basis_fn_for_shell(b)
    !    
    !    if (NOT ua AND NOT ub) then
    !       ! Zero block: At least one of (a,b) is 
    !       ! related to a unique fragment atom.
    !       sym(fa:la,fb:lb) = ZERO
    !       sym(fb:lb,fa:la) = ZERO
    !    else
    !       ! Count block & copy
    !       imshcnt(a,b) = 1
    !       imshcnt(b,a) = 1
    !       sym(fa:la,fb:lb) = DM(fa:la,fb:lb)
    !       sym(fb:lb,fa:la) = DM(fb:lb,fa:la)
    !    end

    ! end
    ! end

      ! Generate Symmetry-dependent blocks
      do a = 1,.n_shell

       ! ! Only do unique (asym-atom-corresponding) frag atoms
       ! atom_a = .atom_for_shell(a)
       ! ua = any(atom_a==.crystal.unique_frag_atom)
       ! if (NOT ua) cycle

         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         ma = .angular_moment_for_shell(a)

         do b = 1,a

            ! Do any atom for shell b
            fb = .first_basis_fn_for_shell(b)
            lb = .last_basis_fn_for_shell(b)
            mb = .angular_moment_for_shell(b)

            do g = 2,.crystal.spacegroup.n_seitz

               i = image(a,g)
               j = image(b,g)

               if (i==0 OR j==0) cycle

               fi = .first_basis_fn_for_shell(i)
               li = .last_basis_fn_for_shell(i)
               fj = .first_basis_fn_for_shell(j)
               lj = .last_basis_fn_for_shell(j)

               GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,symops(:,:,g))
               tra = tr(ma)[:,:]
               trb = transpose(tr(mb)[:,:])
               blk = matmul( matmul(tra,DM(fa:la,fb:lb)), trb)

               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + blk
               sym(fj:lj,fi:li) = sym(fj:lj,fi:li) + transpose(blk)

               imshcnt(i,j) = imshcnt(i,j) + 1
               imshcnt(j,i) = imshcnt(j,i) + 1

               tr.destroy

            end

         end

      end

      ! Divide unique blocks by symmetrisation factors
      do a = 1,.n_shell
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         do b = 1,.n_shell
            fb = .first_basis_fn_for_shell(b)
            lb = .last_basis_fn_for_shell(b)
            if (imshcnt(a,b)>0) then
               sym(fa:la,fb:lb) = sym(fa:la,fb:lb)/imshcnt(a,b)
            end
         end
      end

      ! Reset image shell block counts
      ! for symmetry-dependent blocks
    ! imshcnt = 0
    ! do a = 1,.n_shell

    !    atom_a = .atom_for_shell(a)
    !    ua = any(atom_a==.crystal.unique_frag_atom) 
    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)

    !    do b = 1,a
    !    
    !       atom_b = .atom_for_shell(b)
    !       ub = any(atom_b==.crystal.unique_frag_atom) 
    !       fb = .first_basis_fn_for_shell(b)
    !       lb = .last_basis_fn_for_shell(b)
    !      
    !       !  Unique atom block?
    !       if (NOT ua AND NOT ub) then
    !       if (imshcnt(a,b)==0) then
    !          ! Do block this time
    !          imshcnt(a,b) = 1
    !          imshcnt(b,a) = 1
    !          sym(fa:la,fb:lb) = DM(fa:la,fb:lb)
    !          sym(fb:lb,fa:la) = DM(fb:lb,fa:la)
    !       end
    !       end

    !    end

    ! end

    ! ! Symmetrise dependent blocks amonst only themselves
    ! ! This is not ideal: we probably want to copy out from
    ! ! the unique blocks. Maybe fiddle with the image array?
    ! do a = 1,.n_shell

    !    ! Only do unique (asym-atom-corresponding) frag atoms
    !    atom_a = .atom_for_shell(a)
    !    ua = any(atom_a==.crystal.unique_frag_atom)
    !    if (ua) cycle

    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)
    !    ma = .angular_moment_for_shell(a)

    !    do b = 1,a

    !       atom_b = .atom_for_shell(b)
    !       ub = any(atom_b==.crystal.unique_frag_atom)
    !       if (ub) cycle

    !       ! Do any atom for shell b
    !       fb = .first_basis_fn_for_shell(b)
    !       lb = .last_basis_fn_for_shell(b)
    !       mb = .angular_moment_for_shell(b)

    !       do g = 2,.crystal.spacegroup.n_seitz

    !          i = image(a,g)
    !          j = image(b,g)

    !          if (i==0 OR j==0) cycle

    !          !  Unique image atom block?
    !          atom_i = .atom_for_shell(i)
    !          atom_j = .atom_for_shell(j)

    !          ui = any(atom_i==.crystal.unique_frag_atom) 
    !          uj = any(atom_j==.crystal.unique_frag_atom) 

    !          if (NOT ui AND NOT uj) then

    !             fi = .first_basis_fn_for_shell(i)
    !             li =  .last_basis_fn_for_shell(i)
    !             fj = .first_basis_fn_for_shell(j)
    !             lj =  .last_basis_fn_for_shell(j)
    !            
    !             GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,symops(:,:,g))
    !            
    !             tra = tr(ma)[:,:]
    !             trb = transpose(tr(mb)[:,:])
    !             blk = matmul( matmul(tra,DM(fa:la,fb:lb)), trb)
    !            
    !             sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + blk
    !             sym(fj:lj,fi:li) = sym(fj:lj,fi:li) + transpose(blk)
    !            
    !             imshcnt(i,j) = imshcnt(i,j) + 1
    !             imshcnt(j,i) = imshcnt(j,i) + 1
    !            
    !             tr.destroy

    !          end

    !       end

    !    end

    ! end

    ! ! Divide unique blocks by symmetrisation factors
    ! do a = 1,.n_shell
    !    atom_a = .atom_for_shell(a)
    !    ua = any(atom_a==.crystal.unique_frag_atom) 
    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)
    !    do b = 1,.n_shell
    !       atom_b = .atom_for_shell(b)
    !       ub = any(atom_b==.crystal.unique_frag_atom) 
    !       fb = .first_basis_fn_for_shell(b)
    !       lb = .last_basis_fn_for_shell(b)
    !       if (NOT ua AND NOT ub) then
    !       if (imshcnt(a,b)>0) then
    !          sym(fa:la,fb:lb) = sym(fa:la,fb:lb)/imshcnt(a,b)
    !       end
    !       end
    !    end
    ! end

      DM = sym

    ! stdout.text("DM 2:")
    ! stdout.put(DM)

      ! Clean
      sym.destroy
      image.destroy
      imshcnt.destroy
      symops.destroy

   end

   symmetrize_DM_like_mx(DM) ::: get_from(symmetrize_DM_like_mx, TYPE?=>REAL), PURE
   ! Symmetrize a density matrix-like object "DM" using the crystal
   ! seitz operators. 
   end

   symmetrize_DM_like_mx(DM) ::: get_from(symmetrize_DM_like_mx, TYPE?=>CPX), PURE
   ! Symmetrize a density matrix-like object "DM" using the crystal
   ! seitz operators. 
   end


   make_sg_image_of_shell(res) ::: PURE
   ! Return an array "res(s,g)" which is the image of shell "s" under
   ! *spacegroup* operation "g" ignoring whole cell translations.
   ! Size of "res" is [.n_shell,.crystal.spacegroup.n_seitz]
      self :: IN
      res  :: MAT{INT}, OUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.spacegroup.analyzed, "crystal spacegroup not analyzed")
   ENSURE(res.dim1==.n_shell, "wrong dim2, res")
   ENSURE(res.dim2==.crystal.spacegroup.n_seitz, "wrong dim2, res")

      pg :: VEC{REAL}(3)
      g,s,as,sa,ag,fg :: INT

      res = ZERO

      do g = 1,.crystal.spacegroup.n_seitz
      do s = 1,.n_shell

         ! Get transformed atom position
         as = .atom_for_shell(s)
         pg = .atom(as).position
         .crystal.transform_xyz_position(pg,g,to_unit_cell=TRUE)

         ! Get index of rotated atom by its position
         ag = .atom.atom_index_from_position(pg)

         ! Assign
         if (ag==0) then
            res(s,g) = 0
         else
            fg = .first_shell_for_atom(ag)
            sa = .atom_shell_for_shell(s)
            res(s,g) = fg + sa - 1
         end

      end
      end

   end


   stabilize(mat) ::: template, PURE
   ! Stabilize a matrix
      self :: IN
      mat :: MAT{TYPE?}, INOUT

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,w :: MAT{TYPE?}@
      tra,trb :: MAT{REAL}@
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}@

      image.create(.n_shell,.crystal.n_stabilizer_symops)
      .:make_image_of_stabilizer(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.crystal.n_stabilizer_symops

         do a = 1,.n_shell

            tra = .crystal.xyz_stabilizer_mx(n,.angular_moment_for_shell(a))

            i  = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb = .crystal.xyz_stabilizer_mx(n,.angular_moment_for_shell(b))

               j  = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               w.create(na,nb)
               w.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(w,trb,transpose_b=TRUE)
               w.destroy

            end

         end

      end

      mat = sym/REALIFY(.crystal.n_stabilizer_symops)

      sym.destroy
      image.destroy

   end

   stabilize(mat) ::: get_from(stabilize, TYPE?=>REAL), PURE
   ! Stabilize a matrix
   end

   stabilize(mat) ::: get_from(stabilize, TYPE?=>CPX), PURE
   ! Stabilize a matrix
   end

   make_image_of_stabilizer(res) ::: PURE
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! a crystal stabilizer operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      self :: IN
      res :: MAT{INT}, OUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(res.dim1==.n_shell,                    "wromg dim1, res")
   ENSURE(res.dim2==.crystal.n_stabilizer_symops,"wromg dim2, res")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.crystal.n_stabilizer_symops
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos = matmul(.crystal.ptr(:,:,n), .atom(aa).position)

         new_atom = .atom.atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end

!  ==================
!  Archiving routines
!  ==================

   archive(opmatrix,archive_name,genre,with_lambda)
   ! Save "opmatrix" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opmatrix :: OPMATRIX
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opmatrix,genre)

      if (avec_lambda) then
        if (.scfdata.allocated) then
        if (.scfdata.SCF_kind.includes("xray_") OR .scfdata.SCF_kind.includes("pnd_")) then
   !    archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6")))
        archive.write(opmatrix,genre)
        end
        end
      end

   end

   archive(opvector,archive_name,genre,with_lambda)
   ! Save "opvector" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opvector,genre)
      if (avec_lambda) then
        if (.scfdata.allocated) then
        if (.scfdata.SCF_kind.includes("xray_") OR .scfdata.SCF_kind.includes("pnd_")) then
    !   archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6")))
        archive.write(opvector,genre)
        end
        end
      end
   end

   archive(item,archive_name,genre,with_lambda)
   ! Save "item" to an archive on disk with name "archive_name".
      self :: IN
      item :: REAL, IN
      archive_name :: STR, IN
      genre :: STR, optional, IN
      with_lambda :: BIN, optional, IN

      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(item,genre)

      if (avec_lambda) then
         if (.scfdata.allocated) then
         if (.scfdata.SCF_kind.includes("xray_") OR .scfdata.SCF_kind.includes("pnd_")) then
     !   archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
         archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6")))
         archive.write(item,genre)
         end
         end
      end

   end

   unarchive(opmatrix,archive_name,genre) ::: leaky
   ! Recover the "opmatrix" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opmatrix".
      self :: INOUT
      opmatrix :: OPMATRIX@, OUT
      archive_name :: STR, IN
      genre :: STR, optional, IN

   ENSURE(opmatrix.has_any_genre,"no opmatrix genre created")

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opmatrix,genre)

   end

   unarchive(opvector,archive_name,genre) ::: leaky
   ! Recover the "opvector" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opvector".
      self :: INOUT
      opvector :: OPVECTOR, OUT
      archive_name :: STR, IN
      genre :: STR, optional, IN

   ENSURE(opvector.has_any_genre,"no opvector genre created")

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opvector,genre)

   end

   unarchive(item,archive_name,genre) ::: leaky
   ! Recover the "item" from an archive on disk with name "archive_name".
      self :: INOUT
      item :: REAL, OUT
      archive_name :: STR, IN
      genre :: STR, optional, IN

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(item,genre)

   end

!   unarchive(archive_name,genre) ::: template
!   ! Recover the object from an archive on disk
!      self :: INOUT
!      archive_name :: STR, optional, IN
!      genre :: STR, optional, IN
!
!   ENSURE(.basis_info_made,"no basis set info")
!
!      name :: STR
!
!      name = "NAME?"
!      if (present(archive_name)) name = archive_name
!      if (.NAME?.deallocated) then
!         ENSURE(present(genre),"missing genre")
!         .NAME?.create(.n_bf,genre)
!      end
!      .unarchive(.NAME?,name,genre)
!
!   end

   delete_archive(name)
   ! Delete the archive called "name"
      self :: IN
      name :: STR, IN

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,name)
      archive.delete_all_genres

   end

   archive_exists(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      self :: IN
      archive_name :: STR, IN
      genre :: STR, IN
      res :: BIN

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = archive.exists

   end

   archive_doesnt_exist(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      self :: IN
      archive_name :: STR, IN
      genre :: STR, IN
      res :: BIN

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = NOT archive.exists

   end

!  ===========
!  SCF archive
!  ===========

   read_SCF_archives ::: leaky
   ! Copy the natural orbitals to be the MOs.
   ! If thw MO's are not there, try and read them from disk.
   ! The occupation numbers are the MO ones.
      self :: INOUT

      genre :: STR
      arch :: ARCHIVE

      ! Get MO's 
      if (.MOs.allocated) then
         ! Already there
         genre = .MOs.genre
      else if (.scfdata.allocated) then
         ! Does it exist as on disk?
         genre = .scfdata.spinorbital_genre
         arch.set(.name,"MOs",genre)
         if (arch.exists) then
            .MOs.create(.n_bf)
            arch.read(.MOs)
            .MOs.unnormalise("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.close
         end
      end
      
      ! Get density matrix
      if (.density_mx.allocated) then
         ! Already there
         genre = .density_mx.genre
      else if (.scfdata.allocated) then
         ! Does it exist on disk?
         genre = .scfdata.spinorbital_genre
         arch.set(.name,"density_mx",genre)
         if (arch.exists) then
            .density_mx.create(.n_bf)
            arch.read(.density_mx)
            .density_mx.unnormalise(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.close
         end
      end

      ! Get orbital energies
      if (.MO_energies.deallocated) then
      if (.scfdata.allocated) then
         genre = .scfdata.spinorbital_genre
         .MO_energies.create(.n_bf,genre)
         ! Does it exist on disk?
         arch.set(.name,"MO_energies",genre)
         if (arch.exists) then
            arch.read(.MO_energies)
            arch.close
         end
      end
      end
      
      ! Clone the MO's
      if (.MOs.allocated) then
         .NOs = .MOs
         .NO_occ_nos.create(.n_bf,genre)
         .NO_occ_nos.set_to_zero
         .:set_SCF_occupations_for_NOs(genre)
      end

   end

! May be needed by involved non-SCF routines

   delete_SCF_archives(keep_MOs,keep_DM) ::: recursive
   ! Delete any SCF-procedure generated archives stored on disk.
      self :: IN
      keep_MOs :: BIN, optional, IN
      keep_DM  :: BIN, optional, IN

      archive :: ARCHIVE
      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      archive.set_defaults

      if (delete_MOs) then
      archive.set(.name,"MOs");                     archive.delete_all_genres
      archive.set(.name,"MO_energies");             archive.delete_all_genres
      end                                          
                                                   
      if (delete_DM) then                          
      archive.set(.name,"density_mx");              archive.delete_all_genres
      end                                          
                                                   
      archive.set(.name,"Fock_mx");                 archive.delete_all_genres
      archive.set(.name,"NOs");                     archive.delete_all_genres
      archive.set(.name,"NO_occ_nos");              archive.delete_all_genres
      archive.set(.name,"energy");                  archive.delete_all_genres

      archive.set(.name,"promolecule_density_mx");  archive.delete_all_genres
      archive.set(.name,"group_density_mx");        archive.delete_all_genres
      archive.set(.name,"group_MOs");               archive.delete_all_genres

      archive.set(.name,"U_electric_dipole");       archive.delete_all_genres
      archive.set(.name,"U2_electric_dipole");      archive.delete_all_genres

      archive.set(.name,"J_mx");                    archive.delete_all_genres
      archive.set(.name,"constraint_mx");           archive.delete_all_genres

      archive.set(.name,"ERI_integrals");           archive.delete_all_genres
      archive.set(.name,"ERI_index");               archive.delete_all_genres

      ! WARNING: These two below are recursive
      .:delete_atom_SCF_archives
      .:delete_group_SCF_archives(keep_MOs,keep_DM)

      .:delete_lambda_SCF_archives(keep_MOs)

   end

   delete_lambda_SCF_archives(keep_MOs) ::: private
   ! Delete any lambda type archives stored on disk.
      self :: IN
      keep_MOs :: BIN, optional, IN

      l,l_max :: REAL
      l_str :: STR(len=5)
      archive :: ARCHIVE
      delete_MOs :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      if (NOT delete_MOs)                  return
      if (.scfdata.deallocated)              return
      if (NOT .scfdata.is_constrained_scf) return

      archive.set_defaults
      l = .scfdata.initial_lambda
      l_max = .scfdata.lambda_max + l

      do
         if (l>l_max) exit
         l_str = trim(l.to_str("f5.3"))
         archive.set(.name,"MOs,lambda="//trim(l_str)); archive.delete_all_genres
         archive.set(.name,"MO_energies,lambda="//trim(l_str));   archive.delete_all_genres
         l = l + .scfdata.lambda_step
      end

   end

   delete_atom_SCF_archives ::: recursive, leaky
   ! Delete the atom SCF archives, if they exist.
      self :: IN

      a :: INT
      mol :: MOLECULE@

      if (.n_atom_kind<=0) return

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Delete
         mol.:create
         mol.name = .atom(a).chemical_symbol
         mol.:delete_SCF_archives
         mol.:destroy

      end

   end

   delete_group_SCF_archives(keep_MOs,keep_DM) ::: recursive, private
   ! Delete any group type SCF archives.
      self :: IN
      keep_MOs :: BIN, optional, IN
      keep_DM  :: BIN, optional, IN

      g :: INT

      if (.atom_group.deallocated) return
      if (.mol.deallocated) return

      do g = 1,.atom_group.dim
         .mol(g).:delete_SCF_archives(keep_MOs,keep_DM)
      end

   end

   delete_SCF_MO_archive
   ! Delete the SCF MO archives
      self :: IN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,"MOs"); archive.delete_all_genres
      archive.set(.name,"MO_energies");   archive.delete_all_genres
   end

!  ======
!  Output
!  ======

   put
   ! Put all the available molecule information on file
      self :: INOUT

   DIE_IF(tonto.deallocated,"no tonto variable")

      .:put_basics

      ! Stop here for low verbosity
      if (tonto.low_verbosity) then
      if (.atom.allocated) then
         if (.atom.dim>100) return
      end
      end

      ! Atoms coordinates, basis sets
      if (.atom.allocated) .:put_atoms ! INOUT

      ! Atom groups
      if (.atom_group.allocated) .:put_atom_groups

      ! Stop here for proteins
      if (.crystal.use_Ryde_capping) then
      if (.atom.allocated) then
         if (.atom.dim>100) return
      end
      end

      if (.pointgroup.allocated)  .:put_pointgroup
      if (.crystal.allocated)     .:put_crystal
      if (.cluster.allocated)     .:put_cluster
      if (.becke_grid.allocated)   .:put_becke_grid

      if (.overlapping_atoms.allocated AND .atom.allocated) then
         .:put_overlapping_atoms
         .:put_overlapping_atoms_4_atom
      end

   end

   put_basics
   ! Put basic molecule information
      self :: IN

      stdout.flush
      stdout.flush
      stdout.text("====================")
      stdout.text("Molecule information")
      stdout.text("====================")

      stdout.flush
      stdout.show("Name                   =",.name)

      stdout.flush
      stdout.show("Chemical Formula       =",trim(.atom.chemical_formula(with_spaces=TRUE)))
      stdout.show("Molecular weight       =",.atom.molecular_weight)

      stdout.flush
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.spin_multiplicity)

      stdout.flush
      stdout.show("No. of atoms           =",.n_atom)
      stdout.show("No. of electrons       =",.n_e)
      stdout.show("No. of alpha electrons =",.n_a)
      stdout.show("No. of beta  electrons =",.n_b)

      if (.atom.has_all_bases) stdout.flush
      if (.basis_name/=" ") then
      stdout.show("Gaussian basis name    =",.basis_name)
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      end
      if (.slaterbasis_name/=" ") &
      stdout.show("Slater basis name      =",.slaterbasis_name)
      if (.coppensbasis_name/=" ") &
      stdout.show("Coppens basis name     =",.coppensbasis_name)

      if (NOT .E_field.is_zero) &
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      if (NOT .B_field.is_zero) &
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      if (NOT .gauge_origin.is_zero) &
      stdout.show("B field Gauge origin   =",.gauge_origin)

   end

   put_atoms
   ! Output the atom coordinate and basis set information
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")

      .atom.put_coordinate_info

      .atom.put_core_electrons

      if (.basis.allocated)        .:put_bases ! INOUT
    ! if (.coppensbasis.allocated) .put_coppensbases
    ! if (.slaterbasis.allocated)  .put_slaterbases

    ! .atom.put_ADPs

   end

   put_basics_and_atoms
   ! Output minimal atom info without crystal info.
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")

      .:put_basics
      .:put_atoms ! INOUT
      .:put_bases

   end

   put_ADPs
   ! Output the ADPs in cartesian axes
     self :: IN

   ENSURE(.atom.allocated,"no atom list")

      .atom.put_ADPs

   end


   put_bond_length_with_error ::: leaky
   ! Read two atoms, and output the bond length with associated error
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no diffraction data")
   ENSURE(.crystal.xray_data.covariance_mx.allocated,"no cov matrix created")

      cm :: MAT{REAL}@
      a1,a2,n_f :: INT

      ! Read the two atoms
      stdin.read(a1)
      stdin.read(a2)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.xray_data.fragment_covariance_mx.destroy
      .crystal.xray_data.fragment_covariance_mx.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx ! INOUT

      ! Extract positional-covariances
      .crystal.make_pos_covariance_mx(cm)

      ! Put the bond length
      .atom.put_bond_length_with_error(a1,a2,cm)

      ! Clean
      cm.destroy

   end

   put_bond_angle_with_error ::: leaky
   ! Output the atom coordinate and basis set information
   ! Read three atoms, and output the bond angle with associated error
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no diffraction data")
   ENSURE(.crystal.xray_data.covariance_mx.allocated,"no cov matrix created")

      cm :: MAT{REAL}@
      a1,a2,a3,n_f :: INT

      ! Read the three atoms defining the angle
      stdin.read(a1)
      stdin.read(a2)
      stdin.read(a3)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.xray_data.fragment_covariance_mx.destroy
      .crystal.xray_data.fragment_covariance_mx.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx ! INOUT

      ! Extract positional-covariances
      .crystal.make_pos_covariance_mx(cm)

      ! Put the bond angle
      .atom.put_bond_angle_with_error(a1,a2,a3,cm)

      cm.destroy

   end

   put_torsion_angle_with_error ::: leaky
   ! Output the atom coordinate and basis set information
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"no crystal")
   ENSURE(.crystal.xray_data.allocated,"no diffraction data")
   ENSURE(.crystal.xray_data.covariance_mx.allocated,"no cov matrix created")

      cm :: MAT{REAL}@
      a1,a2,a3,a4,n_f :: INT

      ! Read the three atoms defining the angle
      stdin.read(a1)
      stdin.read(a2)
      stdin.read(a3)
      stdin.read(a4)

      ! No. of fragment atoms
      n_f = .crystal.fragment_atom.no_of_pADPs

      ! Set fragment covariance matrix
      .crystal.xray_data.fragment_covariance_mx.destroy
      .crystal.xray_data.fragment_covariance_mx.create(n_f,n_f)
      .crystal.set_frag_from_asym_cov_mx ! INOUT

      ! Extract positional-covariances
      .crystal.make_pos_covariance_mx(cm)

      ! Put the torsion angle
      .atom.put_torsion_angle_with_error(a1,a2,a3,a4,cm)

      ! Clean
      cm.destroy

   end


   put_principal_axes
   ! Output the atom principal axes
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list")

      .atom.put_principal_axes

   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
      self :: INOUT

      if (NOT .basis.allocated) return

      ! Put atom basis tags
      .atom.put_bases

      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian basis sets")
      stdout.text("===================")
      stdout.flush
      stdout.show("Basis name             =",.basis_name)
      stdout.flush
      if (.use_spherical_basis) &
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      stdout.flush

      .basis.renormalise ! INOUT
      .basis.put
      .basis.unnormalise

   end

   put_slaterbases
   ! Output the molecule slaterbasis set information, if the bases are
   ! all resolved.
      self :: IN

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.slaterbasis.allocated,"no basis set list")

      if (NOT .atom.slaterbases_are_resolved) return

      stdout.flush
      stdout.text("Molecule atom slaterbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.slaterbasis.dim)

      .slaterbasis.put

   end

   put_coppensbases
   ! Output the molecule coppensbasis set information, if the bases are all
   ! resolved.
      self :: IN

   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.coppensbasis.allocated,"no basis set list")

      if (NOT .atom.coppensbases_are_resolved) return

      stdout.flush
      stdout.text("Molecule atom coppensbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.coppensbasis.dim)
      stdout.show("Maximum N value   =",.coppensbasis.maximum_basis_n_value)
      stdout.show("No. of orbitals   =",.coppensbasis.no_of_orbitals)
      stdout.show("No. of primitives =",.coppensbasis.no_of_primitives)

      .coppensbasis.put

   end

   put_atom_groups
   ! Output the .atom_group info array
      self :: INOUT

   ENSURE(.atom_group.allocated,"no atom group information")

      .atom_group.put
      .:put_atom_group_mols
      
   end

   put_atom_group_mols
   ! Output each .atom_group.mol info
      self :: INOUT

   ENSURE(.atom_group.allocated,"no .atom_group information")
   ENSURE(.mol.allocated,"no .mol information")

      name :: STR
      g :: INT

      ! Output fragment info
      do g = 1,.atom_group.dim
      
         ! Minimal stdout for fragment
         name = trim(.atom_group(g).name)
         stdout.redirect(name)
       ! .mol(g).:put_basics_and_atoms
         .mol(g).:put ! INOUT
         stdout.revert
        
         ! Even more minimal xyz for plotting
         .mol(g).atom.put_xyz_file(name)
      
      end

   end

   put_overlapping_atoms
   ! Out out the .overlapping_atom info array
      self :: IN

   ENSURE(.overlapping_atoms.allocated,"no overlapping_atoms")
   ENSURE(.atom.allocated,"no atoms")

      i,j,k :: INT

      stdout.save
      stdout.set_int_width(4)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms:")
      stdout.text(" ")

      do i = 1,.atom.dim
         k = 1
         stdout.put(i)
         do j = 1,.atom.dim
            if (NOT .:is_overlapping_atom(i,j)) cycle
            k = k + 1
            stdout.put(j)
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave

   end

   put_overlapping_atoms_4_atom
   ! Out out the .overlapping_atoms_for_atom info array
      self :: IN

   ENSURE(.overlapping_atoms.allocated,"no overlapping_atoms")
   ENSURE(.atom.allocated,"no atoms")

      i,j,k :: INT

      stdout.save
      stdout.set_int_width(4)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms for atom:")
      stdout.text(" ")

      do i = 1,.atom.dim
         stdout.put(i)
         k = 1
         do j = 1,.overlapping_atoms_for_atom(i).element.dim
            k = k + 1
            stdout.put(.overlapping_atoms_for_atom(i)[j])
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave

   end

   put_pointgroup
   ! Output the current pointgroup
      self :: IN

      .pointgroup.put

   end

   put_plot_grid
   ! Output the current grid.
   ENSURE(.plot_grid.allocated,"no plot grid to output")
      .plot_grid.put
   end

   put_becke_grid
   ! Output the current DFT grid.
      self :: IN

   ENSURE(.becke_grid.allocated,"no Becke integration grid to output")

      .becke_grid.put

   end

   put_crystal
   ! Output the current crystal
      self :: INOUT

      .crystal.put

   end

   put_cluster
   ! Put out the cluster information
      self :: IN

   ENSURE(.cluster.allocated,"no cluster data")

      .cluster.put

   end

   put_MOs
   ! Output the current associated molecular orbitals
      self :: IN

      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.MOs)

   end

   put_MOs_and_energies
   ! Output the current associated molecular orbitals and their energies
      self :: IN

      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.MO_energies)
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.MOs)

   end

   put_MO_energies
   ! Output the molecular orbital energies
      self :: IN

      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.MO_energies)

   end

   put_NOs
   ! Output the current associated molecular orbitals
      self :: IN

      stdout.flush
      stdout.text("NO occupation numbers:")
      stdout.put(.NO_occ_nos)

      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.NOs)

   end

   put_density_mx
   ! Output the current associated density matrix
      self :: IN

   ENSURE(.density_mx.allocated,"no density matrix")

      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_mx)

   end

   put_fock_mx
   ! Output the current associated fock matrix
      self :: IN

   ENSURE(.fock_mx.allocated,"no fock matrix")

      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_mx)

   end


   put_vrml
   ! Output a VRML file for the coordinate geometry
      self :: INOUT

   ENSURE(.atom.allocated,"no atom list!")

      out :: TEXTFILE*

      out.create(trim(.name)//achar(46)//"wrl")
      out.open_for("write")
      stdout.text("Generating VRML molecule")
      out.text("#VRML V2.0 utf8")
      out.text("NavigationInfo { type " // achar(34) // "EXAMINE" // achar(34) // " }")
      out.text("Viewpoint { ")
      out.text("position 0 0 10")
      out.text("fieldOfView 1")
      out.text("orientation 0 0 1 0")
      out.text('description "camera z"')
      out.text("}")
      out.text("DirectionalLight {")
      out.text("  color 1 1 1")
      out.text("  direction 1 0 0")
      out.text("  intensity 0.4")
      out.text("}")
      .atom.put_vrml(out)
      if (.isosurface.allocated) .isosurface.put_vrml(out) ! INOUT
      stdout.text("done VRML molecule")

   end

!  =====
!  ANO's
!  =====

   put_ANOs ::: leaky
   ! Put the ANO data out for all atoms in the molecule.
      self :: IN

   ENSURE(.atom.allocated,"no atoms")

      k,a,b :: INT
      list :: STR

      if (NOT .:has_all_ANO_matrices) return

      if (.n_atom_kind<=0) return

      stdout.flush
      stdout.text("========")
      stdout.text("ANO data")
      stdout.text("========")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle
         k = .atom(a).kind

         list = trim(a.to_str)
         do b = a+1,.n_atom
            if (.atom(b).kind/=k) cycle
            list = trim(list)//" "//trim(b.to_str)
         end
         list = "ANO's for atoms ... "//trim(list)

         stdout.flush
         stdout.text(repeat("=",len_trim(list)))
         stdout.text(list)
         stdout.text(repeat("=",len_trim(list)))
         .atom(a).put_ANOs
         stdout.flush

      end

   end

!  =======
!  Put CIF
!  =======

   put_grown_CIF(with_ESDs)
   ! Prints out fragment cif file.
   ! Does only cartesian axes.
   ! NOTE: IF "with_esds" is present and TRUE, it is assumed
   ! that the covariances from a refinement are present, and
   ! these are used to make the ESDs; otherwise ESDs are still
   ! made by transforming in a straightforward way.
      self :: INOUT
      with_ESDs :: BIN, optional, IN

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean,change_ESDs,H_U_iso :: BIN

      ! Make sure CIF is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".cif")
      end

      ! Cartesian fragment/CIF2
      .cif.set_use_CIF2(TRUE)
      stdout.redirect(trim(.name)//".cartesian.cif2")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
      .crystal.put_fragment_CIF(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.xray_data.allocated) H_U_iso = .crystal.xray_data.refine_H_U_iso

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_CIFs(with_ESDs)
   ! Prints out an asymmetric and fragment cif file.
   ! Does both cartesian and crystal axes.
   ! NOTE: IF "with_esds" is present and TRUE, it is assumed
   ! that the covariances from a refinement are present, and
   ! these are used to make the ESDs; otherwise ESDs are still
   ! made by transforming in a straightforward way.
      self :: INOUT
      with_ESDs :: BIN, optional, IN

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean,change_ESDs,H_U_iso :: BIN
      title :: STR

      ! Make sure CIF is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".cif")
      end

      ! Cartesian fragment/CIF2
      .cif.set_use_CIF2(TRUE)

      ! Set title
      title = .name
      if (.scfdata.allocated) then
      if (.scfdata.is_constrained_wavefunction) then
         title = trim(title)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))
      end
      end
      if (.plot_grid.allocated) then
      if (.plot_grid.plot_label/=" ") then
         title = trim(title)//","//trim(.plot_grid.plot_label)
      end
      end

      ! Redirect
      stdout.redirect(trim(title)//".cartesian.cif2")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
      .crystal.put_fragment_CIF(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.xray_data.allocated) H_U_iso = .crystal.xray_data.refine_H_U_iso

      ! Put refection files
      .:put_tonto_fcf 
      .:put_xd_fco

      ! Crystal asymmetric-unit/CIF1
      .cif.set_use_CIF2(FALSE)

      ! Redirect
      stdout.redirect(trim(title)//".HBB.cif2")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
      .crystal.put_fragment_CIF_HBB(.cif)
      stdout.revert

      ! Sanity check for errors
      change_ESDs = TRUE
      if (present(with_ESDs)) change_ESDs = NOT with_ESDs

      ! Alter sigma(U_iso) for H atoms?
      H_U_iso = FALSE
      if (.crystal.xray_data.allocated) H_U_iso = .crystal.xray_data.refine_H_U_iso

      ! Put refection files
      .:put_tonto_fcf 
      .:put_xd_fco

      ! Crystal asymmetric-unit/CIF1
      .cif.set_use_CIF2(FALSE)

      ! Redirect
      stdout.redirect(trim(title)//".archive.cif")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
    ! .crystal.asymmetric_unit_atom.change_axis_system_to("crystal",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.asymmetric_unit_atom.change_axis_system_to("crystal",.crystal.unit_cell,change_ESDs)
      .crystal.put_asymm_unit_CIF(.cif)
    ! .crystal.asymmetric_unit_atom.change_axis_system_to("cartesian",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.asymmetric_unit_atom.change_axis_system_to("cartesian",.crystal.unit_cell,change_ESDs)
      .crystal.put_asymm_unit_CIF_bond_info ! Must be cartesian
      stdout.revert

      ! Put other files
!     if (.crystal.xray_data.allocated) then
!     if (.crystal.xray_data.reflections.allocated) then

      ! .:put_shelx_hkl3
      ! .:put_shelx_hkl4
      ! .:put_shelx_fcf5
      ! .:put_shelx_fcf6

      ! Crystal fragment/CIF1
      .cif.set_use_CIF2(FALSE)

      ! Redirect
      stdout.redirect(trim(title)//".fractional.cif1")
      .:put_CIF_banner(.cif.use_CIF2)
      .:put_CIF_basics
      .:put_CIF_wavefunction
    ! .crystal.fragment_atom.change_axis_system_to("crystal",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.fragment_atom.change_axis_system_to("crystal",.crystal.unit_cell,change_ESDs)
      .crystal.put_fragment_CIF(.cif)
    ! .crystal.fragment_atom.change_axis_system_to("cartesian",.crystal.unit_cell,H_U_iso,change_ESDs)
      .crystal.fragment_atom.change_axis_system_to("cartesian",.crystal.unit_cell,change_ESDs)
      .crystal.put_fragment_CIF_bond_info   ! Must be cartesian
      stdout.revert

 !     end
 !     end

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_CIF_banner(CIF2) ::: private
   ! Prints out the CIF banner, with "CIF2" format if needed.
      self :: IN
      CIF2 :: BIN, IN

      date :: STR

      if (CIF2) then
      stdout.text("#\#CIF_2.0")
      stdout.flush
      end

      stdout.text("# ========================")
      stdout.text("# Tonto generated CIF file")
      stdout.text("# ========================")
      stdout.flush
      stdout.text("# NOTE: This is an incomplete CIF file")
      stdout.text("# Manually edit it to pass checkCIF")
      stdout.flush
      stdout.text("data_"//trim(.name))
      stdout.flush
      date = TIME:current_date_YMD_str()
      stdout.text("_audit_creation_date                "//trim(date))
      stdout.text("_audit_creation_method              'Tonto "//TONTO_VERSION//" github v. "//GIT_VERSION//"'")

      stdout.flush
      stdout.text("# ============")
      stdout.text("# QCr software")
      stdout.text("# ============")

      stdout.flush
      stdout.text("_QCr_software                       'Tonto'")
      stdout.text("_QCr_software_version               '"//TONTO_VERSION//" v. "//GIT_VERSION//"'")
      stdout.text("_QCr_software_platform              '"//TONTO_PLATFORM//"'")
      stdout.text("_QCr_software_build_date            '"//TONTO_BUILD_DATE//"'")
      stdout.text("_QCr_software_website               'https://github.com/dylan-jayatilaka/tonto'")

   end

   put_CIF_basics ::: private
   ! Put basic molecule information
      self :: IN

      stdout.flush
      stdout.text("# ===========")
      stdout.text("# Publication")
      stdout.text("# ===========")

      stdout.flush
      stdout.text("_publ_contact_author")
      stdout.text(";")
      stdout.text("    Prof. Dr. Sir Tonto Magnifico")
      stdout.text(";")
      stdout.text("_publ_contact_author_email          'tonto.magnifico@gmail.com'")
      stdout.text("_publ_contact_author_phone          '+61 8 6488 3138'")
      stdout.text("_publ_requested_journal             'IUCrJ'")
      stdout.text("_publ_section_title")
      stdout.text(";")
      stdout.text("   'Hirshfeld atom-refinement (HAR) for "//trim(.name)//"'")
      stdout.text("   'X-ray wavefunction refinement (XWR) for "//trim(.name)//"'")
      stdout.text("   Tonto Magnifico, IUCrJ (XXXX)")
      stdout.text(";")

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _publ_author_name")
      stdout.text("    'Tonto Magnifico'")

      stdout.flush
      stdout.text("_publ_author_address")
      stdout.text(";")
      stdout.text("    Prof. Dr. Sir Tonto Magnifico")
      stdout.text("    1 El Camino Ciberespacio")
      stdout.text("    Tierra Austral del Espiritu Santo")
      stdout.text(";")

      stdout.flush
      stdout.text("# ========")
      stdout.text("# Chemical")
      stdout.text("# ========")

      stdout.flush
      stdout.text("_chemical_name_common               "//trim(.name))
      stdout.text("_chemical_formula_sum               '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_moiety            '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_weight            "//trim(REAL:to_str(.atom.molecular_weight,"f10.4")))
      stdout.text("_chemical_compound_source           'see text'")
      stdout.text("_chemical_absolute_configuration    unk")


   end

   put_CIF_wavefunction ::: private
   ! Put the wavefunction information out
      self :: IN

      psi :: VEC{STR}(19)

      if (.scfdata.deallocated) return
      if (.basis.deallocated) return

      ! Get wavefunction details
      psi = .:wavefunction_descriptor

      stdout.flush
      stdout.text("# ==========")
      stdout.text("# QCr method")
      stdout.text("# ==========")

      stdout.flush
      stdout.text("_QCr_calc_method                    '"//trim(psi(1))//"'")
      stdout.text("_QCr_calc_spinorbital_genre          '"//trim(psi(2))//"'")
      stdout.text("_QCr_calc_gaussian_basis_set        '"//trim(psi(3))//"'")
      stdout.text("_QCr_calc_gaussian_basis_set_kind   '"//trim(psi(4))//"'")
      stdout.text("_QCr_calc_basis_max_l               '"//trim(psi(5))//"'")

      stdout.flush
      stdout.text("_QCr_calc_unit                      'See _atom_site_* in tonto.cif2'")
      stdout.text("_QCr_calc_unit_spin_multiplicity    "//trim(INT:to_str(.spin_multiplicity)))
      stdout.text("_QCr_calc_unit_n_electrons          "//trim(INT:to_str(.n_e)))
      stdout.text("_QCr_calc_unit_n_alpha_electrons    "//trim(INT:to_str(.n_a)))
      stdout.text("_QCr_calc_unit_n_beta_electrons     "//trim(INT:to_str(.n_b)))
                                                    
      if (psi(6)/="?") then
      stdout.flush
      stdout.text("_QCr_Becke_grid_kind                "//trim(psi( 6)))
      stdout.text("_QCr_Becke_grid_accuracy            "//trim(psi( 7)))
      stdout.text("_QCr_Becke_grid_L_angular_grid      "//trim(psi(17)))
      stdout.text("_QCr_Becke_grid_L_H_angular_grid    "//trim(psi(18)))
      stdout.text("_QCr_Becke_grid_reduce_L_H_ang_grid "//trim(psi(19)))
      stdout.text("_QCr_Becke_grid_core_pruning_scheme "//trim(psi( 8)))
      stdout.text("_QCr_Becke_grid_scale_H-He_grid     "//trim(psi(11)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_1     "//trim(psi(12)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_2     "//trim(psi(13)))
      stdout.text("_QCr_Becke_grid_n_pts_for_row_3     "//trim(psi(14)))
      stdout.text("_QCr_Becke_grid_n_radial_H_pts      "//trim(psi(15)))
      stdout.text("_QCr_Becke_grid_H_pts_per_n_shell   "//trim(psi(16)))
      stdout.text("_QCr_Becke_grid_basis_fn_cutoff     "//trim(psi( 9)))
      stdout.text("_QCr_Becke_grid_rho_cutoff          "//trim(psi(10)))
      end

   end

   wavefunction_descriptor result (psi) ::: private
   ! Get the wavefunction details. Only call this if an SCF
   ! calculation was completed!
      self :: IN
      psi :: VEC{STR}(19)

   ENSURE(.scfdata.allocated,"no SCF data!")

      field :: STR
      radius :: REAL
      L :: INT

      psi = "?"

      if (.scfdata.deallocated) return

      ! QM method
      psi(1) = "Hartree-Fock"
      if (.scfdata.is_DFT_calculation) then
         psi(1) = "Kohn-Sham/"// &
                  trim(.scfdata.DFT_exchange_functional)// &
                  trim(.scfdata.DFT_correlation_functional)
      end

      if (.scfdata.using_cluster_charges) then

         ! Add crystal field
         field = "CF"
         if (.scfdata.using_SC_cluster_charges) field = "SCCF"

         ! Add L
         if (.scfdata.using_qq_cluster_charges) then
            field = trim(field)//" L=2"
         else
            field = trim(field)//" L=1"
         end

         ! Radius
         radius = .scfdata.cluster_radius*ANGSTROM_PER_BOHR

         ! All bits
         psi(1) = trim(psi(1))//"/"//   &
                  trim(field) //" R="// &
                  trim(radius.to_str("f3.1"))//" A"
      end

      ! AO kind
      psi(2) = .scfdata.spinorbital_genre

      ! Basis
      psi(3) = "custom?"
      if (.basis_name/=" ") psi(3) = trim(.basis_name)

      ! Basis kind
      psi(4) = "cartesian"
      if (.use_spherical_basis) psi(4) = "spherical-harmonic"

      ! Basis max L
      L = .basis.maximum_basis_set_l_value
      psi(5) = trim(L.to_str)

      ! Becke grid
      if (.scfdata.is_DFT_calculation) then
      if (.becke_grid.allocated) then
      psi( 6) = trim(.becke_grid.kind)
      psi( 7) = trim(.becke_grid.accuracy)
      psi( 8) = trim(.becke_grid.pruning_scheme)
      psi( 9) = trim(.becke_grid.basis_function_cutoff.to_str(fmt="e6.1"))
      psi(10) = trim(.becke_grid.rho_cutoff.to_str(fmt="e6.1"))
      psi(11) = trim(.becke_grid.scale_atomic_grids.to_str)
      psi(12) = trim(INT:to_str(.becke_grid.no_of_points_for_row(1)))
      psi(13) = trim(INT:to_str(.becke_grid.no_of_points_for_row(2)))
      psi(14) = trim(INT:to_str(.becke_grid.no_of_points_for_row(3)))
      psi(15) = trim(.becke_grid.n_radial_points.to_str)
      psi(16) = trim(.becke_grid.n_extra_points_per_shell.to_str)
      psi(17) = trim(.becke_grid.l_angular_grid.to_str)
      psi(18) = trim(.becke_grid.l_H_angular_grid.to_str)
      psi(19) = trim(.becke_grid.reduce_H_angular_grid.to_str)
      end
      end

   end

   put_shelx_hkl3
   ! Prints out reflections in shelx hkl3 format
      self :: INOUT

   ENSURE(.atom.allocated, "No atom")
   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.crystal.xray_data.allocated, "No crystal diffraction data")
   ENSURE(.crystal.xray_data.reflections.allocated, "No crystal reflections")

      ! Fragment
      stdout.redirect(trim(.name)//".hkl3")
      .crystal.xray_data.reflections.put_shelx_hkl3
      stdout.revert

   end

   put_shelx_hkl4
   ! Prints out reflections in shelx hkl4 format
      self :: INOUT

   ENSURE(.atom.allocated, "No atom")
   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.crystal.xray_data.allocated, "No crystal diffraction data")
   ENSURE(.crystal.xray_data.reflections.allocated, "No crystal reflections")

      ! Fragment
      stdout.redirect(trim(.name)//".hkl4")
      .crystal.xray_data.reflections.put_shelx_hkl4
      stdout.revert

   end

   put_shelx_fcf5
   ! Prints out just the reflection information plus minimal
   ! extra stuff as in the shelx fcf LIST=5 file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".fcf5")
      end

      ! Fragment
      stdout.redirect(trim(.name)//".fcf5")
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_shelx_fcf5
      stdout.revert

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_shelx_fcf6
   ! Prints out just the reflection information plus minimal
   ! extra stuff as in the shelx fcf LIST=6 file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".fcf6")
      end

      ! Fragment
      stdout.redirect(trim(.name)//".fcf6")
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_shelx_fcf6
      stdout.revert

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_tonto_fcf
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".archive.fcf")
      end

      ! Fragment
      stdout.save
      stdout.redirect(trim(.name)//".archive.fcf")
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_tonto_fcf
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_tonto_fcf_XCW
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         if (.scfdata.do_outputs) then
            if (NOT .scfdata.exceeded_lambda_max) then
               .cif.create(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fcf")
            else
               .cif.create(trim(.name)//".archive.fcf")
            end
         else
            .cif.create(trim(.name)//".archive.fcf")
         end
      end

      ! Fragment
      stdout.save
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
            stdout.redirect(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fcf")
         else
            stdout.redirect(trim(.name)//".archive.fcf")
         end
      else
         stdout.redirect(trim(.name)//".archive.fcf")
      end
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_tonto_fcf
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_olex_fcf_XCW
   ! Prints out the tonto fcf file
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         if (.scfdata.do_outputs) then
            if (NOT .scfdata.exceeded_lambda_max) then
               .cif.create(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".olex.fcf")
            else
               .cif.create(trim(.name)//".archive.fcf")
            end
         else
            .cif.create(trim(.name)//".archive.fcf")
         end
      end

      ! Fragment
      stdout.save
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
            stdout.redirect(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".olex.fcf")
         else
            stdout.redirect(trim(.name)//".archive.fcf")
         end
      else
         stdout.redirect(trim(.name)//".archive.fcf")
      end
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_Olex2_fcf("'all reflections are used'")
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_xd_fco
   ! Prints out just the F2 reflection information plus minimal
   ! extra stuff as in the XD fco file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         .cif.create(trim(.name)//".archive.fco")
      end

      ! Fragment
      stdout.save
      stdout.redirect(trim(.name)//".archive.fco")
      stdout.set_int_width(5)
      stdout.set_real_precision(4)
      stdout.set_real_width(13)
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_xd_fco
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end

   put_xd_fco_XCW
   ! Prints out just the F2 reflection information plus minimal
   ! extra stuff as in the XD fco file.
      self :: INOUT

   ENSURE(.crystal.allocated, "No crystal")
   ENSURE(.atom.allocated, "No atom")

      clean :: BIN

      ! Make sure CIF object is there ...
      clean = FALSE
      if (.cif.deallocated) then
         clean = TRUE
         if (.scfdata.do_outputs) then
            if (NOT .scfdata.exceeded_lambda_max) then
               .cif.create(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fco")
            else
               .cif.create(trim(.name)//".archive.fco")
            end
         else
            .cif.create(trim(.name)//".archive.fco")
         end
      end

      ! Fragment
      stdout.save
      if (.scfdata.do_outputs) then
         if (NOT .scfdata.exceeded_lambda_max) then
            stdout.redirect(trim(.name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".archive.fco")
         else
            stdout.redirect(trim(.name)//".archive.fco")
         end
      else
         stdout.redirect(trim(.name)//".archive.fco")
      end
      stdout.set_int_width(5)
      stdout.set_real_precision(4)
      stdout.set_real_width(13)
      .:put_CIF_banner(.cif.use_CIF2)
      .crystal.put_xd_fco
      stdout.revert
      stdout.unsave

      ! Clean up
      if (clean) then
         .cif.destroy
      end

   end


!  ====
!  Dump
!  ====

   serialize(filename)
   ! Write out data from sbf file
      self :: IN 
      filename :: STR, IN
      datafile :: DATAFILE
      labels   :: STR(len=1), dimension(:,:), allocatable
      i, label_length :: INT

      label_length = 1

      if (tonto.is_master_processor) then

         ! how long is the longest label
         do i = 1, .atom.size
            if (len(trim(.atom(i).label)) > label_length) label_length = len(trim(.atom(i).label))
         end do
        
         ! need to convert the labels to an MxN character array
         allocate(labels(.atom.size, label_length))
         do i = 1, .atom.size
            labels(i, :) = .atom(i).label.character_array(label_length)
         end do
        
         datafile.open(filename)
         call datafile%sbf%add_dataset(sbf_Dataset("name", trim(.name)))
         call datafile%sbf%add_dataset(sbf_Dataset("basis_name", trim(.basis_name)))
         call datafile%sbf%add_dataset(sbf_Dataset("atomic_labels", labels))
         call datafile%sbf%add_dataset(sbf_Dataset("atomic_numbers", .atom(:).atomic_number))
         call datafile%sbf%add_dataset(sbf_Dataset("atomic_coordinates", .atom.coordinate_vector))
         call datafile%sbf%add_dataset(sbf_Dataset("charge_multiplicity", [.charge, .spin_multiplicity]))
        
        
         ! SCF data
         ! TODO should really check if it's created and DONE not just if it's unrestricted
         if (.scfdata.allocated) then
        
            select case (.scfdata.spinorbital_genre)
        
            case ("r ")
               call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("r ")))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx,r", .density_mx.r))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs,r", .MOs.r))
        
            case ("u ")
               call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("u ")))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx,a", .density_mx.a))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx,b", .density_mx.b))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs,a", .MOs.a))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs,b", .MOs.a))
        
            case default
               call datafile%sbf%add_dataset(sbf_Dataset("scf_kind", trim("r ")))
               call datafile%sbf%add_dataset(sbf_Dataset("density_mx", .density_mx.r))
               call datafile%sbf%add_dataset(sbf_Dataset("MOs", .MOs.r))
               !DIE("Serializing these orbitals is not implemented")
        
            end
        
         end if
        
         call datafile%sbf%serialize
         datafile.close
       
      end if 

   end 

   deserialize(filename,do_groups)
   ! Read in data from sbf file
      self :: INOUT
      filename :: STR, IN
      do_groups :: BIN, optional, IN

      datafile :: DATAFILE
      tmp_str :: STR(len=:)@
      atomic_labels :: STR(len=1), dimension(:,:), allocatable
      atomic_numbers :: VEC{INT}@
      atomic_coordinates :: VEC{REAL}@
      charge_multiplicity :: VEC{INT}@
      tmp_mat :: MAT{REAL}@
      labels :: VEC{STR}@
      i, err :: INT
      success = 1 :: INT

      datafile.open(filename)

      call datafile%sbf%deserialize

      call datafile%sbf%get("name", tmp_str, err)
      DIE_IF(err /= success, sbf_strerr(err))

      .name = tmp_str
      call datafile%sbf%get("basis_name", tmp_str, err)
      DIE_IF(err /= success, sbf_strerr(err))

      .basis_name = tmp_str

      call datafile%sbf%get("atomic_labels", atomic_labels, err)
      DIE_IF(err /= success, sbf_strerr(err))

      ! convert back
      allocate(labels(size(atomic_labels, 1)))
      do i = 1, size(atomic_labels, dim=1)
         labels(i) = trim(VEC{STR}:char_array_to_str(atomic_labels(i,:)))
      end do

      call datafile%sbf%get("atomic_numbers", atomic_numbers, err)
      DIE_IF(err /= success, sbf_strerr(err))
      .atom.create(size(atomic_numbers))

      call datafile%sbf%get("atomic_coordinates", atomic_coordinates, err)
      DIE_IF(err /= success, sbf_strerr(err))
      .atom.set_positions_from_vector(atomic_coordinates)

      .atom.set_atom_data_from_labels(labels)

      call datafile%sbf%get("charge_multiplicity", charge_multiplicity, err)
      if(err /= success) then
          stderr.show("Error reading charge_multiplicity from file, not setting:", sbf_strerr(err))
      else
          .:set_charge(charge_multiplicity(1))
          .:set_spin_multiplicity(charge_multiplicity(2))
      endif

      ! Update atom info/basis sets
      .:update_atom_and_basis_info(do_groups)

      call datafile%sbf%get("scf_kind", tmp_str, err)

      ! TODO CHECK FOR ERRORS
      if (err == success) then
         .scfdata.create
         .scfdata.set_output(FALSE)
         .density_mx.create(.n_bf)
         .MOs.create(.n_bf)

         select case (tmp_str)
         !select case (.scfdata.spinorbital_genre)

         case ("r ")
            .scfdata.set_SCF_kind("rhf")
            call datafile%sbf%get("density_mx", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_mx.create("r ")
            .density_mx.r = tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("MOs", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .MOs.create("r ")
            .MOs.r = tmp_mat
            deallocate(tmp_mat)

         case ("u ")
            .scfdata.set_SCF_kind("uhf")
            .density_mx.create("u ")
            call datafile%sbf%get("density_mx,a", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_mx.a= tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("density_mx,b", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .density_mx.b = tmp_mat
            deallocate(tmp_mat)
            .MOs.create("u ")
            call datafile%sbf%get("MOs,a", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .MOs.a = tmp_mat
            deallocate(tmp_mat)
            call datafile%sbf%get("MOs,b", tmp_mat, err)
            DIE_IF(err /= success, sbf_strerr(err))
            .MOs.b = tmp_mat
            deallocate(tmp_mat)

         case default
            DIE("Serializing these orbitals is not implemented")

         end

      else


      end if

      datafile.close

   end

   make_atomic_multipoles(od,oc,no_s) ::: leaky
   ! Make the atomic multipoles using the tanaka partitioing
      self :: INOUT
      od, oc, no_s :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no restricted density_mx")
   ENSURE(NOT .use_spherical_basis,"not implememnted for spherical")

      off_diagonal,only_disconnected, no_s_functions :: BIN
      S,Sa,Sb,part :: MAT{REAL}@
      Ax,Ay,Az :: MAT{REAL}@
      Bx,By,Bz :: MAT{REAL}@
      Axx, Ayy, Azz, Axy, Axz, Ayz :: MAT{REAL}@
      Bxx, Byy, Bzz, Bxy, Bxz, Byz :: MAT{REAL}@
      Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz :: MAT{REAL}@
      Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz :: MAT{REAL}@
      q,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT
      sh :: SHELL2
      fac :: REAL

      off_diagonal = FALSE
      only_disconnected = FALSE
      no_s_functions = FALSE
      if (present(od)) off_diagonal = od
      if (present(oc)) only_disconnected = oc
      if (present(no_s)) no_s_functions = no_s

      .charges.create(.n_atom)
      .dipoles.create(.n_atom, 3)
      .quadrupoles.create(.n_atom, 6)
      .octupoles.create(.n_atom, 10)
  
      .charges     = ZERO
      .dipoles     = ZERO
      .quadrupoles = ZERO
      .octupoles   = ZERO

      do q = 1,.n_shell_pairs

         .BASE:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (atom_a==atom_b) then

            if (no_s_functions AND sh.a.l == 0 AND sh.b.l == 0) cycle
            if (off_diagonal) cycle
            if (only_disconnected) cycle

            fac = TWO
            if (fa==fb) fac=ONE

            S.create(na,nb)
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)

            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 

            sh.make_overlap_ints(S)
            sh.make_dipole_ints(Ax,Ay,Az,sh.a.position)
            sh.make_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz,sh.a.position)
            sh.make_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz,sh.a.position)

            .charges(atom_a)       = .charges(atom_a)       + fac*sum(S*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,1)     = .dipoles(atom_a,1)     + fac*sum(Ax*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,2)     = .dipoles(atom_a,2)     + fac*sum(Ay*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,3)     = .dipoles(atom_a,3)     + fac*sum(Az*.density_mx.r(fa:la,fb:lb))

            .quadrupoles(atom_a,1) = .quadrupoles(atom_a,1) + fac*sum(Axx*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,2) = .quadrupoles(atom_a,2) + fac*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,3) = .quadrupoles(atom_a,3) + fac*sum(Azz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,4) = .quadrupoles(atom_a,4) + fac*sum(Axy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,5) = .quadrupoles(atom_a,5) + fac*sum(Axz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,6) = .quadrupoles(atom_a,6) + fac*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            .octupoles(atom_a, 1)  = .octupoles(atom_a, 1)  + fac*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 2)  = .octupoles(atom_a, 2)  + fac*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 3)  = .octupoles(atom_a, 3)  + fac*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 4)  = .octupoles(atom_a, 4)  + fac*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 5)  = .octupoles(atom_a, 5)  + fac*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 6)  = .octupoles(atom_a, 6)  + fac*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 7)  = .octupoles(atom_a, 7)  + fac*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 8)  = .octupoles(atom_a, 8)  + fac*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 9)  = .octupoles(atom_a, 9)  + fac*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a,10)  = .octupoles(atom_a,10)  + fac*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            S.destroy
            Ax.destroy; Ay.destroy; Az.destroy
            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 

         else

            if (only_disconnected) then
               if (VEC{ATOM}:has_a_connection(atom_a,atom_b)) cycle
            end

            ! Partition factors
            part.create(sh.a.n_cc,sh.b.n_cc)
            sh.make_KM_partition(part)

            ! Get weighted overlap integrals
            Sa.create(na,nb); Sb.create(na,nb)

            sh.make_weighted_overlap_ints(Sa,Sb,part)

            .charges(atom_a) = .charges(atom_a) + TWO*sum(Sa*.density_mx.r(fa:la,fb:lb))
            .charges(atom_b) = .charges(atom_b) + TWO*sum(Sb*.density_mx.r(fa:la,fb:lb))

            Sb.destroy; Sa.destroy

            ! .dipoless
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Bx.create(na,nb); By.create(na,nb); Bz.create(na,nb)

            sh.make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz,part)

            .dipoles(atom_a,1) = .dipoles(atom_a,1) + TWO*sum(Ax*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,2) = .dipoles(atom_a,2) + TWO*sum(Ay*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_a,3) = .dipoles(atom_a,3) + TWO*sum(Az*.density_mx.r(fa:la,fb:lb))

            .dipoles(atom_b,1) = .dipoles(atom_b,1) + TWO*sum(Bx*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_b,2) = .dipoles(atom_b,2) + TWO*sum(By*.density_mx.r(fa:la,fb:lb))
            .dipoles(atom_b,3) = .dipoles(atom_b,3) + TWO*sum(Bz*.density_mx.r(fa:la,fb:lb))

            Ax.destroy; Ay.destroy; Az.destroy
            Bx.destroy; By.destroy; Bz.destroy

            ! .quadrupoless
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)
            Bxx.create(na,nb); Byy.create(na,nb); Bzz.create(na,nb)
            Bxy.create(na,nb); Bxz.create(na,nb); Byz.create(na,nb)

            sh.make_weighted_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz &
                                            ,Bxx,Byy,Bzz,Bxy,Bxz,Byz, part)

            .quadrupoles(atom_a,1) = .quadrupoles(atom_a,1) + TWO*sum(Axx*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,2) = .quadrupoles(atom_a,2) + TWO*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,3) = .quadrupoles(atom_a,3) + TWO*sum(Azz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,4) = .quadrupoles(atom_a,4) + TWO*sum(Axy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,5) = .quadrupoles(atom_a,5) + TWO*sum(Axz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_a,6) = .quadrupoles(atom_a,6) + TWO*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            .quadrupoles(atom_b,1) = .quadrupoles(atom_b,1) + TWO*sum(Bxx*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,2) = .quadrupoles(atom_b,2) + TWO*sum(Byy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,3) = .quadrupoles(atom_b,3) + TWO*sum(Bzz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,4) = .quadrupoles(atom_b,4) + TWO*sum(Bxy*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,5) = .quadrupoles(atom_b,5) + TWO*sum(Bxz*.density_mx.r(fa:la,fb:lb))
            .quadrupoles(atom_b,6) = .quadrupoles(atom_b,6) + TWO*sum(Byz*.density_mx.r(fa:la,fb:lb))

            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy
            Bxx.destroy; Byy.destroy; Bzz.destroy
            Bxy.destroy; Bxz.destroy; Byz.destroy

            ! .octupoless
            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 
            Bxxx.create(na,nb); Byyy.create(na,nb); Bzzz.create(na,nb)
            Bxxy.create(na,nb); Bxxz.create(na,nb); Byyx.create(na,nb)
            Byyz.create(na,nb); Bzzx.create(na,nb); Bzzy.create(na,nb)
            Bxyz.create(na,nb); 

            sh.make_weighted_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz & 
                                          ,Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz,part)

            .octupoles(atom_a, 1) = .octupoles(atom_a, 1) + TWO*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 2) = .octupoles(atom_a, 2) + TWO*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 3) = .octupoles(atom_a, 3) + TWO*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 4) = .octupoles(atom_a, 4) + TWO*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 5) = .octupoles(atom_a, 5) + TWO*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 6) = .octupoles(atom_a, 6) + TWO*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 7) = .octupoles(atom_a, 7) + TWO*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 8) = .octupoles(atom_a, 8) + TWO*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a, 9) = .octupoles(atom_a, 9) + TWO*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_a,10) = .octupoles(atom_a,10) + TWO*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            .octupoles(atom_b, 1) = .octupoles(atom_b, 1) + TWO*sum(Bxxx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 2) = .octupoles(atom_b, 2) + TWO*sum(Byyy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 3) = .octupoles(atom_b, 3) + TWO*sum(Bzzz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 4) = .octupoles(atom_b, 4) + TWO*sum(Bxxy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 5) = .octupoles(atom_b, 5) + TWO*sum(Bxxz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 6) = .octupoles(atom_b, 6) + TWO*sum(Byyx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 7) = .octupoles(atom_b, 7) + TWO*sum(Byyz*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 8) = .octupoles(atom_b, 8) + TWO*sum(Bzzx*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b, 9) = .octupoles(atom_b, 9) + TWO*sum(Bzzy*.density_mx.r(fa:la,fb:lb))
            .octupoles(atom_b,10) = .octupoles(atom_b,10) + TWO*sum(Bxyz*.density_mx.r(fa:la,fb:lb))

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 
            Bxxx.destroy; Byyy.destroy; Bzzz.destroy
            Bxxy.destroy; Bxxz.destroy; Byyx.destroy
            Byyz.destroy; Bzzx.destroy; Bzzy.destroy
            Bxyz.destroy; 

            part.destroy

         end

      end

      ! Electron .charges
      .dipoles     = -ONE * .dipoles
      .quadrupoles = -ONE * .quadrupoles
      .octupoles   = -ONE * .octupoles

   end

   make_atomic_multipoles(charge,dipole,quadrupole,octupole,od,oc,no_s) ::: PURE
   ! Make the atomic multipoles using the tanaka partitioing
      self :: IN
      charge :: VEC{REAL}, OUT
      dipole, quadrupole, octupole :: MAT{REAL}, OUT
      od, oc, no_s :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no restricted density_mx")
   ENSURE(NOT .use_spherical_basis,"not implememnted for spherical")

      off_diagonal,only_disconnected, no_s_functions :: BIN
      S,Sa,Sb,part :: MAT{REAL}@
      Ax,Ay,Az :: MAT{REAL}@
      Bx,By,Bz :: MAT{REAL}@
      Axx,Ayy,Azz,Axy,Axz,Ayz :: MAT{REAL}@
      Bxx,Byy,Bzz,Bxy,Bxz,Byz :: MAT{REAL}@
      Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz :: MAT{REAL}@
      Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz :: MAT{REAL}@
      q,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT
      sh :: SHELL2
      fac :: REAL

      off_diagonal = FALSE
      only_disconnected = FALSE
      no_s_functions = FALSE
      if (present(od)) off_diagonal = od
      if (present(oc)) only_disconnected = oc
      if (present(no_s)) no_s_functions = no_s

      
      charge     = ZERO
      dipole     = ZERO
      quadrupole = ZERO
      octupole   = ZERO

      do q = 1,.n_shell_pairs

         .BASE:set_shell2_from(q,sh,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (atom_a==atom_b) then

            if (no_s_functions AND sh.a.l == 0 AND sh.b.l == 0) cycle
            if (off_diagonal) cycle
            if (only_disconnected) cycle

            fac = TWO
            if (fa==fb) fac=ONE

            S.create(na,nb)
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)

            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 

            sh.make_overlap_ints(S)
            sh.make_dipole_ints(Ax,Ay,Az,sh.a.position)
            sh.make_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz,sh.a.position)
            sh.make_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz,sh.a.position)

            charge(atom_a)       = charge(atom_a)       + fac*sum(S*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,1)     = dipole(atom_a,1)     + fac*sum(Ax*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,2)     = dipole(atom_a,2)     + fac*sum(Ay*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,3)     = dipole(atom_a,3)     + fac*sum(Az*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,1) = quadrupole(atom_a,1) + fac*sum(Axx*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,2) = quadrupole(atom_a,2) + fac*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,3) = quadrupole(atom_a,3) + fac*sum(Azz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,4) = quadrupole(atom_a,4) + fac*sum(Axy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,5) = quadrupole(atom_a,5) + fac*sum(Axz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,6) = quadrupole(atom_a,6) + fac*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            octupole(atom_a, 1)  = octupole(atom_a, 1)  + fac*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 2)  = octupole(atom_a, 2)  + fac*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 3)  = octupole(atom_a, 3)  + fac*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 4)  = octupole(atom_a, 4)  + fac*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 5)  = octupole(atom_a, 5)  + fac*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 6)  = octupole(atom_a, 6)  + fac*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 7)  = octupole(atom_a, 7)  + fac*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 8)  = octupole(atom_a, 8)  + fac*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 9)  = octupole(atom_a, 9)  + fac*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a,10)  = octupole(atom_a,10)  + fac*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            S.destroy
            Ax.destroy; Ay.destroy; Az.destroy
            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy

         else

            if (only_disconnected) then
               if (VEC{ATOM}:has_a_connection(atom_a,atom_b)) cycle
            end

            ! Partition factors
            part.create(sh.a.n_cc,sh.b.n_cc)
            sh.make_KM_partition(part)

            ! Get weighted overlap integrals
            Sa.create(na,nb); Sb.create(na,nb)

            sh.make_weighted_overlap_ints(Sa,Sb,part)

            charge(atom_a) = charge(atom_a) + TWO*sum(Sa*.density_mx.r(fa:la,fb:lb))
            charge(atom_b) = charge(atom_b) + TWO*sum(Sb*.density_mx.r(fa:la,fb:lb))

            Sb.destroy; Sa.destroy

            ! Dipoles
            Ax.create(na,nb); Ay.create(na,nb); Az.create(na,nb)
            Bx.create(na,nb); By.create(na,nb); Bz.create(na,nb)

            sh.make_weighted_dipole_ints(Ax,Ay,Az,Bx,By,Bz,part)

            dipole(atom_a,1) = dipole(atom_a,1) + TWO*sum(Ax*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,2) = dipole(atom_a,2) + TWO*sum(Ay*.density_mx.r(fa:la,fb:lb))
            dipole(atom_a,3) = dipole(atom_a,3) + TWO*sum(Az*.density_mx.r(fa:la,fb:lb))

            dipole(atom_b,1) = dipole(atom_b,1) + TWO*sum(Bx*.density_mx.r(fa:la,fb:lb))
            dipole(atom_b,2) = dipole(atom_b,2) + TWO*sum(By*.density_mx.r(fa:la,fb:lb))
            dipole(atom_b,3) = dipole(atom_b,3) + TWO*sum(Bz*.density_mx.r(fa:la,fb:lb))

            Ax.destroy; Ay.destroy; Az.destroy
            Bx.destroy; By.destroy; Bz.destroy

            ! Quadrupoles
            Axx.create(na,nb); Ayy.create(na,nb); Azz.create(na,nb)
            Axy.create(na,nb); Axz.create(na,nb); Ayz.create(na,nb)
            Bxx.create(na,nb); Byy.create(na,nb); Bzz.create(na,nb)
            Bxy.create(na,nb); Bxz.create(na,nb); Byz.create(na,nb)

            sh.make_weighted_quadrupole_ints(Axx,Ayy,Azz,Axy,Axz,Ayz &
                                            ,Bxx,Byy,Bzz,Bxy,Bxz,Byz, part)

            quadrupole(atom_a,1) = quadrupole(atom_a,1) + TWO*sum(Axx*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,2) = quadrupole(atom_a,2) + TWO*sum(Ayy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,3) = quadrupole(atom_a,3) + TWO*sum(Azz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,4) = quadrupole(atom_a,4) + TWO*sum(Axy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,5) = quadrupole(atom_a,5) + TWO*sum(Axz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_a,6) = quadrupole(atom_a,6) + TWO*sum(Ayz*.density_mx.r(fa:la,fb:lb))

            quadrupole(atom_b,1) = quadrupole(atom_b,1) + TWO*sum(Bxx*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,2) = quadrupole(atom_b,2) + TWO*sum(Byy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,3) = quadrupole(atom_b,3) + TWO*sum(Bzz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,4) = quadrupole(atom_b,4) + TWO*sum(Bxy*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,5) = quadrupole(atom_b,5) + TWO*sum(Bxz*.density_mx.r(fa:la,fb:lb))
            quadrupole(atom_b,6) = quadrupole(atom_b,6) + TWO*sum(Byz*.density_mx.r(fa:la,fb:lb))

            Axx.destroy; Ayy.destroy; Azz.destroy
            Axy.destroy; Axz.destroy; Ayz.destroy
            Bxx.destroy; Byy.destroy; Bzz.destroy
            Bxy.destroy; Bxz.destroy; Byz.destroy

            ! Octupoles
            Axxx.create(na,nb); Ayyy.create(na,nb); Azzz.create(na,nb)
            Axxy.create(na,nb); Axxz.create(na,nb); Ayyx.create(na,nb)
            Ayyz.create(na,nb); Azzx.create(na,nb); Azzy.create(na,nb)
            Axyz.create(na,nb); 
            Bxxx.create(na,nb); Byyy.create(na,nb); Bzzz.create(na,nb)
            Bxxy.create(na,nb); Bxxz.create(na,nb); Byyx.create(na,nb)
            Byyz.create(na,nb); Bzzx.create(na,nb); Bzzy.create(na,nb)
            Bxyz.create(na,nb); 

            sh.make_weighted_octupole_ints(Axxx,Ayyy,Azzz,Axxy,Axxz,Ayyx,Ayyz,Azzx,Azzy,Axyz & 
                                          ,Bxxx,Byyy,Bzzz,Bxxy,Bxxz,Byyx,Byyz,Bzzx,Bzzy,Bxyz,part)

            octupole(atom_a, 1) = octupole(atom_a, 1) + TWO*sum(Axxx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 2) = octupole(atom_a, 2) + TWO*sum(Ayyy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 3) = octupole(atom_a, 3) + TWO*sum(Azzz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 4) = octupole(atom_a, 4) + TWO*sum(Axxy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 5) = octupole(atom_a, 5) + TWO*sum(Axxz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 6) = octupole(atom_a, 6) + TWO*sum(Ayyx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 7) = octupole(atom_a, 7) + TWO*sum(Ayyz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 8) = octupole(atom_a, 8) + TWO*sum(Azzx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a, 9) = octupole(atom_a, 9) + TWO*sum(Azzy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_a,10) = octupole(atom_a,10) + TWO*sum(Axyz*.density_mx.r(fa:la,fb:lb))

            octupole(atom_b, 1) = octupole(atom_b, 1) + TWO*sum(Bxxx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 2) = octupole(atom_b, 2) + TWO*sum(Byyy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 3) = octupole(atom_b, 3) + TWO*sum(Bzzz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 4) = octupole(atom_b, 4) + TWO*sum(Bxxy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 5) = octupole(atom_b, 5) + TWO*sum(Bxxz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 6) = octupole(atom_b, 6) + TWO*sum(Byyx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 7) = octupole(atom_b, 7) + TWO*sum(Byyz*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 8) = octupole(atom_b, 8) + TWO*sum(Bzzx*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b, 9) = octupole(atom_b, 9) + TWO*sum(Bzzy*.density_mx.r(fa:la,fb:lb))
            octupole(atom_b,10) = octupole(atom_b,10) + TWO*sum(Bxyz*.density_mx.r(fa:la,fb:lb))

            Axxx.destroy; Ayyy.destroy; Azzz.destroy
            Axxy.destroy; Axxz.destroy; Ayyx.destroy
            Ayyz.destroy; Azzx.destroy; Azzy.destroy
            Axyz.destroy; 
            Bxxx.destroy; Byyy.destroy; Bzzz.destroy
            Bxxy.destroy; Bxxz.destroy; Byyx.destroy
            Byyz.destroy; Bzzx.destroy; Bzzy.destroy
            Bxyz.destroy; 

            part.destroy

         end

      end

      ! Electron charge
      dipole     = -ONE * dipole
      quadrupole = -ONE * quadrupole
      octupole   = -ONE * octupole

   end

end
