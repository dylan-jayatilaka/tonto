!===============================================================================
!
! MOLECULE.BASE
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below.
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further.
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! Updated 2014-12-01
!
! .BASE
!     3 .REL
!    16---24 .GRID
!    14---12---- 1 .XTAL
!     2--- |---- |---- 4 .CE =
!     7--- |---- 1---- |-- | .INTS
!    14--- |---- 5---- |-- |---- 2 .FOCK
!    30--- 5---- 4---- 5-- |----10---- 5 .SCF
!     2--- |---- |---- |-- |---- 1---- 5--- 1 .GEM =     =     =
!    11--- |---- |---- 1-- |----15---- 5---13--- | .PROP =     =
!     4--- |---- 6---- |-- |---- 3---- |--- 2--- |---- | .PLOT =
!     4--- |---- 5---- |-- |---- 4---- 2--- 1--- |---- |---- | .CP
!    12--- |---- 7---- |-- |---- |---- |--- 1--- |---- |---- 1-- | .TAD
!    15--- |---- 5---- 1-- |---- 5---- 6--- 5--- |---- |---- |-- |--- 2 .MISC
!    76--- 3---- 3----13-- 7---- 1---- |---13--- 3----19---- 6-- 9---11----24 .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===============================================================================

module MOLECULE.BASE

   implicit none

contains


!  ============================
!  Axis change and origin shift
!  ============================

!   change_to_principal_axes ::: PURE
!   ! Move the origin to the center of mass and change to the principal axis
!   ! coordinate system
!      self :: INOUT
!
!   ENSURE(.atom.allocated,"atom list required")
!
!      .atom.change_to_principal_axes
!
!   end

!   change_to_principal_top_axes ::: PURE
!   ! Move the origin to the center of mass and change to the principal axis
!   ! coordinate system, where the symmetric top axis is the z axis and where the
!   ! determinant of the axes transformation is 1.
!      self :: INOUT
!
!   ENSURE(.atom.allocated,"atom list required")
!
!      .atom.change_to_principal_top_axes
!
!   end

   move_origin_to_center_of_mass
   ! Move the origin to the center of mass
      self :: INOUT

   ENSURE(.atom.allocated,"atom list required")

      .atom.move_origin_to_center_of_mass

      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom) ! NOT PURE
         .becke_grid.set_grid_data
      end

   end

   move_origin_to_center_of_atoms
   ! Move the origin to the center of atoms
      self :: INOUT

   ENSURE(.atom.allocated,"atom list required")

      .atom.move_origin_to_center_of_atoms

      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom) ! NOT PURE
         .becke_grid.set_grid_data
      end

   end

   move_origin 
   ! Move the origin by a user specified vector
      self :: INOUT

   ENSURE(.atom.allocated,"atom list required")
   ENSURE(stdin.buffer.n_items==4 OR stdin.buffer.n_items==5,"origin shift needed on same line")

      shift :: VEC{REAL}(3)

      stdin.read_quantity(shift)
      .atom.translate_by(shift)

      if (.becke_grid.allocated) then
         .becke_grid.set_atom_info(.atom) ! NOT PURE
         .becke_grid.set_grid_data
      end

   end

!  =================
!  Overlapping atoms
!  =================

   make_max_S_for_shell_pairs(max_S) ::: PURE
   ! Make "max_S", the maximum of the overlap integrals between basis
   ! functions in pairs of shells.
      self :: IN
      max_S :: VEC{REAL}, OUT

   ENSURE(.overlap_mx.allocated,"no overlap_mx")
   ENSURE(max_S.dim==.n_shell_pairs,"wrong size, S_max")

      ab,a,b,fa,fb,la,lb :: INT

      do ab = 1,.n_shell_pairs

         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2

         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)

         max_S(ab) = maxval(abs(.overlap_mx(fa:la,fb:lb)))

      end

   end

! Below does not work ... but it does with lower cutoff

!  ========================
!  Contraction Coefficients
!  ========================

   make_contraction_mx(cc_mat) ::: PURE
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      self :: IN
      cc_mat :: MAT{REAL}, OUT

   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      b = 1
      p = 1

      cc_mat = ZERO

      do a = 1,.n_atom

         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf

         .atom(a).basis.make_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))

         p = p + ap
         b = b + ab

      end

   end

   make_normalized_contraction_mx(cc_mat) ::: PURE
   ! Returns the matrix of complete contraction coefficients for each
   ! basis set. Size of cc_mat is [.n_prim,.n_bf]. Primitive components
   ! are properly normalized.
      self :: INOUT
      cc_mat :: MAT{REAL}, OUT

   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      .basis.renormalize

      b = 1
      p = 1
      cc_mat = ZERO

      do a = 1,.n_atom

         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf

         .atom(a).basis.make_normalized_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))

         p = p + ap
         b = b + ab

      end

      .basis.unnormalize

   end

!  ========================
!  AIM2000/Morphy interface
!  ========================

! Can we get rid of these beow, from this module? --dylan
! The don't fit in PUT

   put_morphy98_wfn_file ::: leaky
   ! Write a morphy98 .wfn file
      self :: IN

   ENSURE(.NO_occ_nos.is_allocated_with_genre("r "), "No occupation numbers")
   ENSURE(  .MO_energies.is_allocated_with_genre("r "), "No orbital energies")
   ENSURE(.MOs.is_allocated_with_genre("r "), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE@
      lvec :: VEC{INT}@
      evec :: VEC{REAL}@
      dmatrix, cc :: MAT{REAL}@
      sh :: SHELL@
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer.exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".wfn")
      wfnfile.open_for("write")
       
      if (IO_IS_ALLOWED) then

         if (mod(.n_e, 2)==0) then
            n_orbitals = .n_e / 2
         else
            n_orbitals = (.n_e + 1) / 2
         end
       
         write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
         write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
         write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
            .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
         write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)
       
         pcount = 1
         lvec.create(.n_prim)
         evec.create(.n_prim)

         do a = 1, .n_shell

           atomn  = .atom_for_shell(a)
           shelln = .atom_shell_for_shell(a)
           sh     = .atom(atomn).basis.shell(shelln)
           l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
           do j = 1, sh.n_cc
             if (sh.l==3) then
               lvec(pcount  ) = l + 1
               lvec(pcount+1) = l + 2
               lvec(pcount+2) = l + 3
               lvec(pcount+3) = l + 4
               lvec(pcount+4) = l + 5
               lvec(pcount+5) = l + 7
               lvec(pcount+6) = l + 6
               lvec(pcount+7) = l + 8
               lvec(pcount+8) = l + 9
               lvec(pcount+9) = l + 10
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 pcount = pcount + 1
               end
             else
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 lvec(pcount) = l + i
                 pcount = pcount + 1
               end
             end
           end
         end
       
         write(unit=wfnfile.unit, fmt=t_assignment_format) lvec
         write(unit=wfnfile.unit, fmt=exponent_format) evec
       
         lvec.destroy
         evec.destroy
       
         dmatrix.create(.n_prim, .n_bf)
         cc.create(.n_prim, .n_bf)
       
         .BASE:make_contraction_mx(cc)
       
         dmatrix.to_product_of(cc,.MOs.r)
       
         do i = 1, n_orbitals
            write(unit=wfnfile.unit, fmt=mol_title_format) &
               "MO  ", i, &
               "OCC NO = ", .NO_occ_nos.r(i), &
               " ORB. ENERGY = ", .MO_energies.r(i)
            write(unit=wfnfile.unit, fmt=coefficient_format) dmatrix(:, i)
         end
       
         write(unit=wfnfile.unit, fmt="(1A8)") "END DATA"
         if (.scfdata.allocated) then
         write(unit=wfnfile.unit, fmt=e_v_format) .scfdata.energy, TWO
         else
         write(unit=wfnfile.unit, fmt=e_v_format) ZERO, TWO
         end
       
         ! Clean
         cc.destroy
         dmatrix.destroy

      end

      wfnfile.close
      wfnfile.destroy

   end

   put_aim2000_wfn_file ::: leaky
   ! Writes a proaim2000 .wfn file
      self :: IN

   ENSURE(.MO_energies.is_allocated_with_genre("r "), "No orbital energies")
   ENSURE(.MOs.is_allocated_with_genre("r "), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE@
      lvec :: VEC{INT}@
      evec :: VEC{REAL}@
      dmatrix, cc :: MAT{REAL}@
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
      sh :: SHELL@
      occ :: REAL

      n_vars_format :: STR, parameter = "(A8, 10X, I5,' MOL ORBITALS', I7,' PRIMITIVES', I9,' NUCLEI')"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '  CHARGE =', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO  ', I3,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer.exhausted) stdin.read(name)

      wfnfile.create(trim(name)//".wfn")
      wfnfile.open_for("write")

      if (IO_IS_ALLOWED) then
       
         if (mod(.n_e, 2)==0) then
            n_orbitals = .n_e / 2
         else
            n_orbitals = (.n_e + 1) / 2
         end
       
         write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
         write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
         write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
            .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
         write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)
       
         pcount = 1
         lvec.create(.n_prim)
         evec.create(.n_prim)

         do a = 1, .n_shell
           atomn  = .atom_for_shell(a)
           shelln = .atom_shell_for_shell(a)
           sh     = .atom(atomn).basis.shell(shelln)
           l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
           do j = 1, sh.n_cc
             if (sh.l==3) then
               lvec(pcount  ) = l + 1
               lvec(pcount+1) = l + 2
               lvec(pcount+2) = l + 3
               lvec(pcount+3) = l + 4
               lvec(pcount+4) = l + 5
               lvec(pcount+5) = l + 7
               lvec(pcount+6) = l + 6
               lvec(pcount+7) = l + 8
               lvec(pcount+8) = l + 9
               lvec(pcount+9) = l + 10
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 pcount = pcount + 1
               end
             else
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 lvec(pcount) = l + i
                 pcount = pcount + 1
               end
             end
           end
         end
       
         write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
         write(unit = wfnfile.unit, fmt = exponent_format) evec
       
         lvec.destroy
         evec.destroy
       
         dmatrix.create(.n_prim, .n_bf)
         cc.create(.n_prim, .n_bf)
       
         .BASE:make_contraction_mx(cc)
       
         dmatrix.to_product_of(cc,.MOs.r)
       
         do i = 1, n_orbitals
            occ = ZERO
            if (i<=.n_a) occ = TWO
            write(unit=wfnfile.unit, fmt=mol_title_format) &
               i, occ, .MO_energies.r(i)
            write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
         end
       
         write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
         if (.scfdata.allocated) then
         write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
         else
         write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
         end
       
         ! Clean
         cc.destroy
         dmatrix.destroy
      end

      wfnfile.close
      wfnfile.destroy

   end

   put_florian_wfn_file(with_lambda)
   ! Writes a full wavefunction .ffn file
      self :: IN
      with_lambda :: BIN, optional, IN

   ENSURE(.MO_energies.is_allocated_with_genre("r "), "No orbital energies")
   ENSURE(.MOs.is_allocated_with_genre("r "), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE@
      lvec :: VEC{INT}@
      evec :: VEC{REAL}@
      dmatrix, cc :: MAT{REAL}@
      sh :: SHELL@
      i, j, pcount, a, l, atomn, shelln :: INT
      occ :: REAL
      avec_lambda :: BIN

      n_vars_format :: STR, parameter = "(A8, 10X, I5,' MOL ORBITALS', I7,' PRIMITIVES', I9,' NUCLEI')"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '  CHARGE =', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO ', I4,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      name = .name
      if (NOT stdin.buffer.exhausted) stdin.read(name)

      if (avec_lambda) then
        wfnfile.create(trim(name)//",lambda="//trim(.scfdata.lambda.to_str("f9.6"))//".ffn")
      else
        wfnfile.create(trim(name)//".ffn")
      end
      
      wfnfile.open_for("write")
      if (IO_IS_ALLOWED) then
         write(unit = wfnfile.unit, fmt = '(a)') trim(name) //" computed by TONTO "//TONTO_VERSION//" v. "//GIT_VERSION
         write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", .n_bf, .n_prim, .n_atom
         write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
            .atom(i).position, REALIFY(.atom(i).atomic_number), i=1,.n_atom)
         write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i=1,.atom(j).basis.no_of_primitives), j=1,.n_atom)

         pcount = 1
         lvec.create(.n_prim)
         evec.create(.n_prim)
         do a = 1, .n_shell
           atomn  = .atom_for_shell(a)
           shelln = .atom_shell_for_shell(a)
           sh     = .atom(atomn).basis.shell(shelln)
           l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
           do j = 1, sh.n_cc
             if (sh.l==3) then
               lvec(pcount  ) = l + 1
               lvec(pcount+1) = l + 2
               lvec(pcount+2) = l + 3
               lvec(pcount+3) = l + 4
               lvec(pcount+4) = l + 5
               lvec(pcount+5) = l + 7
               lvec(pcount+6) = l + 6
               lvec(pcount+7) = l + 8
               lvec(pcount+8) = l + 9
               lvec(pcount+9) = l + 10
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 pcount = pcount + 1
               end
             else
               do i = 1, sh.n_comp
                 evec(pcount) = sh.exponent(j)
                 lvec(pcount) = l + i
                 pcount = pcount + 1
               end
             end
           end
         end
       
         write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
         write(unit = wfnfile.unit, fmt = exponent_format) evec
       
         lvec.destroy
         evec.destroy
       
         dmatrix.create(.n_prim, .n_bf)
         cc.create(.n_prim, .n_bf)
       
         .BASE:make_contraction_mx(cc)
       
         dmatrix.to_product_of(cc,.MOs.r)
       
         do i = 1, .n_bf
            occ = ZERO
            if (i<=.n_a) occ = TWO
            write(unit=wfnfile.unit, fmt=mol_title_format) &
               i, occ, .MO_energies.r(i)
            write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
         end
       
         write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
         if (.scfdata.allocated) then
            write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
         else
            write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
         end
       
         ! Clean
         cc.destroy
         dmatrix.destroy
      end
      wfnfile.close
      wfnfile.destroy

   end

!  ========================
!  Atom AO subspace setting
!  ========================

   AO_subspace_set(A,B,row_atom,col_atom) ::: PURE
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then copy
   ! the entire row or col, i.e.  A(small) = B(row_atom,col_atom)
      self :: IN
      A :: MAT{REAL}, OUT
      B :: MAT{REAL}, IN
      row_atom :: VEC{INT}, optional, IN
      col_atom :: VEC{INT}, optional, IN

   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")

      n_row_atoms,n_col_atoms, a1,a2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT

      if (present(row_atom) AND present(col_atom)) then

         n_row_atoms = row_atom.dim
         n_col_atoms = col_atom.dim
         a1 = .atom(row_atom).no_of_basis_functions
         a2 = .atom(col_atom).no_of_basis_functions
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_i = 0
         do i = 1,n_row_atoms

            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = l_i - f_i + 1

            b_j = 0

            do j = 1,n_col_atoms

               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = l_j - f_j + 1

               A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)

               b_j = b_j + n_j

            end

            b_i = b_i + n_i

         end

      else if (present(row_atom)) then

         n_row_atoms = row_atom.dim
         a1 = .atom(row_atom).no_of_basis_functions
         a2 = .n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_i = 0

         do i = 1,n_row_atoms

            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = l_i - f_i + 1

            A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)

            b_i = b_i + n_i

         end

      else if (present(col_atom)) then

         n_col_atoms = col_atom.dim
         a1 = .n_bf
         a2 = .atom(col_atom).no_of_basis_functions
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")

         b_j = 0

         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j))
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = l_j - f_j + 1

            A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)

            b_j = b_j + n_j

         end

      end

   end

!  ======================
!  Density matrix methods
!  ======================

   make_density_mx_from_NOs ::: leaky
   ! Make the .density_mx from the *NOs* and the
   ! *NO_occ_nos* vector. Only restricted so far.
      self :: INOUT

   ENSURE(.NO_occ_nos.allocated, "no occupation numbers")
   ENSURE(.NOs.allocated, "no natural orbitals")

      NO :: MAT{REAL}@
      occ :: VEC{REAL}@
      genre :: STR
      arch :: ARCHIVE

      genre = .NOs.genre

      ! Destroy
      .density_mx.destroy(genre)
      .density_mx.create(genre)

      ! Make it
      select case (genre)

      case ("r ")

         ENSURE(.NOs.is_allocated_with_genre("r "),"no NO's")

         occ.create(.n_bf)
         NO.create(.n_bf,.n_bf)

         occ = sqrt(.NO_occ_nos.r)
         NO.to_product_with_diagonal(.NOs.r,occ)
         .density_mx.r.to_product_of(NO,NO,transpose_b=TRUE)

         NO.destroy
         occ.destroy

      case default

         DIE("unknown SCF kind, "//trim(genre))

      end

      ! Archive
      arch.set(.name,"density_mx",genre)
      arch.write(.density_mx)

   end

   make_SCF_density_mx(damp,n_a,method) ::: leaky
   ! Make the density matrix from the molecular orbitals.
   ! . If "damp" is present use it to damp the updated density matrix.
   !   An .old_density_mx must exist for this to work.
   ! . If "n_a" is present it is used as the number of alpha electrons
   !   in embedded scf calculations.
   ! . If "method" is present it is used as the kind of density matrix
   !   to make, otherwise taken from .scfdata.SCF_kind, or guessed
   !   from the spinorbital_genre of the MO's.
   ! NOTE:
   ! . If .scfdata.do_delta_build is set and a a .delta_density_mx
   !   is created, then a delta density is made.
   ! . If .scfdata.apply_pFON a finite temperature density matrix is
   !   made with temperature .scfdata.temperature_for_pFON (untested)
      self :: INOUT
      damp :: BIN, optional, IN
      n_a :: INT, optional, IN
      method :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")

      T :: REAL
      damping,do_delta_density :: BIN
      use_pFON,use_FON :: BIN
      scf_method,genre :: STR

      ! Determine (or guess) the kind of SCF method to be used.
      if      (present(method))    then; scf_method = method
      else if (.scfdata.allocated) then; scf_method = .scfdata.SCF_kind
      else;                              scf_method = .MOs.guess_SCF_kind
      end

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Make the delta density matrix?
      do_delta_density = .delta_density_mx.allocated
      if (.scfdata.allocated) do_delta_density = do_delta_density AND .scfdata.do_delta_build

      ! Determine if density matrix damping is to be used
      damping = .old_density_mx.allocated
      if      (present(damp)) then;      damping = damping AND damp
      else if (.scfdata.allocated) then; damping = damping AND .scfdata.apply_damping
      end

      ! Determine if pFON should be used
      use_pFON = FALSE
      if (.scfdata.allocated) then
      if (.fock_mx.allocated) then
      if (.fock_mx.is_allocated_with_genre(genre)) then
         use_pFON = .scfdata.apply_pFON
      end
      end
      end

      ! Determine if finite temperature FON should be used
      use_FON = FALSE
      if (.scfdata.allocated) use_pFON = .scfdata.using_FON

      ! Create the density matrix (leaky)
      if (.density_mx.deallocated) .density_mx.create(.n_bf)
      .density_mx.destroy(genre)
      .density_mx.create(genre)

      ! Save the old density if damping
      .old_density_mx.destroy
      if (do_delta_density OR damping) then
         .old_density_mx = .density_mx
         .old_density_mx.compress
      end

      ! Make the density matrix
      select case (scf_method)

      case ("group")
         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         ENSURE(present(n_a),"n_a must be specified")
         .density_mx.r.to_scaled_product_of(.MOs.r(:,1:.n_a) &
                                                        ,.MOs.r(:,1:.n_a) &
                                                        ,fac=TWO,transpose_b=TRUE)

      case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")
         ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.atom.chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))

         if (use_pFON) then

            T  =  .scfdata.temperature_for_pFON
            ::make_finite_T_density_mx(.density_mx.r &
                                          ,.MOs.r &
                                          ,.fock_mx.r,T,.n_a)
            .density_mx.r  = TWO*.density_mx.r

         else if (use_FON) then

            T  =  .scfdata.temperature
            ::make_finite_T_DM_r(.density_mx.r &
                                ,.scfdata.E_Fermi &
                                ,.MOs.r &
                                ,.MO_energies.r,T,.n_a)
            .density_mx.r  = TWO*.density_mx.r

         else

            .density_mx.r.to_scaled_product_of(.MOs.r(:,1:.n_a) &
                                                           ,.MOs.r(:,1:.n_a) &
                                                           ,fac=TWO,transpose_b=TRUE)

         end

         if (scf_method(1:4)=="xray" AND .scfdata.stabilize_density) then
            .BASE:stabilize(.density_mx.r)
         end

      case ("rohf")

         ENSURE(.MOs.is_allocated_with_genre("r "),"no MO's")

         .density_mx.a.to_product_of(.MOs.a(:,1:.n_a) &
                                            ,.MOs.a(:,1:.n_a) &
                                            ,transpose_b=TRUE)
         .density_mx.b.to_product_of(.MOs.b(:,1:.n_b) &
                                           ,.MOs.b(:,1:.n_b) &
                                           ,transpose_b=TRUE)

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

         ENSURE(.MOs.is_allocated_with_genre("u "),"no MO's")

         if (use_pFON) then

            T = .scfdata.temperature_for_pFON
            ::make_finite_T_density_mx(.density_mx.a     &
                                          ,.MOs.a &
                                          ,.fock_mx.a,T,.n_a)
            ::make_finite_T_density_mx(.density_mx.b      &
                                          ,.MOs.b, &
                                          .fock_mx.b,T,.n_b)

         else if (use_FON) then

            T = .scfdata.temperature
            ::make_finite_T_DM_u(.density_mx.a     &
                                ,.density_mx.b      &
                                ,.scfdata.E_Fermi &
                                ,.MOs.a &
                                ,.MOs.b  &
                                ,.MO_energies.a   &
                                ,.MO_energies.b    &
                                ,T,.n_a,.n_b)

         else

            .density_mx.a.to_product_of(.MOs.a(:,1:.n_a) &
                                               ,.MOs.a(:,1:.n_a),transpose_b=TRUE)
            .density_mx.b.to_product_of( .MOs.b(:,1:.n_b)  &
                                              , .MOs.b(:,1:.n_b), transpose_b=TRUE)

         end

      case ("gchf","xray_gchf")

         ENSURE(.MOs.is_allocated_with_genre("gc"),"no MO's")

         .density_mx.gc.to_product_of(.MOs.gc(:,1:.n_e) &
                                                      ,.MOs.gc(:,1:.n_e) &
                                                      ,dagger_b=TRUE)

      case default

         DIE("unknown SCF kind, "//trim(scf_method))

      end

      ! Damp the density matrix if required
      if (damping) then
         .old_density_mx.uncompress
         .density_mx.damp(.old_density_mx,.scfdata.damp_factor)
      end

      ! Archive density matrix?
    ! do_archive = FALSE
    ! if (do_archive) .PUT:put_archive(.density_mx,"density_mx")

      ! Save the delta density matrix for incremental Fock build
      if (do_delta_density) then
         .delta_density_mx = .old_density_mx
         .delta_density_mx.scale_by(-ONE)
         .delta_density_mx.plus(.density_mx)
      else
         .old_density_mx.destroy
      end

   end

!   make_S_g(S)
!   ! Make the 2x.n_bf sizes AO overlap matrix
!      self :: IN
!      S :: MAT{REAL}, OUT
!
!   ENSURE(.overlap_mx.allocated, "NO overlap_mx!")
!
!      S = ZERO
!
!      ! Make S in the SAO asis 
!      S.set_aa_block_to(.overlap_mx)
!        S.set_bb_block_to(.overlap_mx)
!
!   end

   make_finite_T_density_mx(D,MO,F,T,n_e) ::: selfless
   ! Make the finite temperature density matrix "D" from molecular
   ! orbitals "MO" according to the pFON method with temperature "T"
   ! and number of electrons "n_e" *for a given spin*, as in Rabuck
   ! and Scuseria, JCP 110, 695 (1999).  There must exist a current
   ! fock_mx "F" made from "D" which is used to get the
   ! eigenvalues for the Fermi-Dirac distribution.
      D :: MAT{REAL}, OUT
      MO,F :: MAT{REAL}, IN
      T :: REAL, IN
      n_e :: INT, IN

   ENSURE(F.is_square,"F must be square")
   ENSURE(F.is_same_shape_as(MO),"incompatible F and MO")
   ENSURE(n_e<MO.dim2,"fewer MO's than electrons")
   ENSURE(T>=ZERO,"T must be positive")

      W :: MAT{REAL}@
      occ :: VEC{REAL}@
      ind :: VEC{INT}@
      beta,e_homo,e_lumo,e_fermi,homo_lumo_gap :: REAL
      n_orb,i,j,n_frac :: INT

      n_orb = F.dim1

      occ.create(n_orb)
      ind.create(n_orb)

      ! Make the occupation numbers
      W.create(n_orb,n_orb)
      W.to_product_of(F,MO)
      do i = 1,n_orb        ! These are energies
         occ(i) = dot_product(MO(:,i),W(:,i))
      end
      occ.quick_sort(ind)   ! "ind" has the energies sorted
      W.destroy

      beta    = KELVIN_PER_HARTREE/T
      e_homo  = occ(ind(n_e))
      e_lumo  = occ(ind(n_e+1))
      e_fermi = HALF*(e_homo + e_lumo)
      homo_lumo_gap = e_lumo - e_homo
      do j = 1,n_orb        ! These are the occupation numbers
         i = ind(j)
         occ(i) = ONE/(ONE+exp(beta*(occ(i)-e_fermi)))
      end

      ! The number of fractional orbitals
      if      (homo_lumo_gap>0.135e0) then; n_frac = 5
      else if (homo_lumo_gap<0.090e0) then; n_frac = 3
      else;                                 n_frac = 4
      end

      ! Reset the fractional occupancies
      do j = 1,n_orb
         i = ind(j)
         if      (j<=n_e-n_frac) then; occ(i) = ONE
         else if (j >n_e+n_frac) then; occ(i) = ZERO
         end
      end

      ! Form the temperature broadended density
      D = ZERO
      do j = 1,n_e+n_frac
         i = ind(j)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ(i),transpose_b=TRUE)
      end

      ind.destroy
      occ.destroy

   end

   make_finite_T_DM_r(D,E_Fermi,MO,eig,T,n_e) ::: selfless
   ! Make the restricted finite temperature density matrix "D" from
   ! molecular orbitals "MO" according to the FON method with
   ! temperature "T" in Kelvin and number of electrons "n_e" *for a
   ! given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
      D :: MAT{REAL}, OUT
      E_Fermi :: REAL, OUT
      MO :: MAT{REAL}, IN
      eig :: VEC{REAL}, IN
      T :: REAL, IN
      n_e :: INT, IN

   ENSURE( D.is_square, "D must be square")
   ENSURE(MO.dim2==eig.dim,"MO and eig are incomptabile")
   ENSURE(n_e<=MO.dim2,"fewer MO's than electrons")
   ENSURE(T>ZERO,"T must be positive")

      i :: INT
      occ :: REAL

      ! Set temperature and eigenvalues
      REAL:set_T_Fermi(T)
      REAL:set_E_level(eig)
      REAL:set_n_electrons(n_e)

      ! Find the Fermi energy
      REAL:find_root_brent(REAL::Fermi_Dirac_excess_fn,x1=eig(1),x2=eig(n_e+1),root=E_Fermi,tol=TOL(6))

      if (TRUE) then
         stdout.show("HOMO      =",eig(n_e))
         stdout.show("LUMO      =",eig(n_e+1))
         stdout.show("E_Fermi   =",E_Fermi)
      end

      ! Set the Fermi energy
      REAL:set_E_Fermi(E_Fermi)

      ! Form the temperature broadended density
      D = ZERO
      do i = 1,MO.dim2
         occ = REAL:Fermi_Dirac_fn(i)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ,transpose_b=TRUE)
      end

   end

   make_finite_T_DM_u(Da,Db,E_Fermi,MOa,MOb,Ea,Eb,T,n_a,n_b) ::: selfless
   ! Make the restricted finite temperature density matrix "D" from
   ! molecular orbitals "MO" according to the FON method with
   ! temperature "T" in Kelvin and number of electrons "n_e" *for a
   ! given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
      Da,Db :: MAT{REAL}, OUT
      E_Fermi :: REAL, OUT
      MOa,MOb :: MAT{REAL}, IN
      Ea,Eb :: VEC{REAL}, IN
      T :: REAL, IN
      n_a,n_b :: INT, IN

   ENSURE( Da.is_square, "Da must be square")
   ENSURE( Db.is_square, "Da must be square")
   ENSURE(MOa.dim2==Ea.dim,"MOa and Ea are incomptabile")
   ENSURE(MOb.dim2==Eb.dim,"MOb and Eb are incomptabile")
   ENSURE(n_b<=MOb.dim2,"fewer MOb's than electrons")
   ENSURE(T>ZERO,"T must be positive")

      i :: INT
      Emin,Emax,occ :: REAL

      ! Set temperature and eigenvalues
      REAL:set_T_Fermi(T)
      REAL:set_E_level(Ea,Eb)
      REAL:set_n_electrons(n_a+n_b)

      ! Find the Fermi energy
      Emin = min(Ea( 1 ),Eb( 1 ))
      Emax = max(Ea(n_a),Eb(n_b))
      REAL:find_root_brent(REAL::Fermi_Dirac_excess_fn,x1=Emin,x2=Emax,root=E_Fermi,tol=TOL(6))

      if (TRUE) then
         stdout.show("HOMOa     =",Ea(n_a))
         stdout.show("HOMOb     =",Eb(n_b))
         stdout.show("LUMOa     =",Ea(n_a+1))
         stdout.show("LUMOb     =",Ea(n_b+1))
         stdout.show("E_Fermi   =",E_Fermi)
      end

      ! Set the Fermi energy
      REAL:set_E_Fermi(E_Fermi)

      ! Form the temperature broadended density
      Da = ZERO
      do i = 1,MOa.dim2
         occ = REAL:Fermi_Dirac_fn(i)
         Da.plus_scaled_product_of(MOa(:,i:i),MOa(:,i:i),fac=occ,transpose_b=TRUE)
      end

      Db = ZERO
      do i = 1,MOb.dim2
         occ = REAL:Fermi_Dirac_fn(n_a+i)
         Db.plus_scaled_product_of(MOb(:,i:i),MOb(:,i:i),fac=occ,transpose_b=TRUE)
      end

   end

   make_r_density_mx ::: leaky, PURE
   ! Make the AO (spin independent) density matrix any existing density
   ! matrix. The result is placed in the "r " part.
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      ! Leaky
      .BASE:make_r_density_mx(.density_mx)

   end

   make_r_density_mx(D) ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix.
      self :: IN
      D :: OPMATRIX, INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.has_any_genre, "no density matrix")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = D.genre
      end

      select case (genre)

      case ("r ")
         ! do nothing

      case ("u ")
         D.r = D.a + D.b

      case ("gc")
         D.r = RE(D.gc.aa_block) + RE(D.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_r_density_mx(P) ::: PURE
   ! Make the AO (spin independent) density matrix "P" from the
   ! existing density matrix.
      self :: IN
      P :: MAT{REAL}, OUT
      .BASE:make_ao_RE_density_mx(P)
   end

   make_ao_RE_density_mx(P) ::: PURE
   ! Make the REAL AO (spin independent) density matrix "P" from the
   ! existing density matrix.
      self :: IN
      P :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      select case (genre)

      case ("r ")
         P = .density_mx.r

      case ("u ")
         P = .density_mx.a + .density_mx.b

      case ("gc")
         P = RE(.density_mx.gc.aa_block) &
           + RE(.density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_IM_density_mx(P) ::: PURE
   ! Make the IMAGINARY AO (spin independent) density matrix "P" from
   ! the existing density matrix.
      self :: IN
      P :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      P = ZERO

      if (genre=="r ") return
      if (genre=="u ") return

      select case (genre)

      case ("gc")
         P = IM(.density_mx.gc.aa_block) &
           + IM(.density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_r_Sz_density_mx ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix. NOTE: factor 1/2 not included.
      self :: INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      .BASE:make_r_Sz_density_mx(.density_mx)   ! leaky

   end

   make_r_Sz_density_mx(D) ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix. NOTE: factor 1/2 not included!
      self :: IN
      D :: OPMATRIX@, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.allocated, "no density matrix")
   ENSURE(D.has_any_genre, "no density matrix")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = D.genre
      end

      if (genre=="r ") return

      select case (genre)

      case ("u ")
         D.destroy("r ")
         D.create("r ")
         D.r = D.a - D.b

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_r_Sz_density_mx(P) ::: leaky, PURE
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "r " part of
   ! the density matrix. NOTE: factor 1/2 not included!
      self :: IN
      P :: MAT{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end


      select case (genre)

      case ("r ") 
         ! return

      case ("u ")
         P = .density_mx.a &
           - .density_mx.b

      case ("gc")
         P = RE(.density_mx.gc.aa_block) &
           - RE(.density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

   end

   make_c_S_densities(S) ::: leaky, PURE
   ! Make  the complex spin density matrices
   ! NOTE: factor 1/2 IS included.
      self :: IN
      S :: MAT3{CPX}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      S = ZERO


      select case (genre)

      case ("r ")
         ! return

      case ("u ")
         S(:,:,3) = .density_mx.a - .density_mx.b

      case ("gc")
         I = IMAGIFY(ONE)
         S(:,:,1) =   .density_mx.gc.ab_block &
                  +   .density_mx.gc.ba_block
         S(:,:,2) = I*.density_mx.gc.ab_block &
                  - I*.density_mx.gc.ba_block
         S(:,:,3) =   .density_mx.gc.aa_block &
                  -   .density_mx.gc.bb_block

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_RE_c_S_densities(S) ::: leaky, PURE
   ! Make the REAL part of the complex spin density matrices.
   ! NOTE: factor 1/2 IS included.
      self :: IN
      S :: MAT3{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      S = ZERO


      select case (genre)

      case ("r ")
         ! return

      case ("u ")
         S(:,:,3) = .density_mx.a - .density_mx.b

      case ("gc")
         I = IMAGIFY(ONE)
         S(:,:,1) = RE(  .density_mx.gc.ab_block)  &
                  + RE(  .density_mx.gc.ba_block)
         S(:,:,2) = RE(I*.density_mx.gc.ab_block)  &
                  - RE(I*.density_mx.gc.ba_block)
         S(:,:,3) = RE(  .density_mx.gc.aa_block) &
                  - RE(  .density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_IM_spin_densities(S) ::: leaky, PURE
   ! Make the IMAGINARY part of the AO spin density matrices.
   ! NOTE: factor 1/2 IS included.
      self :: IN
      S :: MAT3{REAL}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .density_mx.genre
      end

      S = ZERO

      if (genre=="r ")   return
      if (genre=="u ") return

      select case (genre)

      case ("gc")
         I = IMAGIFY(ONE)
         S(:,:,1) = IM(  .density_mx.gc.ab_block)  &
                  - IM(  .density_mx.gc.ba_block)
         S(:,:,2) = IM(I*.density_mx.gc.ab_block)  &
                  - IM(I*.density_mx.gc.ba_block)
         S(:,:,3) = IM(  .density_mx.gc.aa_block) &
                  - IM(  .density_mx.gc.bb_block)

    ! case default
    !    DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_SCF_density_mx(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      self :: INOUT
      n  :: INT, IN
      nb :: INT, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.MOs.allocated, "no molecular orbitals")

      genre :: STR
      arch :: ARCHIVE
      m :: INT
      uhf :: BIN

      uhf = .scfdata.SCF_kind.includes("u ")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")

      m = n
      if (present(nb)) m = nb

      genre = .scfdata.spinorbital_genre
      .density_mx.destroy(genre)
      .density_mx.create(genre)

      select case (.scfdata.SCF_kind)

      case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")

         ENSURE(.spin_multiplicity==1,"Not a singlet state: "//trim(.atom.chemical_formula)//", mult="//trim(.spin_multiplicity.to_str))

         if (n>0 AND n<=.n_a) then
            .density_mx.r.to_scaled_product_of(.MOs.r(:,n:n),.MOs.r(:,n:n),fac=TWO,transpose_b=TRUE)
         else
            .density_mx.r = ZERO
         end

      case ("rohf")

         if (n>0 AND n<=.n_b) then
            .density_mx.a.to_product_of(.MOs.a(:,n:n),.MOs.a(:,n:n),transpose_b=TRUE)
            .density_mx.b.to_product_of(.MOs.b(:,n:n),.MOs.b(:,n:n),transpose_b=TRUE)
         else if (n>nb AND n<=.n_a) then
            .MOs.a(:,n:n) = .MOs.r(:,n:n)
            .density_mx.a.to_product_of(.MOs.a(:,n:n),.MOs.a(:,n:n),transpose_b=TRUE)
            .density_mx.a = ZERO
            .density_mx.b = ZERO
         end

      case ("uhf","uks","xray_uhf","xray_uks", &
            "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")


         if (n>0 AND n<=.n_a) then
            .density_mx.a.to_product_of(.MOs.a(:,n:n),.MOs.a(:,n:n),transpose_b=TRUE)
         else
            .density_mx.a = ZERO
         end

         if (m>0 AND m<=.n_b) then
            .density_mx.b.to_product_of(.MOs.b(:,m:m),.MOs.b(:,m:m),transpose_b=TRUE)
         else
            .density_mx.b = ZERO
         end

      case ("gchf","xray_gchf")

         if (n>0 AND n<=.n_e) then
            .density_mx.gc.to_product_of(.MOs.gc(:,n:n),.MOs.gc(:,n:n),dagger_b=TRUE)
         else
            .density_mx.gc = ZERO
         end

      case default;
         DIE("unknown kind, "//trim(.scfdata.SCF_kind))

      end

      ! Archive
      arch.set(.name,"density_mx",genre)
      arch.write(.density_mx)

   end

!  ==========================
!  Set atoms density matrices
!  ========================== 

   make_aspherical_atoms ::: leaky 
   ! Get the aspherical atom density matrix i.e. just copy the 
   ! atom-atom block from the molecular density matrix.  
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms") 
   ENSURE(.atom_info_made,"no atom info") 
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.has_any_genre,"no density_mx")

      D :: OPMATRIX@
      genre :: STR
      a :: INT

      if (.INQ:has_all_ANO_matrices) .SET:destroy_ANO_matrices

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Copy existing density matrix
      D = .density_mx

      ! Make the restricted density matrix
      .BASE:make_r_density_mx(D)


      ! Set athe atom densities
      do a = 1,.n_atom
         .BASE:set_density_mx_for_atom(a,D.r)
      end

      D.destroy

   end

   set_density_mx_for_atom(a,D) ::: leaky, private
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      a :: INT
      D :: MAT{REAL}, IN

   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.r.allocated,"no density_mx")

      f,l :: INT

      ! Create a-th atoms density matrix
      .atom(a).density_mx.destroy
      .atom(a).density_mx.create(.atom(a).basis.n_bf)
      .atom(a).density_mx.create(genre="r ")

      ! Copy the a-th atom-atom block
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      .atom(a).density_mx.r = D(f:l,f:l)

      .atom(a).set_atom_data_made(TRUE)

   end

!  Spherically average atoms in existing density

   make_spherical_atoms ::: leaky
   ! Get the spherical atom natural orbitals (ANO) data for all
   ! atoms in the molecule.

   ENSURE(.atom.allocated,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.allocated,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_mx.allocated,"no density_mx")
   ENSURE(.density_mx.has_any_genre,"no density_mx")

      D :: OPMATRIX@
      genre :: STR
      a :: INT

      if (.INQ:has_all_atom_data) return

      if (.INQ:has_all_ANO_matrices) .SET:destroy_ANO_matrices

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.allocated) then; genre = .scfdata.spinorbital_genre
      else;                         genre = .MOs.genre
      end

      ! Copy existing density matrix
      D = .density_mx

      ! Make the restricted density matrix
      .BASE:make_r_density_mx(D)


      ! Spherically average the molecule AO density
      do a = 1,.n_atom
         .BASE:spherically_average_atom(a,D.r)
      end
      D.destroy

      .atom.set_atom_data_made(TRUE)

   end

   spherically_average_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      self :: INOUT
      a :: INT, IN
      D :: MAT{REAL}, IN

   ENSURE(.atom(a).NOs.deallocated,  "NOs, atom "//trim(a.to_str))
   ENSURE(.atom(a).NO_occ_nos.deallocated,"occ, atom "//trim(a.to_str))
   ENSURE(.atom(a).density_mx.deallocated,    "DM, atom "//trim(a.to_str))

      f,l :: INT
      mol :: MOLECULE@

      ! Create the molecule
      mol.SET:create
      .SET:set_molecule_from_atom(a,mol)

      ! Get the density matrix
      mol.density_mx.create(mol.n_bf)
      mol.density_mx.create(genre="r ")
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      mol.density_mx.r = D(f:l,f:l)

      ! Spherically average the AO density
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.BASE:symmetrize(mol.density_mx)

      ! Make the natural orbitals
      mol.BASE:make_NOs

      ! Clean up the SCF files
      mol.SET:delete_archive("NOs")
      mol.SET:delete_archive("NO_occ_nos")

      ! Destroy the atoms's NO and interpolator info
      .atom(a).interpolator.destroy
      .atom(a).density_mx.destroy
      .atom(a).NO_occ_nos.destroy
      .atom(a).NOs.destroy

      ! Copy the results
      .atom(a).NOs   = mol.NOs
      .atom(a).NO_occ_nos = mol.NO_occ_nos
      .atom(a).density_mx     = mol.density_mx

      ! Make the interpolator
      .atom(a).make_interpolator

      ! Nullify parts we just copied or can't destroy
      mol.atom.destroy_ptr_part       ! do not destroy ptr part

      ! Safe to destroy
      mol.SET:destroy

   end

!  =================
!  Expectation value
!  =================

   expectation(X) result (res) ::: PURE
   ! Evaluates the expectation value of the matrix of the operator X
   ! with the current density matrix
      self :: IN
      X :: MAT{REAL}, IN
      res :: REAL

   ENSURE(X.is_square,"X operator matrix is not square")

      orb_kind :: STR
      W :: MAT{REAL}@

      res = ZERO

      orb_kind = .density_mx.genre

      select case (orb_kind)

      case ("r ")
         ENSURE(X.dim1==.n_bf,"(rhf) wrong size, X")
         res = .density_mx.r.trace_product_with(X)

      case ("u ")
         ENSURE(X.dim1==.n_bf,"(uhf) wrong size, X")
         res = .density_mx.a.trace_product_with(X)
         res = .density_mx.b.trace_product_with(X) + res

      case ("gc")
         ENSURE(X.dim1==2*.n_bf,"(gchf) wrong size, X")
         W.create(2*.n_bf,2*.n_bf)
         W = RE(.density_mx.gc)
         res = MAT{REAL}:trace_product_with(W,X)
         W.destroy

    ! case default
    !    DIE("unimplemented kind, "//trim(orb_kind))

      end

   end

   expectation(X,with_cross_terms) result (res) ::: PURE
   ! Evaluates the expectation value of the matrix of the opmatrix X
   ! with the current density matrix
      self :: IN
      X :: OPMATRIX, IN
      with_cross_terms :: BIN, optional, IN
      res :: REAL

      orb_kind :: STR
      op_kind  :: STR
      cross_terms :: BIN

      res = ZERO
      cross_terms = FALSE
      if (present(with_cross_terms)) cross_terms = with_cross_terms

      orb_kind = .density_mx.genre
      op_kind = X.genre

      select case (orb_kind)

      case ("r ")
         if(op_kind=="r ") then
            ENSURE(X.r.dim1==.n_bf,"(rhf) wrong size, X")
            res = .density_mx.r.trace_product_with(X.r)
         else
            ENSURE(X.a.dim1==.n_bf,"(rhf) wrong size, X")
            res = .density_mx.r.trace_product_with(X.a)
            res = .density_mx.r.trace_product_with(X.b) + res
         end

      case ("u ")
         if(op_kind=="r ") then
            ENSURE(X.r.dim1==.density_mx.a.dim1,"(uhf) wrong size, X")
            res = .density_mx.a.trace_product_with(X.r)
            res = .density_mx.b.trace_product_with(X.r) + res
         else
            ENSURE(X.a.dim1==.density_mx.a.dim1,"(uhf) wrong size, X")
            res = .density_mx.a.trace_product_with(X.a)
            res = .density_mx.b.trace_product_with(X.b) + res
            if (cross_terms) then
               res = .density_mx.a.trace_product_with(X.b) + res
               res = .density_mx.b.trace_product_with(X.a) + res
            end
         end

    ! case default
    !    DIE("unimplemented kind, "//trim(orb_kind))

      end

   end

!  ===========================
!  Cluster generation routines
!  ===========================

   destroy_cluster ::: leaky, PURE
   ! Destroy a molecule created by the "create_cluster" routine, 
   ! and recover the original molecule from .saved
      self :: allocatable, INOUT

   ENSURE(.saved.allocated,"no crystal data")

      .SET:unsave

   end

   create_cluster ::: leaky
   ! Create a new "self" by generating a cluster from information
   ! stored in .cluster.  The original molecule replaced by the
   ! *cluster-fragent* and stored in .saved. The new molecule is
   ! created from the cluster geometry.
      self :: allocatable, INOUT

   ENSURE(.crystal.allocated,"no crystal data")
   ENSURE(.cluster.allocated,"no cluster data")
   ENSURE(.cluster.info_made,"no cluster data")

      stdout.flush
      stdout.text("Resetting molecule to cluster fragment")

      ! Reset .atom list to the *cluster-fragment*
      .atom.destroy
      .cluster.create_fragment_atom_list(.atom)

      ! Finalize basis on new .atom list
      .atom_info_made = FALSE
      .BASE:update_atom_basis_group_info
      .crystal.update_fragment_info(.atom)

      ! Message
      stdout.flush
      stdout.text("Saving old molecule; making new cluster")
      stdout.flush

      ! Save this molecule & get a clean new molecule
      .SET:save

      ! The name for the new cluster
      .name = trim(.saved.name) // "_cluster"

      ! If a CIF exists, copy that
      if (.saved.cif.allocated) .cif = .saved.cif

      ! Saved crystal is the same
      .crystal = .saved.crystal

      ! Set .atom list from (saved) cluster
      ! Don't make a new cluster, let the user do it.
      .saved.cluster.create_atom_list(.atom)

      ! Create basis sets
      if (.saved.basis.allocated)        .basis        = .saved.basis
      if (.saved.slaterbasis.allocated)  .slaterbasis  = .saved.slaterbasis
      if (.saved.coppensbasis.allocated) .coppensbasis = .saved.coppensbasis
      .basis_name        = .saved.basis_name
      .slaterbasis_name  = .saved.slaterbasis_name
      .coppensbasis_name = .saved.coppensbasis_name

      ! Finalize atom info
      if (.atom.allocated) .atom.destroy_bases
      .atom_info_made = FALSE
      .BASE:update_atom_basis_group_info

      ! Redo crystal.atoms
      .crystal.update_fragment_info(.atom)

   end

!  =====================
!  Atoms and atom groups
!  =====================

   update_atom_basis_group_info ::: leaky
   ! Update the atom labels, no of electrons, spin multiplicities,
   ! axis system, crystal fragment info, and bases; remove isosurface.
      self :: INOUT

      .SET:update_atom_and_basis_info_no_grp

      .BASE:update_atom_groups

      .atom_info_made = TRUE

   end

   update_atom_groups ::: leaky
   ! Update the .atom_group information
      self :: INOUT

      if (.atom.deallocated) return

      if (.atom.has_cartesian_axes) then

         ! We have .atom()'s ...
         if (.crystal.use_Ryde_capping) then
            ! Ulf Ryde's capped residues
            ! WARNING: .atom_groups list only (parent) uncapped atoms
            .BASE:set_Ryde_capped_groups ! NOT PURE
         else if (.atom_group.has_atom_indices) then
            ! User set atom_indices for each atom_group 
            .BASE:set_atom_group_mols   ! NOT PURE
         else 
            ! Make .atom_group's from connection table
            .SET:set_connected_atom_groups
            .BASE:set_atom_group_mols
         end

      end

   end

   set_atom_group_mols ::: leaky
   ! Make the ".atom_group.mol" molecules
      self :: INOUT

   ENSURE(.atom.allocated,"no atoms!")

      g :: INT

      if (.atom_group.deallocated) return

      ! Regenerate molecules
      if (allocated(.mol)) deallocate(.mol)
      allocate(.mol(.atom_group.dim))

      ! Check is indices are sensible
      .atom_group.update(.atom)
      
      ! Create each group from "self"
      do g = 1,.atom_group.dim
      
         ! Create mol & define it
         ! ... including mol.crystal part
         .SET:set_molecule_from_atom_group(g,.mol(g)) ! NOT PURE
      
         ! Read the MOs & make the density
         ! This won't work until Tonto can read in its own dump
       ! if (.atom_group(g).MO_file_name/=" ") then
       !     .mol(g).READ:read_archive("MOs","r ")
       !     .mol(g).BASE:make_SCF_density_mx
       ! end
      
         ! Rotate and translate mol
         if (.atom_group(g).transform_group) then
            .mol(g).BASE:rotate_by(.atom_group(g).rotation_mx)
            .mol(g).atom.translate_by(.atom_group(g).shift)
         end
         .mol(g).atom.set_group_to(g)
         .mol(g).name = .atom_group(g).name
      
      end

      ! Update atom_group info from self
      ! ANOs done above already.
      .SET:update_group_crystal_and_ANOs(skip_ANOs=TRUE)

   end

   join_atom_groups ::: leaky
   ! Delete any existing .atom and .basis and set to the concatenation
   ! of the molecules in .atom_group
      self :: target, INOUT

   ENSURE(.atom_group.allocated,"no .atom_group")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")

      g, charge, unpaired_electrons :: INT

      if (.atom.allocated)  .atom.destroy
      if (.basis.allocated) .basis.destroy

      charge = 0
      unpaired_electrons = 0

      ! Append remaining ...
      do g = 1,.atom_group.dim

         DIE_IF(.mol(g).basis.deallocated,"no basis on mol "//trim(g.to_str))
         DIE_IF(.mol(g).atom.deallocated, "no atoms in mol "//trim(g.to_str))

         charge = charge + .mol(g).charge
         unpaired_electrons = unpaired_electrons + .mol(g).spin_multiplicity - 1 

         if (g==1) then

            ! Initial atom/basis list
            .name  = .atom_group(g).name
            .basis = .mol(g).basis
            .atom  = .mol(g).atom

         else

            ! Append basis & atoms
            .name = trim(.name) // "_" // trim(.atom_group(g).name)
            .basis.append(.mol(g).basis)
            .atom.append(.mol(g).atom)

         end

      end

      ! Unresolve atomic bases
      .atom.destroy_bases

      ! Uniquify basis
      .basis.remove_repetitions

      ! Finally: set atom info & basis info (leaky)
      .SET:set_charge(charge)
      .SET:set_spin_multiplicity(unpaired_electrons + 1)

      ! Finalise atom info
      .SET:update_atom_and_basis_info_no_grp

   end

   rotate_group(g,axis,angle) ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
      self :: INOUT
      g :: INT, IN
      axis :: VEC{REAL}(3), IN
      angle :: REAL, IN

   ENSURE(.atom_group.allocated,"no atom group information")

      mol :: MOLECULE@
      archive :: ARCHIVE
      R :: MAT{REAL}(3,3)
      v :: VEC{REAL}(3)
      P :: MAT{REAL}@
      i,a :: INT

      ! Clean up different-geometry data
      .SET:delete_SCF_archives

      R.to_3x3_rotation_mx(axis,angle)

      ! Rotate atoms; the line below does not work
      do i = 1,.atom_group(g).n_atoms
         a = .atom_group(g).atom_index(i)
         v = .atom(a).position
         .atom(a).position.to_product_of(R,v)
         .atom(a).ADP_tensor.back_transform_using(R)
      end

      .MOs.destroy         ! leaky here
      if (.density_mx.deallocated) return

      ENSURE(.density_mx.r.allocated,"group rotation for restricted DM only")

      ! Create molecule
      mol.SET:create
      .SET:set_molecule_from_atom_group(g,mol)

      ! Rotate density
      P.create(mol.n_bf,mol.n_bf)
      .SET:put_group_density_to(P,g,mol)
      mol.BASE:rotate_density_mx_r(P,R)
      .SET:set_group_density_from(P,g,mol)
      P.destroy

      mol.atom.destroy_ptr_part ! do not destroy these
      mol.SET:destroy

      ! Write out the density matrix
      archive.set(.name,"density_mx",genre="r ")
      archive.write(.density_mx)

   end

!  =====================
!  Ryde fragment capping
!  =====================

   set_Ryde_capped_groups ::: leaky
   ! Make Ulf Ryde's atom capped groups
   ! The strategy is to make them from the compound_sequence_id's
   ! which are found in an mmCIF, normally ....
      self :: INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atoms_bonded_to_atom.allocated,"no connection table")

      n_comp, g :: INT
      IDs :: VEC{INT}@

      if (NOT .crystal.use_Ryde_capping) return

      ! Assign connections ... NOT PURE
      VEC{ATOM}:assign_connection_table(.atoms_bonded_to_atom)

      n_comp = .atom.no_of_compounds

      if (.atom_group.deallocated) then
      
         ! Make groups from compound_id's
         .atom_group.create(n_comp)
         do g = 1,n_comp
            IDs = .atom(:).compound_sequence_id
            .atom_group(g).set_atom_index(IDs.indices_of_elements_matching(g))
            .atom_group(g).set_n_atoms(.atom_group(g).atom_index.dim)
         end

      end

      ! Check indices are sensible
      .atom_group.update(.atom)

      ! Destroy the group .mol s
      deallocate(.mol)
      allocate(.mol(.atom_group.dim))

      ! Make Ryde's molecular caps ... in .mol(g)
      do g = 1,.atom_group.dim
         .BASE:set_Ryde_cap_for_group(g)
      end

      ! Clear connections
      VEC{ATOM}:destroy_connection_table

   end

!   make_NN_capped_groups ::: leaky
!   ! Make atom capped groups for periodic network molecule.
!      self :: INOUT
!
!   ENSURE(.atom.allocated,"no atom info")
!   ENSURE(.atoms_bonded_to_atom.allocated,"no connection table")
!   ENSURE(.crystal.allocated, "no crystal info")
!
!      name,label :: STR
!      n_comp,nc_atoms,a :: INT
!
!      n_comp = .crystal.n_asymmetric_unit_atoms 
!
!      if (.atom_group.deallocated) then
!      
!         ! Make groups from asym atoms
!         .atom_group.create(n_comp)
!         allocate(.mol(n_comp))
!         
!         do a = 1,n_comp
!
!            ! Make cap atoms
!            .cluster.make_asym_occupation_list(a)
!            .cluster.do_NN_defragment(.cluster.occupation_list,1,nc_atoms)
!            .cluster.create_atom_list(.mol(a).atom) 
!            .atom_group(a).set_atom_index( [ a ] )
!            .atom_group(a).set_n_atoms(.cluster.n_atoms)
!            .mol(a).atom(2:).set_is_cap_atom(TRUE)
!
!            ! Correct label & atomic number for last added atom
!            ! WARNING: AN has to be set after setting unique label
!            label = "H-cap"
!            ATOM:set_label(.mol(a).atom(nc_atoms+1:),label,skip_mass=TRUE)
!            ATOM:set_atomic_number_and_mass(.mol(a).atom(nc_atoms+1:),"H ")
!            
!            ! Set charge
!            .mol(a).SET:set_charge(.atom_group(a).charge)
!
!            ! Make atom info; groups should not contain subgroups!
!            .mol(a).atom_info_made = FALSE
!            .mol(a).atom.set_group_to(a)
!            .mol(a).SET:update_atom_and_basis_info_no_grp ! no recursion
!
!            ! Reset multiplicity? NOTE: reset no. of alpha & beta electrons
!            if (.atom_group(a).spin_multiplicity_set) then
!               .mol(a).SET:set_spin_multiplicity(.atom_group(a).spin_multiplicity)
!            end
!
!            ! Set guess-type SCF defaults: no output
!            ! Will reset scf_kind based on multiplicity
!            .mol(a).SET:set_SCF_guess_defaults_from(.scfdata)
!
!            ! Set .name
!            name = "group-"//trim(a.to_str)//"-"
!            name = trim(name)//trim(.mol(a).atom.chemical_formula(with_spaces=FALSE))
!            .mol(a).SET:set_name(name)
!            .atom_group(a).set_name(name)
!
!            ! Assign basis set -- don't destroy!
!            .mol(a).SET:set_basis_name(.basis_name) ! NOT PURE
!
!            ! Copy the crystal -- destroy it!
!            ! Make separate asymm unit with only mol in it later ...
!            ! mol.crystal = .crystal
!            ! mol.crystal.update_fragment_info(mol.atom)
!               
!            ! Don't remake ANO data if there
!            .mol(a).SET:resolve_ANOs_from(self)
!         end
!      end
!
!   end

   set_Ryde_cap_for_group(g) ::: leaky
   ! Make a capped fragment for molecule "mol, the atom_group(g).mol
   ! with compound_sequence_id "g", ready for fragHAR calculation.
   ! *This routine will add extra atoms*.
      self :: INOUT
      g :: INT, IN

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.mol.allocated,"no .mol")
   ENSURE(g<=.atom_group.dim,"group number g too big")
   ENSURE(g>=1,"group number g less than 1!")
   ENSURE(.mol.dim==.atom_group.dim,"wrong size, .mol")

      name :: STR
      
      ! Start with *uncapped* .atom_group(g) atom indices ...
      .mol(g).atom = .atom(.atom_group(g).atom_index)

      ! Add cap atoms !!!!!!!!!!!!!!!
      .BASE:add_Ryde_cap_for_group(g,.mol(g))
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      ! Set charge
      .mol(g).SET:set_charge(.atom_group(g).charge)

      ! Make atom info; groups should not contain subgroups!
      .mol(g).atom_info_made = FALSE
      .mol(g).atom.set_group_to(g)
      .mol(g).SET:update_atom_and_basis_info_no_grp ! no recursion

      ! Reset multiplicity? NOTE: reset no. of alpha & beta electrons
      if (.atom_group(g).spin_multiplicity_set) then
         .mol(g).SET:set_spin_multiplicity(.atom_group(g).spin_multiplicity)
      end

      ! Set guess-type SCF defaults: no output
      ! Will reset scf_kind based on multiplicity
      .mol(g).SET:set_SCF_guess_defaults_from(.scfdata)

      ! Set .name
      name = .atom(.atom_group(g).atom_index(1)).id_compound_str
      if (name==" ") then
         name = "group-"//trim(g.to_str)//"-"
         name = trim(name)//trim(.mol(g).atom.chemical_formula(with_spaces=FALSE))
      end
      .mol(g).SET:set_name(name)
      .atom_group(g).set_name(name)

      ! Assign basis set -- don't destroy!
      .mol(g).SET:set_basis_name(.basis_name) ! NOT PURE

      ! Copy the crystal -- destroy it!
      ! Make separate asymm unit with only mol in it later ...
      if (.crystal.allocated) then
         .mol(g).crystal = .crystal
         .mol(g).crystal.update_fragment_info(.mol(g).atom)
      end
      
      ! Don't remake ANO data if there
      .mol(g).SET:resolve_ANOs_from(self)

   end

   add_Ryde_cap_for_group(g,mol) ::: private, leaky, PURE
   ! Add Ryde' caps fragment for molecule the atom_group(g).mol with
   ! compound_sequence_id "g".
      self :: INOUT
      g :: INT, IN
      mol :: MOLECULE, INOUT

   ENSURE(.atom.allocated,"no atom info")
   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(g<=.atom_group.dim,"group number g too big")
   ENSURE(g>=1,"group number g less than 1!")

      in_residue :: BIN
      bonded_atom :: MAT{INT}@
      n_bonds, g2,b,ap,bp :: INT

      ! Residue atom?
      in_residue = .atom(.atom_group(g).atom_index(1)).is_in_a_residue

      if (NOT in_residue) return

      do g2 = 1,.atom_group.dim
      
         ! Skip group "g" itself
         if (g2==g) cycle
      
         ! No. of bonds to atom_group "g2"
         n_bonds = .INQ:n_bonds_between_atom_groups(g,g2)
      
         ! Any bonds to group "g2"?
         if (n_bonds<=0) cycle
      
         ! Cap each connected group
         bonded_atom = .INQ:bonded_atoms_between_groups(g,g2)
      
         do b = 1,n_bonds
      
            ! Get atoms from each group
            ap = bonded_atom(1,b)
            bp = bonded_atom(2,b)
      
            ! Use them to start the Ryde cap
            .BASE:add_Ryde_cap_from_atoms(ap,bp,mol)

         end
      
         ! Clean
         bonded_atom.destroy
      
      end
 
   end

   add_Ryde_cap_from_atoms(ap,bp,mol) ::: private, leaky, PURE
   ! Cap residue molecule "mol" starting from atom "ap" in that
   ! residue, which is connected to atom "bp" in another group.
   ! WARNING: This will add extra atoms to atom_group(g1).mol.atom 
   ! but it won't add extra indices into atom_index!
   ! Zhang, D. W. & Zhang, J. Z. H. (2003). J. Chem. Phys., 119(7), 3599-3605.
   ! Soederhjelm, P.& Ryde, U. (2008). J. Phys. Chem. A, 113(3), 617-627
      self :: INOUT
      ap,bp :: INT, IN
      mol :: MOLECULE, INOUT

   ENSURE(.atom_group.allocated,"no atom_group info")
   ENSURE(.atoms_bonded_to_atom.allocated,"no connection table")

      i,j, cp,cf,dp,last :: INT
      bp_bonds,cp_bonds :: VEC{INT}@
      length :: REAL
      label :: STR

      ! Append connected atom bp in atom_group(g2)
      mol.atom.append(.atom(bp))
      last = mol.atom.dim
      mol.atom(last).set_cap_atom(TRUE)

      ! Find connections to atom bp ... in SMILES:
      ! -ap-res1 - bp-res2(cp_1-res2)(cp_2-res2) ...
      bp_bonds = .atoms_bonded_to_atom(bp).element

      ! Find connections to bp
      do i = 1,bp_bonds.dim

         ! This case cap atom 2
         cp = bp_bonds(i) 

         ! Already found atom in residue g
         if (cp==ap) cycle 

         ! Append new cap atom 2
         mol.atom.append(.atom(cp))
         last = mol.atom.dim
         mol.atom(last).set_cap_atom(TRUE)

         if (.atom(ap).atomic_number>1) then

            ! Add caps for all non-H atom ... should be 3
            ! (serging for cap atom 3)
            cp_bonds = .atoms_bonded_to_atom(cp).element

            ! Index of cp in atom_group(g) fragment
            cf = last

            ! Find connections to cp
            do j = 1,cp_bonds.dim

               dp = cp_bonds(j)

               ! Already found atom bp
               if (dp==bp) cycle 

               ! Append new cap atom, keep its index
               mol.atom.append(.atom(dp))
               last = mol.atom.dim
               mol.atom(last).set_cap_atom(TRUE)

               ! Correct label & atomic number for last added atom
               ! WARNING: AN has to be set after setting unique label
               label = "H-" // trim(.atom(dp).atom_sequence_id.to_str) // "-"
               label = trim(label) // trim(.atom(dp).compound_id_str)
               mol.atom(last).set_label(label,skip_mass=TRUE)
               mol.atom(last).set_atomic_number_and_mass("H ")
               mol.atom(last).set_cap_atom(TRUE)

               ! Reset bond length to last added atom
               length = CIF_CH_BOND_LENGTH*BOHR_PER_ANGSTROM
               mol.atom.set_bond_length(cf,last,length)

            end

         end

      end

   end

!  =================
!  Molecule rotation
!  =================

   rotate_by(R) ::: PURE
   ! Rotate the whole molecule using matrix "R" which specifies how
   ! positions in space are to be transformed i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(R.is_square,"rotation matrix is not square")
   ENSURE(R.dim1==3,"rotation matrix must be 3x3")

      if (R.is_zero) return

      .atom.rotate_by(R)
      .BASE:rotate_MOs(R)
      .BASE:rotate_density_mx(R)

   end

   rotate_MOs(R) ::: PURE
   ! Rotate the molecular orbital matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(STR:is_one_of(.MOs.genre,["r ","u "]),"unimplemented rotation")

      genre :: STR

      if (.MOs.deallocated) return
      if (.MOs.is_deallocated_or_no_genre) return

      genre = .MOs.genre

      select case (genre)

      case("r ")
         .BASE:rotate_MOs_r(.MOs.r,R)

      case("u ")
         .BASE:rotate_MOs_r(.MOs.a,R)
         .BASE:rotate_MOs_r(.MOs.b,R)

      end

   end

   rotate_MOs_r(MO,R) ::: PURE
   ! Rotate a restricted molecular orbitals "MO" using matrix "R",
   ! where "R" specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: IN
      MO :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO orbitals")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")
   ENSURE(NOT .use_spherical_basis,"only for cartesian bases")

      new :: MAT{REAL}@
      tr :: VEC{EMAT{REAL}}@
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],MO(f:l,:))
      end

      MO = new

      tr.destroy
      new.destroy

   end

   rotate_density_mx(R) ::: PURE
   ! Rotate the resricted density matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
   ! NOTE: the kind is taken from the MO's.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(STR:is_one_of(.MOs.genre,["r ","u "]),"unimplemented rotation")

      genre :: STR

      if (.MOs.deallocated) return
      if (.MOs.is_deallocated_or_no_genre) return

      genre = .MOs.genre

      select case (genre)

      case("r ")
         .BASE:rotate_density_mx_r(.density_mx.r,R)

      case("u ")
         .BASE:rotate_density_mx_r(.density_mx.a,R)
         .BASE:rotate_density_mx_r(.density_mx.b,R)


      end

   end

   rotate_density_mx_r(P,R) ::: PURE
   ! Rotate the density matrix "P" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      self :: IN
      P :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(P.is_square,"wrong shape for density matrix P")
   ENSURE(P.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")

      new :: MAT{REAL}@
      tr :: VEC{EMAT{REAL}}@
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],P(f:l,:))
      end

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         P(:,f:l).to_product_of(new(:,f:l),tr(a)[:,:],transpose_b=TRUE)
      end

      tr.destroy
      new.destroy

   end

   rotate_fock(R) ::: PURE
   ! Rotate the molecular orbital matrix using matrix "R" which
   ! specifies how positions in space are to be transformed
   ! i.e. x' = Rx.
      self :: INOUT
      R :: MAT{REAL}, IN

   ENSURE(STR:is_one_of(.fock_mx.genre,["r ","u "]),"unimplemented rotation")

      genre :: STR

      if (.fock_mx.deallocated) return
      if (.fock_mx.is_deallocated_or_no_genre) return

      genre = .fock_mx.genre

      select case (genre)

      case("r ")
         .BASE:rotate_fock_mx_r(.fock_mx.r,R)

      case("u ")
         .BASE:rotate_fock_mx_r(.fock_mx.a,R)
         .BASE:rotate_fock_mx_r(.fock_mx.b,R)

      end

   end

   rotate_fock_mx_r(G,R) ::: PURE
   ! Rotate the fock matrix "G" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
   ! NOTE: THIOS IS WRONG ... SEE DM rotation!
      self :: IN
      G :: MAT{REAL}, INOUT
      R :: MAT{REAL}, IN

   ENSURE(G.is_square,"wrong shape for density matrix P")
   ENSURE(G.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")

      new :: MAT{REAL}@
      tr :: VEC{EMAT{REAL}}@
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,R)

      do s = 1,.n_shell

         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)

         new(f:l,:).to_product_of(tr(a)[:,:],G(f:l,:), transpose_b=TRUE)

      end

      G = new

      tr.destroy
      new.destroy

   end


!  ==============================
!  Shift/remove linear dependence
!  ==============================

   shift_dependence_from(F)
   ! Level shift the linear dependence in "F"
      F :: OPMATRIX, INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      s_kind :: STR

      ! Extrapolate compressed entities
      s_kind = .scfdata.spinorbital_genre
      select case (s_kind)
         case("rhf","rks","xray_rhf","xray_rks","rdvpt")
            .BASE:shift_dependence_from_r(F.r)
         case("uhf","uks","rohf","pnd_uhf","pnd_uks","xray_uhf","xray_uks","xray_pnd_uhf","xray_pnd_uks")
            .BASE:shift_dependence_from_r(F.a)
            .BASE:shift_dependence_from_r(F.b)
         case default
            ! Unimplemented !!!
      end

   end

   shift_dependence_from_r(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors "evec" with small eigenvalue "eval".
   ! WARNING: this routine assumes eval's are ordered
   ! smallest to largest.
      F :: MAT{REAL}

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_eigenvalues")
   ENSURE(F.dim1==.overlap_eigenvectors.dim1,"wrong size, F")

      n :: INT
      tol,shift :: REAL

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Decouple and shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      ::decouple_and_shift_r(F,.overlap_eigenvectors,n,shift)

   end

   decouple_and_shift_r(F,evec,n,shift) ::: selfless
   ! In "F", decouple the first "n" eigenvectors "evec" and shift them
   ! to eigenvalue "shift". NOTE: ensure "evec" is orthonormal.
      F :: MAT{REAL}
      evec :: MAT{REAL}, IN
      n :: INT, IN
      shift  :: REAL, IN

   ENSURE(F.is_square,"F is not square")

      d :: INT

      ! Return if no vectores to shift/decouple
      if (n<=0) return

      d = F.dim1

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the vectors
      F(  1:n,n+1:d) = ZERO
      F(n+1:d,  1:n) = ZERO

      ! Shift the first n eigenvectors
      F(1:n,1:n).set_diagonal_to(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)

   end

   remove_dependence_from(F)
   ! Zero-out the linear dependence in "F"
      self :: INOUT
      F :: OPMATRIX, INOUT

   ENSURE(.scfdata.allocated,"no scfdata")

      s_kind :: STR

      ! Extrapolate compressed entities
      s_kind = .scfdata.spinorbital_genre
      select case (s_kind)
         case("rhf","rks","xray_rhf","xray_rks","rdvpt")
            .BASE:remove_dependence_from_r(F.r)
         case("uhf","uks","rohf","pnd_uhf","pnd_uks","xray_uhf","xray_uks","xray_pnd_uhf","xray_pnd_uks")
            .BASE:remove_dependence_from_r(F.a)
            .BASE:remove_dependence_from_r(F.b)
         case default
            ! Unimplemented !!!
      end

   end

   remove_dependence_from_r(F) ::: PURE
   ! In "F", remove the linearly-dependent overlap eigenvectors.
      self :: INOUT
      F :: MAT{REAL}, INOUT

   ENSURE(.scfdata.allocated,"no scfdata")
   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(F.dim1==.n_bf,"wrong size, F")

      tol :: REAL
      n :: INT

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Return if no vectores to shift/decouple
      if (n<=0) return

      ! Change to the eigenvector basis
      F.change_basis_using(.overlap_eigenvectors)

      ! Zero couplings 
      F( : ,1:n) = ZERO
      F(1:n, : ) = ZERO

      ! Revert from the eigenvector basis
      F.back_transform_using(.overlap_eigenvectors)

   end

!  ================
!  Natural orbitals
!  ================

   make_NOs(genre) ::: leaky
   ! Make the natural orbitals from the density matrix
      self :: INOUT
      genre :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.has_any_genre, "no density matrix")

      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .density_mx.genre
      end

      select case (orb_kind)
      case ("r "); .BASE:make_r_NOs
      case ("u "); .BASE:make_u_NOs
      case ("gc"); .BASE:make_gc_NOs
      case default; UNKNOWN(orb_kind)
      end

   end

   make_r_NOs ::: leaky
   ! Make the restricted natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.r.allocated, "no density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .NOs.destroy
      .NOs.create(.n_bf,"r ")
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,"r ")

      ! Make the restricted NO's
      .BASE:make_r_NOs(.NOs.r,.NO_occ_nos.r,.density_mx.r)

   end

   make_u_NOs ::: leaky
   ! Make the unrestricted natural orbitals from the density matrix
      self :: INOUT

   ENSURE(.density_mx.allocated, "no density matrix")
   ENSURE(.density_mx.a.allocated, "no density matrix")
   ENSURE(.density_mx.b.allocated, "no density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .NOs.destroy
      .NOs.create(.n_bf,"u ")
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,"u ")

      ! Make the unrestricted NO's
      .BASE:make_r_NOs(.NOs.a,.NO_occ_nos.a,.density_mx.a)
      .BASE:make_r_NOs(.NOs.b,.NO_occ_nos.b,.density_mx.b)

   end

   make_gc_NOs ::: leaky
   ! Make the general natural orbitals and occupations from the
   ! complex density matrix.
      self :: INOUT

   ENSURE(.density_mx.allocated,"no density matrix")
   ENSURE(.density_mx.gc.allocated,"no density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      R :: MAT{REAL}@
      V,X :: MAT{CPX}@

      ! Recreate
      .NOs.destroy
      .NOs.create(.n_bf,"gc")
      .NO_occ_nos.destroy
      .NO_occ_nos.create(.n_bf,"g")


      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)

      .BASE:make_r_overlap_sqrt(R)

      V = ZERO
      V.set_aa_block_to(R)
      V.set_bb_block_to(R)

      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .density_mx.gc
      X.change_basis_using(V)
      X.solve_hermitian_eigenproblem(.NO_occ_nos.g,V)

      R.create(.n_bf,.n_bf)
      .BASE:make_r_overlap_inverse_sqrt(R)

      X = ZERO
      X.set_aa_block_to(R)
      X.set_bb_block_to(R)
      R.destroy

      .NOs.gc.to_product_of(X,V)
      .NO_occ_nos.g = .NO_occ_nos.g(2*.n_bf:1:-1)
      .NOs.gc       =     .NOs.gc(:,2*.n_bf:1:-1)

      X.destroy
      V.destroy

   end


   make_E_NOs(genre) ::: leaky
   ! Make the energy natural orbitals from the energy density matrix
      self :: INOUT
      genre :: STR, optional, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.E_density_mx.allocated, "no density matrix")
   ENSURE(.E_density_mx.has_any_genre, "no density matrix")

      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .E_density_mx.genre
      end

      select case (orb_kind)
      case ("r "); .BASE:make_r_ENOs
      case ("u "); .BASE:make_u_ENOs
      case ("gc"); .BASE:make_gc_ENOs
      case default;  UNKNOWN(orb_kind)
      end

   end

   make_r_ENOs ::: leaky
   ! Make the restricted energy natural orbitals from the energy density matrix
      self :: INOUT

   ENSURE(.E_density_mx.allocated, "no E density matrix")
   ENSURE(.E_density_mx.r.allocated, "no E density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .E_NO_energies.destroy
      .E_NO_energies.create(.n_bf,"r ")
      .E_NOs.destroy
      .E_NOs.create(.n_bf,"r ")

      ! Make the restricted NO's
      .BASE:make_r_NOs(.E_NOs.r,.E_NO_energies.r,.E_density_mx.r)

   end

   make_u_ENOs ::: leaky
   ! Make the unrestricted energy natural orbitals from the energy density matrix
      self :: INOUT

   ENSURE(.E_density_mx.allocated, "no E density matrix")
   ENSURE(.E_density_mx.a.allocated, "no E density matrix")
   ENSURE(.E_density_mx.b.allocated, "no E density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      ! Recreate (leaky)
      .E_NO_energies.destroy
      .E_NO_energies.create(.n_bf,"u ")
      .E_NOs.destroy
      .E_NOs.create(.n_bf,"u ")

      ! Make the unrestricted NO's
      .BASE:make_r_NOs(.E_NOs.a,.E_NO_energies.a,.E_density_mx.a,reverse_order=FALSE)
      .BASE:make_r_NOs(.E_NOs.b, .E_NO_energies.b, .E_density_mx.b, reverse_order=FALSE)

   end

   make_gc_ENOs ::: leaky
   ! Make the general energy natural orbitals and eigenvalues from the
   ! general complex energy density matrix.
      self :: INOUT

   ENSURE(.E_density_mx.allocated,"no E_density matrix")
   ENSURE(.E_density_mx.gc.allocated,"no E density matrix")
   ENSURE(.overlap_mx.allocated, "no overlap matrix")

      R :: MAT{REAL}@
      V,X :: MAT{CPX}@

      ! Recreate
      .E_NOs.destroy
      .E_NOs.create(.n_bf,"gc")
      .E_NO_energies.destroy
      .E_NO_energies.create(.n_bf,"g ")


      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)
      .BASE:make_r_overlap_sqrt(R)

      V = ZERO
      V.set_aa_block_to(R)
      V.set_bb_block_to(R)
      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .E_density_mx.gc
      X.change_basis_using(V)
      X.solve_hermitian_eigenproblem(.E_NO_energies.g,V)

      R.create(.n_bf,.n_bf)
      .BASE:make_r_overlap_inverse_sqrt(R)

      X = ZERO
      X.set_aa_block_to(R)
      X.set_bb_block_to(R)
      R.destroy

      .E_NOs.gc.to_product_of(X,V)

      X.destroy
      V.destroy

   end


   make_r_NOs(NO,occupation,P,reverse_order)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      self :: INOUT
      NO,P :: MAT{REAL}
      occupation :: VEC{REAL}
      reverse_order :: BIN, optional, IN

   ENSURE(.overlap_mx.allocated,"no overlap matrix")

      reverse :: BIN
      V,X :: MAT{REAL}@

      reverse = TRUE
      if (present(reverse_order)) reverse = reverse_order

      V.create(.n_bf,.n_bf)
      .BASE:make_r_overlap_sqrt(V)

      X.create(.n_bf,.n_bf)

      P.change_basis_to(X,V)
      X.solve_symmetric_eigenproblem(occupation,V)

      .BASE:make_r_overlap_inverse_sqrt(X)

      NO.to_product_of(X,V)

      X.destroy
      V.destroy

      if (reverse) then
         occupation = occupation(.n_bf:1:-1)
         NO         = NO(:,.n_bf:1:-1)
      end

   end


   make_density_mx_from(NO,occupations,genre) ::: leaky
   ! Make the density_mx from the natural orbitals and the
   ! occupation numbers.
      NO :: OPMATRIX, IN
      occupations :: OPVECTOR, IN
      genre :: STR, IN, optional

   ENSURE(.basis_info_made, "no basis info")


      genus :: STR
      Pr :: MAT{REAL}@


      if (present(genre)) then; genus = genre
      else;                     genus = .NOs.genre
      end

      select case (genus)

      case ("r ")
          ENSURE(NO.r.allocated,"no restricted NOs")
          ENSURE(occupations.r.allocated,"no restricted occupations")
          .density_mx.destroy
          .density_mx.create(.n_bf,"r ")
          Pr.create(.n_bf,.n_bf)
          Pr.to_product_with_diagonal(NO.r,occupations.r)
          .density_mx.r.to_product_of(Pr,NO.r,transpose_b=TRUE)
          Pr.destroy

      case ("u ")
          ENSURE(NO.a.allocated,"no alpha NOs")
          ENSURE(NO.b.allocated, "no beta NOs")
          ENSURE(occupations.a.allocated,"no alpha occupations")
          ENSURE(occupations.b.allocated, "no beta occupations")
          .density_mx.destroy
          .density_mx.create(.n_bf,"u ")
          Pr.create(.n_bf,.n_bf)
          Pr.to_product_with_diagonal(NO.a,occupations.a)
          .density_mx.a.to_product_of(Pr,NO.a,transpose_b=TRUE)
          Pr.to_product_with_diagonal(NO.b,occupations.b)
          .density_mx.b.to_product_of(Pr,NO.b,transpose_b=TRUE)
          Pr.destroy

      case default
          UNKNOWN(genus)

      end

   end


!  ===================
!  Overlap matrix sqrt
!  ===================

   make_r_overlap_sqrt(S_sqrt) ::: leaky
   ! Get "S_sqrt", the sqrt overlap matrix
      S_sqrt :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_values")
   ENSURE(S_sqrt.is_square,"non-square S_qrt")
   ENSURE(S_sqrt.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.allocated) then
         tol   = .scfdata.linear_dependence_tol
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

   make_r_overlap_inverse_sqrt(S_inv) ::: leaky, PURE
   ! Get "S_inv", the inverse sqrt overlap matrix
      self  :: INOUT
      S_inv :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.allocated,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.allocated,"no overlap_values")
   ENSURE(S_inv.is_square,"non-square S_inv")
   ENSURE(S_inv.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.allocated) then
         tol = .scfdata.linear_dependence_tol
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

!  ==========================
!  Natural orbital assignment
!  ==========================

   assign_NOs_to_MOs ::: leaky
   ! Copy the natural orbitals to be the MOs.
   ! If the MO's are not there, try and read them from disk.
   ! The occupation numbers are the MO ones.
      self :: target, INOUT

   ENSURE(.MOs.allocated, "no molecular orbitals")
   ENSURE(.MOs.has_any_genre, "no molecular orbitals")

      arch  :: ARCHIVE
      genre :: STR
      g :: INT

      ! Get MOs
      if (.MOs.allocated) then
         ! Already there
         genre = .MOs.genre
      else if (.scfdata.allocated) then
         ! Does it exist on disk?
         genre = .scfdata.spinorbital_genre
         arch.set(.name,"MOs",genre)
         if (arch.exists) then
            .MOs.create(.n_bf)
            arch.read(.MOs)
            .MOs.unnormalize("1",.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
            arch.close
         end
      end

      ! Clone the MO's
      if (.MOs.allocated) then
         .NOs = .MOs
         .NO_occ_nos.create(.n_bf,genre)
         .NO_occ_nos.set_to_zero
         .SET:set_SCF_occupations_for_NOs(genre)
      end

      if (.atom_group.allocated) then
      if (.mol.allocated) then
         
         do g = 1,.atom_group.dim

            ! Should be generalised to read archives like above ...
            if (.mol(g).MOs.deallocated) cycle

            genre = .mol(g).MOs.genre
            .mol(g).NOs = .mol(g).MOs
            .mol(g).NO_occ_nos.create(.mol(g).n_bf,genre)
            .mol(g).NO_occ_nos.set_to_zero
            .mol(g).SET:set_SCF_occupations_for_NOs(genre)

         end

      end
      end

   end

   assign_MOs_to_NOs ::: leaky
   ! Copy the MOs to be the same as the natural orbitals
   ! The occupation numbers are the MO ones.
      self :: target, INOUT

      genre :: STR
      g :: INT

      ! Clone
      if (.NOs.allocated) then
         genre = .NOs.genre
         .MOs = .NOs
         .NO_occ_nos.create(.n_bf,genre)
         .NO_occ_nos.set_to_zero
         .SET:set_SCF_occupations_for_NOs(genre)
      end

      if (.atom_group.allocated) then
      if (.mol.allocated) then
         
         do g = 1,.atom_group.dim

            if (.mol(g).NOs.deallocated) cycle

            genre = .NOs.genre
            .mol(g).MOs = .mol(g).NOs
            .mol(g).NO_occ_nos.create(.n_bf,genre)
            .mol(g).NO_occ_nos.set_to_zero
            .mol(g).SET:set_SCF_occupations_for_NOs(genre)

         end

      end
      end

   end

!  ================
!  Symmetry methods
!  ================

   symmetrize(mat,orb_kind)
   ! Symmetrize an opmatrix matrix "mat" and of spinorbital_genre
   ! "orb_kind" (if specified)
      self :: IN
      mat :: OPMATRIX, INOUT
      orb_kind :: STR, optional, IN

      itemkind :: STR

      itemkind = mat.genre
      if (present(orb_kind)) itemkind = orb_kind

      select case (itemkind)
      case ("r ")
         .BASE:symmetrize(mat.r)
      case ("u ")
         .BASE:symmetrize(mat.a)
         .BASE:symmetrize(mat.b)
      case ("gc")
         .BASE:symmetrize(mat.gc.aa_block_ptr)
         .BASE:symmetrize(mat.gc.bb_block_ptr)
         .BASE:symmetrize(mat.gc.ab_block_ptr)
         .BASE:symmetrize(mat.gc.ba_block_ptr)
    ! case default;   DIE("unknown kind, "//trim(orb_kind))
      end

   end


   symmetrize(mat) ::: template, PURE
   ! Symmetrize a matrix
      self :: IN
      mat :: MAT{TYPE?}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.pointgroup.allocated, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,W :: MAT{TYPE?}@
      tra,trb :: MAT{REAL}@
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}@

      image.create(.n_shell, .pointgroup.order)
      .BASE:make_pg_image_of_shell(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.pointgroup.order

         do a = 1,.n_shell

            tra = .pointgroup.xyz_mx(n,.angular_moment_for_shell(a))
            i  = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb = .pointgroup.xyz_mx(n,.angular_moment_for_shell(b))
               j  = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               W.create(na,nb)
               W.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(W,trb,transpose_b=TRUE)
               W.destroy

            end

         end

      end

      mat = sym/REALIFY(.pointgroup.order)

      sym.destroy
      image.destroy

   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE?=>REAL)
   ! Symmetrize a matrix
   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE?=>CPX)
   ! Symmetrize a matrix
   end

   make_pg_image_of_shell(res) ::: PURE
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! pointgroup operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      self :: IN
      res :: MAT{INT}, OUT

   ENSURE(.pointgroup.allocated, "no pointgroup")
   ENSURE(res.dim1==.n_shell,          "wrong dim2, res")
   ENSURE(res.dim2==.pointgroup.order, "wrong dime2, res")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.pointgroup.order
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos.to_product_of(.pointgroup.mx(:,:,n), .atom(aa).position)

         new_atom = .atom.atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end


   symmetrize_DM_like_mx(DM) ::: template, PURE
   ! Symmetrize a density matrix-like object "DM" using the crystal
   ! seitz operators. 
      self :: IN
      DM :: MAT{TYPE?}, INOUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated,"No crystal")
   ENSURE(.crystal.fragment_info_made,"No crystal")
   ENSURE(DM.is_square,"non-square matrix")
   ENSURE(DM.dim1==.n_bf,"incorrectly dimensioned matrix")

      tr :: VEC{EMAT{REAL}}@
      sym,blk :: MAT{TYPE?}@
      tra,trb :: MAT{REAL}@
      imshcnt :: MAT{INT}@
      g :: INT
      a,fa,la,ma :: INT
      b,fb,lb,mb :: INT
      i,fi,li    :: INT
      j,fj,lj    :: INT
      symops  :: MAT3{REAL}@
      image  :: MAT{INT}@

      ! Symops
      symops = .crystal.xyz_seitz_matrices

      ! Make image shell map
      image.create(.n_shell,.crystal.spacegroup.n_seitz)
      .BASE:make_sg_image_of_shell(image)

      ! Rotated and accumulated SM coeffcients
      sym.create(.n_bf,.n_bf)
      sym = DM

    ! stdout.text("DM:")
    ! stdout.put(DM)
      
      ! Counter for image-shell blocks
      imshcnt.create(.n_shell, .n_shell)
      imshcnt = 1

      ! Zero lower-triangle symmetry-dependent blocks
      ! Reset image shell block counts
    ! do a = 1,.n_shell
    ! do b = 1,a
    !    
    !    atom_a = .atom_for_shell(a)
    !    atom_b = .atom_for_shell(b)

    !    !  Unique atom block?
    !    ua = any(atom_a==.crystal.unique_frag_atom) 
    !    ub = any(atom_b==.crystal.unique_frag_atom) 

    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)
    !    fb = .first_basis_fn_for_shell(b)
    !    lb = .last_basis_fn_for_shell(b)
    !    
    !    if (NOT ua AND NOT ub) then
    !       ! Zero block: At least one of (a,b) is 
    !       ! related to a unique fragment atom.
    !       sym(fa:la,fb:lb) = ZERO
    !       sym(fb:lb,fa:la) = ZERO
    !    else
    !       ! Count block & copy
    !       imshcnt(a,b) = 1
    !       imshcnt(b,a) = 1
    !       sym(fa:la,fb:lb) = DM(fa:la,fb:lb)
    !       sym(fb:lb,fa:la) = DM(fb:lb,fa:la)
    !    end

    ! end
    ! end

      ! Generate Symmetry-dependent blocks
      do a = 1,.n_shell

       ! ! Only do unique (asym-atom-corresponding) frag atoms
       ! atom_a = .atom_for_shell(a)
       ! ua = any(atom_a==.crystal.unique_frag_atom)
       ! if (NOT ua) cycle

         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         ma = .angular_moment_for_shell(a)

         do b = 1,a

            ! Do any atom for shell b
            fb = .first_basis_fn_for_shell(b)
            lb = .last_basis_fn_for_shell(b)
            mb = .angular_moment_for_shell(b)

            do g = 2,.crystal.spacegroup.n_seitz

               i = image(a,g)
               j = image(b,g)

               if (i==0 OR j==0) cycle

               fi = .first_basis_fn_for_shell(i)
               li = .last_basis_fn_for_shell(i)
               fj = .first_basis_fn_for_shell(j)
               lj = .last_basis_fn_for_shell(j)

               GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,symops(:,:,g))
               tra = tr(ma)[:,:]
               trb = transpose(tr(mb)[:,:])
               blk = matmul( matmul(tra,DM(fa:la,fb:lb)), trb)

               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + blk
               sym(fj:lj,fi:li) = sym(fj:lj,fi:li) + transpose(blk)

               imshcnt(i,j) = imshcnt(i,j) + 1
               imshcnt(j,i) = imshcnt(j,i) + 1

               tr.destroy

            end

         end

      end

      ! Divide unique blocks by symmetrisation factors
      do a = 1,.n_shell
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         do b = 1,.n_shell
            fb = .first_basis_fn_for_shell(b)
            lb = .last_basis_fn_for_shell(b)
            if (imshcnt(a,b)>0) then
               sym(fa:la,fb:lb) = sym(fa:la,fb:lb)/imshcnt(a,b)
            end
         end
      end

      ! Reset image shell block counts
      ! for symmetry-dependent blocks
    ! imshcnt = 0
    ! do a = 1,.n_shell

    !    atom_a = .atom_for_shell(a)
    !    ua = any(atom_a==.crystal.unique_frag_atom) 
    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)

    !    do b = 1,a
    !    
    !       atom_b = .atom_for_shell(b)
    !       ub = any(atom_b==.crystal.unique_frag_atom) 
    !       fb = .first_basis_fn_for_shell(b)
    !       lb = .last_basis_fn_for_shell(b)
    !      
    !       !  Unique atom block?
    !       if (NOT ua AND NOT ub) then
    !       if (imshcnt(a,b)==0) then
    !          ! Do block this time
    !          imshcnt(a,b) = 1
    !          imshcnt(b,a) = 1
    !          sym(fa:la,fb:lb) = DM(fa:la,fb:lb)
    !          sym(fb:lb,fa:la) = DM(fb:lb,fa:la)
    !       end
    !       end

    !    end

    ! end

    ! ! Symmetrise dependent blocks amonst only themselves
    ! ! This is not ideal: we probably want to copy out from
    ! ! the unique blocks. Maybe fiddle with the image array?
    ! do a = 1,.n_shell

    !    ! Only do unique (asym-atom-corresponding) frag atoms
    !    atom_a = .atom_for_shell(a)
    !    ua = any(atom_a==.crystal.unique_frag_atom)
    !    if (ua) cycle

    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)
    !    ma = .angular_moment_for_shell(a)

    !    do b = 1,a

    !       atom_b = .atom_for_shell(b)
    !       ub = any(atom_b==.crystal.unique_frag_atom)
    !       if (ub) cycle

    !       ! Do any atom for shell b
    !       fb = .first_basis_fn_for_shell(b)
    !       lb = .last_basis_fn_for_shell(b)
    !       mb = .angular_moment_for_shell(b)

    !       do g = 2,.crystal.spacegroup.n_seitz

    !          i = image(a,g)
    !          j = image(b,g)

    !          if (i==0 OR j==0) cycle

    !          !  Unique image atom block?
    !          atom_i = .atom_for_shell(i)
    !          atom_j = .atom_for_shell(j)

    !          ui = any(atom_i==.crystal.unique_frag_atom) 
    !          uj = any(atom_j==.crystal.unique_frag_atom) 

    !          if (NOT ui AND NOT uj) then

    !             fi = .first_basis_fn_for_shell(i)
    !             li =  .last_basis_fn_for_shell(i)
    !             fj = .first_basis_fn_for_shell(j)
    !             lj =  .last_basis_fn_for_shell(j)
    !            
    !             GAUSSIAN_DATA:make_gaussian_xyz_matrices(tr,symops(:,:,g))
    !            
    !             tra = tr(ma)[:,:]
    !             trb = transpose(tr(mb)[:,:])
    !             blk = matmul( matmul(tra,DM(fa:la,fb:lb)), trb)
    !            
    !             sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + blk
    !             sym(fj:lj,fi:li) = sym(fj:lj,fi:li) + transpose(blk)
    !            
    !             imshcnt(i,j) = imshcnt(i,j) + 1
    !             imshcnt(j,i) = imshcnt(j,i) + 1
    !            
    !             tr.destroy

    !          end

    !       end

    !    end

    ! end

    ! ! Divide unique blocks by symmetrisation factors
    ! do a = 1,.n_shell
    !    atom_a = .atom_for_shell(a)
    !    ua = any(atom_a==.crystal.unique_frag_atom) 
    !    fa = .first_basis_fn_for_shell(a)
    !    la = .last_basis_fn_for_shell(a)
    !    do b = 1,.n_shell
    !       atom_b = .atom_for_shell(b)
    !       ub = any(atom_b==.crystal.unique_frag_atom) 
    !       fb = .first_basis_fn_for_shell(b)
    !       lb = .last_basis_fn_for_shell(b)
    !       if (NOT ua AND NOT ub) then
    !       if (imshcnt(a,b)>0) then
    !          sym(fa:la,fb:lb) = sym(fa:la,fb:lb)/imshcnt(a,b)
    !       end
    !       end
    !    end
    ! end

      DM = sym

    ! stdout.text("DM 2:")
    ! stdout.put(DM)

      ! Clean
      sym.destroy
      image.destroy
      imshcnt.destroy
      symops.destroy

   end

   symmetrize_DM_like_mx(DM) ::: get_from(symmetrize_DM_like_mx, TYPE?=>REAL), PURE
   ! Symmetrize a density matrix-like object "DM" using the crystal
   ! seitz operators. 
   end

   symmetrize_DM_like_mx(DM) ::: get_from(symmetrize_DM_like_mx, TYPE?=>CPX), PURE
   ! Symmetrize a density matrix-like object "DM" using the crystal
   ! seitz operators. 
   end


   make_sg_image_of_shell(res) ::: PURE
   ! Return an array "res(s,g)" which is the image of shell "s" under
   ! *spacegroup* operation "g" ignoring whole cell translations.
   ! Size of "res" is [.n_shell,.crystal.spacegroup.n_seitz]
      self :: IN
      res  :: MAT{INT}, OUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(.crystal.spacegroup.analyzed, "crystal spacegroup not analyzed")
   ENSURE(res.dim1==.n_shell, "wrong dim2, res")
   ENSURE(res.dim2==.crystal.spacegroup.n_seitz, "wrong dim2, res")

      pg :: VEC{REAL}(3)
      g,s,as,sa,ag,fg :: INT

      res = ZERO

      do g = 1,.crystal.spacegroup.n_seitz
      do s = 1,.n_shell

         ! Get transformed atom position
         as = .atom_for_shell(s)
         pg = .atom(as).position
         .crystal.transform_xyz_position(pg,g,to_unit_cell=TRUE)

         ! Get index of rotated atom by its position
         ag = .atom.atom_index_from_position(pg)

         ! Assign
         if (ag==0) then
            res(s,g) = 0
         else
            fg = .first_shell_for_atom(ag)
            sa = .atom_shell_for_shell(s)
            res(s,g) = fg + sa - 1
         end

      end
      end

   end


   stabilize(mat) ::: template, PURE
   ! Stabilize a matrix
      self :: IN
      mat :: MAT{TYPE?}, INOUT

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.allocated,"no atom list")
   ENSURE(.crystal.allocated, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,w :: MAT{TYPE?}@
      tra,trb :: MAT{REAL}@
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}@

      image.create(.n_shell,.crystal.n_stabilizer_symops)
      .BASE:make_image_of_stabilizer(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.crystal.n_stabilizer_symops

         do a = 1,.n_shell

            tra = .crystal.xyz_stabilizer_mx(n,.angular_moment_for_shell(a))

            i  = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb = .crystal.xyz_stabilizer_mx(n,.angular_moment_for_shell(b))

               j  = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               w.create(na,nb)
               w.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(w,trb,transpose_b=TRUE)
               w.destroy

            end

         end

      end

      mat = sym/REALIFY(.crystal.n_stabilizer_symops)

      sym.destroy
      image.destroy

   end

   stabilize(mat) ::: get_from(stabilize, TYPE?=>REAL), PURE
   ! Stabilize a matrix
   end

   stabilize(mat) ::: get_from(stabilize, TYPE?=>CPX), PURE
   ! Stabilize a matrix
   end

   make_image_of_stabilizer(res) ::: PURE
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! a crystal stabilizer operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      self :: IN
      res :: MAT{INT}, OUT

   ENSURE(.crystal.allocated, "no crystal")
   ENSURE(res.dim1==.n_shell,                    "wromg dim1, res")
   ENSURE(res.dim2==.crystal.n_stabilizer_symops,"wromg dim2, res")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.crystal.n_stabilizer_symops
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos = matmul(.crystal.ptr(:,:,n), .atom(aa).position)

         new_atom = .atom.atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end

end
