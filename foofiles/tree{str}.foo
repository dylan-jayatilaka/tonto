!===================================================================
!
! TREE{STR}
! Tree's labelled by STR vertices.
!
! Copyright (C) Dylan Jayatilaka, 2023
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!===================================================================

module TREE{STR}

   type TREE

      ids :: VEC{STR}@
      ! The array of vertex ID's for each vertex index

      parents :: VEC{INT}@
      ! The parent index of the vertex index

      levels :: VEC{INT}@
      ! The level of the vertex index

      is_leaf :: VEC{BIN}@
      ! Is TRUE if the vertex is a leat.

      children :: VEC{EVEC{INT}}@
      ! The child indices (EVEC) for a given vertex index (VEC)

   end

contains

! ==========
! Allocation
! ==========

   create ::: get_from(OBJECT), leaky, PURE
   ! Allocate an object
   end

   create(id) ::: leaky, PURE
   ! Allocate a TREE with root "id"
      self :: allocatable, OUT
      id   :: STR, IN

      .create

      .ids.create(1)
      .parents.create(1)
      .levels.create(1)
      .is_leaf.create(1)
      .children.create(1)

      ! Set up root node
      .ids(1)     = "root"
      .parents(1) = 0
      .is_leaf(1) = TRUE
      .levels(1)  = 0
      .children(1).elements.create(1)

   end

   destroy ::: get_from(OBJECT), leaky, PURE
   ! Deallocate "self"
   end

! ===========
! Set methods
! ===========

   attach_to(parent_id,child_id) ::: PURE
   ! Attach to "parent_id" the "child_id"
      self :: INOUT
      parent_id :: STR, IN
      child_id  :: STR, IN

   ENSURE(.is_defined,"no tree!")

   end

   attach_to(parent_id,tree)
   end

   attach_to_vertex(parent_ind,child_id) ::: PURE
   ! Attach to "parent_id" the "child_id"
      self :: INOUT
      parent_ind :: , IN
      child_id   :: STR, IN

   ENSURE(.is_defined,"no tree!")
   ENSURE(parent_ind.is_in_range[1,ids.dim],"parent_ind not in tree!")
   ENSURE(child_id/="root","root defined!")

      n,l,p :: INT

      ! Add vertex, store child index "n"
      .ids.append(child_id)
      n = .ids.dim

      ! Set leaf of child, not parent
      p = parent_id
      .is_leaf(p) = FALSE
      .is_leaf(n) = TRUE

      ! New level
      l = .levels(p)
      .levels.append(l+1)

      ! Children
      .children(p).elements.append(n)

   end

   set_defaults ::: leaky, PURE
   ! Set up a default diffraction_data object
      self :: INOUT

      .SET:destroy_reflection_data

      .data_kind              = DIFFRACTION_DATA_DATA_KIND

      ! Experimental data
      .wavelength             = -ONE
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      ! Data treatment options
      .F_sigma_cutoff         = DIFFRACTION_DATA_F_SIGMA_CUTOFF
      .I_sigma_cutoff         = DIFFRACTION_DATA_I_SIGMA_CUTOFF
      .F_z_cutoff             = -ONE
      .I_z_cutoff             = -ONE
      .F_calc_cutoff          = TOL(3)
      .F_pred_cutoff          = -ONE
      .I_pred_cutoff          = -ONE
      .stl_high_cutoff        = -ONE
      .stl_low_cutoff         = -ONE
      .stl_limit              = -ONE
      .show_rejects           = FALSE
      .synthesize_sigma_I     = DIFFRACTION_DATA_SYNTHESIZE_SIGMA_I
      .SF_mixing_parameter    = ZERO

      ! Structure factor calculation parameters
      .partition_model          = DIFFRACTION_DATA_PARTITION_MODEL
      .temperature_factor_model = DIFFRACTION_DATA_TEMPERATURE_FACTOR_MODEL
      .use_Voronoi_atoms        = FALSE
      .use_KM_atoms             = FALSE
      .use_IAM_density          = FALSE
      .use_IAM_ITC_FFs          = TRUE
      .use_zero_overlap         = FALSE

      ! Invarioms
      .invariom_database_directory = " "
      .invariom_refinement         = FALSE

      ! Experimental corrections
      .refine_scale           = TRUE
      .scale_factor           =  ONE
      .exp_scale_factor       = -ONE
      .refine_extinction      = FALSE
      .extinction_factor      = ZERO
      .add_dispersion_to_F_calc = FALSE
      .remove_dispersion_from_F_exp = FALSE

      ! Agreement statistics
      .n_param                  = 0
      .n_param_manually_set     = FALSE
      .chi2                     = ZERO
      .max_residual             = ZERO
      .min_residual             = ZERO
      .rms_residual             = ZERO
      .max_atom_residual        = ZERO
      .max_atom_residual_tag    = " "
      .min_atom_residual        = ZERO
      .min_atom_residual_tag    = " "
      .rms_atom_residual        = ZERO

      ! Refine/fit switches
      .fit_structure                = FALSE
      .refine_structure             = FALSE
      .refine_F                     = TRUE
      .refine_positions_only        = FALSE
      .refine_ADPs_only             = FALSE
      .refine_H_ADPs                = TRUE
      .refine_H_positions           = TRUE 
      .refine_H_U_iso               = FALSE
      .refine_anharmonicity         = FALSE
      .refine_4th_order_only        = FALSE
      .restart_HAR_with_promolecule = FALSE
      .XCW                          = FALSE

      ! Refine/fit iteration termination
      .max_iterations           = DIFFRACTION_DATA_MAX_ITER
      .min_iterations           = DIFFRACTION_DATA_MIN_ITER
      .max_allowed_param_shift  = DIFFRACTION_DATA_MAX_ALLOWED_SHIFT

      ! Least squares options (zero/near zero eigenvalues)
      .tol_for_shift_on_esd     = DIFFRACTION_DATA_TOL_FOR_SHIFT_ON_ESD
      .near_0_tol               = DIFFRACTION_DATA_TOL_NEAR_0

      ! Refinement/fit output control
      .show_fit_output          = FALSE
      .show_near_0_eigenvectors = FALSE
      .min_correlation          = DIFFRACTION_DATA_MIN_CORRELATION

      ! Set the internal variables for a refine/fit data
      .SET:destroy_fit_data
      .SET:set_fit_data

      .SET:destroy_refinement_data
      .SET:set_refinement_data

   end

   set_fit_data ::: pure
   ! Set the defaults internal variables for a fit
      self :: INOUT

      ! Refinement/fit iteration data
      .fit_iteration           = 0
      .chi2_fit                = ZERO
      .chi2_fit0               = ZERO
      .max_shift               = ZERO
      .max_esd                 = ZERO
      .max_shift_on_esd        = ZERO
      .max_shift_on_esd_ind    = 0
      .max_shift_on_esd_par    = " "
      .fit_finished            = FALSE ! <<<<
      .fit_converged           = FALSE
      .chi2_increased          = FALSE
      .too_many_fit_iterations = FALSE

      ! Near zero eigenvalues in the least-squares
      .n_0                     = 0
      .near_0                  = 0

   end


! =======
! Inquiry
! =======

   is_defined result (res) ::: pure
   ! Return whether anything is defined in the tree.
   ! It's assumed all the other arrays are made.
      self :: IN
      res  :: INT
      res = ids.allocated
   end

   n_of_vertices result (res) ::: pure
   ! Return the number of vertices
      self :: IN
      res  :: INT
      if (.is_defined) then
         res = .ids.dim
      else
         res = 0
      end
   end

   depth result (res) ::: PURE
   ! Return the number of vertices
      self :: IN
      res  :: INT
   ENSURE(.is_defined,"No tree!") 
      res = maxval(.levels)
   end

   has_vertex_with_id(id) result (res) ::: pure
   ! Returns TRUE if "id" appears in the graph.
      self :: IN
      res  :: BIN
      if (.ids.allocated) then
         res = .ids.contains(id)
      else
         res = FALSE
      end
   end

   index_of_vertex_with_id(id) result (res) ::: leaky, PURE
   ! Return the *index* of vertex "id" if it exists
      self :: INT
      id   :: STR, IN
      res  :: INT
   ENSURE(.has_vertex_with_id(id),"no vertex with id: "//trim(id))

      if (.ids.allocated) then
         res = .ids.index_of_valuec(id)
      else
         res = 0
      end

   end

   index_of_parent_of(id) result (res) ::: PURE
   ! Get the parent of vertex "id"
      self :: IN
      id   :: STR, IN
      res  :: INT
   ENSURE(.has_vertex_with_id(id),"no vertex with id: "//trim(id))

      ind,par :: INT


      ind = .index_of_vertex_with_id(id)
      res = .parents(ind)

   end

   indices_of_children_with_id(id) result (res) ::: PURE
   ! Get the *indices* of children of vertex "id"
   end

   children_with_id(id) result (res) ::: PURE
   ! Get the parent of vertex "id"
   end

   indices_of_vertices_with_level(level) result (res) ::: PURE
   ! Get the *indices* of vertices which have a certain "level"
   end

   vertices_with_level(level) result (res) ::: PURE
   ! Get the vertices which have a certain "level"
   end

   is_leaf(id)
   end

   indices_of_leaves result (res) ::: pure
   end

   link_past_node(self, nid):
   ! Delete a node by linking past it.
   ! For example, if we have `a -> b -> c` and delete node b, we are left
   ! with `a -> c`.

   move_vertex(id,new) ::: pure
   ! Move vertex "id" to "new" parent vertex.
   end


   is_child_of(ancestor,id) result (res)
   end

   indices_of_paths_to_leaves result (res)
   end

   remove_vertex(id)
   end

   subtree_at(id) result (res)
   end

   siblings_of(id)
   end

end
