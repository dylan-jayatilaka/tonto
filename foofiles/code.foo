
   get_unique_Hirshfeld_atom_SFs(ff_n,spin_density) ::: leaky
   ! Get "ff_n", the static structure factors for the symmetry related
   ! K points with *no* thermal smearing, for every unique atom.
   ! NOTE: "ff_n" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
      self :: INOUT
      ff_n :: MAT{CPX}*
      spin_density :: BIN, optional, IN

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.associated,"no atom list")
   ENSURE(.density_matrix.allocated, "no density matrix")
   ENSURE(.crystal.associated, "no crystal")
   ENSURE(.crystal.data.associated, "no reflection data")
   ENSURE(.crystal.xray_data.associated, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      overlapping_atom :: VEC{INT}*
      rc,ra, tr :: VEC{REAL}(3)
      pt,pt0 :: MAT{REAL}@
      wt,wt0, Wc  :: VEC{REAL}@
      xa,ya,za,a2 :: VEC{REAL}@
      rho, ga,gb  :: VEC{REAL}@
      pi,pj,pn    :: VEC{INT}@
      skipa0,skipab :: VEC{BIN}@
      skipa,skipb   :: VEC{BIN}@
      k_pts,grida,gridb :: MAT{REAL}@
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      ff :: CPX
      cutoff,sc,s2, k1,k2,k3,kr,kt, Dab, fac, val :: REAL
      n_atom,n_k,n_pt,n_keep :: INT
      u,c,ca,cb :: INT
      oa,fsa,lsa,fba  :: INT
      ob,fsb,lsb      :: INT
      sa,fa,la,na, as :: INT
      sb,fb,lb,nb     :: INT
      a,b,i,j,k,n,p   :: INT
      s,of :: INT
      spin :: BIN

      ! Make sure HA stuff is there
      .:make_Hirshfeld_inputs(skip_NOs=TRUE)

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      ff_n.create(n_k,n_atom)
      ff_n = ZERO

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.data.reflections.make_unique_SF_k_pts(k_pts,.crystal.spacegroup,.crystal.unit_cell)

      ! X-ray or PND?
      spin = FALSE
      if (present(spin_density)) spin = spin_density

      ! Density matrix (leaky)
      if (NOT spin) then; .BASE:make_ao_density_matrix
      else;               .BASE:make_ao_sz_density_matrix
      end
      ENSURE(.density_matrix.restricted.allocated, "no restricted DM")

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced numerical integration grid points 
      ! and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Loop over integration asymmetric/unique atoms "c"
      parallel do u = 1,.crystal.n_unique_frag_atoms

         c  = .crystal.unique_frag_atom(u)
         rc = .atom(c).position

         ! Repetition factor for this atom
         sc = .crystal.frag_atom_sym_factor(c)
         if (sc.is_zero) cycle

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Get the unsymmetrised  Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,c)
       ! .becke_grid.make_grid(pt0,wt0,bf_save,c)
         n_pt = pt.dim1

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms
         ! are used ... otherwise nothing is skipped
         Wc.create(n_pt)
         if (.use_interpolators) then
            .GRID:make_stockholder_atom_grid(Wc,c,pt,overlapping_atom)
         else
            .GRID:make_stockholder_atom_grid(Wc,c,pt)
         end

         ! Incorporate integration weight
         wt = Wc*wt
         Wc.destroy

         ! Prune the grid with new "wt", get saved bf grid bf_save,
         ! and new no of points, n_pt (leaky)
         .becke_grid.prune_grid(pt,wt)
       ! .becke_grid.prune_grid(pt,wt,bf_save)

         ! *New* points
         n_pt = pt.dim1
         !!!!!!!!!!!!!!

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff)

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff)

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element.create(skipa.dim)
               bf_skip(sa).element = skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
               sha.make_skip_grid(grida,n_keep,xa,ya,za,a2,skipa,n_pt)
               bf_grid(sa).element.create(n_keep,na)
               bf_grid(sa).element = grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.disassociated) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb = bf_skip(sb).element
                     gridb = bf_grid(sb).element

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga = grida(:,1)
                        gb = gridb(:,1)
                        Dab = fac*.density_matrix.restricted(fa,fb)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                        ga.destroy
                        gb.destroy

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep)
                        pj.create(n_keep)
                        pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0
                        i = 0
                        j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga = grida(:,a)
                           do b = 1,nb
                              gb = gridb(:,b)
                              Dab = fac*.density_matrix.restricted(fa+a-1,fb+b-1)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        ga.destroy
                        gb.destroy
                        pn.destroy
                        pj.destroy
                        pi.destroy

                     end

                     gridb.destroy
                     skipb.destroy

                  end
               end
            end
         end

         ! Weight the atom "c" density
         rho = rho*wt


         ! Generate site-symmetry equivalent grid points
         ! No. of pt's and wt's now are multiplied by no. of site symops
         .crystal.make_symmetry_equivalents_from(pt,pt0)
       ! s2 = ONE/(sc*.crystal.spacegroup.n_seitz)
         s2 = ONE/(sc)

         ! Make the (unique) structure factors
         ! Fourier transform, yay!
         do k = 1,n_k

            k1 = k_pts(k,1)
            k2 = k_pts(k,2)
            k3 = k_pts(k,3)

            ff = IMAGIFY(ZERO)
            of = 0

          ! do s = 1,.crystal.spacegroup.n_seitz
            do s = 1,1

               ! Translational part
               tr = 2*PI*.crystal.spacegroup.seitz(:,4,s)

               ! Integrate over grid pts
               do i = 1,n_pt  
                  kr = k1*pt0(of+i,1) + k2*pt0(of+i,2) + k3*pt0(of+i,3)
                  kt = k1*      tr(1) + k2*      tr(2) + k3*      tr(3)    
                  kr = kr + kt
                  ff = ff + rho(i)*exp(IMAGIFY(kr))
               end

               of = of + n_pt

            end

            ! Atomic form factor
            ff_n(k,u) = ff * s2 * .atom(c).site_occupancy

         end

         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         pt0.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(ff_n)
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      k_pts.destroy

   end
